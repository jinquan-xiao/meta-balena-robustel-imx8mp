From fcc0e639c2fda9d07238c0d7c09868b99483d40d Mon Sep 17 00:00:00 2001
From: machangbao <machangbao@rt.com>
Date: Tue, 5 Nov 2024 08:15:31 +0800
Subject: [PATCH] adapts to robustel eg5120 hardware

---
 .../devicetree/bindings/mmc/fsl-imx-esdhc.txt |     9 +
 Makefile                                      |     3 +
 arch/arm64/boot/dts/freescale/Makefile        |   124 +-
 .../boot/dts/freescale/imx8mp-eg5120.dts      |  1191 ++
 .../boot/dts/freescale/imx8mp-eg5120.dtsi     |  2445 ++++
 .../boot/dts/freescale/overlays/Makefile      |    15 +
 .../overlays/eg5120-if-can1-overlay.dts       |    17 +
 .../eg5120-if-uart1-rs232-overlay.dts         |    23 +
 .../eg5120-if-uart1-rs485-overlay.dts         |    25 +
 .../eg5120-if-uart3-rs232-overlay.dts         |    25 +
 .../eg5120-if-uart3-rs485-overlay.dts         |    27 +
 .../overlays/eg5120-kza-zaa-overlay.dts       |    65 +
 .../overlays/eg5120-wireless-lora-overlay.dts |    44 +
 .../eg5120-wireless-wifi5-overlay.dts         |    29 +
 arch/arm64/configs/imx8mp_eg5120_defconfig    |  6594 ++++++++++
 drivers/gpu/drm/bridge/synopsys/dw-hdmi.c     |     7 -
 drivers/gpu/drm/imx/dw_hdmi-imx.c             |     5 +-
 drivers/leds/Kconfig                          |    10 +
 drivers/leds/Makefile                         |     1 +
 drivers/leds/leds-gpio-2color.c               |   393 +
 drivers/mmc/host/sdhci-esdhc-imx.c            |    17 +-
 drivers/net/ethernet/freescale/fec_main.c     |     4 +
 .../net/ethernet/stmicro/stmmac/dwmac-imx.c   |    23 +
 drivers/net/phy/micrel.c                      |    60 +
 drivers/net/usb/qmi_wwan.c                    |     3 +-
 .../wireless/marvell/mwifiex/sta_cmdresp.c    |     2 +-
 .../wireless/nxp/mxm_wifiex/wlan_src/Makefile |   281 +-
 .../wireless/nxp/mxm_wifiex/wlan_src/README   |  1188 ++
 .../mapp_org/mapp/mlanconfig/Makefile         |    46 +
 .../config/ed_mac_ctrl_V1_8801.conf           |    15 +
 .../config/ed_mac_ctrl_V3_8987.conf           |    23 +
 .../config/ed_mac_ctrl_V3_8997.conf           |    23 +
 .../config/ed_mac_ctrl_V3_909x.conf           |    23 +
 .../config/txpwrlimit_cfg_8987.conf           |   537 +
 .../config/txpwrlimit_cfg_8997.conf           |   621 +
 .../config/txpwrlimit_cfg_9098.conf           |   617 +
 .../mapp/mlanconfig/config/wifi_mod_para.conf |   178 +
 .../wlan_src/mapp_org/mapp/mlanutl/Android.mk |    54 +
 .../wlan_src/mapp_org/mapp/mlanutl/Makefile   |    56 +
 .../wlan_src/mapp_org/mapp/mlanutl/mlanutl.c  |  5052 ++++++++
 .../wlan_src/mapp_org/mapp/mlanutl/mlanutl.h  |  1243 ++
 .../mxm_wifiex/wlan_src/mapp_org/script/load  |    16 +
 .../wlan_src/mapp_org/script/unload           |    22 +
 .../script/wifidirect/start_auto_go.sh        |    30 +
 .../script/wifidirect/start_find_phase.sh     |    25 +
 .../script/wifidirect/start_listen_state.sh   |    18 +
 .../script/wifidirect/stop_auto_go.sh         |     8 +
 .../wifidirect/stop_wifidirect_client.sh      |     6 +
 .../mapp_org/script/wifidirect/update_mac.sh  |    16 +
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan.h       |     2 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c  |   362 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h  |     8 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c  |   340 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h  |    21 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c   |   183 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c   |   778 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h   |    43 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c   |   183 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h   |    22 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c  |   119 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h  |     2 +-
 .../wlan_src/mlan/mlan_11n_rxreorder.c        |   123 +-
 .../wlan_src/mlan/mlan_11n_rxreorder.h        |     2 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c   |  1257 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c    |  2731 +++-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h  |  1037 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h    |  1499 ++-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h  |   398 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c  |   223 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h  |     2 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h |  1259 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c  |   579 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h  |     2 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h  |   724 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c  |     5 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h  |     2 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c  |  2678 +++-
 .../mxm_wifiex/wlan_src/mlan/mlan_module.c    |     5 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c  |   820 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h  |   167 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c  |  1072 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c  |  1105 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h  |   340 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c  |   371 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c   |  1483 ++-
 .../wlan_src/mlan/mlan_sta_cmdresp.c          |  1111 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_sta_event.c |   457 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c |   855 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c    |   538 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c    |    46 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c  |    98 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h   |     2 +-
 .../wlan_src/mlan/mlan_uap_cmdevent.c         |   746 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c |   338 +-
 .../mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c  |   233 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c   |   216 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h  |    26 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c   |   609 +-
 .../nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h   |    10 +-
 .../nxp/mxm_wifiex/wlan_src/mlinux/mlan.h     |     2 +-
 .../mxm_wifiex/wlan_src/mlinux/mlan_decl.h    |  1037 +-
 .../mxm_wifiex/wlan_src/mlinux/mlan_ieee.h    |   398 +-
 .../mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h   |  1259 +-
 .../wlan_src/mlinux/moal_cfg80211.c           |  1241 +-
 .../wlan_src/mlinux/moal_cfg80211.h           |   106 +-
 .../wlan_src/mlinux/moal_cfg80211_util.c      |  1928 ++-
 .../wlan_src/mlinux/moal_cfg80211_util.h      |   117 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_debug.c   |    79 +-
 .../wlan_src/mlinux/moal_eth_ioctl.c          | 10492 ++++++++++++----
 .../wlan_src/mlinux/moal_eth_ioctl.h          |   105 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_init.c    |   862 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_ioctl.c   |  2519 +++-
 .../mxm_wifiex/wlan_src/mlinux/moal_main.c    |  5761 +++++++--
 .../mxm_wifiex/wlan_src/mlinux/moal_main.h    |  1214 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_pcie.c    |   732 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_pcie.h    |    58 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_priv.c    |   685 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_priv.h    |   201 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_proc.c    |   673 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_sdio.h    |    53 +-
 .../wlan_src/mlinux/moal_sdio_mmc.c           |   862 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_shim.c    |  2305 +++-
 .../mxm_wifiex/wlan_src/mlinux/moal_shim.h    |   131 +-
 .../wlan_src/mlinux/moal_sta_cfg80211.c       |  3724 +++++-
 .../wlan_src/mlinux/moal_sta_cfg80211.h       |    12 +-
 .../nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c |   563 +-
 .../nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h |    74 +-
 .../wlan_src/mlinux/moal_uap_cfg80211.c       |  1166 +-
 .../wlan_src/mlinux/moal_uap_cfg80211.h       |     2 +-
 .../wlan_src/mlinux/moal_uap_priv.c           |    28 +-
 .../wlan_src/mlinux/moal_uap_priv.h           |    54 +-
 .../wlan_src/mlinux/moal_uap_wext.c           |    92 +-
 .../nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c |   353 +-
 .../nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h |    65 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_wext.c    |   542 +-
 .../mxm_wifiex/wlan_src/mlinux/moal_wext.h    |     2 +-
 .../nxp/mxm_wifiex/wlan_src/script/load       |    16 +
 .../nxp/mxm_wifiex/wlan_src/script/unload     |    22 +
 drivers/of/Kconfig                            |     7 +
 drivers/of/Makefile                           |     1 +
 drivers/of/configfs.c                         |   277 +
 drivers/of/overlay.c                          |     2 +
 drivers/of/resolver.c                         |     4 +-
 drivers/pci/controller/dwc/pci-imx6.c         |    32 +-
 .../pci/controller/dwc/pcie-designware-host.c |     6 +-
 drivers/pci/controller/dwc/pcie-designware.h  |     2 +-
 drivers/phy/freescale/phy-fsl-imx8-pcie.c     |     2 +
 drivers/phy/freescale/phy-fsl-samsung-hdmi.c  |   378 +-
 drivers/spi/spidev.c                          |     2 +
 drivers/usb/dwc3/dwc3-imx8mp.c                |    63 +
 drivers/usb/serial/option.c                   |   103 +
 drivers/usb/serial/qcserial.c                 |     2 +-
 drivers/usb/serial/usb_wwan.c                 |    13 +
 include/linux/platform_data/mmc-esdhc-imx.h   |     1 +
 net/bluetooth/hci_request.c                   |     6 +-
 net/ipv4/esp4_offload.c                       |     3 +
 net/wireless/Kconfig                          |     9 +-
 scripts/Makefile.dtbinst                      |     6 +-
 scripts/Makefile.lib                          |    12 +
 159 files changed, 74850 insertions(+), 12107 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-eg5120.dts
 create mode 100644 arch/arm64/boot/dts/freescale/imx8mp-eg5120.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/Makefile
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-if-can1-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs232-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs485-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs232-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs485-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-kza-zaa-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-lora-overlay.dts
 create mode 100644 arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-wifi5-overlay.dts
 create mode 100644 arch/arm64/configs/imx8mp_eg5120_defconfig
 create mode 100644 drivers/leds/leds-gpio-2color.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/Makefile
 create mode 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/README
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/Makefile
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V1_8801.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8987.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8997.conf
 create mode 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_909x.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8987.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8997.conf
 create mode 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_9098.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/wifi_mod_para.conf
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Android.mk
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Makefile
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.c
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.h
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/load
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/unload
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_auto_go.sh
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_find_phase.sh
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_listen_state.sh
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_auto_go.sh
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_wifidirect_client.sh
 create mode 100644 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/update_mac.sh
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_module.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmdresp.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_event.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_cmdevent.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_decl.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ieee.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_debug.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_init.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_ioctl.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_proc.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio_mmc.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_wext.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.c
 mode change 100644 => 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.h
 create mode 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/load
 create mode 100755 drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/unload
 create mode 100644 drivers/of/configfs.c

diff --git a/Documentation/devicetree/bindings/mmc/fsl-imx-esdhc.txt b/Documentation/devicetree/bindings/mmc/fsl-imx-esdhc.txt
index 0da89a7a6..d621d3954 100644
--- a/Documentation/devicetree/bindings/mmc/fsl-imx-esdhc.txt
+++ b/Documentation/devicetree/bindings/mmc/fsl-imx-esdhc.txt
@@ -53,6 +53,15 @@ Optional properties:
   of the CMD23's argument. SDMA mode will default disable the ACMD23 mode. SD card do
   not has this limitation on these SoCs.
 
+- fsl,sdio-interrupt-enabled:
+  description: |
+      Recommend for SDIO cards that enables SDIO interrupt for SDR104 and SDR50 operating
+      modes. SDIO interrupt uses DAT[1] to signal the card's interrupt to the i.MX
+      device. uSDHC tuning mechanism must use DAT[0] and CMD signals to avoid a possible
+      conflict and incorrect delay line calculated by the uSDHC auto tuning mechanism.
+      Enabling this device tree property is only recommended for layouts that are
+      matching the SD interface length.
+
 Examples:
 
 esdhc@70004000 {
diff --git a/Makefile b/Makefile
index e409fd909..2c987550e 100644
--- a/Makefile
+++ b/Makefile
@@ -1284,6 +1284,9 @@ endif
 
 endif
 
+%.dtbo: include/config/kernel.release scripts_dtc
+	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
+
 PHONY += scripts_dtc
 scripts_dtc: scripts_basic
 	$(Q)$(MAKE) $(build)=scripts/dtc
diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 27d3bbdc6..e91a5b0a7 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -48,118 +48,16 @@ dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-ls2088a-rdb.dtb
 dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-lx2160a-qds.dtb
 dtb-$(CONFIG_ARCH_LAYERSCAPE) += fsl-lx2160a-rdb.dtb
 
-dtb-$(CONFIG_ARCH_MXC) += imx8mm-evk.dtb imx8mm-evk-rpmsg.dtb imx8mm-evk-rm67191.dtb \
-			  imx8mm-ddr4-evk.dtb imx8mm-evk-root.dtb imx8mm-evk-inmate.dtb \
-			  imx8mm-ddr4-evk-rm67191.dtb imx8mm-evk-revb-qca-wifi.dtb imx8mm-ddr4-evk-revb.dtb \
-			  imx8mm-ddr4-evk-revb-rm67191.dtb imx8mm-ddr3l-val.dtb \
-			  imx8mm-evk-pcie-ep.dtb imx8mm-ddr4-evk-pcie-ep.dtb \
-			  imx8mm-evk-usd-wifi.dtb \
-			  imx8mm-evk-qca-wifi.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mm-evk-ak4497.dtb imx8mm-evk-ak5558.dtb imx8mm-evk-audio-tdm.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mm-evk-8mic-revE.dtb imx8mm-evk-8mic-swpdm.dtb \
-			  imx8mm-evk-iqaudio-dacplus.dtb imx8mm-evk-iqaudio-dacpro.dtb imx8mm-evk-hifiberry-dacplus.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mm-ab2.dtb imx8mm-ab2-m4.dtb imx8mm-ddr4-ab2.dtb imx8mm-ddr4-ab2-m4.dtb \
-			  imx8mm-ddr4-ab2-revb.dtb imx8mm-ddr4-ab2-m4-revb.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mn-evk.dtb imx8mn-evk-rm67191.dtb imx8mn-ddr4-evk.dtb imx8mn-ddr4-evk-ak5558.dtb \
-			  imx8mn-ddr4-evk-rm67191.dtb imx8mn-ddr4-evk-rpmsg.dtb imx8mn-ddr4-evk-usd-wifi.dtb \
-			  imx8mn-evk-ak5558.dtb imx8mn-evk-rpmsg.dtb imx8mn-evk-8mic-revE.dtb imx8mn-ddr3l-evk.dtb \
-			  imx8mn-ddr3l-evk-ak5558.dtb imx8mn-ddr3l-evk-rpmsg.dtb \
-			  imx8mn-evk-iqaudio-dacplus.dtb imx8mn-evk-iqaudio-dacpro.dtb imx8mn-evk-hifiberry-dacplus.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mn-ddr4-evk-root.dtb imx8mn-ddr4-evk-inmate.dtb imx8mn-evk-root.dtb imx8mn-evk-inmate.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mn-ab2.dtb imx8mn-ddr4-ab2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk.dtb imx8mp-evk-root.dtb imx8mp-evk-inmate.dtb imx8mp-evk-rpmsg.dtb \
-			  imx8mp-evk-rm67191.dtb imx8mp-evk-flexcan2.dtb imx8mp-evk-it6263-lvds-dual-channel.dtb \
-			  imx8mp-evk-jdi-wuxga-lvds-panel.dtb imx8mp-ab2.dtb imx8mp-evk-sof-wm8960.dtb \
-			  imx8mp-evk-dsp.dtb imx8mp-evk-ov2775.dtb imx8mp-evk-basler.dtb imx8mp-evk-pcie-ep.dtb \
-			  imx8mp-evk-spdif-lb.dtb imx8mp-evk-dsp-lpa.dtb imx8mp-evk-ov2775-ov5640.dtb \
-			  imx8mp-evk-basler-ov5640.dtb imx8mp-evk-dual-ov2775.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-ddr4-evk.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb imx8mq-evk-pcie1-m2.dtb imx8mq-evk-usd-wifi.dtb \
-			  imx8mq-evk-usdhc2-m2.dtb imx8mq-evk-pcie-ep.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-ak4497.dtb imx8mq-evk-audio-tdm.dtb imx8mq-evk-pdm.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-root.dtb imx8mq-evk-inmate.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-lcdif-rm67191.dtb imx8mq-evk-lcdif-adv7535.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-lcdif-rm67199.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-hummingboard-pulse.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-dcss-rm67191.dtb imx8mq-evk-dcss-adv7535.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-dcss-rm67199.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-dual-display.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-librem5-devkit.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-nitrogen.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-pico-pi.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-dp.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-zii-ultra-rmb3.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-zii-ultra-zest.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mq-ddr3l-val.dtb imx8mq-ddr4-val.dtb imx8mq-ddr4-val-gpmi-nand.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8qm-mek.dtb imx8qm-mek-ov5640.dtb \
-			  imx8qm-mek-enet2-tja1100.dtb imx8qm-mek-rpmsg.dtb \
-			  imx8qm-mek-hdmi.dtb imx8qm-mek-dsp.dtb \
-			  imx8qm-mek-jdi-wuxga-lvds1-panel.dtb \
-			  imx8qm-mek-jdi-wuxga-lvds1-panel-rpmsg.dtb \
-			  imx8qm-mek-usdhc3-m2.dtb imx8qm-mek-usd-wifi.dtb \
-			  imx8qm-lpddr4-val.dtb imx8qm-lpddr4-val-mqs.dtb \
-			  imx8qm-lpddr4-val-spdif.dtb imx8qm-mek-ca53.dtb \
-			  imx8qm-mek-ca72.dtb imx8qm-lpddr4-val-ca53.dtb \
-			  imx8qm-lpddr4-val-ca72.dtb imx8qm-ddr4-val.dtb \
-			  imx8qm-lpddr4-val-lpspi.dtb imx8qm-lpddr4-val-lpspi-slave.dtb \
-			  imx8qm-mek-dsi-rm67191.dtb imx8qm-lpddr4-val-dp.dtb\
-			  imx8qp-lpddr4-val.dtb imx8dm-lpddr4-val.dtb imx8qm-pcieax2pciebx1.dtb \
-			  imx8qm-mek-esai.dtb imx8qm-mek-vop.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8qm-mek-dom0.dtb imx8qm-mek-domu.dtb \
-			  imx8qm-mek-root.dtb imx8qm-mek-inmate.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8qxp-ai_ml.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8dxl-phantom-mek.dtb \
-			  imx8dxl-phantom-mek-rpmsg.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8qxp-mek.dtb imx8qxp-mek-dsp.dtb imx8qxp-mek-ov5640.dtb \
-			  imx8qxp-mek-enet2.dtb imx8qxp-mek-enet2-tja1100.dtb \
-			  imx8qxp-mek-sof-cs42888.dtb imx8qxp-mek-sof-wm8960.dtb \
-			  imx8qm-mek-sof-cs42888.dtb imx8qm-mek-sof-wm8960.dtb \
-			  imx8qxp-mek-rpmsg.dtb imx8qxp-mek-a0.dtb \
-			  imx8qxp-mek-it6263-lvds0-dual-channel.dtb \
-			  imx8qxp-mek-it6263-lvds1-dual-channel.dtb \
-			  imx8qxp-mek-it6263-lvds0-dual-channel-rpmsg.dtb \
-			  imx8qxp-mek-it6263-lvds1-dual-channel-rpmsg.dtb \
-			  imx8qxp-mek-jdi-wuxga-lvds0-panel.dtb \
-			  imx8qxp-mek-jdi-wuxga-lvds1-panel.dtb \
-			  imx8qxp-mek-jdi-wuxga-lvds0-panel-rpmsg.dtb \
-			  imx8qxp-mek-jdi-wuxga-lvds1-panel-rpmsg.dtb \
-			  imx8qxp-mek-dsi-rm67191.dtb \
-			  imx8qxp-mek-dsi-rm67191-rpmsg.dtb \
-			  imx8qxp-mek-dpu-lcdif.dtb \
-			  imx8qxp-mek-dpu-lcdif-rpmsg.dtb \
-			  imx8qxp-mek-ov5640-rpmsg.dtb \
-			  imx8qxp-mek-pcie-ep.dtb \
-			  imx8qm-mek-pcie-ep.dtb \
-			  imx8dx-mek.dtb imx8dx-mek-dsp.dtb imx8dx-mek-rpmsg.dtb \
-			  imx8dx-mek-enet2-tja1100.dtb \
-			  imx8dx-mek-ov5640.dtb \
-			  imx8dx-mek-ov5640-rpmsg.dtb \
-			  imx8dx-mek-it6263-lvds0-dual-channel.dtb \
-			  imx8dx-mek-it6263-lvds1-dual-channel.dtb \
-			  imx8dx-mek-it6263-lvds0-dual-channel-rpmsg.dtb \
-			  imx8dx-mek-it6263-lvds1-dual-channel-rpmsg.dtb \
-			  imx8dx-mek-jdi-wuxga-lvds0-panel.dtb \
-			  imx8dx-mek-jdi-wuxga-lvds1-panel.dtb \
-			  imx8dx-mek-jdi-wuxga-lvds0-panel-rpmsg.dtb \
-			  imx8dx-mek-jdi-wuxga-lvds1-panel-rpmsg.dtb \
-			  imx8dx-mek-dsi-rm67191.dtb \
-			  imx8dx-mek-dsi-rm67191-rpmsg.dtb \
-			  imx8qxp-mek-lcdif.dtb \
-			  imx8qxp-mek-lcdif-rpmsg.dtb \
-			  imx8qxp-lpddr4-val-a0.dtb \
-			  imx8qxp-lpddr4-val.dtb imx8qxp-lpddr4-val-mqs.dtb imx8qxp-ddr3l-val.dtb \
-			  imx8qxp-lpddr4-val-lpspi.dtb imx8qxp-lpddr4-val-lpspi-slave.dtb \
-			  imx8qxp-lpddr4-val-spdif.dtb imx8qxp-lpddr4-val-gpmi-nand.dtb imx8dxp-lpddr4-val.dtb \
-			  imx8qxp-17x17-val.dtb imx8dx-lpddr4-val.dtb imx8dx-17x17-val.dtb \
-			  imx8qxp-lpddr4-val-mlb.dtb imx8qxp-mek-vop.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8qxp-mek-dom0.dtb imx8qxp-mek-root.dtb \
-			  imx8qxp-mek-inmate.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8dxl-evk.dtb imx8dxl-evk-rpmsg.dtb \
-			  imx8dxl-evk-enet0.dtb imx8dxl-evk-enet0-tja1100.dtb \
-			  imx8dxl-evk-lpspi-slave.dtb \
-			  imx8dxl-evk-pcie-ep.dtb \
-			  imx8dxl-evk-lcdif.dtb \
-			  imx8dxl-ddr3-evk.dtb imx8dxl-ddr3-evk-rpmsg.dtb \
-			  imx8dxl-evk-root.dtb imx8dxl-evk-inmate.dtb
+dtb-$(CONFIG_ARCH_MXC) += imx8mp-eg5120.dtb
 dtb-$(CONFIG_ARCH_S32) += s32v234-evb.dtb \
 			  s32v234-sbc.dtb
+
+targets += dtbs dtbs_install
+targets += $(dtb-y)
+
+subdir-y       := overlays
+
+# Enable fixups to support overlays on IMX8MP platforms
+ifeq ($(CONFIG_ARCH_MXC),y)
+       DTC_FLAGS ?= -@
+endif
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dts b/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dts
new file mode 100644
index 000000000..de0ecf6f8
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dts
@@ -0,0 +1,1191 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/usb/pd.h>
+#include "imx8mp-eg5120.dtsi"
+
+/ {
+	model = "Robustel i.MX8MPlus EG5120 board";
+	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		rpmsg_reserved: rpmsg@0x55800000 {
+			no-map;
+			reg = <0 0x55800000 0 0x800000>;
+		};
+	};
+
+	chosen {
+		stdout-path = &uart2;
+	};
+	
+	
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_gpio_led>;
+
+		status {
+			label = "status";
+			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
+			default-state = "on"; /* LED GREEN */
+		};
+		
+		run {
+			label = "run";
+			gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+			default-state = "on";
+		};
+		
+		user {
+			label = "user";
+			gpios = <&gpio4 21 GPIO_ACTIVE_HIGH>;
+		};
+	};
+	
+	leds_2color {
+		compatible = "gpio-leds-2color";
+
+		modem {
+			label = "modem";
+
+			red-gpio = <&gpio4 22 GPIO_ACTIVE_HIGH>;
+			green-gpio = <&gpio4 26 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		rssi {
+			label = "rssi";
+
+			red-gpio = <&gpio4 24 GPIO_ACTIVE_HIGH>;
+			green-gpio = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+	};
+/*
+	reg_can1_stby: regulator-can1-stby {
+		compatible = "regulator-fixed";
+		regulator-name = "can1-stby";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_flexcan1_reg>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+*/
+
+/*	reg_can2_stby: regulator-can2-stby {
+		compatible = "regulator-fixed";
+		regulator-name = "can2-stby";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_flexcan2_reg>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+	};
+*/
+
+	reg_usb1_host_vbus: regulator-usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1_host_vbus";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usb1_vbus>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
+	};
+
+/*	reg_usdhc2_vmmc: regulator-usdhc2 {
+		compatible = "regulator-fixed";
+		regulator-name = "VSD_3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio2 0 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		startup-delay-us = <100>;
+		off-on-delay-us = <12000>;
+	}; 
+*/
+
+	sound-hdmi {
+		compatible = "fsl,imx-audio-cdnhdmi";
+		model = "audio-hdmi";
+		audio-cpu = <&aud2htx>;
+		hdmi-out;
+		constraint-rate = <44100>,
+				<88200>,
+				<176400>,
+				<32000>,
+				<48000>,
+				<96000>,
+				<192000>;
+		status = "disabled";
+	};
+
+	gpio_keys@5 {
+        	compatible = "gpio-keys";
+        	status = "okay";
+
+        	reset {
+            		label = "reset";
+            		gpios = <&gpio3 0 GPIO_ACTIVE_LOW>;
+            		linux,code = <0x198>;
+            		gpio-key,wakeup;
+        	};
+	};
+	
+	ext_watchdog: watchdog {
+        	compatible = "linux,wdt-gpio";
+        	gpios = <&gpio1 8 GPIO_ACTIVE_HIGH>;
+        	hw_algo = "level"; /*The TPL5010 recognizes avalid DONE signal as a low to high transition*/
+        	hw_margin_ms = <60000>;
+        	timeout-sec = <60>;
+    	};
+
+	usdhc1_pwrseq: usdhc1_pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		reset-gpios = <&gpio2 7 GPIO_ACTIVE_LOW>;
+		post-power-on-delay-ms = <400>;
+		power-off-delay-us = <40000>;
+	};
+};
+
+&snvs_rtc {
+	status = "disabled";
+};
+
+&aud2htx {
+	status = "okay";
+};
+
+&clk {
+	init-on-array = <IMX8MP_CLK_HSIO_ROOT>;
+};
+
+&A53_0 {
+	cpu-supply = <&buck2_reg>;
+};
+
+&pwm1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm1>;
+	status = "disabled";
+};
+
+&pwm2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm2>;
+	status = "disabled";
+};
+
+&pwm4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pwm4>;
+	status = "disabled";
+};
+
+&ecspi2 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	fsl,spi-num-chipselects = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_ecspi2 &pinctrl_ecspi2_cs>;
+	cs-gpios = <&gpio5 13 GPIO_ACTIVE_LOW>;
+	status = "disabled";
+
+};
+
+&eqos {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_eqos>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy0>;
+	snps,reset-gpios = <&gpio3 14 GPIO_ACTIVE_LOW>;
+	snps,reset-delays-us = <0 30000 200000>;
+	status = "disabled";
+
+	mdio {
+		compatible = "snps,dwmac-mdio";
+		pinctrl-0 = <&pinctrl_mdio>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+
+		ethphy0: ethernet-phy@3 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0x3>;
+			rxc-dll-2ns = <1>;
+			txc-dll-2ns = <1>;
+			eee-broken-100tx;
+			eee-broken-1000t;
+		};
+	};
+};
+
+&fec {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_fec>;
+	phy-mode = "rgmii-id";
+	phy-handle = <&ethphy1>;
+	phy-reset-gpios = <&gpio3 1 GPIO_ACTIVE_LOW>;
+	phy-reset-duration = <100>;
+	fsl,magic-packet;
+	fsl,magic-packet;
+	fsl,rgmii_rxc_dly;
+	fsl,rgmii_txc_dly;
+	status = "okay";
+
+	mdio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		ethphy1: ethernet-phy@7 {
+			compatible = "ethernet-phy-ieee802.3-c22";
+			reg = <0x7>;
+			rxc-dll-2ns = <1>;
+			txc-dll-2ns = <1>;
+			micrel,led-mode = <1>;
+		};
+	};
+};
+
+&i2c1 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c1>;
+	status = "okay";
+
+	pmic: pca9450@25 {
+		reg = <0x25>;
+		compatible = "nxp,pca9450";
+		/* PMIC PCA9450 PMIC_nINT GPIO1_IO3 */
+		pinctrl-0 = <&pinctrl_pmic>;
+		gpio_intr = <&gpio1 3 GPIO_ACTIVE_LOW>;
+
+		regulators {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			pca9450,pmic-buck2-uses-i2c-dvs;
+			/* Run/Standby voltage */
+			pca9450,pmic-buck2-dvs-voltage = <950000>, <850000>;
+
+			buck1_reg: regulator@0 {
+				reg = <0>;
+				regulator-compatible = "buck1";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck2_reg: regulator@1 {
+				reg = <1>;
+				regulator-compatible = "buck2";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <2187500>;
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-ramp-delay = <3125>;
+			};
+
+			buck4_reg: regulator@3 {
+				reg = <3>;
+				regulator-compatible = "buck4";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck5_reg: regulator@4 {
+				reg = <4>;
+				regulator-compatible = "buck5";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			buck6_reg: regulator@5 {
+				reg = <5>;
+				regulator-compatible = "buck6";
+				regulator-min-microvolt = <600000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo1_reg: regulator@6 {
+				reg = <6>;
+				regulator-compatible = "ldo1";
+				regulator-min-microvolt = <1600000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo2_reg: regulator@7 {
+				reg = <7>;
+				regulator-compatible = "ldo2";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <1150000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo3_reg: regulator@8 {
+				reg = <8>;
+				regulator-compatible = "ldo3";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo4_reg: regulator@9 {
+				reg = <9>;
+				regulator-compatible = "ldo4";
+				regulator-min-microvolt = <800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			ldo5_reg: regulator@10 {
+				reg = <10>;
+				regulator-compatible = "ldo5";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c2>;
+	status = "okay";
+	
+	at24_0@54 {
+        	compatible = "at24,24c04";
+        	pagesize = <16>;
+        	reg = <0x54>;
+    	};
+
+	at24_1@56 {
+        	compatible = "at24,24c04";
+        	pagesize = <16>;
+        	reg = <0x56>;
+    	};
+
+        pcf8563: rtc@51 {
+                compatible = "nxp,pcf8563";
+                reg = <0x51>;
+        };
+};
+
+/*
+&i2c3 {
+	clock-frequency = <100000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
+
+	pca6416: gpio@20 {
+		compatible = "ti,tca6416";
+		reg = <0x20>;
+		gpio-controller;
+		#gpio-cells = <2>;
+	};
+};
+*/
+
+&irqsteer_hdmi {
+	status = "disabled";
+};
+
+&flexcan1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan1>;
+	//xceiver-supply = <&reg_can1_stby>;
+	status = "disabled";
+};
+/*
+&flexcan2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_flexcan2>;
+	xceiver-supply = <&reg_can2_stby>;
+	pinctrl-assert-gpios = <&pca6416 3 GPIO_ACTIVE_HIGH>;
+	status = "disabled";
+};*/
+
+&hdmimix_clk {
+	status = "disabled";
+};
+
+&hdmimix_reset {
+	status = "disabled";
+};
+
+&hdmi_pavi {
+	status = "disabled";
+};
+
+&hdmi {
+	status = "disabled";
+};
+
+&hdmiphy {
+	status = "disabled";
+};
+
+&easrc {
+	fsl,asrc-rate  = <48000>;
+	status = "okay";
+};
+
+&micfil {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pdm>;
+	assigned-clocks = <&clk IMX8MP_CLK_PDM>;
+	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
+	assigned-clock-rates = <196608000>;
+	status = "disabled";
+};
+
+&pcie{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	//disable-gpio = <&gpio5 21 GPIO_ACTIVE_LOW>;
+	clkreq-gpio = <&gpio5 20 GPIO_ACTIVE_LOW>;
+	reset-gpio = <&gpio1 5 GPIO_ACTIVE_LOW>;
+	//reset-gpio-active-high;
+	ext_osc = <0>;
+	clocks = <&clk IMX8MP_CLK_HSIO_AXI_DIV>,
+		 <&clk IMX8MP_CLK_PCIE_AUX>,
+		 <&clk IMX8MP_CLK_PCIE_PHY>,
+		 <&clk IMX8MP_CLK_PCIE_ROOT>;
+	clock-names = "pcie", "pcie_aux", "pcie_phy", "pcie_bus";
+	assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI_SRC>,
+			  <&clk IMX8MP_CLK_PCIE_AUX>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+				 <&clk IMX8MP_SYS_PLL2_50M>;
+	status = "disabled";
+};
+
+&pcie_ep{
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_pcie>;
+	ext_osc = <1>;
+	clocks = <&clk IMX8MP_CLK_HSIO_AXI_DIV>,
+		 <&clk IMX8MP_CLK_PCIE_AUX>,
+		 <&clk IMX8MP_CLK_PCIE_PHY>,
+		 <&clk IMX8MP_CLK_PCIE_ROOT>;
+	clock-names = "pcie", "pcie_aux", "pcie_phy", "pcie_bus";
+	assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI_SRC>,
+			  <&clk IMX8MP_CLK_PCIE_AUX>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+				 <&clk IMX8MP_SYS_PLL2_50M>;
+	status = "disabled";
+};
+
+&pcie_phy{
+	ext_osc = <0>;
+	status = "okay";
+};
+
+&xcvr {
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&sdma2 {
+	status = "okay";
+};
+
+/*
+&uart1 { 
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart1>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts; 
+	status = "disabled";
+};*/
+
+&uart2 {
+	/* console */
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart2>;
+	status = "okay";
+};
+
+/*
+&uart3 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart3>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	fsl,uart-has-rtscts; 
+	fsl,dte-mode;
+	status = "disabled";
+};*/
+
+&uart4 { 
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
+	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+	status = "disabled";
+};
+
+&usb3_phy0 {
+	status = "okay";
+};
+
+&usb3_0 {
+	status = "okay";
+};
+
+&usb_dwc3_0 {
+	dr_mode = "host";
+	hnp-disable;
+	srp-disable;
+	adp-disable;
+	usb-role-switch;
+	status = "okay";
+
+};
+
+&usb3_phy1 {
+	status = "okay";
+};
+
+&usb3_1 {
+	status = "okay";
+};
+
+&usb_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usdhc1 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc1>, <&pinctrl_usdhc1_gpio>;
+	pinctrl-1 = <&pinctrl_usdhc1_100mhz>, <&pinctrl_usdhc1_gpio>;
+	pinctrl-2 = <&pinctrl_usdhc1_200mhz>, <&pinctrl_usdhc1_gpio>;
+	bus-width = <4>;
+	cd-gpios = <&gpio2 6 GPIO_ACTIVE_LOW>; 
+	mmc-pwrseq = <&usdhc1_pwrseq>; 
+	no-1-8-v;
+	status = "okay";
+};
+
+&usdhc2 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+//	pinctrl-0 = <&pinctrl_usdhc2>, <&pinctrl_usdhc2_gpio>;
+//	pinctrl-1 = <&pinctrl_usdhc2_100mhz>, <&pinctrl_usdhc2_gpio>;
+//	pinctrl-2 = <&pinctrl_usdhc2_200mhz>, <&pinctrl_usdhc2_gpio>;
+//	cd-gpios = <&gpio2 12 GPIO_ACTIVE_LOW>; 
+//	vmmc-supply = <&reg_usdhc2_vmmc>;
+	pinctrl-0 = <&pinctrl_usdhc2>;
+	pinctrl-1 = <&pinctrl_usdhc2_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc2_200mhz>;
+	bus-width = <4>;
+	pinctrl-assert-gpios = <&gpio1 4 GPIO_ACTIVE_HIGH>; /*fix NVCC_SD2 to always 1v8*/
+	status = "disabled";
+};
+
+&usdhc3 {
+	pinctrl-names = "default", "state_100mhz", "state_200mhz";
+	pinctrl-0 = <&pinctrl_usdhc3>;
+	pinctrl-1 = <&pinctrl_usdhc3_100mhz>;
+	pinctrl-2 = <&pinctrl_usdhc3_200mhz>;
+	bus-width = <8>;
+	non-removable;
+	status = "okay";
+};
+
+&wdog1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_wdog>;
+	fsl,ext-reset-output;
+	status = "okay";
+};
+
+&iomuxc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_misc &pinctrl_hog>;
+
+	pinctrl_misc: miscgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_ALE__GPIO3_IO00 	0x19 /* EXT_RST */
+			MX8MP_IOMUXC_SAI5_RXFS__GPIO3_IO19 	0x19 /* TAMPER0 */
+			MX8MP_IOMUXC_SAI5_RXC__GPIO3_IO20 	0x19 /* TAMPER1 */
+			MX8MP_IOMUXC_SAI5_RXD0__GPIO3_IO21 	0x19 /* TYPE0_M2.COM */
+			MX8MP_IOMUXC_SAI5_RXD1__GPIO3_IO22 	0x19 /* TYPE1_M2.COM */
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23 	0x19 /* TYPE2_M2.COM */
+			MX8MP_IOMUXC_SAI5_RXD3__GPIO3_IO24 	0x19 /* TYPE3_M2.COM */
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05  0x19 /* SIM_SEL */ 
+			MX8MP_IOMUXC_SAI2_RXD0__GPIO4_IO23 	0x19 /* GPIO_EXT_1 (M.2 5V_EN) */ 
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28 	0x19 /* GPIO_EXT_2 (LORA_RESET) */ 
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29 	0x19 /* GPIO_EXT_3 (WIFI_PowerDown/LORA_PPS) */ 
+			MX8MP_IOMUXC_I2C3_SCL__GPIO5_IO18 	0x19 /* GPIO5_IO18 */ 
+			MX8MP_IOMUXC_I2C3_SDA__GPIO5_IO19 	0x19 /* GPIO5_IO19 */
+
+                        MX8MP_IOMUXC_SAI3_TXD__GPIO5_IO01       0x19 /* UART1_SEL_DAT */
+                        MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28      0x19 /* UART1_SEL_CLK */
+                        MX8MP_IOMUXC_SAI3_TXC__GPIO5_IO00 	0x19 /* UART3_SEL_DAT */
+                        MX8MP_IOMUXC_SAI3_MCLK__GPIO5_IO02      0x19 /* UART3_SEL_CLK */
+		>;
+	};
+
+	pinctrl_hog: hoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c3
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c3
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000019
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000019
+		>;
+	};
+
+	pinctrl_pwm1: pwm1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO01__PWM1_OUT	0x116
+		>;
+	};
+
+	pinctrl_pwm2: pwm2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
+		>;
+	};
+
+	pinctrl_pwm4: pwm4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXFS__PWM4_OUT	0x116
+		>;
+	};
+
+	pinctrl_ecspi1: ecspi1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI1_SCLK__ECSPI1_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI1_MOSI__ECSPI1_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI1_MISO__ECSPI1_MISO		0x82
+			MX8MP_IOMUXC_ECSPI1_SS0__GPIO5_IO09		0x19 /* CS0 */
+			/*MX8MP_IOMUXC_I2C3_SCL__GPIO5_IO18     	0x19*/ /* CS1 */
+		>;
+	};
+	
+	pinctrl_ecspi2: ecspi2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
+		>;
+	};
+
+	pinctrl_ecspi2_cs: ecspi2cs {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
+		>;
+	};
+	
+	pinctrl_a2aaz_dido:di_do {
+		fsl,pins = <
+			MX8MP_IOMUXC_ECSPI2_SCLK__GPIO5_IO10		0x19   //di 1
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x19	//di 2
+			MX8MP_IOMUXC_ECSPI2_MOSI__GPIO5_IO11		0x19	//do 1	
+			MX8MP_IOMUXC_ECSPI2_MISO__GPIO5_IO12		0x19	//do 2
+		>;
+	};
+
+	pinctrl_eqos: eqosgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC	0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO	0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0	0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1	0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2	0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3	0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+		>;
+	};
+	
+	pinctrl_mdio: mdiogrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DQS__GPIO3_IO14		0x19
+		>;
+	};
+
+	pinctrl_fec: fecgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			MX8MP_IOMUXC_NAND_CE0_B__GPIO3_IO01		0x19
+		>;
+	};
+
+	pinctrl_flexcan1: flexcan1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX          0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX          0x154
+		>;
+	};
+
+/*	pinctrl_flexcan2: flexcan2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_MCLK__CAN2_RX		0x154
+			MX8MP_IOMUXC_SAI5_RXD3__CAN2_TX		0x154
+		>;
+	};
+*/
+/*
+	pinctrl_flexcan1_reg: flexcan1reggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05	0x154	// CAN1_STBY
+		>;
+	};
+*/
+/*	pinctrl_flexcan2_reg: flexcan2reggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27	0x154
+		>;
+	}; */
+
+	pinctrl_flexspi0: flexspi0grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_ALE__FLEXSPI_A_SCLK		0x1c2
+		/*	MX8MP_IOMUXC_NAND_CE0_B__FLEXSPI_A_SS0_B	0x82  */
+			MX8MP_IOMUXC_NAND_DATA00__FLEXSPI_A_DATA00	0x82
+			MX8MP_IOMUXC_NAND_DATA01__FLEXSPI_A_DATA01	0x82
+			MX8MP_IOMUXC_NAND_DATA02__FLEXSPI_A_DATA02	0x82
+			MX8MP_IOMUXC_NAND_DATA03__FLEXSPI_A_DATA03	0x82
+		>;
+	};
+
+	pinctrl_gpio_led: gpioledgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_READY_B__GPIO3_IO16	0x19
+			MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25		0x19
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27		0x19
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22 		0x19
+			MX8MP_IOMUXC_SAI2_TXFS__GPIO4_IO24		0x19
+			MX8MP_IOMUXC_SAI2_RXFS__GPIO4_IO21		0x19
+			MX8MP_IOMUXC_SAI2_TXD0__GPIO4_IO26		0x19
+			
+		>;
+	};
+	
+/*	pinctrl_gpio_dido:gpiodidogrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXFS__GPIO4_IO31  0x19
+			MX8MP_IOMUXC_SAI3_TXC__GPIO5_IO00   0x19
+			MX8MP_IOMUXC_SAI3_TXD__GPIO5_IO01	0x19
+			MX8MP_IOMUXC_SAI3_MCLK__GPIO5_IO02	0x19
+		>;
+	}; */
+
+	pinctrl_i2c1: i2c1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C1_SCL__I2C1_SCL		0x400001c3
+			MX8MP_IOMUXC_I2C1_SDA__I2C1_SDA		0x400001c3
+		>;
+	};
+
+	pinctrl_i2c2: i2c2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C2_SCL__I2C2_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C2_SDA__I2C2_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_i2c3: i2c3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C3_SCL__I2C3_SCL			0x400001c3
+			MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA			0x400001c3
+		>;
+	};
+
+	pinctrl_mipi_dsi_en: mipi_dsi_en {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO08__GPIO1_IO08	0x16
+		>;
+	};
+
+	pinctrl_pcie: pciegrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_I2C4_SCL__PCIE_CLKREQ_B		0x61 /* open drain, pull up */
+			MX8MP_IOMUXC_I2C4_SDA__GPIO5_IO21			0x41
+			//MX8MP_IOMUXC_GPIO1_IO00__GPIO1_IO00		0x41
+			MX8MP_IOMUXC_GPIO1_IO05__GPIO1_IO05		0x41
+			//MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06     0x41
+		>;
+	};
+
+	pinctrl_pmic: pmicirq {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x41
+		>;
+	};
+
+	pinctrl_typec: typec1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10	0x41
+		/*	MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4 */
+		>;
+	};
+
+	pinctrl_typec_mux: typec1muxgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x16
+		>;
+	};
+
+	pinctrl_pdm: pdmgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI5_RXC__AUDIOMIX_PDM_CLK			0xd6
+			MX8MP_IOMUXC_SAI5_RXD0__AUDIOMIX_PDM_BIT_STREAM00	0xd6
+			MX8MP_IOMUXC_SAI5_RXD1__AUDIOMIX_PDM_BIT_STREAM01	0xd6
+			MX8MP_IOMUXC_SAI5_RXD2__AUDIOMIX_PDM_BIT_STREAM02	0xd6
+			MX8MP_IOMUXC_SAI5_RXD3__AUDIOMIX_PDM_BIT_STREAM03	0xd6
+		>;
+	};
+
+/*	pinctrl_sai2: sai2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI2_TXC__AUDIOMIX_SAI2_TX_BCLK	0xd6
+			MX8MP_IOMUXC_SAI2_TXFS__AUDIOMIX_SAI2_TX_SYNC	0xd6
+			MX8MP_IOMUXC_SAI2_TXD0__AUDIOMIX_SAI2_TX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI2_RXD0__AUDIOMIX_SAI2_RX_DATA00	0xd6
+		>;
+	}; */
+	
+	pinctrl_sai2: sai2grp {
+		fsl,pins = <
+		/*	MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25	0x19 */
+			MX8MP_IOMUXC_SAI3_TXFS__GPIO4_IO31	0x19
+			MX8MP_IOMUXC_SAI3_TXC__GPIO5_IO00   0x19
+			MX8MP_IOMUXC_SAI3_TXD__GPIO5_IO01   0x19
+			MX8MP_IOMUXC_SAI3_MCLK__GPIO5_IO02  0x19
+		>;
+	}; 
+
+	pinctrl_sai3: sai3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC	0xd6
+			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK	0xd6
+			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK	0xd6
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28		0xd6
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29		0xd6
+		>;
+	};
+
+	pinctrl_i2c2_synaptics_dsx_io: synaptics_dsx_iogrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO09__GPIO1_IO09		0x16
+		>;
+	};
+
+	pinctrl_uart1: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+			MX8MP_IOMUXC_UART3_RXD__UART1_DCE_CTS	0x140
+			MX8MP_IOMUXC_UART3_TXD__UART1_DCE_RTS	0x140 
+		>;
+	};
+	
+	pinctrl_uart1_rs232: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+		>;
+	};
+
+	pinctrl_uart1_rs485: uart1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART1_RXD__UART1_DCE_RX	0x140
+			MX8MP_IOMUXC_UART1_TXD__UART1_DCE_TX	0x140
+			MX8MP_IOMUXC_UART3_TXD__GPIO5_IO27 0x140
+		>;
+	};
+
+	pinctrl_uart2: uart2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x49
+			MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x49
+		>;
+	};
+
+	pinctrl_uart3: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA6__UART3_DTE_RX		0x140
+			MX8MP_IOMUXC_SD1_DATA7__UART3_DTE_TX		0x140
+			MX8MP_IOMUXC_SD1_RESET_B__UART3_DTE_CTS		0x140
+			MX8MP_IOMUXC_SD1_STROBE__UART3_DTE_RTS		0x140  
+		>;
+	};
+	
+	pinctrl_uart3_rs232: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA6__UART3_DTE_RX		0x140
+			MX8MP_IOMUXC_SD1_DATA7__UART3_DTE_TX		0x140
+		>;
+	};
+	
+	pinctrl_uart3_rs485: uart3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA6__UART3_DTE_RX		0x140
+			MX8MP_IOMUXC_SD1_DATA7__UART3_DTE_TX		0x140
+			MX8MP_IOMUXC_SD1_STROBE__GPIO2_IO11		0x140  
+		>;
+	};
+	
+	pinctrl_uart4: uart4grp {
+        	fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__UART4_DCE_RX    0x49
+			MX8MP_IOMUXC_UART4_TXD__UART4_DCE_TX    0x49
+        	>;
+	};
+
+	pinctrl_uart4_hfc: uart4grp {
+        	fsl,pins = <
+			MX8MP_IOMUXC_UART4_RXD__UART4_DCE_RX    0x49
+			MX8MP_IOMUXC_UART4_TXD__UART4_DCE_TX    0x49
+			MX8MP_IOMUXC_NAND_DATA02__UART4_DTE_RTS 0x49
+			MX8MP_IOMUXC_NAND_DATA03__UART4_DTE_CTS 0x49
+        	>;
+	};
+
+	pinctrl_usb1_vbus: usb1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO14__GPIO1_IO14	0x19
+		>;
+	};
+
+	pinctrl_usdhc1_gpio: usdhc1grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06 	0x1c4 /* TF Card Detect */
+			MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07	0x41  /* TF PWR_EN */
+		>;
+	};
+
+	pinctrl_usdhc1: usdhc1grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK	0x190
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d0
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0	0x1d0
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d0
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d0
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d0
+		>;
+	};
+
+	pinctrl_usdhc1_100mhz: usdhc1grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK	0x194
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d4
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0	0x1d4
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d4
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d4
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d4
+		>;
+	};
+
+	pinctrl_usdhc1_200mhz: usdhc1grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_CLK__USDHC1_CLK	0x196
+			MX8MP_IOMUXC_SD1_CMD__USDHC1_CMD	0x1d6
+			MX8MP_IOMUXC_SD1_DATA0__USDHC1_DATA0	0x1d6
+			MX8MP_IOMUXC_SD1_DATA1__USDHC1_DATA1	0x1d6
+			MX8MP_IOMUXC_SD1_DATA2__USDHC1_DATA2	0x1d6
+			MX8MP_IOMUXC_SD1_DATA3__USDHC1_DATA3	0x1d6
+		>;
+	};
+
+	pinctrl_usdhc2_gpio: usdhc2grp-gpio {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CD_B__GPIO2_IO12 	0x1c4
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
+			MX8MP_IOMUXC_SD1_CLK__GPIO2_IO00 	0x41
+		>;
+	};
+
+	pinctrl_usdhc2: usdhc2grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d0
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
+			/*MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1*/
+			MX8MP_IOMUXC_GPIO1_IO04__GPIO1_IO04 	0x41
+		>;
+	};
+
+	pinctrl_usdhc2_100mhz: usdhc2grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x194
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d4
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
+			/*MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1*/
+			MX8MP_IOMUXC_GPIO1_IO04__GPIO1_IO04 	0x41
+		>;
+	};
+
+	pinctrl_usdhc2_200mhz: usdhc2grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x196
+			MX8MP_IOMUXC_SD2_CMD__USDHC2_CMD	0x1d6
+			MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
+			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
+			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
+			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
+			/*MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1*/
+			MX8MP_IOMUXC_GPIO1_IO04__GPIO1_IO04 	0x41
+		>;
+	};
+
+	pinctrl_usdhc3: usdhc3grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x190
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d0
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d0
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d0
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d0
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d0
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d0
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d0
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d0
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d0
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x190
+		>;
+	};
+
+	pinctrl_usdhc3_100mhz: usdhc3grp-100mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x194
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d4
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d4
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d4
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d4
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d4
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d4
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d4
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d4
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d4
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x194
+		>;
+	};
+
+	pinctrl_usdhc3_200mhz: usdhc3grp-200mhz {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_WE_B__USDHC3_CLK	0x196
+			MX8MP_IOMUXC_NAND_WP_B__USDHC3_CMD	0x1d6
+			MX8MP_IOMUXC_NAND_DATA04__USDHC3_DATA0	0x1d6
+			MX8MP_IOMUXC_NAND_DATA05__USDHC3_DATA1	0x1d6
+			MX8MP_IOMUXC_NAND_DATA06__USDHC3_DATA2	0x1d6
+			MX8MP_IOMUXC_NAND_DATA07__USDHC3_DATA3	0x1d6
+			MX8MP_IOMUXC_NAND_RE_B__USDHC3_DATA4	0x1d6
+			MX8MP_IOMUXC_NAND_CE2_B__USDHC3_DATA5	0x1d6
+			MX8MP_IOMUXC_NAND_CE3_B__USDHC3_DATA6	0x1d6
+			MX8MP_IOMUXC_NAND_CLE__USDHC3_DATA7	0x1d6
+			MX8MP_IOMUXC_NAND_CE1_B__USDHC3_STROBE	0x196
+		>;
+	};
+
+	pinctrl_wdog: wdoggrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0xc6
+		>;
+	};
+
+	pinctrl_csi0_pwn: csi0_pwn_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD1_STROBE__GPIO2_IO11	0x19
+		>;
+	};
+
+	pinctrl_csi0_rst: csi0_rst_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x19
+		>;
+	};
+
+	pinctrl_csi_mclk: csi_mclk_grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_GPIO1_IO15__CCM_CLKO2	0x59
+		>;
+	};
+};
+
+&vpu_g1 {
+	status = "okay";
+};
+
+&vpu_g2 {
+	status = "okay";
+};
+
+&vpu_vc8000e {
+	status = "okay";
+};
+
+&gpu_3d {
+	status = "okay";
+};
+
+&gpu_2d {
+	status = "okay";
+};
+
+&ml_vipsi {
+	status = "okay";
+};
+
+&mix_gpu_ml {
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dtsi b/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dtsi
new file mode 100644
index 000000000..d206db087
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/imx8mp-eg5120.dtsi
@@ -0,0 +1,2445 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright 2019 NXP
+ */
+
+#include <dt-bindings/clock/imx8mp-clock.h>
+#include <dt-bindings/reset/imx8mq-reset.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/thermal/thermal.h>
+#include <dt-bindings/reset/imx8mp-mediamix.h>
+#include <dt-bindings/reset/imx-hdmimix-reset.h>
+#include "imx8mp-pinfunc.h"
+
+/ {
+	compatible = "fsl,imx8mp";
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	aliases {
+		ethernet0 = &fec;
+		ethernet1 = &eqos;
+		serial0 = &uart1;
+		serial1 = &uart2;
+		serial2 = &uart3;
+		serial3 = &uart4;
+		gpio0 = &gpio1;
+		gpio1 = &gpio2;
+		gpio2 = &gpio3;
+		gpio3 = &gpio4;
+		gpio4 = &gpio5;
+		mmc0 = &usdhc1;
+		mmc1 = &usdhc2;
+		mmc2 = &usdhc3;
+		isi0 = &isi_0;
+		isi1 = &isi_1;
+		csi0 = &mipi_csi_0;
+		csi1 = &mipi_csi_1;
+		isp0 = &isp_0;
+		isp1 = &isp_1;
+	};
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		idle-states {
+			entry-method = "psci";
+
+			cpu_pd_wait: cpu-pd-wait {
+				compatible = "arm,idle-state";
+				arm,psci-suspend-param = <0x0010033>;
+				local-timer-stop;
+				entry-latency-us = <1000>;
+				exit-latency-us = <700>;
+				min-residency-us = <2700>;
+				wakeup-latency-us = <1500>;
+			};
+		};
+
+		A53_0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x0>;
+			clock-latency = <61036>; /* two CLK32 periods */
+			next-level-cache = <&A53_L2>;
+			clocks = <&clk IMX8MP_CLK_ARM>;
+			operating-points-v2 = <&a53_opp_table>;
+			enable-method = "psci";
+			nvmem-cells = <&cpu_speed_grade>;
+			nvmem-cell-names = "speed_grade";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+		};
+
+		A53_1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x1>;
+			clock-latency = <61036>; /* two CLK32 periods */
+			next-level-cache = <&A53_L2>;
+			clocks = <&clk IMX8MP_CLK_ARM>;
+			operating-points-v2 = <&a53_opp_table>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+		};
+
+		A53_2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x2>;
+			clock-latency = <61036>; /* two CLK32 periods */
+			next-level-cache = <&A53_L2>;
+			clocks = <&clk IMX8MP_CLK_ARM>;
+			operating-points-v2 = <&a53_opp_table>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+		};
+
+		A53_3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a53";
+			reg = <0x3>;
+			clock-latency = <61036>; /* two CLK32 periods */
+			next-level-cache = <&A53_L2>;
+			clocks = <&clk IMX8MP_CLK_ARM>;
+			operating-points-v2 = <&a53_opp_table>;
+			enable-method = "psci";
+			#cooling-cells = <2>;
+			cpu-idle-states = <&cpu_pd_wait>;
+		};
+
+		A53_L2: l2-cache0 {
+			compatible = "cache";
+		};
+	};
+
+	a53_opp_table: opp-table {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <850000>;
+			opp-supported-hw = <0x8a0>, <0x7>;
+			clock-latency-ns = <150000>;
+			opp-suspend;
+		};
+
+		opp-1600000000 {
+			opp-hz = /bits/ 64 <1600000000>;
+			opp-microvolt = <950000>;
+			opp-supported-hw = <0xa0>, <0x7>;
+			clock-latency-ns = <150000>;
+			opp-suspend;
+		};
+
+		opp-1800000000 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <1000000>;
+			opp-supported-hw = <0x20>, <0x3>;
+			clock-latency-ns = <150000>;
+			opp-suspend;
+		};
+	};
+
+	ddr_pmu0: ddr_pmu@3d800000 {
+		compatible = "fsl,imx8mp-ddr-pmu", "fsl,imx8m-ddr-pmu";
+		reg = <0x0 0x3d800000 0x0 0x400000>;
+		interrupts = <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	edacmc: memory-controller@3d400000 {
+		compatible = "fsl,imx8mp-ddrc";
+		reg = <0x0 0x3d400000 0x0 0x400000>;
+		interrupts = <GIC_SPI 147 IRQ_TYPE_LEVEL_HIGH>;
+	};
+
+	gic: interrupt-controller@38800000 {
+		compatible = "arm,gic-v3";
+		reg = <0x0 0x38800000 0 0x10000>, /* GIC Dist */
+		      <0x0 0x38880000 0 0xC0000>; /* GICR (RD_base + SGI_base) */
+		#interrupt-cells = <3>;
+		interrupt-controller;
+		interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-parent = <&gic>;
+	};
+
+	memory@40000000 {
+		device_type = "memory";
+		reg = <0x0 0x40000000 0 0x80000000>;
+	};
+
+	resmem: reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		ocram: ocram@900000 {
+			no-map;
+			reg = <0 0x900000 0 0x70000>;
+		};
+
+/*
+ *		Memory reserved for optee usage. Please do not use.
+ *		This will be automaticky added to dtb if OP-TEE is installed.
+ *		optee@56000000 {
+ *   			reg = <0 0x56000000 0 0x2000000>;
+ *			no-map;
+ *		};
+ */
+		/* global autoconfigured region for contiguous allocations */
+		linux,cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			size = <0 0x8000000>;
+			alloc-ranges = <0 0x40000000 0 0xC0000000>;
+			linux,cma-default;
+		};
+
+		dsp_reserved: dsp@92400000 {
+			no-map;
+			reg = <0 0x92400000 0 0x2000000>;
+		};
+	};
+
+	osc_32k: clock-osc-32k {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "osc_32k";
+	};
+
+	osc_24m: clock-osc-24m {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+		clock-output-names = "osc_24m";
+	};
+
+	clk_ext1: clock-ext1 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <133000000>;
+		clock-output-names = "clk_ext1";
+	};
+
+	clk_ext2: clock-ext2 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <133000000>;
+		clock-output-names = "clk_ext2";
+	};
+
+	clk_ext3: clock-ext3 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <133000000>;
+		clock-output-names = "clk_ext3";
+	};
+
+	clk_ext4: clock-ext4 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency= <133000000>;
+		clock-output-names = "clk_ext4";
+	};
+
+	busfreq { /* BUSFREQ */
+		compatible = "fsl,imx_busfreq";
+		clocks = <&clk IMX8MP_DRAM_PLL_OUT>, <&clk IMX8MP_CLK_DRAM_ALT>,
+			 <&clk IMX8MP_CLK_DRAM_APB>, <&clk IMX8MP_CLK_DRAM_APB>,
+			 <&clk IMX8MP_CLK_DRAM_CORE>, <&clk IMX8MP_CLK_DRAM_ALT_ROOT>,
+			 <&clk IMX8MP_SYS_PLL1_40M>, <&clk IMX8MP_SYS_PLL1_100M>,
+			 <&clk IMX8MP_SYS_PLL2_333M>, <&clk IMX8MP_CLK_NOC>,
+			 <&clk IMX8MP_CLK_AHB>, <&clk IMX8MP_CLK_MAIN_AXI>,
+			 <&clk IMX8MP_CLK_24M>, <&clk IMX8MP_SYS_PLL1_800M>,
+			 <&clk IMX8MP_DRAM_PLL>;
+		clock-names = "dram_pll", "dram_alt_src", "dram_apb_src", "dram_apb_pre_div",
+			      "dram_core", "dram_alt_root", "sys_pll1_40m", "sys_pll1_100m",
+			      "sys_pll2_333m", "noc_div", "ahb_div", "main_axi_src", "osc_24m",
+			      "sys_pll1_800m", "dram_pll_div";
+	};
+
+	power-domains {
+		compatible = "simple-bus";
+
+		/* HSIO SS */
+		hsiomix_pd: hsiomix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			active-wakeup;
+			rpm-always-on;
+			#power-domain-cells = <0>;
+			domain-index = <0>;
+			domain-name = "hsiomix";
+		};
+
+		pcie_pd: pcie-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <1>;
+			domain-name = "pcie";
+			parent-domains = <&hsiomix_pd>;
+		};
+
+		usb_otg1_pd: usbotg1-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <2>;
+			domain-name = "usb_otg1";
+			parent-domains = <&hsiomix_pd>;
+		};
+
+
+		usb_otg2_pd: usbotg2-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <3>;
+			domain-name = "usb_otg2";
+			parent-domains = <&hsiomix_pd>;
+		};
+
+		/* MLMIX */
+		mlmix_pd: mlmix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <4>;
+			domain-name = "mlmix";
+			clocks = <&clk IMX8MP_CLK_ML_AXI>,
+				 <&clk IMX8MP_CLK_ML_AHB>,
+				 <&clk IMX8MP_CLK_NPU_ROOT>;
+		};
+
+		audiomix_pd: audiomix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <5>;
+			domain-name = "audiomix";
+			clocks = <&clk IMX8MP_CLK_AUDIO_ROOT>,
+				 <&clk IMX8MP_CLK_AUDIO_AXI_DIV>;
+		};
+
+		gpumix_pd: gpumix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <6>;
+			domain-name = "gpumix";
+			clocks = <&clk IMX8MP_CLK_GPU_ROOT>, <&clk IMX8MP_CLK_GPU_AHB>,
+				 <&clk IMX8MP_CLK_GPU_AXI>;
+		};
+
+		gpu2d_pd: gpu2d-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <7>;
+			domain-name = "gpu2d";
+			parent-domains = <&gpumix_pd>;
+			clocks = <&clk IMX8MP_CLK_GPU2D_ROOT>;
+		};
+
+		gpu3d_pd: gpu3d-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <8>;
+			domain-name = "gpu3d";
+			parent-domains = <&gpumix_pd>;
+			clocks = <&clk IMX8MP_CLK_GPU3D_ROOT>,
+				 <&clk IMX8MP_CLK_GPU3D_SHADER_DIV>;
+		};
+
+		vpumix_pd: vpumix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <9>;
+			domain-name = "vpumix";
+			clocks =<&clk IMX8MP_CLK_VPU_ROOT>;
+		};
+
+		vpu_g1_pd: vpug1-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <10>;
+			domain-name = "vpu_g1";
+			parent-domains = <&vpumix_pd>;
+			clocks = <&clk IMX8MP_CLK_VPU_G1_ROOT>;
+		};
+
+		vpu_g2_pd: vpug2-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <11>;
+			domain-name = "vpu_g2";
+			parent-domains = <&vpumix_pd>;
+			clocks = <&clk IMX8MP_CLK_VPU_G2_ROOT>;
+		};
+
+		vpu_h1_pd: vpuh1-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <12>;
+			domain-name = "vpu_h1";
+			parent-domains = <&vpumix_pd>;
+			clocks = <&clk IMX8MP_CLK_VPU_VC8KE_ROOT>;
+		};
+
+		mediamix_pd: mediamix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <13>;
+			domain-name = "mediamix";
+			clocks = <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+				 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+		};
+
+		ispdwp_pd: power-domain@14 {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <14>;
+			domain-name = "ispdwp";
+			parent-domains = <&mediamix_pd>;
+			clocks = <&clk IMX8MP_CLK_MEDIA_ISP_DIV>;
+		};
+
+		mipi_phy1_pd: mipiphy1-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <15>;
+			domain-name = "mipi_phy1";
+			parent-domains = <&mediamix_pd>;
+		};
+
+		mipi_phy2_pd: mipiphy2-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <16>;
+			domain-name = "mipi_phy2";
+			parent-domains = <&mediamix_pd>;
+		};
+
+		hdmimix_pd: hdmimix-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <17>;
+			domain-name = "hdmimix";
+			clocks = <&clk IMX8MP_CLK_HDMI_ROOT>,
+				 <&clk IMX8MP_CLK_HDMI_APB>,
+				 <&clk IMX8MP_CLK_HDMI_REF_266M>;
+		};
+
+		hdmi_phy_pd: hdmiphy-pd {
+			compatible = "fsl,imx8m-pm-domain";
+			#power-domain-cells = <0>;
+			domain-index = <18>;
+			domain-name = "hdmi_phy";
+			parent-domains = <&hdmimix_pd>;
+		};
+	};
+
+	psci {
+		compatible = "arm,psci-1.0";
+		method = "smc";
+	};
+
+	pmu {
+		compatible = "arm,armv8-pmuv3";
+		interrupt-parent = <&gic>;
+		interrupts = <GIC_PPI 7
+			     (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_HIGH)>;
+		interrupt-affinity = <&A53_0>, <&A53_1>, <&A53_2>, <&A53_3>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(6) | IRQ_TYPE_LEVEL_LOW)>;
+		clock-frequency = <8000000>;
+		arm,no-tick-in-suspend;
+		interrupt-parent = <&gic>;
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <2000>;
+			thermal-sensors = <&tmu 0x0>;
+			trips {
+				cpu_alert0: trip0 {
+					temperature = <95000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_crit0: trip1 {
+					temperature = <105000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				map0 {
+					trip = <&cpu_alert0>;
+					cooling-device =
+						<&A53_0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A53_1 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A53_2 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>,
+						<&A53_3 THERMAL_NO_LIMIT THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		soc-thermal {
+			polling-delay-passive = <250>;
+			polling-delay = <2000>;
+			thermal-sensors = <&tmu 0x1>;
+			trips {
+				soc_alert0: trip0 {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				soc_crit0: trip1 {
+					temperature = <95000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+		};
+	};
+
+	soc@0 {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0x3e000000>;
+
+		caam_sm: caam-sm@100000 {
+			compatible = "fsl,imx6q-caam-sm";
+			reg = <0x100000 0x8000>;
+		};
+
+		aips1: bus@30000000 {
+			compatible = "simple-bus";
+			reg = <0x30000000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			gpio1: gpio@30200000 {
+				compatible = "fsl,imx8mp-gpio", "fsl,imx35-gpio";
+				reg = <0x30200000 0x10000>;
+				interrupts = <GIC_SPI 64 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 65 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_GPIO1_ROOT>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio2: gpio@30210000 {
+				compatible = "fsl,imx8mp-gpio", "fsl,imx35-gpio";
+				reg = <0x30210000 0x10000>;
+				interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_GPIO2_ROOT>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio3: gpio@30220000 {
+				compatible = "fsl,imx8mp-gpio", "fsl,imx35-gpio";
+				reg = <0x30220000 0x10000>;
+				interrupts = <GIC_SPI 68 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 69 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_GPIO3_ROOT>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio4: gpio@30230000 {
+				compatible = "fsl,imx8mp-gpio", "fsl,imx35-gpio";
+				reg = <0x30230000 0x10000>;
+				interrupts = <GIC_SPI 70 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 71 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_GPIO4_ROOT>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			gpio5: gpio@30240000 {
+				compatible = "fsl,imx8mp-gpio", "fsl,imx35-gpio";
+				reg = <0x30240000 0x10000>;
+				interrupts = <GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_GPIO5_ROOT>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				interrupt-controller;
+				#interrupt-cells = <2>;
+			};
+
+			tmu: tmu@30260000 {
+				compatible = "fsl,imx8mp-tmu";
+				reg = <0x30260000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_TSENSOR_ROOT>;
+				#thermal-sensor-cells = <1>;
+			};
+
+			wdog1: watchdog@30280000 {
+				compatible = "fsl,imx8mp-wdt", "fsl,imx21-wdt";
+				reg = <0x30280000 0x10000>;
+				interrupts = <GIC_SPI 78 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_WDOG1_ROOT>;
+				status = "disabled";
+			};
+
+			iomuxc: pinctrl@30330000 {
+				compatible = "fsl,imx8mp-iomuxc";
+				reg = <0x30330000 0x10000>;
+			};
+
+			gpr: iomuxc-gpr@30340000 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "fsl,imx7d-iomuxc-gpr",
+					     "fsl,imx6q-iomuxc-gpr", "syscon";
+				reg = <0x30340000 0x10000>;
+			};
+
+			ocotp: ocotp-ctrl@30350000 {
+				compatible = "fsl,imx8mp-ocotp", "fsl,imx8mm-ocotp", "syscon";
+				reg = <0x30350000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_OCOTP_ROOT>;
+				/* For nvmem subnodes */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				cpu_speed_grade: speed-grade@10 {
+					reg = <0x10 4>;
+				};
+
+				eth_mac1: mac-address@640 {
+					reg = <0x90 6>;
+				};
+
+				eth_mac2: mac-address@650 {
+					reg = <0x96 6>;
+				};
+			};
+
+			anatop: anatop@30360000 {
+				compatible = "fsl,imx8mp-anatop", "fsl,imx8mm-anatop",
+					     "syscon";
+				reg = <0x30360000 0x10000>;
+			};
+
+			irq_sec_vio: caam_secvio {
+				compatible = "fsl,imx6q-caam-secvio";
+				interrupts = <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
+				jtag-tamper = "disabled";
+				watchdog-tamper = "enabled";
+				internal-boot-tamper = "enabled";
+				external-pin-tamper = "disabled";
+			};
+
+			caam_snvs: caam-snvs@30370000 {
+				compatible = "fsl,imx6q-caam-snvs";
+				reg = <0x30370000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_SNVS_ROOT>;
+				clock-names = "ipg";
+			};
+
+			snvs: snvs@30370000 {
+				compatible = "fsl,sec-v4.0-mon","syscon", "simple-mfd";
+				reg = <0x30370000 0x10000>;
+
+				snvs_rtc: snvs-rtc-lp{
+					compatible = "fsl,sec-v4.0-mon-rtc-lp";
+					regmap =<&snvs>;
+					offset = <0x34>;
+					interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&clk IMX8MP_CLK_SNVS_ROOT>;
+					clock-names = "snvs-rtc";
+				};
+
+				snvs_pwrkey: snvs-powerkey {
+					compatible = "fsl,sec-v4.0-pwrkey";
+					regmap = <&snvs>;
+					interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&clk IMX8MP_CLK_SNVS_ROOT>;
+					clock-names = "snvs";
+					linux,keycode = <KEY_POWER>;
+					wakeup-source;
+				};
+			};
+
+			clk: clock-controller@30380000 {
+				compatible = "fsl,imx8mp-ccm";
+				reg = <0x30380000 0x10000>;
+				#clock-cells = <1>;
+				clocks = <&osc_32k>, <&osc_24m>, <&clk_ext1>, <&clk_ext2>,
+					 <&clk_ext3>, <&clk_ext4>;
+				clock-names = "osc_32k", "osc_24m", "clk_ext1", "clk_ext2",
+					      "clk_ext3", "clk_ext4";
+				assigned-clocks = <&clk IMX8MP_CLK_NOC>,
+						  <&clk IMX8MP_CLK_NOC_IO>,
+						  <&clk IMX8MP_CLK_GIC>,
+						  <&clk IMX8MP_CLK_AUDIO_AHB>,
+						  <&clk IMX8MP_CLK_AUDIO_AXI_SRC>,
+						  <&clk IMX8MP_CLK_IPG_AUDIO_ROOT>,
+						  <&clk IMX8MP_AUDIO_PLL1>,
+						  <&clk IMX8MP_AUDIO_PLL2>,
+						  <&clk IMX8MP_VIDEO_PLL1>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>,
+							 <&clk IMX8MP_SYS_PLL2_500M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <1000000000>,
+						       <800000000>,
+						       <500000000>,
+						       <400000000>,
+						       <800000000>,
+						       <400000000>,
+						       <393216000>,
+						       <361267200>,
+						       <1039500000>;
+			};
+
+			src: src@30390000 {
+				compatible = "fsl,imx8mp-src", "fsl,imx8mq-src", "syscon";
+				reg = <0x30390000 0x10000>;
+				interrupts = <GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH>;
+				#reset-cells = <1>;
+			};
+		};
+
+		aips2: bus@30400000 {
+			compatible = "simple-bus";
+			reg = <0x30400000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			pwm1: pwm@30660000 {
+				compatible = "fsl,imx8mp-pwm", "fsl,imx27-pwm";
+				reg = <0x30660000 0x10000>;
+				interrupts = <GIC_SPI 81 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_PWM1_ROOT>,
+					 <&clk IMX8MP_CLK_PWM1_ROOT>;
+				clock-names = "ipg", "per";
+				#pwm-cells = <2>;
+				status = "disabled";
+			};
+
+			pwm2: pwm@30670000 {
+				compatible = "fsl,imx8mp-pwm", "fsl,imx27-pwm";
+				reg = <0x30670000 0x10000>;
+				interrupts = <GIC_SPI 82 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_PWM2_ROOT>,
+					 <&clk IMX8MP_CLK_PWM2_ROOT>;
+				clock-names = "ipg", "per";
+				#pwm-cells = <2>;
+				status = "disabled";
+			};
+
+			pwm3: pwm@30680000 {
+				compatible = "fsl,imx8mp-pwm", "fsl,imx27-pwm";
+				reg = <0x30680000 0x10000>;
+				interrupts = <GIC_SPI 83 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_PWM3_ROOT>,
+					 <&clk IMX8MP_CLK_PWM3_ROOT>;
+				clock-names = "ipg", "per";
+				#pwm-cells = <2>;
+				status = "disabled";
+			};
+
+			pwm4: pwm@30690000 {
+				compatible = "fsl,imx8mp-pwm", "fsl,imx27-pwm";
+				reg = <0x30690000 0x10000>;
+				interrupts = <GIC_SPI 84 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_PWM4_ROOT>,
+					 <&clk IMX8MP_CLK_PWM4_ROOT>;
+				clock-names = "ipg", "per";
+				#pwm-cells = <2>;
+				status = "disabled";
+			};
+
+			system_counter: timer@306a0000 {
+				compatible = "nxp,sysctr-timer";
+				reg = <0x306a0000 0x20000>;
+				interrupts = <GIC_SPI 47 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&osc_24m>;
+				clock-names = "per";
+			};
+		};
+
+		aips3: bus@30800000 {
+			compatible = "simple-bus";
+			reg = <0x30800000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			ecspi1: spi@30820000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-ecspi", "fsl,imx6ul-ecspi";
+				reg = <0x30820000 0x10000>;
+				interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_ECSPI1_ROOT>,
+					 <&clk IMX8MP_CLK_ECSPI1_ROOT>;
+				clock-names = "ipg", "per";
+				assigned-clock-rates = <80000000>;
+				assigned-clocks = <&clk IMX8MP_CLK_ECSPI1>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>;
+				dmas = <&sdma1 0 7 1>, <&sdma1 1 7 2>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			ecspi2: spi@30830000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-ecspi", "fsl,imx6ul-ecspi";
+				reg = <0x30830000 0x10000>;
+				interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_ECSPI2_ROOT>,
+					 <&clk IMX8MP_CLK_ECSPI2_ROOT>;
+				clock-names = "ipg", "per";
+				assigned-clock-rates = <80000000>;
+				assigned-clocks = <&clk IMX8MP_CLK_ECSPI2>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>;
+				dmas = <&sdma1 2 7 1>, <&sdma1 3 7 2>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			ecspi3: spi@30840000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-ecspi", "fsl,imx6ul-ecspi";
+				reg = <0x30840000 0x10000>;
+				interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_ECSPI3_ROOT>,
+					 <&clk IMX8MP_CLK_ECSPI3_ROOT>;
+				clock-names = "ipg", "per";
+				assigned-clock-rates = <80000000>;
+				assigned-clocks = <&clk IMX8MP_CLK_ECSPI3>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>;
+				dmas = <&sdma1 4 7 1>, <&sdma1 5 7 2>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			uart1: serial@30860000 {
+				compatible = "fsl,imx8mp-uart", "fsl,imx6q-uart";
+				reg = <0x30860000 0x10000>;
+				interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_UART1_ROOT>,
+					 <&clk IMX8MP_CLK_UART1_ROOT>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma1 22 4 0>, <&sdma1 23 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			uart3: serial@30880000 {
+				compatible = "fsl,imx8mp-uart", "fsl,imx6q-uart";
+				reg = <0x30880000 0x10000>;
+				interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_UART3_ROOT>,
+					 <&clk IMX8MP_CLK_UART3_ROOT>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma1 26 4 0>, <&sdma1 27 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			uart2: serial@30890000 {
+				compatible = "fsl,imx8mp-uart", "fsl,imx6q-uart";
+				reg = <0x30890000 0x10000>;
+				interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_UART2_ROOT>,
+					 <&clk IMX8MP_CLK_UART2_ROOT>;
+				clock-names = "ipg", "per";
+				status = "disabled";
+			};
+
+			flexcan1: can@308c0000 {
+				compatible = "fsl,imx8mp-flexcan", "fsl,imx6q-flexcan";
+				reg = <0x308c0000 0x10000>;
+				interrupts = <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_IPG_ROOT>,
+					 <&clk IMX8MP_CLK_CAN1_ROOT>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&clk IMX8MP_CLK_CAN1>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_40M>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source= <0>;
+				fsl,stop-mode = <&gpr 0x10 4 0x10 20>;
+				status = "disabled";
+			};
+
+			flexcan2: can@308d0000 {
+				compatible = "fsl,imx8mp-flexcan", "fsl,imx6q-flexcan";
+				reg = <0x308d0000 0x10000>;
+				interrupts = <GIC_SPI 144 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_IPG_ROOT>,
+					 <&clk IMX8MP_CLK_CAN2_ROOT>;
+				clock-names = "ipg", "per";
+				assigned-clocks = <&clk IMX8MP_CLK_CAN2>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_40M>;
+				assigned-clock-rates = <40000000>;
+				fsl,clk-source= <0>;
+				fsl,stop-mode = <&gpr 0x10 5 0x10 21>;
+				status = "disabled";
+			};
+
+			crypto: crypto@30900000 {
+				compatible = "fsl,sec-v4.0";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x30900000 0x40000>;
+				ranges = <0 0x30900000 0x40000>;
+				interrupts = <GIC_SPI 91 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_AHB>,
+					 <&clk IMX8MP_CLK_IPG_ROOT>;
+				clock-names = "aclk", "ipg";
+
+				sec_jr0: jr@1000 {
+					compatible = "fsl,sec-v4.0-job-ring";
+					reg = <0x1000 0x1000>;
+					interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				sec_jr1: jr@2000 {
+					compatible = "fsl,sec-v4.0-job-ring";
+					reg = <0x2000 0x1000>;
+					interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				};
+
+				sec_jr2: jr@3000 {
+					compatible = "fsl,sec-v4.0-job-ring";
+					reg = <0x3000 0x1000>;
+					interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH>;
+				};
+			};
+
+			i2c1: i2c@30a20000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30a20000 0x10000>;
+				interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C1_ROOT>;
+				status = "disabled";
+			};
+
+			i2c2: i2c@30a30000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30a30000 0x10000>;
+				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C2_ROOT>;
+				status = "disabled";
+			};
+
+			i2c3: i2c@30a40000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30a40000 0x10000>;
+				interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C3_ROOT>;
+				status = "disabled";
+			};
+
+			i2c4: i2c@30a50000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30a50000 0x10000>;
+				interrupts = <GIC_SPI 38 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C4_ROOT>;
+				status = "disabled";
+			};
+
+			uart4: serial@30a60000 {
+				compatible = "fsl,imx8mp-uart", "fsl,imx6q-uart";
+				reg = <0x30a60000 0x10000>;
+				interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_UART4_ROOT>,
+					 <&clk IMX8MP_CLK_UART4_ROOT>;
+				clock-names = "ipg", "per";
+				dmas = <&sdma1 28 4 0>, <&sdma1 29 4 0>;
+				dma-names = "rx", "tx";
+				status = "disabled";
+			};
+
+			mu: mu@30aa0000 {
+				compatible = "fsl,imx8mp-mu", "fsl,imx6sx-mu";
+				reg = <0x30aa0000 0x10000>;
+				interrupts = <GIC_SPI 88 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_MU_ROOT>;
+				clock-names = "mu";
+				#mbox-cells = <2>;
+			};
+
+			i2c5: i2c@30ad0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30ad0000 0x10000>;
+				interrupts = <GIC_SPI 76 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C5_ROOT>;
+				status = "disabled";
+			};
+
+			i2c6: i2c@30ae0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-i2c", "fsl,imx21-i2c";
+				reg = <0x30ae0000 0x10000>;
+				interrupts = <GIC_SPI 77 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_I2C6_ROOT>;
+				status = "disabled";
+			};
+
+			usdhc1: mmc@30b40000 {
+				compatible = "fsl,imx8mm-usdhc", "fsl,imx7d-usdhc";
+				reg = <0x30b40000 0x10000>;
+				interrupts = <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_DUMMY>,
+					 <&clk IMX8MP_CLK_NAND_USDHC_BUS>,
+					 <&clk IMX8MP_CLK_USDHC1_ROOT>;
+				clock-names = "ipg", "ahb", "per";
+				assigned-clocks = <&clk IMX8MP_CLK_USDHC1>;
+				assigned-clock-rates = <400000000>;
+				fsl,tuning-start-tap = <20>;
+				fsl,tuning-step= <2>;
+				bus-width = <4>;
+				status = "disabled";
+			};
+
+			usdhc2: mmc@30b50000 {
+				compatible = "fsl,imx8mm-usdhc", "fsl,imx7d-usdhc";
+				reg = <0x30b50000 0x10000>;
+				interrupts = <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_DUMMY>,
+					 <&clk IMX8MP_CLK_NAND_USDHC_BUS>,
+					 <&clk IMX8MP_CLK_USDHC2_ROOT>;
+				clock-names = "ipg", "ahb", "per";
+				assigned-clocks = <&clk IMX8MP_CLK_USDHC2>;
+				assigned-clock-rates = <400000000>;
+				fsl,tuning-start-tap = <20>;
+				fsl,tuning-step= <2>;
+				bus-width = <4>;
+				status = "disabled";
+			};
+
+			usdhc3: mmc@30b60000 {
+				compatible = "fsl,imx8mm-usdhc", "fsl,imx7d-usdhc";
+				reg = <0x30b60000 0x10000>;
+				interrupts = <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_DUMMY>,
+					 <&clk IMX8MP_CLK_NAND_USDHC_BUS>,
+					 <&clk IMX8MP_CLK_USDHC3_ROOT>;
+				clock-names = "ipg", "ahb", "per";
+				assigned-clocks = <&clk IMX8MP_CLK_USDHC3>;
+				assigned-clock-rates = <400000000>;
+				fsl,tuning-start-tap = <20>;
+				fsl,tuning-step= <2>;
+				bus-width = <4>;
+				status = "disabled";
+			};
+
+			flexspi: spi@30bb0000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "nxp,imx8mm-fspi";
+				reg = <0x30bb0000 0x10000>, <0x08000000 0x10000000>;
+				reg-names = "fspi_base", "fspi_mmap";
+				interrupts = <GIC_SPI 107 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_QSPI_ROOT>,
+					 <&clk IMX8MP_CLK_QSPI_ROOT>;
+				clock-names = "fspi", "fspi_en";
+				assigned-clock-rates = <80000000>;
+				assigned-clocks = <&clk IMX8MP_CLK_QSPI>;
+				status = "disabled";
+			};
+
+			sdma1: dma-controller@30bd0000 {
+				compatible = "fsl,imx8mq-sdma", "fsl,imx7d-sdma";
+				reg = <0x30bd0000 0x10000>;
+				interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_SDMA1_ROOT>,
+					 <&clk IMX8MP_CLK_AHB>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
+			};
+
+			fec: ethernet@30be0000 {
+				compatible = "fsl,imx8mm-fec", "fsl,imx8mq-fec", "fsl,imx6sx-fec";
+				reg = <0x30be0000 0x10000>;
+				interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 120 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_ENET1_ROOT>,
+					 <&clk IMX8MP_CLK_SIM_ENET_ROOT>,
+					 <&clk IMX8MP_CLK_ENET_TIMER>,
+					 <&clk IMX8MP_CLK_ENET_REF>,
+					 <&clk IMX8MP_CLK_ENET_PHY_REF>;
+				clock-names = "ipg", "ahb", "ptp",
+					      "enet_clk_ref", "enet_out";
+				assigned-clocks = <&clk IMX8MP_CLK_ENET_AXI>,
+						  <&clk IMX8MP_CLK_ENET_TIMER>,
+						  <&clk IMX8MP_CLK_ENET_REF>,
+						  <&clk IMX8MP_CLK_ENET_TIMER>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_266M>,
+							 <&clk IMX8MP_SYS_PLL2_100M>,
+							 <&clk IMX8MP_SYS_PLL2_125M>;
+				assigned-clock-rates = <0>, <0>, <125000000>, <100000000>;
+				fsl,num-tx-queues = <3>;
+				fsl,num-rx-queues = <3>;
+				nvmem-cells = <&eth_mac1>;
+				nvmem-cell-names = "mac-address";
+				nvmem_macaddr_swap;
+				stop-mode = <&gpr 0x10 3>;
+				fsl,wakeup_irq = <2>;
+				status = "disabled";
+			};
+
+			eqos: ethernet@30bf0000 {
+				compatible = "nxp,imx8mp-dwmac-eqos", "snps,dwmac-5.10a";
+				reg = <0x30bf0000 0x10000>;
+				interrupts = <GIC_SPI 134 IRQ_TYPE_LEVEL_HIGH>,
+					     <GIC_SPI 135 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-names = "eth_wake_irq", "macirq";
+				clocks = <&clk IMX8MP_CLK_ENET_QOS_ROOT>,
+					 <&clk IMX8MP_CLK_QOS_ENET_ROOT>,
+					 <&clk IMX8MP_CLK_ENET_QOS_TIMER>,
+					 <&clk IMX8MP_CLK_ENET_QOS>;
+				clock-names = "stmmaceth", "pclk", "ptp_ref", "tx";
+				assigned-clocks = <&clk IMX8MP_CLK_ENET_AXI>,
+						  <&clk IMX8MP_CLK_ENET_QOS_TIMER>,
+						  <&clk IMX8MP_CLK_ENET_QOS>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_266M>,
+							 <&clk IMX8MP_SYS_PLL2_100M>,
+							 <&clk IMX8MP_SYS_PLL2_125M>;
+				assigned-clock-rates = <0>, <100000000>, <125000000>;
+				nvmem-cells = <&eth_mac2>;
+				nvmem-cell-names = "mac-address";
+				nvmem_macaddr_swap;
+				intf_mode = <&gpr 0x4>;
+				status = "disabled";
+			};
+		};
+
+		aips5: bus@30c00000 {
+			compatible = "simple-bus";
+			reg = <0x30c00000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			spba-bus@30c00000 {
+				compatible = "fsl,spba-bus", "simple-bus";
+				reg = <0x30c00000 0x100000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges;
+
+				sai1: sai@30c10000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c10000 0x10000>;
+					interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI1_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI1_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 0 2 0>, <&sdma2 1 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xff 0xff>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai2: sai@30c20000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c20000 0x10000>;
+					interrupts = <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI2_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI2_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 2 2 0>, <&sdma2 3 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xf 0xf>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai3: sai@30c30000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c30000 0x10000>;
+					interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 4 2 0>, <&sdma2 5 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0x3 0x3>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai5: sai@30c50000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c50000 0x10000>;
+					interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI5_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI5_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 8 2 0>, <&sdma2 9 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					fsl,dataline = <0 0xf 0xf>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai6: sai@30c60000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c60000 0x10000>;
+					interrupts = <GIC_SPI 90 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI6_IPG>,
+						 <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI6_MCLK1>,
+						 <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 10 2 0>, <&sdma2 11 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				sai7: sai@30c80000 {
+					compatible = "fsl,imx8mq-sai", "fsl,imx6sx-sai";
+					reg = <0x30c80000 0x10000>;
+					interrupts = <GIC_SPI 111 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI7_IPG>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SAI7_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
+						 <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
+					dmas = <&sdma2 12 2 0>, <&sdma2 13 2 0>;
+					dma-names = "rx", "tx";
+					fsl,shared-interrupt;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				easrc: easrc@30c90000 {
+					compatible = "fsl,imx8mn-easrc";
+					reg = <0x30c90000 0x10000>;
+					interrupts = <GIC_SPI 122 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_ASRC_IPG>;
+					clock-names = "mem";
+					dmas = <&sdma2 16 23 0> , <&sdma2 17 23 0>,
+					       <&sdma2 18 23 0> , <&sdma2 19 23 0>,
+					       <&sdma2 20 23 0> , <&sdma2 21 23 0>,
+					       <&sdma2 22 23 0> , <&sdma2 23 23 0>;
+					dma-names = "ctx0_rx", "ctx0_tx",
+						    "ctx1_rx", "ctx1_tx",
+						    "ctx2_rx", "ctx2_tx",
+						    "ctx3_rx", "ctx3_tx";
+					fsl,easrc-ram-script-name = "imx/easrc/easrc-imx8mn.bin";
+					fsl,asrc-rate  = <8000>;
+					fsl,asrc-width = <16>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				micfil: micfil@30ca0000 {
+					compatible = "fsl,imx8mp-micfil";
+					reg = <0x30ca0000 0x10000>;
+					interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 44 IRQ_TYPE_LEVEL_HIGH>,
+						     <GIC_SPI 45 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_PDM_IPG>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_PDM_ROOT>,
+						 <&clk IMX8MP_AUDIO_PLL1_OUT>,
+						 <&clk IMX8MP_AUDIO_PLL2_OUT>,
+						 <&clk IMX8MP_CLK_EXT3>;
+					clock-names = "ipg_clk", "ipg_clk_app",
+						      "pll8k", "pll11k", "clkext3";
+					dmas = <&sdma2 24 25 0x80000000>;
+					dma-names = "rx";
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				aud2htx: aud2htx@30cb0000 {
+					compatible = "fsl,imx8mp-aud2htx";
+					reg = <0x30cb0000 0x10000>;
+					interrupts = <GIC_SPI 130 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_AUD2HTX_IPG>;
+					clock-names = "bus";
+					dmas = <&sdma2 26 2 0>;
+					dma-names = "tx";
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+
+				xcvr: xcvr@30cc0000 {
+					compatible = "fsl,imx8mp-xcvr";
+					reg = <0x30cc0000 0x800>,
+					      <0x30cc0800 0x400>,
+					      <0x30cc0c00 0x080>,
+					      <0x30cc0e00 0x080>;
+					reg-names = "ram", "regs", "rxfifo",
+						    "txfifo";
+					interrupts = /* XCVR IRQ 0 */
+						     <GIC_SPI 128 IRQ_TYPE_LEVEL_HIGH>,
+						     /* XCVR IRQ 1 */
+						     <GIC_SPI 129 IRQ_TYPE_LEVEL_HIGH>,
+						     /* XCVR PHY - SPDIF wakeup IRQ */
+						     <GIC_SPI 146 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_EARC_IPG>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_EARC_PHY>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SPBA2_ROOT>,
+						 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_AUDPLL_ROOT>;
+					clock-names = "ipg", "phy", "spba", "pll_ipg";
+					dmas = <&sdma2 30 2 0>, <&sdma2 31 2 0>;
+					dma-names = "rx", "tx";
+					resets = <&audiomix_reset 0>;
+					power-domains = <&audiomix_pd>;
+					status = "disabled";
+				};
+			};
+
+			sdma3: dma-controller@30e00000 {
+				compatible = "fsl,imx8mp-sdma", "fsl,imx7d-sdma";
+				reg = <0x30e00000 0x10000>;
+				interrupts = <GIC_SPI 34 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SDMA3_ROOT>,
+					 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_SDMA3_ROOT>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
+				fsl,ratio-1-1;
+				power-domains = <&audiomix_pd>;
+				status = "disabled";
+			};
+
+			sdma2: dma-controller@30e10000 {
+				compatible = "fsl,imx8mp-sdma", "fsl,imx7d-sdma";
+				reg = <0x30e10000 0x10000>;
+				interrupts = <GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&clk IMX8MP_CLK_IPG_AUDIO_ROOT>,
+					 <&clk IMX8MP_CLK_AUDIO_AHB>;
+				clock-names = "ipg", "ahb";
+				#dma-cells = <3>;
+				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
+				fsl,ratio-1-1;
+				power-domains = <&audiomix_pd>;
+				status = "disabled";
+			};
+
+			audiomix: audiomix@30e20000 {
+				compatible = "fsl,imx8mp-audiomix";
+				reg = <0x30e20000 0x10000>;
+
+				audiomix_clk: clock-controller {
+					compatible = "fsl,imx8mp-audiomix-clk";
+					#clock-cells = <1>;
+					clocks = <&clk IMX8MP_CLK_AUDIO_ROOT>;
+					clock-names = "audio_root";
+					power-domains = <&audiomix_pd>;
+				};
+
+				audiomix_reset: reset-controller {
+					compatible = "fsl,imx8mp-audiomix-reset";
+					power-domains = <&audiomix_pd>;
+					#reset-cells = <1>;
+				};
+
+				audiomix_dsp: audiomix_dsp {
+					compatible = "fsl,audiomix-dsp";
+				};
+			};
+
+			mu2: mu2@30e60000 {
+				compatible = "fsl,imx8-mu-dsp", "fsl,imx6sx-mu";
+				reg = <0x30E60000 0x10000>;
+				interrupts = <GIC_SPI 136 IRQ_TYPE_LEVEL_HIGH>;
+				fsl,dsp_ap_mu_id = <2>;
+				 #mbox-cells = <2>;
+				clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_MU2_ROOT>;
+				status = "okay";
+			};
+		};
+
+		aips4: bus@32c00000 {
+			compatible = "simple-bus";
+			reg = <0x32c00000 0x400000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			mipi_dsi: mipi_dsi@32e60000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-mipi-dsim";
+				reg = <0x32e60000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_APB_ROOT>,
+					 <&clk IMX8MP_CLK_MEDIA_MIPI_PHY1_REF>;
+				clock-names = "cfg", "pll-ref";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_MIPI_PHY1_REF>;
+				assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+				assigned-clock-rates = <12000000>;
+				interrupts = <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&mipi_phy1_pd>;
+				blk-ctl = <&mediamix_blk_ctl>;
+				status = "disabled";
+
+				port@0 {
+					dsim_from_lcdif: endpoint {
+						remote-endpoint = <&lcdif_to_dsim>;
+					};
+				};
+			};
+
+			lcdif1: lcd-controller@32e80000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif1";
+				reg = <0x32e80000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_DISP1_PIX_ROOT>,
+					 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+					 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+				clock-names = "pix", "disp-axi", "disp-apb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_DISP1_PIX>,
+						  <&clk IMX8MP_CLK_MEDIA_AXI>,
+						  <&clk IMX8MP_CLK_MEDIA_APB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>,
+							 <&clk IMX8MP_SYS_PLL2_1000M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <0>, <500000000>, <200000000>;
+				interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+				blk-ctl = <&mediamix_blk_ctl>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lcdif1_disp: port@0 {
+					reg = <0>;
+
+					lcdif_to_dsim: endpoint {
+						remote-endpoint = <&dsim_from_lcdif>;
+					};
+				};
+			};
+
+			lcdif2: lcd-controller@32e90000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif2";
+				reg = <0x32e90000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_DISP2_PIX_ROOT>,
+					 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+					 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+				clock-names = "pix", "disp-axi", "disp-apb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_DISP2_PIX>,
+						  <&clk IMX8MP_CLK_MEDIA_AXI>,
+						  <&clk IMX8MP_CLK_MEDIA_APB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>,
+							 <&clk IMX8MP_SYS_PLL2_1000M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <0>, <500000000>, <200000000>;
+				interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lcdif2_disp: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					lcdif2_disp_ldb_ch0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&ldb_ch0>;
+					};
+
+					lcdif2_disp_ldb_ch1: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&ldb_ch1>;
+					};
+				};
+			};
+
+			mediamix_blk_ctl: blk-ctl@32ec0000 {
+				compatible = "fsl,imx8mp-mediamix-blk-ctl",
+					     "syscon";
+				reg = <0x32ec0000 0x10000>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+			};
+
+			ldb: ldb@32ec005c {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-ldb";
+				clocks = <&clk IMX8MP_CLK_MEDIA_LDB_ROOT>;
+				clock-names = "ldb";
+				assigned-clocks = <&clk IMX8MP_CLK_MEDIA_LDB>;
+				assigned-clock-parents = <&clk IMX8MP_VIDEO_PLL1_OUT>;
+				gpr = <&mediamix_blk_ctl>;
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				lvds-channel@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+					phys = <&ldb_phy1>;
+					phy-names = "ldb_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch0: endpoint {
+							remote-endpoint = <&lcdif2_disp_ldb_ch0>;
+						};
+					};
+				};
+
+				lvds-channel@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+					phys = <&ldb_phy2>;
+					phy-names = "ldb_phy";
+					status = "disabled";
+
+					port@0 {
+						reg = <0>;
+
+						ldb_ch1: endpoint {
+							remote-endpoint = <&lcdif2_disp_ldb_ch1>;
+						};
+					};
+				};
+			};
+
+			/* TODO for HDMI PHY power on */
+			hdmi_blk: hdmi-blk@32fc0000 {
+				compatible = "syscon";
+				reg = <0x32fc0000 0x1000>;
+			};
+
+			hdmimix: hdmimix@32fc0000 {
+				compatible = "fsl,imx8mp-audiomix", "fsl,imx8mp-hdmimix";
+				reg = <0x32fc0000 0x1000>;
+
+				hdmimix_clk: clock-controller {
+					compatible = "fsl,imx8mp-hdmimix-clk";
+					#clock-cells = <1>;
+					clocks = <&clk IMX8MP_CLK_DUMMY>;
+					clock-names = "dummy";
+					status = "disabled";
+				};
+
+				hdmimix_reset: reset-controller {
+					compatible = "fsl,imx8mp-hdmimix-reset";
+					#reset-cells = <1>;
+					status = "disabled";
+				};
+			};
+
+			irqsteer_hdmi: irqsteer@32fc2000 {
+				compatible = "fsl,imx-irqsteer";
+				reg = <0x32fc2000 0x1000>;
+				interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-controller;
+				interrupt-parent = <&gic>;
+				#interrupt-cells = <1>;
+				fsl,channel = <1>;
+				fsl,num-irqs = <64>;
+				clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_IRQS_STEER_CLK>;
+				clock-names = "ipg";
+				assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <200000000>;
+				resets = <&hdmimix_reset IMX_HDMIMIX_IRQ_STEER_RESET>;
+				status = "disabled";
+			};
+
+			hdmi_pavi: hdmi-pai-pvi@32fc4000 {
+				compatible = "fsl,imx8mp-hdmi-pavi";
+				reg = <0x32fc4000 0x1000>;
+				clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_VID_LINK_PIX_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_GPA_CLK>;
+				clock-names = "pvi_clk", "pai_clk";
+				resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_PAI_RESET>,
+						<&hdmimix_reset IMX_HDMIMIX_HDMI_PVI_RESET>;
+				reset-names = "pai_rst", "pvi_rst";
+				status = "disabled";
+			};
+
+			lcdif3: lcd-controller@32fc6000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,imx8mp-lcdif3";
+				reg = <0x32fc6000 0x10000>;
+				clocks = <&hdmiphy 0>,
+						<&clk IMX8MP_CLK_HDMI_AXI>,
+						<&clk IMX8MP_CLK_HDMI_APB>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_APB_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_B_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_XTAL24M_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_TX_PIX_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_APB_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_B_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_PDI_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_PIX_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_LCDIF_SPU_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_NOC_HDMI_CLK>;
+				clock-names = "pix", "disp-axi", "disp-apb",
+							"mix_apb","mix_axi", "xtl_24m", "mix_pix", "lcdif_apb",
+							"lcdif_axi", "lcdif_pdi", "lcdif_pix", "lcdif_spu",
+							"noc_hdmi";
+				assigned-clocks =  <&clk IMX8MP_CLK_HDMI_AXI>,
+								<&clk IMX8MP_CLK_HDMI_APB>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>,
+							 <&clk IMX8MP_SYS_PLL1_800M>;
+				assigned-clock-rates = <500000000>, <200000000>;
+				interrupts = <8 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-parent = <&irqsteer_hdmi>;
+				resets = <&hdmimix_reset IMX_HDMIMIX_LCDIF_RESET>;
+				power-domains = <&hdmimix_pd>;
+				status = "disabled";
+
+				lcdif3_disp: port@0 {
+					reg = <0>;
+
+					lcdif3_to_hdmi: endpoint {
+						remote-endpoint = <&hdmi_from_lcdif3>;
+					};
+				};
+			};
+
+			hdmi: hdmi@32fd8000 {
+				compatible = "fsl,imx8mp-hdmi";
+				reg = <0x32fd8000 0x7eff>;
+				interrupts = <0 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-parent = <&irqsteer_hdmi>;
+				clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+						<&clk IMX8MP_CLK_HDMI_24M>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_INT_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PREP_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_SKP_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_SFR_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PIXEL_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_CEC_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_APB_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_HPI_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_FDCC_REF_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PIPE_CLK_SEL>;
+				clock-names = "iahb", "isfr",
+								"phy_int", "prep_clk", "skp_clk", "sfr_clk", "pix_clk",
+								"cec_clk", "apb_clk", "hpi_clk", "fdcc_ref", "pipe_clk";
+				assigned-clocks = <&clk IMX8MP_CLK_HDMI_APB>,
+							<&clk IMX8MP_CLK_HDMI_AXI>,
+							<&clk IMX8MP_CLK_HDMI_24M>;
+				assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>,
+							<&clk IMX8MP_SYS_PLL2_500M>,
+							<&clk IMX8MP_CLK_24M>;
+				assigned-clock-rates = <200000000>, <500000000>, <24000000>;
+				phys = <&hdmiphy>;
+				phy-names = "hdmi";
+				resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_TX_RESET>;
+				gpr = <&hdmi_blk>;
+				power-domains = <&hdmi_phy_pd>;
+				status = "disabled";
+
+				port@0 {
+					hdmi_from_lcdif3: endpoint {
+						remote-endpoint = <&lcdif3_to_hdmi>;
+					};
+				};
+			};
+
+			hdmiphy: hdmiphy@32fdff00 {
+				compatible = "fsl,samsung-hdmi-phy";
+				reg = <0x32fdff00 0x100>;
+				#clock-cells = <1>;
+				clocks = <&hdmimix_clk IMX8MP_CLK_HDMIMIX_TX_PHY_APB_CLK>,
+						<&hdmimix_clk IMX8MP_CLK_HDMIMIX_GLOBAL_XTAL24M_CLK>;
+				clock-names = "apb", "ref";
+				clock-output-names = "hdmi_phy";
+				#phy-cells = <0>;
+				resets = <&hdmimix_reset IMX_HDMIMIX_HDMI_PHY_RESET>;
+				status = "disabled";
+			};
+
+			mediamix_gasket0: gasket@32ec0060 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0060 0x28>;
+			};
+
+			mediamix_gasket1: gasket@32ec0090 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0090 0x28>;
+			};
+
+			ldb_phy: phy@32ec0128 {
+				compatible = "fsl,imx8mp-lvds-phy";
+				#address-cells = <1>;
+				#size-cells = <0>;
+				gpr = <&mediamix_blk_ctl>;
+				clocks = <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+				clock-names = "apb";
+				power-domains = <&mediamix_pd>;
+				status = "disabled";
+
+				ldb_phy1: port@0 {
+					reg = <0>;
+					#phy-cells = <0>;
+				};
+
+				ldb_phy2: port@1 {
+					reg = <1>;
+					#phy-cells = <0>;
+				};
+			};
+
+			mediamix_gpr: media_gpr@32ec0008 {
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32ec0008 0x4>;
+			};
+
+			isi_chain_buf: isi_chain@32e02000{
+				compatible = "fsl,imx8mp-iomuxc-gpr", "syscon";
+				reg = <0x32e02000 0x4>;
+			};
+
+			cameradev: camera {
+				compatible = "fsl,mxc-md", "simple-bus";
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges;
+				status = "disabled";
+
+				isi_0: isi@32e00000 {
+					compatible = "fsl,imx8mp-isi", "fsl,imx8mn-isi";
+					reg = <0x32e00000 0x2000>;
+					interrupts = <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>;
+					interface = <2 0 2>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+						 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					clock-names = "disp_axi", "disp_apb", "disp_axi_root", "disp_apb_root";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+							  <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					assigned-clock-rates = <500000000>, <200000000>;
+					no-reset-control;
+					power-domains = <&mediamix_pd>;
+					isi_chain = <&isi_chain_buf>;
+					status = "disabled";
+
+					cap_device {
+						compatible = "imx-isi-capture";
+						status = "disabled";
+					};
+
+					m2m_device{
+						compatible = "imx-isi-m2m";
+						status = "disabled";
+					};
+				};
+
+				isi_1: isi@32e02000 {
+					compatible = "fsl,imx8mp-isi", "fsl,imx8mn-isi";
+					reg = <0x32e02000 0x2000>;
+					interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+					interface = <3 0 2>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+						 <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					clock-names = "disp_axi", "disp_apb", "disp_axi_root", "disp_apb_root";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_AXI_ROOT>,
+							  <&clk IMX8MP_CLK_MEDIA_APB_ROOT>;
+					assigned-clock-rates = <500000000>, <200000000>;
+					no-reset-control;
+					power-domains = <&mediamix_pd>;
+					status = "disabled";
+
+					cap_device {
+						compatible = "imx-isi-capture";
+						status = "disabled";
+					};
+				};
+
+				isp_0: isp@32e10000 {
+					compatible = "fsl,imx8mp-isp";
+					reg = <0x32e10000 0x10000>;
+					interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_ISP_SRC>;
+					clock-names = "isp_root";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_ISP_SRC>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+					assigned-clock-rates = <500000000>;
+					power-domains = <&ispdwp_pd>;
+					id = <0>;
+					status = "disabled";
+				};
+
+				isp_1: isp@32e20000 {
+					compatible = "fsl,imx8mp-isp";
+					reg = <0x32e20000 0x10000>;
+					interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_ISP_SRC>;
+					clock-names = "isp_root";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_ISP_SRC>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+					assigned-clock-rates = <500000000>;
+					power-domains = <&ispdwp_pd>;
+					id = <1>;
+					status = "disabled";
+				};
+
+				dewarp: dwe@32e30000 {
+					compatible = "fsl,imx8mp-dwe";
+					reg = <0x32e30000 0x10000>;
+					interrupts = <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>;
+					status = "disabled";
+				};
+
+				mipi_csi_0: csi@32e40000 {
+					compatible = "fsl,imx8mp-mipi-csi", "fsl,imx8mn-mipi-csi";
+					reg = <0x32e40000 0x10000>;
+					interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+					clock-frequency = <500000000>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_CAM1_PIX>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>;
+					clock-names = "mipi_clk", "disp_axi", "disp_apb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_CAM1_PIX>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>;
+					assigned-clock-rates = <500000000>;
+					bus-width = <4>;
+					csi-gpr = <&mediamix_gasket0>;
+					gpr = <&mediamix_blk_ctl>;
+					no-reset-control;
+					power-domains = <&mipi_phy1_pd>;
+					status = "disabled";
+				};
+
+				mipi_csi_1: csi@32e50000 {
+					compatible = "fsl,imx8mp-mipi-csi", "fsl,imx8mn-mipi-csi";
+					reg = <0x32e50000 0x10000>;
+					interrupts = <GIC_SPI 80 IRQ_TYPE_LEVEL_HIGH>;
+					clock-frequency = <266000000>;
+					clocks = <&clk IMX8MP_CLK_MEDIA_CAM2_PIX>,
+						 <&clk IMX8MP_CLK_MEDIA_AXI>,
+						 <&clk IMX8MP_CLK_MEDIA_APB>;
+					clock-names = "mipi_clk", "disp_axi", "disp_apb";
+					assigned-clocks = <&clk IMX8MP_CLK_MEDIA_CAM2_PIX>;
+					assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>;
+					assigned-clock-rates = <266000000>;
+					bus-width = <4>;
+					csi-gpr = <&mediamix_gasket1>;
+					gpr = <&mediamix_blk_ctl>;
+					no-reset-control;
+					power-domains = <&mipi_phy2_pd>;
+					status = "disabled";
+				};
+			};
+		};
+	};
+
+	pcie_phy: pcie-phy@32f00000 {
+		compatible = "fsl,imx8mp-pcie-phy";
+		reg = <0x0 0x32f00000 0x0 0x10000>;
+		clocks = <&clk IMX8MP_CLK_PCIE_PHY>;
+		clock-names = "phy";
+		assigned-clocks = <&clk IMX8MP_CLK_PCIE_PHY>;
+		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	hsio_mix: hsio-mix@32f10000 {
+		  compatible = "fsl,imx8mp-hsio-mix";
+		  reg = <0x0 0x32f10000 0x0 0x8>;
+	};
+
+	dma_apbh: dma-apbh@33000000 {
+		compatible = "fsl,imx7d-dma-apbh", "fsl,imx28-dma-apbh";
+		reg = <0 0x33000000 0 0x2000>;
+		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "gpmi0", "gpmi1", "gpmi2", "gpmi3";
+		#dma-cells = <1>;
+		dma-channels = <4>;
+		clocks = <&clk IMX8MP_CLK_NAND_USDHC_BUS_RAWNAND_CLK>;
+	};
+
+	gpmi: gpmi-nand@33002000{
+		compatible = "fsl,imx7d-gpmi-nand";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0 0x33002000 0 0x2000>, <0 0x33004000 0 0x4000>;
+		reg-names = "gpmi-nand", "bch";
+		interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "bch";
+		clocks = <&clk IMX8MP_CLK_NAND_ROOT>,
+			<&clk IMX8MP_CLK_NAND_USDHC_BUS_RAWNAND_CLK>;
+		clock-names = "gpmi_io", "gpmi_bch_apb";
+		dmas = <&dma_apbh 0>;
+		dma-names = "rx-tx";
+		status = "disabled";
+	};
+
+	pcie: pcie@33800000 {
+		compatible = "fsl,imx8mp-pcie", "snps,dw-pcie";
+		reg = <0x0 0x33800000 0x0 0x400000>,
+			<0x0 0x1ff00000 0x0 0x80000>;
+		reg-names = "dbi", "config";
+		#address-cells = <3>;
+		#size-cells = <2>;
+		device_type = "pci";
+		ranges =  <0x81000000 0 0x00000000 0x0 0x1ff80000 0 0x00010000 /* downstream I/O 64KB */
+			   0x82000000 0 0x18000000 0x0 0x18000000 0 0x07f00000>; /* non-prefetchable memory */
+		num-lanes = <1>;
+		interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+				<GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>; /* eDMA */
+		interrupt-names = "msi", "dma";
+		#interrupt-cells = <1>;
+		interrupt-map-mask = <0 0 0 0x7>;
+		interrupt-map = <0 0 0 1 &gic GIC_SPI 126 IRQ_TYPE_LEVEL_HIGH>,
+				<0 0 0 2 &gic GIC_SPI 125 IRQ_TYPE_LEVEL_HIGH>,
+				<0 0 0 3 &gic GIC_SPI 124 IRQ_TYPE_LEVEL_HIGH>,
+				<0 0 0 4 &gic GIC_SPI 123 IRQ_TYPE_LEVEL_HIGH>;
+		fsl,max-link-speed = <3>;
+		power-domains = <&pcie_pd>;
+		resets = <&src IMX8MQ_RESET_PCIEPHY>,
+			 <&src IMX8MQ_RESET_PCIEPHY_PERST>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_EN>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_CLK_REQ>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_TURNOFF>;
+		reset-names = "pciephy", "pciephy_perst", "apps", "clkreq", "turnoff";
+		phys = <&pcie_phy>;
+		phy-names = "pcie-phy";
+		fsl,imx8mp-hsio-mix = <&hsio_mix>;
+		status = "disabled";
+	};
+
+	pcie_ep: pcie_ep@33800000 {
+		compatible = "fsl,imx8mp-pcie-ep";
+		reg = <0x0 0x33800000 0x0 0x000400000>,
+		      <0x0 0x18000000 0x0 0x08000000>;
+		reg-names = "regs", "addr_space";
+		num-lanes = <1>;
+		interrupts = <GIC_SPI 127 IRQ_TYPE_LEVEL_HIGH>; /* eDMA */
+		interrupt-names = "dma";
+		fsl,max-link-speed = <3>;
+		power-domains = <&pcie_pd>;
+		resets = <&src IMX8MQ_RESET_PCIEPHY>,
+			 <&src IMX8MQ_RESET_PCIEPHY_PERST>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_EN>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_CLK_REQ>,
+			 <&src IMX8MQ_RESET_PCIE_CTRL_APPS_TURNOFF>;
+		reset-names = "pciephy", "pciephy_perst", "apps", "clkreq", "turnoff";
+		phys = <&pcie_phy>;
+		phy-names = "pcie-phy";
+		fsl,imx8mp-hsio-mix = <&hsio_mix>;
+		num-ib-windows = <4>;
+		num-ob-windows = <4>;
+		status = "disabled";
+	};
+
+	gpu_3d: gpu3d@38000000 {
+		compatible = "fsl,imx8-gpu";
+		reg = <0x0 0x38000000 0x0 0x8000>;
+		interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk IMX8MP_CLK_GPU3D_ROOT>,
+			 <&clk IMX8MP_CLK_GPU3D_SHADER_DIV>,
+			 <&clk IMX8MP_CLK_GPU_AXI>,
+			 <&clk IMX8MP_CLK_GPU_AHB>;
+		clock-names = "core", "shader", "axi", "ahb";
+		assigned-clocks = <&clk IMX8MP_CLK_GPU3D_CORE_SRC>,
+				  <&clk IMX8MP_CLK_GPU3D_SHADER_SRC>,
+				  <&clk IMX8MP_CLK_GPU_AXI>,
+				  <&clk IMX8MP_CLK_GPU_AHB>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>,
+					 <&clk IMX8MP_SYS_PLL2_1000M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <1000000000>, <1000000000>,
+				       <800000000>, <400000000>;
+		power-domains = <&gpu3d_pd>;
+		status = "disabled";
+	};
+
+	gpu_2d: gpu2d@38008000 {
+		compatible = "fsl,imx8-gpu";
+		reg = <0x0 0x38008000 0x0 0x8000>;
+		interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk IMX8MP_CLK_GPU2D_ROOT>,
+			 <&clk IMX8MP_CLK_GPU_AXI>,
+			 <&clk IMX8MP_CLK_GPU_AHB>;
+		clock-names = "core", "axi", "ahb";
+		assigned-clocks = <&clk IMX8MP_CLK_GPU2D_SRC>,
+				  <&clk IMX8MP_CLK_GPU_AXI>,
+				  <&clk IMX8MP_CLK_GPU_AHB>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <1000000000>, <800000000>, <400000000>;
+		power-domains = <&gpu2d_pd>;
+		status = "disabled";
+	};
+
+	usb3_phy0: usb-phy@381f0040 {
+		compatible = "fsl,imx8mp-usb-phy";
+		reg = <0 0x381f0040 0 0x40>;
+		clocks = <&clk IMX8MP_CLK_USB_PHY_ROOT>;
+		clock-names = "phy";
+		assigned-clocks = <&clk IMX8MP_CLK_USB_PHY_REF>;
+		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	usb3_0: usb@32f10100 {
+		compatible = "fsl,imx8mp-dwc3";
+		reg = <0 0x32f10100 0 0x8>;
+		clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
+			 <&clk IMX8MP_CLK_USB_ROOT>;
+		clock-names = "hsio", "suspend";
+		interrupts = <GIC_SPI 148 IRQ_TYPE_LEVEL_HIGH>;
+		power-domains = <&hsiomix_pd>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		status = "disabled";
+
+		usb_dwc3_0: dwc3@38100000 {
+			compatible = "snps,dwc3";
+			reg = <0 0x38100000 0 0x10000>;
+			clocks = <&clk IMX8MP_CLK_HSIO_AXI_DIV>,
+				 <&clk IMX8MP_CLK_USB_CORE_REF>,
+				 <&clk IMX8MP_CLK_USB_ROOT>;
+			clock-names = "bus_early", "ref", "suspend";
+			assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI_SRC>;
+			assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+			assigned-clock-rates = <500000000>;
+			interrupts = <GIC_SPI 40 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb3_phy0>, <&usb3_phy0>;
+			phy-names = "usb2-phy", "usb3-phy";
+			snps,dis-u2-freeclk-exists-quirk;
+			status = "disabled";
+		};
+
+	};
+
+	usb3_phy1: usb-phy@382f0040 {
+		compatible = "fsl,imx8mp-usb-phy";
+		reg = <0 0x382f0040 0 0x40>;
+		clocks = <&clk IMX8MP_CLK_USB_PHY_ROOT>;
+		clock-names = "phy";
+		assigned-clocks = <&clk IMX8MP_CLK_USB_PHY_REF>;
+		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
+		#phy-cells = <0>;
+		status = "disabled";
+	};
+
+	usb3_1: usb@32f10108 {
+		compatible = "fsl,imx8mp-dwc3";
+		reg = <0 0x32f10108 0 0x8>;
+		clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
+			 <&clk IMX8MP_CLK_USB_ROOT>;
+		clock-names = "hsio", "suspend";
+		interrupts = <GIC_SPI 149 IRQ_TYPE_LEVEL_HIGH>;
+		power-domains = <&hsiomix_pd>;
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+		status = "disabled";
+
+		usb_dwc3_1: dwc3@38200000 {
+			compatible = "snps,dwc3";
+			reg = <0 0x38200000 0 0x10000>;
+			clocks = <&clk IMX8MP_CLK_HSIO_AXI_DIV>,
+				 <&clk IMX8MP_CLK_USB_CORE_REF>,
+				 <&clk IMX8MP_CLK_USB_ROOT>;
+			clock-names = "bus_early", "ref", "suspend";
+			assigned-clocks = <&clk IMX8MP_CLK_HSIO_AXI_SRC>;
+			assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_500M>;
+			assigned-clock-rates = <500000000>;
+			interrupts = <GIC_SPI 41 IRQ_TYPE_LEVEL_HIGH>;
+			phys = <&usb3_phy1>, <&usb3_phy1>;
+			phy-names = "usb2-phy", "usb3-phy";
+			snps,dis-u2-freeclk-exists-quirk;
+			status = "disabled";
+		};
+	};
+
+	vpu_g1: vpu_g1@38300000 {
+		compatible = "nxp,imx8mm-hantro","nxp,imx8mp-hantro";
+		reg = <0x0 0x38300000 0x0 0x100000>;
+		reg-names = "regs_hantro";
+		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_hantro";
+		clocks = <&clk IMX8MP_CLK_VPU_G1_ROOT>, <&clk IMX8MP_CLK_VPU_ROOT>;
+		clock-names = "clk_hantro", "clk_hantro_bus";
+		assigned-clocks = <&clk IMX8MP_CLK_VPU_G1>, <&clk IMX8MP_CLK_VPU_BUS>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_800M>, <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <800000000>, <800000000>;
+		power-domains = <&vpu_g1_pd>;
+		status = "disabled";
+	};
+
+	vpu_g2: vpu_g2@38310000 {
+		compatible = "nxp,imx8mm-hantro","nxp,imx8mp-hantro";
+		reg = <0x0 0x38310000 0x0 0x100000>;
+		reg-names = "regs_hantro";
+		interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_hantro";
+		clocks = <&clk IMX8MP_CLK_VPU_G2_ROOT>, <&clk IMX8MP_CLK_VPU_ROOT>;
+		clock-names = "clk_hantro", "clk_hantro_bus";
+		assigned-clocks = <&clk IMX8MP_CLK_VPU_G2>, <&clk IMX8MP_CLK_VPU_BUS>, <&clk IMX8MP_VPU_PLL>;
+		assigned-clock-parents = <&clk IMX8MP_VPU_PLL_OUT>, <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <700000000>, <800000000>, <700000000>;
+		power-domains = <&vpu_g2_pd>;
+		status = "disabled";
+	};
+
+	vpu_vc8000e: vpu_vc8000e@38320000 {
+		compatible = "nxp,imx8mp-hantro-vc8000e";
+		reg = <0x0 0x38320000 0x0 0x10000>;
+		reg-names = "regs_hantro_vc8000e";
+		interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_hantro_vc8000e";
+		clocks = <&clk IMX8MP_CLK_VPU_VC8KE_ROOT>, <&clk IMX8MP_CLK_VPU_ROOT>;
+		clock-names = "clk_hantro_vc8000e", "clk_hantro_vc8000e_bus";
+		assigned-clocks = <&clk IMX8MP_CLK_VPU_VC8000E>,<&clk IMX8MP_CLK_VPU_BUS>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>, <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <500000000>, <800000000>;
+		power-domains = <&vpu_h1_pd>;
+		status = "disabled";
+	};
+
+	ml_vipsi: vipsi@38500000 {
+		compatible = "fsl,imx8-gpu", "fsl,imx8-vipsi";
+		reg = <0x0 0x38500000 0x0 0x20000>;
+		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+		clocks = <&clk IMX8MP_CLK_NPU_ROOT>,
+				<&clk IMX8MP_CLK_NPU_ROOT>,
+				<&clk IMX8MP_CLK_ML_AXI>,
+				<&clk IMX8MP_CLK_ML_AHB>;
+		clock-names = "core", "shader", "axi", "ahb";
+		assigned-clocks = <&clk IMX8MP_CLK_ML_SRC>,
+				  <&clk IMX8MP_CLK_ML_AXI>,
+				  <&clk IMX8MP_CLK_ML_AHB>;
+		assigned-clock-parents = <&clk IMX8MP_SYS_PLL2_1000M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>,
+					 <&clk IMX8MP_SYS_PLL1_800M>;
+		assigned-clock-rates = <1000000000>, <800000000>, <400000000>;
+		power-domains = <&mlmix_pd>;
+		status = "disabled";
+	};
+
+	dsp: dsp@3b6e8000 {
+		compatible = "fsl,imx8mp-dsp-v1";
+		memory-region = <&dsp_reserved>;
+		reg = <0x0 0x3B6E8000 0x0 0x88000>;
+		clocks = <&audiomix_clk IMX8MP_CLK_AUDIOMIX_OCRAMA_IPG>,
+			 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_DSP_ROOT>,
+			 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_DSPDBG_ROOT>,
+			 <&audiomix_clk IMX8MP_CLK_AUDIOMIX_MU2_ROOT>;
+		clock-names = "ocram", "core", "debug", "mu2";
+		fsl,dsp-firmware = "imx/dsp/hifi4.bin";
+		power-domains = <&audiomix_pd>;
+		mbox-names = "txdb0", "txdb1", "rxdb0", "rxdb1";
+		mboxes = <&mu2 2 0>,
+			<&mu2 2 1>,
+			<&mu2 3 0>,
+			<&mu2 3 1>;
+		status = "disabled";
+	};
+
+	display-subsystem {
+		compatible = "fsl,imx-display-subsystem";
+		ports = <&lcdif1_disp>,
+			<&lcdif2_disp>,
+			<&lcdif3_disp>;
+	};
+
+	imx_ion: imx_ion {
+		compatible = "fsl,mxc-ion";
+		fsl,heap-id = <0>;
+	};
+
+	mix_gpu_ml: mix_gpu_ml {
+		compatible = "fsl,imx8mp-gpu", "fsl,imx8-gpu-ss";
+		cores = <&gpu_3d>, <&ml_vipsi>, <&gpu_2d>;
+		reg = <0x0 0x40000000 0x0 0xC0000000>, <0x0 0x0 0x0 0x10000000>;
+		reg-names = "phys_baseaddr", "contiguous_mem";
+		status = "disabled";
+	};
+
+	rpmsg: rpmsg{
+		compatible = "fsl,imx8mq-rpmsg";
+		/* up to now, the following channels are used in imx rpmsg
+		 * - tx1/rx1: messages channel.
+		 * - general interrupt1: remote proc finish re-init rpmsg stack
+		 *   when A core is partition reset.
+		 */
+		mbox-names = "tx", "rx", "rxdb";
+		mboxes = <&mu 0 1
+			  &mu 1 1
+			  &mu 3 1>;
+		status = "disabled";
+	};
+
+	i2c_rpbus_3: i2c-rpbus-3 {
+		compatible = "fsl,i2c-rpbus";
+		status = "disabled";
+	};
+
+	etm0: etm@28440000 {
+		compatible = "arm,coresight-etm4x", "arm,primecell";
+		reg = <0x0 0x28440000 0x0 0x10000>;
+		arm,primecell-periphid = <0xbb95d>;
+		cpu = <&A53_0>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		out-ports {
+			port {
+				etm0_out_port: endpoint {
+					remote-endpoint = <&ca_funnel_in_port0>;
+				};
+			};
+		};
+	};
+
+	etm1: etm@28540000 {
+		compatible = "arm,coresight-etm4x", "arm,primecell";
+		reg = <0x0 0x28540000 0x0 0x10000>;
+		arm,primecell-periphid = <0xbb95d>;
+		cpu = <&A53_1>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		out-ports {
+			port {
+				etm1_out_port: endpoint {
+					remote-endpoint = <&ca_funnel_in_port1>;
+				};
+			};
+		};
+	};
+
+	etm2: etm@28640000 {
+		compatible = "arm,coresight-etm4x", "arm,primecell";
+		reg = <0x0 0x28640000 0x0 0x10000>;
+		arm,primecell-periphid = <0xbb95d>;
+		cpu = <&A53_2>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		out-ports {
+			port {
+				etm2_out_port: endpoint {
+					remote-endpoint = <&ca_funnel_in_port2>;
+				};
+			};
+		};
+	};
+
+	etm3: etm@28740000 {
+		compatible = "arm,coresight-etm4x", "arm,primecell";
+		reg = <0x0 0x28740000 0x0 0x10000>;
+		arm,primecell-periphid = <0xbb95d>;
+		cpu = <&A53_3>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		out-ports {
+			port {
+				etm3_out_port: endpoint {
+					remote-endpoint = <&ca_funnel_in_port3>;
+				};
+			};
+		};
+	};
+
+	funnel0: funnel {
+	       /*
+		* non-configurable funnel don't show up on the AMBA
+		* bus.  As such no need to add "arm,primecell".
+		*/
+		compatible = "arm,coresight-static-funnel";
+		status = "disabled";
+
+		in-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				ca_funnel_in_port0: endpoint {
+					remote-endpoint = <&etm0_out_port>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				ca_funnel_in_port1: endpoint {
+					remote-endpoint = <&etm1_out_port>;
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				ca_funnel_in_port2: endpoint {
+					remote-endpoint = <&etm2_out_port>;
+				};
+			};
+
+			port@3 {
+				reg = <3>;
+				ca_funnel_in_port3: endpoint {
+					remote-endpoint = <&etm3_out_port>;
+				};
+			};
+		};
+
+		out-ports {
+			port {
+				ca_funnel_out_port0: endpoint {
+					remote-endpoint = <&hugo_funnel_in_port0>;
+				};
+			};
+		};
+
+	};
+
+	funnel1: funnel@28c03000 {
+		compatible = "arm,coresight-dynamic-funnel", "arm,primecell";
+		reg = <0x0 0x28c03000 0x0 0x1000>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				hugo_funnel_in_port0: endpoint {
+					remote-endpoint = <&ca_funnel_out_port0>;
+				};
+			};
+
+			port@1 {
+				reg = <1>;
+				hugo_funnel_in_port1: endpoint {
+					/* M7 input */
+				};
+			};
+
+			port@2 {
+				reg = <2>;
+				hugo_funnel_in_port2: endpoint {
+					/* DSP input */
+				};
+			};
+			/* the other input ports are not connect to anything */
+		};
+
+		out-ports {
+			port {
+				hugo_funnel_out_port0: endpoint {
+					remote-endpoint = <&etf_in_port>;
+				};
+			};
+		};
+	};
+
+	etf@28c04000 {
+		compatible = "arm,coresight-tmc", "arm,primecell";
+		reg = <0x0 0x28c04000 0x0 0x1000>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				etf_in_port: endpoint {
+					remote-endpoint = <&hugo_funnel_out_port0>;
+				};
+			};
+		};
+
+		out-ports {
+			port {
+				etf_out_port: endpoint {
+					remote-endpoint = <&etr_in_port>;
+				};
+			};
+		};
+	};
+
+	etr@28c06000 {
+		compatible = "arm,coresight-tmc", "arm,primecell";
+		reg = <0x0 0x28c06000 0x0 0x1000>;
+		clocks = <&clk IMX8MP_CLK_MAIN_AXI>;
+		clock-names = "apb_pclk";
+		status = "disabled";
+
+		in-ports {
+			port {
+				etr_in_port: endpoint {
+					remote-endpoint = <&etf_out_port>;
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/Makefile b/arch/arm64/boot/dts/freescale/overlays/Makefile
new file mode 100644
index 000000000..4ffad13ad
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/Makefile
@@ -0,0 +1,15 @@
+dtbo-$(CONFIG_ARCH_MXC) += \
+	eg5120-kza-zaa.dtbo \
+	eg5120-if-can1.dtbo \
+	eg5120-if-uart1-rs232.dtbo \
+	eg5120-if-uart1-rs485.dtbo \
+	eg5120-if-uart3-rs232.dtbo \
+	eg5120-if-uart3-rs485.dtbo \
+	eg5120-wireless-wifi5.dtbo \
+	eg5120-wireless-lora.dtbo	
+
+targets += dtbs dtbs_install
+targets += $(dtbo-y)
+
+always          := $(dtbo-y)
+clean-files     := *.dtbo
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-if-can1-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-can1-overlay.dts
new file mode 100644
index 000000000..bc469e747
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-can1-overlay.dts
@@ -0,0 +1,17 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+        /* flexcan1 */
+        fragment@1 {
+                target = <&flexcan1>;
+                __overlay__ {
+                        status = "okay";
+                };
+        };
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs232-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs232-overlay.dts
new file mode 100644
index 000000000..3af9ad4a1
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs232-overlay.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+        /* rs232 */
+        fragment@1 {
+                target = <&uart1>;
+                __overlay__ {
+                        pinctrl-names = "default";
+                        pinctrl-0 = <&pinctrl_uart1_rs232>;
+                        assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+                        assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+                        dmas = <&sdma1 22 4 0>, <&sdma1 23 4 0>;
+                        dma-names = "rx", "tx";
+                        status = "okay";
+                };
+        };
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs485-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs485-overlay.dts
new file mode 100644
index 000000000..553da9d58
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart1-rs485-overlay.dts
@@ -0,0 +1,25 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+        /* rs485 */
+        fragment@1 {
+                target = <&uart1>;
+                __overlay__ {
+                        pinctrl-names = "default";
+                        pinctrl-0 = <&pinctrl_uart1_rs485>;
+                        assigned-clocks = <&clk IMX8MP_CLK_UART1>;
+                        assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+                        dmas = <&sdma1 22 4 0>, <&sdma1 23 4 0>;
+                        rts-gpios = <&gpio5 27 GPIO_ACTIVE_HIGH>;
+                        linux,rs485-enabled-at-boot-time;
+                        dma-names = "rx", "tx";
+                        status = "okay";
+                };
+        };
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs232-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs232-overlay.dts
new file mode 100644
index 000000000..c25580d27
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs232-overlay.dts
@@ -0,0 +1,25 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {     
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+        
+        /* rs232 */
+        fragment@1 {
+                target = <&uart3>;
+                __overlay__ {
+                        pinctrl-names = "default";
+                        pinctrl-0 = <&pinctrl_uart3_rs232>;
+                        assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+                        assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+                        dmas = <&sdma1 26 4 0>, <&sdma1 27 4 0>;
+                        dma-names = "rx", "tx";
+                        fsl,dte-mode;
+                        status = "okay";
+                };
+        };
+
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs485-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs485-overlay.dts
new file mode 100644
index 000000000..bd8592e4e
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-if-uart3-rs485-overlay.dts
@@ -0,0 +1,27 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {     
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+        
+        /* rs485 */
+        fragment@1 {
+                target = <&uart3>;
+                __overlay__ {
+                        pinctrl-names = "default";
+                        pinctrl-0 = <&pinctrl_uart3_rs485>;
+                        assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+                        assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
+                        rts-gpios = <&gpio2 11 GPIO_ACTIVE_HIGH>;
+                        dmas = <&sdma1 26 4 0>, <&sdma1 27 4 0>;
+                        dma-names = "rx", "tx";
+                        fsl,dte-mode;
+                        linux,rs485-enabled-at-boot-time;
+                        status = "okay";
+                };
+        };
+
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-kza-zaa-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-kza-zaa-overlay.dts
new file mode 100644
index 000000000..0009c49bd
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-kza-zaa-overlay.dts
@@ -0,0 +1,65 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	fragment@1 {
+                target = <&eqos>;
+                __overlay__ {
+			status = "okay";
+        
+		};
+	};
+
+	/* 2*DI & 2*DO */
+        fragment@2 {
+                target-path = "/";
+                __overlay__ {
+                        gpio_keys@2 {
+                                compatible = "gpio-keys";
+                                pinctrl-names = "default";
+                       		pinctrl-0 = <&pinctrl_a2aaz_dido>;
+				status = "okay";
+
+                                di_1 {
+                                        label = "di_1";
+                                        gpios = <&gpio5 10 GPIO_ACTIVE_HIGH>;
+                                        linux,code = <0x184>;
+                                        gpio-key,wakeup;
+                                };
+                        };
+
+			gpio_keys@3 {
+                                compatible = "gpio-keys";
+                                status = "okay";
+
+                                di_2 {
+                                        label = "di_2";
+                                        gpios = <&gpio5 13 GPIO_ACTIVE_HIGH>;
+                                        linux,code = <0x185>;
+                                        gpio-key,wakeup;
+                                };
+                        };
+
+			
+			dout3_leds {
+                                compatible = "gpio-leds";
+
+                                do1-led {
+                                        label = "do1";
+                                        gpios = <&gpio5 11 0>;
+                                };
+				
+				do2-led {
+                                        label = "do2";
+                                        gpios = <&gpio5 12 0>;
+                                };
+                        };  
+                };
+        };
+
+};
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-lora-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-lora-overlay.dts
new file mode 100644
index 000000000..6e535b23a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-lora-overlay.dts
@@ -0,0 +1,44 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+        /* M.2 ECSPI */
+        fragment@1 {
+                target = <&ecspi1>;
+                __overlay__ {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        pinctrl-names = "default";
+                        pinctrl-0 = <&pinctrl_ecspi1>;
+                        cs-gpios = <&gpio5 9 GPIO_ACTIVE_HIGH
+        		            &gpio5 8 GPIO_ACTIVE_HIGH>;
+                        status = "okay";
+
+                        spidev1: spi@0 {
+                                compatible = "spidev";
+                                reg = <0>;
+                                spi-max-frequency = <60000000>;
+                        };
+
+                        spidev2: spi@1 {
+                                compatible = "spidev";
+                                reg = <1>;
+                                spi-max-frequency = <60000000>;
+                        };
+                };
+        };
+
+        /* M.2 UART */
+        fragment@2 {
+                target = <&uart4>;
+                __overlay__ {
+                        status = "okay";
+                };
+        };
+};
+
diff --git a/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-wifi5-overlay.dts b/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-wifi5-overlay.dts
new file mode 100644
index 000000000..7d89d2772
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/overlays/eg5120-wireless-wifi5-overlay.dts
@@ -0,0 +1,29 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/clock/imx8mp-clock.h>
+
+/ {
+        compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
+
+	/* M.2 SDIO */
+        fragment@0 {
+                target = <&usdhc2>;
+                __overlay__ {
+			non-removable;
+			fsl,sdio-interrupt-enabled;
+			max-frequency = <100000000>;
+                        status = "okay";
+                };
+        };
+
+        /* M.2 UART */
+        fragment@2 {
+                target = <&uart4>;
+                __overlay__ {
+                        status = "okay";
+                };
+        };
+};
+
diff --git a/arch/arm64/configs/imx8mp_eg5120_defconfig b/arch/arm64/configs/imx8mp_eg5120_defconfig
new file mode 100644
index 000000000..703e6a5d4
--- /dev/null
+++ b/arch/arm64/configs/imx8mp_eg5120_defconfig
@@ -0,0 +1,6594 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm64 5.4.70 Kernel Configuration
+#
+
+#
+# Compiler: aarch64-poky-linux-gcc (GCC) 9.2.0
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=90200
+CONFIG_CLANG_VERSION=0
+CONFIG_CC_HAS_ASM_GOTO=y
+CONFIG_CC_HAS_ASM_INLINE=y
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+CONFIG_THREAD_INFO_IN_TASK=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+CONFIG_AUDIT=y
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+CONFIG_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_GENERIC_IRQ_MIGRATION=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_GENERIC_MSI_IRQ=y
+CONFIG_GENERIC_MSI_IRQ_DOMAIN=y
+CONFIG_IRQ_MSI_IOMMU=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+# CONFIG_GENERIC_IRQ_DEBUGFS is not set
+# end of IRQ subsystem
+
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_ARCH_HAS_TICK_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+# CONFIG_NO_HZ is not set
+CONFIG_HIGH_RES_TIMERS=y
+# end of Timers subsystem
+
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_COUNT=y
+CONFIG_PREEMPTION=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_SCHED_AVG_IRQ=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+# CONFIG_PSI is not set
+# end of CPU/Task time and stats accounting
+
+CONFIG_CPU_ISOLATION=y
+
+#
+# RCU Subsystem
+#
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TREE_SRCU=y
+CONFIG_TASKS_RCU=y
+CONFIG_RCU_STALL_COMMON=y
+CONFIG_RCU_NEED_SEGCBLIST=y
+# end of RCU Subsystem
+
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_IKHEADERS is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_LOG_CPU_MAX_BUF_SHIFT=12
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+
+#
+# Scheduler features
+#
+# CONFIG_UCLAMP_TASK is not set
+# end of Scheduler features
+
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_SUPPORTS_INT128=y
+CONFIG_NUMA_BALANCING=y
+CONFIG_NUMA_BALANCING_DEFAULT_ENABLED=y
+CONFIG_CGROUPS=y
+CONFIG_PAGE_COUNTER=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_MEMCG_SWAP_ENABLED=y
+CONFIG_MEMCG_KMEM=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_WRITEBACK=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_PIDS=y
+# CONFIG_CGROUP_RDMA is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_CGROUP_BPF=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_SOCK_CGROUP_DATA=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+# CONFIG_RD_LZ4 is not set
+CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_BPF=y
+# CONFIG_EXPERT is not set
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+CONFIG_SYSFS_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_IO_URING=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_BPF_JIT_ALWAYS_ON=y
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+# end of Kernel Performance Events And Counters
+
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_SLAB_FREELIST_HARDENED is not set
+# CONFIG_SHUFFLE_PAGE_ALLOCATOR is not set
+CONFIG_SLUB_CPU_PARTIAL=y
+CONFIG_SYSTEM_DATA_VERIFICATION=y
+CONFIG_PROFILING=y
+# end of General setup
+
+CONFIG_ARM64=y
+CONFIG_64BIT=y
+CONFIG_MMU=y
+CONFIG_ARM64_PAGE_SHIFT=12
+CONFIG_ARM64_CONT_SHIFT=4
+CONFIG_ARCH_MMAP_RND_BITS_MIN=18
+CONFIG_ARCH_MMAP_RND_BITS_MAX=33
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MIN=11
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS_MAX=16
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CSUM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ZONE_DMA32=y
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_SMP=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_PGTABLE_LEVELS=4
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+
+#
+# Platform selection
+#
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_AGILEX is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_BCM2835 is not set
+# CONFIG_ARCH_BCM_IPROC is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_BITMAIN is not set
+# CONFIG_ARCH_BRCMSTB is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_K3 is not set
+# CONFIG_ARCH_LAYERSCAPE is not set
+# CONFIG_ARCH_LG1K is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MVEBU is not set
+CONFIG_ARCH_MXC=y
+CONFIG_HAVE_IMX_BUSFREQ=y
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALTEK is not set
+# CONFIG_ARCH_RENESAS is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S32 is not set
+# CONFIG_ARCH_SEATTLE is not set
+# CONFIG_ARCH_STRATIX10 is not set
+# CONFIG_ARCH_SYNQUACER is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_SPRD is not set
+# CONFIG_ARCH_THUNDER is not set
+# CONFIG_ARCH_THUNDER2 is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_XGENE is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQMP is not set
+# end of Platform selection
+
+#
+# Kernel Features
+#
+
+#
+# ARM errata workarounds via the alternatives framework
+#
+CONFIG_ARM64_WORKAROUND_CLEAN_CACHE=y
+CONFIG_ARM64_ERRATUM_826319=y
+CONFIG_ARM64_ERRATUM_827319=y
+CONFIG_ARM64_ERRATUM_824069=y
+CONFIG_ARM64_ERRATUM_819472=y
+CONFIG_ARM64_ERRATUM_832075=y
+CONFIG_ARM64_ERRATUM_834220=y
+CONFIG_ARM64_ERRATUM_845719=y
+CONFIG_ARM64_ERRATUM_843419=y
+CONFIG_ARM64_ERRATUM_1024718=y
+CONFIG_ARM64_ERRATUM_1418040=y
+CONFIG_ARM64_ERRATUM_1165522=y
+CONFIG_ARM64_ERRATUM_1286807=y
+CONFIG_ARM64_ERRATUM_1463225=y
+CONFIG_ARM64_ERRATUM_1542419=y
+CONFIG_CAVIUM_ERRATUM_22375=y
+CONFIG_CAVIUM_ERRATUM_23144=y
+CONFIG_CAVIUM_ERRATUM_23154=y
+CONFIG_CAVIUM_ERRATUM_27456=y
+CONFIG_CAVIUM_ERRATUM_30115=y
+CONFIG_CAVIUM_TX2_ERRATUM_219=y
+CONFIG_QCOM_FALKOR_ERRATUM_1003=y
+CONFIG_ARM64_WORKAROUND_REPEAT_TLBI=y
+CONFIG_QCOM_FALKOR_ERRATUM_1009=y
+CONFIG_QCOM_QDF2400_ERRATUM_0065=y
+CONFIG_SOCIONEXT_SYNQUACER_PREITS=y
+CONFIG_HISILICON_ERRATUM_161600802=y
+CONFIG_QCOM_FALKOR_ERRATUM_E1041=y
+CONFIG_FUJITSU_ERRATUM_010001=y
+# end of ARM errata workarounds via the alternatives framework
+
+CONFIG_ARM64_4K_PAGES=y
+# CONFIG_ARM64_16K_PAGES is not set
+# CONFIG_ARM64_64K_PAGES is not set
+# CONFIG_ARM64_VA_BITS_39 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_ARM64_VA_BITS=48
+CONFIG_ARM64_PA_BITS_48=y
+CONFIG_ARM64_PA_BITS=48
+# CONFIG_CPU_BIG_ENDIAN is not set
+CONFIG_SCHED_MC=y
+# CONFIG_SCHED_SMT is not set
+CONFIG_NR_CPUS=256
+CONFIG_HOTPLUG_CPU=y
+CONFIG_NUMA=y
+CONFIG_NODES_SHIFT=2
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_HOLES_IN_ZONE=y
+# CONFIG_HZ_100 is not set
+CONFIG_HZ_250=y
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=250
+CONFIG_SCHED_HRTICK=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+CONFIG_HW_PERF_EVENTS=y
+CONFIG_SYS_SUPPORTS_HUGETLBFS=y
+CONFIG_ARCH_WANT_HUGE_PMD_SHARE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_ENABLE_SPLIT_PMD_PTLOCK=y
+CONFIG_SECCOMP=y
+CONFIG_PARAVIRT=y
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+CONFIG_KEXEC=y
+# CONFIG_KEXEC_FILE is not set
+CONFIG_CRASH_DUMP=y
+CONFIG_XEN_DOM0=y
+CONFIG_XEN=y
+CONFIG_FORCE_MAX_ZONEORDER=14
+CONFIG_UNMAP_KERNEL_AT_EL0=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_HARDEN_EL2_VECTORS=y
+CONFIG_ARM64_SSBD=y
+CONFIG_RODATA_FULL_DEFAULT_ENABLED=y
+# CONFIG_ARM64_SW_TTBR0_PAN is not set
+CONFIG_ARM64_TAGGED_ADDR_ABI=y
+CONFIG_COMPAT=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_ARMV8_DEPRECATED is not set
+
+#
+# ARMv8.1 architectural features
+#
+CONFIG_ARM64_HW_AFDBM=y
+CONFIG_ARM64_PAN=y
+CONFIG_ARM64_LSE_ATOMICS=y
+CONFIG_ARM64_VHE=y
+# end of ARMv8.1 architectural features
+
+#
+# ARMv8.2 architectural features
+#
+CONFIG_ARM64_UAO=y
+# CONFIG_ARM64_PMEM is not set
+CONFIG_ARM64_RAS_EXTN=y
+CONFIG_ARM64_CNP=y
+# end of ARMv8.2 architectural features
+
+#
+# ARMv8.3 architectural features
+#
+CONFIG_ARM64_PTR_AUTH=y
+# end of ARMv8.3 architectural features
+
+CONFIG_ARM64_SVE=y
+CONFIG_ARM64_MODULE_PLTS=y
+# CONFIG_ARM64_PSEUDO_NMI is not set
+CONFIG_RELOCATABLE=y
+CONFIG_RANDOMIZE_BASE=y
+CONFIG_RANDOMIZE_MODULE_REGION_FULL=y
+CONFIG_CC_HAVE_STACKPROTECTOR_SYSREG=y
+CONFIG_STACKPROTECTOR_PER_TASK=y
+# end of Kernel Features
+
+#
+# Boot options
+#
+CONFIG_CMDLINE=""
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_EFI is not set
+# end of Boot options
+
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION=y
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+CONFIG_PM_DEBUG=y
+# CONFIG_PM_ADVANCED_DEBUG is not set
+CONFIG_PM_TEST_SUSPEND=y
+CONFIG_PM_SLEEP_DEBUG=y
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+# CONFIG_ENERGY_MODEL is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# end of Power management options
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Idle
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+# CONFIG_CPU_IDLE_GOV_LADDER is not set
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_CPU_IDLE_GOV_TEO is not set
+CONFIG_DT_IDLE_STATES=y
+
+#
+# ARM CPU Idle Drivers
+#
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+# end of ARM CPU Idle Drivers
+# end of CPU Idle
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_SCHEDUTIL is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+
+#
+# CPU frequency scaling drivers
+#
+CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+CONFIG_ARM_SCPI_CPUFREQ=y
+CONFIG_ARM_IMX_CPUFREQ_DT=y
+# CONFIG_ARM_IMX7ULP_CPUFREQ is not set
+CONFIG_QORIQ_CPUFREQ=y
+# end of CPU Frequency scaling
+# end of CPU Power Management
+
+#
+# Firmware Drivers
+#
+# CONFIG_ARM_SCMI_PROTOCOL is not set
+CONFIG_ARM_SCPI_PROTOCOL=y
+CONFIG_ARM_SCPI_POWER_DOMAIN=y
+# CONFIG_ARM_SDE_INTERFACE is not set
+# CONFIG_FW_CFG_SYSFS is not set
+CONFIG_HAVE_ARM_SMCCC=y
+CONFIG_ARM_PSCI_FW=y
+# CONFIG_ARM_PSCI_CHECKER is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+CONFIG_EFI_EARLYCON=y
+CONFIG_IMX_DSP=y
+CONFIG_IMX_SCU=y
+CONFIG_IMX_SCU_PD=y
+CONFIG_IMX_SECO_MU=y
+
+#
+# Tegra firmware driver
+#
+# end of Tegra firmware driver
+# end of Firmware Drivers
+
+CONFIG_HAVE_KVM_IRQCHIP=y
+CONFIG_HAVE_KVM_IRQFD=y
+CONFIG_HAVE_KVM_IRQ_ROUTING=y
+CONFIG_HAVE_KVM_EVENTFD=y
+CONFIG_KVM_MMIO=y
+CONFIG_HAVE_KVM_MSI=y
+CONFIG_HAVE_KVM_CPU_RELAX_INTERCEPT=y
+CONFIG_KVM_VFIO=y
+CONFIG_HAVE_KVM_ARCH_TLB_FLUSH_ALL=y
+CONFIG_KVM_GENERIC_DIRTYLOG_READ_PROTECT=y
+CONFIG_HAVE_KVM_IRQ_BYPASS=y
+CONFIG_HAVE_KVM_VCPU_RUN_PID_CHANGE=y
+CONFIG_IRQ_BYPASS_MANAGER=y
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_KVM_ARM_HOST=y
+CONFIG_KVM_ARM_PMU=y
+CONFIG_KVM_INDIRECT_VECTORS=y
+# CONFIG_VHOST_NET is not set
+# CONFIG_VHOST_CROSS_ENDIAN_LEGACY is not set
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA256_ARM64=y
+CONFIG_CRYPTO_SHA512_ARM64=m
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_SHA512_ARM64_CE=m
+CONFIG_CRYPTO_SHA3_ARM64=m
+CONFIG_CRYPTO_SM3_ARM64_CE=m
+# CONFIG_CRYPTO_SM4_ARM64_CE is not set
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_CRCT10DIF_ARM64_CE=m
+CONFIG_CRYPTO_AES_ARM64=y
+CONFIG_CRYPTO_AES_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_AES_ARM64_NEON_BLK=m
+CONFIG_CRYPTO_CHACHA20_NEON=y
+# CONFIG_CRYPTO_NHPOLY1305_NEON is not set
+CONFIG_CRYPTO_AES_ARM64_BS=m
+
+#
+# General architecture-dependent options
+#
+CONFIG_CRASH_CORE=y
+CONFIG_KEXEC_CORE=y
+# CONFIG_KPROBES is not set
+CONFIG_JUMP_LABEL=y
+# CONFIG_STATIC_KEYS_SELFTEST is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_FUNCTION_ERROR_INJECTION=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_KEEPINITRD=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_ARCH_HAS_SET_DIRECT_MAP=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_ASM_MODVERSIONS=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_FUNCTION_ARG_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE=y
+CONFIG_HAVE_RCU_TABLE_FREE=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_STACKLEAK=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_HAVE_ARCH_HUGE_VMAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS=18
+CONFIG_HAVE_ARCH_MMAP_RND_COMPAT_BITS=y
+CONFIG_ARCH_MMAP_RND_COMPAT_BITS=11
+CONFIG_ARCH_WANT_DEFAULT_TOPDOWN_MMAP_LAYOUT=y
+CONFIG_HAVE_COPY_THREAD_TLS=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+CONFIG_64BIT_TIME=y
+CONFIG_COMPAT_32BIT_TIME=y
+CONFIG_HAVE_ARCH_VMAP_STACK=y
+CONFIG_VMAP_STACK=y
+CONFIG_ARCH_HAS_STRICT_KERNEL_RWX=y
+CONFIG_STRICT_KERNEL_RWX=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_STRICT_MODULE_RWX=y
+CONFIG_REFCOUNT_FULL=y
+CONFIG_HAVE_ARCH_PREL32_RELOCATIONS=y
+CONFIG_ARCH_USE_MEMREMAP_PROT=y
+# CONFIG_LOCK_EVENT_COUNTS is not set
+CONFIG_ARCH_HAS_RELR=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+# end of GCOV-based kernel profiling
+
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+# end of General architecture-dependent options
+
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_ASM_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_MODULE_SIG is not set
+# CONFIG_MODULE_COMPRESS is not set
+# CONFIG_MODULE_ALLOW_MISSING_NAMESPACE_IMPORTS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_TRIM_UNUSED_KSYMS is not set
+CONFIG_MODULES_TREE_LOOKUP=y
+CONFIG_BLOCK=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_BLK_DEV_ZONED is not set
+CONFIG_BLK_DEV_THROTTLING=y
+# CONFIG_BLK_DEV_THROTTLING_LOW is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_CGROUP_IOLATENCY is not set
+# CONFIG_BLK_CGROUP_IOCOST is not set
+CONFIG_BLK_DEBUG_FS=y
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# end of Partition Types
+
+CONFIG_BLOCK_COMPAT=y
+CONFIG_BLK_MQ_PCI=y
+CONFIG_BLK_MQ_VIRTIO=y
+CONFIG_BLK_PM=y
+
+#
+# IO Schedulers
+#
+CONFIG_MQ_IOSCHED_DEADLINE=y
+CONFIG_MQ_IOSCHED_KYBER=y
+CONFIG_IOSCHED_BFQ=y
+CONFIG_BFQ_GROUP_IOSCHED=y
+# CONFIG_BFQ_CGROUP_DEBUG is not set
+# end of IO Schedulers
+
+CONFIG_PREEMPT_NOTIFIERS=y
+CONFIG_ASN1=y
+CONFIG_UNINLINE_SPIN_UNLOCK=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_RWSEM_SPIN_ON_OWNER=y
+CONFIG_LOCK_SPIN_ON_OWNER=y
+CONFIG_ARCH_USE_QUEUED_SPINLOCKS=y
+CONFIG_QUEUED_SPINLOCKS=y
+CONFIG_ARCH_USE_QUEUED_RWLOCKS=y
+CONFIG_QUEUED_RWLOCKS=y
+CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ELFCORE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+# end of Executable file formats
+
+#
+# Memory Management options
+#
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_FAST_GUP=y
+CONFIG_ARCH_KEEP_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_MEMORY_BALLOON=y
+CONFIG_BALLOON_COMPACTION=y
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_CONTIG_ALLOC=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_MMU_NOTIFIER=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_TRANSPARENT_HUGEPAGE_ALWAYS=y
+# CONFIG_TRANSPARENT_HUGEPAGE_MADVISE is not set
+CONFIG_TRANSPARENT_HUGE_PAGECACHE=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_CMA=y
+# CONFIG_CMA_DEBUG is not set
+# CONFIG_CMA_DEBUGFS is not set
+CONFIG_CMA_AREAS=7
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_DEFERRED_STRUCT_PAGE_INIT is not set
+# CONFIG_IDLE_PAGE_TRACKING is not set
+CONFIG_ARCH_HAS_PTE_DEVMAP=y
+CONFIG_FRAME_VECTOR=y
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
+# CONFIG_READ_ONLY_THP_FOR_FS is not set
+CONFIG_ARCH_HAS_PTE_SPECIAL=y
+# end of Memory Management options
+
+CONFIG_NET=y
+CONFIG_COMPAT_NETLINK_MESSAGES=y
+CONFIG_NET_INGRESS=y
+CONFIG_SKB_EXTENSIONS=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+CONFIG_UNIX_SCM=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+CONFIG_XFRM_OFFLOAD=y
+CONFIG_XFRM_ALGO=y
+CONFIG_XFRM_USER=y
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_XFRM_IPCOMP=y
+# CONFIG_NET_KEY is not set
+# CONFIG_XDP_SOCKETS is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_MULTIPATH is not set
+# CONFIG_IP_ROUTE_VERBOSE is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+CONFIG_NET_IPIP=y
+CONFIG_NET_IPGRE_DEMUX=y
+CONFIG_NET_IP_TUNNEL=y
+CONFIG_NET_IPGRE=y
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_IP_MROUTE_COMMON=y
+CONFIG_IP_MROUTE=y
+CONFIG_IP_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+CONFIG_SYN_COOKIES=y
+# CONFIG_NET_IPVTI is not set
+CONFIG_NET_UDP_TUNNEL=y
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_ESP_OFFLOAD=y
+CONFIG_INET_IPCOMP=y
+CONFIG_INET_XFRM_TUNNEL=y
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+CONFIG_INET_UDP_DIAG=y
+CONFIG_INET_RAW_DIAG=y
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+CONFIG_INET6_AH=y
+CONFIG_INET6_ESP=y
+CONFIG_INET6_ESP_OFFLOAD=y
+CONFIG_INET6_IPCOMP=y
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_IPV6_ILA is not set
+CONFIG_INET6_XFRM_TUNNEL=y
+CONFIG_INET6_TUNNEL=y
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+CONFIG_IPV6_TUNNEL=y
+CONFIG_IPV6_GRE=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_MROUTE=y
+CONFIG_IPV6_MROUTE_MULTIPLE_TABLES=y
+CONFIG_IPV6_PIMSM_V2=y
+CONFIG_IPV6_SEG6_LWTUNNEL=y
+CONFIG_IPV6_SEG6_HMAC=y
+CONFIG_IPV6_SEG6_BPF=y
+# CONFIG_NETLABEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_ADVANCED=y
+CONFIG_BRIDGE_NETFILTER=m
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_INGRESS=y
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_FAMILY_BRIDGE=y
+# CONFIG_NETFILTER_NETLINK_ACCT is not set
+# CONFIG_NETFILTER_NETLINK_QUEUE is not set
+# CONFIG_NETFILTER_NETLINK_LOG is not set
+CONFIG_NETFILTER_NETLINK_OSF=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_LOG_COMMON=y
+# CONFIG_NF_LOG_NETDEV is not set
+CONFIG_NETFILTER_CONNCOUNT=y
+CONFIG_NF_CONNTRACK_MARK=y
+# CONFIG_NF_CONNTRACK_ZONES is not set
+CONFIG_NF_CONNTRACK_PROCFS=y
+# CONFIG_NF_CONNTRACK_EVENTS is not set
+# CONFIG_NF_CONNTRACK_TIMEOUT is not set
+# CONFIG_NF_CONNTRACK_TIMESTAMP is not set
+# CONFIG_NF_CONNTRACK_LABELS is not set
+CONFIG_NF_CT_PROTO_DCCP=y
+CONFIG_NF_CT_PROTO_GRE=y
+CONFIG_NF_CT_PROTO_SCTP=y
+CONFIG_NF_CT_PROTO_UDPLITE=y
+# CONFIG_NF_CONNTRACK_AMANDA is not set
+CONFIG_NF_CONNTRACK_FTP=y
+# CONFIG_NF_CONNTRACK_H323 is not set
+# CONFIG_NF_CONNTRACK_IRC is not set
+# CONFIG_NF_CONNTRACK_NETBIOS_NS is not set
+# CONFIG_NF_CONNTRACK_SNMP is not set
+CONFIG_NF_CONNTRACK_PPTP=y
+# CONFIG_NF_CONNTRACK_SANE is not set
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CONNTRACK_TFTP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_SIP=y
+CONFIG_NF_NAT_TFTP=y
+CONFIG_NF_NAT_REDIRECT=y
+CONFIG_NF_NAT_MASQUERADE=y
+CONFIG_NETFILTER_SYNPROXY=y
+CONFIG_NF_TABLES=y
+CONFIG_NF_TABLES_SET=y
+CONFIG_NF_TABLES_INET=y
+CONFIG_NF_TABLES_NETDEV=y
+CONFIG_NFT_NUMGEN=y
+CONFIG_NFT_CT=y
+# CONFIG_NFT_FLOW_OFFLOAD is not set
+CONFIG_NFT_COUNTER=y
+CONFIG_NFT_CONNLIMIT=y
+CONFIG_NFT_LOG=y
+CONFIG_NFT_LIMIT=y
+CONFIG_NFT_MASQ=y
+CONFIG_NFT_REDIR=y
+CONFIG_NFT_NAT=y
+CONFIG_NFT_TUNNEL=y
+CONFIG_NFT_OBJREF=y
+CONFIG_NFT_QUOTA=y
+CONFIG_NFT_REJECT=y
+CONFIG_NFT_REJECT_INET=y
+CONFIG_NFT_COMPAT=y
+CONFIG_NFT_HASH=y
+CONFIG_NFT_XFRM=y
+CONFIG_NFT_SOCKET=y
+CONFIG_NFT_OSF=y
+CONFIG_NFT_TPROXY=y
+CONFIG_NFT_SYNPROXY=y
+# CONFIG_NF_DUP_NETDEV is not set
+# CONFIG_NFT_DUP_NETDEV is not set
+# CONFIG_NFT_FWD_NETDEV is not set
+# CONFIG_NF_FLOW_TABLE_INET is not set
+CONFIG_NF_FLOW_TABLE=y
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+CONFIG_NETFILTER_XT_MARK=y
+CONFIG_NETFILTER_XT_CONNMARK=y
+# CONFIG_NETFILTER_XT_SET is not set
+
+#
+# Xtables targets
+#
+# CONFIG_NETFILTER_XT_TARGET_AUDIT is not set
+CONFIG_NETFILTER_XT_TARGET_CHECKSUM=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=y
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=y
+CONFIG_NETFILTER_XT_TARGET_CT=y
+# CONFIG_NETFILTER_XT_TARGET_DSCP is not set
+# CONFIG_NETFILTER_XT_TARGET_HL is not set
+# CONFIG_NETFILTER_XT_TARGET_HMARK is not set
+# CONFIG_NETFILTER_XT_TARGET_IDLETIMER is not set
+# CONFIG_NETFILTER_XT_TARGET_LED is not set
+CONFIG_NETFILTER_XT_TARGET_LOG=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_NAT=y
+# CONFIG_NETFILTER_XT_TARGET_NETMAP is not set
+# CONFIG_NETFILTER_XT_TARGET_NFLOG is not set
+# CONFIG_NETFILTER_XT_TARGET_NFQUEUE is not set
+# CONFIG_NETFILTER_XT_TARGET_NOTRACK is not set
+# CONFIG_NETFILTER_XT_TARGET_RATEEST is not set
+CONFIG_NETFILTER_XT_TARGET_REDIRECT=y
+CONFIG_NETFILTER_XT_TARGET_MASQUERADE=y
+# CONFIG_NETFILTER_XT_TARGET_TEE is not set
+# CONFIG_NETFILTER_XT_TARGET_TPROXY is not set
+# CONFIG_NETFILTER_XT_TARGET_TRACE is not set
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+# CONFIG_NETFILTER_XT_TARGET_TCPOPTSTRIP is not set
+
+#
+# Xtables matches
+#
+CONFIG_NETFILTER_XT_MATCH_ADDRTYPE=y
+CONFIG_NETFILTER_XT_MATCH_BPF=y
+# CONFIG_NETFILTER_XT_MATCH_CGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_CLUSTER is not set
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+# CONFIG_NETFILTER_XT_MATCH_CONNBYTES is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLABEL is not set
+# CONFIG_NETFILTER_XT_MATCH_CONNLIMIT is not set
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+# CONFIG_NETFILTER_XT_MATCH_CPU is not set
+# CONFIG_NETFILTER_XT_MATCH_DCCP is not set
+# CONFIG_NETFILTER_XT_MATCH_DEVGROUP is not set
+# CONFIG_NETFILTER_XT_MATCH_DSCP is not set
+# CONFIG_NETFILTER_XT_MATCH_ECN is not set
+# CONFIG_NETFILTER_XT_MATCH_ESP is not set
+# CONFIG_NETFILTER_XT_MATCH_HASHLIMIT is not set
+# CONFIG_NETFILTER_XT_MATCH_HELPER is not set
+# CONFIG_NETFILTER_XT_MATCH_HL is not set
+# CONFIG_NETFILTER_XT_MATCH_IPCOMP is not set
+CONFIG_NETFILTER_XT_MATCH_IPRANGE=y
+CONFIG_NETFILTER_XT_MATCH_IPVS=y
+CONFIG_NETFILTER_XT_MATCH_L2TP=y
+# CONFIG_NETFILTER_XT_MATCH_LENGTH is not set
+CONFIG_NETFILTER_XT_MATCH_LIMIT=y
+CONFIG_NETFILTER_XT_MATCH_MAC=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=y
+# CONFIG_NETFILTER_XT_MATCH_NFACCT is not set
+# CONFIG_NETFILTER_XT_MATCH_OSF is not set
+# CONFIG_NETFILTER_XT_MATCH_OWNER is not set
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+# CONFIG_NETFILTER_XT_MATCH_PHYSDEV is not set
+# CONFIG_NETFILTER_XT_MATCH_PKTTYPE is not set
+# CONFIG_NETFILTER_XT_MATCH_QUOTA is not set
+# CONFIG_NETFILTER_XT_MATCH_RATEEST is not set
+# CONFIG_NETFILTER_XT_MATCH_REALM is not set
+# CONFIG_NETFILTER_XT_MATCH_RECENT is not set
+# CONFIG_NETFILTER_XT_MATCH_SCTP is not set
+# CONFIG_NETFILTER_XT_MATCH_SOCKET is not set
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=y
+CONFIG_NETFILTER_XT_MATCH_STRING=y
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_TIME=y
+# CONFIG_NETFILTER_XT_MATCH_U32 is not set
+# end of Core Netfilter Configuration
+
+CONFIG_IP_SET=y
+CONFIG_IP_SET_MAX=256
+# CONFIG_IP_SET_BITMAP_IP is not set
+# CONFIG_IP_SET_BITMAP_IPMAC is not set
+# CONFIG_IP_SET_BITMAP_PORT is not set
+CONFIG_IP_SET_HASH_IP=y
+CONFIG_IP_SET_HASH_IPMARK=y
+CONFIG_IP_SET_HASH_IPPORT=y
+CONFIG_IP_SET_HASH_IPPORTIP=y
+CONFIG_IP_SET_HASH_IPPORTNET=y
+CONFIG_IP_SET_HASH_IPMAC=y
+CONFIG_IP_SET_HASH_MAC=y
+CONFIG_IP_SET_HASH_NETPORTNET=y
+CONFIG_IP_SET_HASH_NET=y
+CONFIG_IP_SET_HASH_NETNET=y
+CONFIG_IP_SET_HASH_NETPORT=y
+CONFIG_IP_SET_HASH_NETIFACE=y
+CONFIG_IP_SET_LIST_SET=y
+CONFIG_IP_VS=y
+# CONFIG_IP_VS_IPV6 is not set
+# CONFIG_IP_VS_DEBUG is not set
+CONFIG_IP_VS_TAB_BITS=12
+
+#
+# IPVS transport protocol load balancing support
+#
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_IP_VS_PROTO_UDP=y
+# CONFIG_IP_VS_PROTO_ESP is not set
+# CONFIG_IP_VS_PROTO_AH is not set
+# CONFIG_IP_VS_PROTO_SCTP is not set
+
+#
+# IPVS scheduler
+#
+CONFIG_IP_VS_RR=y
+# CONFIG_IP_VS_WRR is not set
+# CONFIG_IP_VS_LC is not set
+# CONFIG_IP_VS_WLC is not set
+# CONFIG_IP_VS_FO is not set
+# CONFIG_IP_VS_OVF is not set
+# CONFIG_IP_VS_LBLC is not set
+# CONFIG_IP_VS_LBLCR is not set
+# CONFIG_IP_VS_DH is not set
+# CONFIG_IP_VS_SH is not set
+# CONFIG_IP_VS_MH is not set
+# CONFIG_IP_VS_SED is not set
+# CONFIG_IP_VS_NQ is not set
+
+#
+# IPVS SH scheduler
+#
+CONFIG_IP_VS_SH_TAB_BITS=8
+
+#
+# IPVS MH scheduler
+#
+CONFIG_IP_VS_MH_TAB_INDEX=12
+
+#
+# IPVS application helper
+#
+# CONFIG_IP_VS_FTP is not set
+CONFIG_IP_VS_NFCT=y
+# CONFIG_IP_VS_PE_SIP is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_SOCKET_IPV4=y
+CONFIG_NF_TPROXY_IPV4=y
+CONFIG_NF_TABLES_IPV4=y
+CONFIG_NFT_REJECT_IPV4=y
+# CONFIG_NFT_DUP_IPV4 is not set
+# CONFIG_NFT_FIB_IPV4 is not set
+# CONFIG_NF_TABLES_ARP is not set
+# CONFIG_NF_FLOW_TABLE_IPV4 is not set
+# CONFIG_NF_DUP_IPV4 is not set
+# CONFIG_NF_LOG_ARP is not set
+CONFIG_NF_LOG_IPV4=y
+CONFIG_NF_REJECT_IPV4=y
+CONFIG_NF_NAT_PPTP=y
+CONFIG_IP_NF_IPTABLES=y
+# CONFIG_IP_NF_MATCH_AH is not set
+# CONFIG_IP_NF_MATCH_ECN is not set
+# CONFIG_IP_NF_MATCH_RPFILTER is not set
+# CONFIG_IP_NF_MATCH_TTL is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_SYNPROXY is not set
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+# CONFIG_IP_NF_TARGET_NETMAP is not set
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_TARGET_CLUSTERIP is not set
+# CONFIG_IP_NF_TARGET_ECN is not set
+# CONFIG_IP_NF_TARGET_TTL is not set
+CONFIG_IP_NF_RAW=y
+# CONFIG_IP_NF_SECURITY is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+# end of IP: Netfilter Configuration
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_SOCKET_IPV6=y
+CONFIG_NF_TPROXY_IPV6=y
+CONFIG_NF_TABLES_IPV6=y
+CONFIG_NFT_REJECT_IPV6=y
+# CONFIG_NFT_DUP_IPV6 is not set
+# CONFIG_NFT_FIB_IPV6 is not set
+# CONFIG_NF_FLOW_TABLE_IPV6 is not set
+# CONFIG_NF_DUP_IPV6 is not set
+CONFIG_NF_REJECT_IPV6=y
+CONFIG_NF_LOG_IPV6=y
+CONFIG_IP6_NF_IPTABLES=y
+# CONFIG_IP6_NF_MATCH_AH is not set
+# CONFIG_IP6_NF_MATCH_EUI64 is not set
+# CONFIG_IP6_NF_MATCH_FRAG is not set
+# CONFIG_IP6_NF_MATCH_OPTS is not set
+# CONFIG_IP6_NF_MATCH_HL is not set
+# CONFIG_IP6_NF_MATCH_IPV6HEADER is not set
+# CONFIG_IP6_NF_MATCH_MH is not set
+# CONFIG_IP6_NF_MATCH_RPFILTER is not set
+# CONFIG_IP6_NF_MATCH_RT is not set
+# CONFIG_IP6_NF_MATCH_SRH is not set
+# CONFIG_IP6_NF_TARGET_HL is not set
+CONFIG_IP6_NF_FILTER=y
+CONFIG_IP6_NF_TARGET_REJECT=y
+# CONFIG_IP6_NF_TARGET_SYNPROXY is not set
+CONFIG_IP6_NF_MANGLE=y
+CONFIG_IP6_NF_RAW=y
+# CONFIG_IP6_NF_SECURITY is not set
+CONFIG_IP6_NF_NAT=y
+CONFIG_IP6_NF_TARGET_MASQUERADE=y
+CONFIG_IP6_NF_TARGET_NPT=y
+# end of IPv6: Netfilter Configuration
+
+CONFIG_NF_DEFRAG_IPV6=y
+# CONFIG_NF_TABLES_BRIDGE is not set
+CONFIG_NF_CONNTRACK_BRIDGE=y
+# CONFIG_BRIDGE_NF_EBTABLES is not set
+CONFIG_BPFILTER=y
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+CONFIG_STP=y
+CONFIG_BRIDGE=y
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_NET_DSA=y
+# CONFIG_NET_DSA_TAG_8021Q is not set
+# CONFIG_NET_DSA_TAG_BRCM is not set
+# CONFIG_NET_DSA_TAG_BRCM_PREPEND is not set
+# CONFIG_NET_DSA_TAG_GSWIP is not set
+# CONFIG_NET_DSA_TAG_DSA is not set
+# CONFIG_NET_DSA_TAG_EDSA is not set
+# CONFIG_NET_DSA_TAG_MTK is not set
+CONFIG_NET_DSA_TAG_KSZ=y
+# CONFIG_NET_DSA_TAG_OCELOT is not set
+# CONFIG_NET_DSA_TAG_QCA is not set
+# CONFIG_NET_DSA_TAG_LAN9303 is not set
+# CONFIG_NET_DSA_TAG_SJA1105 is not set
+# CONFIG_NET_DSA_TAG_TRAILER is not set
+CONFIG_VLAN_8021Q=y
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_VLAN_8021Q_MVRP is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+CONFIG_LLC2=y
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+CONFIG_NET_SCH_CBQ=y
+CONFIG_NET_SCH_HTB=y
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+CONFIG_NET_SCH_SFQ=y
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_CBS is not set
+# CONFIG_NET_SCH_ETF is not set
+# CONFIG_NET_SCH_TAPRIO is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_SKBPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_CAKE is not set
+# CONFIG_NET_SCH_FQ is not set
+# CONFIG_NET_SCH_HHF is not set
+# CONFIG_NET_SCH_PIE is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+# CONFIG_NET_SCH_DEFAULT is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+CONFIG_NET_CLS_FW=y
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_CLS_BPF=y
+# CONFIG_NET_CLS_FLOWER is not set
+# CONFIG_NET_CLS_MATCHALL is not set
+# CONFIG_NET_EMATCH is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_SAMPLE is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+# CONFIG_NET_ACT_MPLS is not set
+# CONFIG_NET_ACT_VLAN is not set
+CONFIG_NET_ACT_BPF=m
+# CONFIG_NET_ACT_CONNMARK is not set
+# CONFIG_NET_ACT_CTINFO is not set
+# CONFIG_NET_ACT_SKBMOD is not set
+# CONFIG_NET_ACT_IFE is not set
+# CONFIG_NET_ACT_TUNNEL_KEY is not set
+# CONFIG_NET_ACT_CT is not set
+# CONFIG_NET_TC_SKB_EXT is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+CONFIG_NET_SWITCHDEV=y
+CONFIG_NET_L3_MASTER_DEV=y
+# CONFIG_NET_NCSI is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+CONFIG_CGROUP_NET_PRIO=y
+CONFIG_CGROUP_NET_CLASSID=y
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+CONFIG_BPF_JIT=y
+CONFIG_BPF_STREAM_PARSER=y
+CONFIG_NET_FLOW_LIMIT=y
+
+#
+# Network testing
+#
+CONFIG_NET_PKTGEN=y
+# end of Network testing
+# end of Networking options
+
+# CONFIG_HAMRADIO is not set
+CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+# CONFIG_CAN_J1939 is not set
+
+#
+# CAN Device Drivers
+#
+# CONFIG_CAN_VCAN is not set
+# CONFIG_CAN_VXCAN is not set
+# CONFIG_CAN_SLCAN is not set
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+CONFIG_CAN_FLEXCAN=y
+# CONFIG_CAN_GRCAN is not set
+# CONFIG_CAN_KVASER_PCIEFD is not set
+# CONFIG_CAN_XILINXCAN is not set
+# CONFIG_CAN_C_CAN is not set
+# CONFIG_CAN_CC770 is not set
+# CONFIG_CAN_IFI_CANFD is not set
+# CONFIG_CAN_M_CAN is not set
+# CONFIG_CAN_PEAK_PCIEFD is not set
+# CONFIG_CAN_SJA1000 is not set
+# CONFIG_CAN_SOFTING is not set
+
+#
+# CAN SPI interfaces
+#
+# CONFIG_CAN_HI311X is not set
+# CONFIG_CAN_MCP251X is not set
+# end of CAN SPI interfaces
+
+#
+# CAN USB interfaces
+#
+# CONFIG_CAN_8DEV_USB is not set
+# CONFIG_CAN_EMS_USB is not set
+# CONFIG_CAN_ESD_USB2 is not set
+# CONFIG_CAN_GS_USB is not set
+# CONFIG_CAN_KVASER_USB is not set
+# CONFIG_CAN_MCBA_USB is not set
+# CONFIG_CAN_PEAK_USB is not set
+# CONFIG_CAN_UCAN is not set
+# end of CAN USB interfaces
+
+# CONFIG_CAN_DEBUG_DEVICES is not set
+# end of CAN Device Drivers
+
+CONFIG_BT=y
+CONFIG_BT_BREDR=y
+CONFIG_BT_RFCOMM=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_BT_BNEP=y
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_BT_HIDP=y
+CONFIG_BT_HS=y
+CONFIG_BT_LE=y
+# CONFIG_BT_LEDS is not set
+# CONFIG_BT_SELFTEST is not set
+CONFIG_BT_DEBUGFS=y
+
+#
+# Bluetooth device drivers
+#
+CONFIG_BT_INTEL=m
+CONFIG_BT_BCM=m
+CONFIG_BT_RTL=m
+CONFIG_BT_HCIBTUSB=m
+# CONFIG_BT_HCIBTUSB_AUTOSUSPEND is not set
+CONFIG_BT_HCIBTUSB_BCM=y
+# CONFIG_BT_HCIBTUSB_MTK is not set
+CONFIG_BT_HCIBTUSB_RTL=y
+CONFIG_BT_HCIBTSDIO=y
+CONFIG_BT_HCIUART=y
+CONFIG_BT_HCIUART_SERDEV=y
+CONFIG_BT_HCIUART_H4=y
+# CONFIG_BT_HCIUART_NOKIA is not set
+CONFIG_BT_HCIUART_BCSP=y
+# CONFIG_BT_HCIUART_ATH3K is not set
+CONFIG_BT_HCIUART_LL=y
+CONFIG_BT_HCIUART_3WIRE=y
+# CONFIG_BT_HCIUART_INTEL is not set
+# CONFIG_BT_HCIUART_BCM is not set
+# CONFIG_BT_HCIUART_QCA is not set
+# CONFIG_BT_HCIUART_AG6XX is not set
+CONFIG_BT_HCIUART_MRVL=y
+# CONFIG_BT_HCIBCM203X is not set
+# CONFIG_BT_HCIBPA10X is not set
+# CONFIG_BT_HCIBFUSB is not set
+CONFIG_BT_HCIVHCI=y
+CONFIG_BT_MRVL=y
+CONFIG_BT_MRVL_SDIO=y
+# CONFIG_BT_ATH3K is not set
+# CONFIG_BT_MTKSDIO is not set
+# CONFIG_BT_MTKUART is not set
+# end of Bluetooth device drivers
+
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_STREAM_PARSER=y
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+CONFIG_NL80211_TESTMODE=y
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+CONFIG_CFG80211_REQUIRE_SIGNED_REGDB=y
+CONFIG_CFG80211_USE_KERNEL_REGDB_KEYS=y
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_DEBUGFS is not set
+CONFIG_CFG80211_CRDA_SUPPORT=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_MAC80211_HAS_RC=y
+CONFIG_MAC80211_RC_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_MESSAGE_TRACING is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+CONFIG_LWTUNNEL=y
+CONFIG_LWTUNNEL_BPF=y
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+CONFIG_NET_SOCK_MSG=y
+CONFIG_NET_DEVLINK=y
+CONFIG_PAGE_POOL=y
+CONFIG_FAILOVER=y
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+CONFIG_ARM_AMBA=y
+CONFIG_HAVE_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCI_DOMAINS_GENERIC=y
+CONFIG_PCI_SYSCALL=y
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+# CONFIG_PCIEAER_INJECT is not set
+# CONFIG_PCIE_ECRC is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_POWER_SUPERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+# CONFIG_PCIE_DPC is not set
+# CONFIG_PCIE_PTM is not set
+# CONFIG_PCIE_BW is not set
+CONFIG_PCI_MSI=y
+CONFIG_PCI_MSI_IRQ_DOMAIN=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+# CONFIG_PCI_PF_STUB is not set
+CONFIG_PCI_ATS=y
+CONFIG_PCI_ECAM=y
+CONFIG_PCI_IOV=y
+# CONFIG_PCI_PRI is not set
+# CONFIG_PCI_PASID is not set
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# PCI controller drivers
+#
+
+#
+# Cadence PCIe controllers support
+#
+# CONFIG_PCIE_CADENCE_HOST is not set
+# CONFIG_PCIE_CADENCE_EP is not set
+# end of Cadence PCIe controllers support
+
+# CONFIG_PCI_FTPCI100 is not set
+CONFIG_PCI_HOST_COMMON=y
+CONFIG_PCI_HOST_GENERIC=y
+# CONFIG_PCIE_XILINX is not set
+CONFIG_PCI_XGENE=y
+CONFIG_PCI_XGENE_MSI=y
+CONFIG_PCIE_ALTERA=y
+CONFIG_PCIE_ALTERA_MSI=y
+CONFIG_PCI_HOST_THUNDER_PEM=y
+CONFIG_PCI_HOST_THUNDER_ECAM=y
+
+#
+# DesignWare PCI Core Support
+#
+CONFIG_PCIE_DW=y
+CONFIG_PCIE_DW_HOST=y
+CONFIG_PCIE_DW_EP=y
+# CONFIG_PCIE_DW_PLAT_HOST is not set
+# CONFIG_PCIE_DW_PLAT_EP is not set
+CONFIG_PCI_IMX6=y
+CONFIG_PCI_IMX6_HOST=y
+# CONFIG_PCI_IMX6_COMPLIANCE_TEST is not set
+CONFIG_PCI_IMX6_EP=y
+CONFIG_PCI_HISI=y
+CONFIG_PCIE_KIRIN=y
+# CONFIG_PCI_MESON is not set
+# CONFIG_PCIE_AL is not set
+# end of DesignWare PCI Core Support
+
+#
+# Mobiveil PCIe Core Support
+#
+CONFIG_PCIE_MOBIVEIL=y
+CONFIG_PCIE_MOBIVEIL_HOST=y
+CONFIG_PCIE_LAYERSCAPE_GEN4=y
+# CONFIG_PCIE_LAYERSCAPE_GEN4_EP is not set
+# end of Mobiveil PCIe Core Support
+# end of PCI controller drivers
+
+#
+# PCI Endpoint
+#
+CONFIG_PCI_ENDPOINT=y
+CONFIG_PCI_ENDPOINT_CONFIGFS=y
+CONFIG_PCI_EPF_TEST=y
+# end of PCI Endpoint
+
+#
+# PCI switch controller drivers
+#
+# CONFIG_PCI_SW_SWITCHTEC is not set
+# end of PCI switch controller drivers
+
+# CONFIG_PCCARD is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Generic Driver Options
+#
+# CONFIG_UEVENT_HELPER is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_FW_LOADER_PAGED_BUF=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+CONFIG_FW_LOADER_USER_HELPER_FALLBACK=y
+# CONFIG_FW_LOADER_COMPRESS is not set
+# end of Firmware loader
+
+CONFIG_WANT_DEV_COREDUMP=y
+CONFIG_ALLOW_DEV_COREDUMP=y
+CONFIG_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+# CONFIG_TEST_ASYNC_DRIVER_PROBE is not set
+CONFIG_SYS_HYPERVISOR=y
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_GENERIC_CPU_VULNERABILITIES=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_MMIO=y
+CONFIG_REGMAP_IRQ=y
+CONFIG_DMA_SHARED_BUFFER=y
+# CONFIG_DMA_FENCE_TRACE is not set
+CONFIG_GENERIC_ARCH_TOPOLOGY=y
+# end of Generic Driver Options
+
+#
+# Bus devices
+#
+CONFIG_BRCMSTB_GISB_ARB=y
+# CONFIG_MOXTET is not set
+# CONFIG_IMX_WEIM is not set
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_VEXPRESS_CONFIG=y
+# end of Bus devices
+
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
+# CONFIG_MTD is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+CONFIG_OF_RESOLVE=y
+CONFIG_OF_OVERLAY=y
+CONFIG_OF_NUMA=y
+CONFIG_OF_CONFIGFS=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SKD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_XEN_BLKDEV_FRONTEND=y
+CONFIG_XEN_BLKDEV_BACKEND=y
+CONFIG_VIRTIO_BLK=y
+# CONFIG_VIRTIO_BLK_SCSI is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# NVME Support
+#
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+# end of NVME Support
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+CONFIG_SENSORS_FXOS8700=y
+CONFIG_SENSORS_FXAS2100X=y
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+CONFIG_SRAM=y
+CONFIG_VEXPRESS_SYSCFG=y
+CONFIG_PCI_ENDPOINT_TEST=y
+# CONFIG_XILINX_SDFEC is not set
+# CONFIG_PVPANIC is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+CONFIG_EEPROM_AT24=y
+# CONFIG_EEPROM_AT25 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+# CONFIG_EEPROM_EE1004 is not set
+# end of EEPROM support
+
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# end of Texas Instruments shared transport line discipline
+
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel/IMX MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+# CONFIG_SCIF_BUS is not set
+
+#
+# VOP Bus Driver
+#
+# CONFIG_VOP_BUS is not set
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# IMX MIC Host Driver
+#
+
+#
+# IMX MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# end of Intel/IMX MIC & related support
+
+# CONFIG_GENWQE is not set
+# CONFIG_ECHO is not set
+# CONFIG_MISC_ALCOR_PCI is not set
+# CONFIG_MISC_RTSX_PCI is not set
+# CONFIG_MISC_RTSX_USB is not set
+# CONFIG_HABANA_AI is not set
+# end of Misc devices
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_PROC_FS is not set
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+# end of SCSI Transports
+
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_SCSI_ESAS2R is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_SMARTPQI is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_SCSI_MYRB is not set
+# CONFIG_SCSI_MYRS is not set
+# CONFIG_XEN_SCSI_FRONTEND is not set
+# CONFIG_SCSI_SNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FDOMAIN_PCI is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_AM53C974 is not set
+# CONFIG_SCSI_WD719X is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_VIRTIO is not set
+# CONFIG_SCSI_DH is not set
+# end of SCSI device support
+
+CONFIG_HAVE_PATA_PLATFORM=y
+# CONFIG_ATA is not set
+CONFIG_MD=y
+# CONFIG_BLK_DEV_MD is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_BUFIO=y
+# CONFIG_DM_DEBUG_BLOCK_MANAGER_LOCKING is not set
+CONFIG_DM_BIO_PRISON=y
+CONFIG_DM_PERSISTENT_DATA=y
+# CONFIG_DM_UNSTRIPED is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+CONFIG_DM_THIN_PROVISIONING=y
+# CONFIG_DM_CACHE is not set
+# CONFIG_DM_WRITECACHE is not set
+# CONFIG_DM_ERA is not set
+# CONFIG_DM_CLONE is not set
+# CONFIG_DM_MIRROR is not set
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_ZERO is not set
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_DUST is not set
+# CONFIG_DM_INIT is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_DM_SWITCH is not set
+# CONFIG_DM_LOG_WRITES is not set
+# CONFIG_DM_INTEGRITY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# end of IEEE 1394 (FireWire) support
+
+CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=y
+CONFIG_DUMMY=y
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+CONFIG_MACVLAN=y
+CONFIG_MACVTAP=y
+CONFIG_IPVLAN_L3S=y
+CONFIG_IPVLAN=y
+CONFIG_IPVTAP=y
+CONFIG_VXLAN=y
+# CONFIG_GENEVE is not set
+# CONFIG_GTP is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+CONFIG_TUN=y
+CONFIG_TAP=y
+# CONFIG_TUN_VNET_CROSS_LE is not set
+CONFIG_VETH=y
+# CONFIG_VIRTIO_NET is not set
+# CONFIG_NLMON is not set
+# CONFIG_NET_VRF is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_B53 is not set
+# CONFIG_NET_DSA_BCM_SF2 is not set
+# CONFIG_NET_DSA_LOOP is not set
+# CONFIG_NET_DSA_LANTIQ_GSWIP is not set
+# CONFIG_NET_DSA_MT7530 is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+CONFIG_NET_DSA_MICROCHIP_KSZ_COMMON=y
+CONFIG_NET_DSA_MICROCHIP_KSZ9477=y
+CONFIG_NET_DSA_MICROCHIP_KSZ9477_I2C=y
+# CONFIG_NET_DSA_MICROCHIP_KSZ9477_SPI is not set
+# CONFIG_NET_DSA_MICROCHIP_KSZ8795 is not set
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_SJA1105 is not set
+# CONFIG_NET_DSA_QCA8K is not set
+# CONFIG_NET_DSA_REALTEK_SMI is not set
+# CONFIG_NET_DSA_SMSC_LAN9303_I2C is not set
+# CONFIG_NET_DSA_SMSC_LAN9303_MDIO is not set
+# CONFIG_NET_DSA_VITESSE_VSC73XX_SPI is not set
+# CONFIG_NET_DSA_VITESSE_VSC73XX_PLATFORM is not set
+# end of Distributed Switch Architecture drivers
+
+CONFIG_ETHERNET=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_ALTERA_TSE is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+CONFIG_NET_VENDOR_FREESCALE=y
+CONFIG_FEC=y
+# CONFIG_FSL_PQ_MDIO is not set
+CONFIG_FSL_XGMAC_MDIO=y
+# CONFIG_GIANFAR is not set
+
+#
+# Frame Manager support
+#
+CONFIG_FSL_SDK_FMAN=y
+# CONFIG_FSL_SDK_FMAN_TEST is not set
+
+#
+# FMAN Processor support
+#
+CONFIG_FMAN_ARM=y
+# CONFIG_FMAN_P3040_P4080_P5020 is not set
+# CONFIG_FMAN_P1023 is not set
+# CONFIG_FMAN_V3H is not set
+# CONFIG_FMAN_V3L is not set
+# end of FMAN Processor support
+
+# CONFIG_FSL_SDK_FMAN_RTC_API is not set
+# CONFIG_FMAN_MIB_CNT_OVF_IRQ_EN is not set
+CONFIG_FSL_FM_MAX_FRAME_SIZE=1522
+CONFIG_FSL_FM_RX_EXTRA_HEADROOM=64
+# CONFIG_FMAN_PFC is not set
+# end of Frame Manager support
+
+CONFIG_FSL_SDK_DPAA_ETH=y
+# CONFIG_FSL_DPAA_HOOKS is not set
+# CONFIG_FSL_DPAA_CEETM is not set
+CONFIG_FSL_DPAA_OFFLINE_PORTS=y
+CONFIG_FSL_DPAA_ADVANCED_DRIVERS=y
+# CONFIG_FSL_DPAA_ETH_JUMBO_FRAME is not set
+# CONFIG_FSL_DPAA_TS is not set
+# CONFIG_FSL_DPAA_1588 is not set
+CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT=128
+CONFIG_FSL_DPAA_ETH_REFILL_THRESHOLD=80
+CONFIG_FSL_DPAA_CS_THRESHOLD_1G=0x06000000
+CONFIG_FSL_DPAA_CS_THRESHOLD_10G=0x10000000
+CONFIG_FSL_DPAA_INGRESS_CS_THRESHOLD=0x10000000
+CONFIG_FSL_DPAA_ETH_DEBUGFS=y
+# CONFIG_FSL_DPAA_ETH_DEBUG is not set
+# CONFIG_FSL_DPAA_DBG_LOOP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HP is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_JME is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MICROCHIP=y
+# CONFIG_ENC28J60 is not set
+# CONFIG_ENCX24J600 is not set
+# CONFIG_LAN743X is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_PENSANDO is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_NET_VENDOR_STMICRO=y
+CONFIG_STMMAC_ETH=y
+# CONFIG_STMMAC_SELFTESTS is not set
+CONFIG_STMMAC_PLATFORM=y
+# CONFIG_DWMAC_DWC_QOS_ETH is not set
+CONFIG_DWMAC_GENERIC=y
+CONFIG_DWMAC_IMX8=y
+# CONFIG_STMMAC_PCI is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+CONFIG_MDIO_BITBANG=y
+CONFIG_MDIO_BUS_MUX=y
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+CONFIG_MDIO_BUS_MUX_MMIOREG=y
+CONFIG_MDIO_BUS_MUX_MULTIPLEXER=y
+CONFIG_MDIO_CAVIUM=y
+# CONFIG_MDIO_GPIO is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+# CONFIG_MDIO_OCTEON is not set
+CONFIG_MDIO_THUNDER=y
+CONFIG_PHYLINK=y
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+# CONFIG_LED_TRIGGER_PHY is not set
+
+#
+# MII PHY device drivers
+#
+# CONFIG_SFP is not set
+# CONFIG_ADIN_PHY is not set
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_AX88796B_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INPHI_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
+CONFIG_MICREL_PHY=y
+CONFIG_MICROCHIP_PHY=y
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_NXP_TJA11XX_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_RENESAS_PHY is not set
+# CONFIG_ROCKCHIP_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+CONFIG_PPP=y
+CONFIG_PPP_BSDCOMP=y
+CONFIG_PPP_DEFLATE=y
+CONFIG_PPP_FILTER=y
+CONFIG_PPP_MPPE=y
+CONFIG_PPP_MULTILINK=y
+CONFIG_PPPOE=y
+CONFIG_PPTP=y
+CONFIG_PPP_ASYNC=y
+CONFIG_PPP_SYNC_TTY=y
+# CONFIG_SLIP is not set
+CONFIG_SLHC=y
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+CONFIG_USB_PEGASUS=m
+CONFIG_USB_RTL8150=m
+CONFIG_USB_RTL8152=y
+CONFIG_USB_LAN78XX=m
+CONFIG_USB_USBNET=y
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_NET_AX88179_178A=m
+CONFIG_USB_NET_CDCETHER=y
+# CONFIG_USB_NET_CDC_EEM is not set
+CONFIG_USB_NET_CDC_NCM=y
+# CONFIG_USB_NET_HUAWEI_CDC_NCM is not set
+CONFIG_USB_NET_CDC_MBIM=y
+CONFIG_USB_NET_DM9601=m
+# CONFIG_USB_NET_SR9700 is not set
+CONFIG_USB_NET_SR9800=m
+CONFIG_USB_NET_SMSC75XX=m
+CONFIG_USB_NET_SMSC95XX=m
+# CONFIG_USB_NET_GL620A is not set
+CONFIG_USB_NET_NET1080=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_USB_NET_MCS7830=m
+CONFIG_USB_NET_RNDIS_HOST=y
+CONFIG_USB_NET_CDC_SUBSET_ENABLE=m
+CONFIG_USB_NET_CDC_SUBSET=m
+# CONFIG_USB_ALI_M5632 is not set
+# CONFIG_USB_AN2720 is not set
+CONFIG_USB_BELKIN=y
+CONFIG_USB_ARMLINUX=y
+# CONFIG_USB_EPSON2888 is not set
+# CONFIG_USB_KC2190 is not set
+CONFIG_USB_NET_ZAURUS=m
+# CONFIG_USB_NET_CX82310_ETH is not set
+# CONFIG_USB_NET_KALMIA is not set
+CONFIG_USB_NET_QMI_WWAN=y
+# CONFIG_USB_NET_INT51X1 is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_USB_SIERRA_NET is not set
+# CONFIG_USB_VL600 is not set
+# CONFIG_USB_NET_CH9200 is not set
+# CONFIG_USB_NET_AQC111 is not set
+CONFIG_WLAN=y
+# CONFIG_WLAN_VENDOR_ADMTEK is not set
+# CONFIG_WLAN_VENDOR_ATH is not set
+# CONFIG_WLAN_VENDOR_ATMEL is not set
+# CONFIG_WLAN_VENDOR_BROADCOM is not set
+# CONFIG_WLAN_VENDOR_CISCO is not set
+# CONFIG_WLAN_VENDOR_INTEL is not set
+# CONFIG_WLAN_VENDOR_INTERSIL is not set
+# CONFIG_WLAN_VENDOR_MARVELL is not set
+# CONFIG_WLAN_VENDOR_MEDIATEK is not set
+CONFIG_WLAN_VENDOR_NXP=y
+CONFIG_MXMWIFIEX=m
+# CONFIG_WLAN_VENDOR_RALINK is not set
+# CONFIG_WLAN_VENDOR_REALTEK is not set
+# CONFIG_WLAN_VENDOR_RSI is not set
+# CONFIG_WLAN_VENDOR_ST is not set
+# CONFIG_WLAN_VENDOR_TI is not set
+# CONFIG_WLAN_VENDOR_ZYDAS is not set
+# CONFIG_WLAN_VENDOR_QUANTENNA is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_VIRT_WIFI is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_XEN_NETDEV_FRONTEND is not set
+# CONFIG_XEN_NETDEV_BACKEND is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_NETDEVSIM is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_IVSHMEM_NET is not set
+# CONFIG_ISDN is not set
+# CONFIG_NVM is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_LEDS is not set
+# CONFIG_INPUT_FF_MEMLESS is not set
+CONFIG_INPUT_POLLDEV=y
+# CONFIG_INPUT_SPARSEKMAP is not set
+CONFIG_INPUT_MATRIXKMAP=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ADC=m
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1050 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_DLINK_DIR685 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+CONFIG_KEYBOARD_GPIO=y
+CONFIG_KEYBOARD_GPIO_POLLED=y
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+CONFIG_KEYBOARD_SNVS_PWRKEY=y
+CONFIG_KEYBOARD_IMX_SC_PWRKEY=y
+# CONFIG_KEYBOARD_IMX is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_SAMSUNG is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_OMAP4 is not set
+# CONFIG_KEYBOARD_TM2_TOUCHKEY is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_CROS_EC is not set
+# CONFIG_KEYBOARD_CAP11XX is not set
+# CONFIG_KEYBOARD_BCM is not set
+CONFIG_INPUT_MOUSE=y
+# CONFIG_MOUSE_PS2 is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_ELAN_I2C is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_TOUCHSCREEN_FTS is not set
+# CONFIG_INPUT_MISC is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+# CONFIG_SERIO_SERPORT is not set
+CONFIG_SERIO_AMBAKMI=y
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_SERIO_APBPS2 is not set
+# CONFIG_SERIO_GPIO_PS2 is not set
+# CONFIG_USERIO is not set
+# CONFIG_GAMEPORT is not set
+# end of Hardware I/O ports
+# end of Input device support
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_NULL_TTY is not set
+CONFIG_LDISC_AUTOLOAD=y
+CONFIG_DEVMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+# CONFIG_SERIAL_8250_FINTEK is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_DMA=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_EXAR=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_SERIAL_8250_EXTENDED=y
+# CONFIG_SERIAL_8250_MANY_PORTS is not set
+# CONFIG_SERIAL_8250_ASPEED_VUART is not set
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+# CONFIG_SERIAL_8250_RSA is not set
+CONFIG_SERIAL_8250_DWLIB=y
+CONFIG_SERIAL_8250_FSL=y
+CONFIG_SERIAL_8250_DW=y
+# CONFIG_SERIAL_8250_RT288X is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+CONFIG_SERIAL_IMX=y
+CONFIG_SERIAL_IMX_CONSOLE=y
+# CONFIG_SERIAL_UARTLITE is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SIFIVE is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_SERIAL_FSL_LPUART=y
+CONFIG_SERIAL_FSL_LPUART_CONSOLE=y
+# CONFIG_SERIAL_FSL_LINFLEXUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# end of Serial drivers
+
+CONFIG_SERIAL_MCTRL_GPIO=y
+CONFIG_SERIAL_DEV_BUS=y
+CONFIG_SERIAL_DEV_CTRL_TTYPORT=y
+CONFIG_HVC_DRIVER=y
+CONFIG_HVC_IRQ=y
+CONFIG_HVC_XEN=y
+CONFIG_HVC_XEN_FRONTEND=y
+# CONFIG_HVC_DCC is not set
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+# CONFIG_HW_RANDOM_VIRTIO is not set
+CONFIG_HW_RANDOM_IMX_RNGC=y
+CONFIG_HW_RANDOM_CAVIUM=y
+CONFIG_HW_RANDOM_OPTEE=y
+# CONFIG_APPLICOM is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_TCG_TPM=y
+CONFIG_HW_RANDOM_TPM=y
+CONFIG_TCG_TIS_CORE=y
+CONFIG_TCG_TIS=y
+# CONFIG_TCG_TIS_SPI is not set
+# CONFIG_TCG_TIS_I2C_ATMEL is not set
+CONFIG_TCG_TIS_I2C_INFINEON=y
+# CONFIG_TCG_TIS_I2C_NUVOTON is not set
+# CONFIG_TCG_ATMEL is not set
+# CONFIG_TCG_XEN is not set
+# CONFIG_TCG_VTPM_PROXY is not set
+# CONFIG_TCG_FTPM_TEE is not set
+# CONFIG_TCG_TIS_ST33ZP24_I2C is not set
+# CONFIG_TCG_TIS_ST33ZP24_SPI is not set
+CONFIG_DEVPORT=y
+# CONFIG_XILLYBUS is not set
+# end of Character devices
+
+# CONFIG_RANDOM_TRUST_BOOTLOADER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
+# CONFIG_I2C_DEMUX_PINCTRL is not set
+# CONFIG_I2C_MUX_MLXCPLD is not set
+# end of Multiplexer I2C Chip support
+
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_NVIDIA_GPU is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CADENCE is not set
+# CONFIG_I2C_CBUS_GPIO is not set
+CONFIG_I2C_DESIGNWARE_CORE=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+# CONFIG_I2C_DESIGNWARE_SLAVE is not set
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+# CONFIG_I2C_EMEV2 is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_GPIO_FAULT_INJECTOR is not set
+CONFIG_I2C_IMX=y
+CONFIG_I2C_IMX_LPI2C=y
+# CONFIG_I2C_NOMADIK is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_RPBUS is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_THUNDERX is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+CONFIG_I2C_CROS_EC_TUNNEL=y
+CONFIG_XEN_I2C_FRONTEND=y
+CONFIG_XEN_I2C_BACKEND=y
+# end of I2C Hardware Bus support
+
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_SLAVE is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# end of I2C support
+
+# CONFIG_I3C is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+CONFIG_SPI_BITBANG=y
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+CONFIG_SPI_FSL_LPSPI=y
+CONFIG_SPI_FSL_QUADSPI=y
+CONFIG_SPI_NXP_FLEXSPI=y
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_IMX=y
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX is not set
+# CONFIG_SPI_ROCKCHIP is not set
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SIFIVE is not set
+# CONFIG_SPI_MXIC is not set
+# CONFIG_SPI_THUNDERX is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_LOOPBACK_TEST is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_SPI_SLAVE=y
+CONFIG_SPI_SLAVE_TIME=y
+CONFIG_SPI_SLAVE_SYSTEM_CONTROL=y
+CONFIG_SPI_DYNAMIC=y
+CONFIG_SPMI=y
+# CONFIG_HSI is not set
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# end of PTP clock support
+
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
+CONFIG_PINCTRL_SINGLE=y
+# CONFIG_PINCTRL_SX150X is not set
+# CONFIG_PINCTRL_STMFX is not set
+# CONFIG_PINCTRL_RK805 is not set
+# CONFIG_PINCTRL_OCELOT is not set
+CONFIG_PINCTRL_IMX=y
+CONFIG_PINCTRL_IMX_SCU=y
+CONFIG_PINCTRL_IMX8MM=y
+CONFIG_PINCTRL_IMX8MN=y
+CONFIG_PINCTRL_IMX8MP=y
+CONFIG_PINCTRL_IMX8MQ=y
+CONFIG_PINCTRL_IMX8QM=y
+CONFIG_PINCTRL_IMX8QXP=y
+CONFIG_PINCTRL_IMX8DXL=y
+CONFIG_PINCTRL_S32V_CORE=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_GENERIC=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_CADENCE is not set
+CONFIG_GPIO_DWAPB=y
+# CONFIG_GPIO_EXAR is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+CONFIG_GPIO_GENERIC_PLATFORM=y
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+CONFIG_GPIO_MXC=y
+CONFIG_GPIO_MXC_PAD_WAKEUP=y
+CONFIG_GPIO_PL061=y
+# CONFIG_GPIO_SAMA5D2_PIOBU is not set
+# CONFIG_GPIO_SYSCON is not set
+CONFIG_GPIO_IMX_RPMSG=y
+CONFIG_GPIO_XGENE=y
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_AMD_FCH is not set
+# end of Memory mapped GPIO drivers
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_GW_PLD is not set
+# CONFIG_GPIO_MAX7300 is not set
+CONFIG_GPIO_MAX732X=y
+# CONFIG_GPIO_MAX732X_IRQ is not set
+CONFIG_GPIO_PCA953X=y
+# CONFIG_GPIO_PCA953X_IRQ is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_TPIC2810 is not set
+# end of I2C GPIO expanders
+
+#
+# MFD GPIO expanders
+#
+# end of MFD GPIO expanders
+
+#
+# PCI GPIO expanders
+#
+# CONFIG_GPIO_BT8XX is not set
+# CONFIG_GPIO_PCI_IDIO_16 is not set
+# CONFIG_GPIO_PCIE_IDIO_24 is not set
+# CONFIG_GPIO_RDC321X is not set
+# end of PCI GPIO expanders
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+# end of SPI GPIO expanders
+
+#
+# USB GPIO expanders
+#
+# end of USB GPIO expanders
+
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_AVS=y
+CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMSTB is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+CONFIG_POWER_RESET_VEXPRESS=y
+CONFIG_POWER_RESET_XGENE=y
+CONFIG_POWER_RESET_SYSCON=y
+CONFIG_POWER_RESET_SYSCON_POWEROFF=y
+# CONFIG_SYSCON_REBOOT_MODE is not set
+# CONFIG_NVMEM_REBOOT_MODE is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+CONFIG_POWER_SUPPLY_HWMON=y
+# CONFIG_PDA_POWER is not set
+# CONFIG_GENERIC_ADC_BATTERY is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_LEGO_EV3 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_ISP1704 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LT3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24190 is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
+# CONFIG_CHARGER_CROS_USBPD is not set
+# CONFIG_CHARGER_UCS1002 is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_AD7314 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7310 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_AS370 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+CONFIG_SENSORS_ARM_SCPI=y
+# CONFIG_SENSORS_ASPEED is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FTSTEUTATES is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_G762 is not set
+# CONFIG_SENSORS_GPIO_FAN is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_IIO_HWMON is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_POWR1220 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LTC2945 is not set
+# CONFIG_SENSORS_LTC2990 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4222 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4260 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX17135 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX31722 is not set
+# CONFIG_SENSORS_MAX6621 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MAX31790 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_TC654 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+# CONFIG_SENSORS_LM73 is not set
+CONFIG_SENSORS_LM75=y
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_NCT6683 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NCT7802 is not set
+# CONFIG_SENSORS_NCT7904 is not set
+# CONFIG_SENSORS_NPCM7XX is not set
+# CONFIG_SENSORS_OCC_P8_I2C is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_PWM_FAN is not set
+# CONFIG_SENSORS_SHT15 is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SHT3x is not set
+# CONFIG_SENSORS_SHTC1 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH5627 is not set
+# CONFIG_SENSORS_SCH5636 is not set
+# CONFIG_SENSORS_STTS751 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_ADC128D818 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_ADS7871 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_INA3221 is not set
+# CONFIG_SENSORS_TC74 is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP103 is not set
+# CONFIG_SENSORS_TMP108 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VEXPRESS is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83773G is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_MAG3110 is not set
+# CONFIG_MXC_MMA8451 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_STATISTICS=y
+CONFIG_THERMAL_EMERGENCY_POWEROFF_DELAY_MS=0
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_OF=y
+CONFIG_THERMAL_WRITABLE_TRIPS=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_POWER_ALLOCATOR is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_BANG_BANG is not set
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+# CONFIG_CLOCK_THERMAL is not set
+# CONFIG_DEVFREQ_THERMAL is not set
+CONFIG_THERMAL_EMULATION=y
+# CONFIG_THERMAL_MMIO is not set
+# CONFIG_IMX_THERMAL is not set
+CONFIG_IMX_SC_THERMAL=y
+CONFIG_DEVICE_THERMAL=y
+CONFIG_IMX8MM_THERMAL=y
+CONFIG_QORIQ_THERMAL=y
+# CONFIG_GENERIC_ADC_THERMAL is not set
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+CONFIG_WATCHDOG_OPEN_TIMEOUT=0
+CONFIG_WATCHDOG_SYSFS=y
+
+#
+# Watchdog Pretimeout Governors
+#
+# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_GPIO_WATCHDOG=y
+CONFIG_GPIO_WATCHDOG_ARCH_INITCALL=y
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+CONFIG_ARM_SP805_WATCHDOG=y
+CONFIG_ARM_SBSA_WATCHDOG=y
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+CONFIG_IMX2_WDT=y
+CONFIG_IMX_SC_WDT=y
+# CONFIG_IMX7ULP_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_MEN_A21_WDT is not set
+CONFIG_XEN_WDT=y
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC_DEV is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
+# CONFIG_MFD_DA9063 is not set
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_MXC_HDMI is not set
+CONFIG_MFD_IMX_AUDIOMIX=y
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_LPC_ICH is not set
+# CONFIG_LPC_SCH is not set
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX17135 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77650 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+CONFIG_MFD_RK808=y
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+CONFIG_MFD_SYSCON=y
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TQMX86 is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_LOCHNAGAR is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
+# CONFIG_MFD_ROHM_BD70528 is not set
+# CONFIG_MFD_STPMIC1 is not set
+# CONFIG_MFD_STMFX is not set
+CONFIG_MFD_PCA9450=y
+CONFIG_MFD_VEXPRESS_SYSREG=y
+# CONFIG_RAVE_SP_CORE is not set
+# end of Multifunction device drivers
+
+CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_ANATOP is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+CONFIG_REGULATOR_FAN53555=y
+CONFIG_REGULATOR_GPIO=y
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+CONFIG_REGULATOR_MAX8973=y
+# CONFIG_REGULATOR_MCP16502 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+CONFIG_REGULATOR_PCA9450=y
+# CONFIG_REGULATOR_PF1550_RPMSG is not set
+CONFIG_REGULATOR_PFUZE100=y
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+CONFIG_REGULATOR_PWM=y
+CONFIG_REGULATOR_QCOM_SPMI=y
+CONFIG_REGULATOR_RK808=y
+# CONFIG_REGULATOR_SLG51000 is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_SY8824X is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+CONFIG_REGULATOR_VCTRL=m
+# CONFIG_REGULATOR_VEXPRESS is not set
+CONFIG_CEC_CORE=y
+CONFIG_CEC_NOTIFIER=y
+# CONFIG_RC_CORE is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+# CONFIG_MEDIA_ANALOG_TV_SUPPORT is not set
+CONFIG_MEDIA_DIGITAL_TV_SUPPORT=y
+# CONFIG_MEDIA_RADIO_SUPPORT is not set
+# CONFIG_MEDIA_SDR_SUPPORT is not set
+# CONFIG_MEDIA_CEC_SUPPORT is not set
+CONFIG_MEDIA_CONTROLLER=y
+# CONFIG_MEDIA_CONTROLLER_DVB is not set
+# CONFIG_MEDIA_CONTROLLER_REQUEST_API is not set
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_VIDEO_V4L2=y
+CONFIG_VIDEO_V4L2_I2C=y
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_FIXED_MINOR_RANGES is not set
+CONFIG_V4L2_MEM2MEM_DEV=y
+CONFIG_V4L2_FWNODE=y
+CONFIG_VIDEOBUF_GEN=y
+CONFIG_VIDEOBUF_DMA_CONTIG=y
+CONFIG_DVB_CORE=y
+# CONFIG_DVB_MMAP is not set
+# CONFIG_DVB_NET is not set
+CONFIG_DVB_MAX_ADAPTERS=16
+# CONFIG_DVB_DYNAMIC_MINORS is not set
+# CONFIG_DVB_DEMUX_SECTION_LOSS_LOG is not set
+# CONFIG_DVB_ULE_DEBUG is not set
+
+#
+# Media drivers
+#
+CONFIG_MEDIA_USB_SUPPORT=y
+
+#
+# Webcam devices
+#
+CONFIG_USB_VIDEO_CLASS=y
+CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y
+# CONFIG_USB_GSPCA is not set
+# CONFIG_USB_PWC is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_USB_ZR364XX is not set
+# CONFIG_USB_STKWEBCAM is not set
+# CONFIG_USB_S2255 is not set
+# CONFIG_VIDEO_USBTV is not set
+
+#
+# Analog/digital TV USB devices
+#
+# CONFIG_VIDEO_AU0828 is not set
+# CONFIG_VIDEO_CX231XX is not set
+
+#
+# Digital TV USB devices
+#
+# CONFIG_DVB_USB_V2 is not set
+# CONFIG_DVB_TTUSB_BUDGET is not set
+# CONFIG_DVB_TTUSB_DEC is not set
+# CONFIG_SMS_USB_DRV is not set
+# CONFIG_DVB_B2C2_FLEXCOP_USB is not set
+# CONFIG_DVB_AS102 is not set
+
+#
+# Webcam, TV (analog/digital) USB devices
+#
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_MEDIA_PCI_SUPPORT is not set
+CONFIG_V4L_PLATFORM_DRIVERS=y
+# CONFIG_VIDEO_CAFE_CCIC is not set
+# CONFIG_VIDEO_CADENCE is not set
+# CONFIG_VIDEO_ASPEED is not set
+# CONFIG_VIDEO_MUX is not set
+CONFIG_VIDEO_MX8_CAPTURE=y
+# CONFIG_VIDEO_MXC_CAPTURE is not set
+# CONFIG_VIDEO_MXC_OUTPUT is not set
+
+#
+# IMX8 Camera ISI/MIPI Features support
+#
+CONFIG_IMX8_MIPI_CSI2_YAV=y
+CONFIG_IMX8_JPEG=y
+# end of IMX8 Camera ISI/MIPI Features support
+
+CONFIG_VIDEO_MXC_PXP_V4L2=y
+# CONFIG_VIDEO_XILINX is not set
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_VIDEO_CODA=m
+CONFIG_VIDEO_IMX_PXP=y
+# CONFIG_VIDEO_MEM2MEM_DEINTERLACE is not set
+# CONFIG_VIDEO_SH_VEU is not set
+# CONFIG_V4L_TEST_DRIVERS is not set
+# CONFIG_DVB_PLATFORM_DRIVERS is not set
+
+#
+# Supported MMC/SDIO adapters
+#
+# CONFIG_SMS_SDIO_DRV is not set
+# CONFIG_CYPRESS_FIRMWARE is not set
+CONFIG_VIDEOBUF2_CORE=y
+CONFIG_VIDEOBUF2_V4L2=y
+CONFIG_VIDEOBUF2_MEMOPS=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=y
+CONFIG_VIDEOBUF2_VMALLOC=y
+
+#
+# Media ancillary drivers (tuners, sensors, i2c, spi, frontends)
+#
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_MEDIA_ATTACH=y
+
+#
+# I2C Encoders, decoders, sensors and other helper chips
+#
+
+#
+# Audio decoders, processors and mixers
+#
+# CONFIG_VIDEO_TVAUDIO is not set
+# CONFIG_VIDEO_TDA7432 is not set
+# CONFIG_VIDEO_TDA9840 is not set
+# CONFIG_VIDEO_TEA6415C is not set
+# CONFIG_VIDEO_TEA6420 is not set
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS3308 is not set
+# CONFIG_VIDEO_CS5345 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_UDA1342 is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_VP27SMPX is not set
+# CONFIG_VIDEO_SONY_BTF_MPX is not set
+
+#
+# RDS decoders
+#
+# CONFIG_VIDEO_SAA6588 is not set
+
+#
+# Video decoders
+#
+# CONFIG_VIDEO_ADV7180 is not set
+# CONFIG_VIDEO_ADV7183 is not set
+# CONFIG_VIDEO_ADV748X is not set
+# CONFIG_VIDEO_ADV7604 is not set
+# CONFIG_VIDEO_ADV7842 is not set
+# CONFIG_VIDEO_BT819 is not set
+# CONFIG_VIDEO_BT856 is not set
+# CONFIG_VIDEO_BT866 is not set
+# CONFIG_VIDEO_KS0127 is not set
+# CONFIG_VIDEO_ML86V7667 is not set
+# CONFIG_VIDEO_SAA7110 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_TC358743 is not set
+# CONFIG_VIDEO_TVP514X is not set
+# CONFIG_VIDEO_TVP5150 is not set
+# CONFIG_VIDEO_TVP7002 is not set
+# CONFIG_VIDEO_TW2804 is not set
+# CONFIG_VIDEO_TW9903 is not set
+# CONFIG_VIDEO_TW9906 is not set
+# CONFIG_VIDEO_TW9910 is not set
+# CONFIG_VIDEO_VPX3220 is not set
+
+#
+# Video and audio decoders
+#
+# CONFIG_VIDEO_SAA717X is not set
+# CONFIG_VIDEO_CX25840 is not set
+
+#
+# Video encoders
+#
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_SAA7185 is not set
+# CONFIG_VIDEO_ADV7170 is not set
+# CONFIG_VIDEO_ADV7175 is not set
+# CONFIG_VIDEO_ADV7343 is not set
+# CONFIG_VIDEO_ADV7393 is not set
+# CONFIG_VIDEO_ADV7511 is not set
+# CONFIG_VIDEO_AD9389B is not set
+# CONFIG_VIDEO_AK881X is not set
+# CONFIG_VIDEO_THS8200 is not set
+
+#
+# Camera sensor devices
+#
+# CONFIG_VIDEO_IMX214 is not set
+# CONFIG_VIDEO_IMX258 is not set
+# CONFIG_VIDEO_IMX274 is not set
+# CONFIG_VIDEO_IMX319 is not set
+# CONFIG_VIDEO_IMX355 is not set
+# CONFIG_VIDEO_OV2640 is not set
+# CONFIG_VIDEO_OV2659 is not set
+# CONFIG_VIDEO_OV2680 is not set
+# CONFIG_VIDEO_OV2685 is not set
+# CONFIG_VIDEO_OV5640 is not set
+# CONFIG_VIDEO_OV5645 is not set
+# CONFIG_VIDEO_OV5647 is not set
+# CONFIG_VIDEO_OV6650 is not set
+# CONFIG_VIDEO_OV5670 is not set
+# CONFIG_VIDEO_OV5675 is not set
+# CONFIG_VIDEO_OV5695 is not set
+# CONFIG_VIDEO_OV7251 is not set
+# CONFIG_VIDEO_OV772X is not set
+# CONFIG_VIDEO_OV7640 is not set
+# CONFIG_VIDEO_OV7670 is not set
+# CONFIG_VIDEO_OV7740 is not set
+# CONFIG_VIDEO_OV8856 is not set
+# CONFIG_VIDEO_OV9640 is not set
+# CONFIG_VIDEO_OV9650 is not set
+# CONFIG_VIDEO_OV13858 is not set
+# CONFIG_VIDEO_VS6624 is not set
+# CONFIG_VIDEO_MT9M001 is not set
+# CONFIG_VIDEO_MT9M032 is not set
+# CONFIG_VIDEO_MT9M111 is not set
+# CONFIG_VIDEO_MT9P031 is not set
+# CONFIG_VIDEO_MT9T001 is not set
+# CONFIG_VIDEO_MT9T112 is not set
+# CONFIG_VIDEO_MT9V011 is not set
+# CONFIG_VIDEO_MT9V032 is not set
+# CONFIG_VIDEO_MT9V111 is not set
+# CONFIG_VIDEO_SR030PC30 is not set
+# CONFIG_VIDEO_NOON010PC30 is not set
+# CONFIG_VIDEO_M5MOLS is not set
+# CONFIG_VIDEO_RJ54N1 is not set
+# CONFIG_VIDEO_S5K6AA is not set
+# CONFIG_VIDEO_S5K6A3 is not set
+# CONFIG_VIDEO_S5K4ECGX is not set
+# CONFIG_VIDEO_S5K5BAF is not set
+# CONFIG_VIDEO_SMIAPP is not set
+# CONFIG_VIDEO_ET8EK8 is not set
+# CONFIG_VIDEO_S5C73M3 is not set
+
+#
+# Lens drivers
+#
+# CONFIG_VIDEO_AD5820 is not set
+# CONFIG_VIDEO_AK7375 is not set
+# CONFIG_VIDEO_DW9714 is not set
+# CONFIG_VIDEO_DW9807_VCM is not set
+
+#
+# Flash devices
+#
+# CONFIG_VIDEO_ADP1653 is not set
+# CONFIG_VIDEO_LM3560 is not set
+# CONFIG_VIDEO_LM3646 is not set
+
+#
+# Video improvement chips
+#
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# Audio/Video compression chips
+#
+# CONFIG_VIDEO_SAA6752HS is not set
+
+#
+# SDR tuner chips
+#
+
+#
+# Miscellaneous helper chips
+#
+# CONFIG_VIDEO_THS7303 is not set
+# CONFIG_VIDEO_M52790 is not set
+# CONFIG_VIDEO_I2C is not set
+# CONFIG_VIDEO_ST_MIPID02 is not set
+# end of I2C Encoders, decoders, sensors and other helper chips
+
+#
+# SPI helper chips
+#
+# CONFIG_VIDEO_GS1662 is not set
+# end of SPI helper chips
+
+#
+# Media SPI Adapters
+#
+# CONFIG_CXD2880_SPI_DRV is not set
+# end of Media SPI Adapters
+
+CONFIG_MEDIA_TUNER=y
+
+#
+# Customize TV tuners
+#
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+# end of Customize TV tuners
+
+#
+# Customise DVB Frontends
+#
+
+#
+# Multistandard (satellite) frontends
+#
+# CONFIG_DVB_STB0899 is not set
+# CONFIG_DVB_STB6100 is not set
+# CONFIG_DVB_STV090x is not set
+# CONFIG_DVB_STV0910 is not set
+# CONFIG_DVB_STV6110x is not set
+# CONFIG_DVB_STV6111 is not set
+# CONFIG_DVB_MXL5XX is not set
+# CONFIG_DVB_M88DS3103 is not set
+
+#
+# Multistandard (cable + terrestrial) frontends
+#
+# CONFIG_DVB_DRXK is not set
+# CONFIG_DVB_TDA18271C2DD is not set
+# CONFIG_DVB_SI2165 is not set
+# CONFIG_DVB_MN88472 is not set
+# CONFIG_DVB_MN88473 is not set
+
+#
+# DVB-S (satellite) frontends
+#
+# CONFIG_DVB_CX24110 is not set
+# CONFIG_DVB_CX24123 is not set
+# CONFIG_DVB_MT312 is not set
+# CONFIG_DVB_ZL10036 is not set
+# CONFIG_DVB_ZL10039 is not set
+# CONFIG_DVB_S5H1420 is not set
+# CONFIG_DVB_STV0288 is not set
+# CONFIG_DVB_STB6000 is not set
+# CONFIG_DVB_STV0299 is not set
+# CONFIG_DVB_STV6110 is not set
+# CONFIG_DVB_STV0900 is not set
+# CONFIG_DVB_TDA8083 is not set
+# CONFIG_DVB_TDA10086 is not set
+# CONFIG_DVB_TDA8261 is not set
+# CONFIG_DVB_VES1X93 is not set
+# CONFIG_DVB_TUNER_ITD1000 is not set
+# CONFIG_DVB_TUNER_CX24113 is not set
+# CONFIG_DVB_TDA826X is not set
+# CONFIG_DVB_TUA6100 is not set
+# CONFIG_DVB_CX24116 is not set
+# CONFIG_DVB_CX24117 is not set
+# CONFIG_DVB_CX24120 is not set
+# CONFIG_DVB_SI21XX is not set
+# CONFIG_DVB_TS2020 is not set
+# CONFIG_DVB_DS3000 is not set
+# CONFIG_DVB_MB86A16 is not set
+# CONFIG_DVB_TDA10071 is not set
+
+#
+# DVB-T (terrestrial) frontends
+#
+# CONFIG_DVB_SP8870 is not set
+# CONFIG_DVB_SP887X is not set
+# CONFIG_DVB_CX22700 is not set
+# CONFIG_DVB_CX22702 is not set
+# CONFIG_DVB_S5H1432 is not set
+# CONFIG_DVB_DRXD is not set
+# CONFIG_DVB_L64781 is not set
+# CONFIG_DVB_TDA1004X is not set
+# CONFIG_DVB_NXT6000 is not set
+# CONFIG_DVB_MT352 is not set
+# CONFIG_DVB_ZL10353 is not set
+# CONFIG_DVB_DIB3000MB is not set
+# CONFIG_DVB_DIB3000MC is not set
+# CONFIG_DVB_DIB7000M is not set
+# CONFIG_DVB_DIB7000P is not set
+# CONFIG_DVB_DIB9000 is not set
+# CONFIG_DVB_TDA10048 is not set
+# CONFIG_DVB_AF9013 is not set
+# CONFIG_DVB_EC100 is not set
+# CONFIG_DVB_STV0367 is not set
+# CONFIG_DVB_CXD2820R is not set
+# CONFIG_DVB_CXD2841ER is not set
+# CONFIG_DVB_RTL2830 is not set
+# CONFIG_DVB_RTL2832 is not set
+# CONFIG_DVB_SI2168 is not set
+# CONFIG_DVB_ZD1301_DEMOD is not set
+# CONFIG_DVB_CXD2880 is not set
+
+#
+# DVB-C (cable) frontends
+#
+# CONFIG_DVB_VES1820 is not set
+# CONFIG_DVB_TDA10021 is not set
+# CONFIG_DVB_TDA10023 is not set
+# CONFIG_DVB_STV0297 is not set
+
+#
+# ATSC (North American/Korean Terrestrial/Cable DTV) frontends
+#
+# CONFIG_DVB_NXT200X is not set
+# CONFIG_DVB_OR51211 is not set
+# CONFIG_DVB_OR51132 is not set
+# CONFIG_DVB_BCM3510 is not set
+# CONFIG_DVB_LGDT330X is not set
+# CONFIG_DVB_LGDT3305 is not set
+# CONFIG_DVB_LGDT3306A is not set
+# CONFIG_DVB_LG2160 is not set
+# CONFIG_DVB_S5H1409 is not set
+# CONFIG_DVB_AU8522_DTV is not set
+# CONFIG_DVB_AU8522_V4L is not set
+# CONFIG_DVB_S5H1411 is not set
+
+#
+# ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_S921 is not set
+# CONFIG_DVB_DIB8000 is not set
+# CONFIG_DVB_MB86A20S is not set
+
+#
+# ISDB-S (satellite) & ISDB-T (terrestrial) frontends
+#
+# CONFIG_DVB_TC90522 is not set
+# CONFIG_DVB_MN88443X is not set
+
+#
+# Digital terrestrial only tuners/PLL
+#
+# CONFIG_DVB_PLL is not set
+# CONFIG_DVB_TUNER_DIB0070 is not set
+# CONFIG_DVB_TUNER_DIB0090 is not set
+
+#
+# SEC control devices for DVB-S
+#
+# CONFIG_DVB_DRX39XYJ is not set
+# CONFIG_DVB_LNBH25 is not set
+# CONFIG_DVB_LNBH29 is not set
+# CONFIG_DVB_LNBP21 is not set
+# CONFIG_DVB_LNBP22 is not set
+# CONFIG_DVB_ISL6405 is not set
+# CONFIG_DVB_ISL6421 is not set
+# CONFIG_DVB_ISL6423 is not set
+# CONFIG_DVB_A8293 is not set
+# CONFIG_DVB_LGS8GL5 is not set
+# CONFIG_DVB_LGS8GXX is not set
+# CONFIG_DVB_ATBM8830 is not set
+# CONFIG_DVB_TDA665x is not set
+# CONFIG_DVB_IX2505V is not set
+# CONFIG_DVB_M88RS2000 is not set
+# CONFIG_DVB_AF9033 is not set
+# CONFIG_DVB_HORUS3A is not set
+# CONFIG_DVB_ASCOT2E is not set
+# CONFIG_DVB_HELENE is not set
+
+#
+# Common Interface (EN50221) controller drivers
+#
+# CONFIG_DVB_CXD2099 is not set
+# CONFIG_DVB_SP2 is not set
+
+#
+# Tools to develop new frontends
+#
+# CONFIG_DVB_DUMMY_FE is not set
+# end of Customise DVB Frontends
+
+#
+# Graphics support
+#
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_IMX8_PC=y
+CONFIG_IMX8_PRG=y
+CONFIG_IMX8_DPRC=y
+CONFIG_IMX_DPU_CORE=y
+CONFIG_IMX_DPU_BLIT=y
+CONFIG_IMX_LCDIF_CORE=y
+CONFIG_IMX_LCDIFV3_CORE=y
+CONFIG_DRM=y
+CONFIG_DRM_MIPI_DSI=y
+# CONFIG_DRM_DP_AUX_CHARDEV is not set
+# CONFIG_DRM_DEBUG_MM is not set
+# CONFIG_DRM_DEBUG_SELFTEST is not set
+CONFIG_DRM_KMS_HELPER=y
+CONFIG_DRM_KMS_FB_HELPER=y
+CONFIG_DRM_FBDEV_EMULATION=y
+CONFIG_DRM_FBDEV_OVERALLOC=100
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+# CONFIG_DRM_DP_CEC is not set
+CONFIG_DRM_GEM_CMA_HELPER=y
+CONFIG_DRM_KMS_CMA_HELPER=y
+CONFIG_DRM_GEM_SHMEM_HELPER=y
+CONFIG_DRM_VM=y
+CONFIG_DRM_SCHED=m
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_I2C_NXP_TDA9950 is not set
+# end of I2C encoder or helper chips
+
+#
+# ARM devices
+#
+# CONFIG_DRM_HDLCD is not set
+CONFIG_DRM_MALI_DISPLAY=m
+# CONFIG_DRM_KOMEDA is not set
+# end of ARM devices
+
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_AMDGPU is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+# end of ACP (Audio CoProcessor) Configuration
+
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_VGEM is not set
+# CONFIG_DRM_VKMS is not set
+CONFIG_DRM_ATI_PCIGART=y
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_RCAR_DW_HDMI is not set
+# CONFIG_DRM_RCAR_LVDS is not set
+CONFIG_DRM_RCAR_WRITEBACK=y
+# CONFIG_DRM_QXL is not set
+# CONFIG_DRM_BOCHS is not set
+# CONFIG_DRM_VIRTIO_GPU is not set
+CONFIG_DRM_PANEL=y
+
+#
+# Display Panels
+#
+# CONFIG_DRM_PANEL_ARM_VERSATILE is not set
+# CONFIG_DRM_PANEL_LVDS is not set
+CONFIG_DRM_PANEL_SIMPLE=y
+# CONFIG_DRM_PANEL_FEIYANG_FY07024DI26A30D is not set
+# CONFIG_DRM_PANEL_ILITEK_IL9322 is not set
+# CONFIG_DRM_PANEL_ILITEK_ILI9881C is not set
+# CONFIG_DRM_PANEL_INNOLUX_P079ZCA is not set
+# CONFIG_DRM_PANEL_JDI_LT070ME05000 is not set
+# CONFIG_DRM_PANEL_KINGDISPLAY_KD097D04 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_LD9040 is not set
+# CONFIG_DRM_PANEL_LG_LB035Q02 is not set
+# CONFIG_DRM_PANEL_LG_LG4573 is not set
+# CONFIG_DRM_PANEL_NEC_NL8048HL11 is not set
+# CONFIG_DRM_PANEL_NOVATEK_NT39016 is not set
+# CONFIG_DRM_PANEL_OLIMEX_LCD_OLINUXINO is not set
+# CONFIG_DRM_PANEL_ORISETECH_OTM8009A is not set
+# CONFIG_DRM_PANEL_OSD_OSD101T2587_53TS is not set
+# CONFIG_DRM_PANEL_PANASONIC_VVX10F034N00 is not set
+# CONFIG_DRM_PANEL_RASPBERRYPI_TOUCHSCREEN is not set
+CONFIG_DRM_PANEL_RAYDIUM_RM67191=y
+# CONFIG_DRM_PANEL_RAYDIUM_RM68200 is not set
+# CONFIG_DRM_PANEL_ROCKTECH_JH057N00900 is not set
+# CONFIG_DRM_PANEL_RONBO_RB070D30 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6D16D0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E3HA2 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63J0X03 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E63M0 is not set
+# CONFIG_DRM_PANEL_SAMSUNG_S6E8AA0 is not set
+CONFIG_DRM_PANEL_SEIKO_43WVF1G=y
+# CONFIG_DRM_PANEL_SHARP_LQ101R1SX01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS037V7DW01 is not set
+# CONFIG_DRM_PANEL_SHARP_LS043T1LE01 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7701 is not set
+# CONFIG_DRM_PANEL_SITRONIX_ST7789V is not set
+# CONFIG_DRM_PANEL_SONY_ACX565AKM is not set
+# CONFIG_DRM_PANEL_TPO_TD028TTEC1 is not set
+# CONFIG_DRM_PANEL_TPO_TD043MTEA1 is not set
+# CONFIG_DRM_PANEL_TPO_TPG110 is not set
+# CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA is not set
+CONFIG_DRM_PANEL_WKS_101WX001=y
+# end of Display Panels
+
+CONFIG_DRM_BRIDGE=y
+CONFIG_DRM_PANEL_BRIDGE=y
+
+#
+# Display Interface Bridges
+#
+# CONFIG_DRM_ANALOGIX_ANX78XX is not set
+# CONFIG_DRM_CDNS_DSI is not set
+# CONFIG_DRM_DUMB_VGA_DAC is not set
+CONFIG_DRM_FSL_IMX_LVDS_BRIDGE=y
+# CONFIG_DRM_LVDS_ENCODER is not set
+# CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW is not set
+CONFIG_DRM_SEC_MIPI_DSIM=y
+CONFIG_DRM_NXP_SEIKO_43WVFIG=y
+# CONFIG_DRM_NXP_PTN3460 is not set
+# CONFIG_DRM_PARADE_PS8622 is not set
+# CONFIG_DRM_SIL_SII8620 is not set
+# CONFIG_DRM_SII902X is not set
+# CONFIG_DRM_SII9234 is not set
+# CONFIG_DRM_THINE_THC63LVD1024 is not set
+# CONFIG_DRM_TOSHIBA_TC358764 is not set
+# CONFIG_DRM_TOSHIBA_TC358767 is not set
+# CONFIG_DRM_TI_TFP410 is not set
+# CONFIG_DRM_TI_SN65DSI86 is not set
+# CONFIG_DRM_I2C_ADV7511 is not set
+CONFIG_DRM_NWL_MIPI_DSI=y
+CONFIG_DRM_CDNS_MHDP=y
+CONFIG_DRM_CDNS_HDMI=y
+CONFIG_DRM_CDNS_DP=y
+CONFIG_DRM_CDNS_AUDIO=y
+CONFIG_DRM_CDNS_HDMI_CEC=y
+CONFIG_DRM_DW_HDMI=y
+# CONFIG_DRM_DW_HDMI_AHB_AUDIO is not set
+CONFIG_DRM_DW_HDMI_GP_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+# CONFIG_DRM_ITE_IT6263 is not set
+# end of Display Interface Bridges
+
+CONFIG_DRM_IMX=y
+CONFIG_DRM_IMX_LCDIF_MUX_DISPLAY=y
+CONFIG_DRM_IMX_PARALLEL_DISPLAY=y
+CONFIG_DRM_IMX_TVE=y
+CONFIG_DRM_IMX_LDB=y
+CONFIG_IMX8MP_HDMI_PAVI=y
+CONFIG_DRM_IMX_HDMI=y
+CONFIG_DRM_IMX_SEC_DSIM=y
+CONFIG_DRM_IMX_DPU=y
+CONFIG_DRM_IMX_LCDIF=y
+CONFIG_DRM_IMX_LCDIFV3=y
+CONFIG_DRM_IMX_DCSS=y
+CONFIG_DRM_IMX_CDNS_MHDP=y
+# CONFIG_DRM_ETNAVIV is not set
+# CONFIG_DRM_ARCPGU is not set
+# CONFIG_DRM_HISI_HIBMC is not set
+# CONFIG_DRM_HISI_KIRIN is not set
+# CONFIG_DRM_MXSFB is not set
+# CONFIG_DRM_GM12U320 is not set
+# CONFIG_TINYDRM_HX8357D is not set
+# CONFIG_TINYDRM_ILI9225 is not set
+# CONFIG_TINYDRM_ILI9341 is not set
+# CONFIG_TINYDRM_MI0283QT is not set
+# CONFIG_TINYDRM_REPAPER is not set
+# CONFIG_TINYDRM_ST7586 is not set
+# CONFIG_TINYDRM_ST7735R is not set
+# CONFIG_DRM_PL111 is not set
+# CONFIG_DRM_XEN is not set
+CONFIG_DRM_LIMA=m
+CONFIG_DRM_PANFROST=m
+CONFIG_DRM_LEGACY=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+CONFIG_DRM_PANEL_ORIENTATION_QUIRKS=y
+
+#
+# Frame buffer Devices
+#
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_DEFERRED_IO=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_IMX is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+CONFIG_XEN_FBDEV_FRONTEND=y
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_FB_MX3=y
+# CONFIG_FB_MXS is not set
+# CONFIG_FB_SIMPLE is not set
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_FB_SM712 is not set
+CONFIG_FB_MXC=y
+# CONFIG_FB_MXC_DISP_FRAMEWORK is not set
+# CONFIG_FB_MXC_OVERLAY is not set
+CONFIG_FB_MXC_EDID=y
+# CONFIG_FB_MXC_EINK_PANEL is not set
+# CONFIG_FB_MXC_EINK_V2_PANEL is not set
+# end of Frame buffer Devices
+
+#
+# Backlight & LCD device support
+#
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+# CONFIG_BACKLIGHT_GENERIC is not set
+CONFIG_BACKLIGHT_PWM=y
+# CONFIG_BACKLIGHT_PM8941_WLED is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630A is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+# CONFIG_BACKLIGHT_GPIO is not set
+# CONFIG_BACKLIGHT_LV5207LP is not set
+# CONFIG_BACKLIGHT_BD6107 is not set
+# CONFIG_BACKLIGHT_ARCXCNN is not set
+# end of Backlight & LCD device support
+
+CONFIG_VIDEOMODE_HELPERS=y
+CONFIG_HDMI=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_DUMMY_CONSOLE_COLUMNS=80
+CONFIG_DUMMY_CONSOLE_ROWS=25
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
+# end of Console display driver support
+
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+# end of Graphics support
+
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_PCM_ELD=y
+CONFIG_SND_PCM_IEC958=y
+CONFIG_SND_HWDEP=y
+CONFIG_SND_RAWMIDI=y
+# CONFIG_SND_OSSEMUL is not set
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_MAX_CARDS=32
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_PCI is not set
+
+#
+# HD-Audio
+#
+# end of HD-Audio
+
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_SND_USB_AUDIO_USE_MEDIA_CONTROLLER=y
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SND_XEN_FRONTEND is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_BIGBEN_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_MACALLY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CREATIVE_SB0540 is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELAN is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GOOGLE_HAMMER is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_VIEWSONIC is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MALTRON is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_U2FZERO is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+# end of Special HID drivers
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+# end of USB HID support
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+# end of I2C HID support
+# end of HID support
+
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+# CONFIG_USB_LED_TRIG is not set
+CONFIG_USB_ULPI_BUS=y
+# CONFIG_USB_CONN_GPIO is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=y
+CONFIG_USB_PCI=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_OTG=y
+CONFIG_USB_OTG_WHITELIST=y
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_OTG_FSM is not set
+# CONFIG_USB_LEDS_TRIGGER_USBPORT is not set
+CONFIG_USB_AUTOSUSPEND_DELAY=2
+CONFIG_USB_MON=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=y
+# CONFIG_USB_XHCI_DBGCAP is not set
+CONFIG_USB_XHCI_PCI=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_TT_NEWSCHED=y
+CONFIG_USB_EHCI_PCI=y
+# CONFIG_USB_EHCI_FSL is not set
+# CONFIG_USB_EHCI_MXC is not set
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PCI=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+CONFIG_USB_HCD_TEST_MODE=y
+
+#
+# USB Device Class drivers
+#
+CONFIG_USB_ACM=y
+# CONFIG_USB_PRINTER is not set
+CONFIG_USB_WDM=y
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+CONFIG_USB_UAS=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_CDNS3 is not set
+# CONFIG_USB_MUSB_HDRC is not set
+CONFIG_USB_DWC3=y
+# CONFIG_USB_DWC3_ULPI is not set
+# CONFIG_USB_DWC3_HOST is not set
+# CONFIG_USB_DWC3_GADGET is not set
+CONFIG_USB_DWC3_DUAL_ROLE=y
+
+#
+# Platform Glue Driver Support
+#
+CONFIG_USB_DWC3_HAPS=y
+CONFIG_USB_DWC3_OF_SIMPLE=y
+CONFIG_USB_DWC3_IMX8MP=y
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_SIMPLE=y
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+CONFIG_USB_SERIAL_CH341=y
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+CONFIG_USB_SERIAL_CP210X=y
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+CONFIG_USB_SERIAL_FTDI_SIO=y
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_F81232 is not set
+# CONFIG_USB_SERIAL_F8153X is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_METRO is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MXUPORT is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+CONFIG_USB_SERIAL_PL2303=y
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+CONFIG_USB_SERIAL_WWAN=y
+CONFIG_USB_SERIAL_OPTION=y
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_XSENS_MT is not set
+# CONFIG_USB_SERIAL_WISHBONE is not set
+# CONFIG_USB_SERIAL_SSU100 is not set
+# CONFIG_USB_SERIAL_QT2 is not set
+# CONFIG_USB_SERIAL_UPD78F0730 is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+CONFIG_USB_EHSET_TEST_FIXTURE=y
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+CONFIG_USB_HSIC_USB3503=y
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+# CONFIG_USB_CHAOSKEY is not set
+
+#
+# USB Physical Layer drivers
+#
+CONFIG_USB_PHY=y
+CONFIG_NOP_USB_XCEIV=y
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+CONFIG_USB_MXS_PHY=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_ULPI_VIEWPORT=y
+# end of USB Physical Layer drivers
+
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+# CONFIG_USB_GADGET_DEBUG_FS is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+CONFIG_USB_FSL_USB2=y
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+CONFIG_USB_SNP_CORE=y
+CONFIG_USB_SNP_UDC_PLAT=y
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_AMD5536UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_NET2280 is not set
+# CONFIG_USB_GOKU is not set
+# CONFIG_USB_EG20T is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# end of USB Peripheral Controller
+
+CONFIG_USB_LIBCOMPOSITE=y
+CONFIG_USB_U_ETHER=y
+CONFIG_USB_F_ECM=m
+CONFIG_USB_F_EEM=y
+CONFIG_USB_F_SUBSET=m
+CONFIG_USB_F_RNDIS=y
+CONFIG_USB_F_MASS_STORAGE=y
+CONFIG_USB_CONFIGFS=y
+# CONFIG_USB_CONFIGFS_SERIAL is not set
+# CONFIG_USB_CONFIGFS_ACM is not set
+# CONFIG_USB_CONFIGFS_OBEX is not set
+# CONFIG_USB_CONFIGFS_NCM is not set
+# CONFIG_USB_CONFIGFS_ECM is not set
+# CONFIG_USB_CONFIGFS_ECM_SUBSET is not set
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_EEM=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
+# CONFIG_USB_CONFIGFS_F_LB_SS is not set
+# CONFIG_USB_CONFIGFS_F_FS is not set
+# CONFIG_USB_CONFIGFS_F_UAC1 is not set
+# CONFIG_USB_CONFIGFS_F_UAC1_LEGACY is not set
+# CONFIG_USB_CONFIGFS_F_UAC2 is not set
+# CONFIG_USB_CONFIGFS_F_MIDI is not set
+# CONFIG_USB_CONFIGFS_F_HID is not set
+# CONFIG_USB_CONFIGFS_F_UVC is not set
+# CONFIG_USB_CONFIGFS_F_PRINTER is not set
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_ETH_EEM=y
+# CONFIG_USB_G_NCM is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+CONFIG_USB_MASS_STORAGE=m
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_ACM_MS is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_DBGP is not set
+# CONFIG_USB_G_WEBCAM is not set
+CONFIG_TYPEC=y
+CONFIG_TYPEC_TCPM=y
+CONFIG_TYPEC_TCPCI=y
+# CONFIG_TYPEC_RT1711H is not set
+# CONFIG_TYPEC_FUSB302 is not set
+# CONFIG_TYPEC_UCSI is not set
+# CONFIG_TYPEC_TPS6598X is not set
+
+#
+# USB Type-C Multiplexer/DeMultiplexer Switch support
+#
+# CONFIG_TYPEC_MUX_PI3USB30532 is not set
+CONFIG_TYPEC_SWITCH_GPIO=y
+# end of USB Type-C Multiplexer/DeMultiplexer Switch support
+
+#
+# USB Type-C Alternate Mode drivers
+#
+# CONFIG_TYPEC_DP_ALTMODE is not set
+# end of USB Type-C Alternate Mode drivers
+
+CONFIG_USB_ROLE_SWITCH=y
+CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+# CONFIG_PWRSEQ_SD8787 is not set
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=32
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_ARMMMCI=y
+CONFIG_MMC_STM32_SDMMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+# CONFIG_MMC_SDHCI_PCI is not set
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_ARASAN=y
+# CONFIG_MMC_SDHCI_OF_ASPEED is not set
+# CONFIG_MMC_SDHCI_OF_AT91 is not set
+CONFIG_MMC_SDHCI_OF_ESDHC=y
+# CONFIG_MMC_SDHCI_OF_DWCMSHC is not set
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_MMC_SDHCI_ESDHC_IMX=y
+CONFIG_MMC_SDHCI_F_SDH30=y
+# CONFIG_MMC_MXC is not set
+# CONFIG_MMC_TIFM_SD is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_CB710 is not set
+# CONFIG_MMC_VIA_SDMMC is not set
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_PLTFM=y
+# CONFIG_MMC_DW_BLUEFIELD is not set
+CONFIG_MMC_DW_EXYNOS=y
+CONFIG_MMC_DW_HI3798CV200=y
+CONFIG_MMC_DW_K3=y
+# CONFIG_MMC_DW_PCI is not set
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+CONFIG_MMC_CQHCI=y
+# CONFIG_MMC_TOSHIBA_PCI is not set
+# CONFIG_MMC_MTK is not set
+CONFIG_MMC_SDHCI_XENON=y
+# CONFIG_MMC_SDHCI_OMAP is not set
+# CONFIG_MMC_SDHCI_AM654 is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_AN30259A is not set
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3532 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_2COLOR=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+CONFIG_LEDS_PWM=y
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_SYSCON is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+# CONFIG_LEDS_SPI_BYTE is not set
+# CONFIG_LEDS_TI_LMU_COMMON is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_ONESHOT=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_CPU=y
+# CONFIG_LEDS_TRIGGER_ACTIVITY is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_LEDS_TRIGGER_TRANSIENT is not set
+# CONFIG_LEDS_TRIGGER_CAMERA is not set
+# CONFIG_LEDS_TRIGGER_PANIC is not set
+CONFIG_LEDS_TRIGGER_NETDEV=y
+CONFIG_LEDS_TRIGGER_PATTERN=y
+# CONFIG_LEDS_TRIGGER_AUDIO is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_SUPPORT=y
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+CONFIG_RTC_NVMEM=y
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABEOZ9 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RK808 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+CONFIG_RTC_DRV_PCF8563=y
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3028 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+# CONFIG_RTC_DRV_SD3078 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+# CONFIG_RTC_DRV_CROS_EC is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_IMXDI is not set
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+# CONFIG_RTC_DRV_CADENCE is not set
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_MXC is not set
+# CONFIG_RTC_DRV_MXC_V2 is not set
+CONFIG_RTC_DRV_SNVS=y
+# CONFIG_RTC_DRV_IMX_SC is not set
+# CONFIG_RTC_DRV_IMX_RPMSG is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+CONFIG_DMADEVICES=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_ASYNC_TX_ENABLE_CHANNEL_SWITCH=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_VIRTUAL_CHANNELS=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_AMBA_PL08X is not set
+# CONFIG_BCM_SBA_RAID is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_DMA is not set
+# CONFIG_DW_AXI_DMAC is not set
+CONFIG_FSL_EDMA=y
+# CONFIG_FSL_QDMA is not set
+CONFIG_FSL_EDMA_V3=y
+# CONFIG_IMX_DMA is not set
+CONFIG_IMX_SDMA=y
+# CONFIG_INTEL_IDMA64 is not set
+CONFIG_MV_XOR_V2=y
+CONFIG_MXS_DMA=y
+CONFIG_MX3_IPU=y
+CONFIG_MX3_IPU_IRQS=4
+# CONFIG_PL330_DMA is not set
+# CONFIG_XILINX_DMA is not set
+# CONFIG_XILINX_ZYNQMP_DMA is not set
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+# CONFIG_DW_DMAC_PCI is not set
+# CONFIG_DW_EDMA is not set
+# CONFIG_DW_EDMA_PCIE is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+CONFIG_DMATEST=y
+CONFIG_DMA_ENGINE_RAID=y
+
+#
+# DMABUF options
+#
+CONFIG_SYNC_FILE=y
+# CONFIG_SW_SYNC is not set
+# CONFIG_UDMABUF is not set
+# CONFIG_DMABUF_SELFTESTS is not set
+# end of DMABUF options
+
+# CONFIG_AUXDISPLAY is not set
+CONFIG_UIO=y
+# CONFIG_UIO_CIF is not set
+# CONFIG_UIO_PDRV_GENIRQ is not set
+# CONFIG_UIO_DMEM_GENIRQ is not set
+# CONFIG_UIO_AEC is not set
+# CONFIG_UIO_SERCOS3 is not set
+CONFIG_UIO_PCI_GENERIC=y
+# CONFIG_UIO_NETX is not set
+# CONFIG_UIO_PRUSS is not set
+# CONFIG_UIO_MF624 is not set
+CONFIG_UIO_IVSHMEM=y
+CONFIG_VFIO_IOMMU_TYPE1=y
+CONFIG_VFIO_VIRQFD=y
+CONFIG_VFIO=y
+# CONFIG_VFIO_NOIOMMU is not set
+CONFIG_VFIO_PCI=y
+CONFIG_VFIO_PCI_MMAP=y
+CONFIG_VFIO_PCI_INTX=y
+# CONFIG_VFIO_PLATFORM is not set
+# CONFIG_VFIO_MDEV is not set
+# CONFIG_VIRT_DRIVERS is not set
+CONFIG_VIRTIO=y
+CONFIG_VIRTIO_MENU=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_PCI_LEGACY=y
+CONFIG_VIRTIO_BALLOON=y
+# CONFIG_VIRTIO_INPUT is not set
+CONFIG_VIRTIO_MMIO=y
+# CONFIG_VIRTIO_MMIO_CMDLINE_DEVICES is not set
+# CONFIG_VIRTIO_IVSHMEM is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# end of Microsoft Hyper-V guest support
+
+#
+# Xen driver support
+#
+CONFIG_XEN_BALLOON=y
+CONFIG_XEN_SCRUB_PAGES_DEFAULT=y
+CONFIG_XEN_DEV_EVTCHN=y
+CONFIG_XEN_BACKEND=y
+CONFIG_XENFS=y
+CONFIG_XEN_COMPAT_XENFS=y
+CONFIG_XEN_SYS_HYPERVISOR=y
+CONFIG_XEN_XENBUS_FRONTEND=y
+CONFIG_XEN_GNTDEV=y
+CONFIG_XEN_GRANT_DEV_ALLOC=y
+# CONFIG_XEN_GRANT_DMA_ALLOC is not set
+CONFIG_SWIOTLB_XEN=y
+# CONFIG_XEN_PVCALLS_FRONTEND is not set
+# CONFIG_XEN_PVCALLS_BACKEND is not set
+CONFIG_XEN_PRIVCMD=y
+CONFIG_XEN_AUTO_XLATE=y
+# end of Xen driver support
+
+# CONFIG_GREYBUS is not set
+CONFIG_STAGING=y
+# CONFIG_PRISM2_USB is not set
+# CONFIG_COMEDI is not set
+# CONFIG_RTL8192U is not set
+# CONFIG_RTLLIB is not set
+# CONFIG_RTL8723BS is not set
+# CONFIG_R8712U is not set
+# CONFIG_R8188EU is not set
+# CONFIG_RTS5208 is not set
+# CONFIG_VT6655 is not set
+# CONFIG_VT6656 is not set
+
+#
+# IIO staging drivers
+#
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16203 is not set
+# CONFIG_ADIS16240 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7816 is not set
+# CONFIG_AD7192 is not set
+# CONFIG_AD7280 is not set
+# end of Analog to digital converters
+
+#
+# Analog digital bi-direction converters
+#
+# CONFIG_ADT7316 is not set
+# end of Analog digital bi-direction converters
+
+#
+# Capacitance to digital converters
+#
+# CONFIG_AD7150 is not set
+# CONFIG_AD7746 is not set
+# end of Capacitance to digital converters
+
+#
+# Direct Digital Synthesis
+#
+# CONFIG_AD9832 is not set
+# CONFIG_AD9834 is not set
+# end of Direct Digital Synthesis
+
+#
+# Network Analyzer, Impedance Converters
+#
+# CONFIG_AD5933 is not set
+# end of Network Analyzer, Impedance Converters
+
+#
+# Active energy metering IC
+#
+# CONFIG_ADE7854 is not set
+# end of Active energy metering IC
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S1210 is not set
+# end of Resolver to digital converters
+# end of IIO staging drivers
+
+# CONFIG_FB_SM750 is not set
+
+#
+# Speakup console speech
+#
+# CONFIG_SPEAKUP is not set
+# end of Speakup console speech
+
+CONFIG_STAGING_MEDIA=y
+CONFIG_VIDEO_IMX_CAPTURE=y
+
+#
+# i.MX8QXP/QM Camera ISI/MIPI Features support
+#
+CONFIG_IMX8_MEDIA_DEVICE=m
+CONFIG_IMX8_ISI_HW=y
+CONFIG_IMX8_ISI_CORE=y
+CONFIG_IMX8_ISI_CAPTURE=y
+CONFIG_IMX8_ISI_M2M=y
+CONFIG_IMX8_MIPI_CSI2=y
+CONFIG_IMX8_MIPI_CSI2_SAM=y
+CONFIG_IMX8_PARALLEL_CSI=y
+CONFIG_GMSL_MAX9286=y
+# end of i.MX8QXP/QM Camera ISI/MIPI Features support
+
+#
+# soc_camera sensor drivers
+#
+
+#
+# Android
+#
+CONFIG_ION=y
+CONFIG_ION_SYSTEM_HEAP=y
+CONFIG_ION_CMA_HEAP=y
+# end of Android
+
+# CONFIG_STAGING_BOARD is not set
+# CONFIG_LTE_GDM724X is not set
+# CONFIG_GS_FPGABOOT is not set
+# CONFIG_UNISYSSPAR is not set
+# CONFIG_COMMON_CLK_XLNX_CLKWZRD is not set
+# CONFIG_FB_TFT is not set
+# CONFIG_WILC1000_SDIO is not set
+# CONFIG_WILC1000_SPI is not set
+# CONFIG_MOST is not set
+# CONFIG_KS7010 is not set
+# CONFIG_PI433 is not set
+
+#
+# Gasket devices
+#
+# CONFIG_STAGING_GASKET_FRAMEWORK is not set
+# end of Gasket devices
+
+# CONFIG_XIL_AXIS_FIFO is not set
+# CONFIG_FIELDBUS_DEV is not set
+# CONFIG_KPC2000 is not set
+# CONFIG_USB_WUSB_CBAF is not set
+# CONFIG_UWB is not set
+CONFIG_EXFAT_FS=y
+CONFIG_EXFAT_DONT_MOUNT_VFAT=y
+CONFIG_EXFAT_DISCARD=y
+# CONFIG_EXFAT_DELAYED_SYNC is not set
+# CONFIG_EXFAT_KERNEL_DEBUG is not set
+# CONFIG_EXFAT_DEBUG_MSG is not set
+CONFIG_EXFAT_DEFAULT_CODEPAGE=437
+CONFIG_EXFAT_DEFAULT_IOCHARSET="utf8"
+# CONFIG_QLGE is not set
+CONFIG_FSL_SDK_DPA=y
+
+#
+# Freescale Datapath QMan/BMan options
+#
+# CONFIG_FSL_DPA_CHECKING is not set
+CONFIG_FSL_DPA_CAN_WAIT=y
+CONFIG_FSL_DPA_CAN_WAIT_SYNC=y
+CONFIG_FSL_DPA_PIRQ_FAST=y
+CONFIG_FSL_DPA_PIRQ_SLOW=y
+CONFIG_FSL_DPA_PORTAL_SHARE=y
+CONFIG_FSL_SDK_BMAN=y
+CONFIG_FSL_BMAN_CONFIG=y
+# CONFIG_FSL_BMAN_TEST is not set
+CONFIG_FSL_BMAN_DEBUGFS=y
+CONFIG_FSL_SDK_QMAN=y
+CONFIG_FSL_QMAN_POLL_LIMIT=32
+CONFIG_FSL_QMAN_CONFIG=y
+# CONFIG_FSL_QMAN_TEST is not set
+CONFIG_FSL_QMAN_DEBUGFS=y
+CONFIG_FSL_QMAN_FQD_SZ=10
+CONFIG_FSL_QMAN_PFDR_SZ=13
+CONFIG_FSL_QMAN_CI_SCHED_CFG_SRCCIV=4
+CONFIG_FSL_QMAN_CI_SCHED_CFG_SRQ_W=3
+CONFIG_FSL_QMAN_CI_SCHED_CFG_RW_W=2
+CONFIG_FSL_QMAN_CI_SCHED_CFG_BMAN_W=2
+CONFIG_FSL_QMAN_PIRQ_DQRR_ITHRESH=12
+CONFIG_FSL_QMAN_PIRQ_MR_ITHRESH=4
+CONFIG_FSL_QMAN_PIRQ_IPERIOD=100
+CONFIG_FSL_QMAN_FQ_LOOKUP=y
+CONFIG_QMAN_CEETM_UPDATE_PERIOD=1000
+CONFIG_FSL_QMAN_INIT_TIMEOUT=10
+CONFIG_FSL_USDPAA=y
+# end of Freescale Datapath QMan/BMan options
+
+CONFIG_FSL_PPFE=y
+CONFIG_FSL_PPFE_UTIL_DISABLED=y
+# CONFIG_GOLDFISH is not set
+CONFIG_MFD_CROS_EC=y
+CONFIG_CHROME_PLATFORMS=y
+CONFIG_CROS_EC=y
+CONFIG_CROS_EC_I2C=y
+# CONFIG_CROS_EC_RPMSG is not set
+CONFIG_CROS_EC_SPI=y
+CONFIG_CROS_EC_PROTO=y
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+CONFIG_COMMON_CLK_VERSATILE=y
+CONFIG_CLK_SP810=y
+CONFIG_CLK_VEXPRESS_OSC=y
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+CONFIG_COMMON_CLK_RK808=y
+CONFIG_COMMON_CLK_SCPI=y
+# CONFIG_COMMON_CLK_SI5341 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_CLK_QORIQ=y
+CONFIG_COMMON_CLK_XGENE=y
+CONFIG_COMMON_CLK_PWM=y
+# CONFIG_COMMON_CLK_VC5 is not set
+# CONFIG_COMMON_CLK_FIXED_MMIO is not set
+CONFIG_MXC_CLK=y
+CONFIG_MXC_CLK_SCU=y
+CONFIG_CLK_IMX8MM=y
+CONFIG_CLK_IMX8MN=y
+CONFIG_CLK_IMX8MP=y
+CONFIG_CLK_IMX8MQ=y
+CONFIG_CLK_IMX8QXP=y
+CONFIG_ARCH_S32_CLK=y
+# end of Common Clock Framework
+
+CONFIG_HWSPINLOCK=y
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_ARM_ARCH_TIMER=y
+CONFIG_ARM_ARCH_TIMER_EVTSTREAM=y
+CONFIG_ARM_ARCH_TIMER_OOL_WORKAROUND=y
+CONFIG_FSL_ERRATUM_A008585=y
+CONFIG_HISILICON_ERRATUM_161010101=y
+CONFIG_ARM64_ERRATUM_858921=y
+CONFIG_CLKSRC_VERSATILE=y
+CONFIG_TIMER_IMX_SYS_CTR=y
+# end of Clock Source drivers
+
+CONFIG_MAILBOX=y
+CONFIG_ARM_MHU=y
+CONFIG_IMX_MBOX=y
+CONFIG_PLATFORM_MHU=y
+# CONFIG_PL320_MBOX is not set
+# CONFIG_ALTERA_MBOX is not set
+# CONFIG_MAILBOX_TEST is not set
+CONFIG_IOMMU_IOVA=y
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+
+#
+# Generic IOMMU Pagetable Support
+#
+CONFIG_IOMMU_IO_PGTABLE=y
+CONFIG_IOMMU_IO_PGTABLE_LPAE=y
+# CONFIG_IOMMU_IO_PGTABLE_LPAE_SELFTEST is not set
+# CONFIG_IOMMU_IO_PGTABLE_ARMV7S is not set
+# end of Generic IOMMU Pagetable Support
+
+# CONFIG_IOMMU_DEBUGFS is not set
+# CONFIG_IOMMU_DEFAULT_PASSTHROUGH is not set
+CONFIG_OF_IOMMU=y
+CONFIG_IOMMU_DMA=y
+CONFIG_ARM_SMMU=y
+CONFIG_ARM_SMMU_DISABLE_BYPASS_BY_DEFAULT=y
+CONFIG_ARM_SMMU_V3=y
+# CONFIG_VIRTIO_IOMMU is not set
+
+#
+# Remoteproc drivers
+#
+CONFIG_REMOTEPROC=y
+CONFIG_IMX_REMOTEPROC=y
+# end of Remoteproc drivers
+
+#
+# Rpmsg drivers
+#
+CONFIG_RPMSG=y
+# CONFIG_RPMSG_CHAR is not set
+# CONFIG_RPMSG_QCOM_GLINK_RPM is not set
+CONFIG_RPMSG_VIRTIO=y
+CONFIG_HAVE_IMX_RPMSG=y
+CONFIG_IMX_RPMSG_PINGPONG=m
+CONFIG_IMX_RPMSG_TTY=m
+# end of Rpmsg drivers
+
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+# end of Amlogic SoC drivers
+
+#
+# Aspeed SoC drivers
+#
+# end of Aspeed SoC drivers
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+# end of Broadcom SoC drivers
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+# CONFIG_QUICC_ENGINE is not set
+CONFIG_FSL_GUTS=y
+# CONFIG_FSL_QIXIS is not set
+# CONFIG_FSL_RCPM is not set
+# end of NXP/Freescale QorIQ SoC drivers
+
+#
+# i.MX SoC drivers
+#
+CONFIG_IMX_GPCV2_PM_DOMAINS=y
+CONFIG_IMX_SCU_SOC=y
+CONFIG_IMX8M_PM_DOMAINS=y
+CONFIG_IMX8M_BUSFREQ=y
+CONFIG_SECVIO_SC=y
+# end of i.MX SoC drivers
+
+#
+# Qualcomm SoC drivers
+#
+# end of Qualcomm SoC drivers
+
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# end of Xilinx SoC drivers
+# end of SOC (System On Chip) specific Drivers
+
+CONFIG_PM_DEVFREQ=y
+
+#
+# DEVFREQ Governors
+#
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+# CONFIG_DEVFREQ_GOV_PERFORMANCE is not set
+# CONFIG_DEVFREQ_GOV_POWERSAVE is not set
+# CONFIG_DEVFREQ_GOV_USERSPACE is not set
+# CONFIG_DEVFREQ_GOV_PASSIVE is not set
+
+#
+# DEVFREQ Drivers
+#
+# CONFIG_PM_DEVFREQ_EVENT is not set
+CONFIG_EXTCON=y
+
+#
+# Extcon Device Drivers
+#
+# CONFIG_EXTCON_ADC_JACK is not set
+# CONFIG_EXTCON_FSA9480 is not set
+# CONFIG_EXTCON_GPIO is not set
+# CONFIG_EXTCON_MAX3355 is not set
+CONFIG_EXTCON_PTN5150=y
+# CONFIG_EXTCON_RT8973A is not set
+# CONFIG_EXTCON_SM5502 is not set
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_EXTCON_USBC_CROS_EC=y
+# CONFIG_MEMORY is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+# CONFIG_IIO_BUFFER_CB is not set
+# CONFIG_IIO_BUFFER_HW_CONSUMER is not set
+CONFIG_IIO_KFIFO_BUF=y
+# CONFIG_IIO_CONFIGFS is not set
+CONFIG_IIO_TRIGGER=y
+CONFIG_IIO_CONSUMERS_PER_TRIGGER=2
+# CONFIG_IIO_SW_DEVICE is not set
+# CONFIG_IIO_SW_TRIGGER is not set
+
+#
+# Accelerometers
+#
+# CONFIG_ADIS16201 is not set
+# CONFIG_ADIS16209 is not set
+# CONFIG_ADXL345_I2C is not set
+# CONFIG_ADXL345_SPI is not set
+# CONFIG_ADXL372_SPI is not set
+# CONFIG_ADXL372_I2C is not set
+# CONFIG_BMA180 is not set
+# CONFIG_BMA220 is not set
+# CONFIG_BMC150_ACCEL is not set
+# CONFIG_DA280 is not set
+# CONFIG_DA311 is not set
+# CONFIG_DMARD06 is not set
+# CONFIG_DMARD09 is not set
+# CONFIG_DMARD10 is not set
+# CONFIG_IIO_ST_ACCEL_3AXIS is not set
+# CONFIG_KXSD9 is not set
+# CONFIG_KXCJK1013 is not set
+# CONFIG_MC3230 is not set
+# CONFIG_MMA7455_I2C is not set
+# CONFIG_MMA7455_SPI is not set
+# CONFIG_MMA7660 is not set
+# CONFIG_MMA8452 is not set
+# CONFIG_MMA9551 is not set
+# CONFIG_MMA9553 is not set
+# CONFIG_MXC4005 is not set
+# CONFIG_MXC6255 is not set
+# CONFIG_SCA3000 is not set
+# CONFIG_STK8312 is not set
+# CONFIG_STK8BA50 is not set
+# end of Accelerometers
+
+#
+# Analog to digital converters
+#
+# CONFIG_AD7124 is not set
+# CONFIG_AD7266 is not set
+# CONFIG_AD7291 is not set
+# CONFIG_AD7298 is not set
+# CONFIG_AD7476 is not set
+# CONFIG_AD7606_IFACE_PARALLEL is not set
+# CONFIG_AD7606_IFACE_SPI is not set
+# CONFIG_AD7766 is not set
+# CONFIG_AD7768_1 is not set
+# CONFIG_AD7780 is not set
+# CONFIG_AD7791 is not set
+# CONFIG_AD7793 is not set
+# CONFIG_AD7887 is not set
+# CONFIG_AD7923 is not set
+# CONFIG_AD7949 is not set
+# CONFIG_AD799X is not set
+# CONFIG_CC10001_ADC is not set
+# CONFIG_ENVELOPE_DETECTOR is not set
+# CONFIG_HI8435 is not set
+# CONFIG_HX711 is not set
+# CONFIG_INA2XX_ADC is not set
+# CONFIG_IMX7D_ADC is not set
+CONFIG_IMX8QXP_ADC=y
+# CONFIG_LTC2471 is not set
+# CONFIG_LTC2485 is not set
+# CONFIG_LTC2497 is not set
+# CONFIG_MAX1027 is not set
+# CONFIG_MAX11100 is not set
+# CONFIG_MAX1118 is not set
+# CONFIG_MAX1363 is not set
+# CONFIG_MAX9611 is not set
+# CONFIG_MCP320X is not set
+# CONFIG_MCP3422 is not set
+# CONFIG_MCP3911 is not set
+# CONFIG_NAU7802 is not set
+# CONFIG_QCOM_SPMI_IADC is not set
+# CONFIG_QCOM_SPMI_VADC is not set
+# CONFIG_QCOM_SPMI_ADC5 is not set
+# CONFIG_SD_ADC_MODULATOR is not set
+# CONFIG_TI_ADC081C is not set
+# CONFIG_TI_ADC0832 is not set
+# CONFIG_TI_ADC084S021 is not set
+# CONFIG_TI_ADC12138 is not set
+# CONFIG_TI_ADC108S102 is not set
+# CONFIG_TI_ADC128S052 is not set
+# CONFIG_TI_ADC161S626 is not set
+# CONFIG_TI_ADS1015 is not set
+# CONFIG_TI_ADS7950 is not set
+# CONFIG_TI_ADS8344 is not set
+# CONFIG_TI_ADS8688 is not set
+# CONFIG_TI_ADS124S08 is not set
+# CONFIG_TI_TLC4541 is not set
+# CONFIG_VF610_ADC is not set
+# CONFIG_XILINX_XADC is not set
+# end of Analog to digital converters
+
+#
+# Analog Front Ends
+#
+# CONFIG_IIO_RESCALE is not set
+# end of Analog Front Ends
+
+#
+# Amplifiers
+#
+# CONFIG_AD8366 is not set
+# end of Amplifiers
+
+#
+# Chemical Sensors
+#
+# CONFIG_ATLAS_PH_SENSOR is not set
+# CONFIG_BME680 is not set
+# CONFIG_CCS811 is not set
+# CONFIG_IAQCORE is not set
+# CONFIG_PMS7003 is not set
+# CONFIG_SENSIRION_SGP30 is not set
+# CONFIG_SPS30 is not set
+# CONFIG_VZ89X is not set
+# end of Chemical Sensors
+
+# CONFIG_IIO_CROS_EC_SENSORS_CORE is not set
+
+#
+# Hid Sensor IIO Common
+#
+# end of Hid Sensor IIO Common
+
+#
+# SSP Sensor Common
+#
+# CONFIG_IIO_SSP_SENSORHUB is not set
+# end of SSP Sensor Common
+
+#
+# Digital to analog converters
+#
+# CONFIG_AD5064 is not set
+# CONFIG_AD5360 is not set
+# CONFIG_AD5380 is not set
+# CONFIG_AD5421 is not set
+# CONFIG_AD5446 is not set
+# CONFIG_AD5449 is not set
+# CONFIG_AD5592R is not set
+# CONFIG_AD5593R is not set
+# CONFIG_AD5504 is not set
+# CONFIG_AD5624R_SPI is not set
+# CONFIG_LTC1660 is not set
+# CONFIG_LTC2632 is not set
+# CONFIG_AD5686_SPI is not set
+# CONFIG_AD5696_I2C is not set
+# CONFIG_AD5755 is not set
+# CONFIG_AD5758 is not set
+# CONFIG_AD5761 is not set
+# CONFIG_AD5764 is not set
+# CONFIG_AD5791 is not set
+# CONFIG_AD7303 is not set
+# CONFIG_AD8801 is not set
+# CONFIG_DPOT_DAC is not set
+# CONFIG_DS4424 is not set
+# CONFIG_M62332 is not set
+# CONFIG_MAX517 is not set
+# CONFIG_MAX5821 is not set
+# CONFIG_MCP4725 is not set
+# CONFIG_MCP4922 is not set
+# CONFIG_TI_DAC082S085 is not set
+# CONFIG_TI_DAC5571 is not set
+# CONFIG_TI_DAC7311 is not set
+# CONFIG_TI_DAC7612 is not set
+# CONFIG_VF610_DAC is not set
+# end of Digital to analog converters
+
+#
+# IIO dummy driver
+#
+# end of IIO dummy driver
+
+#
+# Frequency Synthesizers DDS/PLL
+#
+
+#
+# Clock Generator/Distribution
+#
+# CONFIG_AD9523 is not set
+# end of Clock Generator/Distribution
+
+#
+# Phase-Locked Loop (PLL) frequency synthesizers
+#
+# CONFIG_ADF4350 is not set
+# CONFIG_ADF4371 is not set
+# end of Phase-Locked Loop (PLL) frequency synthesizers
+# end of Frequency Synthesizers DDS/PLL
+
+#
+# Digital gyroscope sensors
+#
+# CONFIG_ADIS16080 is not set
+# CONFIG_ADIS16130 is not set
+# CONFIG_ADIS16136 is not set
+# CONFIG_ADIS16260 is not set
+# CONFIG_ADXRS450 is not set
+# CONFIG_BMG160 is not set
+# CONFIG_FXAS21002C is not set
+# CONFIG_MPU3050_I2C is not set
+# CONFIG_IIO_ST_GYRO_3AXIS is not set
+# CONFIG_ITG3200 is not set
+# end of Digital gyroscope sensors
+
+#
+# Health Sensors
+#
+
+#
+# Heart Rate Monitors
+#
+# CONFIG_AFE4403 is not set
+# CONFIG_AFE4404 is not set
+# CONFIG_MAX30100 is not set
+# CONFIG_MAX30102 is not set
+# end of Heart Rate Monitors
+# end of Health Sensors
+
+#
+# Humidity sensors
+#
+# CONFIG_AM2315 is not set
+# CONFIG_DHT11 is not set
+# CONFIG_HDC100X is not set
+# CONFIG_HTS221 is not set
+# CONFIG_HTU21 is not set
+# CONFIG_SI7005 is not set
+# CONFIG_SI7020 is not set
+# end of Humidity sensors
+
+#
+# Inertial measurement units
+#
+# CONFIG_ADIS16400 is not set
+# CONFIG_ADIS16460 is not set
+# CONFIG_ADIS16480 is not set
+# CONFIG_BMI160_I2C is not set
+# CONFIG_BMI160_SPI is not set
+# CONFIG_KMX61 is not set
+# CONFIG_INV_MPU6050_I2C is not set
+# CONFIG_INV_MPU6050_SPI is not set
+# CONFIG_IIO_ST_LSM6DSX is not set
+# end of Inertial measurement units
+
+#
+# Light sensors
+#
+# CONFIG_ADJD_S311 is not set
+# CONFIG_AL3320A is not set
+# CONFIG_APDS9300 is not set
+# CONFIG_APDS9960 is not set
+# CONFIG_BH1750 is not set
+# CONFIG_BH1780 is not set
+# CONFIG_CM32181 is not set
+# CONFIG_CM3232 is not set
+# CONFIG_CM3323 is not set
+# CONFIG_CM3605 is not set
+# CONFIG_CM36651 is not set
+# CONFIG_GP2AP020A00F is not set
+# CONFIG_SENSORS_ISL29018 is not set
+# CONFIG_SENSORS_ISL29028 is not set
+# CONFIG_ISL29125 is not set
+# CONFIG_JSA1212 is not set
+# CONFIG_RPR0521 is not set
+# CONFIG_LTR501 is not set
+# CONFIG_LV0104CS is not set
+# CONFIG_MAX44000 is not set
+# CONFIG_MAX44009 is not set
+# CONFIG_NOA1305 is not set
+# CONFIG_OPT3001 is not set
+# CONFIG_PA12203001 is not set
+# CONFIG_SI1133 is not set
+# CONFIG_SI1145 is not set
+# CONFIG_STK3310 is not set
+# CONFIG_ST_UVIS25 is not set
+# CONFIG_TCS3414 is not set
+# CONFIG_TCS3472 is not set
+# CONFIG_SENSORS_TSL2563 is not set
+# CONFIG_TSL2583 is not set
+# CONFIG_TSL2772 is not set
+# CONFIG_TSL4531 is not set
+# CONFIG_US5182D is not set
+# CONFIG_VCNL4000 is not set
+# CONFIG_VCNL4035 is not set
+# CONFIG_VEML6070 is not set
+# CONFIG_VL6180 is not set
+# CONFIG_ZOPT2201 is not set
+# end of Light sensors
+
+#
+# Magnetometer sensors
+#
+# CONFIG_AK8974 is not set
+# CONFIG_AK8975 is not set
+# CONFIG_AK09911 is not set
+# CONFIG_BMC150_MAGN_I2C is not set
+# CONFIG_BMC150_MAGN_SPI is not set
+# CONFIG_MAG3110 is not set
+# CONFIG_MMC35240 is not set
+# CONFIG_IIO_ST_MAGN_3AXIS is not set
+# CONFIG_SENSORS_HMC5843_I2C is not set
+# CONFIG_SENSORS_HMC5843_SPI is not set
+# CONFIG_SENSORS_RM3100_I2C is not set
+# CONFIG_SENSORS_RM3100_SPI is not set
+# end of Magnetometer sensors
+
+#
+# Multiplexers
+#
+# CONFIG_IIO_MUX is not set
+# end of Multiplexers
+
+#
+# Inclinometer sensors
+#
+# end of Inclinometer sensors
+
+#
+# Triggers - standalone
+#
+# CONFIG_IIO_INTERRUPT_TRIGGER is not set
+# CONFIG_IIO_SYSFS_TRIGGER is not set
+# end of Triggers - standalone
+
+#
+# Digital potentiometers
+#
+# CONFIG_AD5272 is not set
+# CONFIG_DS1803 is not set
+# CONFIG_MAX5432 is not set
+# CONFIG_MAX5481 is not set
+# CONFIG_MAX5487 is not set
+# CONFIG_MCP4018 is not set
+# CONFIG_MCP4131 is not set
+# CONFIG_MCP4531 is not set
+# CONFIG_MCP41010 is not set
+# CONFIG_TPL0102 is not set
+# end of Digital potentiometers
+
+#
+# Digital potentiostats
+#
+# CONFIG_LMP91000 is not set
+# end of Digital potentiostats
+
+#
+# Pressure sensors
+#
+# CONFIG_ABP060MG is not set
+# CONFIG_BMP280 is not set
+# CONFIG_DPS310 is not set
+# CONFIG_HP03 is not set
+# CONFIG_MPL115_I2C is not set
+# CONFIG_MPL115_SPI is not set
+# CONFIG_MPL3115 is not set
+# CONFIG_MS5611 is not set
+# CONFIG_MS5637 is not set
+# CONFIG_IIO_ST_PRESS is not set
+# CONFIG_T5403 is not set
+# CONFIG_HP206C is not set
+# CONFIG_ZPA2326 is not set
+# end of Pressure sensors
+
+#
+# Lightning sensors
+#
+# CONFIG_AS3935 is not set
+# end of Lightning sensors
+
+#
+# Proximity and distance sensors
+#
+# CONFIG_ISL29501 is not set
+# CONFIG_LIDAR_LITE_V2 is not set
+# CONFIG_MB1232 is not set
+# CONFIG_RFD77402 is not set
+# CONFIG_SRF04 is not set
+# CONFIG_SX9500 is not set
+# CONFIG_SRF08 is not set
+# CONFIG_VL53L0X_I2C is not set
+# end of Proximity and distance sensors
+
+#
+# Resolver to digital converters
+#
+# CONFIG_AD2S90 is not set
+# CONFIG_AD2S1200 is not set
+# end of Resolver to digital converters
+
+#
+# Temperature sensors
+#
+# CONFIG_MAXIM_THERMOCOUPLE is not set
+# CONFIG_MLX90614 is not set
+# CONFIG_MLX90632 is not set
+# CONFIG_TMP006 is not set
+# CONFIG_TMP007 is not set
+# CONFIG_TSYS01 is not set
+# CONFIG_TSYS02D is not set
+# CONFIG_MAX31856 is not set
+# end of Temperature sensors
+
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+CONFIG_PWM=y
+CONFIG_PWM_SYSFS=y
+CONFIG_PWM_CROS_EC=m
+# CONFIG_PWM_FSL_FTM is not set
+# CONFIG_PWM_IMX1 is not set
+CONFIG_PWM_IMX27=y
+# CONFIG_PWM_IMX_TPM is not set
+# CONFIG_PWM_PCA9685 is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+CONFIG_ARM_GIC_V2M=y
+CONFIG_ARM_GIC_V3=y
+CONFIG_ARM_GIC_V3_ITS=y
+CONFIG_ARM_GIC_V3_ITS_PCI=y
+# CONFIG_AL_FIC is not set
+CONFIG_IMX_GPCV2=y
+CONFIG_PARTITION_PERCPU=y
+CONFIG_IMX_IRQSTEER=y
+CONFIG_IMX_INTMUX=y
+# end of IRQ chip support
+
+# CONFIG_IPACK_BUS is not set
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_DISPMIX=y
+CONFIG_RESET_IMX7=y
+CONFIG_RESET_IMX_HDMIMIX=y
+CONFIG_RESET_IMX_AUDIOMIX=y
+CONFIG_RESET_GPIO=y
+# CONFIG_RESET_TI_SYSCON is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_PHY_MIPI_DPHY=y
+# CONFIG_PHY_XGENE is not set
+# CONFIG_PHY_MIXEL_LVDS is not set
+# CONFIG_PHY_MIXEL_LVDS_COMBO is not set
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_CADENCE_DP is not set
+# CONFIG_PHY_CADENCE_DPHY is not set
+# CONFIG_PHY_CADENCE_SIERRA is not set
+# CONFIG_PHY_FSL_IMX8MP_LVDS is not set
+CONFIG_PHY_FSL_IMX8MQ_USB=y
+# CONFIG_PHY_MIXEL_MIPI_DPHY is not set
+CONFIG_PHY_SAMSUNG_HDMI_PHY=y
+CONFIG_PHY_FSL_IMX_PCIE=y
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_CPCAP_USB is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_OCELOT_SERDES is not set
+CONFIG_PHY_QCOM_USB_HS=y
+# CONFIG_PHY_QCOM_USB_HSIC is not set
+# CONFIG_PHY_TUSB1210 is not set
+# end of PHY Subsystem
+
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+
+#
+# Performance monitor support
+#
+# CONFIG_ARM_CCI_PMU is not set
+# CONFIG_ARM_CCN is not set
+CONFIG_ARM_PMU=y
+# CONFIG_ARM_DSU_PMU is not set
+CONFIG_FSL_IMX8_DDR_PMU=y
+# CONFIG_ARM_SPE_PMU is not set
+# end of Performance monitor support
+
+CONFIG_RAS=y
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# end of Android
+
+# CONFIG_LIBNVDIMM is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+CONFIG_NVMEM_SYSFS=y
+# CONFIG_NVMEM_IMX_IIM is not set
+CONFIG_NVMEM_IMX_OCOTP=y
+CONFIG_NVMEM_IMX_OCOTP_SCU=y
+# CONFIG_NVMEM_SNVS_LPGPR is not set
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# end of HW tracing support
+
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+CONFIG_TEE=y
+
+#
+# TEE drivers
+#
+CONFIG_OPTEE=y
+CONFIG_OPTEE_SHM_NUM_PRIV_PAGES=1
+# end of TEE drivers
+
+CONFIG_MULTIPLEXER=y
+
+#
+# Multiplexer drivers
+#
+# CONFIG_MUX_ADG792A is not set
+# CONFIG_MUX_ADGS1408 is not set
+# CONFIG_MUX_GPIO is not set
+CONFIG_MUX_MMIO=y
+# end of Multiplexer drivers
+
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+# CONFIG_INTERCONNECT is not set
+# CONFIG_COUNTER is not set
+
+#
+# MXC support drivers
+#
+# CONFIG_MXC_SIM is not set
+# CONFIG_MXC_IPU is not set
+
+#
+# MXC HANTRO(Video Processing Unit) support
+#
+CONFIG_MXC_HANTRO=y
+# end of MXC HANTRO(Video Processing Unit) support
+
+#
+# MXC HANTRO(Video Processing Unit) 845 support
+#
+CONFIG_MXC_HANTRO_845=y
+# end of MXC HANTRO(Video Processing Unit) 845 support
+
+#
+# MXC HANTRO(Video Processing Unit) encoder support
+#
+CONFIG_MXC_HANTRO_845_H1=y
+# end of MXC HANTRO(Video Processing Unit) encoder support
+
+#
+# MXC HANTRO(Video Processing Unit) VC8000E encoder support
+#
+CONFIG_MXC_HANTRO_VC8000E=y
+# end of MXC HANTRO(Video Processing Unit) VC8000E encoder support
+
+#
+# MXC VPU(Video Processing Unit) MALONE DECODER support
+#
+CONFIG_MXC_VPU_MALONE=y
+# CONFIG_MXC_VPU_MALONE_DEBUG is not set
+# end of MXC VPU(Video Processing Unit) MALONE DECODER support
+
+#
+# MXC VPU(Video Processing Unit) WINDSOR ENCODER support
+#
+CONFIG_MXC_VPU_WINDSOR=y
+# CONFIG_MXC_VPU_WINDSOR_DEBUG is not set
+# end of MXC VPU(Video Processing Unit) WINDSOR ENCODER support
+
+#
+# XUVI/PPM HW TS filter and demux
+#
+CONFIG_MXC_IMX_DMX_HW=y
+# end of XUVI/PPM HW TS filter and demux
+
+#
+# MXC Vivante GPU support
+#
+CONFIG_MXC_GPU_VIV=y
+# end of MXC Vivante GPU support
+
+#
+# MXC VPU(Video Processing Unit) support
+#
+# end of MXC VPU(Video Processing Unit) support
+
+#
+# MXC SIM Support
+#
+# end of MXC SIM Support
+
+#
+# MXC Media Local Bus Driver
+#
+CONFIG_MXC_MLB=y
+CONFIG_MXC_MLB150=y
+# end of MXC Media Local Bus Driver
+
+#
+# MXC HDMI CEC (Consumer Electronics Control) support
+#
+# end of MXC HDMI CEC (Consumer Electronics Control) support
+
+#
+# MXC MIPI Support
+#
+# end of MXC MIPI Support
+# end of MXC support drivers
+# end of Device Drivers
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_VALIDATE_FS_PARSER is not set
+CONFIG_FS_IOMAP=y
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_BTRFS_FS=y
+CONFIG_BTRFS_FS_POSIX_ACL=y
+# CONFIG_BTRFS_FS_CHECK_INTEGRITY is not set
+# CONFIG_BTRFS_FS_RUN_SANITY_TESTS is not set
+# CONFIG_BTRFS_DEBUG is not set
+# CONFIG_BTRFS_ASSERT is not set
+# CONFIG_BTRFS_FS_REF_VERIFY is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_FS_DAX is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+# CONFIG_FS_VERITY is not set
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+# CONFIG_FANOTIFY_ACCESS_PERMISSIONS is not set
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+CONFIG_PRINT_QUOTA_WARNING=y
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_AUTOFS_FS=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_VIRTIO_FS=y
+CONFIG_OVERLAY_FS=y
+# CONFIG_OVERLAY_FS_REDIRECT_DIR is not set
+CONFIG_OVERLAY_FS_REDIRECT_ALWAYS_FOLLOW=y
+# CONFIG_OVERLAY_FS_INDEX is not set
+CONFIG_OVERLAY_FS_XINO_AUTO=y
+# CONFIG_OVERLAY_FS_METACOPY is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+# end of Caches
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+# end of CD-ROM/DVD Filesystems
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+# end of DOS/FAT/NT Filesystems
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+# CONFIG_PROC_KCORE is not set
+# CONFIG_PROC_VMCORE is not set
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_MEMFD_CREATE=y
+CONFIG_ARCH_HAS_GIGANTIC_PAGE=y
+CONFIG_CONFIGFS_FS=y
+# end of Pseudo filesystems
+
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_FILE_CACHE is not set
+CONFIG_SQUASHFS_FILE_DIRECT=y
+# CONFIG_SQUASHFS_DECOMP_SINGLE is not set
+# CONFIG_SQUASHFS_DECOMP_MULTI is not set
+CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU=y
+CONFIG_SQUASHFS_XATTR=y
+CONFIG_SQUASHFS_ZLIB=y
+CONFIG_SQUASHFS_LZ4=y
+CONFIG_SQUASHFS_LZO=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_SQUASHFS_ZSTD=y
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+CONFIG_PSTORE_DEFLATE_COMPRESS=y
+# CONFIG_PSTORE_LZO_COMPRESS is not set
+# CONFIG_PSTORE_LZ4_COMPRESS is not set
+# CONFIG_PSTORE_LZ4HC_COMPRESS is not set
+# CONFIG_PSTORE_842_COMPRESS is not set
+# CONFIG_PSTORE_ZSTD_COMPRESS is not set
+CONFIG_PSTORE_COMPRESS=y
+CONFIG_PSTORE_DEFLATE_COMPRESS_DEFAULT=y
+CONFIG_PSTORE_COMPRESS_DEFAULT="deflate"
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_PMSG is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_EROFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_PNFS_FILE_LAYOUT=y
+CONFIG_PNFS_BLOCK=y
+CONFIG_PNFS_FLEXFILE_LAYOUT=m
+CONFIG_NFS_V4_1_IMPLEMENTATION_ID_DOMAIN="kernel.org"
+# CONFIG_NFS_V4_1_MIGRATION is not set
+CONFIG_NFS_V4_SECURITY_LABEL=y
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+# CONFIG_NFSD is not set
+CONFIG_GRACE_PERIOD=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_SUNRPC_BACKCHANNEL=y
+CONFIG_RPCSEC_GSS_KRB5=m
+# CONFIG_SUNRPC_DISABLE_INSECURE_ENCTYPES is not set
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="cp437"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+CONFIG_NLS_CODEPAGE_950=y
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+# CONFIG_UNICODE is not set
+# end of File systems
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_COMPAT=y
+# CONFIG_KEYS_REQUEST_CACHE is not set
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_TRUSTED_KEYS is not set
+# CONFIG_SECURE_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+CONFIG_SECURITYFS=y
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+CONFIG_SECURITY_PATH=y
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+CONFIG_SECURITY_APPARMOR=y
+CONFIG_SECURITY_APPARMOR_HASH=y
+CONFIG_SECURITY_APPARMOR_HASH_DEFAULT=y
+# CONFIG_SECURITY_APPARMOR_DEBUG is not set
+# CONFIG_SECURITY_LOADPIN is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_SECURITY_SAFESETID is not set
+# CONFIG_SECURITY_LOCKDOWN_LSM is not set
+CONFIG_INTEGRITY=y
+# CONFIG_INTEGRITY_SIGNATURE is not set
+CONFIG_INTEGRITY_AUDIT=y
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+# CONFIG_DEFAULT_SECURITY_APPARMOR is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_LSM="lockdown,yama,loadpin,safesetid,integrity"
+
+#
+# Kernel hardening options
+#
+
+#
+# Memory initialization
+#
+CONFIG_INIT_STACK_NONE=y
+# CONFIG_INIT_ON_ALLOC_DEFAULT_ON is not set
+# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set
+# end of Memory initialization
+# end of Kernel hardening options
+# end of Security options
+
+CONFIG_XOR_BLOCKS=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_KPP=y
+CONFIG_CRYPTO_ACOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_USER=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+CONFIG_CRYPTO_GF128MUL=y
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_CRYPTD=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_TEST=m
+CONFIG_CRYPTO_SIMD=y
+CONFIG_CRYPTO_ENGINE=y
+
+#
+# Public-key cryptography
+#
+CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+CONFIG_CRYPTO_ECC=y
+CONFIG_CRYPTO_ECDH=y
+# CONFIG_CRYPTO_ECRDSA is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_CHACHA20POLY1305=m
+# CONFIG_CRYPTO_AEGIS128 is not set
+CONFIG_CRYPTO_SEQIV=y
+CONFIG_CRYPTO_ECHAINIV=y
+CONFIG_CRYPTO_TLS=m
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_CFB=m
+CONFIG_CRYPTO_CTR=y
+CONFIG_CRYPTO_CTS=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_CRYPTO_LRW=m
+CONFIG_CRYPTO_OFB=m
+CONFIG_CRYPTO_PCBC=m
+CONFIG_CRYPTO_XTS=m
+# CONFIG_CRYPTO_KEYWRAP is not set
+# CONFIG_CRYPTO_ADIANTUM is not set
+CONFIG_CRYPTO_ESSIV=y
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_CMAC=y
+CONFIG_CRYPTO_HMAC=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_CRYPTO_VMAC=m
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_XXHASH is not set
+CONFIG_CRYPTO_CRCT10DIF=y
+CONFIG_CRYPTO_GHASH=y
+CONFIG_CRYPTO_POLY1305=m
+CONFIG_CRYPTO_MD4=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_RMD128=m
+CONFIG_CRYPTO_RMD160=m
+CONFIG_CRYPTO_RMD256=m
+CONFIG_CRYPTO_RMD320=m
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_LIB_SHA256=y
+CONFIG_CRYPTO_SHA256=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SHA3=m
+CONFIG_CRYPTO_SM3=m
+CONFIG_CRYPTO_STREEBOG=m
+CONFIG_CRYPTO_TGR192=m
+CONFIG_CRYPTO_WP512=m
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_LIB_AES=y
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_CRYPTO_LIB_ARC4=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_CRYPTO_BLOWFISH_COMMON=m
+CONFIG_CRYPTO_CAMELLIA=m
+CONFIG_CRYPTO_CAST_COMMON=m
+CONFIG_CRYPTO_CAST5=m
+CONFIG_CRYPTO_CAST6=m
+CONFIG_CRYPTO_LIB_DES=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_FCRYPT=m
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_CRYPTO_SALSA20=m
+CONFIG_CRYPTO_CHACHA20=y
+CONFIG_CRYPTO_SEED=m
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_CRYPTO_SM4=m
+CONFIG_CRYPTO_TEA=m
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+CONFIG_CRYPTO_LZO=y
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+CONFIG_CRYPTO_ZSTD=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+# CONFIG_CRYPTO_DRBG_CTR is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+CONFIG_CRYPTO_USER_API=y
+CONFIG_CRYPTO_USER_API_HASH=y
+CONFIG_CRYPTO_USER_API_SKCIPHER=y
+CONFIG_CRYPTO_USER_API_RNG=y
+CONFIG_CRYPTO_USER_API_AEAD=y
+# CONFIG_CRYPTO_STATS is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_COMMON=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_KEYBLOB_API_DESC=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SECVIO=y
+CONFIG_CRYPTO_DEV_FSL_CAAM=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_DEBUG is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_JR=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RINGSIZE=9
+# CONFIG_CRYPTO_DEV_FSL_CAAM_INTC is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API_QI=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_AHASH_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_PKC_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_API=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API=y
+# CONFIG_CRYPTO_DEV_FSL_CAAM_TK_API_TEST is not set
+# CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST is not set
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM=y
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_SLOTSIZE=7
+CONFIG_CRYPTO_DEV_FSL_CAAM_SM_TEST=m
+CONFIG_CRYPTO_DEV_FSL_CAAM_JR_UIO=y
+# CONFIG_CRYPTO_DEV_SAHARA is not set
+# CONFIG_CRYPTO_DEV_ATMEL_ECC is not set
+# CONFIG_CRYPTO_DEV_ATMEL_SHA204A is not set
+# CONFIG_CRYPTO_DEV_CCP is not set
+# CONFIG_CRYPTO_DEV_MXS_DCP is not set
+# CONFIG_CRYPTO_DEV_NITROX_CNN55XX is not set
+# CONFIG_CRYPTO_DEV_CAVIUM_ZIP is not set
+CONFIG_CRYPTO_DEV_VIRTIO=m
+# CONFIG_CRYPTO_DEV_SAFEXCEL is not set
+# CONFIG_CRYPTO_DEV_CCREE is not set
+# CONFIG_CRYPTO_DEV_HISI_SEC is not set
+# CONFIG_CRYPTO_DEV_HISI_ZIP is not set
+CONFIG_ASYMMETRIC_KEY_TYPE=y
+CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
+CONFIG_X509_CERTIFICATE_PARSER=y
+# CONFIG_PKCS8_PRIVATE_KEY_PARSER is not set
+CONFIG_PKCS7_MESSAGE_PARSER=y
+# CONFIG_PKCS7_TEST_KEY is not set
+# CONFIG_SIGNED_PE_FILE_VERIFICATION is not set
+
+#
+# Certificates for signature checking
+#
+CONFIG_SYSTEM_TRUSTED_KEYRING=y
+CONFIG_SYSTEM_TRUSTED_KEYS=""
+# CONFIG_SYSTEM_EXTRA_CERTIFICATE is not set
+# CONFIG_SECONDARY_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+# end of Certificates for signature checking
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_RAID6_PQ_BENCHMARK=y
+# CONFIG_PACKING is not set
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+# CONFIG_CORDIC is not set
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_STMP_DEVICE=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+CONFIG_ARCH_HAS_FAST_MULTIPLIER=y
+CONFIG_INDIRECT_PIO=y
+CONFIG_CRC_CCITT=y
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_XXHASH=y
+CONFIG_AUDIT_GENERIC=y
+CONFIG_AUDIT_ARCH_COMPAT_GENERIC=y
+CONFIG_AUDIT_COMPAT_GENERIC=y
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_ZSTD_COMPRESS=y
+CONFIG_ZSTD_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_TEXTSEARCH=y
+CONFIG_TEXTSEARCH_KMP=y
+CONFIG_TEXTSEARCH_BM=y
+CONFIG_TEXTSEARCH_FSM=y
+CONFIG_XARRAY_MULTI=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DMA_DECLARE_COHERENT=y
+CONFIG_ARCH_HAS_SETUP_DMA_OPS=y
+CONFIG_ARCH_HAS_TEARDOWN_DMA_OPS=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE=y
+CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU=y
+CONFIG_ARCH_HAS_DMA_PREP_COHERENT=y
+CONFIG_ARCH_HAS_DMA_COHERENT_TO_PFN=y
+CONFIG_SWIOTLB=y
+CONFIG_DMA_REMAP=y
+CONFIG_DMA_DIRECT_REMAP=y
+CONFIG_DMA_CMA=y
+
+#
+# Default contiguous memory area size:
+#
+CONFIG_CMA_SIZE_MBYTES=320
+CONFIG_CMA_SIZE_SEL_MBYTES=y
+# CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
+# CONFIG_CMA_SIZE_SEL_MIN is not set
+# CONFIG_CMA_SIZE_SEL_MAX is not set
+CONFIG_CMA_ALIGNMENT=8
+# CONFIG_DMA_API_DEBUG is not set
+CONFIG_SGL_ALLOC=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+CONFIG_IRQ_POLL=y
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_HAVE_GENERIC_VDSO=y
+CONFIG_GENERIC_GETTIMEOFDAY=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_SG_POOL=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+# end of Library routines
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
+CONFIG_PRINTK_TIME=y
+# CONFIG_PRINTK_CALLER is not set
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# end of printk and dmesg options
+
+#
+# Compile-time checks and compiler options
+#
+# CONFIG_DEBUG_INFO is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_INSTALL is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# end of Compile-time checks and compiler options
+
+CONFIG_MAGIC_SYSRQ=y
+CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE=0x1
+CONFIG_MAGIC_SYSRQ_SERIAL=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_DEBUG_MISC=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_RODATA_TEST is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+CONFIG_HAVE_ARCH_KASAN=y
+CONFIG_HAVE_ARCH_KASAN_SW_TAGS=y
+CONFIG_CC_HAS_KASAN_GENERIC=y
+# CONFIG_KASAN is not set
+CONFIG_KASAN_STACK=1
+# end of Memory Debugging
+
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+CONFIG_LOCKUP_DETECTOR=y
+CONFIG_SOFTLOCKUP_DETECTOR=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC=y
+CONFIG_BOOTPARAM_SOFTLOCKUP_PANIC_VALUE=1
+CONFIG_DETECT_HUNG_TASK=y
+CONFIG_DEFAULT_HUNG_TASK_TIMEOUT=600
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC=y
+CONFIG_BOOTPARAM_HUNG_TASK_PANIC_VALUE=1
+CONFIG_WQ_WATCHDOG=y
+# end of Debug Lockups and Hangs
+
+CONFIG_PANIC_ON_OOPS=y
+CONFIG_PANIC_ON_OOPS_VALUE=1
+CONFIG_PANIC_TIMEOUT=5
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHED_INFO=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+# CONFIG_DEBUG_PREEMPT is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_RWSEMS is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# end of Lock Debugging (spinlocks, mutexes, etc...)
+
+CONFIG_STACKTRACE=y
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_HAVE_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PLIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# end of RCU Debugging
+
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_CPU_HOTPLUG_STATE_CONTROL is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_RUNTIME_TESTING_MENU is not set
+CONFIG_MEMTEST=y
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_ARCH_HAS_UBSAN_SANITIZE_ALL=y
+# CONFIG_UBSAN is not set
+CONFIG_UBSAN_ALIGNMENT=y
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_IO_STRICT_DEVMEM is not set
+# CONFIG_ARM64_PTDUMP_DEBUGFS is not set
+CONFIG_PID_IN_CONTEXTIDR=y
+# CONFIG_ARM64_RANDOMIZE_TEXT_OFFSET is not set
+# CONFIG_DEBUG_WX is not set
+# CONFIG_DEBUG_ALIGN_RODATA is not set
+# CONFIG_ARM64_RELOC_TEST is not set
+# CONFIG_CORESIGHT is not set
+# end of Kernel hacking
diff --git a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
index d2d205342..73b006c2f 100644
--- a/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
+++ b/drivers/gpu/drm/bridge/synopsys/dw-hdmi.c
@@ -761,37 +761,30 @@ static void dw_hdmi_gp_audio_enable(struct dw_hdmi *hdmi)
 	case 32000:
 		sample_freq = 0x03;
 		org_sample_freq = 0x0C;
-		hdmi_writeb(hdmi, 0x31, HDMI_FC_AUDICONF1);
 		break;
 	case 44100:
 		sample_freq = 0x00;
 		org_sample_freq = 0x0F;
-		hdmi_writeb(hdmi, 0x32, HDMI_FC_AUDICONF1);
 		break;
 	case 48000:
 		sample_freq = 0x02;
 		org_sample_freq = 0x0D;
-		hdmi_writeb(hdmi, 0x33, HDMI_FC_AUDICONF1);
 		break;
 	case 88200:
 		sample_freq = 0x08;
 		org_sample_freq = 0x07;
-		hdmi_writeb(hdmi, 0x34, HDMI_FC_AUDICONF1);
 		break;
 	case 96000:
 		sample_freq = 0x0A;
 		org_sample_freq = 0x05;
-		hdmi_writeb(hdmi, 0x35, HDMI_FC_AUDICONF1);
 		break;
 	case 176400:
 		sample_freq = 0x0C;
 		org_sample_freq = 0x03;
-		hdmi_writeb(hdmi, 0x36, HDMI_FC_AUDICONF1);
 		break;
 	case 192000:
 		sample_freq = 0x0E;
 		org_sample_freq = 0x01;
-		hdmi_writeb(hdmi, 0x37, HDMI_FC_AUDICONF1);
 		break;
 	default:
 		break;
diff --git a/drivers/gpu/drm/imx/dw_hdmi-imx.c b/drivers/gpu/drm/imx/dw_hdmi-imx.c
index 1c8d2ac06..0c54acd52 100644
--- a/drivers/gpu/drm/imx/dw_hdmi-imx.c
+++ b/drivers/gpu/drm/imx/dw_hdmi-imx.c
@@ -276,8 +276,11 @@ static int imx8mp_hdmi_phy_init(struct dw_hdmi *dw_hdmi, void *data,
 	imx8mp_hdmi_pavi_powerup();
 	imx8mp_hdmi_pvi_enable(mode);
 
-	/* HDMI PHY power up */
 	regmap_read(hdmi->regmap, 0x200, &val);
+	/* HDMI PHY power off */
+	val |= 0x8;
+	regmap_write(hdmi->regmap, 0x200, val);
+	/* HDMI PHY power on */
 	val &= ~0x8;
 	/* Enable CEC */
 	val |= 0x2;
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index 1988de1d6..3a500062f 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -315,6 +315,16 @@ config LEDS_GPIO
 	  defined as platform devices and/or OpenFirmware platform devices.
 	  The code to use these bindings can be selected below.
 
+config LEDS_GPIO_2COLOR
+        tristate "LED Support for GPIO connected 2color LEDs"
+        depends on LEDS_CLASS
+        depends on GPIOLIB
+        help
+          This option enables support for the 2color LEDs connected to 2 GPIO
+          outputs. To be useful the particular board must have 2color LEDs
+          and they must be connected to the GPIO lines.  The LEDs must be
+          defined as platform devices and/or OpenFirmware platform devices.
+
 config LEDS_LP3944
 	tristate "LED Support for N.S. LP3944 (Fun Light) I2C chip"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index 41fb073a3..64aa679f5 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_LEDS_SUNFIRE)		+= leds-sunfire.o
 obj-$(CONFIG_LEDS_PCA9532)		+= leds-pca9532.o
 obj-$(CONFIG_LEDS_GPIO_REGISTER)	+= leds-gpio-register.o
 obj-$(CONFIG_LEDS_GPIO)			+= leds-gpio.o
+obj-$(CONFIG_LEDS_GPIO_2COLOR)          += leds-gpio-2color.o
 obj-$(CONFIG_LEDS_LP3944)		+= leds-lp3944.o
 obj-$(CONFIG_LEDS_LP3952)		+= leds-lp3952.o
 obj-$(CONFIG_LEDS_LP55XX_COMMON)	+= leds-lp55xx-common.o
diff --git a/drivers/leds/leds-gpio-2color.c b/drivers/leds/leds-gpio-2color.c
new file mode 100644
index 000000000..672f4907a
--- /dev/null
+++ b/drivers/leds/leds-gpio-2color.c
@@ -0,0 +1,393 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * LEDs driver for GPIOs
+ *
+ * Copyright (C) 2007 8D Technologies inc.
+ * Raphael Assenat <raph@8d.com>
+ * Ma ChangBao     <machangbao@sina.com>
+ * Copyright (C) 2008 Freescale Semiconductor, Inc.
+ */
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/slab.h>
+
+//#define LEDS_GPIO_DEFSTATE_OFF          0 /*already define in <linux/leds.h> */
+//#define LEDS_GPIO_DEFSTATE_ON           1 /*already define in <linux/leds.h> */
+//#define LEDS_GPIO_DEFSTATE_KEEP         2 /*already define in <linux/leds.h> */
+#define LEDS_GPIO_DEFSTATE_ON_RED    	  0x11
+#define LEDS_GPIO_DEFSTATE_ON_GREEN       0x12
+#define LEDS_GPIO_DEFSTATE_ON_YELLOW      0x13
+#define LEDS_GPIO_DEFSTATE_ON_MASK        0x0f
+
+struct gpio_led_2color {
+        const char *name;
+        const char *default_trigger;
+        unsigned        gpio;
+        unsigned        active_low : 1;
+        unsigned        retain_state_suspended : 1;
+        unsigned        panic_indicator : 1;
+        unsigned        default_state;
+        unsigned        retain_state_shutdown : 1;
+        /* default_state should be one of LEDS_GPIO_DEFSTATE_(ON|OFF|KEEP) */
+        struct gpio_desc *gpiod[2];
+};
+
+
+struct gpio_led_data {
+	struct led_classdev cdev;
+	struct gpio_desc *gpiod[2];
+	u8 can_sleep;
+	u8 blinking;
+	int on_color;
+	gpio_blink_set_t platform_gpio_blink_set;
+};
+
+static inline struct gpio_led_data *
+			cdev_to_gpio_led_data(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct gpio_led_data, cdev);
+}
+
+
+static int gpiod_get_2color_value_cansleep(struct gpio_desc **gpiod)
+{
+	int color;
+
+	color = (!!gpiod_get_value_cansleep(gpiod[0])<<1) | (!!gpiod_get_value_cansleep(gpiod[1]));
+
+	return color;
+}
+
+static int gpiod_set_2color_value(struct gpio_desc **gpiod, int color)
+{
+	gpiod_set_value(gpiod[0], color&0x1);
+	gpiod_set_value(gpiod[1], (color>>1)&0x1);
+
+	return 0;
+}
+
+static int gpiod_set_2color_value_cansleep(struct gpio_desc **gpiod, int color)
+{
+	gpiod_set_value_cansleep(gpiod[0], color&0x1);
+	gpiod_set_value_cansleep(gpiod[1], (color>>1)&0x1);
+
+	return 0;
+}
+
+static void gpio_led_2color_set(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);
+	int color;
+
+	if (value == LED_OFF) {
+		color = 0;
+	} else if (value == LED_FULL) {
+		/* most triger like netdev only give single LED_FULL, 
+		 * so we need to get the stored color instand 
+		 */
+		led_cdev->brightness = led_dat->on_color;
+		color = led_dat->on_color;
+	} else {
+		/* save the color if neither LED_FULL nor LED_OFF 
+		 * .eg: when echo 1/2/3 > brightness
+		 *  the new color(value) have been saved to led_cdev->brightness before this.
+		 */
+		led_dat->on_color = value;
+		color = led_dat->on_color;
+	}
+
+	//if (led_dat->blinking) {
+	//	led_dat->platform_gpio_blink_set(led_dat->gpiod, level,
+	//					 NULL, NULL);
+	//	led_dat->blinking = 0;
+	//} else {
+		if (led_dat->can_sleep)
+			gpiod_set_2color_value_cansleep(led_dat->gpiod, color);
+		else
+			gpiod_set_2color_value(led_dat->gpiod, color);
+	//}
+}
+
+static int gpio_led_2color_set_blocking(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	gpio_led_2color_set(led_cdev, value);
+	return 0;
+}
+
+/*static int gpio_blink_set(struct led_classdev *led_cdev,
+	unsigned long *delay_on, unsigned long *delay_off)
+{
+	struct gpio_led_data *led_dat = cdev_to_gpio_led_data(led_cdev);
+
+	led_dat->blinking = 1;
+	return led_dat->platform_gpio_blink_set(led_dat->gpiod, GPIO_LED_BLINK,
+						delay_on, delay_off);
+}*/
+
+static int create_gpio_led_2color(const struct gpio_led_2color *template,
+	struct gpio_led_data *led_dat, struct device *parent,
+	struct fwnode_handle *fwnode, gpio_blink_set_t blink_set)
+{
+	struct led_init_data init_data = {};
+	int ret, state;
+
+	led_dat->cdev.default_trigger = template->default_trigger;
+	led_dat->can_sleep = (gpiod_cansleep(led_dat->gpiod[0]) && gpiod_cansleep(led_dat->gpiod[1]));
+	if (!led_dat->can_sleep)
+		led_dat->cdev.brightness_set = gpio_led_2color_set;
+	else
+		led_dat->cdev.brightness_set_blocking = gpio_led_2color_set_blocking;
+	led_dat->blinking = 0;
+	if (blink_set) {
+		/*led_dat->platform_gpio_blink_set = blink_set;
+		led_dat->cdev.blink_set = gpio_blink_set;*/
+		printk("create_gpio_led_2color: warning, not support blink_set\n");
+	}
+	if (template->default_state == LEDS_GPIO_DEFSTATE_KEEP) {
+		state = gpiod_get_2color_value_cansleep(led_dat->gpiod);
+		if (state < 0)
+			return state;
+	} else {
+		state = (template->default_state & LEDS_GPIO_DEFSTATE_ON_MASK);
+	}
+	led_dat->cdev.brightness = state;
+	if (!template->retain_state_suspended)
+		led_dat->cdev.flags |= LED_CORE_SUSPENDRESUME;
+	if (template->panic_indicator)
+		led_dat->cdev.flags |= LED_PANIC_INDICATOR;
+	if (template->retain_state_shutdown)
+		led_dat->cdev.flags |= LED_RETAIN_AT_SHUTDOWN;
+
+        if (led_dat->can_sleep)
+            ret = gpiod_set_2color_value_cansleep(led_dat->gpiod, state);
+        else
+            ret = gpiod_set_2color_value(led_dat->gpiod, state);
+	if (ret < 0)
+		return ret;
+
+	if (template->name) {
+		led_dat->cdev.name = template->name;
+		ret = devm_led_classdev_register(parent, &led_dat->cdev);
+	} else {
+		init_data.fwnode = fwnode;
+		ret = devm_led_classdev_register_ext(parent, &led_dat->cdev,
+						     &init_data);
+	}
+
+	return ret;
+}
+
+struct gpio_leds_priv {
+	int num_leds;
+	struct gpio_led_data leds[];
+};
+
+static inline int sizeof_gpio_leds_priv(int num_leds)
+{
+	return sizeof(struct gpio_leds_priv) +
+		(sizeof(struct gpio_led_data) * num_leds);
+}
+
+static struct gpio_leds_priv *gpio_leds_2color_create(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct fwnode_handle *child;
+	struct gpio_leds_priv *priv;
+	int count, ret;
+	char name[16];
+
+	count = device_get_child_node_count(dev);
+	if (!count)
+		return ERR_PTR(-ENODEV);
+
+	priv = devm_kzalloc(dev, sizeof_gpio_leds_priv(count), GFP_KERNEL);
+	if (!priv)
+		return ERR_PTR(-ENOMEM);
+
+	device_for_each_child_node(dev, child) {
+		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
+		struct gpio_led_2color led = {};
+		const char *state = NULL;
+
+		/*
+		 * Acquire gpiod from DT with uninitialized label, which
+		 * will be updated after LED class device is registered,
+		 * Only then the final LED name is known.
+		 */
+		led.gpiod[0] = devm_fwnode_get_gpiod_from_child(dev, "red", child,
+							     GPIOD_ASIS,
+							     NULL);
+		if (IS_ERR(led.gpiod[0])) {
+			fwnode_handle_put(child);
+			return ERR_CAST(led.gpiod[0]);
+		}
+		
+		led.gpiod[1] = devm_fwnode_get_gpiod_from_child(dev, "green", child,
+							     GPIOD_ASIS,
+							     NULL);
+		if (IS_ERR(led.gpiod[1])) {
+			fwnode_handle_put(child);
+			return ERR_CAST(led.gpiod[1]);
+		}
+		
+		led_dat->gpiod[0] = led.gpiod[0];
+		led_dat->gpiod[1] = led.gpiod[1];
+
+		gpiod_direction_output(led_dat->gpiod[0], 0);
+		gpiod_direction_output(led_dat->gpiod[1], 0);
+
+		fwnode_property_read_string(child, "linux,default-trigger",
+					    &led.default_trigger);
+
+		if (!fwnode_property_read_string(child, "default-state",
+						 &state)) {
+			if (!strcmp(state, "keep"))
+				led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
+			else if (!strcmp(state, "red"))
+				led.default_state = LEDS_GPIO_DEFSTATE_ON_RED;
+			else if (!strcmp(state, "green"))
+				led.default_state = LEDS_GPIO_DEFSTATE_ON_GREEN;
+			else if (!strcmp(state, "yellow"))
+				led.default_state = LEDS_GPIO_DEFSTATE_ON_YELLOW;
+			else
+				led.default_state = LEDS_GPIO_DEFSTATE_OFF;
+		}
+
+		if (fwnode_property_present(child, "retain-state-suspended"))
+			led.retain_state_suspended = 1;
+		if (fwnode_property_present(child, "retain-state-shutdown"))
+			led.retain_state_shutdown = 1;
+		if (fwnode_property_present(child, "panic-indicator"))
+			led.panic_indicator = 1;
+
+		ret = create_gpio_led_2color(&led, led_dat, dev, child, NULL);
+		if (ret < 0) {
+			fwnode_handle_put(child);
+			return ERR_PTR(ret);
+		}
+
+		/* Set gpiod label to match the corresponding LED name. */
+		sprintf(name,"%s-red", led_dat->cdev.dev->kobj.name);
+		gpiod_set_consumer_name(led_dat->gpiod[0], name);
+		sprintf(name,"%s-green", led_dat->cdev.dev->kobj.name);
+		gpiod_set_consumer_name(led_dat->gpiod[1], name);
+		priv->num_leds++;
+	}
+
+	return priv;
+}
+
+static const struct of_device_id of_gpio_leds_match[] = {
+	{ .compatible = "gpio-leds-2color", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, of_gpio_leds_match);
+
+#if 0
+static struct gpio_desc *gpio_led_get_gpiod(struct device *dev, int idx,
+					    const struct gpio_led *template)
+{
+	struct gpio_desc *gpiod;
+	unsigned long flags = GPIOF_OUT_INIT_LOW;
+	int ret;
+
+	/*
+	 * This means the LED does not come from the device tree
+	 * or ACPI, so let's try just getting it by index from the
+	 * device, this will hit the board file, if any and get
+	 * the GPIO from there.
+	 */
+	gpiod = devm_gpiod_get_index(dev, NULL, idx, flags);
+	if (!IS_ERR(gpiod)) {
+		gpiod_set_consumer_name(gpiod, template->name);
+		return gpiod;
+	}
+	if (PTR_ERR(gpiod) != -ENOENT)
+		return gpiod;
+
+	/*
+	 * This is the legacy code path for platform code that
+	 * still uses GPIO numbers. Ultimately we would like to get
+	 * rid of this block completely.
+	 */
+
+	/* skip leds that aren't available */
+	if (!gpio_is_valid(template->gpio))
+		return ERR_PTR(-ENOENT);
+
+	if (template->active_low)
+		flags |= GPIOF_ACTIVE_LOW;
+
+	ret = devm_gpio_request_one(dev, template->gpio, flags,
+				    template->name);
+	if (ret < 0)
+		return ERR_PTR(ret);
+
+	gpiod = gpio_to_desc(template->gpio);
+	if (!gpiod)
+		return ERR_PTR(-EINVAL);
+
+	return gpiod;
+}
+#endif
+
+static int gpio_led_2color_probe(struct platform_device *pdev)
+{
+	struct gpio_led_platform_data *pdata = dev_get_platdata(&pdev->dev);
+	struct gpio_leds_priv *priv;
+
+	if (pdata && pdata->num_leds) {
+	    printk(KERN_ERR "gpio_led_2color_probe: error, only support dts platform_device\n");
+		return -1;
+
+	} else {
+		priv = gpio_leds_2color_create(pdev);
+		if (IS_ERR(priv))
+			return PTR_ERR(priv);
+	}
+
+	platform_set_drvdata(pdev, priv);
+
+	return 0;
+}
+
+static void gpio_led_2color_shutdown(struct platform_device *pdev)
+{
+	struct gpio_leds_priv *priv = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < priv->num_leds; i++) {
+		struct gpio_led_data *led = &priv->leds[i];
+
+		if (!(led->cdev.flags & LED_RETAIN_AT_SHUTDOWN))
+			gpio_led_2color_set(&led->cdev, LED_OFF);
+	}
+}
+
+static struct platform_driver gpio_led_2color_driver = {
+	.probe		= gpio_led_2color_probe,
+	.shutdown	= gpio_led_2color_shutdown,
+	.driver		= {
+		.name	= "leds_gpio_2color",
+		.of_match_table = of_gpio_leds_match,
+	},
+};
+
+module_platform_driver(gpio_led_2color_driver);
+
+MODULE_AUTHOR("machangbao <machangbao110@sina.com>");
+MODULE_DESCRIPTION("GPIO 2COLOR LED driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:leds-gpio-2color");
+
+
diff --git a/drivers/mmc/host/sdhci-esdhc-imx.c b/drivers/mmc/host/sdhci-esdhc-imx.c
index fd404ad79..0d7b0239c 100644
--- a/drivers/mmc/host/sdhci-esdhc-imx.c
+++ b/drivers/mmc/host/sdhci-esdhc-imx.c
@@ -93,6 +93,8 @@
 #define ESDHC_STROBE_DLL_STS_SLV_LOCK	0x1
 
 #define ESDHC_VEND_SPEC2		0xc8
+#define ESDHC_VEND_SPEC2_TUNING_EN_MASK	0x00000070
+#define ESDHC_VEND_SPEC2_TUNING_EN_SHIFT	4
 #define ESDHC_VEND_SPEC2_EN_BUSY_IRQ	(1 << 8)
 
 #define ESDHC_TUNING_CTRL		0xcc
@@ -242,7 +244,7 @@ static struct esdhc_soc_data usdhc_imx8qxp_data = {
 	.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING
 			| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200
 			| ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES
-			| ESDHC_FLAG_CQHCI
+			/*| ESDHC_FLAG_CQHCI*/
 			| ESDHC_FLAG_STATE_LOST_IN_LPMODE
 			| ESDHC_FLAG_CLK_RATE_LOST_IN_PM_RUNTIME,
 };
@@ -251,7 +253,7 @@ static struct esdhc_soc_data usdhc_imx8mm_data = {
 	.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING
 			| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200
 			| ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES
-			| ESDHC_FLAG_CQHCI | ESDHC_FLAG_BUSFREQ
+			/*| ESDHC_FLAG_CQHCI*/ | ESDHC_FLAG_BUSFREQ
 			| ESDHC_FLAG_STATE_LOST_IN_LPMODE,
 };
 
@@ -1370,6 +1372,14 @@ static void sdhci_esdhc_imx_hwinit(struct sdhci_host *host)
 			tmp &= ~ESDHC_STD_TUNING_EN;
 			writel(tmp, host->ioaddr + ESDHC_TUNING_CTRL);
 		}
+
+                /* uSDHC auto tuning mechanism should use DAT[0] and CMD lines
+                 * if SDIO card is enabling SDIO Interrupts on DAT[1].
+                 */
+                if (imx_data->boarddata.sdio_interrupt_enabled)
+                        esdhc_clrset_le(host, ESDHC_VEND_SPEC2_TUNING_EN_MASK,
+                                        0x6 << ESDHC_VEND_SPEC2_TUNING_EN_SHIFT,
+                                        ESDHC_VEND_SPEC2);
 	}
 }
 
@@ -1468,6 +1478,9 @@ sdhci_esdhc_imx_probe_dt(struct platform_device *pdev,
 	if (of_find_property(np, "auto-cmd23-broken", NULL))
 		host->quirks2 |= SDHCI_QUIRK2_ACMD23_BROKEN;
 
+	if (of_property_read_bool(np, "fsl,sdio-interrupt-enabled"))
+		boarddata->sdio_interrupt_enabled = true;
+
 	if (of_property_read_u32(np, "fsl,delay-line", &boarddata->delay_line))
 		boarddata->delay_line = 0;
 
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 09df434b2..df325de21 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -3735,6 +3735,7 @@ fec_probe(struct platform_device *pdev)
 	int num_rx_qs;
 	char irq_name[8];
 	int irq_cnt;
+	const char *name = of_get_property(np, "label", NULL);
 
 	fec_enet_get_queue_num(pdev, &num_tx_qs, &num_rx_qs);
 
@@ -3758,6 +3759,9 @@ fec_probe(struct platform_device *pdev)
 	fep->num_rx_queues = num_rx_qs;
 	fep->num_tx_queues = num_tx_qs;
 
+	if (name)
+                strlcpy(fep->netdev->name, name, 20);
+
 #if !defined(CONFIG_M5272)
 	/* default enable pause frame auto negotiation */
 	if (fep->quirks & FEC_QUIRK_HAS_GBIT)
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c b/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
index f86d24af3..a6ea391fb 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-imx.c
@@ -208,6 +208,27 @@ static void imx_dwmac_exit(struct platform_device *pdev, void *priv)
 	pm_runtime_put(&pdev->dev);
 }
 
+static void imx_dwmac_eqos_workaround_ksz9131_10m_speed(struct imx_priv_data *dwmac, unsigned int speed)
+{
+	int val, id1, id2;
+	struct net_device *ndev = dev_get_drvdata(dwmac->dev);
+	struct phy_device *phy_dev = ndev->phydev;
+
+	id1 = phy_read(phy_dev, 0x02);
+	id2 = phy_read(phy_dev, 0x03);
+	if((id1 != 0x0022) || ((id2 & 0xfff0) != 0x1640)) {
+		return;
+	}
+
+	if (speed == SPEED_10) {
+		val = phy_read(phy_dev, 0x11);
+		phy_write(phy_dev, 0x11, (val | (1<<2)));
+	} else {
+		val = phy_read(phy_dev, 0x11);
+		phy_write(phy_dev, 0x11, (val & (~(1<<2))));
+	}
+}
+
 static void imx_dwmac_fix_speed(void *priv, unsigned int speed)
 {
 	struct imx_priv_data *dwmac = priv;
@@ -238,6 +259,8 @@ static void imx_dwmac_fix_speed(void *priv, unsigned int speed)
 	err = clk_set_rate(dwmac->clk_tx, rate);
 	if (err < 0)
 		dev_err(dwmac->dev, "failed to set tx rate %lu\n", rate);
+
+	imx_dwmac_eqos_workaround_ksz9131_10m_speed(dwmac, speed);
 }
 
 static int
diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c
index 663c68ed6..42fb3319b 100644
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@ -705,6 +705,61 @@ static int ksz9131_of_load_skew_values(struct phy_device *phydev,
 	return phy_write_mmd(phydev, 2, reg, newval);
 }
 
+#define KSZ9131_RX_DLL_CTRL	0x4c
+#define KSZ9131_TX_DLL_CTRL	0x4d
+#define KSZ9131_DLL_CTRL_BYPASS	BIT(12)
+static int ksz9131_of_load_dll_skew(struct phy_device *phydev,
+				    struct device_node *of_node)
+{
+	int ret;
+	u16 tmp;
+	u32 val;
+
+	if (!of_property_read_u32(of_node, "rxc-dll-2ns", &val)) {
+		tmp = phy_read_mmd(phydev, 2, KSZ9131_RX_DLL_CTRL);
+		if (val == 0)
+			tmp |= KSZ9131_DLL_CTRL_BYPASS;
+		if (val == 1)
+			tmp &= ~KSZ9131_DLL_CTRL_BYPASS;
+		ret = phy_write_mmd(phydev, 2, KSZ9131_RX_DLL_CTRL, tmp);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (!of_property_read_u32(of_node, "txc-dll-2ns", &val)) {
+		tmp = phy_read_mmd(phydev, 2, KSZ9131_TX_DLL_CTRL);
+		if (val == 0)
+			tmp |= KSZ9131_DLL_CTRL_BYPASS;
+		if (val == 1)
+			tmp &= ~KSZ9131_DLL_CTRL_BYPASS;
+		ret = phy_write_mmd(phydev, 2, KSZ9131_TX_DLL_CTRL, tmp);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
+/* Silicon Errata DS80000693B
+ *
+ * When LEDs are configured in Individual Mode, LED1 is ON in a no-link
+ * condition. Workaround is to set register 0x1e, bit 9, this way LED1 behaves
+ * according to the datasheet (off if there is no link).
+ */
+static int ksz9131_led_errata(struct phy_device *phydev)
+{
+        int reg;
+
+        reg = phy_read_mmd(phydev, 2, 0);
+        if (reg < 0)
+                return reg;
+
+        if (!(reg & BIT(4)))
+                return 0;
+
+        return phy_set_bits(phydev, 0x1e, BIT(9));
+}
+
 static int ksz9131_config_init(struct phy_device *phydev)
 {
 	const struct device *dev = &phydev->mdio.dev;
@@ -731,6 +786,7 @@ static int ksz9131_config_init(struct phy_device *phydev)
 	if (!of_node)
 		return 0;
 
+	ksz9131_of_load_dll_skew(phydev, of_node);
 	ret = ksz9131_of_load_skew_values(phydev, of_node,
 					  MII_KSZ9031RN_CLK_PAD_SKEW, 5,
 					  clk_skews, 2);
@@ -755,6 +811,10 @@ static int ksz9131_config_init(struct phy_device *phydev)
 	if (ret < 0)
 		return ret;
 
+	ret = ksz9131_led_errata(phydev);
+	if (ret < 0)
+		return ret;
+
 	return 0;
 }
 
diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c
index e57d59b0a..f95fa307d 100644
--- a/drivers/net/usb/qmi_wwan.c
+++ b/drivers/net/usb/qmi_wwan.c
@@ -1058,7 +1058,8 @@ static const struct usb_device_id products[] = {
 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0125)},	/* Quectel EC25, EC20 R2.0  Mini PCIe */
 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0306)},	/* Quectel EP06/EG06/EM06 */
 	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0512)},	/* Quectel EG12/EM12 */
-	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0800)},	/* Quectel RM500Q-GL */
+	{QMI_MATCH_FF_FF_FF(0x2c7c, 0x0800)},	/* Quectel RM500Q */
+    {QMI_MATCH_FF_FF_FF(0x2c7c, 0x0801)},	/* Quectel RM520N */
 
 	/* 3. Combined interface devices matching on interface number */
 	{QMI_FIXED_INTF(0x0408, 0xea42, 4)},	/* Yota / Megafon M100-1 */
diff --git a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
index 4eaa493e3..a406d74b8 100644
--- a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
@@ -47,7 +47,7 @@ mwifiex_process_cmdresp_error(struct mwifiex_private *priv,
 	struct mwifiex_adapter *adapter = priv->adapter;
 	struct host_cmd_ds_802_11_ps_mode_enh *pm;
 
-	mwifiex_dbg(adapter, ERROR,
+	mwifiex_dbg(adapter, MSG,
 		    "CMD_RESP: cmd %#x error, result=%#x\n",
 		    resp->command, resp->result);
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/Makefile b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/Makefile
old mode 100644
new mode 100755
index 8ee9b9322..378fd4376
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/Makefile
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/Makefile
@@ -1,7 +1,6 @@
-# SPDX-License-Identifier: GPL-2.0-only
 #  File: Makefile
 #
-#  Copyright 2014-2020 NXP
+#  Copyright 2008-2022 NXP
 #
 #  This software file (the File) is distributed by NXP
 #  under the terms of the GNU General Public License Version 2, June 1991
@@ -17,6 +16,18 @@
 #  this warranty disclaimer.
 #
 
+CONFIG_COMPATDIR=n
+ifeq ($(CONFIG_COMPATDIR), y)
+COMPATDIR=/lib/modules/$(KERNELVERSION_X86)/build/compat-wireless-3.2-rc1-1/include
+CC ?=		$(CROSS_COMPILE)gcc -I$(COMPATDIR)
+else
+CC ?=		$(CROSS_COMPILE)gcc -I$(COMPATDIR)
+endif
+
+LD ?=		$(CROSS_COMPILE)ld
+BACKUP=		/root/backup
+YMD=		`date +%Y%m%d%H%M`
+
 #############################################################################
 # Configuration Options
 #############################################################################
@@ -26,18 +37,28 @@ CONFIG_SD8897=n
 CONFIG_USB8897=n
 CONFIG_PCIE8897=n
 CONFIG_SD8977=n
-CONFIG_SD8978=n
+CONFIG_SD8978=y
 CONFIG_USB8978=n
-CONFIG_SD8997=n
+CONFIG_SD8997=y
 CONFIG_USB8997=n
 CONFIG_PCIE8997=y
 CONFIG_SD8987=y
 CONFIG_SD9097=n
+CONFIG_SD9177=y
+CONFIG_SD8801=y
+CONFIG_USB8801=n
 CONFIG_USB9097=n
 CONFIG_PCIE9097=n
-CONFIG_SD9098=n
+CONFIG_SD9098=y
 CONFIG_USB9098=n
-CONFIG_PCIE9098=n
+CONFIG_PCIE9098=y
+CONFIG_SDIW62X=n
+CONFIG_SDAW693=n
+CONFIG_PCIEIW62X=n
+CONFIG_USBIW62X=n
+CONFIG_PCIEAW693=n
+
+
 
 # Debug Option
 # DEBUG LEVEL n/1/2:
@@ -55,9 +76,11 @@ CONFIG_UAP_SUPPORT=y
 # Enable WIFIDIRECT support
 CONFIG_WIFI_DIRECT_SUPPORT=y
 
+
 # Re-association in driver
 CONFIG_REASSOCIATION=y
 
+
 # Manufacturing firmware support
 CONFIG_MFG_CMD_SUPPORT=y
 
@@ -67,6 +90,16 @@ CONFIG_OPENWRT_SUPPORT=n
 # Big-endian platform
 CONFIG_BIG_ENDIAN=n
 
+#ifdef EMBEDDED_AUTH
+# Enable driver based authenticator
+CONFIG_DRV_EMBEDDED_AUTHENTICATOR=n
+#endif
+
+#ifdef EMBEDDED_SUPP
+# Enable driver based supplicant
+CONFIG_DRV_EMBEDDED_SUPPLICANT=n
+#endif
+
 ifeq ($(CONFIG_DRV_EMBEDDED_SUPPLICANT), y)
 CONFIG_EMBEDDED_SUPP_AUTH=y
 else
@@ -83,25 +116,58 @@ CONFIG_SDIO_SUSPEND_RESUME=y
 # DFS testing support
 CONFIG_DFS_TESTING_SUPPORT=y
 
-CONFIG_ANDROID_KERNEL=n
+# Multi-channel support
+CONFIG_MULTI_CHAN_SUPPORT=y
+
+
+
 
 #32bit app over 64bit kernel support
 CONFIG_USERSPACE_32BIT_OVER_KERNEL_64BIT=n
 
+
 #############################################################################
 # Select Platform Tools
 #############################################################################
 
 MODEXT = ko
-ccflags-y += -I$(M)/mlan
+ccflags-y += -I$(PWD)/mlan
 ccflags-y += -DLINUX
 
+
+
+#if defined(EMBEDDED_SUPP) || defined(EMBEDDED_AUTH)
+ifeq ($(CONFIG_EMBEDDED_SUPP_AUTH), y)
+ccflags-y += -I$(M)/mlan/esa
+ccflags-y += -I$(M)/mlan/esa/common
+endif
+#endif
+
+
+
+ARCH ?= arm64
+CONFIG_IMX_SUPPORT=y
+ifeq ($(CONFIG_IMX_SUPPORT),y)
+ccflags-y += -DIMX_SUPPORT
+ifneq ($(ANDROID_PRODUCT_OUT),)
+ccflags-y += -DIMX_ANDROID
+CONFIG_ANDROID_KERNEL=y
+endif
+endif
+KERNELDIR ?= /usr/src/arm/linux_5_10_y_kernel/linux-nxp
+CROSS_COMPILE ?= /opt/fsl-imx-internal-xwayland/5.10-gatesgarth/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-
+
 LD += -S
 
+BINDIR = ../bin_wlan
+APPDIR= $(shell if test -d "mapp"; then echo mapp; fi)
+
 #############################################################################
 # Compiler Flags
 #############################################################################
 
+	ccflags-y += -I$(KERNELDIR)/include
+
 	ccflags-y += -DFPNUM='"92"'
 
 ifeq ($(CONFIG_DEBUG),1)
@@ -159,6 +225,9 @@ ifeq ($(CONFIG_SDIO_SUSPEND_RESUME),y)
 endif
 #endif
 
+ifeq ($(CONFIG_MULTI_CHAN_SUPPORT),y)
+	ccflags-y += -DMULTI_CHAN_SUPPORT
+endif
 
 ifeq ($(CONFIG_DFS_TESTING_SUPPORT),y)
 	ccflags-y += -DDFS_TESTING_SUPPORT
@@ -207,10 +276,30 @@ ifeq ($(CONFIG_SD9097),y)
 	CONFIG_SDIO=y
 	ccflags-y += -DSD9097
 endif
+ifeq ($(CONFIG_SDIW62X),y)
+	CONFIG_SDIO=y
+	ccflags-y += -DSDIW62X
+endif
+ifeq ($(CONFIG_SDAW693),y)
+	CONFIG_SDIO=y
+	ccflags-y += -DSDAW693
+endif
+ifeq ($(CONFIG_SD9177),y)
+	CONFIG_SDIO=y
+	ccflags-y += -DSD9177
+endif
+ifeq ($(CONFIG_SD8801),y)
+	CONFIG_SDIO=y
+	ccflags-y += -DSD8801
+endif
 ifeq ($(CONFIG_SD9098),y)
 	CONFIG_SDIO=y
 	ccflags-y += -DSD9098
 endif
+ifeq ($(CONFIG_USB8801),y)
+	CONFIG_MUSB=y
+	ccflags-y += -DUSB8801
+endif
 ifeq ($(CONFIG_USB8897),y)
 	CONFIG_MUSB=y
 	ccflags-y += -DUSB8897
@@ -227,6 +316,10 @@ ifeq ($(CONFIG_USB9097),y)
 	CONFIG_MUSB=y
 	ccflags-y += -DUSB9097
 endif
+ifeq ($(CONFIG_USBIW62X),y)
+	CONFIG_MUSB=y
+	ccflags-y += -DUSBIW62X
+endif
 ifeq ($(CONFIG_USB9098),y)
 	CONFIG_MUSB=y
 	ccflags-y += -DUSB9098
@@ -247,6 +340,16 @@ ifeq ($(CONFIG_PCIE9098),y)
 	CONFIG_PCIE=y
 	ccflags-y += -DPCIE9098
 endif
+ifeq ($(CONFIG_PCIEIW62X),y)
+	CONFIG_PCIE=y
+	ccflags-y += -DPCIEIW62X
+endif
+#ifdef PCIEAW693_OPT
+ifeq ($(CONFIG_PCIEAW693),y)
+	CONFIG_PCIE=y
+	ccflags-y += -DPCIEAW693
+endif
+#endif
 ifeq ($(CONFIG_SDIO),y)
 	ccflags-y += -DSDIO
 	ccflags-y += -DSDIO_MMC
@@ -258,20 +361,44 @@ ifeq ($(CONFIG_PCIE),y)
 	ccflags-y += -DPCIE
 endif
 
+ifeq ($(CONFIG_MAC80211_SUPPORT),y)
+	ccflags-y += -DMAC80211_SUPPORT
+endif
+ifeq ($(CONFIG_MAC80211_SUPPORT_UAP),y)
+	ccflags-y += -DMAC80211_SUPPORT_UAP
+endif
+ifeq ($(CONFIG_MAC80211_SUPPORT_MESH),y)
+	ccflags-y += -DMAC80211_SUPPORT_MESH
+endif
+
 # add -Wno-packed-bitfield-compat when GCC version greater than 4.4
 GCC_VERSION := $(shell echo `gcc -dumpversion | cut -f1-2 -d.` \>= 4.4 | sed -e 's/\./*100+/g' | bc )
 ifeq ($(GCC_VERSION),1)
 	ccflags-y += -Wno-packed-bitfield-compat
 endif
-	ccflags-y += -Wno-stringop-overflow
-	ccflags-y += -Wno-tautological-compare
-	ccflags-y += -Wno-packed-bitfield-compat
-	ccflags-y += -Wno-stringop-truncation
-
+WimpGCC_VERSION := $(shell echo `gcc -dumpversion | cut -f1 -d.`| bc )
+ifeq ($(shell test $(WimpGCC_VERSION) -ge 7; echo $$?),0)
+ccflags-y += -Wimplicit-fallthrough=3
+endif
+#ccflags-y += -Wunused-but-set-variable
+#ccflags-y += -Wmissing-prototypes
+#ccflags-y += -Wold-style-definition
+#ccflags-y += -Wtype-limits
+#ccflags-y += -Wsuggest-attribute=format
+#ccflags-y += -Wmissing-include-dirs
+#ccflags-y += -Wshadow
+#ccflags-y += -Wsign-compare
+#ccflags-y += -Wunused-macros
+#ccflags-y += -Wmissing-field-initializers
+#ccflags-y += -Wstringop-truncation
+#ccflags-y += -Wmisleading-indentation
+#ccflags-y += -Wunused-const-variable
 #############################################################################
 # Make Targets
 #############################################################################
 
+ifneq ($(KERNELRELEASE),)
+
 ifeq ($(CONFIG_WIRELESS_EXT),y)
 ifeq ($(CONFIG_WEXT_PRIV),y)
 	# Enable WEXT for STA
@@ -381,6 +508,20 @@ endif
 endif
 endif
 
+
+#ifdef EMBEDDED_AUTH
+ifeq ($(CONFIG_DRV_EMBEDDED_AUTHENTICATOR), y)
+    ccflags-y += -DDRV_EMBEDDED_AUTHENTICATOR
+endif
+#endif
+
+#ifdef EMBEDDED_SUPP
+ifeq ($(CONFIG_DRV_EMBEDDED_SUPPLICANT), y)
+    ccflags-y += -DDRV_EMBEDDED_SUPPLICANT
+endif
+#endif
+
+
 MOALOBJS =	mlinux/moal_main.o \
 		mlinux/moal_ioctl.o \
 		mlinux/moal_shim.o \
@@ -451,7 +592,46 @@ MOALOBJS += mlinux/moal_proc.o
 MOALOBJS += mlinux/moal_debug.o
 endif
 
-obj-$(CONFIG_MXMWIFIEX) := mlan.o
+ifeq ($(CONFIG_MAC80211_SUPPORT),y)
+MOALOBJS += mlinux/moal_mac80211.o
+MLANOBJS += mlan/mlan_mac80211.o
+endif
+
+
+
+#if defined(EMBEDDED_SUPP) || defined(EMBEDDED_AUTH)
+ifeq ($(CONFIG_EMBEDDED_SUPP_AUTH), y)
+MLANOBJS += mlan/esa/common/crypto_api.o \
+			mlan/esa/common/aes_cmac_rom.o \
+			mlan/esa/common/crypt_new_rom.o \
+			mlan/esa/common/pmkCache.o \
+			mlan/esa/common/pmkCache_rom.o \
+			mlan/esa/common/parser.o \
+			mlan/esa/common/parser_rom.o \
+			mlan/esa/keyMgmtApStaCommon.o \
+			mlan/esa/hostsa_init.o \
+			mlan/esa/authenticator_api.o
+endif
+#endif
+
+
+#ifdef EMBEDDED_SUPP
+ifeq ($(CONFIG_DRV_EMBEDDED_SUPPLICANT),y)
+MLANOBJS += mlan/esa/keyMgmtSta.o \
+			mlan/esa/keyMgmtSta_rom.o \
+			mlan/esa/supplicant.o
+endif
+#endif
+
+#ifdef EMBEDDED_AUTH
+ifeq ($(CONFIG_DRV_EMBEDDED_AUTHENTICATOR),y)
+MLANOBJS += mlan/esa/AssocAp_srv_rom.o \
+			mlan/esa/keyMgmtAp_rom.o \
+			mlan/esa/keyMgmtAp.o
+endif
+#endif
+
+obj-m := mlan.o
 mlan-objs := $(MLANOBJS)
 
 ifeq ($(CONFIG_MUSB),y)
@@ -463,22 +643,84 @@ endif
 ifeq ($(CONFIG_PCIE),y)
 MOALOBJS += mlinux/moal_pcie.o
 endif
-
-obj-$(CONFIG_MXMWIFIEX) += moal.o
+obj-m += moal.o
 moal-objs := $(MOALOBJS)
 
+# Otherwise we were called directly from the command line; invoke the kernel build system.
+else
+
+default:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) modules
+
+endif
+
+###############################################################
+
+export		CC LD ccflags-y KERNELDIR
+
+.PHONY: mapp/mlanutl clean distclean
+	@echo "Finished Making NXP Wlan Linux Driver"
+
+mapp/mlanutl:
+	$(MAKE) -C $@
+
+echo:
+
+appsbuild:
+
+	@if [ ! -d $(BINDIR) ]; then \
+		mkdir $(BINDIR); \
+	fi
+
+	cp -f README $(BINDIR)
+
+ifneq ($(APPDIR),)
+	cp -rf mapp/mlanconfig/config $(BINDIR)
+	$(MAKE) -C mapp/mlanutl $@ INSTALLDIR=$(BINDIR)
+endif
+
+build:		echo default
+
+	@if [ ! -d $(BINDIR) ]; then \
+		mkdir $(BINDIR); \
+	fi
+
+	cp -f mlan.$(MODEXT) $(BINDIR)/mlan$(DBG).$(MODEXT)
+
+	cp -f moal.$(MODEXT) $(BINDIR)/moal$(DBG).$(MODEXT)
+	cp -rpf script/load $(BINDIR)/
+	cp -rpf script/unload $(BINDIR)/
+
+	cp -f README $(BINDIR)
+
+ifneq ($(APPDIR),)
+	cp -rf mapp/mlanconfig/config $(BINDIR)
+	$(MAKE) -C mapp/mlanutl $@ INSTALLDIR=$(BINDIR)
+endif
+
 clean:
 	-find . -name "*.o" -exec rm {} \;
 	-find . -name "*.ko" -exec rm {} \;
 	-find . -name ".*.cmd" -exec rm {} \;
 	-find . -name "*.mod.c" -exec rm {} \;
-	-find . -name "*.mod" -exec rm {} \;
 	-find . -name "Module.symvers" -exec rm {} \;
 	-find . -name "Module.markers" -exec rm {} \;
 	-find . -name "modules.order" -exec rm {} \;
 	-find . -name ".*.dwo" -exec rm {} \;
 	-find . -name "*dwo" -exec rm {} \;
 	-rm -rf .tmp_versions
+ifneq ($(APPDIR),)
+	$(MAKE) -C mapp/mlanutl $@
+endif
+#ifdef SDIO
+#endif // SDIO
+
+install: default
+
+	cp -f mlan.$(MODEXT) $(INSTALLDIR)/mlan$(DBG).$(MODEXT)
+	cp -f moal.$(MODEXT) $(INSTALLDIR)/moal$(DBG).$(MODEXT)
+	echo $(INSTALLDIR)
+	echo "MX Driver Installed"
 
 distclean:
 	-find . -name "*.o" -exec rm {} \;
@@ -496,3 +738,8 @@ distclean:
 	-find . -name ".*.dwo" -exec rm {} \;
 	-find . -name "*dwo" -exec rm {} \;
 	-rm -rf .tmp_versions
+ifneq ($(APPDIR),)
+	$(MAKE) -C mapp/mlanutl $@
+endif
+
+# End of file
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/README b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/README
new file mode 100755
index 000000000..08ca659ee
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/README
@@ -0,0 +1,1188 @@
+===============================================================================
+			U S E R  M A N U A L
+
+ Copyright 2008-2023 NXP
+
+
+1) FOR DRIVER BUILD
+
+	Goto source code directory wlan_src/.
+	make [clean] build
+	The driver and utility binaries can be found in ../bin_xxxx directory.
+	The driver code supports Linux kernel from 2.6.32 to 6.0.0.
+
+2) FOR DRIVER INSTALL
+
+#ifdef MULTI_CHIP
+	a) Copy firmware image to /lib/firmware/nxp/, copy wifi_mod_para.conf to /lib/firmware/nxp/.
+	b) Install WLAN driver
+	   There are drv_mode, max_sta_bss, max_uap_bss etc. module parameters.
+		The bit settings of drv_mode are,
+			Bit 0 :  STA
+			Bit 1 :  uAP
+#ifdef WIFI_DIRECT_SUPPORT
+			Bit 2 :  WIFIDIRECT
+#endif
+#ifdef MPL_SUPPORT
+			Bit 3 :  MPL
+#endif
+#ifdef NAN_SUPPORT
+			Bit 4 :  NAN
+#endif
+
+#ifdef ADHOC_OVER_IP
+		max_sta_bss: Maximum number of STA BSS (default 1, max 18)
+#else
+#ifdef STA_MBSS_SUPPORT
+		max_sta_bss: Maximum number of STA BSS (default 1, max 2)
+#else
+		max_sta_bss: Maximum number of STA BSS (default 1, max 1)
+#endif
+#endif
+		sta_name: Name of the STA interface (default: "mlan")
+#ifdef UAP_MBSS_SUPPORT
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 2)
+#else
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 1)
+#endif
+		uap_name: Name of the uAP interface (default: "uap")
+#ifdef WIFI_DIRECT_SUPPORT
+		max_wfd_bss: Maximum number of WIFIDIRECT BSS (default 1, max 1)
+		wfd_name: Name of the WIFIDIRECT interface (default: "wfd")
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		max_vir_bss: Number of Virtual interfaces (default 0)
+#endif
+#endif
+#ifdef MPL_SUPPORT
+		max_mpl_bss: Number of MPL interfaces (defaut 1, max 1)
+#endif
+#ifdef NAN_SUPPORT
+		nan_name: Name of the NAN interface (default: "nan")
+		max_nan_bss: Number of NAN interfaces (default 1)
+#endif
+		uap_oper_ctrl: uAP operation control when in-STA disconnect with ext-AP
+                               0: default do nothing, 2: uAP stops and restarts automatically
+	   For example, to install multi-chip driver,
+		insmod mlan.ko
+		insmod moal.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi-chips which has different load module parameters. It contains
+           the module parameters for different chips.
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		ifconfig uapX down
+		rmmod moal
+		rmmod mlan
+#else
+#ifdef USB      // Section 1	USB
+#ifdef UAP_STA_SUPPORT
+#ifdef ORION
+	a) Copy firmware image usb8786_uapsta.bin | ... to /usr/lib/hotplug/firmware/nxp/
+	   directory, create the directory if it doesn't exist.
+#else
+	a) Copy firmware image usb8766_uapsta.bin | ... to /lib/firmware/nxp/ directory,
+	   create the directory if it doesn't exist.
+#endif
+	b) Install WLAN driver
+	   There are drv_mode, max_sta_bss, max_uap_bss etc. module parameters.
+		The bit settings of drv_mode are,
+			Bit 0 :  STA
+			Bit 1 :  uAP
+#ifdef WIFI_DIRECT_SUPPORT
+			Bit 2 :  WIFIDIRECT
+#endif
+#ifdef MPL_SUPPORT
+			Bit 3 :  MPL
+#endif
+#ifdef NAN_SUPPORT
+			Bit 4 :  NAN
+#endif
+
+#ifdef ADHOC_OVER_IP
+		max_sta_bss: Maximum number of STA BSS (default 1, max 18)
+#else
+#ifdef STA_MBSS_SUPPORT
+		max_sta_bss: Maximum number of STA BSS (default 1, max 2)
+#else
+		max_sta_bss: Maximum number of STA BSS (default 1, max 1)
+#endif
+#endif
+		sta_name: Name of the STA interface (default: "mlan")
+#ifdef UAP_MBSS_SUPPORT
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 2)
+#else
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 1)
+#endif
+		uap_name: Name of the uAP interface (default: "uap")
+#ifdef WIFI_DIRECT_SUPPORT
+		max_wfd_bss: Maximum number of WIFIDIRECT BSS (default 1, max 1)
+		wfd_name: Name of the WIFIDIRECT interface (default: "wfd")
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		max_vir_bss: Number of Virtual interfaces (default 0)
+#endif
+#endif
+#ifdef MPL_SUPPORT
+		max_mpl_bss: Number of MPL interfaces (defaut 1, max 1)
+#endif
+#ifdef NAN_SUPPORT
+		nan_name: Name of the NAN interface (default: "nan")
+		max_nan_bss: Number of NAN interfaces (default 1)
+#endif
+		uap_oper_ctrl: uAP operation control when in-STA disconnect with ext-AP
+                               0: default do nothing, 2: uAP stops and restarts automatically
+#ifdef USBXXX
+	   For example, to install USB multi-chip driver,
+		insmod mlan.ko
+		insmod usbxxx.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi-chips which has different load module parameters. It contains
+           the module parameters for different chips.
+#else
+	   For example, to install USB8766 driver,
+		insmod mlan.ko
+		insmod usb8766.ko [drv_mode=3] [fw_name=nxp/usb8766_uapsta.bin]
+	   To load driver in STA only mode,
+		insmod mlan.ko
+		insmod usb8766.ko drv_mode=1 [fw_name=nxp/usb8766_uapsta.bin]
+	   To load driver in uAP only mode,
+		insmod mlan.ko
+		insmod usb8766.ko drv_mode=2 [fw_name=nxp/usb8766_uapsta.bin]
+#ifdef USB_FW_DNLD_ENH
+	   To load driver with wifi downloader firmware support.
+		insmod mlan.ko
+		insmod usb8997.ko usb_fw_option=1 cal_data_cfg=...
+#endif
+#endif // USBXXX
+	   To switch mode between STA only, uAP only and uAPSTA in run time,
+		echo drv_mode=1 > /proc/mwlan/adapterX/config		// STA mode
+		echo drv_mode=2 > /proc/mwlan/adapterX/config		// uAP mode
+		echo drv_mode=3 > /proc/mwlan/adapterX/config		// uAPSTA mode
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		ifconfig uapX down
+		rmmod usbxxx
+		rmmod mlan
+#else
+#ifdef ORION
+	a) Copy firmware image usb8786.bin | ... to /usr/lib/hotplug/firmware/nxp/
+	   directory, create the directory if it doesn't exist.
+#else
+	a) Copy firmware image usb8766.bin | ... to /lib/firmware/nxp/ directory,
+	   create the directory if it doesn't exist.
+#endif
+	b) Install WLAN driver,
+#ifdef USBXXX
+	   For example, to install multi-chip driver,
+		insmod mlan.ko
+		insmod usbxxx.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi chips which has different module parameters. It contains
+           the module parameters for different chips.
+#else
+	   For example, to install USB8766 driver,
+		insmod mlan.ko
+		insmod usb8766.ko [fw_name=nxp/usb8766.bin]
+#endif //USBXXX
+	c) Uninstall WLAN driver,
+		ifconfig mlan0 down
+		rmmod usbxxx
+		rmmod mlan
+#endif // UAP_STA_SUPPORT
+#endif          // End of section 1	USB
+
+#ifdef SDIO     // Section 2	SDIO
+#ifdef UAP_STA_SUPPORT
+#ifdef PXA9XX
+	a) Copy firmware image sd8787_uapsta.bin | sd8797_uapsta.bin | ... to
+	   /system/etc/firmware/nxp/ directory, create the directory if it doesn't exist.
+#else
+	a) Copy firmware image sd8787_uapsta.bin | sd8797_uapsta.bin | ... to
+	   /lib/firmware/nxp/ directory, create the directory if it doesn't exist.
+#endif
+#ifdef SYSKT_MULTI
+	b) Install SDIO bus driver and WLAN driver,
+		./load sd8787 | sd8797 | ...
+	   Update load script to specify drv_mode, max_sta_bss, max_uap_bss etc. parameters.
+#else
+	b) Install WLAN driver,
+	   There are drv_mode, max_sta_bss, max_uap_bss etc. module parameters.
+#endif
+		The bit settings of drv_mode are,
+			Bit 0 :  STA
+			Bit 1 :  uAP
+#ifdef WIFI_DIRECT_SUPPORT
+			Bit 2 :  WIFIDIRECT
+		The default drv_mode is 7.
+#else
+		The default drv_mode is 3.
+#endif
+#ifdef MPL_SUPPORT
+			Bit 3 :  MPL
+#endif
+#ifdef NAN_SUPPORT
+			Bit 4 :  NAN
+#endif
+
+#ifdef ADHOC_OVER_IP
+		max_sta_bss: Maximum number of STA BSS (default 1, max 18)
+#else
+#ifdef STA_MBSS_SUPPORT
+		max_sta_bss: Maximum number of STA BSS (default 1, max 2)
+#else
+		max_sta_bss: Maximum number of STA BSS (default 1, max 1)
+#endif
+#endif
+		sta_name: Name of the STA interface (default: "mlan")
+#ifdef UAP_MBSS_SUPPORT
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 2)
+#else
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 1)
+#endif
+		uap_name: Name of the uAP interface (default: "uap")
+#ifdef WIFI_DIRECT_SUPPORT
+		max_wfd_bss: Maximum number of WIFIDIRECT BSS (default 1, max 1)
+		wfd_name: Name of the WIFIDIRECT interface (default: "wfd")
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		max_vir_bss: Number of Virtual interfaces (default 0)
+#endif
+#endif
+#ifdef MPL_SUPPORT
+		max_mpl_bss: Number of MPL interfaces (defaut 1, max 1)
+#endif
+#ifdef NAN_SUPPORT
+		nan_name: Name of the NAN interface (default: "nan")
+		max_nan_bss: Number of NAN interfaces (default 1)
+#endif
+#ifdef SDIOXXX
+	   For example, to install multi-chip driver,
+		insmod mlan.ko
+		insmod sdxxx.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi chips which has different module parameters. It contains
+	   the module parameters for different chips.
+#else
+#ifdef SYSKT_MULTI
+	   For example, load driver in STA only mode,
+		...
+		insmod $1.ko drv_mode=1 [fw_name=nxp/sd8887_uapsta.bin]
+#else
+	   For example, to install SD8887 driver,
+		insmod mlan.ko
+		insmod sd8887.ko [drv_mode=3] [fw_name=nxp/sd8887_uapsta.bin]
+	   To load driver in STA only mode,
+		insmod mlan.ko
+		insmod sd8887.ko drv_mode=1 [fw_name=nxp/sd8887_uapsta.bin]
+	   To load driver in uAP only mode,
+		insmod mlan.ko
+		insmod sd8887.ko drv_mode=2 [fw_name=nxp/sd8887_uapsta.bin]
+#endif
+#endif //SDIOXXX
+
+	   To switch mode between STA only, uAP only and uAPSTA etc. in run time,
+		echo drv_mode=1 > /proc/mwlan/adapterX/config		// STA mode
+		echo drv_mode=2 > /proc/mwlan/adapterX/config		// uAP mode
+		echo drv_mode=3 > /proc/mwlan/adapterX/config		// STA+uAP mode
+#ifdef WIFI_DIRECT_SUPPORT
+		echo drv_mode=7 > /proc/mwlan/adapterX/config		// STA+uAP+WIFIDIRECT mode
+#endif
+#ifdef SYSKT_MULTI
+	c) Uninstall WLAN driver and SDIO bus driver,
+		./unload
+#else
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		ifconfig uapX down
+		rmmod sdxxx
+		rmmod mlan
+#endif
+#else
+	a) Copy sd8787.bin | ... to /lib/firmware/nxp/ directory,
+	   create the directory if it doesn't exist.
+#ifdef SDIOXXX
+	b) Install SDIO bus driver and WLAN driver,
+	   For example, to install multi-chip driver,
+		insmod mlan.ko
+		insmod sdxxx.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi chips which has different module parameters. It contains
+	   the module parameters for different chips.
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		rmmod sdxxx
+		rmmod mlan
+#else
+#ifdef SYSKT_MULTI
+	b) Install SDIO bus driver and WLAN driver,
+		./load sd8787 | ...
+	c) Uninstall WLAN driver and SDIO bus driver,
+		./unload
+#else
+#ifdef ENT_BUILD
+	b) Install WLAN driver,
+		insmod mlan_ent.ko
+		insmod sdxxx_ent.ko [fw_name=nxp/sd8xxx.bin]
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		rmmod sdxxx_ent
+		rmmod mlan_ent
+#else
+	b) Install WLAN driver,
+		insmod mlan.ko
+		insmod sdxxx.ko [fw_name=nxp/sd8xxx.bin]
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		rmmod sdxxx
+		rmmod mlan
+#endif // ENT_BUILD
+#endif // SYSKT_MULTI
+#endif // SDIOXXX
+#endif // UAP_STA_SUPPORT
+#endif          // End of section 2	SDIO
+
+#ifdef PCIE     // Section 4	PCIe
+#ifdef UAP_STA_SUPPORT
+	a) Copy firmware image pcie8897_uapsta.bin | ... to /lib/firmware/nxp/ directory,
+	   create the directory if it doesn't exist.
+	b) Install WLAN driver
+	   There are drv_mode, max_sta_bss, max_uap_bss etc. module parameters.
+		The bit settings of drv_mode are,
+			Bit 0 :  STA
+			Bit 1 :  uAP
+#ifdef WIFI_DIRECT_SUPPORT
+			Bit 2 :  WIFIDIRECT
+#endif
+#ifdef MPL_SUPPORT
+			Bit 3 :  MPL
+#endif
+#ifdef NAN_SUPPORT
+			Bit 4 :  NAN
+#endif
+
+#ifdef ADHOC_OVER_IP
+		max_sta_bss: Maximum number of STA BSS (default 1, max 18)
+#else
+#ifdef STA_MBSS_SUPPORT
+		max_sta_bss: Maximum number of STA BSS (default 1, max 2)
+#else
+		max_sta_bss: Maximum number of STA BSS (default 1, max 1)
+#endif
+#endif
+		sta_name: Name of the STA interface (default: "mlan")
+#ifdef UAP_MBSS_SUPPORT
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 2)
+#else
+		max_uap_bss: Maximum number of uAP BSS (default 1, max 1)
+#endif
+		uap_name: Name of the uAP interface (default: "uap")
+#ifdef WIFI_DIRECT_SUPPORT
+		max_wfd_bss: Maximum number of WIFIDIRECT BSS (default 1, max 1)
+		wfd_name: Name of the WIFIDIRECT interface (default: "wfd")
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		max_vir_bss: Number of Virtual interfaces (default 0)
+#endif
+#endif
+#ifdef MPL_SUPPORT
+		max_mpl_bss: Number of MPL interfaces (defaut 1, max 1)
+#endif
+#ifdef NAN_SUPPORT
+		nan_name: Name of the NAN interface (default: "nan")
+		max_nan_bss: Number of NAN interfaces (default 1)
+#endif
+#ifdef PCIEXXX
+	   For example, to install multi-chip driver,
+		insmod mlan.ko
+		insmod pciexxx.ko mod_para=nxp/wifi_mod_para.conf [drvdbg=0x7]
+	   wifi_mod_para.conf is used to support multi chips which has different module parameters. It contains
+	   the module parameters for different chips.
+#else
+	   For example, to install PCIE8897 driver,
+		insmod mlan.ko
+		insmod pcie8897.ko [drv_mode=3] [fw_name=nxp/pcie8897_uapsta.bin]
+	   To load driver in STA only mode,
+		insmod mlan.ko
+		insmod pcie8897.ko drv_mode=1 [fw_name=nxp/pcie8897_uapsta.bin]
+	   To load driver in uAP only mode,
+		insmod mlan.ko
+		insmod pcie8897.ko drv_mode=2 [fw_name=nxp/pcie8897_uapsta.bin]
+#endif // PCIEXXX
+
+	   To switch mode between STA only, uAP only and uAPSTA in run time,
+		echo drv_mode=1 > /proc/mwlan/adapterX/config		// STA mode
+		echo drv_mode=2 > /proc/mwlan/adapterX/config		// uAP mode
+		echo drv_mode=3 > /proc/mwlan/adapterX/config		// uAPSTA mode
+	c) Uninstall WLAN driver,
+		ifconfig mlanX down
+		ifconfig uapX down
+		rmmod pciexxx
+		rmmod mlan
+#endif // UAP_STA_SUPPORT
+#endif          // End of section 4	PCIe
+#endif // MULTI_CHIP
+
+#ifdef MFG_CMD_SUPPORT
+	To load driver with MFG firmware file, use mfg_mode=1 when insmod WLAN driver and
+	specify MFG firmware name if needed.
+#endif
+
+#ifdef RF_TEST_MODE
+	To load driver with rf_test firmware file, use rf_test_mode=1 when insmod WLAN driver.
+	This parameter only used for 9177(FC)
+#endif
+
+	There are some other parameters for debugging purpose etc. Use modinfo to check details.
+#ifdef DEBUG_LEVEL1
+	  drvdbg=<bit mask of driver debug message control>
+#ifdef DEBUG_LOG
+	  logctrl=<Bit mask of driver log message control>
+	  sh_mem_size=<Shared memory length (default 8192 bytes)>
+#endif
+#endif
+	  dev_cap_mask=<Bit mask of the device capability>
+	  mac_addr=xx:xx:xx:xx:xx:xx <override the MAC address (in hex)>
+#if defined(OPTIMIZED_PS) && defined(DEEP_SLEEP)
+	  auto_ds=0|1|2 <use MLAN default | enable auto deepsleep | disable auto deepsleep>
+#endif
+#if defined(EXT_SCAN_SUPPORT) && defined(EXT_SCAN_ENH)
+	  ext_scan=0|1|2 <use MLAN default | Enable Extended Scan| Enable Enhanced Extended Scan>
+#endif
+      net_rx=0|1 <use netif_rx_ni in rx | use netif_receive_skb in rx>
+      amsdu_deaggr=0|1 <default | Try avoid buf copy in amsud deaggregation>
+
+#ifdef ENABLE_802_11P
+	  max_11p_bss = <Max number of 802_11P interfaces (default 1)>
+#endif
+	  ps_mode=0|1|2 <use MLAN default | enable IEEE PS mode | disable IEEE PS mode>
+	  sched_scan=0|1 <disable sched_scan | enable sched_scan default>
+	  max_tx_buf=2048|4096|8192 <maximum AMSDU Tx buffer size>
+#ifdef SDIO_SUSPEND_RESUME
+	  pm_keep_power=1|0 <PM keep power in suspend (default) | PM no power in suspend>
+	  shutdown_hs=1|0 <Enable HS when shutdown | No HS when shutdown (default)>
+#endif
+#ifdef ENABLE_802_11D
+	  cfg_11d=0|1|2 <use MLAN default | enable 11d | disable 11d>
+#endif
+#ifdef CONFIG_OF
+	  dts_enable=0|1 <Disable DTS | Enable DTS (default)>
+#endif
+#ifdef FW_DNLD_NEEDED
+	  fw_name = <FW file name>
+		e.g. copy pcieuart9098_combo_v1.bin to firmware directory, fw_name=nxp/pcieuart9098_combo_v1.bin
+#endif
+	  hw_name = <hardware name>
+	  reg_work=0|1 <Disable register work queue| Enable register work queue>
+	  hw_test=0|1 <Disable hardware test (default) | Enable hardware test>
+	  fw_serial=0|1 <support parallel download FW | support serial download FW (default)>
+	  req_fw_nowait=0|1 <use request_firmware API (default) | use request_firmware_nowait API>
+#if !defined(MLANUTL_LITE)
+#ifdef DFS_SUPPORT
+      dfs53cfg=0|1|2 <use Fw Default | New W53 | Old W53>
+#endif
+	  mcs32=0|1 <disable HT MCS32 support | enable HT MCS32 (default)>
+#ifdef SDIOXXX
+	  SD8887: antcfg=0|1|2|0xffff <default | Tx/Rx antenna 1 | Tx/Rx antenna 2 | enable antenna diversity>
+	  SD8897/SD8997: antcfg=0x11|0x13|0x33 <Bit0:Rx Path A, Bit1:Rx Path B, Bit 4:Tx Path A, Bit 5:Tx Path B>
+#else
+#ifdef SD8887
+	  antcfg=0|1|2|0xffff <default | Tx/Rx antenna 1 | Tx/Rx antenna 2 | enable antenna diversity>
+#else
+#if defined(SD8897) || defined(SD8997)||defined(SD9098) ||defined(SD9097)||defined(SDIW624)
+	  antcfg=0x11|0x13|0x33 <Bit0:Rx Path A, Bit1:Rx Path B, Bit 4:Tx Path A, Bit 5:Tx Path B>
+#endif
+#endif
+#endif
+#endif /* !defined(MLANUTL_LITE) */
+#ifdef SDIO
+	  slew_rate: Slew Rate Control value = 0|1|2|3 (0 is the slowest slew rate and 03 has the highest slew rate (default))
+#endif
+#ifdef NO_EEPROM_SUPPORT
+	  init_cfg=<init config (MAC addresses, registers etc.) file name>
+		e.g. copy init_cfg.conf to firmware directory, init_cfg=nxp/init_cfg.conf
+	  cal_data_cfg=<CAL data config file name>
+		e.g. copy cal_data.conf to firmware directory, cal_data_cfg=nxp/cal_data.conf
+#if defined(SDIOXXX) || defined(SD8887)
+          Note: Loading driver with 8887 must include correct cal_data_cfg parameter.
+#endif
+#endif
+#ifdef NO_EEPROM_SUPPORT
+	 dpd_data_cfg=<DPD data config file name>
+	   e.g. copy dpd_data.conf to firmware directory, dpd_data_cfg=nxp/dpd_data.conf
+#endif
+#ifdef TX_POWERCFG
+	  txpwrlimit_cfg=<Tx power limit config file name>
+		e.g. copy txpwrlimit_cfg_set.conf to firmware directory, txpwrlimit_cfg=nxp/txpwrlimit_cfg_set.conf
+#ifdef OTP_CHANINFO
+      cntry_txpwr=0|1|2
+#else
+      cntry_txpwr=0|1
+#endif
+                  0: Disable setting tx power table of country (default)
+                  1: Enable setting tx power table of country
+#ifdef OTP_CHANINFO
+                  2: Enable setting rgpower table of country
+#endif
+#endif
+#ifdef HOSTCMD_CFG
+	  init_hostcmd_cfg=<init hostcmd config file name>
+		e.g. copy init_hostcmd_cfg.conf to firmware directory, init_hostcmd_cfg=nxp/init_hostcmd_cfg.conf
+	  band_steer_cfg=<band steer config file name>
+		e.g. generate bscfg.conf by band_steer_cfg.conf, then copy bscfg.conf to firmware directory, band_steer_cfg=nxp/bscfg.conf
+#endif
+#if defined(SYSKT_MULTI) && defined(OOB_WAKEUP)
+	  oob_mode=0|1 <disable OOB wakeup mode (default) | enable OOB wakeup mode>
+#endif
+#ifdef SUSPEND_SDIO_PULL_DOWN
+	  sdio_pd=0|1 <disable suspend with sdio pull down feature (default) | enable suspend with sdio pull down feature>
+#endif
+#ifdef SDIO_SP_RX_AGGR
+	  sdio_rx_aggr=1|0 <Enable SDIO rx aggr (default) | Disable SDIO rx aggr>
+#endif
+#ifdef T3T
+#ifdef SDIO
+	  minicard_pwrup=1|0 <power up/down on driver load/unload (default) | don't power up/down>
+#endif
+#endif
+#ifdef SIMU_CFG80211_WEXT
+	  cfg80211_wext=<bit mask of CFG80211 and WEXT control>
+#ifdef STA_WEXT
+		Bit 0: STA WEXT
+#endif
+#ifdef UAP_WEXT
+		Bit 1: uAP WEXT
+#endif
+#ifdef STA_CFG80211
+		Bit 2: STA CFG80211
+#endif
+#ifdef UAP_CFG80211
+		Bit 3: uAP CFG80211
+#endif
+#endif
+#ifdef MULTI_CHAN_SUPPORT
+	  cfg80211_drcs=1|0 <Enable DRCS support (default) | Disable DRCS support>
+#endif
+	  reg_alpha2=<Regulatory alpha2 (default NULL)>
+#ifdef USB_NEW_FW_DNLD
+	  skip_fwdnld=0|1 <enable FW download support (default) | disable FW download support>
+#endif
+#ifdef WORK_QUEUE
+	  wq_sched_prio: Priority for work queue
+	  wq_sched_policy: Scheduling policy for work queue
+		(0: SCHED_NORMAL, 1: SCHED_FIFO, 2: SCHED_RR, 3: SCHED_BATCH, 5: SCHED_IDLE)
+		Please note that, both wq_sched_prio and wq_sched_policy should be provided
+		as module parameters. If wq_sched_policy is (0, 3 or 5), then wq_sched_prio
+		must be 0. wq_sched_prio should be 1 to 99 otherwise.
+	  rx_work=0|1|2 <default | Enable rx_work_queue | Disable rx_work_queue>
+#endif
+#ifdef PCIE
+#if defined(PCIE) && defined(PCIE_MSIX)
+	  pcie_int_mode=0|1|2 <Legacy mode, MSI mode (default), MSI-X mode>
+#elif defined(PCIE_MSI)
+	  pcie_int_mode=0|1 <Legacy mode, MSI mode (default)>
+#else
+	  pcie_int_mode=0 <Legacy mode(default)>
+#endif
+#if defined(PCIE9098) ||defined(PCIE9097)||defined(PCIEIW624)
+      ring_size=32|64|128|256|512 <adma ring size for 9097/9098>
+#endif
+#endif
+#if !defined(MLANUTL_LITE)
+#ifdef AGGR_CTRL
+	  aggrctrl=1|0 <enable Tx aggr | disable Tx aggr>
+#endif
+#endif /* !defined(MLANUTL_LITE) */
+#if defined(USB_TX_AGGR) || defined(USB_RX_DEAGGR)
+	  usb_aggr=0|1|2 <use MLAN default (disabled) | enable USB aggr | disable USB aggr>
+#endif
+#if defined WLAN_LOW_POWER_ENABLE
+	  low_power_mode_enable=0|1 <disable low power mode (default)| enable low power mode>
+	  When low power mode is enabled, the output power will be clipped at ~+10dBm and the
+	  expected PA current is expected to be in the 80-90 mA range for b/g/n modes
+#endif
+#if defined(ANDROID_KERNEL)
+#ifdef T50
+	wakelock_timeout=<set wakelock_timeout value (ms),default 3000ms>
+#else
+	wakelock_timeout=<set wakelock_timeout value (ms)>
+#endif
+#endif
+#ifdef V16_FW_API
+	pmic=0|1 <No pmic configure cmd sent to firmware | Send pmic configure cmd to firmware>
+#endif
+#ifdef HS_SUPPORT
+	indication_gpio=0xXY <GPIO to indicate wakeup source and its level; high four bits X:
+                  level(0/1) for normal wakeup; low four bits Y: GPIO pin number. This parameter
+                  only works with specific board and firmware.>
+	hs_wake_interval=<Host sleep wakeup interval,it will round to nearest multiple dtim*beacon_period in fw>
+	disconnect_on_suspend=0|1 <Disable disconnect wifi on suspend (default) | Enable disconnect wifi on suspend>
+#ifdef HS_MIMO_SWITCH
+	hs_mimo_switch=0|1 <Disable dynamic MIMO-SISO switch during host sleep (default) | Enable dynamic MIMO-SISO switch during host sleep>
+#endif
+#endif
+#if defined(HS_SUPPORT) || defined(UAP_HS_SUPPORT)
+    hs_auto_arp=0|1 <disable hs_auto_arp (default) | enable hs_auto_arp>
+#endif
+#ifdef GTK_REKEY_OFFLOAD
+	gtk_rekey_offload=0|1|2 <disable gtk_rekey_offload|enable gtk_rekey_offload (default) | enable gtk_rekey_offload in suspend mode only>
+#endif
+#ifdef NAPI_SUPPORT
+	napi=0|1 <disable napi | enable napi>
+#endif
+	fixed_beacon_buffer=0|1 <allocate default buffer size (default) | allocate max buffer size>
+#ifdef WIFI_DIRECT_SUPPORT
+	GoAgeoutTime=0|x <use default ageout time (default) | set Go age out time xTU(TU 100ms)>
+#endif
+	multi_dtim=0|x <use default DTIM interval(default) | set x*beacon_period as DTIM interval>
+	inact_tmo=0|x <use default IEEE ps inactivity timout value (default) | use IEEE ps inactivity timeout value x ms>
+#ifdef MULTI_CHAN_SUPPORT
+	drcs_chantime_mode=0|x <channel time and mode for DRCS, use default value (default) | use setting value>
+	  Bit31~Bit24:Channel time for channel index0;
+	  Bit23~Bit16:mode for channel index0; 0|1 <PM1 | Null2Self>
+	  Bit15~Bit8:Channel time for channel index1;
+	  Bit7~Bit0:mode for channel index1; 0|1 <PM1 | Null2Self>
+#endif
+#ifdef FW_ROAMING
+	roamoffload_in_hs=0|1 <always enable fw roaming (default) | enable fw roaming only when host suspend>
+#endif
+#ifdef MAX_STA_SIXTY_FOUR
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 64)
+#else
+#ifdef MAX_STA_THIRTY_TWO
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 32)
+#else
+#ifdef MAX_STA_TWENTY
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 20)
+#else
+#ifdef MAX_STA_TEN
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 10)
+#else
+#ifdef MAX_STA_FIVE
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 5)
+#else
+	uap_max_sta: Maximum number of STA for UAP/GO (default 0, max 8)
+#endif
+#endif
+#endif
+#endif
+#endif
+#ifdef HOST_MLME
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	host_mlme=0|1 <Operate in non-host_mlme mode | Operate in host_mlme mode (default)>
+	for supplicant/authenticator running on host side, WPA3 support is available only in host_mlme mode
+#endif
+#endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	country_ie_ignore=0|1 <Follow countryIE from AP and beacon hint enable (default) | Ignore countryIE from AP and beacon hint disable>
+	beacon_hints=0|1 <enable beacon hints(default) | disable beacon hints>
+#endif
+
+	chan_track=0|1 <restore channel tracking parameters(default) | set channel tracking new parameters> for 9098 only
+	keep_previous_scan=0|1, <Flush previous scan result before start scan | Keep previous scan result(default)>
+	auto_11ax=0|1, <disable auto_11ax | enable auto_11ax(default)>
+
+
+	Note: On some platforms (e.g. PXA910/920) double quotation marks ("") need to used
+	for module parameters.
+		insmod sdxxx.ko "<para1> <para2> ..."
+
+3) FOR DRIVER PROC & DEBUG
+
+	The following info are provided in /proc/net/mwlan/adapterX/mlanY|uapY|wfdY/info,
+	on kernel 2.6.24 or later, the entry is /proc/mwlan/adapterX/mlanY|uapY|wfdY/info.
+
+	driver_name = "wlan" or "uap"
+	driver_version = <chip id, firmware version and driver version>
+	interface_name = "mlanX", "uapX" or "wfdX"
+	bss_mode = "Ad-hoc" | "Managed" | "Auto" | "Unknown"
+	media_state = "Disconnected" | "Connected"
+	mac_address = <6-byte adapter MAC address>
+	multicase_count = <multicast address count>     // Only for STA
+	essid = <current SSID>                          // Only for STA
+	bssid = <current BSSID>                         // Only for STA
+	channel = <current channel>                     // Only for STA
+	region_code = <current region code>             // Only for STA
+	multicast_address[n] = <multicast address>      // Only for STA
+	num_tx_bytes = <number of bytes sent to device>
+	num_rx_bytes = <number of bytes received from device and sent to kernel>
+	num_tx_pkts = <number of packets sent to device>
+	num_rx_pkts = <number of packets received from device and sent to kernel>
+	num_tx_pkts_dropped = <number of Tx packets dropped by driver>
+	num_rx_pkts_dropped = <number of Rx packets dropped by driver>
+	num_tx_pkts_err = <number of Tx packets failed to send to device>
+	num_rx_pkts_err = <number of Rx packets failed to receive from device>
+	carrier "on" | "off"
+	tx queue "stopped" | "started"
+	tkip_mic_failures = 0                           // Only for uAP (use of WEP/TKIP is not recommended anymore)
+	ccmp_decrypt_errors = 0                         // Only for uAP
+	wep_undecryptable_count = 0                     // Only for uAP  (use of WEP/TKIP is not recommended anymore)
+	wep_icv_error_count = 0                         // Only for uAP  (use of WEP/TKIP is not recommended anymore)
+	decrypt_failure_count = 0                       // Only for uAP
+	mcast_tx_count = 0                              // Only for uAP
+	failed_count = 0                                // Only for uAP
+	retry_count = 0                                 // Only for uAP
+	multiple_retry_count = 0                        // Only for uAP
+	frame_duplicate_count = 0                       // Only for uAP
+	rts_success_count = 0                           // Only for uAP
+	rts_failure_count = 0                           // Only for uAP
+	ack_failure_count = 0                           // Only for uAP
+	rx_fragment_count = 0                           // Only for uAP
+	mcast_rx_frame_count = 0                        // Only for uAP
+	fcs_error_count = 0                             // Only for uAP
+	tx_frame_count = 0                              // Only for uAP
+	rsna_tkip_cm_invoked = 0                        // Only for uAP  (use of WEP/TKIP is not recommended anymore)
+	rsna_4way_hshk_failures = 0                     // Only for uAP
+
+	The following debug info are provided in /proc/net/mwlan/adapterX/mlanY|uapY|wfdY/debug,
+	on kernel 2.6.24 or later, the entry is /proc/mwlan/adapterX/mlanY|uapY|wfdY/debug.
+
+#ifdef DEBUG_LEVEL1
+	drvdbg = <bit mask of driver debug message control>
+#endif
+	wmm_ac_vo = <number of packets sent to device from WMM AcVo queue>
+	wmm_ac_vi = <number of packets sent to device from WMM AcVi queue>
+	wmm_ac_be = <number of packets sent to device from WMM AcBE queue>
+	wmm_ac_bk = <number of packets sent to device from WMM AcBK queue>
+	max_tx_buf_size = <maximum Tx buffer size>
+	tx_buf_size = <current Tx buffer size>
+	curr_tx_buf_size = <current Tx buffer size in FW>
+	ps_mode = <0/1, CAM mode/PS mode>
+#ifdef OPTIMIZED_PS
+	ps_state = <0/1/2/3, awake state/pre-sleep state/sleep-confirm state/sleep state>
+#else
+	ps_state = <0/1/2/3, full power state/awake state/pre-sleep state/sleep state>
+#endif
+#ifdef DEEP_SLEEP
+	is_deep_sleep = <0/1, not deep sleep state/deep sleep state>    // Only for STA
+#endif
+#if defined(HS_SUPPORT)
+	wakeup_dev_req = <0/1, wakeup device not required/required>
+#endif
+#if defined(HS_SUPPORT) || defined(DEEP_SLEEP)
+	wakeup_tries = <wakeup device count, cleared when device awake>
+#endif
+#ifdef HS_SUPPORT
+	hs_configured = <0/1, host sleep not configured/configured>
+	hs_activated = <0/1, extended host sleep not activated/activated>
+#endif
+	tx_pkts_queued = <number of Tx packets queued>
+#ifdef WMM_UAPSD
+	pps_uapsd_mode = <0/1, PPS/UAPSD mode disabled/enabled>     // Only for STA
+	sleep_pd = <sleep period in milliseconds>                   // Only for STA
+	qos_cfg = <WMM QoS info>                                    // Only for STA
+#endif
+	tx_lock_flag = <0/1, Tx lock flag>                          // Only for STA
+	port_open = <0/1, port open flag>                           // Only for STA
+	scan_processing = <0/1, scan processing flag>               // Only for STA
+	num_bridge_pkts = <number of bridged packets>               // Only for uAP
+	num_drop_pkts = <number of dropped packets>                 // Only for uAP
+	num_tx_timeout = <number of Tx timeout>
+	num_cmd_timeout = <number of timeout commands>
+	timeout_cmd_id = <command id of the last timeout command>
+	timeout_cmd_act = <command action of the last timeout command>
+	last_cmd_id = <command id of the last several commands sent to device>
+	last_cmd_act = <command action of the last several commands sent to device>
+	last_cmd_index = <0 based last command index>
+	last_cmd_resp_id = <command id of the last several command responses received from device>
+	last_cmd_resp_index = <0 based last command response index>
+	last_event = <event id of the last several events received from device>
+	last_event_index = <0 based last event index>
+	num_cmd_h2c_fail = <number of commands failed to send to device>
+	num_cmd_sleep_cfm_fail = <number of sleep confirm failed to send to device>
+	num_tx_h2c_fail = <number of data packets failed to send to device>
+#ifdef SDIO
+	num_cmdevt_c2h_fail = <number of commands/events failed to receive from device>
+	num_rx_c2h_fail = <number of data packets failed to receive from device>
+	num_int_read_fail = <number of interrupt read failures>
+	last_int_status = <last interrupt status>
+#endif
+	num_evt_deauth = <number of deauthenticated events received from device>        // Only for STA
+	num_evt_disassoc = <number of disassociated events received from device>        // Only for STA
+	num_evt_link_lost = <number of link lost events received from device>           // Only for STA
+	num_cmd_deauth = <number of deauthenticate commands sent to device>             // Only for STA
+	num_cmd_assoc_ok = <number of associate commands with success return>           // Only for STA
+	num_cmd_assoc_fail = <number of associate commands with failure return>         // Only for STA
+	cmd_sent = <0/1, send command resources available/sending command to device>
+	data_sent = <0/1, send data resources available/sending data to device>
+	mp_rd_bitmap = <SDIO multi-port read bitmap>
+	curr_rd_port = <SDIO multi-port current read port>
+	mp_wr_bitmap = <SDIO multi-port write bitmap>
+	curr_wr_port = <SDIO multi-port current write port>
+#ifdef PCIE
+	txbd_rdptr = <PCIE transmit read pointer>
+	txbd_wrptr = <PCIE transmit write pointer>
+	rxbd_rdptr = <PCIE recieve read pointer>
+	rxbd_wrptr = <PCIE recieve write pointer>
+	eventbd_rdptr = <PCIE event read pointer>
+	eventbd_wrptr = <PCIE event write pointer>
+#endif
+	cmd_resp_received = <0/1, no cmd response to process/response received and yet to process>
+	event_received = <0/1, no event to process/event received and yet to process>
+#ifdef USB
+	tx_cmd_urb_pending = <number of URB pending for cmd transmit>
+	tx_data_urb_pending = <number of URB pending for data transmit>
+#ifdef USB_CMD_DATA_EP
+	rx_cmd_urb_pending = <number of URB pending for cmd receive>
+#endif
+	rx_data_urb_pending = <number of URB pending for data receive>
+#endif
+	ioctl_pending = <number of ioctl pending>
+	tx_pending = <number of Tx packet pending>
+	rx_pending = <number of Rx packet pending>
+	lock_count = <number of lock used>
+	malloc_count = <number of malloc done>
+	mbufalloc_count = <number of mlan_buffer allocated>
+#ifdef PCIE
+	malloc_cons_count = <number of consistent malloc done>
+#endif
+	main_state = <current state of the main process>
+#ifdef SDIO_MMC_DEBUG
+	sdiocmd53w = <SDIO Cmd53 write status>
+	sdiocmd53r = <SDIO Cmd52 read status>
+#endif
+#if defined(USB_SUSPEND_RESUME) || defined(SDIO_SUSPEND_RESUME)
+	hs_skip_count = <number of skipped suspends>
+	hs_force_count = <number of forced suspends>
+#endif
+
+#if !defined(MLANUTL_LITE)
+#ifdef SDIO
+	Issue SDIO cmd52 read/write through proc.
+	Usage:
+		echo "sdcmd52rw=<func> <reg> [data]" > /proc/mwlan/adapterX/config
+	where the parameters:
+		func: The function number to use (0-7)
+		reg:  The address of the register
+		data: The value to write, read if the value is absent
+#ifdef SDIO_MMC
+		For SDIO MMC driver, only function 0 and WLAN function access is allowed.
+		And there is a limitation for function 0 write, only vendor specific CCCR
+		registers (0xf0 -0xff) are permiited.
+#endif
+	Examples:
+		echo "sdcmd52rw= 0 4" > /proc/mwlan/adapterX/config      # read func 0 address 4
+		cat /proc/mwlan/adapterX/config                          # display the register value
+		echo "sdcmd52rw= 1 3 0xf" > /proc/mwlan/adapterX/config  # write 0xf to func 1 address 3
+#endif
+#endif /* !defined(MLANUTL_LITE) */
+
+	Issue debug_dump command through proc.
+	Usage:
+		echo "debug_dump" > /proc/mwlan/adapterX/config
+
+	Examples:
+		echo "debug_dump" > /proc/mwlan/adapterX/config      # dump driver internal debug status.
+#ifdef DUMP_TO_PROC
+	To obtain fw dump or driver dump, use command:
+	        cat /proc/mwlan/adapter0/drv_dump > file_drv_dump     #save the drv dump to file_drv_dump
+	        cat /proc/mwlan/adapter0/fw_dump > file_fw_dump       #save the fw dump to file_fw_dump
+#ifdef DUAL_MAC
+            cat /proc/mwlan/adapter1/drv_dump > file_drv_dump_2   #save the adapter1 drv dump to file_drv_dump_2
+#endif
+#endif
+
+	Use dmesg or cat /var/log/debug to check driver debug messages.
+#ifdef CONFIG_X86
+	To log driver debug messages to file,
+	a) Edit /etc/syslog.conf, add one line "*.debug		/var/log/debug"
+	   on kernel 2.6.24 or later, edit /etc/rsyslog.conf instead
+	b) touch /var/log/debug (if the file doesn't exist)
+	c) service syslog restart
+	   on kernel 2.6.24 or later, service rsyslog restart
+#endif
+
+#ifdef DEBUG_LOG
+	To control the driver log buffer through the proc, the following command can be used.
+	Note: proc can only read at max kernel PAGE_SIZE - 1024 bytes.
+
+	Usage:
+		cat /proc/mwlan/adapterX/logctrl                         # To read driver log messages
+		echo "lock" > /proc/mwlan/adapterX/logctrl               # Lock the driver log buffer
+		echo "unlock" > /proc/mwlan/adapterX/logctrl             # Unlock the driver log buffer
+		echo "clear" > /proc/mwlan/adapterX/logctrl              # Clear the driver log buffer
+		echo "level=0xFF" > /proc/mwlan/adapterX/logctrl         # Set log buffer level to 0xFF
+#endif
+
+	Update /proc/sys/kernel/printk to change message log levels.
+	For example,
+	echo 6 > /proc/sys/kernel/printk    (messages with a higher priority than 6
+	                                     will be printed to the console)
+	echo 15 > /proc/sys/kernel/printk   (all messages will be printed to console)
+
+#ifdef FW_RELOAD
+4) FOR FW RELOAD
+    a) Enable parallel firmware download in driver parameter
+       insmod sdxxx.ko fw_serial=0
+
+    b) default fw name for parallel firmware download
+       sd8887_wlan_a2.bin
+
+    c) Trigger FW reload
+       echo "fw_reload=1" > /proc/mwlan/adapterX/config   trigger SDIO inband firmware reset and reload firmware
+       echo "fw_reload=2" > /proc/mwlan/adapterX/config   trigger firmware reload
+       echo "fw_reload=3" > /proc/mwlan/adapterX/config   set firmware reload flag in driver.
+#ifdef PCIE
+       echo "fw_reload=4" > /proc/mwlan/config   trigger PCIe FLR and reload firmware.
+       echo "fw_reload=6" > /proc/mwlan/config   trigger PCIe inband firmware reset and reload firmware.
+#endif
+
+    (Note: This feature will be supported on Robin3 and KF2.
+           For CAC-A2, it only work with the board which supports parallel fw download)
+#endif
+
+#ifdef RF_TEST_MODE
+5) FOR RF test mode commands:
+
+    Following commands are used to perform RF testing of the wifi chipset.
+    Please not that these test mode commands can only be issued while the
+    device is in disconnected state and the uAP BSS is inactive.
+    Normal wifi operations cannot be used on entering RF Test Mode.
+
+    Enter RF Test Mode:
+	echo "rf_test_mode=1" > /proc/mwlan/adapterX/config
+
+    Exit RF Test Mode:
+	echo "rf_test_mode=0" > /proc/mwlan/adapterX/config
+    Please note that after exiting the RF Test Mode, the FW needs to be
+    reset in order to use normal wifi connectivity.
+
+    To get the set of available RF Test Mode commands, currently set
+    parameters values for each command and the output,
+	cat /proc/mwlan/adapterX/config
+
+  Set Radio Mode
+    echo "radio_mode=<radioMode0> <radioMode1>"
+
+    Example: 2.4G[1x1]
+    echo "radio_mode=11 0" > /proc/mwlan/adapterX/config
+    5G[1x1]
+    echo "radio_mode=3 0" > /proc/mwlan/adapterX/config
+
+    Set Tx Antenna
+	For 1x1 chipsets, 1:Main, 2:Aux when antenna diversity is supported
+#ifdef STREAM_2X2
+	For 2x2 chipsets, 1:Path A, 2: Path B, 3: Path A+B
+			  Both Tx and Rx must be set to same antenna path
+#endif
+	echo "tx_antenna=1" > /proc/mwlan/adapterX/config
+
+    Set Rx Antenna
+	For 1x1 chipsets, 1:Main, 2:Aux when antenna diversity is supported
+#ifdef STREAM_2X2
+	For 2x2 chipsets, 1:Path A, 2:Path B, 3:Path A+B
+			  Both Tx and Rx must be set to same antenna path
+#endif
+	echo "rx_antenna=1" > /proc/mwlan/adapterX/config
+
+    Set RF band  (0:2G, 1:5G)
+	For 2G, channel will be reset to 6, while for 5G, to channel 36
+	echo "band=0" > /proc/mwlan/adapterX/config
+
+    Set RF bandwidth  (0:20MHz, 1:40MHz, 4:80MHz)
+	echo "bw=0" > /proc/mwlan/adapterX/config
+
+    Set RF channel
+	echo "channel=6" > /proc/mwlan/adapterX/config
+
+    Get and reset packet error rate
+	echo "get_and_reset_per" > /proc/mwlan/adapterX/config
+
+    Set Tx Power
+	This command will set power only if caldata is already loaded in the FW.
+	Power       (0 to 24 dBm)
+	Modulation  (0: CCK, 1:OFDM, 2:MCS)
+	Path ID     (0: PathA, 1:PathB, 2:PathA+B)
+	echo "tx_power=16 2 0" > /proc/mwlan/adapterX/config
+
+    Set MFG HE TB Tx to configure Trigger based TX reponse
+    Enable Tx   (0:disable, 1:enable)
+    Q num       (0-7 : TCQs 0-7, 17-20: AXQs 0-3)
+    AID         (Association ID as applicable)
+    AXQ MU Timer(to set the MU EDCA Timer for the Queue)
+    Tx Power    (-11 to 9 dBm)
+    echo "he_tb_tx=1 1 5 400 10" > /proc/mwlan/adapterX/config
+
+    Set Tx Continuous Mode
+	Start                 (0:disable, 1:enable)
+	Continuous Wave Mode  (0:disable, 1:enable)
+	Payload Pattern       (0 to 0xFFFFFFFF)
+	CS Mode               (Applicable only when continuous wave is disabled)
+	                      (0:disable, 1:enable)
+	Active SubChannel     (0:low, 1:upper, 3:both)
+	Tx Data Rate          (Rate Index corresponding to legacy/HT/VHT rates)
+
+	Example: To start continuous wave (tone) mode, first stop any ongoing
+	Tx and then start wave mode:
+	step1: echo "tx_continuous=0" > /proc/mwlan/adapterX/config
+	step2: echo "tx_continuous=1 1 0xAAA 0 3 7" > /proc/mwlan/adapterX/config
+
+	Example: To start continuous packet mode, first stop any ongoing Tx and
+	then start pkt mode:
+	step1: echo "tx_continuous=0" > /proc/mwlan/adapterX/config
+	step2: echo "tx_continuous=1 0 0xAAA 0 3 7" > /proc/mwlan/adapterX/config
+
+	stop:
+	echo "tx_continuous=0" > /proc/mwlan/adapterX/config
+
+    Set Tx Frame
+	Start                 (0:disable, 1:enable)
+	Tx Data Rate          (Rate Index corresponding to legacy/HT/VHT rates)
+	Payload Pattern       (0 to 0xFFFFFFFF)
+	Payload Length        (1 to 0x400)
+	Adjust Burst SIFS Gap (0:disable, 1:enable)
+	Burst SIFS in us      (0 to 255us)
+	Short Preamble        (0:disable, 1:enable)
+	Active SubChannel     (0:low, 1:upper, 3:both)
+	Short GI              (0:disable, 1:enable)
+	Adv Coding            (0:disable, 1:enable)
+	Beamforming           (0:disable, 1:enable)
+	GreenField Mode       (0:disable, 1:enable)
+	STBC                  (0:disable, 1:enable)
+	NumPkt                (Set to default value -1)
+	MaxPktExt             (Set to default value -1)
+	BeamChange            (Set to default value -1)
+	DCM                   (Set to default value -1)
+	Doppler               (Set to default value -1)
+	MidamblePeriod        (Set to default value -1)
+	QNum                  (Set to default value  1)
+	BSSID                 (xx:xx:xx:xx:xx:xx)
+
+	Example: To start Tx frame with duty cycle, first stop any ongoing Tx
+        and then start Tx frame:
+	echo "tx_frame=0" > /proc/mwlan/adapterX/config
+	echo "tx_frame=1 7 0xAAA 0x100 1 20 0 0 0 0 0 0 0 05:43:3f:c4:51" > /proc/mwlan/adapterX/config
+
+    Configure Trigger Frame
+    Example: To configure Trigger frame:
+    echo "trigger_frame=1 0 1 2 5484 0 256 0 0 2 1 0 0 0 1 60 1 0 65535 0 511 5 0 67 0 0 0 0 90 0 0 0 0"  > /proc/mwlan/adapter0/config
+
+    Example: To disable configuration of  Trigger frame:
+    echo "trigger_frame=0"  > /proc/mwlan/adapter0/config
+
+    For more information about trigger frame configuration as per supported BW(80MHz, 40MHz and 20MHz),
+    Please refer : config/trigger_frame_cfg.conf
+
+    Example : To start trigger frame transmission :
+    echo "rf_test_mode=1" > /proc/mwlan/adapter0/config
+    echo "radio_mode=3 0" > /proc/mwlan/adapterX/config
+    echo "bw=0" > /proc/mwlan/adapter0/config
+    echo "channel=36" > /proc/mwlan/adapter0/config
+    echo "trigger_frame=1 0 1 2 5484 0 256 0 0 0 1 0 0 0 1 60 1 0 65535 0 511 5 0 61 0 0 0 0 90 0 0 0 0"  > /proc/mwlan/adapter0/config
+    echo "tx_frame=1 0x1102 0xabababab 200" >/proc/mwlan/adapter0/config
+
+
+#endif
+
+#ifdef HS_SUPPORT
+6) Set host sleep parameters
+
+    hssetpara
+	This command is used to set host sleep parameters.
+    Example:
+        echo "hssetpara=2 0xff 0xc8 3 400" > /proc/mwlan/adapter0/config
+        echo "hssetpara=2 1 0xc8 3 400 " > /proc/mwlan/adapter0/config
+#endif
+
+7) For Antenna Diversity Command
+
+    antcfg
+        This command is used to set/get the mode of Tx/Rx path.
+
+        GET Command Format: cat /proc/mwlan/adapter0/config
+        SET Command Format: echo "antcfg=[m] [n] [o] [p]" > /proc/mwlan/adapter0/config
+
+#ifdef STREAM_2X2
+    For chip which support STREAM_2X2
+    where value of m is:
+        Bit 0   -- Tx Path A or Tx/Rx Path A if [n] is not provided
+        Bit 1   -- Tx Path B or Tx/Rx Path B if [n] is not provided
+        Bit 0-1 -- Tx Path A+B or Tx/Rx Path A+B if [n] is not provided
+#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) || defined(PCIE9097) || defined(SD9097) || defined(USB9097)||defined(SDIW624)||defined(PCIEIW624)||defined(USBIW624)
+        For 9097/9098/IW624, LOW BYTE for 2G setting
+        Bit 8   -- Tx Path A or Tx/Rx Path A if [n] is not provided
+        Bit 9   -- Tx Path B or Tx/Rx Path B if [n] is not provided
+        Bit 8-9 -- Tx Path A+B or Tx/Rx Path A+B if [n] is not provided
+        For 9097/9098/IW624, HIGH BYTE for 5G setting
+#endif
+    where value of n is:
+        Bit 0   -- Rx Path A
+        Bit 1   -- Rx Path B
+        Bit 0-1 -- Rx Path A+B
+#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) || defined(PCIE9097) || defined(SD9097) || defined(USB9097)||defined(SDIW624)||defined(PCIEIW624)||defined(USBIW624)
+        For 9097/9098/IW624, LOW BYTE for 2G setting
+        Bit 8   -- Rx Path A
+        Bit 8   -- Rx Path B
+        Bit 8-9 -- Rx Path A+B
+        For 9097/9098/IW624, HIGH BYTE for 5G setting
+#endif
+#ifdef ENABLE_802_116E
+    where value of o is:
+        For IW624, 6G setting
+        Bit 0   -- Tx Path A
+        Bit 1   -- Tx Path B
+        Bit 0-1 -- Tx Path A+B
+    where value of p is:
+        For IW624, 6G setting
+        Bit 0   -- Rx Path A
+        Bit 1   -- Rx Path B
+        Bit 0-1 -- Rx Path A+B
+#endif
+    The Tx path setting (m) is used for both Tx and Rx if Rx path (n) is not provided.
+
+    Examples:
+        cat /proc/mwlan/adapter0/config                         : Get Tx and Rx path
+        echo "antcfg=3" > /proc/mwlan/adapter0/config           : Set Tx and Rx path to A+B
+        echo "antcfg=1 3" > /proc/mwlan/adapter0/config         : Set Tx path to A and Rx path to A+B
+
+#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) || defined(PCIE9097) || defined(SD9097) || defined(USB9097)||defined(SDIW624)||defined(PCIEIW624)||defined(USBIW624)
+        echo "antcfg=0x103" > /proc/mwlan/adapter0/config           : Set Tx and Rx path to A+B on 2G and Tx and Rx path to A on 5G
+        echo "antcfg=0x103 0x103" > /proc/mwlan/adapter0/config     : Set Tx path to A+B and Rx path to A+B on 2G, and Tx and Rx path to A on 5G
+#endif
+#ifdef ENABLE_802_116E
+        echo "antcfg=0x103 0x103 2 2" > /proc/mwlan/adapter0/config   : Set both Tx and Rx path to A+B on 2G, both Tx and Rx path to A on 5G, both Tx and Rx path to B on 6G
+#endif
+
+#if defined(PCIE9098) || defined(SD9098) || defined(USB9098)
+        echo "antcfg=0x202" > /proc/mwlan/adapter0/config : Use 5GHz path B pin for 5G TX/RX and 2GHz path B pin for 2G TX/RX
+
+        On RD board connection is as follows :
+        5GHz path A pin -> AntA
+        5GHz path B pin -> AntB
+        2GHz path A pin -> AntB
+        2GHz path B pin -> AntA
+#endif
+
+#ifdef FEATURE_CONTROL
+    For chip which support SAD
+        where value of m is:
+        Bit 0   -- Tx/Rx antenna 1
+        Bit 1   -- Tx/Rx antenna 2
+        ...
+        0xFFFF  -- Tx/Rx antenna diversity
+
+        where value of n is:
+                SAD evaluate time interval, only be provided when m = 0xFFFF, default value is 6s(0x1770)
+
+    Examples:
+        cat /proc/mwlan/adapter0/config                                : Get Tx/Rx antenna mode
+        echo "antcfg=1" > /proc/mwlan/adapter0/config                : Set Tx/Rx antenna 1
+        echo "antcfg=0xFFFF" > /proc/mwlan/adapter0/config            : Set Tx/Rx antenna diversity
+        echo "antcfg=0xFFFF 0x1770" > /proc/mwlan/adapter0/config     : Set antenna evaluate time interval to 6s
+
+#endif
+
+#else
+    This command is used to set/get the mode of Tx/Rx antenna.If SAD is enabled,
+this command can also used to set SAD antenna evaluate time interval(antenna mode must
+ be antenna diversity when set SAD evaluate time interval).
+
+
+    where value of m is:
+        Bit 0   -- Tx/Rx antenna 1
+        Bit 1   -- Tx/Rx antenna 2
+        ...
+        0xFFFF  -- Tx/Rx antenna diversity
+
+        where value of n is:
+                if m = 0xFFFF, SAD evaluate time interval,default value is 6s(0x1770)
+
+    Examples:
+        cat /proc/mwlan/adapter0/config                                : Get Tx/Rx antenna mode
+        echo "antcfg=1" > /proc/mwlan/adapter0/config                : Set Tx/Rx antenna 1
+        echo "antcfg=0xFFFF" > /proc/mwlan/adapter0/config            : Set Tx/Rx antenna diversity
+        echo "antcfg=0xFFFF 0x1770" > /proc/mwlan/adapter0/config     : Set antenna evaluate time interval to 6s
+
+#endif
+
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/Makefile b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/Makefile
new file mode 100644
index 000000000..d0215711a
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/Makefile
@@ -0,0 +1,46 @@
+#
+# File : mlanconfig/Makefile
+#
+# Copyright 2008-2020 NXP
+
+# Path to the top directory of the mlandriver distribution
+PATH_TO_TOP = ../..
+
+# Determine how we should copy things to the install directory
+ABSPATH := $(filter /%, $(INSTALLDIR))
+RELPATH := $(filter-out /%, $(INSTALLDIR))
+INSTALLPATH := $(ABSPATH)
+ifeq ($(strip $(INSTALLPATH)),)
+INSTALLPATH := $(PATH_TO_TOP)/$(RELPATH)
+endif
+
+# Override CFLAGS for application sources, remove __ kernel namespace defines
+CFLAGS := $(filter-out -D__%, $(ccflags-y))
+# remove KERNEL include dir
+CFLAGS := $(filter-out -I$(KERNELDIR)%, $(CFLAGS))
+
+#
+# List of application executables to create
+#
+TARGETS := $(exectarget)
+
+#
+# Make target rules
+#
+
+# All rule compiles list of TARGETS using builtin program target from src rule
+all :
+$(exectarget): $(libobjs)
+	$(CC) $(CFLAGS) $(libobjs) -o $(exectarget)
+
+# Update any needed TARGETS and then copy to the install path
+build install: $(TARGETS)
+	@cp -rf config $(INSTALLPATH)
+
+clean:
+	@rm -f $(exectarget)
+	@rm -f *.o
+
+distclean: clean
+	@rm -f *~ core
+	@rm -f tags
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V1_8801.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V1_8801.conf
new file mode 100644
index 000000000..c67354764
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V1_8801.conf
@@ -0,0 +1,15 @@
+#       File : ed_mac_ctrl_V1_8801.conf
+#
+#   ./mlanutl mlan0 hostcmd config/ed_mac_ctrl_V1_8801.conf ed_mac_ctrl
+#
+#
+## Set Energy Detect Threshold for EU Adaptivity test
+
+ed_mac_ctrl={
+        CmdCode=0x0124          #Command code, DO NOT change this line
+        Enable:2=0x1            # 0       - disable EU adaptivity
+                                # 1       - enable EU adaptivity
+
+        Offset:2=0x1b           # 0       - Default Energy Detect threshold
+                                #offset value range: 0x80 to 0x7F
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8987.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8987.conf
new file mode 100644
index 000000000..af2f2da3b
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8987.conf
@@ -0,0 +1,23 @@
+#       File : ed_mac_ctrl_V3_8987.conf
+#
+#   ed_mac_ctrl_v3 is used for 88W8997, 88W8987, 88W8977
+#   ./mlanutl mlan0 hostcmd config/ed_mac_ctrl_V3_8987.conf ed_mac_ctrl_v3
+#
+## Set Energy Detect Threshold for EU Adaptivity test
+
+ed_mac_ctrl_v3={
+        CmdCode=0x0130                 #Command code, DO NOT change this line
+        ed_ctrl_2g.enable:2=0x1        # 0       - disable EU adaptivity for 2.4GHz band
+                                       # 1       - enable EU adaptivity for 2.4GHz band
+
+        ed_ctrl_2g.offset:2=0x6        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_5g.enable:2=0x1        # 0       - disable EU adaptivity for 5GHz band
+                                       # 1       - enable EU adaptivity for 5GHz band
+
+        ed_ctrl_5g.offset:2=0x6        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_txq_lock:4=0xFF        #DO NOT Change this line
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8997.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8997.conf
new file mode 100644
index 000000000..6c86bd706
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_8997.conf
@@ -0,0 +1,23 @@
+#       File : ed_mac_ctrl_V3_8997.conf
+#
+#   ed_mac_ctrl_v3 is used for 88W8997, 88W8987, 88W8977
+#   ./mlanutl mlan0 hostcmd config/ed_mac_ctrl_V3_8997.conf ed_mac_ctrl_v3
+#
+## Set Energy Detect Threshold for EU Adaptivity test
+
+ed_mac_ctrl_v3={
+        CmdCode=0x0130                 #Command code, DO NOT change this line
+        ed_ctrl_2g.enable:2=0x1        # 0       - disable EU adaptivity for 2.4GHz band
+                                       # 1       - enable EU adaptivity for 2.4GHz band
+
+        ed_ctrl_2g.offset:2=0x0        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_5g.enable:2=0x1        # 0       - disable EU adaptivity for 5GHz band
+                                       # 1       - enable EU adaptivity for 5GHz band
+
+        ed_ctrl_5g.offset:2=0x4        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_txq_lock:4=0xFF        #DO NOT Change this line
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_909x.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_909x.conf
new file mode 100755
index 000000000..b0e18b507
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/ed_mac_ctrl_V3_909x.conf
@@ -0,0 +1,23 @@
+#       File : ed_mac_ctrl_V3_909x.conf
+#
+#   ed_mac_ctrl_v3 is used for 88W9098, 88W9097
+#   ./mlanutl mlan0 hostcmd config/ed_mac_ctrl_V3_909x.conf ed_mac_ctrl_v3
+#
+## Set Energy Detect Threshold for EU Adaptivity test
+
+ed_mac_ctrl_v3={
+        CmdCode=0x0130                 #Command code, DO NOT change this line
+        ed_ctrl_2g.enable:2=0x1        # 0       - disable EU adaptivity for 2.4GHz band
+                                       # 1       - enable EU adaptivity for 2.4GHz band
+
+        ed_ctrl_2g.offset:2=0x8        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_5g.enable:2=0x1        # 0       - disable EU adaptivity for 5GHz band
+                                       # 1       - enable EU adaptivity for 5GHz band
+
+        ed_ctrl_5g.offset:2=0x8        # 0       - Default Energy Detect threshold
+                                       #offset value range: 0x80 to 0x7F
+
+        ed_ctrl_txq_lock:4=0x1e00FF    #DO NOT Change this line
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8987.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8987.conf
new file mode 100644
index 000000000..aef78cbd4
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8987.conf
@@ -0,0 +1,537 @@
+#       File : txpwrlimit_cfg.conf
+## Get CFG data for Tx power limitation
+txpwrlimit_2g_cfg_get={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x00          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Get Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+}
+
+
+txpwrlimit_5g_cfg_get_sub0={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x10          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Get Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+}
+
+
+txpwrlimit_5g_cfg_get_sub1={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x11          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Get Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+}
+
+
+txpwrlimit_5g_cfg_get_sub2={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x12          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Get Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+}
+
+
+txpwrlimit_5g_cfg_get_sub3={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x13          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Get Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+}
+
+## Set CFG data for Tx power limitation
+##
+## TLVStartFreq: Starting Frequency of the band for this channel
+##                 2407, 2414 or 2400 for 2.4 GHz
+##                 5000
+##                 4000
+## TLVChanWidth: Channel Width
+##                 20
+## TLVChanNum  : Channel Number
+## TLVPwr[]    : ModulationGroup
+##                 0: CCK (1,2,5.5,11 Mbps)
+##                 1: OFDM (6,9,12,18 Mbps)
+##                 2: OFDM (24,36 Mbps)
+##                 3: OFDM (48,54 Mbps)
+##                 4: HT20 (0,1,2)
+##                 5: HT20 (3,4)
+##                 6: HT20 (5,6,7)
+##                 7: HT40 (0,1,2)
+##                 8: HT40 (3,4)
+##                 9: HT40 (5,6,7)
+##                 10: VHT_QAM256 (MCS8)
+##                 11: VHT_40_QAM256 (MCS8,9)
+##                 12: VHT_80_PSK (MCS0,1,2)
+##                 13: VHT_80_QAM16 (MCS3,4)
+##                 14: VHT_80_QAM64 (MCS5,6,7)
+##                 15: VHT_80_QAM256 (MCS8,9)
+##               Power Limit in dBm
+##
+## For 40MHz modulation groups, specify same Tx power value for a set of
+## two consecutive channel frequencies
+## Valid channel sets:
+##      (36, 40), (44, 48), (52, 56), (60, 64)
+##      (100, 104), (108, 112), (116, 120), (124, 128), (132, 136), (140, 144)
+##      (149, 153), (157, 161)
+##
+## For 80MHz modulation groups, specify same Tx power value for a set of
+## four consecutive channel frequencies
+## Valid channel sets:
+##      (36, 40, 44, 48), (52, 56, 60, 64)
+##      (100, 104, 108, 112), (116, 120, 124, 128), (132, 136, 140, 144)
+##      (149, 153, 157, 161)
+
+## 2G Tx power limit CFG
+txpwrlimit_2g_cfg_set={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        RSVD:2=0                # do NOT change this line
+
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Configure Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=1
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=2
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=3
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=4
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=5
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=6
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=9
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=10
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:24='0,18,1,18,2,16,3,14,4,18,5,16,6,14,7,18,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:24='0,16,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=13
+            TLVPwr:24='0,16,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,16,11,16'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2414
+            TLVChanWidth:1=20
+            TLVChanNum:1=14
+            TLVPwr:24='0,12,1,12,2,12,3,12,4,12,5,12,6,12,7,12,8,12,9,12,10,12,11,12'
+        }
+}
+
+## 5G Tx power limit CFG
+txpwrlimit_5g_cfg_set={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        RSVD:2=0                # do NOT change this line
+
+        ChanTRPC.TlvType:2=0x0249
+        ChanTRPC.TlvLength:2={  # Configure Tx Power Values for a particular antenna
+            TLVAntNum:1=0       # Antenna Num: 0 - Both, 1 - Main, 2 - Aux
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=36
+            TLVPwr:32='0,0,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=40
+            TLVPwr:32='0,0,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=44
+            TLVPwr:32='0,0,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=48
+            TLVPwr:32='0,0,1,16,2,16,3,14,4,16,5,16,6,14,7,16,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=52
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=56
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=60
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=64
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=100
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=104
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=108
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=112
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=116
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=120
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=124
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=128
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=132
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=136
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=140
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=144
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=149
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=153
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=157
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=161
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=165
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=183
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=184
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=185
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=187
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=188
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=189
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=192
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=196
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=16
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=34
+            TLVPwr:32='0,0,1,17,2,16,3,14,4,17,5,16,6,14,7,17,8,16,9,14,10,15,11,14,12,15,13,15,14,14,15,13'
+        }
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8997.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8997.conf
new file mode 100644
index 000000000..0f3b71a53
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_8997.conf
@@ -0,0 +1,621 @@
+#       File : txpwrlimit_cfg.conf
+## Get CFG data for Tx power limitation
+txpwrlimit_2g_cfg_get={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x00          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub0={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x10          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub1={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x11          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub2={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x12          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub3={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x13          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+## Set CFG data for Tx power limitation
+##
+## TLVStartFreq: Starting Frequency of the band for this channel
+##                 2407, 2414 or 2400 for 2.4 GHz
+##                 5000
+##                 4000
+## TLVChanWidth: Channel Width
+##                 20
+## TLVChanNum  : Channel Number
+## TLVPwr[]    : ModulationGroup
+##                 0: CCK (1,2,5.5,11 Mbps)
+##                 1: OFDM (6,9,12,18 Mbps)
+##                 2: OFDM (24,36 Mbps)
+##                 3: OFDM (48,54 Mbps)
+##                 4: HT20 (MCS0,1,2)
+##                 5: HT20 (MCS3,4)
+##                 6: HT20 (MCS5,6,7)
+##                 7: HT40 (MCS0,1,2)
+##                 8: HT40 (MCS3,4)
+##                 9: HT40 (MCS5,6,7)
+##                 10: HT2_20 (MCS8,9,10)
+##                 11: HT2_20 (MCS11,12)
+##                 12: HT2_20 (MCS13,14,15)
+##                 13: HT2_40 (MCS8,9,10)
+##                 14: HT2_40 (MCS11,12)
+##                 15: HT2_40 (MCS13,14,15)
+##                 16: VHT_QAM256 (MCS8)
+##                 17: VHT_40_QAM256 (MCS8,9)
+##                 18: VHT_80_PSK (MCS0,1,2)
+##                 19: VHT_80_QAM16 (MCS3,4)
+##                 20: VHT_80_QAM64 (MCS5,6,7)
+##                 21: VHT_80_QAM256 (MCS8,9)
+##                 22: VHT2_20_QAM256 (MCS8,9)
+##                 23: VHT2_40_QAM256 (MCS8,9)
+##                 24: VHT2_80_PSK (MCS0, 1, 2)
+##                 25: VHT2_80_QAM16 (MCS3,4)
+##                 26: VHT2_80_QAM64 (MCS5,6,7)
+##                 27: VHT2_80_QAM256 (MCS8,9)
+##               Power Limit in dBm
+
+## For 40MHz modulation groups, specify same Tx power value for a set of
+## two consecutive channel frequencies
+## Valid channel sets:
+##      (36, 40), (44, 48), (52, 56), (60, 64)
+##      (100, 104), (108, 112), (116, 120), (124, 128), (132, 136), (140, 144)
+##      (149, 153), (157, 161)
+##
+## For 80MHz modulation groups, specify same Tx power value for a set of
+## four consecutive channel frequencies
+## Valid channel sets:
+##      (36, 40, 44, 48), (52, 56, 60, 64)
+##      (100, 104, 108, 112), (116, 120, 124, 128), (132, 136, 140, 144)
+##      (149, 153, 157, 161)
+
+
+## 2G subband0 Tx power limit CFG
+txpwrlimit_2g_cfg_set={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=1
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=2
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=3
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=4
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=5
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=6
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=9
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=10
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=13
+            TLVPwr:32='0,17,1,15,2,15,3,13,4,15,5,15,6,13,7,15,8,15,9,13,10,15,11,15,12,15,13,15,14,15,15,15'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=14
+            TLVPwr:32='0,12,1,12,2,12,3,12,4,12,5,12,6,12,7,12,8,12,9,12,10,12,11,12,12,12,13,12,14,12,15,12'
+        }
+}
+
+## 5G subband1 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub0={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=36
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=40
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=44
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=48
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=52
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=56
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=60
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=64
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+}
+
+## 5G subband2 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub1={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=100
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=104
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=108
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=112
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=116
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=120
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=124
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=128
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=132
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=136
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=140
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=144
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+}
+
+
+## 5G subband3 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub2={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=149
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=153
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=157
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=161
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=165
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+}
+
+
+## 5G subband4 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub3={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=183
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=184
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=185
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=187
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=188
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=189
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=192
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=196
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=16
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=34
+            TLVPwr:56='0,17,1,15,2,15,3,11,4,15,5,15,6,11,7,15,8,15,9,11,10,15,11,15,12,14,13,15,14,15,15,14,16,11,17,11,18,13,19,13,20,10,21,10,22,11,23,11,24,13,25,13,26,12,27,10'
+        }
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_9098.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_9098.conf
new file mode 100755
index 000000000..20f0ea5cc
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/txpwrlimit_cfg_9098.conf
@@ -0,0 +1,617 @@
+#       File : txpwrlimit_cfg.conf
+## Get CFG data for Tx power limitation
+txpwrlimit_2g_cfg_get={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x00          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub0={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x10          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub1={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x11          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub2={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x12          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+
+txpwrlimit_5g_cfg_get_sub3={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=0              # 0 - GET
+        SubBand:2=0x13          # 0x00 2G subband  (2.4G: channel 1-14)
+                                # 0x10 5G subband0 (5G: channel 36,40,44,48,
+                                #                               52,56,60,64)
+                                # 0x11 5G subband1 (5G: channel 100,104,108,112,
+                                #                               116,120,124,128,
+                                #                               132,136,140,144)
+                                # 0x12 5G subband2 (5G: channel 149,153,157,161,165,172)
+                                # 0x13 5G subband3 (5G: channel 183,184,185,187,188,
+                                #                               189, 192,196;
+                                #                   5G: channel 7,8,11,12,16,34)
+}
+
+## Set CFG data for Tx power limitation
+##
+## TLVStartFreq: Starting Frequency of the band for this channel
+##                 2407, 2414 or 2400 for 2.4 GHz
+##                 5000
+##                 4000
+## TLVChanWidth: Channel Width
+##                 20
+## TLVChanNum  : Channel Number
+## TLVPwr[]    : ModulationGroup
+##                 0: CCK (1,2,5.5,11 Mbps)
+##                 1: OFDM (6,9,12,18 Mbps)
+##                 2: OFDM (24,36 Mbps)
+##                 3: OFDM (48,54 Mbps)
+##                 4: HT20 (MCS0,1,2)
+##                 5: HT20 (MCS3,4)
+##                 6: HT20 (MCS5,6,7)
+##                 7: HT40 (MCS0,1,2)
+##                 8: HT40 (MCS3,4)
+##                 9: HT40 (MCS5,6,7)
+##                 10: HT2_20 (MCS8,9,10)
+##                 11: HT2_20 (MCS11,12)
+##                 12: HT2_20 (MCS13,14,15)
+##                 13: HT2_40 (MCS8,9,10)
+##                 14: HT2_40 (MCS11,12)
+##                 15: HT2_40 (MCS13,14,15)
+##                 16: VHT_QAM256 (MCS8)
+##                 17: VHT_40_QAM256 (MCS8,9)
+##                 18: VHT_80_PSK (MCS0,1,2)
+##                 19: VHT_80_QAM16 (MCS3,4)
+##                 20: VHT_80_QAM64 (MCS5,6,7)
+##                 21: VHT_80_QAM256 (MCS8,9)
+##                 22: VHT2_20_QAM256 (MCS8,9)
+##                 23: VHT2_40_QAM256 (MCS8,9)
+##                 24: VHT2_80_PSK (MCS0, 1, 2)
+##                 25: VHT2_80_QAM16 (MCS3,4)
+##                 26: VHT2_80_QAM64 (MCS5,6,7)
+##                 27: VHT2_80_QAM256 (MCS8,9)
+##                 28: HE_20_QAM256 (MCS8,9)
+##                 29: HE_20_QAM1024 (MCS10,11)
+##                 30: HE_40_QAM1024 (MCS10,11)
+##                 31: HE_80_QAM1024 (MCS10,11)
+##                 32: HE2_20_QAM256 (MCS8,9)
+##                 33: HE2_20_QAM1024 (MCS10,11)
+##                 34: HE2_40_QAM1024 (MCS10,11)
+##                 35: HE2_80_QAM1024 (MCS10,11)
+##               Power Limit in dBm
+##
+## Note: For KF, add VHT 20/40/80 1SS/2SS mod group.
+
+## 2G subband0 Tx power limit CFG
+txpwrlimit_2g_cfg_set={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=1
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=2
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=3
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=4
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=5
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=6
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=9
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=10
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=13
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=2407
+            TLVChanWidth:1=20
+            TLVChanNum:1=14
+            TLVPwr:72='0,10,1,10,2,10,3,10,4,10,5,10,6,10,7,10,8,10,9,10,10,10,11,10,12,10,13,10,14,10,15,10,16,0,17,0,18,0,19,0,20,0,21,0,22,0,23,0,24,0,25,0,26,0,27,0,28,10,29,10,30,10,31,0,32,10,33,10,34,10,35,0'
+        }
+}
+
+
+## 5G subband1 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub0={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=36
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,18,10,20,11,20,12,18,13,20,14,20,15,18,16,17,17,17,18,20,19,19,20,17,21,16,22,17,23,17,24,20,25,19,26,17,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=40
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,18,10,20,11,20,12,18,13,20,14,20,15,18,16,17,17,17,18,20,19,19,20,17,21,16,22,17,23,17,24,20,25,19,26,17,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=44
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,18,10,20,11,20,12,18,13,20,14,20,15,18,16,18,17,17,18,20,19,19,20,17,21,16,22,18,23,17,24,20,25,19,26,17,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=48
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,18,10,20,11,20,12,18,13,20,14,20,15,18,16,18,17,17,18,20,19,19,20,17,21,16,22,18,23,17,24,20,25,19,26,17,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=52
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,19,10,20,11,20,12,18,13,20,14,20,15,19,16,18,17,17,18,19,19,19,20,18,21,17,22,18,23,17,24,19,25,19,26,18,27,17,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=56
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,19,10,20,11,20,12,18,13,20,14,20,15,19,16,18,17,17,18,19,19,19,20,18,21,17,22,18,23,17,24,19,25,19,26,18,27,17,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=60
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,19,10,20,11,20,12,18,13,20,14,20,15,19,16,18,17,17,18,19,19,19,20,18,21,17,22,18,23,17,24,19,25,19,26,18,27,17,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+ ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=64
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,20,5,20,6,18,7,20,8,20,9,19,10,20,11,20,12,18,13,20,14,20,15,19,16,18,17,17,18,19,19,19,20,18,21,17,22,18,23,17,24,19,25,19,26,18,27,17,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+}
+
+## 5G subband2 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub1={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=100
+            TLVPwr:72='0,0,1,20,2,20,3,20,4,18,5,18,6,19,7,18,8,18,9,18,10,18,11,18,12,19,13,18,14,18,15,18,16,18,17,16,18,18,19,19,20,18,21,16,22,18,23,16,24,18,25,19,26,18,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=104
+            TLVPwr:72='0,0,1,20,2,20,3,20,4,18,5,18,6,18,7,18,8,18,9,18,10,18,11,18,12,18,13,18,14,18,15,18,16,18,17,16,18,18,19,19,20,18,21,16,22,18,23,16,24,18,25,19,26,18,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=108
+            TLVPwr:72='0,0,1,20,2,20,3,20,4,18,5,18,6,19,7,18,8,18,9,17,10,18,11,18,12,19,13,18,14,18,15,17,16,18,17,16,18,18,19,19,20,18,21,16,22,18,23,16,24,18,25,19,26,18,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=112
+            TLVPwr:72='0,0,1,20,2,20,3,20,4,18,5,18,6,19,7,18,8,18,9,17,10,18,11,18,12,19,13,18,14,18,15,17,16,17,17,16,18,18,19,19,20,18,21,16,22,17,23,16,24,18,25,19,26,18,27,16,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=116
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,18,9,17,10,18,11,18,12,18,13,18,14,18,15,17,16,16,17,15,18,18,19,18,20,17,21,15,22,16,23,15,24,18,25,18,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=120
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,18,9,17,10,18,11,18,12,18,13,18,14,18,15,17,16,17,17,15,18,18,19,18,20,17,21,15,22,17,23,15,24,18,25,18,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=124
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,18,9,18,10,18,11,18,12,18,13,18,14,18,15,18,16,17,17,15,18,18,19,18,20,17,21,15,22,17,23,15,24,18,25,18,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=128
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,18,9,18,10,18,11,18,12,18,13,18,14,18,15,18,16,17,17,15,18,18,19,18,20,17,21,15,22,17,23,15,24,18,25,18,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=132
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,17,9,18,10,18,11,18,12,18,13,18,14,17,15,18,16,16,17,15,18,18,19,18,20,18,21,15,22,16,23,15,24,18,25,18,26,18,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=136
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,17,9,18,10,18,11,18,12,18,13,18,14,17,15,18,16,17,17,15,18,18,19,18,20,18,21,15,22,17,23,15,24,18,25,18,26,18,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=140
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,17,9,17,10,18,11,18,12,18,13,18,14,17,15,17,16,18,17,16,18,18,19,18,20,18,21,15,22,18,23,16,24,18,25,18,26,18,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=144
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,18,6,18,7,18,8,17,9,17,10,18,11,18,12,18,13,18,14,17,15,17,16,18,17,16,18,18,19,18,20,18,21,15,22,18,23,16,24,18,25,18,26,18,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+}
+
+
+## 5G subband3 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub2={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this member in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=149
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,18,7,18,8,18,9,18,10,18,11,19,12,18,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=153
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=157
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=161
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=165
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+}
+
+
+## 5G subband4 Tx power limit CFG
+txpwrlimit_5g_cfg_set_sub3={
+        CmdCode=0x00fb          # do NOT change this line
+        Action:2=1              # 1 - SET
+        SubBand:2=0             # do NOT use this in set cmd
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=183
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=184
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=185
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=187
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=188
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=189
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=192
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=4000
+            TLVChanWidth:1=20
+            TLVChanNum:1=196
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=7
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=8
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=11
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=12
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=16
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+
+
+        ChanTRPC.TlvType:2=0x0189
+        ChanTRPC.TlvLength:2={
+            TLVStartFreq:2=5000
+            TLVChanWidth:1=20
+            TLVChanNum:1=34
+            TLVPwr:72='0,0,1,20,2,20,3,19,4,18,5,19,6,19,7,18,8,18,9,18,10,18,11,19,12,19,13,18,14,18,15,18,16,17,17,17,18,18,19,19,20,17,21,15,22,17,23,17,24,18,25,19,26,17,27,15,28,5,29,5,30,5,31,5,32,5,33,5,34,5,35,5'
+        }
+ }
+
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/wifi_mod_para.conf b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/wifi_mod_para.conf
new file mode 100644
index 000000000..6ea3e5988
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanconfig/config/wifi_mod_para.conf
@@ -0,0 +1,178 @@
+# Not matter how many spaces or tabs are inserted in a line,
+# components and ending format must be exactly same as given
+# example:
+#
+# 	<card_type>[_<block_id>] = {
+# 		key=value
+# 	}
+#
+# card_type	: 8XXX			          (mandatory)
+# block_id	: configuration block id          (optional )
+# key		: module parameter name
+# value		: value for module parameter
+#		for string value, no need to add ""
+#
+# card_type supported: 8887/8897/8997/8977/8987/9098
+# block_id: support same chipset with
+# different module parameter.
+# For example to support mutiple SD8997 cards, usr can
+# specify the configuration block id number [0 - 9], if not
+# specified, it is taken as 0 by default.
+#
+# debug related module parameters could not be set via module
+# configure file, ex. drvdbg could not be set in this file
+#
+# line started with "#" will be ignored
+# refer to the USB8997_1 for parameters that could be set in
+# this configuration file, and set the corresponding value
+# according to your real needs
+
+SD8997 = {
+	cfg80211_wext=0xf
+	wfd_name=p2p
+	max_vir_bss=1
+	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+	drv_mode=7
+}
+
+#SD8997_1 = {
+#       cfg80211_wext=0xf
+#       wfd_name=wfd0
+#       max_vir_bss=1
+#       cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#       drv_mode=5
+#}
+
+#SD8887 = {
+#	cfg80211_wext=0xf
+#	wfd_name=p2p
+#	max_vir_bss=1
+#	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#	drv_mode=7
+#}
+
+#SD8897 = {
+#	cfg80211_wext=0xf
+#	wfd_name=p2p
+#	max_vir_bss=1
+#	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#	drv_mode=7
+#}
+
+#SD8977 = {
+#	cfg80211_wext=0xf
+#	wfd_name=p2p
+#	max_vir_bss=1
+#	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#	drv_mode=7
+#}
+
+#SD8987 = {
+#	cfg80211_wext=0xf
+#	wfd_name=p2p
+#	max_vir_bss=1
+#	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#	drv_mode=7
+#}
+
+USB8997 = {
+	cfg80211_wext=0xf
+	wfd_name=p2p
+	max_vir_bss=1
+	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+	drv_mode=7
+}
+
+PCIE8997 = {
+	cfg80211_wext=0xf
+	wfd_name=p2p
+	max_vir_bss=1
+	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+	drv_mode=7
+}
+
+PCIE9098_0 = {
+	cfg80211_wext=0xf
+	wfd_name=p2p
+	max_vir_bss=1
+	cal_data_cfg=none
+	drv_mode=7
+	mac_addr=00:50:43:20:12:34
+}
+
+PCIE9098_1 = {
+	cfg80211_wext=0xf
+	wfd_name=p2p
+	max_vir_bss=1
+	cal_data_cfg=none
+	drv_mode=7
+	mac_addr=00:50:43:20:52:56
+}
+
+#USB8997 = {
+#	hw_test=0
+#	fw_name="nxp/usbusb8997_combo_v4.bin"
+#	req_fw_nowait=1
+#	fw_reload=3
+#	fw_serial=1
+#	mac_addr=00:50:43:22:1e:3d
+#	mfg_mode=0
+#	drv_mode=0x5
+#	max_sta_bss=1
+#	sta_name=wlan
+#	max_uap_bss=1
+#	uap_name=uap
+#	wfd_name=p2p
+#	max_vir_bss=1
+#	max_mpl_bss=1
+#	nan_name=nan
+#	max_nan_bss=1
+#	max_11p_bss=1
+#	auto_ds=0
+#	ps_mode=1
+#	max_tx_buf=4096
+#	intmode=0
+#	gpiopin=0
+#	pm_keep_power=0
+#	shutdown_hs=1
+#	cfg_11d=1
+#	start_11ai_scan=0
+#	oob_mode=0
+#	sdio_pd=1
+#	cal_data_cfg=nxp/WlanCalData_ext_8997_QFN_TB.conf
+#	txpwrtlimit_cfg=nxp/txpwr_limit.conf
+#	cntry_txpwrt=0
+#	init_hostcmd_cfg=nxp/init_hostcmd_cfg.conf
+#	minicard_pwrup=0
+#	cfg80211_wext=0xf
+#	skip_fwdnld=0
+#	wq_sched_prio=0
+#	wq_sched_policy=0
+#	rx_work=1
+#	aggrctrl=1
+#	usb_aggr=1
+#	pcie_int_mode=1
+#	low_power_mode_enable=1
+#	wakelock_timeout=10
+#	dev_cap_mask=0xffffffff
+#	sdio_rx_aggr=1
+#	pmic=1
+#	antcfg=0
+#	uap_oper_ctrl=0
+#	hs_wake_interval=400
+#	indication_gpio=0xff
+#	disconnect_on_suspend=0
+#	hs_mimo_switch=1
+#	indrstcfg=0xffffffff
+#	fixed_beacon_buffer=0
+#	GoAgeoutTime=0
+#	gtk_rekey_offload=1
+#	multi_dtim=0
+#	inact_tmo=0
+#	usb_fw_option=1
+#	napi=1
+#	dfs_offload=1
+#	cfg80211_drcs=1
+#	drcs_chantime_mode=0
+#	reg_alpha2=US
+#}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Android.mk b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Android.mk
new file mode 100644
index 000000000..f746a6ddc
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Android.mk
@@ -0,0 +1,54 @@
+# Copyright 2021 NXP
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+##      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(my-dir)
+include $(CLEAR_VARS)
+
+# Enable DEBUG Level
+DEBUG_LEVEL=1
+ifeq ($(DEBUG_LEVEL),1)
+LOCAL_CFLAGS += -DDEBUG_LEVEL1
+endif
+ifeq ($(DEBUG_LEVEL),2)
+LOCAL_CFLAGS += -DDEBUG_LEVEL1
+LOCAL_CFLAGS += -DDEBUG_LEVEL2
+endif
+# Enable STA mode support
+CONFIG_STA_SUPPORT=y
+ifeq ($(CONFIG_STA_SUPPORT),y)
+LOCAL_CFLAGS += -DSTA_SUPPORT
+endif
+# Enable uAP mode support
+CONFIG_UAP_SUPPORT=y
+ifeq ($(CONFIG_UAP_SUPPORT),y)
+LOCAL_CFLAGS += -DUAP_SUPPORT
+endif
+CONFIG_WIFI_DIRECT_SUPPORT=y
+ifeq ($(CONFIG_WIFI_DIRECT_SUPPORT), y)
+LOCAL_CFLAGS += -DWIFI_DIRECT_SUPPORT
+endif
+
+# if 64bit Android is used (e.g. PXA1928)
+# Please turn on following compiler flag
+CONFIG_USERSPACE_32BIT_OVER_KERNEL_64BIT=y
+ifeq ($(CONFIG_USERSPACE_32BIT_OVER_KERNEL_64BIT), y)
+LOCAL_CFLAGS += -DUSERSPACE_32BIT_OVER_KERNEL_64BIT
+endif
+
+LOCAL_MODULE := mlanutl
+LOCAL_VENDOR_MODULE := true
+OBJS = mlanutl.c
+LOCAL_SRC_FILES := $(OBJS)
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_EXECUTABLE)
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Makefile b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Makefile
new file mode 100644
index 000000000..46977f91b
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/Makefile
@@ -0,0 +1,56 @@
+# File : mlanutl/Makefile
+#
+# Copyright 2011-2020 NXP
+
+# Path to the top directory of the wlan distribution
+PATH_TO_TOP = ../..
+
+# Determine how we should copy things to the install directory
+ABSPATH := $(filter /%, $(INSTALLDIR))
+RELPATH := $(filter-out /%, $(INSTALLDIR))
+INSTALLPATH := $(ABSPATH)
+ifeq ($(strip $(INSTALLPATH)),)
+INSTALLPATH := $(PATH_TO_TOP)/$(RELPATH)
+endif
+
+# Override CFLAGS for application sources, remove __ kernel namespace defines
+CFLAGS := $(filter-out -D__%, $(ccflags-y))
+# remove KERNEL include dir
+CFLAGS := $(filter-out -I$(KERNELDIR)%, $(CFLAGS))
+
+
+#CFLAGS += -DAP22 -fshort-enums
+CFLAGS += -Wall
+#ECHO = @
+ifeq (,$(findstring ANDROID_KERNEL, $(CFLAGS)))
+LIBS=-lrt
+endif
+
+.PHONY: default tags all
+
+OBJECTS = mlanutl.o
+HEADERS = mlanutl.h
+
+
+
+exectarget=mlanutl
+TARGET := $(exectarget)
+
+build default: $(TARGET)
+	@cp -f $(TARGET) $(INSTALLPATH)
+
+all : tags default
+
+$(TARGET): $(OBJECTS) $(HEADERS)
+	$(ECHO)$(CC) $(LIBS) -o $@ $(OBJECTS)
+
+%.o: %.c $(HEADERS)
+	$(ECHO)$(CC) $(CFLAGS) -c -o $@ $<
+
+tags:
+	ctags -R -f tags.txt
+
+distclean clean:
+	$(ECHO)$(RM) $(OBJECTS) $(TARGET)
+	$(ECHO)$(RM) tags.txt
+
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.c
new file mode 100644
index 000000000..8cee774b6
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.c
@@ -0,0 +1,5052 @@
+/** @file  mlanutl.c
+ *
+ * @brief Program to control parameters in the mlandriver
+ *
+ *
+ * Copyright 2011-2021 NXP
+ *
+ * This software file (the File) is distributed by NXP
+ * under the terms of the GNU General Public License Version 2, June 1991
+ * (the License).  You may use, redistribute and/or modify the File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/************************************************************************
+Change log:
+     11/04/2011: initial version
+************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/time.h>
+#include <getopt.h>
+
+#include <sys/socket.h>
+#include <linux/netlink.h>
+#include <linux/if.h>
+#include <sys/stat.h>
+#include <net/ethernet.h>
+
+#include "mlanutl.h"
+
+/** Supported stream modes */
+#define HT_STREAM_MODE_1X1 0x11
+#define HT_STREAM_MODE_2X2 0x22
+
+/** mlanutl version number */
+#define MLANUTL_VER "M1.3.02"
+
+/** Termination flag */
+int terminate_flag = 0;
+
+/********************************************************
+			Local Variables
+********************************************************/
+
+/** Stringification of rateId enumeration */
+const char *rateIdStr[] = {"1",	 "2",  "5.5", "11", "--", "6",	"9",  "12",
+			   "18", "24", "36",  "48", "54", "--", "M0", "M1",
+			   "M2", "M3", "M4",  "M5", "M6", "M7", "H0", "H1",
+			   "H2", "H3", "H4",  "H5", "H6", "H7"};
+
+#ifdef DEBUG_LEVEL1
+#define MMSG MBIT(0)
+#define MFATAL MBIT(1)
+#define MERROR MBIT(2)
+#define MDATA MBIT(3)
+#define MCMND MBIT(4)
+#define MEVENT MBIT(5)
+#define MINTR MBIT(6)
+#define MIOCTL MBIT(7)
+
+#define MREG_D MBIT(9)
+
+#define MMPA_D MBIT(15)
+#define MDAT_D MBIT(16)
+#define MCMD_D MBIT(17)
+#define MEVT_D MBIT(18)
+#define MFW_D MBIT(19)
+#define MIF_D MBIT(20)
+
+#ifdef DEBUG_LEVEL2
+#define MENTRY MBIT(28)
+#define MWARN MBIT(29)
+#define MINFO MBIT(30)
+#endif
+#endif
+
+static int process_version(int argc, char *argv[]);
+static int process_verext(int argc, char *argv[]);
+static int process_hostcmd(int argc, char *argv[]);
+#ifdef DEBUG_LEVEL1
+static int process_drvdbg(int argc, char *argv[]);
+#endif
+static int process_datarate(int argc, char *argv[]);
+static int process_getlog(int argc, char *argv[]);
+static int process_get_txpwrlimit(int argc, char *argv[]);
+#ifdef STA_SUPPORT
+static int process_get_signal(int argc, char *argv[]);
+static int process_get_signal_ext(int argc, char *argv[]);
+static int process_signalext_cfg(int argc, char *argv[]);
+#endif
+static int process_vhtcfg(int argc, char *argv[]);
+static int process_dyn_bw(int argc, char *argv[]);
+static int process_11axcfg(int argc, char *argv[]);
+static int process_11axcmdcfg(int argc, char *argv[]);
+static int process_txratecfg(int argc, char *argv[]);
+static int process_httxcfg(int argc, char *argv[]);
+static int process_htcapinfo(int argc, char *argv[]);
+static int process_addbapara(int argc, char *argv[]);
+static int process_aggrpriotbl(int argc, char *argv[]);
+static int process_addbareject(int argc, char *argv[]);
+static int process_hssetpara(int argc, char *argv[]);
+static int process_mefcfg(int argc, char *argv[]);
+static int process_cloud_keep_alive(int argc, char *argv[]);
+
+struct command_node command_list[] = {
+	{"version", process_version},
+	{"verext", process_verext},
+	{"hostcmd", process_hostcmd},
+#ifdef DEBUG_LEVEL1
+	{"drvdbg", process_drvdbg},
+#endif
+	{"getdatarate", process_datarate},
+	{"getlog", process_getlog},
+	{"get_txpwrlimit", process_get_txpwrlimit},
+#ifdef STA_SUPPORT
+	{"getsignal", process_get_signal},
+	{"getsignalext", process_get_signal_ext},
+	{"getsignalextv2", process_get_signal_ext},
+	{"signalextcfg", process_signalext_cfg},
+#endif
+	{"vhtcfg", process_vhtcfg},
+	{"dyn_bw", process_dyn_bw},
+	{"11axcfg", process_11axcfg},
+	{"11axcmd", process_11axcmdcfg},
+	{"txratecfg", process_txratecfg},
+	{"addbapara", process_addbapara},
+	{"aggrpriotbl", process_aggrpriotbl},
+	{"addbareject", process_addbareject},
+	{"httxcfg", process_httxcfg},
+	{"htcapinfo", process_htcapinfo},
+	{"hssetpara", process_hssetpara},
+	{"mefcfg", process_mefcfg},
+	{"cloud_keep_alive", process_cloud_keep_alive},
+};
+
+static char *usage[] = {
+	"Usage: ",
+	"   mlanutl -v  (version)",
+	"   mlanutl <ifname> <cmd> [...]",
+	"   where",
+	"   ifname : wireless network interface name, such as mlanX or uapX",
+	"   cmd :",
+	"         version",
+	"         verext",
+	"         hostcmd",
+#ifdef DEBUG_LEVEL1
+	"         drvdbg",
+#endif
+	"         getdatarate",
+	"         getlog",
+	"         get_txpwrlimit",
+#ifdef STA_SUPPORT
+	"         getsignal",
+	"         signalextcfg",
+	"         getsignalext",
+	"         getsignalextv2",
+#endif
+	"         vhtcfg",
+	"         dyn_bw",
+	"         11axcfg",
+	"         11axcmd",
+	"         txratecfg",
+	"         httxcfg",
+	"         htcapinfo",
+	"         aggrpriotbl",
+	"         addbapara",
+	"         addbareject",
+	"         hssetpara",
+	"         mefcfg",
+	"         cloud_keep_alive",
+};
+
+/** Socket */
+t_s32 sockfd;
+/** Device name */
+char dev_name[IFNAMSIZ + 1];
+#define HOSTCMD "hostcmd"
+
+static char *config_get_line(char *s, int size, FILE *stream, int *line,
+			     char **_pos);
+#define BSSID_FILTER 1
+#define SSID_FILTER 2
+/********************************************************
+			Global Variables
+********************************************************/
+
+int setuserscan_filter = 0;
+int num_ssid_filter = 0;
+/********************************************************
+			Local Functions
+********************************************************/
+/**
+ *  @brief Convert char to hex integer
+ *
+ *  @param chr      Char to convert
+ *  @return         Hex integer or 0
+ */
+static int hexval(t_s32 chr)
+{
+	if (chr >= '0' && chr <= '9')
+		return chr - '0';
+	if (chr >= 'A' && chr <= 'F')
+		return chr - 'A' + 10;
+	if (chr >= 'a' && chr <= 'f')
+		return chr - 'a' + 10;
+
+	return 0;
+}
+
+/**
+ *  @brief Hump hex data
+ *
+ *  @param prompt   A pointer prompt buffer
+ *  @param p        A pointer to data buffer
+ *  @param len      The len of data buffer
+ *  @param delim    Delim char
+ *  @return         Hex integer
+ */
+t_void hexdump(char *prompt, t_void *p, t_s32 len, char delim)
+{
+	t_s32 i;
+	t_u8 *s = p;
+
+	if (prompt) {
+		printf("%s: len=%d\n", prompt, (int)len);
+	}
+	for (i = 0; i < len; i++) {
+		if (i != len - 1)
+			printf("%02x%c", *s++, delim);
+		else
+			printf("%02x\n", *s);
+		if ((i + 1) % 16 == 0)
+			printf("\n");
+	}
+	printf("\n");
+}
+
+/**
+ *  @brief Convert char to hex integer
+ *
+ *  @param chr      Char
+ *  @return         Hex integer
+ */
+static t_u8 hexc2bin(char chr)
+{
+	if (chr >= '0' && chr <= '9')
+		chr -= '0';
+	else if (chr >= 'A' && chr <= 'F')
+		chr -= ('A' - 10);
+	else if (chr >= 'a' && chr <= 'f')
+		chr -= ('a' - 10);
+
+	return chr;
+}
+
+/**
+ *  @brief Convert string to hex integer
+ *
+ *  @param s        A pointer string buffer
+ *  @return         Hex integer
+ */
+static t_u32 a2hex(char *s)
+{
+	t_u32 val = 0;
+
+	if (!strncasecmp("0x", s, 2)) {
+		s += 2;
+	}
+
+	while (*s && isxdigit((unsigned char)*s)) {
+		val = (val << 4) + hexc2bin(*s++);
+	}
+
+	return val;
+}
+
+/*
+ *  @brief Convert String to integer
+ *
+ *  @param value    A pointer to string
+ *  @return         Integer
+ */
+static t_u32 a2hex_or_atoi(char *value)
+{
+	if (value[0] == '0' && (value[1] == 'X' || value[1] == 'x')) {
+		return a2hex(value + 2);
+	} else {
+		return (t_u32)atoi(value);
+	}
+}
+
+/**
+ *  @brief Convert string to hex
+ *
+ *  @param ptr      A pointer to data buffer
+ *  @param chr      A pointer to return integer
+ *  @return         A pointer to next data field
+ */
+static char *convert2hex(char *ptr, t_u8 *chr)
+{
+	t_u8 val;
+
+	for (val = 0; *ptr && isxdigit((unsigned char)*ptr); ptr++) {
+		val = (val * 16) + hexval(*ptr);
+	}
+
+	*chr = val;
+
+	return ptr;
+}
+
+/**
+ *  @brief Display usage
+ *
+ *  @return       NA
+ */
+static t_void display_usage(t_void)
+{
+	t_u32 i;
+	for (i = 0; i < NELEMENTS(usage); i++)
+		fprintf(stderr, "%s\n", usage[i]);
+}
+
+/**
+ *  @brief Find and execute command
+ *
+ *  @param argc     Number of arguments
+ *  @param argv     A pointer to arguments array
+ *  @return         MLAN_STATUS_SUCCESS for success, otherwise failure
+ */
+static int process_command(int argc, char *argv[])
+{
+	int i = 0, ret = MLAN_STATUS_NOTFOUND;
+	struct command_node *node = NULL;
+
+	for (i = 0; i < (int)NELEMENTS(command_list); i++) {
+		node = &command_list[i];
+		if (!strcasecmp(node->name, argv[2])) {
+			ret = node->handler(argc, argv);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ *  @brief Prepare command buffer
+ *  @param buffer   Command buffer to be filled
+ *  @param cmd      Command id
+ *  @param num      Number of arguments
+ *  @param args     Arguments list
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+static int prepare_buffer(t_u8 *buffer, char *cmd, t_u32 num, char *args[])
+{
+	t_u8 *pos = NULL;
+	unsigned int i = 0;
+
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Flag it for our use */
+	pos = buffer;
+	memcpy((char *)pos, CMD_NXP, strlen(CMD_NXP));
+	pos += (strlen(CMD_NXP));
+
+	/* Insert command */
+	strncpy((char *)pos, (char *)cmd, strlen(cmd));
+	pos += (strlen(cmd));
+
+	/* Insert arguments */
+	for (i = 0; i < num; i++) {
+		strncpy((char *)pos, args[i], strlen(args[i]));
+		pos += strlen(args[i]);
+		if (i < (num - 1)) {
+			memcpy((char *)pos, " ", strlen(" "));
+			pos += 1;
+		}
+	}
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Trims leading and traling spaces only
+ *  @param str  A pointer to argument string
+ *  @return     pointer to trimmed string
+ */
+static char *trim_spaces(char *str)
+{
+	char *str_end = NULL;
+
+	if (!str)
+		return NULL;
+
+	/* Trim leading spaces */
+	while (!*str && isspace((unsigned char)*str))
+		str++;
+
+	if (*str == 0) /* All spaces? */
+		return str;
+
+	/* Trim trailing spaces */
+	str_end = str + strlen(str) - 1;
+	while (str_end > str && isspace((unsigned char)*str_end))
+		str_end--;
+
+	/* null terminate the string */
+	*(str_end + 1) = '\0';
+
+	return str;
+}
+
+/**
+ *  @brief read current command
+ *  @param ptr      A pointer to data
+ *  @param curCmd   A pointer to the buf which will hold current command
+ *  @return         NULL or the pointer to the left command buf
+ */
+static t_s8 *readCurCmd(t_s8 *ptr, t_s8 *curCmd)
+{
+	t_s32 i = 0;
+#define MAX_CMD_SIZE 64 /**< Max command size */
+
+	while (*ptr != ']' && i < (MAX_CMD_SIZE - 1))
+		curCmd[i++] = *(++ptr);
+
+	if (*ptr != ']')
+		return NULL;
+
+	curCmd[i - 1] = '\0';
+
+	return ++ptr;
+}
+
+/**
+ *  @brief parse command and hex data
+ *  @param fp       A pointer to FILE stream
+ *  @param dst      A pointer to the dest buf
+ *  @param cmd      A pointer to command buf for search
+ *  @return         Length of hex data or MLAN_STATUS_FAILURE
+ */
+static int fparse_for_cmd_and_hex(FILE *fp, t_u8 *dst, t_u8 *cmd)
+{
+	t_s8 *ptr;
+	t_u8 *dptr;
+	t_s8 buf[256], curCmd[64] = {0};
+	t_s32 isCurCmd = 0;
+
+	dptr = dst;
+	while (fgets((char *)buf, sizeof(buf), fp)) {
+		ptr = buf;
+
+		while (*ptr) {
+			/* skip leading spaces */
+			while (*ptr && isspace((unsigned char)*ptr))
+				ptr++;
+
+			/* skip blank lines and lines beginning with '#' */
+			if (*ptr == '\0' || *ptr == '#')
+				break;
+
+			if (*ptr == '[' && *(ptr + 1) != '/') {
+				ptr = readCurCmd(ptr, curCmd);
+				if (!ptr)
+					return MLAN_STATUS_FAILURE;
+
+				if (strcasecmp((char *)curCmd,
+					       (char *)cmd)) /* Not equal */
+					isCurCmd = 0;
+				else
+					isCurCmd = 1;
+			}
+
+			/* Ignore the rest if it is not correct cmd */
+			if (!isCurCmd)
+				break;
+
+			if (*ptr == '[' && *(ptr + 1) == '/')
+				return dptr - dst;
+
+			if (isxdigit((unsigned char)*ptr)) {
+				ptr = (t_s8 *)convert2hex((char *)ptr, dptr++);
+			} else {
+				/* Invalid character on data line */
+				ptr++;
+			}
+		}
+	}
+
+	return MLAN_STATUS_FAILURE;
+}
+
+/**
+ *  @brief Process version
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_version(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], 0, NULL);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: version fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	printf("Version string received: %s\n", buffer);
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process extended version
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_verext(int argc, char *argv[])
+{
+	int ret = 0;
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Sanity tests */
+	if (argc < 3 || argc > 4) {
+		printf("Error: invalid no of arguments\n");
+		printf("mlanutl mlanX verext [#]\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: verext fail\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Process result */
+	if (cmd->used_len)
+		printf("Extended Version string received: %s\n", buffer);
+
+done:
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return ret;
+}
+
+int process_host_cmd_resp(char *cmd_name, t_u8 *buf);
+
+/**
+ *  @brief Get one line from the File
+ *
+ *  @param fp       File handler
+ *  @param str      Storage location for data.
+ *  @param size     Maximum number of characters to read.
+ *  @param lineno   A pointer to return current line number
+ *  @return         returns string or NULL
+ */
+static char *mlan_config_get_line(FILE *fp, char *str, t_s32 size, int *lineno)
+{
+	char *start, *end;
+	int out, next_line;
+
+	if (!fp || !str)
+		return NULL;
+
+	do {
+	read_line:
+		if (!fgets(str, size, fp))
+			break;
+		start = str;
+		start[size - 1] = '\0';
+		end = start + strlen(str);
+		(*lineno)++;
+
+		out = 1;
+		while (out && (start < end)) {
+			next_line = 0;
+			/* Remove empty lines and lines starting with # */
+			switch (start[0]) {
+			case ' ': /* White space */
+			case '\t': /* Tab */
+				start++;
+				break;
+			case '#':
+			case '\n':
+			case '\0':
+				next_line = 1;
+				break;
+			case '\r':
+				if (start[1] == '\n')
+					next_line = 1;
+				else
+					start++;
+				break;
+			default:
+				out = 0;
+				break;
+			}
+			if (next_line)
+				goto read_line;
+		}
+
+		/* Remove # comments unless they are within a double quoted
+		 * string. Remove trailing white space. */
+		end = strstr(start, "\"");
+		if (end) {
+			end = strstr(end + 1, "\"");
+			if (!end)
+				end = start;
+		} else
+			end = start;
+
+		end = strstr(end + 1, "#");
+		if (end)
+			*end-- = '\0';
+		else
+			end = start + strlen(start) - 1;
+
+		out = 1;
+		while (out && (start < end)) {
+			switch (*end) {
+			case ' ': /* White space */
+			case '\t': /* Tab */
+			case '\n':
+			case '\r':
+				*end = '\0';
+				end--;
+				break;
+			default:
+				out = 0;
+				break;
+			}
+		}
+
+		if (*start == '\0')
+			continue;
+
+		return start;
+	} while (1);
+
+	return NULL;
+}
+
+/**
+ *  @brief          Parse function for a configuration line
+ *
+ *  @param s        Storage buffer for data
+ *  @param size     Maximum size of data
+ *  @param stream   File stream pointer
+ *  @param line     Pointer to current line within the file
+ *  @param _pos     Output string or NULL
+ *  @return         String or NULL
+ */
+static char *config_get_line(char *s, int size, FILE *stream, int *line,
+			     char **_pos)
+{
+	*_pos = mlan_config_get_line(stream, s, size, line);
+	return *_pos;
+}
+
+/**
+ *  @brief get hostcmd data
+ *
+ *  @param ln           A pointer to line number
+ *  @param buf          A pointer to hostcmd data
+ *  @param size         A pointer to the return size of hostcmd buffer
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static int mlan_get_hostcmd_data(FILE *fp, int *ln, t_u8 *buf, t_u16 *size)
+{
+	t_s32 errors = 0, i;
+	char line[512], *pos, *pos1, *pos2, *pos3;
+	t_u16 len;
+
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), ln))) {
+		(*ln)++;
+		if (strcmp(pos, "}") == 0) {
+			break;
+		}
+
+		pos1 = strchr(pos, ':');
+		if (pos1 == NULL) {
+			printf("Line %d: Invalid hostcmd line '%s'\n", *ln,
+			       pos);
+			errors++;
+			continue;
+		}
+		*pos1++ = '\0';
+
+		pos2 = strchr(pos1, '=');
+		if (pos2 == NULL) {
+			printf("Line %d: Invalid hostcmd line '%s'\n", *ln,
+			       pos);
+			errors++;
+			continue;
+		}
+		*pos2++ = '\0';
+
+		len = a2hex_or_atoi(pos1);
+		if (len < 1 || len > BUFFER_LENGTH) {
+			printf("Line %d: Invalid hostcmd line '%s'\n", *ln,
+			       pos);
+			errors++;
+			continue;
+		}
+
+		*size += len;
+
+		if (*pos2 == '"') {
+			pos2++;
+			pos3 = strchr(pos2, '"');
+			if (pos3 == NULL) {
+				printf("Line %d: invalid quotation '%s'\n", *ln,
+				       pos);
+				errors++;
+				continue;
+			}
+			*pos3 = '\0';
+			memset(buf, 0, len);
+			memmove(buf, pos2, MIN(strlen(pos2), len));
+			buf += len;
+		} else if (*pos2 == '\'') {
+			pos2++;
+			pos3 = strchr(pos2, '\'');
+			if (pos3 == NULL) {
+				printf("Line %d: invalid quotation '%s'\n", *ln,
+				       pos);
+				errors++;
+				continue;
+			}
+			*pos3 = ',';
+			for (i = 0; i < len; i++) {
+				pos3 = strchr(pos2, ',');
+				if (pos3 != NULL) {
+					*pos3 = '\0';
+					*buf++ = (t_u8)a2hex_or_atoi(pos2);
+					pos2 = pos3 + 1;
+				} else
+					*buf++ = 0;
+			}
+		} else if (*pos2 == '{') {
+			t_u16 tlvlen = 0, tmp_tlvlen;
+			mlan_get_hostcmd_data(fp, ln, buf + len, &tlvlen);
+			tmp_tlvlen = tlvlen;
+			while (len--) {
+				*buf++ = (t_u8)(tmp_tlvlen & 0xff);
+				tmp_tlvlen >>= 8;
+			}
+			*size += tlvlen;
+			buf += tlvlen;
+		} else {
+			t_u32 value = a2hex_or_atoi(pos2);
+			while (len--) {
+				*buf++ = (t_u8)(value & 0xff);
+				value >>= 8;
+			}
+		}
+	}
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Prepare host-command buffer
+ *  @param fp       File handler
+ *  @param cmd_name Command name
+ *  @param buf      A pointer to comand buffer
+ *  @return         MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int prepare_host_cmd_buffer(FILE *fp, char *cmd_name, t_u8 *buf)
+{
+	char line[256], cmdname[256], *pos, cmdcode[10];
+	HostCmd_DS_GEN *hostcmd;
+	t_u32 hostcmd_size = 0;
+	int ln = 0;
+	int cmdname_found = 0, cmdcode_found = 0;
+
+	hostcmd = (HostCmd_DS_GEN *)(buf + sizeof(t_u32));
+	hostcmd->command = 0xffff;
+
+	snprintf(cmdname, sizeof(cmdname), "%s={", cmd_name);
+	cmdname_found = 0;
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), &ln))) {
+		if (strcmp(pos, cmdname) == 0) {
+			cmdname_found = 1;
+			snprintf(cmdcode, sizeof(cmdcode), "CmdCode=");
+			cmdcode_found = 0;
+			while ((pos = mlan_config_get_line(
+					fp, line, sizeof(line), &ln))) {
+				if (strncmp(pos, cmdcode, strlen(cmdcode)) ==
+				    0) {
+					t_u16 len = 0;
+					cmdcode_found = 1;
+					hostcmd->command = a2hex_or_atoi(
+						pos + strlen(cmdcode));
+					hostcmd->size = S_DS_GEN;
+					mlan_get_hostcmd_data(
+						fp, &ln,
+						buf + sizeof(t_u32) +
+							hostcmd->size,
+						&len);
+					hostcmd->size += len;
+					break;
+				}
+			}
+			if (!cmdcode_found) {
+				fprintf(stderr,
+					"mlanutl: CmdCode not found in conf file\n");
+				return MLAN_STATUS_FAILURE;
+			}
+			break;
+		}
+	}
+
+	if (!cmdname_found) {
+		fprintf(stderr,
+			"mlanutl: cmdname '%s' is not found in conf file\n",
+			cmd_name);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	hostcmd->seq_num = 0;
+	hostcmd->result = 0;
+	hostcmd->command = cpu_to_le16(hostcmd->command);
+	hostcmd->size = cpu_to_le16(hostcmd->size);
+
+	hostcmd_size = (t_u32)(hostcmd->size);
+	memcpy(buf, (t_u8 *)&hostcmd_size, sizeof(t_u32));
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+#define SUBID_OFFSET 2
+static t_u16 supported_subcmd[] = {0x104, 0x111, 0x11b, 0x11e, 0x27};
+
+static int check_if_hostcmd_subcmd_allowed(t_u8 *buf)
+{
+	t_u32 maxcnt = sizeof(supported_subcmd) / sizeof(supported_subcmd[0]);
+
+	for (int i = 0; i < maxcnt; i++) {
+		if (!memcmp(buf + SUBID_OFFSET, (supported_subcmd + i),
+			    sizeof(t_u16)))
+			return MLAN_STATUS_SUCCESS;
+	}
+	return MLAN_STATUS_NOTFOUND;
+}
+
+/**
+ *  @brief Process hostcmd command
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_hostcmd(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL, *raw_buf = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	FILE *fp = NULL;
+	FILE *fp_raw = NULL;
+	FILE *fp_dtsi = NULL;
+	char cmdname[256];
+	boolean call_ioctl = TRUE;
+	t_u32 buf_len = 0, i, j, k;
+	char *line = NULL, *pos = NULL;
+	int li = 0, blk_count = 0, ob = 0;
+	int ret = MLAN_STATUS_SUCCESS;
+
+	struct cmd_node {
+		char cmd_string[256];
+		struct cmd_node *next;
+	};
+	struct cmd_node *command = NULL, *header = NULL, *new_node = NULL;
+
+	if (argc < 5) {
+		printf("Error: invalid no of arguments\n");
+		printf("Syntax: ./mlanutl mlanX hostcmd <hostcmd.conf> <cmdname>\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	snprintf(cmdname, sizeof(cmdname), "%s", argv[4]);
+
+	if (!strcmp(cmdname, "generate_raw")) {
+		call_ioctl = FALSE;
+	}
+	if (!call_ioctl && argc != 6) {
+		printf("Error: invalid no of arguments\n");
+		printf("Syntax: ./mlanutl mlanX hostcmd <hostcmd.conf> %s <raw_data_file>\n",
+		       cmdname);
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	fp = fopen(argv[3], "r");
+	if (fp == NULL) {
+		fprintf(stderr, "Cannot open file %s\n", argv[3]);
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		fclose(fp);
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	if (call_ioctl) {
+		/* Prepare the hostcmd buffer */
+		prepare_buffer(buffer, argv[2], 0, NULL);
+		if (MLAN_STATUS_FAILURE ==
+		    prepare_host_cmd_buffer(fp, cmdname,
+					    buffer + strlen(CMD_NXP) +
+						    strlen(argv[2]))) {
+			fclose(fp);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		fclose(fp);
+	} else {
+		line = (char *)malloc(MAX_CONFIG_LINE);
+		if (!line) {
+			printf("ERR:Cannot allocate memory for line\n");
+			fclose(fp);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		memset(line, 0, MAX_CONFIG_LINE);
+
+		while (config_get_line(line, MAX_CONFIG_LINE, fp, &li, &pos)) {
+			line = trim_spaces(line);
+			if (line[strlen(line) - 1] == '{') {
+				if (ob == 0) {
+					new_node = (struct cmd_node *)malloc(
+						sizeof(struct cmd_node));
+					if (!new_node) {
+						printf("ERR:Cannot allocate memory for cmd_node\n");
+						fclose(fp);
+						ret = MLAN_STATUS_FAILURE;
+						goto done;
+					}
+					memset(new_node, 0,
+					       sizeof(struct cmd_node));
+					new_node->next = NULL;
+					if (blk_count == 0) {
+						header = new_node;
+						command = new_node;
+					} else {
+						command->next = new_node;
+						command = new_node;
+					}
+					strncpy(command->cmd_string, line,
+						(strchr(line, '=') - line));
+					memmove(command->cmd_string,
+						trim_spaces(
+							command->cmd_string),
+						strlen(trim_spaces(
+							command->cmd_string)) +
+							1);
+				}
+				ob++;
+				continue; /* goto while() */
+			}
+			if (line[strlen(line) - 1] == '}') {
+				ob--;
+				if (ob == 0)
+					blk_count++;
+				continue; /* goto while() */
+			}
+		}
+
+		rewind(fp); /* Set the source file pointer to the beginning
+			       again */
+		command = header; /* Set 'command' at the beginning of the
+				     command list */
+
+		fp_raw = fopen(argv[5], "w");
+		if (fp_raw == NULL) {
+			fprintf(stderr,
+				"Cannot open the destination raw_data file %s\n",
+				argv[5]);
+			fclose(fp);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		/* prepare .dtsi output */
+		snprintf(cmdname, sizeof(cmdname), "%s.dtsi", argv[5]);
+		fp_dtsi = fopen(cmdname, "w");
+		if (fp_dtsi == NULL) {
+			fprintf(stderr, "Cannot open the destination file %s\n",
+				cmdname);
+			fclose(fp);
+			fclose(fp_raw);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		for (k = 0; k < (t_u32)blk_count && command != NULL; k++) {
+			if (MLAN_STATUS_FAILURE ==
+			    prepare_host_cmd_buffer(fp, command->cmd_string,
+						    buffer))
+				memset(buffer, 0, BUFFER_LENGTH);
+
+			memcpy(&buf_len, buffer, sizeof(t_u32));
+			if (buf_len) {
+				raw_buf = buffer + sizeof(t_u32); /* raw_buf
+								     points to
+								     start of
+								     actual <raw
+								     data> */
+				printf("buf_len = %d\n", (int)buf_len);
+				if (k > 0)
+					fprintf(fp_raw, "\n\n");
+				fprintf(fp_raw, "%s={\n", command->cmd_string);
+				fprintf(fp_dtsi,
+					"/ {\n\tmarvell_cfgdata {\n\t\tmarvell,%s = /bits/ 8 <\n",
+					command->cmd_string);
+				i = j = 0;
+				while (i < buf_len) {
+					for (j = 0; j < 16; j++) {
+						fprintf(fp_raw, "%02x ",
+							*(raw_buf + i));
+						if (i >= 8) {
+							fprintf(fp_dtsi,
+								"0x%02x",
+								*(raw_buf + i));
+							if ((j < 16 - 1) &&
+							    (i < buf_len - 1))
+								fprintf(fp_dtsi,
+									" ");
+						}
+						if (++i >= buf_len)
+							break;
+					}
+					fputc('\n', fp_raw);
+					fputc('\n', fp_dtsi);
+				}
+				fprintf(fp_raw, "}");
+				fprintf(fp_dtsi, "\t\t>;\n\t};\n};\n");
+			}
+			command = command->next;
+			rewind(fp);
+		}
+
+		fclose(fp_dtsi);
+		fclose(fp_raw);
+		fclose(fp);
+	}
+
+	if (call_ioctl) {
+		raw_buf = buffer + strlen(CMD_NXP) + strlen(argv[2]) +
+			  sizeof(t_u32) + S_DS_GEN; /* raw_buf points to start
+						       of actual <raw data> */
+		if (check_if_hostcmd_subcmd_allowed(raw_buf) !=
+		    MLAN_STATUS_SUCCESS) {
+			printf("ERR:Entered hostcmd not allowed!\n");
+			goto done;
+		}
+		cmd = (struct eth_priv_cmd *)malloc(
+			sizeof(struct eth_priv_cmd));
+		if (!cmd) {
+			printf("ERR:Cannot allocate buffer for command!\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+		memset(cmd, 0, sizeof(struct eth_priv_cmd));
+		memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+		cmd->buf = buffer;
+#endif
+		cmd->used_len = 0;
+		cmd->total_len = BUFFER_LENGTH;
+
+		/* Perform IOCTL */
+		memset(&ifr, 0, sizeof(struct ifreq));
+		strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+		ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+		if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+			perror("mlanutl");
+			fprintf(stderr, "mlanutl: hostcmd fail\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		/* Process result */
+		process_host_cmd_resp(argv[2], buffer);
+	}
+done:
+	while (header) {
+		command = header;
+		header = header->next;
+		free(command);
+	}
+	if (line)
+		free(line);
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+	return ret;
+}
+
+#ifdef DEBUG_LEVEL1
+/**
+ *  @brief Process driver debug configuration
+ *  @param argc   number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_drvdbg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	t_u32 drvdbg;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: drvdbg config fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	if (argc == 3) {
+		memcpy(&drvdbg, buffer, sizeof(drvdbg));
+		printf("drvdbg: 0x%08x\n", drvdbg);
+#ifdef DEBUG_LEVEL2
+		printf("MINFO  (%08x) %s\n", MINFO,
+		       (drvdbg & MINFO) ? "X" : "");
+		printf("MWARN  (%08x) %s\n", MWARN,
+		       (drvdbg & MWARN) ? "X" : "");
+		printf("MENTRY (%08x) %s\n", MENTRY,
+		       (drvdbg & MENTRY) ? "X" : "");
+#endif
+		printf("MMPA_D (%08x) %s\n", MMPA_D,
+		       (drvdbg & MMPA_D) ? "X" : "");
+		printf("MIF_D  (%08x) %s\n", MIF_D,
+		       (drvdbg & MIF_D) ? "X" : "");
+		printf("MFW_D  (%08x) %s\n", MFW_D,
+		       (drvdbg & MFW_D) ? "X" : "");
+		printf("MEVT_D (%08x) %s\n", MEVT_D,
+		       (drvdbg & MEVT_D) ? "X" : "");
+		printf("MCMD_D (%08x) %s\n", MCMD_D,
+		       (drvdbg & MCMD_D) ? "X" : "");
+		printf("MDAT_D (%08x) %s\n", MDAT_D,
+		       (drvdbg & MDAT_D) ? "X" : "");
+		printf("MREG_D (%08x) %s\n", MREG_D,
+		       (drvdbg & MREG_D) ? "X" : "");
+		printf("MIOCTL (%08x) %s\n", MIOCTL,
+		       (drvdbg & MIOCTL) ? "X" : "");
+		printf("MINTR  (%08x) %s\n", MINTR,
+		       (drvdbg & MINTR) ? "X" : "");
+		printf("MEVENT (%08x) %s\n", MEVENT,
+		       (drvdbg & MEVENT) ? "X" : "");
+		printf("MCMND  (%08x) %s\n", MCMND,
+		       (drvdbg & MCMND) ? "X" : "");
+		printf("MDATA  (%08x) %s\n", MDATA,
+		       (drvdbg & MDATA) ? "X" : "");
+		printf("MERROR (%08x) %s\n", MERROR,
+		       (drvdbg & MERROR) ? "X" : "");
+		printf("MFATAL (%08x) %s\n", MFATAL,
+		       (drvdbg & MFATAL) ? "X" : "");
+		printf("MMSG   (%08x) %s\n", MMSG, (drvdbg & MMSG) ? "X" : "");
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+#endif
+
+static char *rate_format[4] = {"LG", "HT", "VHT", "HE"};
+static char *lg_rate[] = {"1 Mbps",  "2 Mbps",	"5.5 Mbps", "11 Mbps",
+			  "6 Mbps",  "9 Mbps",	"12 Mbps",  "18 Mbps",
+			  "24 Mbps", "36 Mbps", "48 Mbps",  "54 Mbps"};
+
+/**
+ *  @brief Process Get data rate
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_datarate(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct eth_priv_data_rate *datarate = NULL;
+	struct ifreq ifr;
+	char *bw[] = {"20 MHz", "40 MHz", "80 MHz", "160 MHz"};
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], 0, NULL);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: getdatarate fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	datarate = (struct eth_priv_data_rate *)buffer;
+	printf("Data Rate:\n");
+	printf("  TX: \n");
+	if (datarate->tx_rate_format <= 3) {
+		printf("    Type: %s\n", rate_format[datarate->tx_rate_format]);
+		if ((datarate->tx_rate_format == 0) &&
+		    datarate->tx_data_rate <= 11)
+			/* LG */
+			printf("    Rate: %s\n",
+			       lg_rate[datarate->tx_data_rate]);
+		else {
+			/* HT and VHT*/
+			if (datarate->tx_bw <= 3)
+				printf("    BW:   %s\n", bw[datarate->tx_bw]);
+			if (datarate->tx_rate_format < 3) {
+				if (datarate->tx_gi == 0)
+					printf("    GI:   Long\n");
+				else
+					printf("    GI:   Short\n");
+			} else if (datarate->tx_rate_format == 3) {
+				switch (datarate->tx_gi) {
+				case 0:
+					printf("    GI:   1xHELTF + GI 0.8us  \n");
+					break;
+				case 1:
+					printf("    GI:   2xHELTF + GI 0.8us  \n");
+					break;
+				case 2:
+					printf("    GI:   2xHELTF + GI 1.6us  \n");
+					break;
+				case 3:
+					printf("    GI:   4xHELTF + GI 0.8us DCM=0 and STBC=0 or\n"
+					       "          4xHELTF + GI 3.2us Otherwise  \n");
+					break;
+				}
+			}
+			if (datarate->tx_rate_format >= 2)
+				printf("    NSS:  %d\n", datarate->tx_nss + 1);
+			if (datarate->tx_mcs_index != 0xFF)
+				printf("    MCS:  MCS %d\n",
+				       (int)datarate->tx_mcs_index);
+			else
+				printf("    MCS:  Auto\n");
+			if (datarate->tx_rate_format < 3)
+				printf("    Rate: %f Mbps\n",
+				       (float)datarate->tx_data_rate / 2);
+		}
+	}
+
+	printf("  RX: \n");
+	if (datarate->rx_rate_format <= 3) {
+		printf("    Type: %s\n", rate_format[datarate->rx_rate_format]);
+		if ((datarate->rx_rate_format == 0) &&
+		    datarate->rx_data_rate <= 11)
+			/* LG */
+			printf("    Rate: %s\n",
+			       lg_rate[datarate->rx_data_rate]);
+		else {
+			/* HT and VHT*/
+			if (datarate->rx_bw <= 3)
+				printf("    BW:   %s\n", bw[datarate->rx_bw]);
+			if (datarate->rx_rate_format < 3) {
+				if (datarate->rx_gi == 0)
+					printf("    GI:   Long\n");
+				else
+					printf("    GI:   Short\n");
+			} else if (datarate->rx_rate_format == 3) {
+				switch (datarate->rx_gi) {
+				case 0:
+					printf("    GI:   1xHELTF + GI 0.8us  \n");
+					break;
+				case 1:
+					printf("    GI:   2xHELTF + GI 0.8us  \n");
+					break;
+				case 2:
+					printf("    GI:   2xHELTF + GI 1.6us  \n");
+					break;
+				case 3:
+					printf("    GI:   4xHELTF + GI 0.8us DCM=0 and STBC=0 or\n"
+					       "          4xHELTF + GI 3.2us Otherwise  \n");
+					break;
+				}
+			}
+			if (datarate->rx_rate_format >= 2)
+				printf("    NSS:  %d\n", datarate->rx_nss + 1);
+			if (datarate->rx_mcs_index != 0xFF)
+				printf("    MCS:  MCS %d\n",
+				       (int)datarate->rx_mcs_index);
+			else
+				printf("    MCS:  Auto\n");
+			if (datarate->rx_rate_format < 3)
+				printf("    Rate: %f Mbps\n",
+				       (float)datarate->rx_data_rate / 2);
+		}
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process get wireless stats
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_getlog(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct eth_priv_get_log *stats = NULL;
+	struct ifreq ifr;
+	struct timeval tv;
+	int i = 0;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: getlog fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	gettimeofday(&tv, NULL);
+
+	/* Process results */
+	stats = (struct eth_priv_get_log *)buffer;
+	printf("Get log: timestamp %d.%06d sec\n", (int)tv.tv_sec,
+	       (int)tv.tv_usec);
+	printf("dot11GroupTransmittedFrameCount    %u\n"
+	       "dot11FailedCount                   %u\n"
+	       "dot11RetryCount                    %u\n"
+	       "dot11MultipleRetryCount            %u\n"
+	       "dot11FrameDuplicateCount           %u\n"
+	       "dot11RTSSuccessCount               %u\n"
+	       "dot11RTSFailureCount               %u\n"
+	       "dot11ACKFailureCount               %u\n"
+	       "dot11ReceivedFragmentCount         %u\n"
+	       "dot11GroupReceivedFrameCount       %u\n"
+	       "dot11FCSErrorCount                 %u\n"
+	       "dot11TransmittedFrameCount         %u\n"
+	       "wepicverrcnt-1                     %u\n"
+	       "wepicverrcnt-2                     %u\n"
+	       "wepicverrcnt-3                     %u\n"
+	       "wepicverrcnt-4                     %u\n"
+	       "beaconReceivedCount                %u\n"
+	       "beaconMissedCount                  %u\n",
+	       stats->mcast_tx_frame, stats->failed, stats->retry,
+	       stats->multi_retry, stats->frame_dup, stats->rts_success,
+	       stats->rts_failure, stats->ack_failure, stats->rx_frag,
+	       stats->mcast_rx_frame, stats->fcs_error, stats->tx_frame,
+	       stats->wep_icv_error[0], stats->wep_icv_error[1],
+	       stats->wep_icv_error[2], stats->wep_icv_error[3],
+	       stats->bcn_rcv_cnt, stats->bcn_miss_cnt);
+
+	if (argc == 4 && !(strcmp(argv[3], "ext"))) {
+		printf("rxStuckIssueCount-1                %u\n"
+		       "rxStuckIssueCount-2                %u\n"
+		       "rxStuckRecoveryCount               %u\n"
+		       "rxStuckTsf-1                       %llu\n"
+		       "rxStuckTsf-2                       %llu\n"
+		       "txWatchdogRecoveryCount            %u\n"
+		       "txWatchdogTsf-1                    %llu\n"
+		       "txWatchdogTsf-2                    %llu\n"
+		       "channelSwitchAnnouncementSent      %u\n"
+		       "channelSwitchState                 %u\n"
+		       "registerClass                      %u\n"
+		       "channelNumber                      %u\n"
+		       "channelSwitchMode                  %u\n"
+		       "RxResetRecoveryCount               %u\n"
+		       "RxIsr2NotDoneCnt                   %u\n"
+		       "gdmaAbortCnt                       %u\n"
+		       "gResetRxMacCnt                     %u\n"
+		       "gOwnrshpCtlErrCnt                  %u\n"
+		       "gOwnrshpBcnErrCnt                  %u\n"
+		       "gOwnrshpMgtErrCnt                  %u\n"
+		       "gOwnrshpDatErrCnt                  %u\n"
+		       "bigtk_mmeGoodCnt                   %u\n"
+		       "bigtk_replayErrCnt                 %u\n"
+		       "bigtk_micErrCnt                    %u\n"
+		       "bigtk_mmeNotFoundCnt               %u\n",
+		       stats->rx_stuck_issue_cnt[0],
+		       stats->rx_stuck_issue_cnt[1],
+		       stats->rx_stuck_recovery_cnt, stats->rx_stuck_tsf[0],
+		       stats->rx_stuck_tsf[1], stats->tx_watchdog_recovery_cnt,
+		       stats->tx_watchdog_tsf[0], stats->tx_watchdog_tsf[1],
+		       stats->channel_switch_ann_sent,
+		       stats->channel_switch_state, stats->reg_class,
+		       stats->channel_number, stats->channel_switch_mode,
+		       stats->rx_reset_mac_recovery_cnt,
+		       stats->rx_Isr2_NotDone_Cnt, stats->gdma_abort_cnt,
+		       stats->g_reset_rx_mac_cnt, stats->dwCtlErrCnt,
+		       stats->dwBcnErrCnt, stats->dwMgtErrCnt,
+		       stats->dwDatErrCnt, stats->bigtk_mmeGoodCnt,
+		       stats->bigtk_replayErrCnt, stats->bigtk_micErrCnt,
+		       stats->bigtk_mmeNotFoundCnt);
+	}
+
+	if (cmd->used_len == sizeof(struct eth_priv_get_log)) {
+		printf("dot11TransmittedFragmentCount      %u\n",
+		       stats->tx_frag_cnt);
+		printf("dot11QosTransmittedFragmentCount   ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_tx_frag_cnt[i]);
+		}
+		printf("\ndot11QosFailedCount                ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_failed_cnt[i]);
+		}
+		printf("\ndot11QosRetryCount                 ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_retry_cnt[i]);
+		}
+		printf("\ndot11QosMultipleRetryCount         ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_multi_retry_cnt[i]);
+		}
+		printf("\ndot11QosFrameDuplicateCount        ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_frm_dup_cnt[i]);
+		}
+		printf("\ndot11QosRTSSuccessCount            ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_rts_suc_cnt[i]);
+		}
+		printf("\ndot11QosRTSFailureCount            ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_rts_failure_cnt[i]);
+		}
+		printf("\ndot11QosACKFailureCount            ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_ack_failure_cnt[i]);
+		}
+		printf("\ndot11QosReceivedFragmentCount      ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_rx_frag_cnt[i]);
+		}
+		printf("\ndot11QosTransmittedFrameCount      ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_tx_frm_cnt[i]);
+		}
+		printf("\ndot11QosDiscardedFrameCount        ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_discarded_frm_cnt[i]);
+		}
+		printf("\ndot11QosMPDUsReceivedCount         ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_mpdus_rx_cnt[i]);
+		}
+		printf("\ndot11QosRetriesReceivedCount       ");
+		for (i = 0; i < 8; i++) {
+			printf("%u ", stats->qos_retries_rx_cnt[i]);
+		}
+		printf("\ndot11RSNAStatsCMACICVErrors          %u\n"
+		       "dot11RSNAStatsCMACReplays            %u\n"
+		       "dot11RSNAStatsRobustMgmtCCMPReplays  %u\n"
+		       "dot11RSNAStatsTKIPICVErrors          %u\n"
+		       "dot11RSNAStatsTKIPReplays            %u\n"
+		       "dot11RSNAStatsCCMPDecryptErrors      %u\n"
+		       "dot11RSNAstatsCCMPReplays            %u\n"
+		       "dot11TransmittedAMSDUCount           %u\n"
+		       "dot11FailedAMSDUCount                %u\n"
+		       "dot11RetryAMSDUCount                 %u\n"
+		       "dot11MultipleRetryAMSDUCount         %u\n"
+		       "dot11TransmittedOctetsInAMSDUCount   %llu\n"
+		       "dot11AMSDUAckFailureCount            %u\n"
+		       "dot11ReceivedAMSDUCount              %u\n"
+		       "dot11ReceivedOctetsInAMSDUCount      %llu\n"
+		       "dot11TransmittedAMPDUCount           %u\n"
+		       "dot11TransmittedMPDUsInAMPDUCount    %u\n"
+		       "dot11TransmittedOctetsInAMPDUCount   %llu\n"
+		       "dot11AMPDUReceivedCount              %u\n"
+		       "dot11MPDUInReceivedAMPDUCount        %u\n"
+		       "dot11ReceivedOctetsInAMPDUCount      %llu\n"
+		       "dot11AMPDUDelimiterCRCErrorCount     %u\n",
+		       stats->cmacicv_errors, stats->cmac_replays,
+		       stats->mgmt_ccmp_replays, stats->tkipicv_errors,
+		       stats->tkip_replays, stats->ccmp_decrypt_errors,
+		       stats->ccmp_replays, stats->tx_amsdu_cnt,
+		       stats->failed_amsdu_cnt, stats->retry_amsdu_cnt,
+		       stats->multi_retry_amsdu_cnt,
+		       stats->tx_octets_in_amsdu_cnt,
+		       stats->amsdu_ack_failure_cnt, stats->rx_amsdu_cnt,
+		       stats->rx_octets_in_amsdu_cnt, stats->tx_ampdu_cnt,
+		       stats->tx_mpdus_in_ampdu_cnt,
+		       stats->tx_octets_in_ampdu_cnt, stats->ampdu_rx_cnt,
+		       stats->mpdu_in_rx_ampdu_cnt,
+		       stats->rx_octets_in_ampdu_cnt,
+		       stats->ampdu_delimiter_crc_error_cnt);
+	}
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+#ifdef STA_SUPPORT
+/**
+ *  @brief Get signal
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return       MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_get_signal(int argc, char *argv[])
+{
+#define DATA_SIZE 12
+	int ret = 0, data[DATA_SIZE], i = 0, copy_size = 0;
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	memset(data, 0, sizeof(data));
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Sanity tests */
+	if (argc < 3 || argc > 5) {
+		printf("Error: invalid no of arguments\n");
+		printf("mlanutl mlanX getsignal [m] [n]\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: getsignal fail\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Process result */
+	copy_size =
+		(int)MIN((int)cmd->used_len, (int)(DATA_SIZE * sizeof(int)));
+	if (copy_size > 0)
+		memcpy(&data, buffer, copy_size);
+	printf("Get signal output is\t");
+	for (i = 0; i < (int)(copy_size / sizeof(int)); i++)
+		printf("%d\t", data[i]);
+	printf("\n");
+
+done:
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return ret;
+}
+
+/**
+ *  @brief Set signalext cfg
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return       MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_signalext_cfg(int argc, char *argv[])
+{
+	int ret = 0;
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Sanity tests */
+	if (argc != 4) {
+		printf("Error: invalid no of arguments\n");
+		printf("mlanutl mlanX signalextcfg [#]\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: signalext cfg fail\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+done:
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return ret;
+}
+
+/**
+ *  @brief Get signal
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return       MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_get_signal_ext(int argc, char *argv[])
+{
+#define MAX_NUM_PATH 3
+#define PATH_SIZE 13
+#define PATH_A 1
+#define PATH_B 2
+#define PATH_AB 3
+	int ret = 0, data[PATH_SIZE * MAX_NUM_PATH] = {0};
+	int i = 0, copy_size = 0;
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	t_u8 num_path = 0;
+
+	memset(data, 0, sizeof(data));
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Sanity tests */
+	if (argc != 3 && argc != 4) {
+		printf("Error: invalid no of arguments\n");
+		if (strncmp(argv[2], "getsignalextv2",
+			    strlen("getsignalextv2")) == 0)
+			printf("mlanutl mlanX getsignalextv2 [m]\n");
+		else if (strncmp(argv[2], "getsignalext",
+				 strlen("getsignalext")) == 0)
+			printf("mlanutl mlanX getsignalext [m]\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: getsignal fail\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Process result */
+	copy_size = cmd->used_len;
+	if (copy_size > 0)
+		memcpy(&data, (int *)buffer, copy_size);
+
+	num_path = copy_size / sizeof(int) / PATH_SIZE;
+	for (i = 0; i < num_path; i++) {
+		if (data[i * PATH_SIZE] == PATH_A)
+			printf("PATH A:   %d %d %d %d %d %d %d %d %d %d %d %d\n",
+			       data[i * PATH_SIZE + 1], data[i * PATH_SIZE + 2],
+			       data[i * PATH_SIZE + 3], data[i * PATH_SIZE + 4],
+			       data[i * PATH_SIZE + 5], data[i * PATH_SIZE + 6],
+			       data[i * PATH_SIZE + 7], data[i * PATH_SIZE + 8],
+			       data[i * PATH_SIZE + 9],
+			       data[i * PATH_SIZE + 10],
+			       data[i * PATH_SIZE + 11],
+			       data[i * PATH_SIZE + 12]);
+		else if (data[i * PATH_SIZE] == PATH_B)
+			printf("PATH B:   %d %d %d %d %d %d %d %d %d %d %d %d\n",
+			       data[i * PATH_SIZE + 1], data[i * PATH_SIZE + 2],
+			       data[i * PATH_SIZE + 3], data[i * PATH_SIZE + 4],
+			       data[i * PATH_SIZE + 5], data[i * PATH_SIZE + 6],
+			       data[i * PATH_SIZE + 7], data[i * PATH_SIZE + 8],
+			       data[i * PATH_SIZE + 9],
+			       data[i * PATH_SIZE + 10],
+			       data[i * PATH_SIZE + 11],
+			       data[i * PATH_SIZE + 12]);
+		else if (data[i * PATH_SIZE] == PATH_AB)
+			printf("PATH A+B: %d %d %d %d %d %d %d %d %d %d %d %d\n",
+			       data[i * PATH_SIZE + 1], data[i * PATH_SIZE + 2],
+			       data[i * PATH_SIZE + 3], data[i * PATH_SIZE + 4],
+			       data[i * PATH_SIZE + 5], data[i * PATH_SIZE + 6],
+			       data[i * PATH_SIZE + 7], data[i * PATH_SIZE + 8],
+			       data[i * PATH_SIZE + 9],
+			       data[i * PATH_SIZE + 10],
+			       data[i * PATH_SIZE + 11],
+			       data[i * PATH_SIZE + 12]);
+	}
+	printf("\n");
+
+done:
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return ret;
+}
+#endif /* #ifdef STA_SUPPORT */
+
+/**
+ * @brief      Get txpwrlimit
+ *
+ * @param argc Number of arguments
+ * @param argv Pointer to the arguments array
+ *
+ * @return     MLAN_STATUS_SUCCESS/MLAN_STATUS_FAILURE
+ */
+static int get_txpwrlimit(FILE *fp_raw, char *argv[], t_u16 sub_band,
+			  t_u8 *buffer, t_u16 len, struct eth_priv_cmd *cmd)
+{
+	struct ifreq ifr;
+	mlan_ds_misc_chan_trpc_cfg *trcp_cfg = NULL;
+	MrvlIETypes_ChanTRPCConfig_t *trpc_tlv = NULL;
+	MrvlIEtypes_Data_t *pTlvHdr;
+	int left_len;
+	int mod_num = 0;
+	int i = 0;
+	int j = 0;
+	t_u8 *pByte = NULL;
+
+	memset(buffer, 0, len);
+	/* Insert command */
+	strncpy((char *)buffer, argv[2], strlen(argv[2]));
+	trcp_cfg = (mlan_ds_misc_chan_trpc_cfg *)(buffer + strlen(argv[2]));
+	trcp_cfg->sub_band = sub_band;
+	if (cmd) {
+		/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+		memset(cmd, 0, sizeof(struct eth_priv_cmd));
+		memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+		cmd->buf = buffer;
+#endif
+		cmd->used_len = 0;
+		cmd->total_len = len;
+	}
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: get_txpwrlimit fail\n");
+		return MLAN_STATUS_FAILURE;
+	}
+	/* Process result */
+	printf("------------------------------------------------------------------------------------\n");
+	printf("Get txpwrlimit: sub_band=0x%x len=%d\n", trcp_cfg->sub_band,
+	       trcp_cfg->length);
+	pByte = trcp_cfg->trpc_buf + S_DS_GEN + 4;
+	left_len = trcp_cfg->length - S_DS_GEN - 4;
+	while (left_len >= (int)sizeof(pTlvHdr->header)) {
+		pTlvHdr = (MrvlIEtypes_Data_t *)pByte;
+		pTlvHdr->header.len = le16_to_cpu(pTlvHdr->header.len);
+
+		switch (le16_to_cpu(pTlvHdr->header.type)) {
+		case TLV_TYPE_CHAN_TRPC_CONFIG:
+			trpc_tlv = (MrvlIETypes_ChanTRPCConfig_t *)pTlvHdr;
+			printf("StartFreq: %d\n", trpc_tlv->start_freq);
+			printf("ChanWidth: %d\n", trpc_tlv->width);
+			printf("ChanNum:   %d\n", trpc_tlv->chan_num);
+			mod_num = (pTlvHdr->header.len - 4) /
+				  sizeof(mod_group_setting);
+			printf("Pwr:");
+			for (i = 0; i < mod_num; i++) {
+				if (i == (mod_num - 1))
+					printf("%d,%d",
+					       trpc_tlv->mod_group[i].mod_group,
+					       trpc_tlv->mod_group[i].power);
+				else
+					printf("%d,%d,",
+					       trpc_tlv->mod_group[i].mod_group,
+					       trpc_tlv->mod_group[i].power);
+			}
+			printf("\n");
+			break;
+		default:
+			break;
+		}
+		left_len -= (pTlvHdr->header.len + sizeof(pTlvHdr->header));
+		pByte += pTlvHdr->header.len + sizeof(pTlvHdr->header);
+	}
+	if (fp_raw) {
+		switch (sub_band) {
+		case 0:
+			fprintf(fp_raw, "txpwrlimit_2g_get={\n");
+			break;
+		case 0x10:
+			fprintf(fp_raw, "txpwrlimit_5g_sub0_get={\n");
+			break;
+		case 0x11:
+			fprintf(fp_raw, "txpwrlimit_5g_sub1_get={\n");
+			break;
+		case 0x12:
+			fprintf(fp_raw, "txpwrlimit_5g_sub2_get={\n");
+			break;
+		case 0x13:
+			fprintf(fp_raw, "txpwrlimit_5g_sub3_get={\n");
+			break;
+		default:
+			break;
+		}
+		i = j = 0;
+		while (i < trcp_cfg->length) {
+			for (j = 0; j < 16; j++) {
+				fprintf(fp_raw, "%02x ", trcp_cfg->trpc_buf[i]);
+				if (++i >= trcp_cfg->length)
+					break;
+			}
+			fputc('\n', fp_raw);
+		}
+		fprintf(fp_raw, "}\n\n");
+	}
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ * @brief      Get txpwrlimit
+ *
+ * @param argc Number of arguments
+ * @param argv Pointer to the arguments array
+ *
+ * @return     MLAN_STATUS_SUCCESS/MLAN_STATUS_FAILURE
+ */
+static int process_get_txpwrlimit(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	int ret = MLAN_STATUS_SUCCESS;
+	t_u16 sub_band = 0;
+	FILE *fp_raw = NULL;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(sizeof(mlan_ds_misc_chan_trpc_cfg) +
+				strlen(argv[2]));
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, sizeof(mlan_ds_misc_chan_trpc_cfg) + strlen(argv[2]));
+	/* Sanity tests */
+	if (argc < 4) {
+		printf("Error: invalid no of arguments\n");
+		printf("mlanutl mlanX/uapX get_txpwrlimit [0/0x10/0x11/0x12/0x13/0x1f/0xff]\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	sub_band = a2hex_or_atoi(argv[3]);
+	if (argc == 5) {
+		fp_raw = fopen(argv[4], "w");
+		if (fp_raw == NULL) {
+			fprintf(stderr,
+				"Cannot open the destination raw_data file %s\n",
+				argv[4]);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+	}
+	switch (sub_band) {
+	case 0:
+	case 0x10:
+	case 0x11:
+	case 0x12:
+	case 0x13:
+		ret = get_txpwrlimit(fp_raw, argv, sub_band, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		break;
+	case 0x1f:
+		ret = get_txpwrlimit(fp_raw, argv, 0x10, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x11, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x12, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x13, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		break;
+	case 0xff:
+		ret = get_txpwrlimit(fp_raw, argv, 0, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x10, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x11, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x12, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		ret = get_txpwrlimit(fp_raw, argv, 0x13, buffer,
+				     sizeof(mlan_ds_misc_chan_trpc_cfg) +
+					     strlen(argv[2]),
+				     cmd);
+		break;
+	default:
+		printf("Error: invalid arguments\n");
+		printf("mlanutl mlanX/uapX get_txpwrlimit [0/0x10/0x11/0x12/0x13/0x1f/0xff]\n");
+		break;
+	}
+done:
+	if (fp_raw)
+		fclose(fp_raw);
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+	return ret;
+}
+
+/**
+ *  @brief Process VHT configuration
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_vhtcfg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct eth_priv_vhtcfg vhtcfg;
+	struct ifreq ifr;
+	t_u8 i, num = 0;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Sanity tests */
+	if (argc < 5) {
+		printf("Insufficient parameters\n");
+		printf("For STA interface: mlanutl mlanX vhtcfg <band> <txrx> [bwcfg] [vhtcap]\n");
+		printf("For uAP interface: mlanutl uapX vhtcfg <band> <txrx> [bwcfg] [vhtcap] [vht_tx_mcs] [vht_rx_mcs]\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: vhtcfg fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	/* the first attribute is the number of vhtcfg entries */
+	num = *buffer;
+	if (argc == 5) {
+		/* GET operation */
+		printf("11AC VHT Configuration: \n");
+		for (i = 0; i < num; i++) {
+			memcpy(&vhtcfg, buffer + 1 + i * sizeof(vhtcfg),
+			       sizeof(vhtcfg));
+			/* Band */
+			if (vhtcfg.band == 1)
+				printf("Band: 2.4G\n");
+			else
+				printf("Band: 5G\n");
+			/* BW confi9 */
+
+			if (vhtcfg.bwcfg == 0)
+				printf("    BW config: Follow BW in the 11N config\n");
+			else
+				printf("    BW config: Follow BW in VHT Capabilities\n");
+
+			/* Tx/Rx */
+			if (vhtcfg.txrx & 0x1)
+				printf("    VHT operation for Tx: 0x%08x\n",
+				       vhtcfg.vht_cap_info);
+			if (vhtcfg.txrx & 0x2)
+				/* VHT capabilities */
+				printf("    VHT Capabilities Info: 0x%08x\n",
+				       vhtcfg.vht_cap_info);
+			/* MCS */
+			if (vhtcfg.txrx & 0x2) {
+				printf("    Tx MCS set: 0x%04x\n",
+				       vhtcfg.vht_tx_mcs);
+				printf("    Rx MCS set: 0x%04x\n",
+				       vhtcfg.vht_rx_mcs);
+			}
+		}
+	} else {
+		/* SET operation */
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process dynamic bandwidth set/get
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_dyn_bw(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	int dyn_bw = 0;
+
+	/* Check arguments */
+	if (argc < 3 || argc > 4) {
+		printf("ERR:Incorrect number of arguments!\n");
+		printf("Syntax: ./mlanutl mlanX dyn_bw <bw>\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: dyn_bw fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	dyn_bw = *(int *)buffer;
+	printf("Dynamic bandwidth: 0x%02x\n", dyn_bw);
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process HT Tx configuration
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_httxcfg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	t_u32 *data = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: httxcfg fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (argc == 3) {
+		/* Get result */
+		data = (t_u32 *)buffer;
+		printf("HT Tx cfg: \n");
+		printf("    BG band:  0x%08x\n", data[0]);
+		printf("     A band:  0x%08x\n", data[1]);
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process HT capability configuration
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_htcapinfo(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct eth_priv_htcapinfo *ht_cap = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: htcapinfo fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	if (argc == 3) {
+		ht_cap = (struct eth_priv_htcapinfo *)buffer;
+		printf("HT cap info: \n");
+		printf("    BG band:  0x%08x\n", ht_cap->ht_cap_info_bg);
+		printf("     A band:  0x%08x\n", ht_cap->ht_cap_info_a);
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process HT Add BA parameters
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_addbapara(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	struct eth_priv_addba *addba = NULL;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: addbapara fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (argc == 3) {
+		/* Get */
+		addba = (struct eth_priv_addba *)buffer;
+		printf("Add BA configuration: \n");
+		printf("    Time out : %d\n", addba->time_out);
+		printf("    TX window: %d\n", addba->tx_win_size);
+		printf("    RX window: %d\n", addba->rx_win_size);
+		printf("    TX AMSDU : %d\n", addba->tx_amsdu);
+		printf("    RX AMSDU : %d\n", addba->rx_amsdu);
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process Aggregation priority table parameters
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_aggrpriotbl(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	int i;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: aggrpriotbl fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (argc == 3) {
+		/* Get */
+		printf("Aggregation priority table cfg: \n");
+		printf("    TID      AMPDU      AMSDU \n");
+		for (i = 0; i < MAX_NUM_TID; i++) {
+			printf("     %d        %3d        %3d \n", i,
+			       buffer[2 * i], buffer[2 * i + 1]);
+		}
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process HT Add BA reject configurations
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_addbareject(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	int i;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: addbareject fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (argc == 3) {
+		/* Get */
+		printf("Add BA reject configuration: \n");
+		printf("    TID      Reject \n");
+		for (i = 0; i < MAX_NUM_TID; i++) {
+			printf("     %d        %d\n", i, buffer[i]);
+		}
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+#define MASK_11AX_OM_CONTROL 0xFFF
+
+/**
+ * @brief      11ax HE capability and operation configure
+ *
+ * @param argc Number of arguments
+ * @param argv Pointer to the arguments array
+ *
+ * @return     MLAN_STATUS_SUCCESS/MLAN_STATUS_FAILURE
+ */
+
+static int process_11axcfg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd;
+	struct ifreq ifr;
+	int id_len = 0;
+	FILE *fp = NULL;
+	int ret = 0, cmd_header_len = 0;
+	char config_id[20];
+	char filename[256];
+
+	if (argc != 3 && argc != 4) {
+		printf("Err: Invalid number of arguments\n");
+		printf("Usage: ./mlanutl <interface> 11axcfg [11axcfg.conf]\n");
+		return MLAN_STATUS_FAILURE;
+	}
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	cmd_header_len = strlen(CMD_NXP) + strlen(argv[2]);
+	prepare_buffer(buffer, argv[2], 0, NULL);
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = cmd_header_len;
+	cmd->total_len = BUFFER_LENGTH;
+
+	if (argc == 4) {
+		memset(filename, 0, sizeof(filename));
+		strncpy(filename, argv[3], sizeof(filename) - 1);
+
+		fp = fopen(filename, "r");
+		if (fp == NULL) {
+			perror("fopen");
+			fprintf(stderr, "Cannot open file %s\n", argv[3]);
+			ret = -EFAULT;
+			;
+			goto done;
+		}
+
+		snprintf(config_id, sizeof(config_id), "Band");
+		id_len = fparse_for_cmd_and_hex(fp, buffer + cmd_header_len,
+						(t_u8 *)config_id);
+
+		snprintf(config_id, sizeof(config_id), "HECap");
+		fparse_for_cmd_and_hex(fp, buffer + cmd_header_len + id_len,
+				       (t_u8 *)config_id);
+		hexdump("Set 11axcfg", buffer + cmd_header_len,
+			sizeof(mlan_ds_11ax_he_cfg), ' ');
+		cmd->used_len = cmd_header_len + sizeof(mlan_ds_11ax_he_cfg);
+	}
+	/* Initialize the ifr structure */
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl: 11axcfg");
+		ret = -EFAULT;
+		goto done;
+	}
+	hexdump("11axcfg", buffer + cmd_header_len, sizeof(mlan_ds_11ax_he_cfg),
+		' ');
+done:
+	if (fp)
+		fclose(fp);
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+	return ret;
+}
+
+/**
+ *  @brief Process 11ax command
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_11axcmdcfg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	mlan_ds_11ax_cmd_cfg *axcmd = NULL;
+	t_u32 action = 0;
+	t_u32 prefix_len = 0;
+
+	if (strcmp(argv[3], "tx_omi") == 0) {
+		sprintf(argv[3], "%d", MLAN_11AXCMD_CFG_ID_TX_OMI);
+	} else if (strcmp(argv[3], "obssnbru_toltime") == 0) {
+		sprintf(argv[3], "%d", MLAN_11AXCMD_CFG_ID_OBSSNBRU_TOLTIME);
+	} else {
+		printf("ERR:unknown command %s!\n", argv[3]);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = strlen((char *)buffer);
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: 11axcmd fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prefix_len += strlen(CMD_NXP) + strlen(argv[2]);
+	action = *(t_u32 *)(buffer + prefix_len);
+	if (action == MLAN_ACT_SET) {
+		if (argv[4] == 0) {
+			printf("Invalid OBSSNBRU tolerance time: Valid range[1..3600]\n");
+			free(buffer);
+			return MLAN_STATUS_FAILURE;
+		}
+	}
+	if (action == MLAN_ACT_GET) {
+		axcmd = (mlan_ds_11ax_cmd_cfg *)(buffer + prefix_len +
+						 sizeof(t_u32));
+		switch (axcmd->sub_id) {
+		case MLAN_11AXCMD_TXOMI_SUBID:
+			printf("tx OMI: 0x%x\n", axcmd->param.txomi_cfg.omi &
+							 MASK_11AX_OM_CONTROL);
+			break;
+		case MLAN_11AXCMD_OBSS_TOLTIME_SUBID:
+			if (axcmd->param.toltime_cfg.tol_time > 3600 ||
+			    !axcmd->param.toltime_cfg.tol_time)
+				printf("OBSS Narrow Bandwidth RU tolerance Time: disabled\n");
+			else
+				printf("OBSS Narrow Bandwidth RU Tolerance Time: %d sec\n",
+				       axcmd->param.toltime_cfg.tol_time);
+			break;
+		default:
+			printf("Unknown sub_command 0x%x\n", axcmd->sub_id);
+			break;
+		}
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process tx rate configuration
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_txratecfg(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct eth_priv_tx_rate_cfg *txratecfg = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: txratecfg fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Process result */
+	txratecfg = (struct eth_priv_tx_rate_cfg *)buffer;
+	if (argc == 3) {
+		/* GET operation */
+		printf("Tx Rate Configuration: \n");
+		/* format */
+		if (txratecfg->rate_format == 0xFF) {
+			printf("    Type:       0xFF (Auto)\n");
+		} else if (txratecfg->rate_format <= 3) {
+			printf("    Type:       %d (%s)\n",
+			       txratecfg->rate_format,
+			       rate_format[txratecfg->rate_format]);
+			if (txratecfg->rate_format == 0)
+				printf("    Rate Index: %d (%s)\n",
+				       txratecfg->rate_index,
+				       lg_rate[txratecfg->rate_index]);
+			else if (txratecfg->rate_format >= 1)
+				printf("    MCS Index:  %d\n",
+				       (int)txratecfg->rate_index);
+			if (txratecfg->rate_format == 2 ||
+			    txratecfg->rate_format == 3)
+				printf("    NSS:        %d\n",
+				       (int)txratecfg->nss);
+			if (txratecfg->rate_setting == 0xffff)
+				printf("Rate setting :Preamble type/BW/GI/STBC/.. : auto \n");
+			else {
+				printf("Preamble type: %x\n",
+				       (txratecfg->rate_setting & 0x0003));
+				printf("BW: %x\n",
+				       (txratecfg->rate_setting & 0x001C) >> 2);
+				printf("LTF + GI size %x\n",
+				       (txratecfg->rate_setting & 0x0060) >> 5);
+				printf("STBC %x\n",
+				       (txratecfg->rate_setting & 0x0080) >> 7);
+				printf("DCM %x\n",
+				       (txratecfg->rate_setting & 0x0100) >> 8);
+				printf("Coding %x\n",
+				       (txratecfg->rate_setting & 0x0200) >> 9);
+				printf("maxPE %x\n",
+				       (txratecfg->rate_setting & 0x3000) >>
+					       12);
+			}
+		} else {
+			printf("    Unknown rate format.\n");
+		}
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Process host_cmd response
+ *  @param cmd_name Command name
+ *  @param buf      A pointer to the response buffer
+ *  @return         MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int process_host_cmd_resp(char *cmd_name, t_u8 *buf)
+{
+	t_u32 hostcmd_size = 0;
+	HostCmd_DS_GEN *hostcmd = NULL;
+	int ret = MLAN_STATUS_SUCCESS;
+
+	buf += strlen(CMD_NXP) + strlen(cmd_name);
+	memcpy((t_u8 *)&hostcmd_size, buf, sizeof(t_u32));
+	buf += sizeof(t_u32);
+
+	hostcmd = (HostCmd_DS_GEN *)buf;
+	hostcmd->command = le16_to_cpu(hostcmd->command);
+	hostcmd->size = le16_to_cpu(hostcmd->size);
+	hostcmd->seq_num = le16_to_cpu(hostcmd->seq_num);
+	hostcmd->result = le16_to_cpu(hostcmd->result);
+
+	hostcmd->command &= ~HostCmd_RET_BIT;
+	if (!hostcmd->result) {
+		switch (hostcmd->command) {
+		case HostCmd_CMD_CFG_DATA: {
+			HostCmd_DS_802_11_CFG_DATA *pstcfgData =
+				(HostCmd_DS_802_11_CFG_DATA *)(buf + S_DS_GEN);
+			pstcfgData->data_len =
+				le16_to_cpu(pstcfgData->data_len);
+			pstcfgData->action = le16_to_cpu(pstcfgData->action);
+
+			if (pstcfgData->action == HostCmd_ACT_GEN_GET) {
+				hexdump("cfgdata", pstcfgData->data,
+					pstcfgData->data_len, ' ');
+			}
+			break;
+		}
+		case HostCmd_CMD_802_11_TPC_ADAPT_REQ: {
+			mlan_ioctl_11h_tpc_resp *tpcIoctlResp =
+				(mlan_ioctl_11h_tpc_resp *)(buf + S_DS_GEN);
+			if (tpcIoctlResp->status_code == 0) {
+				printf("tpcrequest:  txPower(%d), linkMargin(%d), rssi(%d)\n",
+				       tpcIoctlResp->tx_power,
+				       tpcIoctlResp->link_margin,
+				       tpcIoctlResp->rssi);
+			} else {
+				printf("tpcrequest:  failure, status = %d\n",
+				       tpcIoctlResp->status_code);
+			}
+			break;
+		}
+		case HostCmd_CMD_802_11_CRYPTO: {
+			t_u16 alg = le16_to_cpu(
+				(t_u16) * (buf + S_DS_GEN + sizeof(t_u16)));
+			if (alg == CIPHER_TEST_AES_CCM ||
+			    alg == CIPHER_TEST_GCMP) {
+				HostCmd_DS_802_11_CRYPTO_AES_CCM *cmd_aes_ccm =
+					(HostCmd_DS_802_11_CRYPTO_AES_CCM
+						 *)(buf + S_DS_GEN);
+
+				cmd_aes_ccm->encdec =
+					le16_to_cpu(cmd_aes_ccm->encdec);
+				cmd_aes_ccm->algorithm =
+					le16_to_cpu(cmd_aes_ccm->algorithm);
+				cmd_aes_ccm->key_length =
+					le16_to_cpu(cmd_aes_ccm->key_length);
+				cmd_aes_ccm->nonce_length =
+					le16_to_cpu(cmd_aes_ccm->nonce_length);
+				cmd_aes_ccm->AAD_length =
+					le16_to_cpu(cmd_aes_ccm->AAD_length);
+				cmd_aes_ccm->data.header.type = le16_to_cpu(
+					cmd_aes_ccm->data.header.type);
+				cmd_aes_ccm->data.header.len = le16_to_cpu(
+					cmd_aes_ccm->data.header.len);
+
+				printf("crypto_result: encdec=%d algorithm=%d, KeyLen=%d,"
+				       " NonceLen=%d,AADLen=%d,dataLen=%d\n",
+				       cmd_aes_ccm->encdec,
+				       cmd_aes_ccm->algorithm,
+				       cmd_aes_ccm->key_length,
+				       cmd_aes_ccm->nonce_length,
+				       cmd_aes_ccm->AAD_length,
+				       cmd_aes_ccm->data.header.len);
+
+				hexdump("Key", cmd_aes_ccm->key,
+					cmd_aes_ccm->key_length, ' ');
+				hexdump("Nonce", cmd_aes_ccm->nonce,
+					cmd_aes_ccm->nonce_length, ' ');
+				hexdump("AAD", cmd_aes_ccm->AAD,
+					cmd_aes_ccm->AAD_length, ' ');
+				hexdump("Data", cmd_aes_ccm->data.data,
+					cmd_aes_ccm->data.header.len, ' ');
+			} else if (alg == CIPHER_TEST_WAPI) {
+				HostCmd_DS_802_11_CRYPTO_WAPI *cmd_wapi =
+					(HostCmd_DS_802_11_CRYPTO_WAPI
+						 *)(buf + S_DS_GEN);
+
+				cmd_wapi->encdec =
+					le16_to_cpu(cmd_wapi->encdec);
+				cmd_wapi->algorithm =
+					le16_to_cpu(cmd_wapi->algorithm);
+				cmd_wapi->key_length =
+					le16_to_cpu(cmd_wapi->key_length);
+				cmd_wapi->nonce_length =
+					le16_to_cpu(cmd_wapi->nonce_length);
+				cmd_wapi->AAD_length =
+					le16_to_cpu(cmd_wapi->AAD_length);
+
+				printf("crypto_result: encdec=%d algorithm=%d, KeyLen=%d,"
+				       " NonceLen=%d,AADLen=%d,dataLen=%d\n",
+				       cmd_wapi->encdec, cmd_wapi->algorithm,
+				       cmd_wapi->key_length,
+				       cmd_wapi->nonce_length,
+				       cmd_wapi->AAD_length,
+				       cmd_wapi->data_length);
+
+				hexdump("Key", cmd_wapi->key,
+					cmd_wapi->key_length, ' ');
+				hexdump("Nonce", cmd_wapi->nonce,
+					cmd_wapi->nonce_length, ' ');
+				hexdump("AAD", cmd_wapi->AAD,
+					cmd_wapi->AAD_length, ' ');
+			} else {
+				HostCmd_DS_802_11_CRYPTO *cmd =
+					(HostCmd_DS_802_11_CRYPTO *)(buf +
+								     S_DS_GEN);
+				cmd->encdec = le16_to_cpu(cmd->encdec);
+				cmd->algorithm = le16_to_cpu(cmd->algorithm);
+				cmd->key_IV_length =
+					le16_to_cpu(cmd->key_IV_length);
+				cmd->key_length = le16_to_cpu(cmd->key_length);
+				cmd->data.header.type =
+					le16_to_cpu(cmd->data.header.type);
+				cmd->data.header.len =
+					le16_to_cpu(cmd->data.header.len);
+
+				printf("crypto_result: encdec=%d algorithm=%d,KeyIVLen=%d,"
+				       " KeyLen=%d,dataLen=%d\n",
+				       cmd->encdec, cmd->algorithm,
+				       cmd->key_IV_length, cmd->key_length,
+				       cmd->data.header.len);
+				hexdump("KeyIV", cmd->keyIV, cmd->key_IV_length,
+					' ');
+				hexdump("Key", cmd->key, cmd->key_length, ' ');
+				hexdump("Data", cmd->data.data,
+					cmd->data.header.len, ' ');
+			}
+			break;
+		}
+		case HostCmd_CMD_802_11_AUTO_TX: {
+			HostCmd_DS_802_11_AUTO_TX *at =
+				(HostCmd_DS_802_11_AUTO_TX *)(buf + S_DS_GEN);
+
+			if (le16_to_cpu(at->action) == HostCmd_ACT_GEN_GET) {
+				if (S_DS_GEN + sizeof(at->action) ==
+				    hostcmd->size) {
+					printf("auto_tx not configured\n");
+
+				} else {
+					MrvlIEtypesHeader_t *header =
+						&at->auto_tx.header;
+
+					header->type =
+						le16_to_cpu(header->type);
+					header->len = le16_to_cpu(header->len);
+
+					if ((S_DS_GEN + sizeof(at->action) +
+						     sizeof(MrvlIEtypesHeader_t) +
+						     header->len ==
+					     hostcmd->size) &&
+					    (header->type ==
+					     TLV_TYPE_AUTO_TX)) {
+						AutoTx_MacFrame_t *atmf =
+							&at->auto_tx
+								 .auto_tx_mac_frame;
+
+						printf("Interval: %d second(s)\n",
+						       le16_to_cpu(
+							       atmf->interval));
+						printf("Priority: %#x\n",
+						       atmf->priority);
+						printf("Frame Length: %d\n",
+						       le16_to_cpu(
+							       atmf->frame_len));
+						printf("Dest Mac Address: "
+						       "%02x:%02x:%02x:%02x:%02x:%02x\n",
+						       atmf->dest_mac_addr[0],
+						       atmf->dest_mac_addr[1],
+						       atmf->dest_mac_addr[2],
+						       atmf->dest_mac_addr[3],
+						       atmf->dest_mac_addr[4],
+						       atmf->dest_mac_addr[5]);
+						printf("Src Mac Address: "
+						       "%02x:%02x:%02x:%02x:%02x:%02x\n",
+						       atmf->src_mac_addr[0],
+						       atmf->src_mac_addr[1],
+						       atmf->src_mac_addr[2],
+						       atmf->src_mac_addr[3],
+						       atmf->src_mac_addr[4],
+						       atmf->src_mac_addr[5]);
+
+						hexdump("Frame Payload",
+							atmf->payload,
+							le16_to_cpu(
+								atmf->frame_len) -
+								MLAN_MAC_ADDR_LENGTH *
+									2,
+							' ');
+					} else {
+						printf("incorrect auto_tx command response\n");
+					}
+				}
+			}
+			break;
+		}
+		case HostCmd_CMD_802_11_SUBSCRIBE_EVENT: {
+			HostCmd_DS_802_11_SUBSCRIBE_EVENT *se =
+				(HostCmd_DS_802_11_SUBSCRIBE_EVENT *)(buf +
+								      S_DS_GEN);
+			if (le16_to_cpu(se->action) == HostCmd_ACT_GEN_GET) {
+				int len =
+					S_DS_GEN +
+					sizeof(HostCmd_DS_802_11_SUBSCRIBE_EVENT);
+				printf("\nEvent\t\tValue\tFreq\tsubscribed\n\n");
+				while (len < hostcmd->size) {
+					MrvlIEtypesHeader_t *header =
+						(MrvlIEtypesHeader_t *)(buf +
+									len);
+					switch (le16_to_cpu(header->type)) {
+					case TLV_TYPE_RSSI_LOW: {
+						MrvlIEtypes_RssiThreshold_t *low_rssi =
+							(MrvlIEtypes_RssiThreshold_t
+								 *)(buf + len);
+						printf("Beacon Low RSSI\t%d\t%d\t%s\n",
+						       low_rssi->RSSI_value,
+						       low_rssi->RSSI_freq,
+						       (le16_to_cpu(se->events) &
+							0x0001) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_SNR_LOW: {
+						MrvlIEtypes_SnrThreshold_t *low_snr =
+							(MrvlIEtypes_SnrThreshold_t
+								 *)(buf + len);
+						printf("Beacon Low SNR\t%d\t%d\t%s\n",
+						       low_snr->SNR_value,
+						       low_snr->SNR_freq,
+						       (le16_to_cpu(se->events) &
+							0x0002) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_FAILCOUNT: {
+						MrvlIEtypes_FailureCount_t
+							*failure_count =
+								(MrvlIEtypes_FailureCount_t
+									 *)(buf +
+									    len);
+						printf("Failure Count\t%d\t%d\t%s\n",
+						       failure_count->fail_value,
+						       failure_count->fail_freq,
+						       (le16_to_cpu(se->events) &
+							0x0004) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_BCNMISS: {
+						MrvlIEtypes_BeaconsMissed_t
+							*bcn_missed =
+								(MrvlIEtypes_BeaconsMissed_t
+									 *)(buf +
+									    len);
+						printf("Beacon Missed\t%d\tN/A\t%s\n",
+						       bcn_missed->beacon_missed,
+						       (le16_to_cpu(se->events) &
+							0x0008) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_RSSI_HIGH: {
+						MrvlIEtypes_RssiThreshold_t
+							*high_rssi =
+								(MrvlIEtypes_RssiThreshold_t
+									 *)(buf +
+									    len);
+						printf("Bcn High RSSI\t%d\t%d\t%s\n",
+						       high_rssi->RSSI_value,
+						       high_rssi->RSSI_freq,
+						       (le16_to_cpu(se->events) &
+							0x0010) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+
+					case TLV_TYPE_SNR_HIGH: {
+						MrvlIEtypes_SnrThreshold_t *high_snr =
+							(MrvlIEtypes_SnrThreshold_t
+								 *)(buf + len);
+						printf("Beacon High SNR\t%d\t%d\t%s\n",
+						       high_snr->SNR_value,
+						       high_snr->SNR_freq,
+						       (le16_to_cpu(se->events) &
+							0x0020) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_RSSI_LOW_DATA: {
+						MrvlIEtypes_RssiThreshold_t *low_rssi =
+							(MrvlIEtypes_RssiThreshold_t
+								 *)(buf + len);
+						printf("Data Low RSSI\t%d\t%d\t%s\n",
+						       low_rssi->RSSI_value,
+						       low_rssi->RSSI_freq,
+						       (le16_to_cpu(se->events) &
+							0x0040) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_SNR_LOW_DATA: {
+						MrvlIEtypes_SnrThreshold_t *low_snr =
+							(MrvlIEtypes_SnrThreshold_t
+								 *)(buf + len);
+						printf("Data Low SNR\t%d\t%d\t%s\n",
+						       low_snr->SNR_value,
+						       low_snr->SNR_freq,
+						       (le16_to_cpu(se->events) &
+							0x0080) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_RSSI_HIGH_DATA: {
+						MrvlIEtypes_RssiThreshold_t
+							*high_rssi =
+								(MrvlIEtypes_RssiThreshold_t
+									 *)(buf +
+									    len);
+						printf("Data High RSSI\t%d\t%d\t%s\n",
+						       high_rssi->RSSI_value,
+						       high_rssi->RSSI_freq,
+						       (le16_to_cpu(se->events) &
+							0x0100) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_SNR_HIGH_DATA: {
+						MrvlIEtypes_SnrThreshold_t *high_snr =
+							(MrvlIEtypes_SnrThreshold_t
+								 *)(buf + len);
+						printf("Data High SNR\t%d\t%d\t%s\n",
+						       high_snr->SNR_value,
+						       high_snr->SNR_freq,
+						       (le16_to_cpu(se->events) &
+							0x0200) ?
+							       "yes" :
+							       "no");
+						break;
+					}
+					case TLV_TYPE_LINK_QUALITY: {
+						MrvlIEtypes_LinkQuality_t *link_qual =
+							(MrvlIEtypes_LinkQuality_t
+								 *)(buf + len);
+						printf("Link Quality Parameters:\n");
+						printf("------------------------\n");
+						printf("Link Quality Event Subscribed\t%s\n",
+						       (le16_to_cpu(se->events) &
+							0x0400) ?
+							       "yes" :
+							       "no");
+						printf("Link SNR Threshold   = %d\n",
+						       le16_to_cpu(
+							       link_qual
+								       ->link_SNR_thrs));
+						printf("Link SNR Frequency   = %d\n",
+						       le16_to_cpu(
+							       link_qual
+								       ->link_SNR_freq));
+						printf("Min Rate Value       = %d\n",
+						       le16_to_cpu(
+							       link_qual
+								       ->min_rate_val));
+						printf("Min Rate Frequency   = %d\n",
+						       le16_to_cpu(
+							       link_qual
+								       ->min_rate_freq));
+						printf("Tx Latency Value     = %d\n",
+						       le32_to_cpu(
+							       link_qual
+								       ->tx_latency_val));
+						printf("Tx Latency Threshold = %d\n",
+						       le32_to_cpu(
+							       link_qual
+								       ->tx_latency_thrs));
+
+						break;
+					}
+					case TLV_TYPE_PRE_BEACON_LOST: {
+						MrvlIEtypes_PreBeaconLost_t
+							*pre_bcn_lost =
+								(MrvlIEtypes_PreBeaconLost_t
+									 *)(buf +
+									    len);
+						printf("------------------------\n");
+						printf("Pre-Beacon Lost Event Subscribed\t%s\n",
+						       (le16_to_cpu(se->events) &
+							0x0800) ?
+							       "yes" :
+							       "no");
+						printf("Pre-Beacon Lost: %d\n",
+						       pre_bcn_lost
+							       ->pre_beacon_lost);
+						break;
+					}
+					default:
+						printf("Unknown subscribed event TLV Type=%#x,"
+						       " Len=%d\n",
+						       le16_to_cpu(
+							       header->type),
+						       le16_to_cpu(
+							       header->len));
+						break;
+					}
+
+					len += (sizeof(MrvlIEtypesHeader_t) +
+						le16_to_cpu(header->len));
+				}
+			}
+			break;
+		}
+		case HostCmd_CMD_MAC_REG_ACCESS:
+		case HostCmd_CMD_BBP_REG_ACCESS:
+		case HostCmd_CMD_RF_REG_ACCESS:
+		case HostCmd_CMD_CAU_REG_ACCESS: {
+			HostCmd_DS_REG *preg =
+				(HostCmd_DS_REG *)(buf + S_DS_GEN);
+			preg->action = le16_to_cpu(preg->action);
+			if (preg->action == HostCmd_ACT_GEN_GET) {
+				preg->value = le32_to_cpu(preg->value);
+				printf("value = 0x%08x\n", preg->value);
+			}
+			break;
+		}
+		case HostCmd_CMD_MEM_ACCESS: {
+			HostCmd_DS_MEM *pmem =
+				(HostCmd_DS_MEM *)(buf + S_DS_GEN);
+			pmem->action = le16_to_cpu(pmem->action);
+			if (pmem->action == HostCmd_ACT_GEN_GET) {
+				pmem->value = le32_to_cpu(pmem->value);
+				printf("value = 0x%08x\n", pmem->value);
+			}
+			break;
+		}
+		case HostCmd_CMD_LINK_STATS_SUMMARY: {
+			HostCmd_DS_LINK_STATS_SUMMARY *linkstats =
+				(HostCmd_DS_LINK_STATS_SUMMARY *)(buf +
+								  S_DS_GEN);
+			/* GET operation */
+			printf("Link Statistics: \n");
+			/* format */
+			printf("Duration:   %u\n",
+			       (int)le32_to_cpu(
+				       linkstats->timeSinceLastQuery_ms));
+
+			printf("Beacon count:     %u\n",
+			       le16_to_cpu(linkstats->bcnCnt));
+			printf("Beacon missing:   %u\n",
+			       le16_to_cpu(linkstats->bcnMiss));
+			printf("Beacon RSSI avg:  %d\n",
+			       le16_to_cpu(linkstats->bcnRssiAvg));
+			printf("Beacon SNR avg:   %d\n",
+			       le16_to_cpu(linkstats->bcnSnrAvg));
+
+			printf("Rx packets:       %u\n",
+			       (int)le32_to_cpu(linkstats->rxPkts));
+			printf("Rx RSSI avg:      %d\n",
+			       le16_to_cpu(linkstats->rxRssiAvg));
+			printf("Rx SNR avg:       %d\n",
+			       le16_to_cpu(linkstats->rxSnrAvg));
+
+			printf("Tx packets:       %u\n",
+			       (int)le32_to_cpu(linkstats->txPkts));
+			printf("Tx Attempts:      %u\n",
+			       (int)le32_to_cpu(linkstats->txAttempts));
+			printf("Tx Failures:      %u\n",
+			       (int)le32_to_cpu(linkstats->txFailures));
+			printf("Tx Initial Rate:  %s\n",
+			       rateIdStr[linkstats->txInitRate]);
+
+			printf("Tx AC VO:         %u [ %u ]\n",
+			       le16_to_cpu(linkstats->txQueuePktCnt[WMM_AC_VO]),
+			       (int)le32_to_cpu(
+				       linkstats->txQueueDelay[WMM_AC_VO]) /
+				       1000);
+			printf("Tx AC VI:         %u [ %u ]\n",
+			       le16_to_cpu(linkstats->txQueuePktCnt[WMM_AC_VI]),
+			       (int)le32_to_cpu(
+				       linkstats->txQueueDelay[WMM_AC_VI]) /
+				       1000);
+			printf("Tx AC BE:         %u [ %u ]\n",
+			       le16_to_cpu(linkstats->txQueuePktCnt[WMM_AC_BE]),
+			       (int)le32_to_cpu(
+				       linkstats->txQueueDelay[WMM_AC_BE]) /
+				       1000);
+			printf("Tx AC BK:         %u [ %u ]\n",
+			       le16_to_cpu(linkstats->txQueuePktCnt[WMM_AC_BK]),
+			       (int)le32_to_cpu(
+				       linkstats->txQueueDelay[WMM_AC_BK]) /
+				       1000);
+			break;
+		}
+		case HostCmd_CMD_WMM_PARAM_CONFIG: {
+			HostCmd_DS_WMM_PARAM_CONFIG *wmm_param =
+				(HostCmd_DS_WMM_PARAM_CONFIG *)(buf + S_DS_GEN);
+			printf("WMM Params: \n");
+			printf("\tBE: AIFSN=%d, CW_MAX=%d CW_MIN=%d, TXOP=%d\n",
+			       wmm_param->ac_params[AC_BE].aci_aifsn.aifsn,
+			       wmm_param->ac_params[AC_BE].ecw.ecw_max,
+			       wmm_param->ac_params[AC_BE].ecw.ecw_min,
+			       le16_to_cpu(
+				       wmm_param->ac_params[AC_BE].tx_op_limit));
+			printf("\tBK: AIFSN=%d, CW_MAX=%d CW_MIN=%d, TXOP=%d\n",
+			       wmm_param->ac_params[AC_BK].aci_aifsn.aifsn,
+			       wmm_param->ac_params[AC_BK].ecw.ecw_max,
+			       wmm_param->ac_params[AC_BK].ecw.ecw_min,
+			       le16_to_cpu(
+				       wmm_param->ac_params[AC_BK].tx_op_limit));
+			printf("\tVI: AIFSN=%d, CW_MAX=%d CW_MIN=%d, TXOP=%d\n",
+			       wmm_param->ac_params[AC_VI].aci_aifsn.aifsn,
+			       wmm_param->ac_params[AC_VI].ecw.ecw_max,
+			       wmm_param->ac_params[AC_VI].ecw.ecw_min,
+			       le16_to_cpu(
+				       wmm_param->ac_params[AC_VI].tx_op_limit));
+			printf("\tVO: AIFSN=%d, CW_MAX=%d CW_MIN=%d, TXOP=%d\n",
+			       wmm_param->ac_params[AC_VO].aci_aifsn.aifsn,
+			       wmm_param->ac_params[AC_VO].ecw.ecw_max,
+			       wmm_param->ac_params[AC_VO].ecw.ecw_min,
+			       le16_to_cpu(
+				       wmm_param->ac_params[AC_VO].tx_op_limit));
+			break;
+		}
+		default:
+			printf("HOSTCMD_RESP: CmdCode=%#04x, Size=%#04x,"
+			       " SeqNum=%#04x, Result=%#04x\n",
+			       hostcmd->command, hostcmd->size,
+			       hostcmd->seq_num, hostcmd->result);
+			hexdump("payload", (t_void *)(buf + S_DS_GEN),
+				hostcmd->size - S_DS_GEN, ' ');
+			break;
+		}
+	} else {
+		printf("HOSTCMD failed: CmdCode=%#04x, Size=%#04x,"
+		       " SeqNum=%#04x, Result=%#04x\n",
+		       hostcmd->command, hostcmd->size, hostcmd->seq_num,
+		       hostcmd->result);
+	}
+	return ret;
+}
+
+/**
+ *  @brief Process hssetpara configuration
+ *  @param argc   Number of arguments
+ *  @param argv   A pointer to arguments array
+ *  @return     MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_hssetpara(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	prepare_buffer(buffer, argv[2], (argc - 3), &argv[3]);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: hssetpara fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+	return MLAN_STATUS_SUCCESS;
+}
+
+#define STACK_NBYTES 100 /**< Number of bytes in stack */
+#define MAX_BYTESEQ 6 /**< Maximum byte sequence */
+#define TYPE_DNUM 1 /**< decimal number */
+#define TYPE_BYTESEQ 2 /**< byte sequence */
+#define MAX_OPERAND 0x40 /**< Maximum operands */
+#define TYPE_EQ (MAX_OPERAND + 1) /**< byte comparison:    == operator */
+#define TYPE_EQ_DNUM (MAX_OPERAND + 2) /**< decimal comparison: =d operator */
+#define TYPE_EQ_BIT (MAX_OPERAND + 3) /**< bit comparison:     =b operator */
+#define TYPE_AND (MAX_OPERAND + 4) /**< && operator */
+#define TYPE_OR (MAX_OPERAND + 5) /**< || operator */
+
+typedef struct {
+	t_u16 sp; /**< Stack pointer */
+	t_u8 byte[STACK_NBYTES]; /**< Stack */
+} mstack_t;
+
+typedef struct {
+	t_u8 type; /**< Type */
+	t_u8 reserve[3]; /**< so 4-byte align val array */
+	/* byte sequence is the largest among all the operands and operators. */
+	/* byte sequence format: 1 byte of num of bytes, then variable num bytes
+	 */
+	t_u8 val[MAX_BYTESEQ + 1]; /**< Value */
+} op_t;
+
+/**
+ *  @brief push data to stack
+ *
+ *  @param s			a pointer to mstack_t structure
+ *
+ *  @param nbytes		number of byte to push to stack
+ *
+ *  @param val			a pointer to data buffer
+ *
+ *  @return			TRUE-- sucess , FALSE -- fail
+ *
+ */
+static int push_n(mstack_t *s, t_u8 nbytes, t_u8 *val)
+{
+	if ((s->sp + nbytes) < STACK_NBYTES) {
+		memcpy((void *)(s->byte + s->sp), (const void *)val,
+		       (size_t)nbytes);
+		s->sp += nbytes;
+		/* printf("push: n %d sp %d\n", nbytes, s->sp); */
+		return TRUE;
+	} else /* stack full */
+		return FALSE;
+}
+
+/**
+ *  @brief push data to stack
+ *
+ *  @param s			a pointer to mstack_t structure
+ *
+ *  @param op			a pointer to op_t structure
+ *
+ *  @return			TRUE-- sucess , FALSE -- fail
+ *
+ */
+static int push(mstack_t *s, op_t *op)
+{
+	t_u8 nbytes;
+	switch (op->type) {
+	case TYPE_DNUM:
+		if (push_n(s, 4, op->val))
+			return push_n(s, 1, &op->type);
+		return FALSE;
+	case TYPE_BYTESEQ:
+		nbytes = op->val[0];
+		if (push_n(s, nbytes, op->val + 1) && push_n(s, 1, op->val) &&
+		    push_n(s, 1, &op->type))
+			return TRUE;
+		return FALSE;
+	default:
+		return push_n(s, 1, &op->type);
+	}
+}
+
+/**
+ *  @brief parse RPN string
+ *
+ *  @param s			a pointer to Null-terminated string to scan.
+ *
+ *  @param first_time		a pointer to return first_time
+ *
+ *  @return			A pointer to the last token found in string.
+ *  				NULL is returned when there are no more tokens to be
+ * found.
+ *
+ */
+static char *getop(char *s, int *first_time)
+{
+	const char delim[] = " \t\n";
+	char *p;
+	if (*first_time) {
+		p = strtok(s, delim);
+		*first_time = FALSE;
+	} else {
+		p = strtok(NULL, delim);
+	}
+	return p;
+}
+
+/**
+ *  @brief Verify hex digit.
+ *
+ *  @param c			input ascii char
+ *  @param h			a pointer to return integer value of the digit
+ * char.
+ *  @return			TURE -- c is hex digit, FALSE -- c is not hex
+ * digit.
+ */
+static int ishexdigit(char c, t_u8 *h)
+{
+	if (c >= '0' && c <= '9') {
+		*h = c - '0';
+		return TRUE;
+	} else if (c >= 'a' && c <= 'f') {
+		*h = c - 'a' + 10;
+		return TRUE;
+	} else if (c >= 'A' && c <= 'F') {
+		*h = c - 'A' + 10;
+		return TRUE;
+	}
+	return FALSE;
+}
+
+/**
+ *  @brief convert hex string to integer.
+ *
+ *  @param s			A pointer to hex string, string length up to 2
+ * digits.
+ *  @return			integer value.
+ */
+static t_u8 hex_atoi(char *s)
+{
+	int i;
+	t_u8 digit; /* digital value */
+	t_u8 t = 0; /* total value */
+
+	for (i = 0, t = 0; ishexdigit(s[i], &digit) && i < 2; i++)
+		t = 16 * t + digit;
+	return t;
+}
+
+/**
+ *  @brief Parse byte sequence in hex format string to a byte sequence.
+ *
+ *  @param opstr		A pointer to byte sequence in hex format string, with
+ * ':' as delimiter between two byte.
+ *  @param val			A pointer to return byte sequence string
+ *  @return			NA
+ */
+static void parse_hex(char *opstr, t_u8 *val)
+{
+	char delim = ':';
+	char *p;
+	char *q;
+	t_u8 i;
+
+	/* +1 is for skipping over the preceding h character. */
+	p = opstr + 1;
+
+	/* First byte */
+	val[1] = hex_atoi(p++);
+
+	/* Parse subsequent bytes. */
+	/* Each byte is preceded by the : character. */
+	for (i = 1; *p; i++) {
+		q = strchr(p, delim);
+		if (!q)
+			break;
+		p = q + 1;
+		val[i + 1] = hex_atoi(p);
+	}
+	/* Set num of bytes */
+	val[0] = i;
+}
+
+/**
+ *  @brief str2bin, convert RPN string to binary format
+ *
+ *  @param str			A pointer to rpn string
+ *  @param stack		A pointer to mstack_t structure
+ *  @return			MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int str2bin(char *str, mstack_t *stack)
+{
+	int first_time;
+	char *opstr;
+	op_t op; /* operator/operand */
+	int dnum;
+	int ret = MLAN_STATUS_SUCCESS;
+
+	memset(stack, 0, sizeof(mstack_t));
+	first_time = TRUE;
+	while ((opstr = getop(str, &first_time)) != NULL) {
+		if (isdigit((unsigned char)*opstr)) {
+			op.type = TYPE_DNUM;
+			dnum = cpu_to_le32(atoi(opstr));
+			memcpy((t_u8 *)op.val, &dnum, sizeof(dnum));
+			if (!push(stack, &op)) {
+				printf("push decimal number failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (*opstr == 'h') {
+			op.type = TYPE_BYTESEQ;
+			parse_hex(opstr, op.val);
+			if (!push(stack, &op)) {
+				printf("push byte sequence failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (!strcmp(opstr, "==")) {
+			op.type = TYPE_EQ;
+			if (!push(stack, &op)) {
+				printf("push byte cmp operator failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (!strcmp(opstr, "=d")) {
+			op.type = TYPE_EQ_DNUM;
+			if (!push(stack, &op)) {
+				printf("push decimal cmp operator failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (!strcmp(opstr, "=b")) {
+			op.type = TYPE_EQ_BIT;
+			if (!push(stack, &op)) {
+				printf("push bit cmp operator failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (!strcmp(opstr, "&&")) {
+			op.type = TYPE_AND;
+			if (!push(stack, &op)) {
+				printf("push AND operator failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else if (!strcmp(opstr, "||")) {
+			op.type = TYPE_OR;
+			if (!push(stack, &op)) {
+				printf("push OR operator failed\n");
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+		} else {
+			printf("Unknown operand\n");
+			ret = MLAN_STATUS_FAILURE;
+			break;
+		}
+	}
+	return ret;
+}
+
+#define FILTER_BYTESEQ TYPE_EQ /**< byte sequence */
+#define FILTER_DNUM TYPE_EQ_DNUM /**< decimal number */
+#define FILTER_BITSEQ TYPE_EQ_BIT /**< bit sequence */
+#define FILTER_TEST (FILTER_BITSEQ + 1) /**< test */
+
+#define NAME_TYPE 1 /**< Field name 'type' */
+#define NAME_PATTERN 2 /**< Field name 'pattern' */
+#define NAME_OFFSET 3 /**< Field name 'offset' */
+#define NAME_NUMBYTE 4 /**< Field name 'numbyte' */
+#define NAME_REPEAT 5 /**< Field name 'repeat' */
+#define NAME_BYTE 6 /**< Field name 'byte' */
+#define NAME_MASK 7 /**< Field name 'mask' */
+#define NAME_DEST 8 /**< Field name 'dest' */
+
+static struct mef_fields {
+	char *name; /**< Name */
+	t_s8 nameid; /**< Name Id. */
+} mef_fields[] = {{"type", NAME_TYPE},	   {"pattern", NAME_PATTERN},
+		  {"offset", NAME_OFFSET}, {"numbyte", NAME_NUMBYTE},
+		  {"repeat", NAME_REPEAT}, {"byte", NAME_BYTE},
+		  {"mask", NAME_MASK},	   {"dest", NAME_DEST}};
+
+/**
+ *  @brief get filter data
+ *
+ *  @param fp			A pointer to file stream
+ *  @param ln			A pointer to line number
+ *  @param buf			A pointer to hostcmd data
+ *  @param size			A pointer to the return size of hostcmd buffer
+ *  @return			MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int mlan_get_filter_data(FILE *fp, int *ln, t_u8 *buf, t_u16 *size)
+{
+	t_s32 errors = 0, i;
+	char line[256], *pos = NULL, *pos1 = NULL;
+	t_u16 type = 0;
+	t_u32 pattern = 0;
+	t_u16 repeat = 0;
+	t_u16 offset = 0;
+	char byte_seq[50];
+	char mask_seq[50];
+	t_u16 numbyte = 0;
+	t_s8 type_find = 0;
+	t_s8 pattern_find = 0;
+	t_s8 offset_find = 0;
+	t_s8 numbyte_find = 0;
+	t_s8 repeat_find = 0;
+	t_s8 byte_find = 0;
+	t_s8 mask_find = 0;
+	t_s8 dest_find = 0;
+	char dest_seq[50];
+
+	*size = 0;
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), ln))) {
+		if (strcmp(pos, "}") == 0) {
+			break;
+		}
+		pos1 = strchr(pos, '=');
+		if (pos1 == NULL) {
+			printf("Line %d: Invalid mef_filter line '%s'\n", *ln,
+			       pos);
+			errors++;
+			continue;
+		}
+		*pos1++ = '\0';
+		for (i = 0; (t_u32)i < NELEMENTS(mef_fields); i++) {
+			if (strncmp(pos, mef_fields[i].name,
+				    strlen(mef_fields[i].name)) == 0) {
+				switch (mef_fields[i].nameid) {
+				case NAME_TYPE:
+					type = a2hex_or_atoi(pos1);
+					if ((type != FILTER_DNUM) &&
+					    (type != FILTER_BYTESEQ) &&
+					    (type != FILTER_BITSEQ) &&
+					    (type != FILTER_TEST)) {
+						printf("Invalid filter type:%d\n",
+						       type);
+						return MLAN_STATUS_FAILURE;
+					}
+					type_find = 1;
+					break;
+				case NAME_PATTERN:
+					pattern = a2hex_or_atoi(pos1);
+					pattern_find = 1;
+					break;
+				case NAME_OFFSET:
+					offset = a2hex_or_atoi(pos1);
+					offset_find = 1;
+					break;
+				case NAME_NUMBYTE:
+					numbyte = a2hex_or_atoi(pos1);
+					numbyte_find = 1;
+					break;
+				case NAME_REPEAT:
+					repeat = a2hex_or_atoi(pos1);
+					repeat_find = 1;
+					break;
+				case NAME_BYTE:
+					memset(byte_seq, 0, sizeof(byte_seq));
+					strncpy(byte_seq, pos1,
+						(sizeof(byte_seq) - 1));
+					byte_find = 1;
+					break;
+				case NAME_MASK:
+					memset(mask_seq, 0, sizeof(mask_seq));
+					strncpy(mask_seq, pos1,
+						(sizeof(mask_seq) - 1));
+					mask_find = 1;
+					break;
+				case NAME_DEST:
+					memset(dest_seq, 0, sizeof(dest_seq));
+					strncpy(dest_seq, pos1,
+						(sizeof(dest_seq) - 1));
+					dest_find = 1;
+					break;
+				}
+				break;
+			}
+		}
+		if (i == NELEMENTS(mef_fields)) {
+			printf("Line %d: unknown mef field '%s'.\n", *line,
+			       pos);
+			errors++;
+		}
+	}
+	if (type_find == 0) {
+		printf("Can not find filter type\n");
+		return MLAN_STATUS_FAILURE;
+	}
+	switch (type) {
+	case FILTER_DNUM:
+		if (!pattern_find || !offset_find || !numbyte_find) {
+			printf("Missing field for FILTER_DNUM: pattern=%d,offset=%d,numbyte=%d\n",
+			       pattern_find, offset_find, numbyte_find);
+			return MLAN_STATUS_FAILURE;
+		}
+		memset(line, 0, sizeof(line));
+		snprintf(line, sizeof(line), "%d %d %d =d ", pattern, offset,
+			 numbyte);
+		break;
+	case FILTER_BYTESEQ:
+		if (!byte_find || !offset_find || !repeat_find) {
+			printf("Missing field for FILTER_BYTESEQ: byte=%d,offset=%d,repeat=%d\n",
+			       byte_find, offset_find, repeat_find);
+			return MLAN_STATUS_FAILURE;
+		}
+		memset(line, 0, sizeof(line));
+		snprintf(line, sizeof(line), "%d h%s %d == ", repeat, byte_seq,
+			 offset);
+		break;
+	case FILTER_BITSEQ:
+		if (!byte_find || !offset_find || !mask_find) {
+			printf("Missing field for FILTER_BITSEQ: byte=%d,offset=%d,mask_find=%d\n",
+			       byte_find, offset_find, mask_find);
+			return MLAN_STATUS_FAILURE;
+		}
+		if (strlen(byte_seq) != strlen(mask_seq)) {
+			printf("byte string's length is different with mask's length!\n");
+			return MLAN_STATUS_FAILURE;
+		}
+		memset(line, 0, sizeof(line));
+		snprintf(line, sizeof(line), "h%s %d h%s =b ", byte_seq, offset,
+			 mask_seq);
+		break;
+	case FILTER_TEST:
+		if (!byte_find || !offset_find || !repeat_find || !dest_find) {
+			printf("Missing field for FILTER_TEST: byte=%d,offset=%d,repeat=%d,dest=%d\n",
+			       byte_find, offset_find, repeat_find, dest_find);
+			return MLAN_STATUS_FAILURE;
+		}
+		memset(line, 0, sizeof(line));
+		snprintf(line, sizeof(line), "h%s %d h%s %d ", dest_seq, repeat,
+			 byte_seq, offset);
+		break;
+	}
+	memcpy(buf, line, strlen(line));
+	*size = strlen(line);
+	return MLAN_STATUS_SUCCESS;
+}
+
+#define NAME_MODE 1 /**< Field name 'mode' */
+#define NAME_ACTION 2 /**< Field name 'action' */
+#define NAME_FILTER_NUM 3 /**< Field name 'filter_num' */
+#define NAME_RPN 4 /**< Field name 'RPN' */
+static struct mef_entry_fields {
+	char *name; /**< Name */
+	t_s8 nameid; /**< Name id */
+} mef_entry_fields[] = {
+	{"mode", NAME_MODE},
+	{"action", NAME_ACTION},
+	{"filter_num", NAME_FILTER_NUM},
+	{"RPN", NAME_RPN},
+};
+
+typedef struct _MEF_ENTRY {
+	/** Mode */
+	t_u8 Mode;
+	/** Size */
+	t_u8 Action;
+	/** Size of expression */
+	t_u16 ExprSize;
+} MEF_ENTRY;
+
+/**
+ *  @brief get mef_entry data
+ *
+ *  @param fp			A pointer to file stream
+ *  @param ln			A pointer to line number
+ *  @param buf			A pointer to hostcmd data
+ *  @param size			A pointer to the return size of hostcmd buffer
+ *  @return			MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int mlan_get_mef_entry_data(FILE *fp, int *ln, t_u8 *buf, t_u16 *size)
+{
+	char line[256], *pos = NULL, *pos1 = NULL;
+	t_u8 mode, action, filter_num = 0;
+	char rpn[256];
+	t_s8 mode_find = 0;
+	t_s8 action_find = 0;
+	t_s8 filter_num_find = 0;
+	t_s8 rpn_find = 0;
+	char rpn_str[256];
+	int rpn_len = 0;
+	char filter_name[50];
+	t_s8 name_found = 0;
+	t_u16 len = 0;
+	int i;
+	int first_time = TRUE;
+	char *opstr = NULL;
+	char filter_action[10];
+	t_s32 errors = 0;
+	MEF_ENTRY *pMefEntry = (MEF_ENTRY *)buf;
+	mstack_t stack;
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), ln))) {
+		if (strcmp(pos, "}") == 0) {
+			break;
+		}
+		pos1 = strchr(pos, '=');
+		if (pos1 == NULL) {
+			printf("Line %d: Invalid mef_entry line '%s'\n", *ln,
+			       pos);
+			errors++;
+			continue;
+		}
+		*pos1++ = '\0';
+		if (!mode_find || !action_find || !filter_num_find ||
+		    !rpn_find) {
+			for (i = 0;
+			     (unsigned int)i < NELEMENTS(mef_entry_fields);
+			     i++) {
+				if (strncmp(pos, mef_entry_fields[i].name,
+					    strlen(mef_entry_fields[i].name)) ==
+				    0) {
+					switch (mef_entry_fields[i].nameid) {
+					case NAME_MODE:
+						mode = a2hex_or_atoi(pos1);
+						if (mode & ~0x7) {
+							printf("invalid mode=%d\n",
+							       mode);
+							return MLAN_STATUS_FAILURE;
+						}
+						pMefEntry->Mode = mode;
+						mode_find = 1;
+						break;
+					case NAME_ACTION:
+						action = a2hex_or_atoi(pos1);
+						if (action & ~0xff) {
+							printf("invalid action=%d\n",
+							       action);
+							return MLAN_STATUS_FAILURE;
+						}
+						pMefEntry->Action = action;
+						action_find = 1;
+						break;
+					case NAME_FILTER_NUM:
+						filter_num =
+							a2hex_or_atoi(pos1);
+						filter_num_find = 1;
+						break;
+					case NAME_RPN:
+						memset(rpn, 0, sizeof(rpn));
+						strncpy(rpn, pos1,
+							(sizeof(rpn) - 1));
+						rpn_find = 1;
+						break;
+					}
+					break;
+				}
+			}
+			if (i == NELEMENTS(mef_fields)) {
+				printf("Line %d: unknown mef_entry field '%s'.\n",
+				       *line, pos);
+				return MLAN_STATUS_FAILURE;
+			}
+		}
+		if (mode_find && action_find && filter_num_find && rpn_find) {
+			for (i = 0; i < filter_num; i++) {
+				opstr = getop(rpn, &first_time);
+				if (opstr == NULL)
+					break;
+				snprintf(filter_name, sizeof(filter_name),
+					 "%s={", opstr);
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), ln))) {
+					if (strncmp(pos, filter_name,
+						    strlen(filter_name)) == 0) {
+						name_found = 1;
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: %s not found in file\n",
+						filter_name);
+					return MLAN_STATUS_FAILURE;
+				}
+				if (MLAN_STATUS_FAILURE ==
+				    mlan_get_filter_data(
+					    fp, ln, (t_u8 *)(rpn_str + rpn_len),
+					    &len))
+					break;
+				rpn_len += len;
+				if (i > 0) {
+					memcpy(rpn_str + rpn_len, filter_action,
+					       strlen(filter_action));
+					rpn_len += strlen(filter_action);
+				}
+				opstr = getop(rpn, &first_time);
+				if (opstr == NULL)
+					break;
+				memset(filter_action, 0, sizeof(filter_action));
+				snprintf(filter_action, sizeof(filter_action),
+					 "%s ", opstr);
+			}
+			/* Remove the last space */
+			if (rpn_len > 0) {
+				rpn_len--;
+				rpn_str[rpn_len] = 0;
+			}
+			if (MLAN_STATUS_FAILURE == str2bin(rpn_str, &stack)) {
+				printf("Fail on str2bin!\n");
+				return MLAN_STATUS_FAILURE;
+			}
+			*size = sizeof(MEF_ENTRY);
+			pMefEntry->ExprSize = cpu_to_le16(stack.sp);
+			memmove(buf + sizeof(MEF_ENTRY), stack.byte, stack.sp);
+			*size += stack.sp;
+			break;
+		} else if (mode_find && action_find && filter_num_find &&
+			   (filter_num == 0)) {
+			pMefEntry->ExprSize = 0;
+			*size = sizeof(MEF_ENTRY);
+			break;
+		}
+	}
+	return MLAN_STATUS_SUCCESS;
+}
+
+#define MEFCFG_CMDCODE 0x009a
+
+/**
+ *  @brief Process mefcfg command
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array
+ *  @return         MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_mefcfg(int argc, char *argv[])
+{
+	char line[256], cmdname[256], *pos = NULL;
+	int cmdname_found = 0, name_found = 0;
+	int ln = 0;
+	int ret = MLAN_STATUS_SUCCESS;
+	int i;
+	t_u8 *buffer = NULL;
+	t_u16 len = 0;
+	HostCmd_DS_MEF_CFG *mefcmd = NULL;
+	HostCmd_DS_GEN *hostcmd = NULL;
+	FILE *fp = NULL;
+	t_u32 cmd_len = 0, cmd_header_len;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+
+	if (argc < 4) {
+		printf("Error: invalid no of arguments\n");
+		printf("Syntax: ./mlanutl mlan0 mefcfg <mef.conf>\n");
+		exit(1);
+	}
+
+	cmd_header_len = strlen(CMD_NXP) + strlen("HOSTCMD");
+	cmd_len = sizeof(HostCmd_DS_GEN) + sizeof(HostCmd_DS_MEF_CFG);
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		return -ENOMEM;
+	}
+
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+	/* buf = MRVL_CMD<cmd> */
+	prepare_buffer(buffer, HOSTCMD, 0, NULL);
+
+	/* buf = MRVL_CMD<cmd><hostcmd_size><HostCmd_DS_GEN> */
+	hostcmd = (HostCmd_DS_GEN *)(buffer + cmd_header_len + sizeof(t_u32));
+	hostcmd->command = cpu_to_le16(MEFCFG_CMDCODE);
+	hostcmd->seq_num = 0;
+	hostcmd->result = 0;
+	/* buf = MRVL_CMD<cmd><hostcmd_size><HostCmd_DS_GEN><HostCmd_DS_MEF_CFG>
+	 */
+	mefcmd = (HostCmd_DS_MEF_CFG *)(buffer + cmd_header_len +
+					sizeof(t_u32) + S_DS_GEN);
+
+	/* Host Command Population */
+	snprintf(cmdname, sizeof(cmdname), "%s={", argv[2]);
+	cmdname_found = 0;
+	fp = fopen(argv[3], "r");
+	if (fp == NULL) {
+		fprintf(stderr, "Cannot open file %s\n", argv[4]);
+		exit(1);
+	}
+
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), &ln))) {
+		if (strcmp(pos, cmdname) == 0) {
+			cmdname_found = 1;
+			snprintf(cmdname, sizeof(cmdname), "Criteria=");
+			name_found = 0;
+			while ((pos = mlan_config_get_line(
+					fp, line, sizeof(line), &ln))) {
+				if (strncmp(pos, cmdname, strlen(cmdname)) ==
+				    0) {
+					name_found = 1;
+					mefcmd->Criteria = a2hex_or_atoi(
+						pos + strlen(cmdname));
+					break;
+				}
+			}
+			if (!name_found) {
+				fprintf(stderr,
+					"mlanutl: criteria not found in file '%s'\n",
+					argv[3]);
+				break;
+			}
+			snprintf(cmdname, sizeof(cmdname), "NumEntries=");
+			name_found = 0;
+			while ((pos = mlan_config_get_line(
+					fp, line, sizeof(line), &ln))) {
+				if (strncmp(pos, cmdname, strlen(cmdname)) ==
+				    0) {
+					name_found = 1;
+					mefcmd->NumEntries = a2hex_or_atoi(
+						pos + strlen(cmdname));
+					break;
+				}
+			}
+			if (!name_found) {
+				fprintf(stderr,
+					"mlanutl: NumEntries not found in file '%s'\n",
+					argv[3]);
+				break;
+			}
+			for (i = 0; i < mefcmd->NumEntries; i++) {
+				snprintf(cmdname, sizeof(cmdname),
+					 "mef_entry_%d={", i);
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: %s not found in file '%s'\n",
+						cmdname, argv[3]);
+					break;
+				}
+				if (MLAN_STATUS_FAILURE ==
+				    mlan_get_mef_entry_data(
+					    fp, &ln, (t_u8 *)hostcmd + cmd_len,
+					    &len)) {
+					ret = MLAN_STATUS_FAILURE;
+					break;
+				}
+				cmd_len += len;
+			}
+			break;
+		}
+	}
+	fclose(fp);
+	/* buf = MRVL_CMD<cmd><hostcmd_size> */
+	memcpy(buffer + cmd_header_len, (t_u8 *)&cmd_len, sizeof(t_u32));
+
+	if (!cmdname_found)
+		fprintf(stderr,
+			"mlanutl: cmdname '%s' not found in file '%s'\n",
+			argv[4], argv[3]);
+
+	if (!cmdname_found || !name_found) {
+		ret = MLAN_STATUS_FAILURE;
+		goto mef_exit;
+	}
+	hostcmd->size = cpu_to_le16(cmd_len);
+	mefcmd->Criteria = cpu_to_le32(mefcmd->Criteria);
+	mefcmd->NumEntries = cpu_to_le16(mefcmd->NumEntries);
+	hexdump("mefcfg", buffer + cmd_header_len, cmd_len, ' ');
+
+	/* Initialize the ifr structure */
+	memset(&ifr, 0, sizeof(ifr));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+	/* Perform ioctl */
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("ioctl[MEF_CFG]");
+		printf("ERR:Command sending failed!\n");
+
+		if (buffer)
+			free(buffer);
+
+		if (cmd)
+			free(cmd);
+
+		return MLAN_STATUS_FAILURE;
+	}
+
+	ret = process_host_cmd_resp(HOSTCMD, buffer);
+
+mef_exit:
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+	return ret;
+}
+
+/**
+ *  @brief Check the Hex String
+ *  @param s  A pointer to the string
+ *  @return   MLAN_STATUS_SUCCESS --HexString, MLAN_STATUS_FAILURE --not
+ * HexString
+ */
+static int ishexstring(char *s)
+{
+	int ret = MLAN_STATUS_FAILURE;
+	t_s32 tmp;
+
+	if (!strncasecmp("0x", s, 2)) {
+		s += 2;
+	}
+	while (*s) {
+		tmp = toupper((unsigned char)*s);
+		if (((tmp >= 'A') && (tmp <= 'F')) ||
+		    ((tmp >= '0') && (tmp <= '9'))) {
+			ret = MLAN_STATUS_SUCCESS;
+		} else {
+			ret = MLAN_STATUS_FAILURE;
+			break;
+		}
+		s++;
+	}
+
+	return ret;
+}
+/**
+ *  @brief Converts colon separated MAC address to hex value
+ *
+ *  @param mac      A pointer to the colon separated MAC string
+ *  @param raw      A pointer to the hex data buffer
+ *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ *                  MAC_BROADCAST   - if broadcast mac
+ *                  MAC_MULTICAST   - if multicast mac
+ */
+static int mac2raw(char *mac, t_u8 *raw)
+{
+	unsigned int temp_raw[ETH_ALEN];
+	int num_tokens = 0;
+	int i;
+
+	if (strlen(mac) != ((2 * ETH_ALEN) + (ETH_ALEN - 1))) {
+		return MLAN_STATUS_FAILURE;
+	}
+	num_tokens = sscanf(mac, "%2x:%2x:%2x:%2x:%2x:%2x", temp_raw + 0,
+			    temp_raw + 1, temp_raw + 2, temp_raw + 3,
+			    temp_raw + 4, temp_raw + 5);
+	if (num_tokens != ETH_ALEN) {
+		return MLAN_STATUS_FAILURE;
+	}
+	for (i = 0; i < num_tokens; i++)
+		raw[i] = (t_u8)temp_raw[i];
+
+	if (memcmp(raw, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0) {
+		return MAC_BROADCAST;
+	} else if (raw[0] & 0x01) {
+		return MAC_MULTICAST;
+	}
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Convert String to Integer
+ *  @param buf      A pointer to the string
+ *  @return         Integer
+ */
+static int atoval(char *buf)
+{
+	if (!strncasecmp(buf, "0x", 2))
+		return a2hex(buf + 2);
+	else if (!ishexstring(buf))
+		return a2hex(buf);
+	else
+		return atoi(buf);
+}
+
+/**
+ *  @brief Parses a command line
+ *
+ *  @param line     The line to parse
+ *  @param args     Pointer to the argument buffer to be filled in
+ *  @param args_count Max number of elements which can be filled in buffer
+ * 'args'
+ *  @return         Number of arguments in the line or EOF
+ */
+static int parse_line(char *line, char *args[], t_u16 args_count)
+{
+	int arg_num = 0;
+	int is_start = 0;
+	int is_quote = 0;
+	int length = 0;
+	int i = 0;
+
+	arg_num = 0;
+	length = strlen(line);
+	/* Process line */
+
+	/* Find number of arguments */
+	is_start = 0;
+	is_quote = 0;
+	for (i = 0; (i < length) && (arg_num < args_count); i++) {
+		/* Ignore leading spaces */
+		if (is_start == 0) {
+			if (line[i] == ' ') {
+				continue;
+			} else if (line[i] == '\t') {
+				continue;
+			} else if (line[i] == '\n') {
+				break;
+			} else {
+				is_start = 1;
+				args[arg_num] = &line[i];
+				arg_num++;
+			}
+		}
+		if (is_start == 1) {
+			/* Ignore comments */
+			if (line[i] == '#') {
+				if (is_quote == 0) {
+					line[i] = '\0';
+					arg_num--;
+				}
+				break;
+			}
+			/* Separate by '=' */
+			if (line[i] == '=') {
+				line[i] = '\0';
+				is_start = 0;
+				continue;
+			}
+			/* Separate by ',' */
+			if (line[i] == ',') {
+				line[i] = '\0';
+				is_start = 0;
+				continue;
+			}
+			/* Change ',' to ' ', but not inside quotes */
+			if ((line[i] == ',') && (is_quote == 0)) {
+				line[i] = ' ';
+				continue;
+			}
+		}
+		/* Remove newlines */
+		if (line[i] == '\n') {
+			line[i] = '\0';
+		}
+		/* Check for quotes */
+		if (line[i] == '"') {
+			is_quote = (is_quote == 1) ? 0 : 1;
+			continue;
+		}
+		if (((line[i] == ' ') || (line[i] == '\t')) &&
+		    (is_quote == 0)) {
+			line[i] = '\0';
+			is_start = 0;
+			continue;
+		}
+	}
+	return arg_num;
+}
+
+/**
+ *  @brief Process cloud keep alive command
+ *  @param argc     number of arguments
+ *  @param argv     A pointer to arguments array
+ *  @return         MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+static int process_cloud_keep_alive(int argc, char *argv[])
+{
+	t_u8 *buffer = NULL;
+	struct eth_priv_cmd *cmd = NULL;
+	struct ifreq ifr;
+	FILE *fp = NULL;
+	int ret = MLAN_STATUS_SUCCESS;
+	char line[256], cmdname[256], *pos = NULL;
+	int cmdname_found = 0, name_found = 0, arg_num = 0;
+	int ln = 0, i = 0;
+	char *args[256];
+	cloud_keep_alive *keep_alive = NULL;
+
+	if (argc < 5) {
+		printf("Error: invalid no of arguments\n");
+		printf("Syntax: ./mlanutl mlanX cloud_keep_alive <keep_alive.conf> <start/stop/reset>\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Initialize buffer */
+	buffer = (t_u8 *)malloc(BUFFER_LENGTH);
+	if (!buffer) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	memset(buffer, 0, BUFFER_LENGTH);
+
+	/* Insert command */
+	strncpy((char *)buffer, argv[2], strlen(argv[2]));
+
+	keep_alive = (cloud_keep_alive *)(buffer + strlen(argv[2]));
+
+	cmdname_found = 0;
+	snprintf(cmdname, sizeof(cmdname), "%s={", argv[4]);
+
+	fp = fopen(argv[3], "r");
+	if (fp == NULL) {
+		fprintf(stderr, "Cannot open file %s\n", argv[3]);
+		ret = MLAN_STATUS_FAILURE;
+		if (buffer)
+			free(buffer);
+		goto done;
+	}
+
+	while ((pos = mlan_config_get_line(fp, line, sizeof(line), &ln))) {
+		if (strcmp(pos, cmdname) == 0) {
+			cmdname_found = 1;
+			snprintf(cmdname, sizeof(cmdname), "mkeep_alive_id=");
+			name_found = 0;
+			while ((pos = mlan_config_get_line(
+					fp, line, sizeof(line), &ln))) {
+				if (strncmp(pos, cmdname, strlen(cmdname)) ==
+				    0) {
+					name_found = 1;
+					keep_alive->mkeep_alive_id =
+						a2hex_or_atoi(pos +
+							      strlen(cmdname));
+					break;
+				}
+			}
+			if (!name_found) {
+				fprintf(stderr,
+					"mlanutl: keep alive id not found in file '%s'\n",
+					argv[3]);
+				break;
+			}
+			snprintf(cmdname, sizeof(cmdname), "enable=");
+			name_found = 0;
+			while ((pos = mlan_config_get_line(
+					fp, line, sizeof(line), &ln))) {
+				if (strncmp(pos, cmdname, strlen(cmdname)) ==
+				    0) {
+					name_found = 1;
+					keep_alive->enable = a2hex_or_atoi(
+						pos + strlen(cmdname));
+					break;
+				}
+			}
+			if (!name_found) {
+				fprintf(stderr,
+					"mlanutl: enable not found in file '%s'\n",
+					argv[3]);
+				break;
+			}
+			if (strcmp(argv[4], "reset") == 0) {
+				snprintf(cmdname, sizeof(cmdname), "reset=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						keep_alive
+							->reset = a2hex_or_atoi(
+							pos + strlen(cmdname));
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: reset not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+			}
+			if (strcmp(argv[4], "start") == 0) {
+				snprintf(cmdname, sizeof(cmdname),
+					 "sendInterval=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						keep_alive->sendInterval =
+							a2hex_or_atoi(
+								pos +
+								strlen(cmdname));
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: sendInterval not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname),
+					 "retryInterval=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						keep_alive->retryInterval =
+							a2hex_or_atoi(
+								pos +
+								strlen(cmdname));
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: retryInterval not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname),
+					 "retryCount=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						keep_alive->retryCount =
+							a2hex_or_atoi(
+								pos +
+								strlen(cmdname));
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: retryCount not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname),
+					 "destMacAddr=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						mac2raw(pos + strlen(cmdname),
+							keep_alive->dst_mac);
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: destination MAC address not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname),
+					 "srcMacAddr=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						mac2raw(pos + strlen(cmdname),
+							keep_alive->src_mac);
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: source MAC address not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname), "pktLen=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						keep_alive->pkt_len =
+							a2hex_or_atoi(
+								pos +
+								strlen(cmdname));
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: ip packet length not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+				snprintf(cmdname, sizeof(cmdname), "ipPkt=");
+				name_found = 0;
+				while ((pos = mlan_config_get_line(
+						fp, line, sizeof(line), &ln))) {
+					if (strncmp(pos, cmdname,
+						    strlen(cmdname)) == 0) {
+						name_found = 1;
+						arg_num = parse_line(line, args,
+								     256);
+						if (arg_num <
+						    keep_alive->pkt_len) {
+							fprintf(stderr,
+								"Invalid ipPkt or pkt_len in '%s'\n",
+								argv[3]);
+							break;
+						}
+						for (i = 0;
+						     i < keep_alive->pkt_len;
+						     i++)
+							keep_alive->pkt[i] =
+								(t_u8)atoval(
+									args[i +
+									     1]);
+						break;
+					}
+				}
+				if (!name_found) {
+					fprintf(stderr,
+						"mlanutl: ipPkt data not found in file '%s'\n",
+						argv[3]);
+					break;
+				}
+			}
+		}
+	}
+	if (!cmdname_found) {
+		fprintf(stderr, "mlanutl: ipPkt data not found in file '%s'\n",
+			argv[3]);
+		free(buffer);
+		if (fp)
+			fclose(fp);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	cmd = (struct eth_priv_cmd *)malloc(sizeof(struct eth_priv_cmd));
+	if (!cmd) {
+		printf("ERR:Cannot allocate buffer for command!\n");
+		free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill up buffer */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+	memset(cmd, 0, sizeof(struct eth_priv_cmd));
+	memcpy(&cmd->buf, &buffer, sizeof(buffer));
+#else
+	cmd->buf = buffer;
+#endif
+	cmd->used_len = 0;
+	cmd->total_len = BUFFER_LENGTH;
+	/* Perform IOCTL */
+	memset(&ifr, 0, sizeof(struct ifreq));
+	strncpy(ifr.ifr_ifrn.ifrn_name, dev_name, strlen(dev_name));
+	ifr.ifr_ifru.ifru_data = (void *)cmd;
+
+	if (ioctl(sockfd, MLAN_ETH_PRIV, &ifr)) {
+		perror("mlanutl");
+		fprintf(stderr, "mlanutl: cloud keep alive fail\n");
+		if (cmd)
+			free(cmd);
+		if (buffer)
+			free(buffer);
+		return MLAN_STATUS_FAILURE;
+	}
+	/* Process result */
+	keep_alive = (cloud_keep_alive *)(buffer + strlen(argv[2]));
+	if (strcmp(argv[4], "start") != 0) {
+		hexdump("Last cloud keep alive packet info", keep_alive->pkt,
+			keep_alive->pkt_len, ' ');
+	}
+
+	if (buffer)
+		free(buffer);
+	if (cmd)
+		free(cmd);
+
+done:
+	return ret;
+}
+
+/********************************************************
+			Global Functions
+********************************************************/
+
+/**
+ *  @brief Entry function for mlanutl
+ *  @param argc     Number of arguments
+ *  @param argv     A pointer to arguments array
+ *  @return         MLAN_STATUS_SUCCESS--success, otherwise--fail
+ */
+int main(int argc, char *argv[])
+{
+	int ret = MLAN_STATUS_SUCCESS;
+
+	if ((argc == 2) && (strcmp(argv[1], "-v") == 0)) {
+		fprintf(stdout, "NXP mlanutl version %s\n", MLANUTL_VER);
+		exit(0);
+	}
+	if (argc < 3) {
+		fprintf(stderr, "Invalid number of parameters!\n");
+		display_usage();
+		exit(1);
+	}
+
+	strncpy(dev_name, argv[1], IFNAMSIZ - 1);
+
+	/*
+	 * Create a socket
+	 */
+	sockfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (sockfd < 0) {
+		fprintf(stderr, "mlanutl: Cannot open socket.\n");
+		exit(1);
+	}
+
+	ret = process_command(argc, argv);
+
+	if (ret == MLAN_STATUS_NOTFOUND) {
+		if (ret) {
+			fprintf(stderr, "Invalid command specified!\n");
+			display_usage();
+			ret = 1;
+		}
+	}
+
+	close(sockfd);
+	return ret;
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.h
new file mode 100644
index 000000000..1b70de6a5
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/mapp/mlanutl/mlanutl.h
@@ -0,0 +1,1243 @@
+/** @file  mlanutl.h
+ *
+ * @brief This file contains definitions for application
+ *
+ *
+ * Copyright 2011-2021 NXP
+ *
+ * This software file (the File) is distributed by NXP
+ * under the terms of the GNU General Public License Version 2, June 1991
+ * (the License).  You may use, redistribute and/or modify the File in
+ * accordance with the terms and conditions of the License, a copy of which
+ * is available by writing to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA or on the
+ * worldwide web at http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
+ *
+ * THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE
+ * ARE EXPRESSLY DISCLAIMED.  The License provides additional details about
+ * this warranty disclaimer.
+ *
+ */
+/************************************************************************
+Change log:
+     11/26/2008: initial version
+************************************************************************/
+#ifndef _MLANUTL_H_
+#define _MLANUTL_H_
+
+/** Include header files */
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+#include <linux/if.h>
+#include <linux/wireless.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <arpa/inet.h>
+
+#include <netinet/ether.h>
+#include <linux/if_packet.h>
+
+/** Type definition: boolean */
+typedef enum { FALSE, TRUE } boolean;
+
+/** 16 bits byte swap */
+#define swap_byte_16(x)                                                        \
+	((t_u16)((((t_u16)(x)&0x00ffU) << 8) | (((t_u16)(x)&0xff00U) >> 8)))
+
+/** 32 bits byte swap */
+#define swap_byte_32(x)                                                        \
+	((t_u32)((((t_u32)(x)&0x000000ffUL) << 24) |                           \
+		 (((t_u32)(x)&0x0000ff00UL) << 8) |                            \
+		 (((t_u32)(x)&0x00ff0000UL) >> 8) |                            \
+		 (((t_u32)(x)&0xff000000UL) >> 24)))
+
+/** Convert to correct endian format */
+#ifdef BIG_ENDIAN_SUPPORT
+/** CPU to little-endian convert for 16-bit */
+#define cpu_to_le16(x) swap_byte_16(x)
+/** CPU to little-endian convert for 32-bit */
+#define cpu_to_le32(x) swap_byte_32(x)
+/** Little-endian to CPU convert for 16-bit */
+#define le16_to_cpu(x) swap_byte_16(x)
+/** Little-endian to CPU convert for 32-bit */
+#define le32_to_cpu(x) swap_byte_32(x)
+#else
+/** Do nothing */
+#define cpu_to_le16(x) (x)
+/** Do nothing */
+#define cpu_to_le32(x) (x)
+/** Do nothing */
+#define le16_to_cpu(x) (x)
+/** Do nothing */
+#define le32_to_cpu(x) (x)
+#endif
+
+/** TLV header */
+#define TLVHEADER /** Tag */                                                   \
+	t_u16 tag;                                                             \
+	/** Length */                                                          \
+	t_u16 length
+
+/** Length of TLV header */
+#define TLVHEADER_LEN 4
+
+/** Character, 1 byte */
+typedef signed char t_s8;
+/** Unsigned character, 1 byte */
+typedef unsigned char t_u8;
+
+/** Short integer */
+typedef signed short t_s16;
+/** Unsigned short integer */
+typedef unsigned short t_u16;
+
+/** Integer */
+typedef signed int t_s32;
+/** Unsigned integer */
+typedef unsigned int t_u32;
+
+/** Long long integer */
+typedef signed long long t_s64;
+/** Unsigned long long integer */
+typedef unsigned long long t_u64;
+
+/** Void pointer (4-bytes) */
+typedef void t_void;
+
+enum _mlan_act_ioctl {
+	MLAN_ACT_SET = 1,
+	MLAN_ACT_GET,
+	MLAN_ACT_CANCEL,
+	MLAN_ACT_CLEAR,
+	MLAN_ACT_RESET,
+	MLAN_ACT_DEFAULT
+};
+
+/** The attribute pack used for structure packing */
+#ifndef __ATTRIB_PACK__
+#define __ATTRIB_PACK__ __attribute__((packed))
+#endif
+
+/** Success */
+#define MLAN_STATUS_SUCCESS (0)
+/** Failure */
+#define MLAN_STATUS_FAILURE (-1)
+/** Not found */
+#define MLAN_STATUS_NOTFOUND (1)
+
+/** IOCTL number */
+#define MLAN_ETH_PRIV (SIOCDEVPRIVATE + 14)
+
+/** Command buffer max length */
+#define BUFFER_LENGTH (4 * 1024)
+
+/** Find number of elements */
+#define NELEMENTS(x) (sizeof(x) / sizeof(x[0]))
+
+/** BIT value */
+#define MBIT(x) (((t_u32)1) << (x))
+
+#ifndef MIN
+/** Find minimum value */
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif /* MIN */
+
+/** Length of ethernet address */
+#ifndef ETH_ALEN
+#define ETH_ALEN 6
+#endif
+
+/** Action field value : get */
+#define ACTION_GET 0
+/** Action field value : set */
+#define ACTION_SET 1
+
+/** Maximum number of TID */
+#define MAX_NUM_TID 8
+
+/** Device name */
+extern char dev_name[IFNAMSIZ + 1];
+
+#define HOSTCMD "hostcmd"
+
+/** NXP private command identifier */
+#define CMD_NXP "MRVL_CMD"
+
+struct command_node {
+	char *name;
+	int (*handler)(int, char **);
+};
+
+/** Private command structure */
+#ifdef USERSPACE_32BIT_OVER_KERNEL_64BIT
+struct eth_priv_cmd {
+	/** Command buffer pointer */
+	t_u64 buf;
+	/** buffer updated by driver */
+	int used_len;
+	/** buffer sent by application */
+	int total_len;
+} __ATTRIB_PACK__;
+#else
+struct eth_priv_cmd {
+	/** Command buffer */
+	t_u8 *buf;
+	/** Used length */
+	int used_len;
+	/** Total length */
+	int total_len;
+};
+#endif
+
+/** data structure for cmd getdatarate */
+struct eth_priv_data_rate {
+	/** Tx data rate */
+	t_u32 tx_data_rate;
+	/** Rx data rate */
+	t_u32 rx_data_rate;
+
+	/** Tx channel bandwidth */
+	t_u32 tx_bw;
+	/** Tx guard interval */
+	t_u32 tx_gi;
+	/** Rx channel bandwidth */
+	t_u32 rx_bw;
+	/** Rx guard interval */
+	t_u32 rx_gi;
+	/** MCS index */
+	t_u32 tx_mcs_index;
+	t_u32 rx_mcs_index;
+	/** NSS */
+	t_u32 tx_nss;
+	t_u32 rx_nss;
+	/* LG rate: 0, HT rate: 1, VHT rate: 2 */
+	t_u32 tx_rate_format;
+	t_u32 rx_rate_format;
+};
+
+/** data structure for cmd getlog */
+struct eth_priv_get_log {
+	/** Multicast transmitted frame count */
+	t_u32 mcast_tx_frame;
+	/** Failure count */
+	t_u32 failed;
+	/** Retry count */
+	t_u32 retry;
+	/** Multi entry count */
+	t_u32 multi_retry;
+	/** Duplicate frame count */
+	t_u32 frame_dup;
+	/** RTS success count */
+	t_u32 rts_success;
+	/** RTS failure count */
+	t_u32 rts_failure;
+	/** Ack failure count */
+	t_u32 ack_failure;
+	/** Rx fragmentation count */
+	t_u32 rx_frag;
+	/** Multicast Tx frame count */
+	t_u32 mcast_rx_frame;
+	/** FCS error count */
+	t_u32 fcs_error;
+	/** Tx frame count */
+	t_u32 tx_frame;
+	/** WEP ICV error count */
+	t_u32 wep_icv_error[4];
+	/** beacon recv count */
+	t_u32 bcn_rcv_cnt;
+	/** beacon miss count */
+	t_u32 bcn_miss_cnt;
+	/** received amsdu count*/
+	t_u32 amsdu_rx_cnt;
+	/** received msdu count in amsdu*/
+	t_u32 msdu_in_rx_amsdu_cnt;
+	/** tx amsdu count*/
+	t_u32 amsdu_tx_cnt;
+	/** tx msdu count in amsdu*/
+	t_u32 msdu_in_tx_amsdu_cnt;
+	/** Tx frag count */
+	t_u32 tx_frag_cnt;
+	/** Qos Tx frag count */
+	t_u32 qos_tx_frag_cnt[8];
+	/** Qos failed count */
+	t_u32 qos_failed_cnt[8];
+	/** Qos retry count */
+	t_u32 qos_retry_cnt[8];
+	/** Qos multi retry count */
+	t_u32 qos_multi_retry_cnt[8];
+	/** Qos frame dup count */
+	t_u32 qos_frm_dup_cnt[8];
+	/** Qos rts success count */
+	t_u32 qos_rts_suc_cnt[8];
+	/** Qos rts failure count */
+	t_u32 qos_rts_failure_cnt[8];
+	/** Qos ack failure count */
+	t_u32 qos_ack_failure_cnt[8];
+	/** Qos Rx frag count */
+	t_u32 qos_rx_frag_cnt[8];
+	/** Qos Tx frame count */
+	t_u32 qos_tx_frm_cnt[8];
+	/** Qos discarded frame count */
+	t_u32 qos_discarded_frm_cnt[8];
+	/** Qos mpdus Rx count */
+	t_u32 qos_mpdus_rx_cnt[8];
+	/** Qos retry rx count */
+	t_u32 qos_retries_rx_cnt[8];
+	/** CMACICV errors count */
+	t_u32 cmacicv_errors;
+	/** CMAC replays count */
+	t_u32 cmac_replays;
+	/** mgmt CCMP replays count */
+	t_u32 mgmt_ccmp_replays;
+	/** TKIP ICV errors count */
+	t_u32 tkipicv_errors;
+	/** TKIP replays count */
+	t_u32 tkip_replays;
+	/** CCMP decrypt errors count */
+	t_u32 ccmp_decrypt_errors;
+	/** CCMP replays count */
+	t_u32 ccmp_replays;
+	/** Tx amsdu count */
+	t_u32 tx_amsdu_cnt;
+	/** failed amsdu count */
+	t_u32 failed_amsdu_cnt;
+	/** retry amsdu count */
+	t_u32 retry_amsdu_cnt;
+	/** multi-retry amsdu count */
+	t_u32 multi_retry_amsdu_cnt;
+	/** Tx octets in amsdu count */
+	t_u64 tx_octets_in_amsdu_cnt;
+	/** amsdu ack failure count */
+	t_u32 amsdu_ack_failure_cnt;
+	/** Rx amsdu count */
+	t_u32 rx_amsdu_cnt;
+	/** Rx octets in amsdu count */
+	t_u64 rx_octets_in_amsdu_cnt;
+	/** Tx ampdu count */
+	t_u32 tx_ampdu_cnt;
+	/** tx mpdus in ampdu count */
+	t_u32 tx_mpdus_in_ampdu_cnt;
+	/** tx octets in ampdu count */
+	t_u64 tx_octets_in_ampdu_cnt;
+	/** ampdu Rx count */
+	t_u32 ampdu_rx_cnt;
+	/** mpdu in Rx ampdu count */
+	t_u32 mpdu_in_rx_ampdu_cnt;
+	/** Rx octets ampdu count */
+	t_u64 rx_octets_in_ampdu_cnt;
+	/** ampdu delimiter CRC error count */
+	t_u32 ampdu_delimiter_crc_error_cnt;
+	/** Rx Stuck Related Info*/
+	/** Rx Stuck Issue count */
+	t_u32 rx_stuck_issue_cnt[2];
+	/** Rx Stuck Recovery count */
+	t_u32 rx_stuck_recovery_cnt;
+	/** Rx Stuck TSF */
+	t_u64 rx_stuck_tsf[2];
+	/** Tx Watchdog Recovery Related Info */
+	/** Tx Watchdog Recovery count */
+	t_u32 tx_watchdog_recovery_cnt;
+	/** Tx Watchdog TSF */
+	t_u64 tx_watchdog_tsf[2];
+	/** Channel Switch Related Info */
+	/** Channel Switch Announcement Sent */
+	t_u32 channel_switch_ann_sent;
+	/** Channel Switch State */
+	t_u32 channel_switch_state;
+	/** Register Class */
+	t_u32 reg_class;
+	/** Channel Number */
+	t_u32 channel_number;
+	/** Channel Switch Mode */
+	t_u32 channel_switch_mode;
+	/** Reset Rx Mac Recovery Count */
+	t_u32 rx_reset_mac_recovery_cnt;
+	/** ISR2 Not Done Count*/
+	t_u32 rx_Isr2_NotDone_Cnt;
+	/** GDMA Abort Count */
+	t_u32 gdma_abort_cnt;
+	/** Rx Reset MAC Count */
+	t_u32 g_reset_rx_mac_cnt;
+	// Ownership error counters
+	/*Error Ownership error count*/
+	t_u32 dwCtlErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwBcnErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwMgtErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwDatErrCnt;
+	/*BIGTK MME good count*/
+	t_u32 bigtk_mmeGoodCnt;
+	/*BIGTK Replay error count*/
+	t_u32 bigtk_replayErrCnt;
+	/*BIGTK MIC error count*/
+	t_u32 bigtk_micErrCnt;
+	/*BIGTK MME not included count*/
+	t_u32 bigtk_mmeNotFoundCnt;
+};
+
+/** MLAN MAC Address Length */
+#define MLAN_MAC_ADDR_LENGTH 6
+#define COUNTRY_CODE_LEN 3
+/** Type definition of eth_priv_countrycode for CMD_COUNTRYCODE */
+struct eth_priv_countrycode {
+	/** Country Code */
+	t_u8 country_code[COUNTRY_CODE_LEN];
+};
+
+/** Type enumeration of WMM AC_QUEUES */
+typedef enum _mlan_wmm_ac_e {
+	WMM_AC_BK,
+	WMM_AC_BE,
+	WMM_AC_VI,
+	WMM_AC_VO
+} __ATTRIB_PACK__ mlan_wmm_ac_e;
+
+/** IEEE Type definitions  */
+typedef enum _IEEEtypes_ElementId_e {
+	SSID = 0,
+	SUPPORTED_RATES = 1,
+	FH_PARAM_SET = 2,
+	DS_PARAM_SET = 3,
+	CF_PARAM_SET = 4,
+
+	IBSS_PARAM_SET = 6,
+
+	COUNTRY_INFO = 7,
+
+	POWER_CONSTRAINT = 32,
+	POWER_CAPABILITY = 33,
+	TPC_REQUEST = 34,
+	TPC_REPORT = 35,
+	SUPPORTED_CHANNELS = 36,
+	CHANNEL_SWITCH_ANN = 37,
+	QUIET = 40,
+	IBSS_DFS = 41,
+	HT_CAPABILITY = 45,
+	HT_OPERATION = 61,
+	BSSCO_2040 = 72,
+	OVERLAPBSSSCANPARAM = 74,
+	EXT_CAPABILITY = 127,
+
+	VHT_CAPABILITY = 191,
+	VHT_OPERATION = 192,
+	EXT_BSS_LOAD = 193,
+	BW_CHANNEL_SWITCH = 194,
+	VHT_TX_POWER_ENV = 195,
+	EXT_POWER_CONSTR = 196,
+	AID_INFO = 197,
+	QUIET_CHAN = 198,
+	OPER_MODE_NTF = 199,
+
+	ERP_INFO = 42,
+	EXTENDED_SUPPORTED_RATES = 50,
+
+	VENDOR_SPECIFIC_221 = 221,
+	WMM_IE = VENDOR_SPECIFIC_221,
+
+	WPS_IE = VENDOR_SPECIFIC_221,
+
+	WPA_IE = VENDOR_SPECIFIC_221,
+	RSN_IE = 48,
+	EXTENSION = 255,
+} __ATTRIB_PACK__ IEEEtypes_ElementId_e;
+
+typedef enum _IEEEtypes_Ext_ElementId_e {
+	HE_CAPABILITY = 35,
+	HE_OPERATION = 36
+} IEEEtypes_Ext_ElementId_e;
+
+/** Capability Bit Map*/
+#ifdef BIG_ENDIAN_SUPPORT
+typedef struct _IEEEtypes_CapInfo_t {
+	t_u8 rsrvd1 : 2;
+	t_u8 dsss_ofdm : 1;
+	t_u8 rsvrd2 : 2;
+	t_u8 short_slot_time : 1;
+	t_u8 rsrvd3 : 1;
+	t_u8 spectrum_mgmt : 1;
+	t_u8 chan_agility : 1;
+	t_u8 pbcc : 1;
+	t_u8 short_preamble : 1;
+	t_u8 privacy : 1;
+	t_u8 cf_poll_rqst : 1;
+	t_u8 cf_pollable : 1;
+	t_u8 ibss : 1;
+	t_u8 ess : 1;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t, *pIEEEtypes_CapInfo_t;
+#else
+typedef struct _IEEEtypes_CapInfo_t {
+	/** Capability Bit Map : ESS */
+	t_u8 ess : 1;
+	/** Capability Bit Map : IBSS */
+	t_u8 ibss : 1;
+	/** Capability Bit Map : CF pollable */
+	t_u8 cf_pollable : 1;
+	/** Capability Bit Map : CF poll request */
+	t_u8 cf_poll_rqst : 1;
+	/** Capability Bit Map : privacy */
+	t_u8 privacy : 1;
+	/** Capability Bit Map : Short preamble */
+	t_u8 short_preamble : 1;
+	/** Capability Bit Map : PBCC */
+	t_u8 pbcc : 1;
+	/** Capability Bit Map : Channel agility */
+	t_u8 chan_agility : 1;
+	/** Capability Bit Map : Spectrum management */
+	t_u8 spectrum_mgmt : 1;
+	/** Capability Bit Map : Reserved */
+	t_u8 rsrvd3 : 1;
+	/** Capability Bit Map : Short slot time */
+	t_u8 short_slot_time : 1;
+	/** Capability Bit Map : APSD */
+	t_u8 apsd : 1;
+	/** Capability Bit Map : Reserved */
+	t_u8 rsvrd2 : 1;
+	/** Capability Bit Map : DSS OFDM */
+	t_u8 dsss_ofdm : 1;
+	/** Capability Bit Map : Reserved */
+	t_u8 rsrvd1 : 2;
+} __ATTRIB_PACK__ IEEEtypes_CapInfo_t, *pIEEEtypes_CapInfo_t;
+#endif /* BIG_ENDIAN_SUPPORT */
+
+/** IEEE IE header */
+typedef struct _IEEEtypes_Header_t {
+	/** Element ID */
+	t_u8 element_id;
+	/** Length */
+	t_u8 len;
+} __ATTRIB_PACK__ IEEEtypes_Header_t, *pIEEEtypes_Header_t;
+
+/** IEEE IE header */
+#define IEEE_HEADER_LEN sizeof(IEEEtypes_Header_t)
+
+/** Maximum size of IEEE Information Elements */
+#define IEEE_MAX_IE_SIZE 256
+
+/** Vendor specific IE header */
+typedef struct _IEEEtypes_VendorHeader_t {
+	/** Element ID */
+	t_u8 element_id;
+	/** Length */
+	t_u8 len;
+	/** OUI */
+	t_u8 oui[3];
+	/** OUI type */
+	t_u8 oui_type;
+	/** OUI subtype */
+	t_u8 oui_subtype;
+	/** Version */
+	t_u8 version;
+} __ATTRIB_PACK__ IEEEtypes_VendorHeader_t, *pIEEEtypes_VendorHeader_t;
+
+/** Vendor specific IE */
+typedef struct _IEEEtypes_VendorSpecific_t {
+	/** Vendor specific IE header */
+	IEEEtypes_VendorHeader_t vend_hdr;
+	/** IE Max - size of previous fields */
+	t_u8 data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_VendorHeader_t)];
+} __ATTRIB_PACK__ IEEEtypes_VendorSpecific_t, *pIEEEtypes_VendorSpecific_t;
+
+/** IEEE IE */
+typedef struct _IEEEtypes_Generic_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** IE Max - size of previous fields */
+	t_u8 data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_Header_t)];
+} __ATTRIB_PACK__ IEEEtypes_Generic_t, *pIEEEtypes_Generic_t;
+
+/** Convert character to integer */
+#define CHAR2INT(x) (((x) >= 'A') ? ((x) - 'A' + 10) : ((x) - '0'))
+
+/** Command RET code, MSB is set to 1 */
+#define HostCmd_RET_BIT 0x8000
+/** General purpose action : Get */
+#define HostCmd_ACT_GEN_GET 0x0000
+/** General purpose action : Set */
+#define HostCmd_ACT_GEN_SET 0x0001
+/** General purpose action : Clear */
+#define HostCmd_ACT_GEN_CLEAR 0x0004
+/** General purpose action : Remove */
+#define HostCmd_ACT_GEN_REMOVE 0x0004
+
+/** TLV  type ID definition */
+#define PROPRIETARY_TLV_BASE_ID 0x0100
+
+/** MrvlIEtypesHeader_t */
+typedef struct MrvlIEtypesHeader {
+	/** Header type */
+	t_u16 type;
+	/** Header length */
+	t_u16 len;
+} __ATTRIB_PACK__ MrvlIEtypesHeader_t;
+
+/** MrvlIEtypes_Data_t */
+typedef struct MrvlIEtypes_Data_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Data */
+	t_u8 data[1];
+} __ATTRIB_PACK__ MrvlIEtypes_Data_t;
+
+/** channel band */
+enum { BAND_2GHZ = 0,
+       BAND_5GHZ = 1,
+       BAND_4GHZ = 2,
+};
+
+/** channel offset */
+enum { SEC_CHAN_NONE = 0,
+       SEC_CHAN_ABOVE = 1,
+       SEC_CHAN_5MHZ = 2,
+       SEC_CHAN_BELOW = 3 };
+
+/** channel bandwidth */
+enum { CHAN_BW_20MHZ = 0,
+       CHAN_BW_10MHZ,
+       CHAN_BW_40MHZ,
+       CHAN_BW_80MHZ,
+};
+
+/** Band_Config_t */
+typedef struct _Band_Config_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Channel Selection Mode - (00)=manual, (01)=ACS,  (02)=user*/
+	t_u8 scanMode : 2;
+	/** Secondary Channel Offset - (00)=None, (01)=Above, (11)=Below */
+	t_u8 chan2Offset : 2;
+	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
+	t_u8 chanWidth : 2;
+	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	t_u8 chanBand : 2;
+#else
+	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	t_u8 chanBand : 2;
+	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
+	t_u8 chanWidth : 2;
+	/** Secondary Channel Offset - (00)=None, (01)=Above, (11)=Below */
+	t_u8 chan2Offset : 2;
+	/** Channel Selection Mode - (00)=manual, (01)=ACS, (02)=Adoption mode*/
+	t_u8 scanMode : 2;
+#endif
+} __ATTRIB_PACK__ Band_Config_t;
+
+/** Maximum length of lines in configuration file */
+#define MAX_CONFIG_LINE 1024
+/** MAC BROADCAST */
+#define MAC_BROADCAST 0x1FF
+/** MAC MULTICAST */
+#define MAC_MULTICAST 0x1FE
+
+/** HostCmd_DS_GEN */
+typedef struct MAPP_HostCmd_DS_GEN {
+	/** Command */
+	t_u16 command;
+	/** Size */
+	t_u16 size;
+	/** Sequence number */
+	t_u16 seq_num;
+	/** Result */
+	t_u16 result;
+} __ATTRIB_PACK__ HostCmd_DS_GEN;
+
+/** Size of HostCmd_DS_GEN */
+#define S_DS_GEN sizeof(HostCmd_DS_GEN)
+
+/** max mod group */
+#define MAX_MOD_GROUP 35
+
+/** modulation setting */
+typedef struct _mod_group_setting {
+	/** modulation group */
+	t_u8 mod_group;
+	/** power */
+	t_u8 power;
+} __ATTRIB_PACK__ mod_group_setting;
+
+/** chan trpc config */
+typedef struct _ChanTRPCConfig_t {
+	/** start freq */
+	t_u16 start_freq;
+	/* channel width */
+	t_u8 width;
+	/** channel number */
+	t_u8 chan_num;
+	mod_group_setting mod_group[MAX_MOD_GROUP];
+} __ATTRIB_PACK__ ChanTRPCConfig_t;
+
+/** MrvlIETypes_ChanTRPCConfig_t */
+typedef struct _MrvlIETypes_ChanTRPCConfig_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** start freq */
+	t_u16 start_freq;
+	/* channel width */
+	t_u8 width;
+	/** channel number */
+	t_u8 chan_num;
+	/** mode groups */
+	mod_group_setting mod_group[];
+} __ATTRIB_PACK__ MrvlIETypes_ChanTRPCConfig_t;
+
+/*This command gets/sets the Transmit Rate-based Power Control (TRPC) channel
+ * configuration.*/
+#define HostCmd_CHANNEL_TRPC_CONFIG 0x00fb
+
+/** TLV OF CHAN_TRPC_CONFIG */
+#define TLV_TYPE_CHAN_TRPC_CONFIG (PROPRIETARY_TLV_BASE_ID + 137)
+
+/** mlan_ds_misc_chan_trpc_cfg */
+typedef struct _mlan_ds_misc_chan_trpc_cfg {
+	/** sub_band */
+	t_u16 sub_band;
+	/** length */
+	t_u16 length;
+	/** trpc buf */
+	t_u8 trpc_buf[BUFFER_LENGTH];
+} __ATTRIB_PACK__ mlan_ds_misc_chan_trpc_cfg;
+
+struct eth_priv_addba {
+	t_u32 time_out;
+	t_u32 tx_win_size;
+	t_u32 rx_win_size;
+	t_u32 tx_amsdu;
+	t_u32 rx_amsdu;
+};
+
+struct eth_priv_htcapinfo {
+	t_u32 ht_cap_info_bg;
+	t_u32 ht_cap_info_a;
+};
+
+/** data_structure for cmd vhtcfg */
+struct eth_priv_vhtcfg {
+	/** Band (1: 2.4G, 2: 5 G, 3: both 2.4G and 5G) */
+	t_u32 band;
+	/** TxRx (1: Tx, 2: Rx, 3: both Tx and Rx) */
+	t_u32 txrx;
+	/** BW CFG (0: 11N CFG, 1: vhtcap) */
+	t_u32 bwcfg;
+	/** VHT capabilities. */
+	t_u32 vht_cap_info;
+	/** VHT Tx mcs */
+	t_u32 vht_tx_mcs;
+	/** VHT Rx mcs */
+	t_u32 vht_rx_mcs;
+	/** VHT rx max rate */
+	t_u16 vht_rx_max_rate;
+	/** VHT max tx rate */
+	t_u16 vht_tx_max_rate;
+};
+
+/** data structure for cmd txratecfg */
+struct eth_priv_tx_rate_cfg {
+	/* LG rate: 0, HT rate: 1, VHT rate: 2 */
+	t_u32 rate_format;
+	/** Rate/MCS index (0xFF: auto) */
+	t_u32 rate_index;
+	/** Rate rate */
+	t_u32 rate;
+	/** NSS */
+	t_u32 nss;
+	/** Rate Setting */
+	t_u16 rate_setting;
+};
+
+#define MLAN_11AXCMD_CFG_ID_TX_OMI 6
+#define MLAN_11AXCMD_CFG_ID_OBSSNBRU_TOLTIME 7
+
+#define MLAN_11AXCMD_TXOMI_SUBID 0x105
+#define MLAN_11AXCMD_OBSS_TOLTIME_SUBID 0x106
+
+/** Type definition of mlan_ds_11ax_he_capa for MLAN_OID_11AX_HE_CFG */
+typedef struct _mlan_ds_11ax_he_capa {
+	/** tlv id of he capability */
+	t_u16 id;
+	/** length of the payload */
+	t_u16 len;
+	/** extension id */
+	t_u8 ext_id;
+	/** he mac capability info */
+	t_u8 he_mac_cap[6];
+	/** he phy capability info */
+	t_u8 he_phy_cap[11];
+	/** he txrx mcs support for 80MHz */
+	t_u8 he_txrx_mcs_support[4];
+	/** val for txrx mcs 160Mhz or 80+80, and PPE thresholds */
+	t_u8 val[28];
+} __ATTRIB_PACK__ mlan_ds_11ax_he_capa, *pmlan_ds_11ax_he_capa;
+
+/** Type definition of mlan_ds_11ax_he_cfg for MLAN_OID_11AX_HE_CFG */
+typedef struct _mlan_ds_11ax_he_cfg {
+	/** band, BIT0:2.4G, BIT1:5G*/
+	t_u8 band;
+	/** mlan_ds_11ax_he_capa */
+	mlan_ds_11ax_he_capa he_cap;
+} __ATTRIB_PACK__ mlan_ds_11ax_he_cfg, *pmlan_ds_11ax_he_cfg;
+
+/** Type definition of mlan_11axcmdcfg_obss_pd_offset for MLAN_OID_11AX_CMD_CFG
+ */
+typedef struct _mlan_11axcmdcfg_obss_pd_offset {
+	/** <NON_SRG_OffSET, SRG_OFFSET> */
+	t_u8 offset[2];
+} __ATTRIB_PACK__ mlan_11axcmdcfg_obss_pd_offset;
+
+/** Type definition of mlan_11axcmdcfg_sr_control for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_11axcmdcfg_sr_control {
+	/** 1 enable, 0 disable */
+	t_u8 control;
+} __ATTRIB_PACK__ mlan_11axcmdcfg_sr_control;
+
+/** Type definition of mlan_ds_11ax_sr_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_sr_cmd {
+	/** type*/
+	t_u16 type;
+	/** length of TLV */
+	t_u16 len;
+	/** value */
+	union {
+		mlan_11axcmdcfg_obss_pd_offset obss_pd_offset;
+		mlan_11axcmdcfg_sr_control sr_control;
+	} param;
+} __ATTRIB_PACK__ mlan_ds_11ax_sr_cmd, *pmlan_ds_11ax_sr_cmd;
+
+/** Type definition of mlan_ds_11ax_beam_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_beam_cmd {
+	/** command value: 1 is disable, 0 is enable*/
+	t_u8 value;
+} mlan_ds_11ax_beam_cmd, *pmlan_ds_11ax_beam_cmd;
+
+/** Type definition of mlan_ds_11ax_htc_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_htc_cmd {
+	/** command value: 1 is enable, 0 is disable*/
+	t_u8 value;
+} mlan_ds_11ax_htc_cmd, *pmlan_ds_11ax_htc_cmd;
+
+/** Type definition of mlan_ds_11ax_txop_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_txop_cmd {
+	/** Two byte rts threshold value of which only 10 bits, bit 0 to bit 9
+	 * are valid */
+	t_u16 rts_thres;
+} mlan_ds_11ax_txop_cmd, *pmlan_ds_11ax_txop_cmd;
+
+/** Type definition of mlan_ds_11ax_txomi_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_txomi_cmd {
+	/* 11ax spec 9.2.4.6a.2 OM Control 12 bits. Bit 0 to bit 11 */
+	t_u16 omi;
+} mlan_ds_11ax_txomi_cmd, *pmlan_ds_11ax_txomi_cmd;
+
+/** Type definition of mlan_ds_11ax_toltime_cmd for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_toltime_cmd {
+	/* OBSS Narrow Bandwidth RU Tolerance Time */
+	t_u32 tol_time;
+} mlan_ds_11ax_toltime_cmd, *pmlan_ds_11ax_toltime_cmd;
+
+/** Type definition of mlan_ds_11ax_cmd_cfg for MLAN_OID_11AX_CMD_CFG */
+typedef struct _mlan_ds_11ax_cmd_cfg {
+	/** Sub-command */
+	t_u32 sub_command;
+	/** Sub-id */
+	t_u32 sub_id;
+	/** 802.11n configuration parameter */
+	union {
+		/** SR configuration for MLAN_11AXCMD_SR_SUBID */
+		mlan_ds_11ax_sr_cmd sr_cfg;
+		/** Beam configuration for MLAN_11AXCMD_BEAM_SUBID */
+		mlan_ds_11ax_beam_cmd beam_cfg;
+		/** HTC configuration for MLAN_11AXCMD_HTC_SUBID */
+		mlan_ds_11ax_htc_cmd htc_cfg;
+		/** HTC configuration for MLAN_11AXCMD_TXOPRTS_SUBID */
+		mlan_ds_11ax_txop_cmd txop_cfg;
+		/** HTC configuration for MLAN_11AXCMD_TXOMI_SUBID */
+		mlan_ds_11ax_txomi_cmd txomi_cfg;
+		/** HTC configuration for MLAN_11AXCMD_TXOMI_SUBID */
+		mlan_ds_11ax_toltime_cmd toltime_cfg;
+	} param;
+} mlan_ds_11ax_cmd_cfg, *pmlan_ds_11ax_cmd_cfg;
+
+/** Maximum number of AC QOS queues available in the driver/firmware */
+#define MAX_AC_QUEUES 4
+
+/** Read/Write Mac register */
+#define HostCmd_CMD_MAC_REG_ACCESS 0x0019
+/** Read/Write BBP register */
+#define HostCmd_CMD_BBP_REG_ACCESS 0x001a
+/** Read/Write RF register */
+#define HostCmd_CMD_RF_REG_ACCESS 0x001b
+
+/** Data structure of WMM Aci/Aifsn */
+typedef struct _IEEEtypes_WmmAciAifsn_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Reserved */
+	t_u8 reserved : 1;
+	/** Aci */
+	t_u8 aci : 2;
+	/** Acm */
+	t_u8 acm : 1;
+	/** Aifsn */
+	t_u8 aifsn : 4;
+#else
+	/** Aifsn */
+	t_u8 aifsn : 4;
+	/** Acm */
+	t_u8 acm : 1;
+	/** Aci */
+	t_u8 aci : 2;
+	/** Reserved */
+	t_u8 reserved : 1;
+#endif
+} __ATTRIB_PACK__ IEEEtypes_WmmAciAifsn_t, *pIEEEtypes_WmmAciAifsn_t;
+
+/** Data structure of WMM ECW */
+typedef struct _IEEEtypes_WmmEcw_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Maximum Ecw */
+	t_u8 ecw_max : 4;
+	/** Minimum Ecw */
+	t_u8 ecw_min : 4;
+#else
+	/** Minimum Ecw */
+	t_u8 ecw_min : 4;
+	/** Maximum Ecw */
+	t_u8 ecw_max : 4;
+#endif
+} __ATTRIB_PACK__ IEEEtypes_WmmEcw_t, *pIEEEtypes_WmmEcw_t;
+
+/** Data structure of WMM AC parameters  */
+typedef struct _IEEEtypes_WmmAcParameters_t {
+	IEEEtypes_WmmAciAifsn_t aci_aifsn; /**< AciAifSn */
+	IEEEtypes_WmmEcw_t ecw; /**< Ecw */
+	t_u16 tx_op_limit; /**< Tx op limit */
+} __ATTRIB_PACK__ IEEEtypes_WmmAcParameters_t, *pIEEEtypes_WmmAcParameters_t;
+
+/** HostCmd_DS_802_11_CFG_DATA */
+typedef struct MAPP_HostCmd_DS_802_11_CFG_DATA {
+	/** Action */
+	t_u16 action;
+	/** Type */
+	t_u16 type;
+	/** Data length */
+	t_u16 data_len;
+	/** Data */
+	t_u8 data[1];
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CFG_DATA;
+
+/** Host Command ID : Configuration data */
+#define HostCmd_CMD_CFG_DATA 0x008f
+
+/** mlan_ioctl_11h_tpc_resp */
+typedef struct {
+	int status_code; /**< Firmware command result status code */
+	int tx_power; /**< Reported TX Power from the TPC Report */
+	int link_margin; /**< Reported Link margin from the TPC Report */
+	int rssi; /**< RSSI of the received TPC Report frame */
+} __ATTRIB_PACK__ mlan_ioctl_11h_tpc_resp;
+
+/** Host Command ID : 802.11 TPC adapt req */
+#define HostCmd_CMD_802_11_TPC_ADAPT_REQ 0x0060
+
+/** HostCmd_DS_802_11_CRYPTO */
+typedef struct MAPP_HostCmd_DS_802_11_CRYPTO {
+	t_u16 encdec; /**< Decrypt=0, Encrypt=1 */
+	t_u16 algorithm; /**< RC4=1 AES=2 , AES_KEY_WRAP=3 */
+	t_u16 key_IV_length; /**< Length of Key IV (bytes)   */
+	t_u8 keyIV[32]; /**< Key IV */
+	t_u16 key_length; /**< Length of Key (bytes) */
+	t_u8 key[32]; /**< Key */
+	MrvlIEtypes_Data_t data; /**< Plain text if encdec=Encrypt, Ciphertext
+				    data if encdec=Decrypt*/
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CRYPTO;
+
+/** HostCmd_DS_802_11_CRYPTO_AES_CCM */
+typedef struct MAPP_HostCmd_DS_802_11_CRYPTO_AES_CCM {
+	t_u16 encdec; /**< Decrypt=0, Encrypt=1 */
+	t_u16 algorithm; /**< AES_CCM=4 */
+	t_u16 key_length; /**< Length of Key (bytes)  */
+	t_u8 key[32]; /**< Key  */
+	t_u16 nonce_length; /**< Length of Nonce (bytes) */
+	t_u8 nonce[14]; /**< Nonce */
+	t_u16 AAD_length; /**< Length of AAD (bytes) */
+	t_u8 AAD[32]; /**< AAD */
+	MrvlIEtypes_Data_t data; /**< Plain text if encdec=Encrypt, Ciphertext
+				    data if encdec=Decrypt*/
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CRYPTO_AES_CCM;
+
+/** HostCmd_DS_802_11_CRYPTO_WAPI */
+typedef struct MAPP_HostCmd_DS_802_11_CRYPTO_WAPI {
+	t_u16 encdec; /**< Decrypt=0, Encrypt=1 */
+	t_u16 algorithm; /**< WAPI =5 */
+	t_u16 key_length; /**< Length of Key (bytes)  */
+	t_u8 key[32]; /**< Key  */
+	t_u16 nonce_length; /**< Length of Nonce (bytes) */
+	t_u8 nonce[16]; /**< Nonce */
+	t_u16 AAD_length; /**< Length of AAD (bytes) */
+	t_u8 AAD[48]; /**< AAD */
+	t_u16 data_length; /**< Length of data (bytes)  */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_CRYPTO_WAPI;
+/** WAPI cipher test */
+#define CIPHER_TEST_WAPI (5)
+/** AES CCM cipher test */
+#define CIPHER_TEST_AES_CCM (4)
+/** GCMP cipher test */
+#define CIPHER_TEST_GCMP (6)
+/** Host Command ID : 802.11 crypto */
+#define HostCmd_CMD_802_11_CRYPTO 0x0078
+
+/** HostCmd_DS_802_11_SUBSCRIBE_EVENT */
+typedef struct MAPP_HostCmd_DS_802_11_SUBSCRIBE_EVENT {
+	/** Action */
+	t_u16 action;
+	/** Events */
+	t_u16 events;
+} __ATTRIB_PACK__ HostCmd_DS_802_11_SUBSCRIBE_EVENT;
+
+/** MrvlIEtypes_RssiParamSet_t */
+typedef struct MrvlIEtypes_RssiThreshold {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** RSSI value */
+	t_u8 RSSI_value;
+	/** RSSI frequency */
+	t_u8 RSSI_freq;
+} __ATTRIB_PACK__ MrvlIEtypes_RssiThreshold_t;
+
+/** MrvlIEtypes_SnrThreshold_t */
+typedef struct MrvlIEtypes_SnrThreshold {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** SNR value */
+	t_u8 SNR_value;
+	/** SNR frequency */
+	t_u8 SNR_freq;
+} __ATTRIB_PACK__ MrvlIEtypes_SnrThreshold_t;
+
+/** MrvlIEtypes_FailureCount_t */
+typedef struct MrvlIEtypes_FailureCount {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Failure value */
+	t_u8 fail_value;
+	/** Failure frequency */
+	t_u8 fail_freq;
+} __ATTRIB_PACK__ MrvlIEtypes_FailureCount_t;
+
+/** MrvlIEtypes_BeaconsMissed_t */
+typedef struct MrvlIEtypes_BeaconsMissed {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Number of beacons missed */
+	t_u8 beacon_missed;
+	/** Reserved */
+	t_u8 reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_BeaconsMissed_t;
+
+/** MrvlIEtypes_LinkQuality_t */
+typedef struct MrvlIEtypes_LinkQuality {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Link SNR threshold */
+	t_u16 link_SNR_thrs;
+	/** Link SNR frequency */
+	t_u16 link_SNR_freq;
+	/** Minimum rate value */
+	t_u16 min_rate_val;
+	/** Minimum rate frequency */
+	t_u16 min_rate_freq;
+	/** Tx latency value */
+	t_u32 tx_latency_val;
+	/** Tx latency threshold */
+	t_u32 tx_latency_thrs;
+} __ATTRIB_PACK__ MrvlIEtypes_LinkQuality_t;
+
+/** Host Command ID : 802.11 subscribe event */
+#define HostCmd_CMD_802_11_SUBSCRIBE_EVENT 0x0075
+
+/** TLV type : Beacon RSSI low */
+#define TLV_TYPE_RSSI_LOW (PROPRIETARY_TLV_BASE_ID + 0x04) /* 0x0104 */
+/** TLV type : Beacon SNR low */
+#define TLV_TYPE_SNR_LOW (PROPRIETARY_TLV_BASE_ID + 0x05) /* 0x0105 */
+/** TLV type : Fail count */
+#define TLV_TYPE_FAILCOUNT (PROPRIETARY_TLV_BASE_ID + 0x06) /* 0x0106 */
+/** TLV type : BCN miss */
+#define TLV_TYPE_BCNMISS (PROPRIETARY_TLV_BASE_ID + 0x07) /* 0x0107 */
+/** TLV type : Beacon RSSI high */
+#define TLV_TYPE_RSSI_HIGH (PROPRIETARY_TLV_BASE_ID + 0x16) /* 0x0116 */
+/** TLV type : Beacon SNR high */
+#define TLV_TYPE_SNR_HIGH (PROPRIETARY_TLV_BASE_ID + 0x17) /* 0x0117 */
+
+/** TLV type :Link Quality */
+#define TLV_TYPE_LINK_QUALITY (PROPRIETARY_TLV_BASE_ID + 0x24) /* 0x0124 */
+
+/** TLV type : Data RSSI low */
+#define TLV_TYPE_RSSI_LOW_DATA (PROPRIETARY_TLV_BASE_ID + 0x26) /* 0x0126 */
+/** TLV type : Data SNR low */
+#define TLV_TYPE_SNR_LOW_DATA (PROPRIETARY_TLV_BASE_ID + 0x27) /* 0x0127 */
+/** TLV type : Data RSSI high */
+#define TLV_TYPE_RSSI_HIGH_DATA (PROPRIETARY_TLV_BASE_ID + 0x28) /* 0x0128 */
+/** TLV type : Data SNR high */
+#define TLV_TYPE_SNR_HIGH_DATA (PROPRIETARY_TLV_BASE_ID + 0x29) /* 0x0129 */
+
+/** MrvlIEtypes_PreBeaconLost_t */
+typedef struct MrvlIEtypes_PreBeaconLost {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Pre-Beacon Lost */
+	t_u8 pre_beacon_lost;
+	/** Reserved */
+	t_u8 reserved;
+} __ATTRIB_PACK__ MrvlIEtypes_PreBeaconLost_t;
+
+/** TLV type: Pre-Beacon Lost */
+#define TLV_TYPE_PRE_BEACON_LOST (PROPRIETARY_TLV_BASE_ID + 0x49) /* 0x0149 */
+
+/** AutoTx_MacFrame_t */
+typedef struct AutoTx_MacFrame {
+	t_u16 interval; /**< in seconds */
+	t_u8 priority; /**< User Priority: 0~7, ignored if non-WMM */
+	t_u8 reserved; /**< set to 0 */
+	t_u16 frame_len; /**< Length of MAC frame payload */
+	t_u8 dest_mac_addr[MLAN_MAC_ADDR_LENGTH]; /**< Destination MAC address
+						   */
+	t_u8 src_mac_addr[MLAN_MAC_ADDR_LENGTH]; /**< Source MAC address */
+	t_u8 payload[]; /**< Payload */
+} __ATTRIB_PACK__ AutoTx_MacFrame_t;
+
+/** MrvlIEtypes_AutoTx_t */
+typedef struct MrvlIEtypes_AutoTx {
+	MrvlIEtypesHeader_t header; /**< Header */
+	AutoTx_MacFrame_t auto_tx_mac_frame; /**< Auto Tx MAC frame */
+} __ATTRIB_PACK__ MrvlIEtypes_AutoTx_t;
+
+/** HostCmd_DS_802_11_AUTO_TX */
+typedef struct MAPP_HostCmd_DS_802_11_AUTO_TX {
+	/** Action */
+	t_u16 action; /* 0 = ACT_GET; 1 = ACT_SET; */
+	MrvlIEtypes_AutoTx_t auto_tx; /**< Auto Tx */
+} __ATTRIB_PACK__ HostCmd_DS_802_11_AUTO_TX;
+
+/** Host Command ID : 802.11 auto Tx */
+#define HostCmd_CMD_802_11_AUTO_TX 0x0082
+
+/** TLV type : Auto Tx */
+#define TLV_TYPE_AUTO_TX (PROPRIETARY_TLV_BASE_ID + 0x18) /* 0x0118 */
+
+/** Host Command ID : CAU register access */
+#define HostCmd_CMD_CAU_REG_ACCESS 0x00ed
+
+/** Host Command ID : Memory access */
+#define HostCmd_CMD_MEM_ACCESS 0x0086
+
+typedef struct {
+	t_u32 timeSinceLastQuery_ms; /**< Duration of stats collection */
+
+	t_u16 bcnCnt; /**< Number of beacons received */
+	t_u16 bcnMiss; /**< Estimate of beacons missed */
+	t_s16 bcnRssiAvg; /**< Avg beacon RSSI */
+	t_s16 bcnSnrAvg; /**< Avg beacon SNR */
+
+	t_u32 rxPkts; /**< Number of packets received */
+	t_s16 rxRssiAvg; /**< Avg received packet RSSI */
+	t_s16 rxSnrAvg; /**< Avg received packet SNR */
+
+	t_u32 txPkts; /**< Number of packets transmitted */
+	t_u32 txAttempts; /**< Number of attempts made */
+	t_u32 txFailures; /**< Number of pkts that failed */
+	t_u8 txInitRate; /**< Current rate adaptation TX rateid */
+	t_u8 reserved[3]; /**< Reserved */
+
+	t_u16 txQueuePktCnt[MAX_AC_QUEUES]; /**< Number of packets per AC */
+	t_u32 txQueueDelay[MAX_AC_QUEUES]; /**< Averge queue delay per AC*/
+} __ATTRIB_PACK__ HostCmd_DS_LINK_STATS_SUMMARY;
+
+#define HostCmd_CMD_LINK_STATS_SUMMARY 0x00d3
+
+/** Type enumeration of WMM AC_QUEUES */
+typedef enum _wmm_ac {
+	AC_BE,
+	AC_BK,
+	AC_VI,
+	AC_VO,
+} wmm_ac;
+
+/** Data structure of Host command WMM_PARAM_CFG  */
+typedef struct _HostCmd_DS_WMM_PARAM_CONFIG {
+	/** action */
+	t_u16 action;
+	/** AC Parameters Record WMM_AC_BE, WMM_AC_BK, WMM_AC_VI, WMM_AC_VO */
+	IEEEtypes_WmmAcParameters_t ac_params[MAX_AC_QUEUES];
+} __ATTRIB_PACK__ HostCmd_DS_WMM_PARAM_CONFIG;
+
+/** Host Command ID : Configure ADHOC_OVER_IP parameters */
+#define HostCmd_CMD_WMM_PARAM_CONFIG 0x023a
+
+/** HostCmd_DS_REG */
+typedef struct MAPP_HostCmd_DS_REG {
+	/** Read or write */
+	t_u16 action;
+	/** Register offset */
+	t_u16 offset;
+	/** Value */
+	t_u32 value;
+} __ATTRIB_PACK__ HostCmd_DS_REG;
+
+/** HostCmd_DS_MEM */
+typedef struct MAPP_HostCmd_DS_MEM {
+	/** Read or write */
+	t_u16 action;
+	/** Reserved */
+	t_u16 reserved;
+	/** Address */
+	t_u32 addr;
+	/** Value */
+	t_u32 value;
+} __ATTRIB_PACK__ HostCmd_DS_MEM;
+
+typedef struct _HostCmd_DS_MEF_CFG {
+	/** Criteria */
+	t_u32 Criteria;
+	/** Number of entries */
+	t_u16 NumEntries;
+} __ATTRIB_PACK__ HostCmd_DS_MEF_CFG;
+
+typedef struct _MEF_CFG_DATA {
+	/** Size */
+	t_u16 size;
+	/** Data */
+	HostCmd_DS_MEF_CFG data;
+} __ATTRIB_PACK__ MEF_CFG_DATA;
+
+/** cloud keep alive parameters */
+typedef struct _cloud_keep_alive {
+	/** id */
+	t_u8 mkeep_alive_id;
+	/** enable/disable of this id */
+	t_u8 enable;
+	/** enable/disable reset*/
+	t_u8 reset;
+	/** Reserved */
+	t_u8 reserved;
+	/** Destination MAC address */
+	t_u8 dst_mac[ETH_ALEN];
+	/** Source MAC address */
+	t_u8 src_mac[ETH_ALEN];
+	/** packet send period */
+	t_u32 sendInterval;
+	/** packet retry interval */
+	t_u32 retryInterval;
+	/** packet retry count */
+	t_u8 retryCount;
+	/** packet length */
+	t_u8 pkt_len;
+	/** packet content */
+	t_u8 pkt[255];
+} __ATTRIB_PACK__ cloud_keep_alive;
+
+#endif /* _MLANUTL_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/load b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/load
new file mode 100644
index 000000000..e9819c959
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/load
@@ -0,0 +1,16 @@
+#! /bin/bash
+if echo $1 2>&1 | grep dbg > /dev/null; then
+    insmod mlan-dbg.ko
+else
+    insmod mlan.ko
+fi
+insmod $1.ko $2 $3 $4 $5 $6 $7 $8
+for (( i = 1; i <= 10; i++ ))
+do
+    ifconfig -a 2>&1 | grep -E "(mlan0|uap0|wfd0)" > /dev/null
+    if [ $? -eq 0 ]; then
+        exit
+    fi
+    sleep 1
+done
+
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/unload b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/unload
new file mode 100644
index 000000000..4f2a306d8
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/unload
@@ -0,0 +1,22 @@
+#! /bin/bash
+ifconfig mlan0 down
+ifconfig uap0 down
+ifconfig mmlan0 down
+ifconfig muap0 down
+ifconfig uap1 down
+ifconfig muap1 down
+ifconfig wfd0 down
+ifconfig wfd1 down
+ifconfig mwfd0 down
+ifconfig mwfd1 down
+for (( i = 0; i <= 30; i++ ))
+do
+    rmmod moal 2> /dev/null
+    lsmod 2>&1 | grep moal > /dev/null
+    if [ ! $? -eq 0 ]; then
+        break
+    fi
+    sleep 1
+done
+rmmod mlan
+sleep 5
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_auto_go.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_auto_go.sh
new file mode 100644
index 000000000..78aa8a8d4
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_auto_go.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+# iwpriv mlan0 drvdbg 0x20037
+# change the mac address
+./wifidirect/update_mac.sh
+echo "wfd0 Mac address updated in config/wifidirect.conf"
+
+
+./wifidirectutl wfd0 wifidirect_config config/wifidirect.conf
+#ifdef STREAM_2X2
+iwpriv wfd0 bssrole 1
+#else
+# iwpriv wfd0 bssrole 1
+#endif
+./uaputl.exe -i wfd0 sys_config config/uaputl_wifidirect.conf
+#ifdef STREAM_2X2
+iwpriv wfd0 bssrole 0
+#else
+# iwpriv wfd0 bssrole 0
+#endif
+# iwpriv wfd0 bssrole 1
+# change the group owner parameters
+# either in uaputl_wifidirect.conf or using CLI below
+#./uaputl.exe -i wfd0 sys_cfg_wpa_passphrase 1234567890
+#./uaputl.exe -i wfd0 sys_cfg_eapol_gwk_hsk 2000 3
+#./uaputl.exe -i wfd0 sys_cfg_eapol_pwk_hsk 2000 3
+# iwpriv wfd0 bssrole 0
+./wifidirectutl wfd0 wifidirect_mode 1
+iwpriv wfd0 bssrole 1
+./wifidirectutl wfd0 wifidirect_mode 2
+./uaputl.exe -i wfd0 bss_start
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_find_phase.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_find_phase.sh
new file mode 100644
index 000000000..26ddd6096
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_find_phase.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+# iwpriv wfd0 drvdbg 0x20037
+#change the mac address
+./wifidirect/update_mac.sh
+echo "wfd0 Mac address updated in config/wifidirect.conf"
+
+#ifdef STREAM_2X2
+iwpriv wfd0 bssrole 1
+#else
+# iwpriv wfd0 bssrole 1
+#endif
+./uaputl.exe -i wfd0 sys_config config/uaputl_wifidirect.conf
+#ifdef STREAM_2X2
+iwpriv wfd0 bssrole 0
+#else
+# iwpriv wfd0 bssrole 0
+#endif
+./wifidirectutl wfd0 wifidirect_config config/wifidirect.conf
+# change the passphrase
+# either in uaputl_wifidirect.conf or using CLI below
+#./uaputl.exe -i wfd0 sys_cfg_wpa_passphrase 1234567890
+./wifidirectutl wfd0 wifidirect_mode 1
+./wifidirectutl wfd0 wifidirect_params_config config/wifidirect.conf
+./mlanutl wfd0 hostcmd config/bg_scan_wifidirect.conf bgscfg
+./wifidirectutl wfd0 wifidirect_mode 4
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_listen_state.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_listen_state.sh
new file mode 100644
index 000000000..91c1e4d0e
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/start_listen_state.sh
@@ -0,0 +1,18 @@
+#!/bin/bash
+iwpriv wfd0 drvdbg 0x20037
+# change the mac address
+ifconfig mlan0 hw ether 00:50:43:21:0e:08
+ifconfig wfd0 hw ether 00:50:43:21:0e:08
+ifconfig uap0 hw ether 00:50:43:21:0e:08
+
+iwpriv wfd0 deepsleep 0
+iwconfig wfd0 power off
+
+iwpriv wfd0 bssrole 1
+./uaputl.exe -i wfd0 sys_config config/uaputl_wifidirect.conf
+iwpriv wfd0 bssrole 0
+./wifidirectutl wfd0 wifidirect_config config/wifidirect.conf
+./uaputl.exe -i wfd0 sys_cfg_protocol 32
+./uaputl.exe -i wfd0 sys_cfg_cipher 8 8
+./uaputl.exe -i wfd0 sys_cfg_wpa_passphrase 1234567890
+./wifidirectutl wfd0 wifidirect_mode 1
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_auto_go.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_auto_go.sh
new file mode 100644
index 000000000..eda03ef67
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_auto_go.sh
@@ -0,0 +1,8 @@
+#!/bin/bash
+./uaputl.exe -i wfd0 bss_stop
+sleep 1
+iwpriv wfd0 bssrole 0
+./wifidirectutl wfd0 wifidirect_mode 0
+# IE clear assume index 0, 1
+./uaputl.exe -i wfd0 sys_cfg_custom_ie 0 0
+./uaputl.exe -i wfd0 sys_cfg_custom_ie 1 0
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_wifidirect_client.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_wifidirect_client.sh
new file mode 100644
index 000000000..5ae1ad5e3
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/stop_wifidirect_client.sh
@@ -0,0 +1,6 @@
+#!/bin/bash
+# deauth the GO first
+./wifidirectutl wfd0 wifidirect_mode 0
+# IE clear assume index 0, 1
+./uaputl.exe -i wfd0 sys_cfg_custom_ie 0 0
+./uaputl.exe -i wfd0 sys_cfg_custom_ie 1 0
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/update_mac.sh b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/update_mac.sh
new file mode 100644
index 000000000..d744db98a
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mapp_org/script/wifidirect/update_mac.sh
@@ -0,0 +1,16 @@
+#!/bin/bash
+MAC=`ifconfig wfd0 | grep wfd0 | tr -s ' ' | cut -d ' ' -f5`
+MAC26=`echo $MAC | cut -d ':' -f2-6`
+LAA=`echo $MAC | cut -d ':' -f1`
+LAA=$((0x$LAA+2))
+if [ $LAA -lt 16 ] ; then
+LAA=`printf "%X\n" $LAA`
+MACLAA=0$LAA:$MAC26
+else
+LAA=`printf "%X\n" $LAA`
+MACLAA=$LAA:$MAC26
+fi
+sed "s/00:50:43:00:00:00/$MAC/" config/wifidirect.conf > tmp$$
+mv tmp$$ config/wifidirect.conf
+sed "s/02:50:43:00:00:00/$MACLAA/" config/wifidirect.conf > tmp$$
+mv tmp$$ config/wifidirect.conf
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan.h
old mode 100644
new mode 100755
index d2cd022e0..4d48ce8e3
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan.h
@@ -4,7 +4,7 @@
  *  It also defines the data structures used for APIs between MLAN and MOAL.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c
old mode 100644
new mode 100755
index 04aee8d4e..298629c6d
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.c
@@ -3,7 +3,7 @@
  *  @brief This file contains the functions for station ioctl.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2011-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -27,8 +27,7 @@
 #include "mlan_main.h"
 #include "mlan_wmm.h"
 #include "mlan_11n.h"
-
-#define NO_NSS_SUPPORT 0x3
+#include "mlan_11ac.h"
 
 /********************************************************
 			Local Variables
@@ -54,97 +53,84 @@ t_u16 wlan_convert_mcsmap_to_maxrate(mlan_private *priv, t_u16 bands,
  *
  *  @return             channel center frequency center, if found; O, otherwise
  */
-
 t_u8 wlan_get_center_freq_idx(mlan_private *pmpriv, t_u16 band, t_u32 pri_chan,
 			      t_u8 chan_bw)
 {
-	t_u8 center_freq_idx = 0;
-
-	if (band & BAND_AAC) {
-		switch (pri_chan) {
-		case 36:
-		case 40:
-		case 44:
-		case 48:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 42;
-				break;
-			}
-			/* fall through */
-		case 52:
-		case 56:
-		case 60:
-		case 64:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 58;
-				break;
-			} else if (chan_bw == CHANNEL_BW_160MHZ) {
-				center_freq_idx = 50;
-				break;
-			}
-			/* fall through */
-		case 100:
-		case 104:
-		case 108:
-		case 112:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 106;
-				break;
-			}
-			/* fall through */
-		case 116:
-		case 120:
-		case 124:
-		case 128:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 122;
-				break;
-			} else if (chan_bw == CHANNEL_BW_160MHZ) {
-				center_freq_idx = 114;
-				break;
-			}
-			/* fall through */
-		case 132:
-		case 136:
-		case 140:
-		case 144:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 138;
-				break;
-			}
-			/* fall through */
-		case 149:
-		case 153:
-		case 157:
-		case 161:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 155;
-				break;
-			}
-			/* fall through */
-		case 165:
-		case 169:
-		case 173:
-		case 177:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 171;
-				break;
-			}
-			/* fall through */
-		case 184:
-		case 188:
-		case 192:
-		case 196:
-			if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 190;
-				break;
-			}
-			/* fall through */
-		default: /* error. go to the default */
-			center_freq_idx = 42;
+	struct center_freq_desc {
+		t_u8 pri_chan;
+		t_u8 ch_40;
+		t_u8 ch_80;
+		t_u8 ch_160;
+	};
+
+	static const struct center_freq_desc center_freq_idx_map_5g[] = {
+		{.pri_chan = 36, .ch_40 = 38, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 40, .ch_40 = 38, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 44, .ch_40 = 46, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 48, .ch_40 = 46, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 52, .ch_40 = 54, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 56, .ch_40 = 54, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 60, .ch_40 = 62, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 64, .ch_40 = 62, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 68, .ch_40 = 70, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 72, .ch_40 = 70, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 76, .ch_40 = 78, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 80, .ch_40 = 78, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 84, .ch_40 = 86, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 88, .ch_40 = 86, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 92, .ch_40 = 94, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 96, .ch_40 = 94, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 100, .ch_40 = 102, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 104, .ch_40 = 102, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 108, .ch_40 = 110, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 112, .ch_40 = 110, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 116, .ch_40 = 118, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 120, .ch_40 = 118, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 124, .ch_40 = 126, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 128, .ch_40 = 126, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 132, .ch_40 = 134, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 136, .ch_40 = 134, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 140, .ch_40 = 142, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 144, .ch_40 = 142, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 149, .ch_40 = 151, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 153, .ch_40 = 151, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 157, .ch_40 = 159, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 161, .ch_40 = 159, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 165, .ch_40 = 167, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 169, .ch_40 = 167, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 173, .ch_40 = 175, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 177, .ch_40 = 175, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 184, .ch_40 = 186, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 188, .ch_40 = 186, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 192, .ch_40 = 194, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 196, .ch_40 = 194, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 0,
+		 .ch_40 = 42 /* terminator with default cfreq */}};
+
+	const struct center_freq_desc *map = MNULL;
+
+	if (band == BAND_5GHZ)
+		map = center_freq_idx_map_5g;
+
+	for (; map != MNULL; map++) {
+		/* reached end of map, return default value for that map */
+		if (map->pri_chan == 0)
+			return map->ch_40;
+
+		if (map->pri_chan == pri_chan) {
+			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
+			    chan_bw == CHANNEL_BW_40MHZ_BELOW)
+				return map->ch_40;
+
+			if (chan_bw == CHANNEL_BW_80MHZ)
+				return map->ch_80;
+
+			if (chan_bw == CHANNEL_BW_160MHZ)
+				return map->ch_160;
 		}
 	}
-	return center_freq_idx;
+
+	return 0;
 }
 
 /**
@@ -193,10 +179,9 @@ static t_u8 wlan_get_nss_num_vht_mcs(t_u16 mcs_map_set)
  *  @return             N/A
  */
 static void wlan_fill_cap_info(mlan_private *priv, VHT_capa_t *vht_cap,
-			       t_u8 bands)
+			       t_u16 bands)
 {
 	t_u32 usr_dot_11ac_dev_cap;
-
 	ENTER();
 
 	if (bands & BAND_A)
@@ -206,6 +191,7 @@ static void wlan_fill_cap_info(mlan_private *priv, VHT_capa_t *vht_cap,
 
 	vht_cap->vht_cap_info = usr_dot_11ac_dev_cap;
 
+	RESET_VHTCAP_MAXMPDULEN(vht_cap->vht_cap_info);
 	LEAVE();
 }
 
@@ -228,11 +214,8 @@ static mlan_status wlan_11ac_ioctl_vhtcfg(pmlan_adapter pmadapter,
 	t_u32 cfg_value = 0;
 	t_u32 hw_value = 0;
 	t_u8 nss = 0;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	t_u16 rx_nss = 0;
 	t_u16 tx_nss = 0;
-#endif
 
 	ENTER();
 
@@ -311,9 +294,8 @@ static mlan_status wlan_11ac_ioctl_vhtcfg(pmlan_adapter pmadapter,
 
 		/** update the RX MCS map */
 		if (cfg->param.vht_cfg.txrx & MLAN_RADIO_RX) {
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 			if (IS_CARD9098(pmadapter->card_type) ||
+			    IS_CARDIW62X(pmadapter->card_type) ||
 			    IS_CARD9097(pmadapter->card_type)) {
 				if (cfg->param.vht_cfg.band == BAND_SELECT_A) {
 					rx_nss = GET_RXMCSSUPP(
@@ -332,7 +314,6 @@ static mlan_status wlan_11ac_ioctl_vhtcfg(pmlan_adapter pmadapter,
 						0x0f;
 				}
 			}
-#endif
 			/* use the previous user value */
 			if (cfg->param.vht_cfg.vht_rx_mcs == 0xffffffff)
 				cfg->param.vht_cfg.vht_rx_mcs = GET_VHTMCS(
@@ -343,11 +324,8 @@ static mlan_status wlan_11ac_ioctl_vhtcfg(pmlan_adapter pmadapter,
 				hw_value = GET_DEVNSSRXMCS(
 					pmadapter->hw_dot_11ac_mcs_support,
 					nss);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 				if ((rx_nss != 0) && (nss > rx_nss))
 					cfg_value = NO_NSS_SUPPORT;
-#endif
 				if ((hw_value == NO_NSS_SUPPORT) ||
 				    (cfg_value == NO_NSS_SUPPORT))
 					SET_VHTNSSMCS(
@@ -370,11 +348,8 @@ static mlan_status wlan_11ac_ioctl_vhtcfg(pmlan_adapter pmadapter,
 				hw_value = GET_DEVNSSTXMCS(
 					pmadapter->hw_dot_11ac_mcs_support,
 					nss);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
-				if ((rx_nss != 0) && (nss > rx_nss))
+				if ((tx_nss != 0) && (nss > tx_nss))
 					cfg_value = NO_NSS_SUPPORT;
-#endif
 				if ((hw_value == NO_NSS_SUPPORT) ||
 				    (cfg_value == NO_NSS_SUPPORT))
 					SET_VHTNSSMCS(
@@ -592,15 +567,15 @@ void wlan_show_dot11acdevcap(pmlan_adapter pmadapter, t_u32 cap)
 	switch (GET_VHTCAP_MAXMPDULEN(cap)) {
 	case 0x0:
 		PRINTM(MINFO,
-		       "GET_HW_SPEC: Maximum MSDU length = 3895 octets\n");
+		       "GET_HW_SPEC: Maximum MPDU length = 3895 octets\n");
 		break;
 	case 0x1:
 		PRINTM(MINFO,
-		       "GET_HW_SPEC: Maximum MSDU length = 7991 octets\n");
+		       "GET_HW_SPEC: Maximum MPDU length = 7991 octets\n");
 		break;
 	case 0x2:
 		PRINTM(MINFO,
-		       "GET_HW_SPEC: Maximum MSDU length = 11454 octets\n");
+		       "GET_HW_SPEC: Maximum MPDU length = 11454 octets\n");
 		break;
 	default:
 		PRINTM(MINFO, "Unsupport value\n");
@@ -795,10 +770,7 @@ void wlan_fill_vht_cap_tlv(mlan_private *priv, MrvlIETypes_VHTCap_t *pvht_cap,
 	t_u16 mcs_user = 0;
 	t_u16 mcs_resp = 0;
 	t_u16 nss;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	t_u16 rx_nss = 0, tx_nss = 0;
-#endif
 	ENTER();
 
 	/* Fill VHT cap info */
@@ -816,9 +788,8 @@ void wlan_fill_vht_cap_tlv(mlan_private *priv, MrvlIETypes_VHTCap_t *pvht_cap,
 	if (flag)
 		mcs_map_resp =
 			wlan_le16_to_cpu(pvht_cap->vht_cap.mcs_sets.rx_mcs_map);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	if (IS_CARD9098(priv->adapter->card_type) ||
+	    IS_CARDIW62X(priv->adapter->card_type) ||
 	    IS_CARD9097(priv->adapter->card_type)) {
 		if (bands & BAND_A) {
 			rx_nss = GET_RXMCSSUPP(priv->adapter->user_htstream >>
@@ -835,16 +806,12 @@ void wlan_fill_vht_cap_tlv(mlan_private *priv, MrvlIETypes_VHTCap_t *pvht_cap,
 		if (bw_80p80)
 			rx_nss = tx_nss = 1;
 	}
-#endif
 	mcs_map_result = 0;
 	for (nss = 1; nss <= 8; nss++) {
 		mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
 		mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if ((rx_nss != 0) && (nss > rx_nss))
 			mcs_user = NO_NSS_SUPPORT;
-#endif
 		if ((mcs_user == NO_NSS_SUPPORT) ||
 		    (mcs_resp == NO_NSS_SUPPORT))
 			SET_VHTNSSMCS(mcs_map_result, nss, NO_NSS_SUPPORT);
@@ -872,11 +839,8 @@ void wlan_fill_vht_cap_tlv(mlan_private *priv, MrvlIETypes_VHTCap_t *pvht_cap,
 	for (nss = 1; nss <= 8; nss++) {
 		mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
 		mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if ((tx_nss != 0) && (nss > tx_nss))
 			mcs_user = NO_NSS_SUPPORT;
-#endif
 		if ((mcs_user == NO_NSS_SUPPORT) ||
 		    (mcs_resp == NO_NSS_SUPPORT))
 			SET_VHTNSSMCS(mcs_map_result, nss, NO_NSS_SUPPORT);
@@ -937,6 +901,146 @@ void wlan_fill_vht_cap_ie(mlan_private *priv, IEEEtypes_VHTCap_t *pvht_cap,
 	return;
 }
 
+/*
+ *  @brief This function check if AP is in 11ac mode
+ *
+ *  @param priv         A pointer to mlan_private structure
+ *
+ *  @return             MTRUE/MFALSE
+ */
+t_u8 wlan_is_ap_in_11ac_mode(mlan_private *priv)
+{
+	BSSDescriptor_t *pbss_desc;
+	IEEEtypes_VHTOprat_t *vht_oprat = MNULL;
+	pbss_desc = &priv->curr_bss_params.bss_descriptor;
+	vht_oprat = pbss_desc->pvht_oprat;
+	if (!pbss_desc->pvht_cap)
+		return MFALSE;
+	if (vht_oprat && (vht_oprat->ieee_hdr.element_id == VHT_OPERATION)) {
+		if (vht_oprat->chan_width == VHT_OPER_CHWD_20_40MHZ)
+			return MFALSE;
+		else
+			return MTRUE;
+	} else
+		return MFALSE;
+}
+
+/**
+ *  @brief This function fills the VHTOperation ie out put format is CPU
+ *
+ *  @param priv         A pointer to mlan_private structure
+ *  @param vht_oprat    A pointer to IEEEtypes_VHTOprat_t structure
+ *  @param sta_ptr      A pointer to sta_node
+ *
+ *  @return             N/A
+ */
+void wlan_fill_tdls_vht_oprat_ie(mlan_private *priv,
+				 IEEEtypes_VHTOprat_t *vht_oprat,
+				 sta_node *sta_ptr)
+{
+	t_u8 supp_chwd_set;
+	t_u8 peer_supp_chwd_set;
+	t_u8 ap_supp_chwd_set;
+	t_u32 usr_vht_cap_info;
+
+	t_u16 mcs_map_user = 0;
+	t_u16 mcs_map_resp = 0;
+	t_u16 mcs_map_result = 0;
+	t_u16 mcs_user = 0;
+	t_u16 mcs_resp = 0;
+	t_u16 nss;
+	t_u8 chan_bw = 0;
+	BSSDescriptor_t *pbss_desc;
+	IEEEtypes_VHTCap_t *pvht_cap = &sta_ptr->vht_cap;
+	IEEEtypes_VHTCap_t *ap_vht_cap = MNULL;
+	ENTER();
+
+	pbss_desc = &priv->curr_bss_params.bss_descriptor;
+
+	/* Check if AP is in 11ac mode */
+	if (MFALSE == wlan_is_ap_in_11ac_mode(priv)) {
+		if (sta_ptr->ExtCap.ieee_hdr.element_id != EXT_CAPABILITY) {
+			PRINTM(MMSG, "No Peer's Ext_cap info\n");
+			return;
+		}
+		if (!ISSUPP_EXTCAP_TDLS_WIDER_BANDWIDTH(
+			    sta_ptr->ExtCap.ext_cap)) {
+			PRINTM(MMSG,
+			       "Peer don't support Wider Bandwitch in Ext_cap\n");
+			return;
+		}
+	} else {
+		ap_vht_cap = pbss_desc->pvht_cap;
+	}
+
+	vht_oprat->ieee_hdr.element_id = VHT_OPERATION;
+	vht_oprat->ieee_hdr.len =
+		sizeof(IEEEtypes_VHTOprat_t) - sizeof(IEEEtypes_Header_t);
+
+	if (pbss_desc->bss_band & BAND_A)
+		usr_vht_cap_info = priv->usr_dot_11ac_dev_cap_a;
+	else
+		usr_vht_cap_info = priv->usr_dot_11ac_dev_cap_bg;
+
+	/* find the minmum bandwith between AP/TDLS peers */
+	supp_chwd_set = GET_VHTCAP_CHWDSET(usr_vht_cap_info);
+	peer_supp_chwd_set = GET_VHTCAP_CHWDSET(pvht_cap->vht_cap.vht_cap_info);
+	supp_chwd_set = MIN(supp_chwd_set, peer_supp_chwd_set);
+
+	/* We need check AP's bandwidth when TDLS_WIDER_BANDWIDTH is off */
+	if (ap_vht_cap &&
+	    !ISSUPP_EXTCAP_TDLS_WIDER_BANDWIDTH(sta_ptr->ExtCap.ext_cap)) {
+		ap_supp_chwd_set =
+			GET_VHTCAP_CHWDSET(ap_vht_cap->vht_cap.vht_cap_info);
+		supp_chwd_set = MIN(supp_chwd_set, ap_supp_chwd_set);
+	}
+	switch (supp_chwd_set) {
+	case VHT_CAP_CHWD_80MHZ:
+		vht_oprat->chan_width = VHT_OPER_CHWD_80MHZ;
+		break;
+	case VHT_CAP_CHWD_160MHZ:
+		vht_oprat->chan_width = VHT_OPER_CHWD_160MHZ;
+		break;
+	case VHT_CAP_CHWD_80_80MHZ:
+		vht_oprat->chan_width = VHT_OPER_CHWD_80_80MHZ;
+		break;
+	}
+
+	/* Fill BASIC VHT MCS and NSS Set */
+	/* rx MCS Set, find the minimum of the user rx mcs and peer rx mcs*/
+	mcs_map_user = GET_DEVRXMCSMAP(priv->usr_dot_11ac_mcs_support);
+	mcs_map_resp = pvht_cap->vht_cap.mcs_sets.rx_mcs_map;
+	mcs_map_result = 0;
+	for (nss = 1; nss <= 8; nss++) {
+		mcs_user = GET_VHTNSSMCS(mcs_map_user, nss);
+		mcs_resp = GET_VHTNSSMCS(mcs_map_resp, nss);
+		if ((mcs_user == NO_NSS_SUPPORT) ||
+		    (mcs_resp == NO_NSS_SUPPORT))
+			SET_VHTNSSMCS(mcs_map_result, nss, NO_NSS_SUPPORT);
+		else
+			SET_VHTNSSMCS(mcs_map_result, nss,
+				      MIN(mcs_user, mcs_resp));
+	}
+	/* Basic MCS map */
+	vht_oprat->basic_MCS_map = mcs_map_result;
+	switch (vht_oprat->chan_width) {
+	case VHT_OPER_CHWD_80MHZ:
+		chan_bw = CHANNEL_BW_80MHZ;
+		break;
+	case VHT_OPER_CHWD_160MHZ:
+		chan_bw = CHANNEL_BW_160MHZ;
+		break;
+	case VHT_OPER_CHWD_80_80MHZ:
+		chan_bw = CHANNEL_BW_80MHZ;
+		break;
+	}
+	vht_oprat->chan_center_freq_1 = wlan_get_center_freq_idx(
+		priv, BAND_5GHZ, pbss_desc->channel, chan_bw);
+
+	LEAVE();
+	return;
+}
+
 /**
  *  @brief This function would check whether support 80+80Mhz
  *
@@ -948,19 +1052,15 @@ void wlan_fill_vht_cap_ie(mlan_private *priv, IEEEtypes_VHTCap_t *pvht_cap,
 t_u8 wlan_is_80_80_support(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
 {
 	t_u8 ret = MFALSE;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	t_u16 rx_nss = 0, tx_nss = 0;
 	IEEEtypes_VHTCap_t *pvht_cap = pbss_desc->pvht_cap;
 	MrvlIEtypes_He_cap_t *phecap = MNULL;
 	IEEEtypes_HECap_t *pBsshecap = MNULL;
-#endif
 
 	ENTER();
 
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	if (!IS_CARD9098(pmpriv->adapter->card_type) &&
+	    !IS_CARDIW62X(pmpriv->adapter->card_type) &&
 	    !IS_CARD9097(pmpriv->adapter->card_type))
 		return ret;
 	/** check band A */
@@ -987,7 +1087,6 @@ t_u8 wlan_is_80_80_support(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
 		else
 			ret = MFALSE;
 	}
-#endif
 	LEAVE();
 	return ret;
 }
@@ -1011,10 +1110,7 @@ int wlan_cmd_append_11ac_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	t_u16 nss;
 	int ret_len = 0;
 	t_u8 bw_80p80 = MFALSE;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	t_u16 rx_nss = 0;
-#endif
 
 	ENTER();
 
@@ -1043,7 +1139,7 @@ int wlan_cmd_append_11ac_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 			   pvht_cap->header.len, sizeof(VHT_capa_t));
 		bw_80p80 = wlan_is_80_80_support(pmpriv, pbss_desc);
 		wlan_fill_vht_cap_tlv(pmpriv, pvht_cap, pbss_desc->bss_band,
-				      MTRUE, bw_80p80);
+				      MFALSE, bw_80p80);
 
 		HEXDUMP("VHT_CAPABILITIES IE", (t_u8 *)pvht_cap,
 			sizeof(MrvlIETypes_VHTCap_t));
@@ -1082,9 +1178,8 @@ int wlan_cmd_append_11ac_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	} else {
 		/** set default bandwidth:80M*/
 		SET_OPER_MODE_80M(pmrvl_oper_mode->oper_mode);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if (IS_CARD9098(pmadapter->card_type) ||
+		    IS_CARDIW62X(pmadapter->card_type) ||
 		    IS_CARD9097(pmadapter->card_type)) {
 			if (pbss_desc->bss_band & BAND_A)
 				rx_nss = GET_RXMCSSUPP(
@@ -1093,19 +1188,16 @@ int wlan_cmd_append_11ac_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 				rx_nss =
 					GET_RXMCSSUPP(pmadapter->user_htstream);
 		}
-#endif
 		mcs_map_user =
 			GET_DEVRXMCSMAP(pmpriv->usr_dot_11ac_mcs_support);
 		nss = wlan_get_nss_num_vht_mcs(mcs_map_user);
 
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if (IS_CARD9098(pmadapter->card_type) ||
+		    IS_CARDIW62X(pmadapter->card_type) ||
 		    IS_CARD9097(pmadapter->card_type)) {
 			PRINTM(MCMND, "rx_nss=%d nss=%d\n", rx_nss, nss);
 			nss = MIN(rx_nss, nss);
 		}
-#endif
 
 		pmrvl_oper_mode->oper_mode |= (nss - 1) << 4;
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h
old mode 100644
new mode 100755
index 81661065b..9db5f9c22
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ac.h
@@ -3,7 +3,7 @@
  *  @brief This file contains the functions for station ioctl.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2011-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -35,12 +35,16 @@ void wlan_fill_vht_cap_tlv(mlan_private *priv, MrvlIETypes_VHTCap_t *pvht_cap,
 			   t_u16 bands, t_u8 flag, t_u8 bw_80p80);
 void wlan_fill_vht_cap_ie(mlan_private *priv, IEEEtypes_VHTCap_t *pvht_cap,
 			  t_u16 bands);
+void wlan_fill_tdls_vht_oprat_ie(mlan_private *priv,
+				 IEEEtypes_VHTOprat_t *vht_oprat,
+				 sta_node *sta_ptr);
+t_u8 wlan_is_ap_in_11ac_mode(mlan_private *priv);
 int wlan_cmd_append_11ac_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 			     t_u8 **ppbuffer);
 mlan_status wlan_11ac_cfg_ioctl(pmlan_adapter pmadapter,
 				pmlan_ioctl_req pioctl_req);
 void wlan_update_11ac_cap(mlan_private *pmpriv);
-t_u8 wlan_11ac_bandconfig_allowed(mlan_private *pmpriv, t_u8 bss_band);
+t_u8 wlan_11ac_bandconfig_allowed(mlan_private *pmpriv, t_u16 bss_band);
 t_u8 wlan_is_80_80_support(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc);
 
 mlan_status wlan_cmd_11ac_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c
old mode 100644
new mode 100755
index 628e430df..45995355a
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.c
@@ -3,7 +3,7 @@
  *  @brief This file contains the functions for 11ax related features.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -47,6 +47,7 @@
 			Global Functions
 ********************************************************/
 
+#if 0
 /**
  *  @brief This function prints the 802.11ax HE mac capability
  *
@@ -55,13 +56,14 @@
  *
  *  @return        N/A
  */
-void wlan_show_dot11axmaccap(pmlan_adapter pmadapter, t_u32 cap)
+static void wlan_show_dot11axmaccap(pmlan_adapter pmadapter, t_u32 cap)
 {
 	ENTER();
 
 	LEAVE();
 	return;
 }
+#endif
 
 /**
  *  @brief This function check if AP support TWT Response.
@@ -70,11 +72,11 @@ void wlan_show_dot11axmaccap(pmlan_adapter pmadapter, t_u32 cap)
  *
  *  @return        MTRUE/MFALSE
  */
-t_u8 wlan_check_ap_11ax_twt_supported(BSSDescriptor_t *pbss_desc)
+static t_u8 wlan_check_ap_11ax_twt_supported(BSSDescriptor_t *pbss_desc)
 {
 	if (!pbss_desc->phe_cap)
 		return MFALSE;
-	if (!(pbss_desc->phe_cap->he_mac_cap[0] & HE_MAC_CAP_TWT_REQ_SUPPORT))
+	if (!(pbss_desc->phe_cap->he_mac_cap[0] & HE_MAC_CAP_TWT_RESP_SUPPORT))
 		return MFALSE;
 	if (!pbss_desc->pext_cap)
 		return MFALSE;
@@ -97,12 +99,14 @@ t_u8 wlan_check_11ax_twt_supported(mlan_private *pmpriv,
 		(MrvlIEtypes_He_cap_t *)&pmpriv->user_he_cap;
 	MrvlIEtypes_He_cap_t *hw_he_cap =
 		(MrvlIEtypes_He_cap_t *)&pmpriv->adapter->hw_he_cap;
+	t_u16 band_selected = BAND_A;
+
 	if (pbss_desc && !wlan_check_ap_11ax_twt_supported(pbss_desc)) {
 		PRINTM(MINFO, "AP don't support twt feature\n");
 		return MFALSE;
 	}
 	if (pbss_desc) {
-		if (pbss_desc->bss_band & BAND_A) {
+		if (pbss_desc->bss_band & band_selected) {
 			hw_he_cap = (MrvlIEtypes_He_cap_t *)&pmpriv->adapter
 					    ->hw_he_cap;
 			phecap = (MrvlIEtypes_He_cap_t *)&pmpriv->user_he_cap;
@@ -123,6 +127,7 @@ t_u8 wlan_check_11ax_twt_supported(mlan_private *pmpriv,
 	return MFALSE;
 }
 
+#if 0
 /**
  *  @brief This function prints the 802.11ax HE PHY cap
  *
@@ -131,13 +136,148 @@ t_u8 wlan_check_11ax_twt_supported(mlan_private *pmpriv,
  *
  *  @return        N/A
  */
-void wlan_show_dot11axphycap(pmlan_adapter pmadapter, t_u32 support)
+static void wlan_show_dot11axphycap(pmlan_adapter pmadapter, t_u32 support)
 {
 	ENTER();
 
 	LEAVE();
 	return;
 }
+#endif
+
+/**
+ *  @brief This function fills the HE CAP IE w/ output format LE, not CPU
+ *
+ *  @param priv         A pointer to mlan_private structure
+ *  @param hecap_ie     A pointer to IEEEtypes_HECap_t structure
+ *  @param band         BAND_A (5G), otherwise, 2.4G
+ *
+ *  @return bytes added to the phe_cap
+ */
+t_u8 wlan_fill_he_cap_ie(mlan_private *pmpriv, IEEEtypes_HECap_t *hecap_ie,
+			 t_u16 band)
+{
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	MrvlIEtypes_He_cap_t *user_hecap_tlv = MNULL;
+	MrvlIEtypes_He_cap_t *hw_hecap_tlv = MNULL;
+	IEEEtypes_HeMcsNss_t *he_mcsnss = MNULL;
+	t_u8 nss = 0;
+	t_u16 cfg_value = 0;
+	t_u16 hw_value = 0;
+
+	if (band & BAND_A) {
+		user_hecap_tlv = (MrvlIEtypes_He_cap_t *)(pmpriv->user_he_cap);
+		hw_hecap_tlv = (MrvlIEtypes_He_cap_t *)pmadapter->hw_he_cap;
+	} else {
+		user_hecap_tlv =
+			(MrvlIEtypes_He_cap_t *)(pmpriv->user_2g_he_cap);
+		hw_hecap_tlv = (MrvlIEtypes_He_cap_t *)pmadapter->hw_2g_he_cap;
+	}
+
+	// include PPE threshold
+	memcpy_ext(pmadapter, (t_u8 *)hecap_ie + sizeof(IEEEtypes_Header_t),
+		   (t_u8 *)user_hecap_tlv + sizeof(MrvlIEtypesHeader_t),
+		   user_hecap_tlv->len,
+		   sizeof(IEEEtypes_HECap_t) - sizeof(IEEEtypes_Header_t));
+
+	hecap_ie->ieee_hdr.element_id = EXTENSION;
+	hecap_ie->ieee_hdr.len =
+		MIN(user_hecap_tlv->len,
+		    sizeof(IEEEtypes_HECap_t) - sizeof(IEEEtypes_Header_t));
+	hecap_ie->ext_id = HE_CAPABILITY;
+
+	he_mcsnss = (IEEEtypes_HeMcsNss_t *)hecap_ie->he_txrx_mcs_support;
+
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(user_hecap_tlv->rx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(hw_hecap_tlv->rx_mcs_80, nss);
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT)) {
+			SET_HE_NSSMCS(he_mcsnss->rx_mcs, nss, NO_NSS_SUPPORT);
+		} else {
+			SET_HE_NSSMCS(he_mcsnss->rx_mcs, nss,
+				      MIN(cfg_value, hw_value));
+		}
+	}
+
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(user_hecap_tlv->tx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(hw_hecap_tlv->tx_mcs_80, nss);
+
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT)) {
+			SET_HE_NSSMCS(he_mcsnss->tx_mcs, nss, NO_NSS_SUPPORT);
+		} else {
+			SET_HE_NSSMCS(he_mcsnss->tx_mcs, nss,
+				      MIN(cfg_value, hw_value));
+		}
+	}
+	PRINTM(MCMND,
+	       "fill_11ax_ie: HE rx mcs_80 = 0x%08x tx mcs 80 = 0x%08x\n",
+	       he_mcsnss->rx_mcs, he_mcsnss->tx_mcs);
+
+	DBG_HEXDUMP(MCMD_D, "fill_11ax_ie", (t_u8 *)hecap_ie,
+		    hecap_ie->ieee_hdr.len + sizeof(IEEEtypes_Header_t));
+	return hecap_ie->ieee_hdr.len;
+}
+
+/**
+ *  @brief This function fills the HE cap tlv out put format is LE, not CPU
+ *
+ *  @param priv         A pointer to mlan_private structure
+ *  @param phe_cap      A pointer to IEEEtypes_HECap_t structure
+ *  @param band         BAND_A (5G), otherwise, 2.4G
+ *
+ *  @return bytes added to the phe_cap
+ */
+t_u8 wlan_fill_he_op_ie(mlan_private *pmpriv, IEEEtypes_HeOp_t *heop_ie)
+{
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	BSSDescriptor_t *pbss_desc = &pmpriv->curr_bss_params.bss_descriptor;
+	IEEEtypes_HeOp_t *bss_heop_ie = MNULL;
+
+	memset(pmadapter, (void *)heop_ie, 0, sizeof(IEEEtypes_HeOp_t));
+
+	heop_ie->ieee_hdr.element_id = EXTENSION;
+	heop_ie->ieee_hdr.len = sizeof(IEEEtypes_HeOp_t) -
+				sizeof(IEEEtypes_Header_t) -
+				sizeof(heop_ie->option);
+	heop_ie->ext_id = HE_OPERATION;
+
+	// HE Operation Parameters
+	heop_ie->he_op_param.default_pe_dur = 7;
+	heop_ie->he_op_param.twt_req = 0;
+	heop_ie->he_op_param.txop_dur_rts_threshold = 12;
+	heop_ie->he_op_param.vht_op_info_present = 0;
+	heop_ie->he_op_param.co_located_bss = 0;
+	heop_ie->he_op_param.er_su_disable = 0;
+	// HE BSS Color Information (following the AP)
+	if (pbss_desc->phe_oprat) {
+		bss_heop_ie = (IEEEtypes_HeOp_t *)(pbss_desc->phe_oprat);
+		heop_ie->bss_color_info.bss_color =
+			bss_heop_ie->bss_color_info.bss_color;
+	} else {
+		// default color
+		heop_ie->bss_color_info.bss_color = 1;
+	}
+	heop_ie->bss_color_info.partial_bss_color = 0;
+	heop_ie->bss_color_info.bss_color_disabled = 0;
+	// Rx HE MCS MAP
+	heop_ie->basic_he_mcs_nss.max_mcs_1ss = 0;
+#if defined(SD9177)
+	heop_ie->basic_he_mcs_nss.max_mcs_2ss = 3;
+#else
+	heop_ie->basic_he_mcs_nss.max_mcs_2ss = 0;
+#endif
+	heop_ie->basic_he_mcs_nss.max_mcs_3ss = 3;
+	heop_ie->basic_he_mcs_nss.max_mcs_4ss = 3;
+	heop_ie->basic_he_mcs_nss.max_mcs_5ss = 3;
+	heop_ie->basic_he_mcs_nss.max_mcs_6ss = 3;
+	heop_ie->basic_he_mcs_nss.max_mcs_7ss = 3;
+	heop_ie->basic_he_mcs_nss.max_mcs_8ss = 3;
+
+	return heop_ie->ieee_hdr.len;
+}
 
 /**
  *  @brief This function fills the HE cap tlv out put format is LE, not CPU
@@ -150,30 +290,80 @@ void wlan_show_dot11axphycap(pmlan_adapter pmadapter, t_u32 support)
  *
  *  @return bytes added to the phe_cap
  */
-t_u16 wlan_fill_he_cap_tlv(mlan_private *pmpriv, t_u8 band,
+t_u16 wlan_fill_he_cap_tlv(mlan_private *pmpriv, t_u16 band,
 			   MrvlIEtypes_Extension_t *phe_cap, t_u8 flag)
 {
 	pmlan_adapter pmadapter = pmpriv->adapter;
 	t_u16 len = 0;
+	t_u16 rx_nss = 0, tx_nss = 0;
+	MrvlIEtypes_He_cap_t *phecap = MNULL;
+	t_u8 nss = 0;
+	t_u16 cfg_value = 0;
+	t_u16 hw_value = 0;
+	MrvlIEtypes_He_cap_t *phw_hecap = MNULL;
 
 	if (!phe_cap) {
 		LEAVE();
 		return 0;
 	}
-	if (band & BAND_A) {
+	if (band & BAND_AAX) {
 		memcpy_ext(pmadapter, (t_u8 *)phe_cap, pmpriv->user_he_cap,
 			   pmpriv->user_hecap_len,
 			   sizeof(MrvlIEtypes_He_cap_t));
 		len = pmpriv->user_hecap_len;
+		phw_hecap = (MrvlIEtypes_He_cap_t *)pmadapter->hw_he_cap;
 	} else {
 		memcpy_ext(pmadapter, (t_u8 *)phe_cap, pmpriv->user_2g_he_cap,
 			   pmpriv->user_2g_hecap_len,
 			   sizeof(MrvlIEtypes_He_cap_t));
 		len = pmpriv->user_2g_hecap_len;
+		phw_hecap = (MrvlIEtypes_He_cap_t *)pmadapter->hw_2g_he_cap;
 	}
 	phe_cap->type = wlan_cpu_to_le16(phe_cap->type);
 	phe_cap->len = wlan_cpu_to_le16(phe_cap->len);
+	if (IS_CARD9098(pmpriv->adapter->card_type) ||
+	    IS_CARD9097(pmpriv->adapter->card_type)) {
+		if (band & BAND_AAX) {
+			rx_nss = GET_RXMCSSUPP(pmpriv->adapter->user_htstream >>
+					       8);
+			tx_nss = GET_TXMCSSUPP(pmpriv->adapter->user_htstream >>
+					       8) &
+				 0x0f;
+		} else {
+			rx_nss = GET_RXMCSSUPP(pmpriv->adapter->user_htstream);
+			tx_nss = GET_TXMCSSUPP(pmpriv->adapter->user_htstream) &
+				 0x0f;
+		}
+	}
+	phecap = (MrvlIEtypes_He_cap_t *)phe_cap;
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(phecap->rx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(phw_hecap->rx_mcs_80, nss);
+		if ((rx_nss != 0) && (nss > rx_nss))
+			cfg_value = NO_NSS_SUPPORT;
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT))
+			SET_HE_NSSMCS(phecap->rx_mcs_80, nss, NO_NSS_SUPPORT);
+		else
+			SET_HE_NSSMCS(phecap->rx_mcs_80, nss,
+				      MIN(cfg_value, hw_value));
+	}
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(phecap->tx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(phw_hecap->tx_mcs_80, nss);
+		if ((tx_nss != 0) && (nss > tx_nss))
+			cfg_value = NO_NSS_SUPPORT;
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT))
+			SET_HE_NSSMCS(phecap->tx_mcs_80, nss, NO_NSS_SUPPORT);
+		else
+			SET_HE_NSSMCS(phecap->tx_mcs_80, nss,
+				      MIN(cfg_value, hw_value));
+	}
+	PRINTM(MCMND, "Set: HE rx mcs set 0x%08x tx mcs set 0x%08x\n",
+	       phecap->rx_mcs_80, phecap->tx_mcs_80);
 
+	DBG_HEXDUMP(MCMD_D, "fill_11ax_tlv", (t_u8 *)phecap, len);
 	LEAVE();
 	return len;
 }
@@ -194,6 +384,12 @@ int wlan_cmd_append_11ax_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	MrvlIEtypes_He_cap_t *phecap = MNULL;
 	int len = 0;
 	t_u8 bw_80p80 = MFALSE;
+	t_u16 rx_nss = 0, tx_nss = 0;
+	t_u8 nss = 0;
+	t_u16 cfg_value = 0;
+	t_u16 hw_value = 0;
+	MrvlIEtypes_He_cap_t *phw_hecap = MNULL;
+	t_u16 band_selected = BAND_A;
 
 	ENTER();
 
@@ -213,40 +409,72 @@ int wlan_cmd_append_11ax_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	}
 	bw_80p80 = wlan_is_80_80_support(pmpriv, pbss_desc);
 	phecap = (MrvlIEtypes_He_cap_t *)*ppbuffer;
-	if (pbss_desc->bss_band & BAND_A) {
+	if (pbss_desc->bss_band & band_selected) {
 		memcpy_ext(pmadapter, *ppbuffer, pmpriv->user_he_cap,
 			   pmpriv->user_hecap_len, pmpriv->user_hecap_len);
 		*ppbuffer += pmpriv->user_hecap_len;
 		len = pmpriv->user_hecap_len;
+		phw_hecap = (MrvlIEtypes_He_cap_t *)pmadapter->hw_he_cap;
 	} else {
 		memcpy_ext(pmadapter, *ppbuffer, pmpriv->user_2g_he_cap,
 			   pmpriv->user_2g_hecap_len,
 			   pmpriv->user_2g_hecap_len);
 		*ppbuffer += pmpriv->user_2g_hecap_len;
 		len = pmpriv->user_2g_hecap_len;
+		phw_hecap = (MrvlIEtypes_He_cap_t *)pmadapter->hw_2g_he_cap;
 	}
 	phecap->type = wlan_cpu_to_le16(phecap->type);
 	phecap->len = wlan_cpu_to_le16(phecap->len);
-
-	if (bw_80p80) {
-		/** configure 2*2 to 1*1 to support 80+80Mhz*/
-		/** set 1*1 mcs rate for 80Mhz rx*/
-		phecap->he_txrx_mcs_support[0] &= ~(MBIT(0) | MBIT(1));
-		/** set 1*1 mcs rate for 80Mhz tx*/
-		phecap->he_txrx_mcs_support[3] &= ~(MBIT(0) | MBIT(1));
-		/** set 1*1 mcs rate for 160Mhz rx*/
-		phecap->he160_txrx_mcs_support[0] &= ~(MBIT(0) | MBIT(1));
-		/** set 1*1 mcs rate for 160Mhz tx*/
-		phecap->he160_txrx_mcs_support[3] &= ~(MBIT(0) | MBIT(1));
-		/** set 1*1 mcs rate for 80+80Mhz rx*/
-		phecap->he8080_txrx_mcs_support[0] &= ~(MBIT(0) | MBIT(1));
-		/** set 1*1 mcs rate for 80+80Mhz tx*/
-		phecap->he8080_txrx_mcs_support[3] &= ~(MBIT(0) | MBIT(1));
-	} else {
+	if (IS_CARD9098(pmpriv->adapter->card_type) ||
+	    IS_CARDIW62X(pmpriv->adapter->card_type) ||
+	    IS_CARD9097(pmpriv->adapter->card_type)) {
+		if (pbss_desc->bss_band & band_selected) {
+			rx_nss = GET_RXMCSSUPP(pmpriv->adapter->user_htstream >>
+					       8);
+			tx_nss = GET_TXMCSSUPP(pmpriv->adapter->user_htstream >>
+					       8) &
+				 0x0f;
+		} else {
+			rx_nss = GET_RXMCSSUPP(pmpriv->adapter->user_htstream);
+			tx_nss = GET_TXMCSSUPP(pmpriv->adapter->user_htstream) &
+				 0x0f;
+		}
+		/** force 1x1 when enable 80P80 */
+		if (bw_80p80)
+			rx_nss = tx_nss = 1;
+	}
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(phecap->rx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(phw_hecap->rx_mcs_80, nss);
+		if ((rx_nss != 0) && (nss > rx_nss))
+			cfg_value = NO_NSS_SUPPORT;
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT))
+			SET_HE_NSSMCS(phecap->rx_mcs_80, nss, NO_NSS_SUPPORT);
+		else
+			SET_HE_NSSMCS(phecap->rx_mcs_80, nss,
+				      MIN(cfg_value, hw_value));
+	}
+	for (nss = 1; nss <= 8; nss++) {
+		cfg_value = GET_HE_NSSMCS(phecap->tx_mcs_80, nss);
+		hw_value = GET_HE_NSSMCS(phw_hecap->tx_mcs_80, nss);
+		if ((tx_nss != 0) && (nss > tx_nss))
+			cfg_value = NO_NSS_SUPPORT;
+		if ((hw_value == NO_NSS_SUPPORT) ||
+		    (cfg_value == NO_NSS_SUPPORT))
+			SET_HE_NSSMCS(phecap->tx_mcs_80, nss, NO_NSS_SUPPORT);
+		else
+			SET_HE_NSSMCS(phecap->tx_mcs_80, nss,
+				      MIN(cfg_value, hw_value));
+	}
+	PRINTM(MCMND, "Set: HE rx mcs set 0x%08x tx mcs set 0x%08x\n",
+	       phecap->rx_mcs_80, phecap->tx_mcs_80);
+	if (!bw_80p80) {
 		/** reset BIT3 and BIT4 channel width ,not support 80 + 80*/
 		/** not support 160Mhz now, if support,not reset bit3 */
 		phecap->he_phy_cap[0] &= ~(MBIT(3) | MBIT(4));
 	}
+	DBG_HEXDUMP(MCMD_D, "append_11ax_tlv", (t_u8 *)phecap, len);
 
 	LEAVE();
 	return len;
@@ -266,6 +494,7 @@ void wlan_update_11ax_cap(mlan_adapter *pmadapter,
 	MrvlIEtypes_He_cap_t *phe_cap = MNULL;
 	t_u8 i = 0;
 	t_u8 he_cap_2g = 0;
+	MrvlIEtypes_He_cap_t *user_he_cap_tlv = MNULL;
 
 	ENTER();
 	if ((hw_he_cap->len + sizeof(MrvlIEtypesHeader_t)) >
@@ -324,6 +553,28 @@ void wlan_update_11ax_cap(mlan_adapter *pmadapter,
 					pmadapter->hw_hecap_len,
 					sizeof(pmadapter->priv[i]->user_he_cap));
 			}
+			/**
+			 *  Clear TWT bits in he_mac_cap by bss role
+			 *  STA mode should clear TWT responder bit
+			 *  UAP mode should clear TWT request bit
+			 */
+			if (he_cap_2g)
+				user_he_cap_tlv =
+					(MrvlIEtypes_He_cap_t *)&pmadapter
+						->priv[i]
+						->user_2g_he_cap;
+			else
+				user_he_cap_tlv =
+					(MrvlIEtypes_He_cap_t *)&pmadapter
+						->priv[i]
+						->user_he_cap;
+
+			if (pmadapter->priv[i]->bss_role == MLAN_BSS_ROLE_STA)
+				user_he_cap_tlv->he_mac_cap[0] &=
+					~HE_MAC_CAP_TWT_RESP_SUPPORT;
+			else
+				user_he_cap_tlv->he_mac_cap[0] &=
+					~HE_MAC_CAP_TWT_REQ_SUPPORT;
 		}
 	}
 	LEAVE();
@@ -334,13 +585,15 @@ void wlan_update_11ax_cap(mlan_adapter *pmadapter,
  *  @brief This function check if 11AX is allowed in bandcfg
  *
  *  @param pmpriv       A pointer to mlan_private structure
- *  @param bss_band     bss band
+ *  @param pbss_desc    A pointer to BSSDescriptor_t
  *
  *  @return 0--not allowed, other value allowed
  */
-t_u16 wlan_11ax_bandconfig_allowed(mlan_private *pmpriv, t_u16 bss_band)
+t_u16 wlan_11ax_bandconfig_allowed(mlan_private *pmpriv,
+				   BSSDescriptor_t *pbss_desc)
 {
-	if (!IS_FW_SUPPORT_11AX(pmpriv->adapter))
+	t_u16 bss_band = pbss_desc->bss_band;
+	if (pbss_desc->disable_11n)
 		return MFALSE;
 	if (pmpriv->bss_mode == MLAN_BSS_MODE_IBSS) {
 		if (bss_band & BAND_G)
@@ -374,15 +627,6 @@ static mlan_status wlan_11ax_ioctl_hecfg(pmlan_adapter pmadapter,
 
 	ENTER();
 
-	if (pioctl_req->buf_len < sizeof(mlan_ds_11ax_cfg)) {
-		PRINTM(MINFO, "MLAN bss IOCTL length is too short.\n");
-		pioctl_req->data_read_written = 0;
-		pioctl_req->buf_len_needed = sizeof(mlan_ds_11ax_cfg);
-		pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
-		LEAVE();
-		return MLAN_STATUS_RESOURCE;
-	}
-
 	cfg = (mlan_ds_11ax_cfg *)pioctl_req->pbuf;
 
 	if ((cfg->param.he_cfg.band & MBIT(0)) &&
@@ -484,7 +728,6 @@ mlan_status wlan_cmd_11ax_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		cmd->size += hecfg->he_cap.len + sizeof(MrvlIEtypesHeader_t);
 		pos += hecfg->he_cap.len + sizeof(MrvlIEtypesHeader_t);
 	}
-
 	cmd->size = wlan_cpu_to_le16(cmd->size);
 
 	LEAVE();
@@ -682,8 +925,9 @@ mlan_status wlan_cmd_11ax_cmd(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		break;
 	case MLAN_11AXCMD_TXOMI_SUBID:
 		memcpy_ext(pmadapter, axcmd->val, &txomi_cmd->omi,
-			   sizeof(t_u16), sizeof(t_u16));
-		cmd->size += sizeof(t_u16);
+			   sizeof(mlan_ds_11ax_txomi_cmd),
+			   sizeof(mlan_ds_11ax_txomi_cmd));
+		cmd->size += sizeof(mlan_ds_11ax_txomi_cmd);
 		break;
 	case MLAN_11AXCMD_OBSS_TOLTIME_SUBID:
 		memcpy_ext(pmadapter, axcmd->val, &toltime_cmd->tol_time,
@@ -718,7 +962,7 @@ mlan_status wlan_ret_11ax_cmd(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	HostCmd_DS_11AX_CMD_CFG *axcmd = &resp->params.axcmd;
 	MrvlIEtypes_Data_t *tlv = MNULL;
 	t_s16 left_len = 0;
-	t_u16 tlv_type = 0, tlv_len = 0;
+	t_u16 tlv_len = 0;
 
 	ENTER();
 
@@ -735,8 +979,7 @@ mlan_status wlan_ret_11ax_cmd(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			resp->size - sizeof(HostCmd_DS_11AX_CMD_CFG) - S_DS_GEN;
 		// tlv = (MrvlIEtypes_Extension_t *)axcfg->val;
 		tlv = (MrvlIEtypes_Data_t *)axcmd->val;
-		while (left_len > sizeof(MrvlIEtypesHeader_t)) {
-			tlv_type = wlan_le16_to_cpu(tlv->header.type);
+		while (left_len > (t_s16)sizeof(MrvlIEtypesHeader_t)) {
 			tlv_len = wlan_le16_to_cpu(tlv->header.len);
 			memcpy_ext(
 				pmadapter,
@@ -760,7 +1003,8 @@ mlan_status wlan_ret_11ax_cmd(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 		break;
 	case MLAN_11AXCMD_TXOMI_SUBID:
 		memcpy_ext(pmadapter, &cfg->param.txomi_cfg.omi, axcmd->val,
-			   sizeof(t_u16), sizeof(t_u16));
+			   sizeof(mlan_ds_11ax_txomi_cmd),
+			   sizeof(mlan_ds_11ax_txomi_cmd));
 		break;
 	case MLAN_11AXCMD_OBSS_TOLTIME_SUBID:
 		memcpy_ext(pmadapter, &cfg->param.toltime_cfg.tol_time,
@@ -795,6 +1039,7 @@ mlan_status wlan_cmd_twt_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	mlan_ds_twtcfg *ds_twtcfg = (mlan_ds_twtcfg *)pdata_buf;
 	hostcmd_twt_setup *twt_setup_params = MNULL;
 	hostcmd_twt_teardown *twt_teardown_params = MNULL;
+	hostcmd_twt_report *twt_report_params = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
@@ -847,6 +1092,13 @@ mlan_status wlan_cmd_twt_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 			ds_twtcfg->param.twt_teardown.teardown_all_twt;
 		cmd->size += sizeof(hostcmd_twtcfg->param.twt_teardown);
 		break;
+	case MLAN_11AX_TWT_REPORT_SUBID:
+		twt_report_params = &hostcmd_twtcfg->param.twt_report;
+		memset(pmpriv->adapter, twt_report_params, 0x00,
+		       sizeof(hostcmd_twtcfg->param.twt_report));
+		twt_report_params->type = ds_twtcfg->param.twt_report.type;
+		cmd->size += sizeof(hostcmd_twtcfg->param.twt_report);
+		break;
 	default:
 		PRINTM(MERROR, "Unknown subcmd %x\n", ds_twtcfg->sub_id);
 		ret = MLAN_STATUS_FAILURE;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h
old mode 100644
new mode 100755
index 4e64772ad..312555192
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11ax.h
@@ -3,7 +3,7 @@
  *  @brief This file contains the functions for station ioctl.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2018-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -28,19 +28,34 @@
 /** device support 2.4G 242 tone RUs */
 #define AX_2G_20MHZ_SUPPORT MBIT(5)
 
+/*
+ * 0 indicates support for HE-MCS 0-7 for n spatial streams
+ * 1 indicates support for HE-MCS 0-9 for n spatial streams
+ * 2 indicates support for HE-MCS 0-11 for n spatial streams
+ * 3 indicates that n spatial streams is not supported for HE PPDUs
+ */
+#define GET_HE_NSSMCS(MCSMapSet, nss) ((MCSMapSet >> (2 * (nss - 1))) & 0x3)
+#define SET_HE_NSSMCS(MCSMapSet, nss, value)                                   \
+	(MCSMapSet |= (value & 0x3) << (2 * (nss - 1)))
+
 t_u8 wlan_check_11ax_twt_supported(mlan_private *pmpriv,
 				   BSSDescriptor_t *pbss_desc);
 mlan_status wlan_11ax_ioctl_twtcfg(pmlan_adapter pmadapter,
 				   pmlan_ioctl_req pioctl_req);
 mlan_status wlan_cmd_twt_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 			     t_u16 cmd_action, t_void *pdata_buf);
-t_u16 wlan_fill_he_cap_tlv(mlan_private *pmpriv, t_u8 band,
+t_u8 wlan_fill_he_cap_ie(mlan_private *pmpriv, IEEEtypes_HECap_t *hecap_ie,
+			 t_u16 band);
+t_u8 wlan_fill_he_op_ie(mlan_private *pmpriv, IEEEtypes_HeOp_t *heop_ie);
+t_u16 wlan_fill_he_cap_tlv(mlan_private *pmpriv, t_u16 band,
 			   MrvlIEtypes_Extension_t *phe_cap, t_u8 flag);
 void wlan_update_11ax_cap(mlan_adapter *pmadapter,
 			  MrvlIEtypes_Extension_t *hw_he_cap);
+
 int wlan_cmd_append_11ax_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 			     t_u8 **ppbuffer);
-t_u16 wlan_11ax_bandconfig_allowed(mlan_private *pmpriv, t_u16 bss_band);
+t_u16 wlan_11ax_bandconfig_allowed(mlan_private *pmpriv,
+				   BSSDescriptor_t *pbss_desc);
 mlan_status wlan_11ax_cfg_ioctl(pmlan_adapter pmadapter,
 				pmlan_ioctl_req pioctl_req);
 mlan_status wlan_11ax_ioctl_cmd(pmlan_adapter pmadapter,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c
old mode 100644
new mode 100755
index a9ac930eb..8537a30c5
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11d.c
@@ -3,7 +3,7 @@
  *  @brief This file contains functions for 802.11D.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -71,39 +71,64 @@ static region_code_mapping_t region_code_mapping[] = {
 /* Following two structures define the supported channels */
 /** Channels for 802.11b/g */
 static chan_freq_power_t channel_freq_power_UN_BG[] = {
-	{1, 2412, TX_PWR_DEFAULT},  {2, 2417, TX_PWR_DEFAULT},
-	{3, 2422, TX_PWR_DEFAULT},  {4, 2427, TX_PWR_DEFAULT},
-	{5, 2432, TX_PWR_DEFAULT},  {6, 2437, TX_PWR_DEFAULT},
-	{7, 2442, TX_PWR_DEFAULT},  {8, 2447, TX_PWR_DEFAULT},
-	{9, 2452, TX_PWR_DEFAULT},  {10, 2457, TX_PWR_DEFAULT},
-	{11, 2462, TX_PWR_DEFAULT}, {12, 2467, TX_PWR_DEFAULT},
-	{13, 2472, TX_PWR_DEFAULT}, {14, 2484, TX_PWR_DEFAULT}};
+	{1, 2412, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, TX_PWR_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, TX_PWR_DEFAULT, MFALSE, {0x1d, 0, 0}},
+	{13, 2472, TX_PWR_DEFAULT, MFALSE, {0x1d, 0, 0}},
+	{14, 2484, TX_PWR_DEFAULT, MFALSE, {0x1d, 0, 0}},
+};
 
 /** Channels for 802.11a/j */
 static chan_freq_power_t channel_freq_power_UN_AJ[] = {
-	{8, 5040, TX_PWR_DEFAULT},   {12, 5060, TX_PWR_DEFAULT},
-	{16, 5080, TX_PWR_DEFAULT},  {34, 5170, TX_PWR_DEFAULT},
-	{38, 5190, TX_PWR_DEFAULT},  {42, 5210, TX_PWR_DEFAULT},
-	{46, 5230, TX_PWR_DEFAULT},  {36, 5180, TX_PWR_DEFAULT},
-	{40, 5200, TX_PWR_DEFAULT},  {44, 5220, TX_PWR_DEFAULT},
-	{48, 5240, TX_PWR_DEFAULT},  {52, 5260, TX_PWR_DEFAULT},
-	{56, 5280, TX_PWR_DEFAULT},  {60, 5300, TX_PWR_DEFAULT},
-	{64, 5320, TX_PWR_DEFAULT},  {100, 5500, TX_PWR_DEFAULT},
-	{104, 5520, TX_PWR_DEFAULT}, {108, 5540, TX_PWR_DEFAULT},
-	{112, 5560, TX_PWR_DEFAULT}, {116, 5580, TX_PWR_DEFAULT},
-	{120, 5600, TX_PWR_DEFAULT}, {124, 5620, TX_PWR_DEFAULT},
-	{128, 5640, TX_PWR_DEFAULT}, {132, 5660, TX_PWR_DEFAULT},
-	{136, 5680, TX_PWR_DEFAULT}, {140, 5700, TX_PWR_DEFAULT},
-	{149, 5745, TX_PWR_DEFAULT}, {153, 5765, TX_PWR_DEFAULT},
-	{157, 5785, TX_PWR_DEFAULT}, {161, 5805, TX_PWR_DEFAULT},
-	{165, 5825, TX_PWR_DEFAULT},
+	{8, 5040, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{12, 5060, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{16, 5080, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{34, 5170, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{36, 5180, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{38, 5190, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{42, 5210, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{46, 5230, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{169, 5845, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{173, 5865, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{177, 5885, TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}
 	/*  {240, 4920, TX_PWR_DEFAULT},
 	    {244, 4940, TX_PWR_DEFAULT},
 	    {248, 4960, TX_PWR_DEFAULT},
 	    {252, 4980, TX_PWR_DEFAULT},
 	channels for 11J JP 10M channel gap */
 };
-
 /********************************************************
 			Global Variables
 ********************************************************/
@@ -149,7 +174,7 @@ static t_u8 *wlan_11d_code_2_region(pmlan_adapter pmadapter, t_u8 code)
  *
  *  @return                     MTRUE or MFALSE
  */
-static t_u8 wlan_11d_channel_known(pmlan_adapter pmadapter, t_u8 band,
+static t_u8 wlan_11d_channel_known(pmlan_adapter pmadapter, t_u16 band,
 				   t_u8 chan,
 				   parsed_region_chan_11d_t *parsed_region_chan)
 {
@@ -271,6 +296,8 @@ wlan_11d_generate_domain_info(pmlan_adapter pmadapter,
 	/* Should be only place that clear domain_reg (besides init) */
 	memset(pmadapter, domain_info, 0, sizeof(wlan_802_11d_domain_reg_t));
 
+	domain_info->dfs_region = NXP_DFS_UNKNOWN;
+
 	/* Set country code */
 	memcpy_ext(pmadapter, domain_info->country_code,
 		   wlan_11d_code_2_region(pmadapter,
@@ -352,7 +379,8 @@ static mlan_status wlan_11d_update_chan_pwr_table(mlan_private *pmpriv,
 
 	chan = pbss_desc->phy_param_set.ds_param_set.current_chan;
 
-	tx_power = wlan_get_txpwr_of_chan_from_cfp(pmpriv, chan);
+	tx_power = wlan_get_txpwr_of_chan_from_cfp(pmpriv, pbss_desc->bss_band,
+						   chan);
 
 	if (!tx_power) {
 		PRINTM(MMSG, "11D: Invalid channel\n");
@@ -381,8 +409,7 @@ static mlan_status wlan_11d_update_chan_pwr_table(mlan_private *pmpriv,
 		/* Channel not found. Update the channel in the channel-power
 		   table */
 		parsed_region_chan->chan_pwr[i].chan = chan;
-		parsed_region_chan->chan_pwr[i].band =
-			(t_u8)pbss_desc->bss_band;
+		parsed_region_chan->chan_pwr[i].band = pbss_desc->bss_band;
 		parsed_region_chan->chan_pwr[i].pwr = tx_power;
 		parsed_region_chan->chan_pwr[i].ap_seen = MTRUE;
 		parsed_region_chan->no_of_chan++;
@@ -403,7 +430,7 @@ static mlan_status wlan_11d_update_chan_pwr_table(mlan_private *pmpriv,
  *
  *  @return           MTRUE or MFALSE
  */
-static t_u8 wlan_11d_get_chan(pmlan_adapter pmadapter, t_u8 band,
+static t_u8 wlan_11d_get_chan(pmlan_adapter pmadapter, t_u16 band,
 			      t_u8 first_chan, t_u8 no_of_chan, t_u8 *chan)
 {
 	chan_freq_power_t *cfp = MNULL;
@@ -467,7 +494,7 @@ static mlan_status wlan_11d_process_country_info(mlan_private *pmpriv,
 
 	/* Parse 11D country info */
 	if (wlan_11d_parse_domain_info(pmadapter, &pbss_desc->country_info,
-				       (t_u8)pbss_desc->bss_band,
+				       pbss_desc->bss_band,
 				       &region_chan) != MLAN_STATUS_SUCCESS) {
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
@@ -636,13 +663,14 @@ static mlan_status wlan_11d_send_domain_info(mlan_private *pmpriv,
  *  @param country_code     Intended country code
  *  @param num_sub_band     Count of tuples in list below
  *  @param sub_band_list    List of sub_band tuples
+ *  @param dfs_region       0-unset,1-fcc,2-etsi,3-JP, 0xff-unknown
  *
  *  @return                 MLAN_STATUS_SUCCESS
  */
 static mlan_status
-wlan_11d_set_domain_info(mlan_private *pmpriv, t_u8 band,
+wlan_11d_set_domain_info(mlan_private *pmpriv, t_u16 band,
 			 t_u8 country_code[COUNTRY_CODE_LEN], t_u8 num_sub_band,
-			 IEEEtypes_SubbandSet_t *sub_band_list)
+			 IEEEtypes_SubbandSet_t *sub_band_list, t_u8 dfs_region)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	wlan_802_11d_domain_reg_t *pdomain = &pmadapter->domain_reg;
@@ -651,6 +679,7 @@ wlan_11d_set_domain_info(mlan_private *pmpriv, t_u8 band,
 	ENTER();
 
 	memset(pmadapter, pdomain, 0, sizeof(wlan_802_11d_domain_reg_t));
+	pdomain->dfs_region = dfs_region;
 	memcpy_ext(pmadapter, pdomain->country_code, country_code,
 		   COUNTRY_CODE_LEN, COUNTRY_CODE_LEN);
 	pdomain->band = band;
@@ -823,13 +852,15 @@ mlan_status wlan_cmd_802_11d_domain_info(mlan_private *pmpriv,
 		&pcmd->params.domain_info;
 	MrvlIEtypes_DomainParamSet_t *domain = &pdomain_info->domain;
 	t_u8 no_of_sub_band = pmadapter->domain_reg.no_of_sub_band;
+	MrvlIEtypes_Rgn_dom_code_t *rgn = MNULL;
 	t_u8 i;
 
 	ENTER();
-	PRINTM(MCMND, "11D:Country=%c%c band=%d sub-band=5d\n",
+	PRINTM(MCMND, "11D:Country=%c%c band=%d sub-band=%d dfs_region=%d\n",
 	       pmadapter->domain_reg.country_code[0],
 	       pmadapter->domain_reg.country_code[1],
-	       pmadapter->domain_reg.band, no_of_sub_band);
+	       pmadapter->domain_reg.band, no_of_sub_band,
+	       pmadapter->domain_reg.dfs_region);
 	for (i = 0; i < no_of_sub_band; i++) {
 		PRINTM(MCMND,
 		       "11D: first chan=%d no_of_chan=%d, max_tx_pwr=%d\n",
@@ -867,15 +898,25 @@ mlan_status wlan_cmd_802_11d_domain_info(mlan_private *pmpriv,
 			   MRVDRV_MAX_SUBBAND_802_11D *
 				   sizeof(IEEEtypes_SubbandSet_t));
 
-		pcmd->size = wlan_cpu_to_le16(
-			sizeof(pdomain_info->action) + domain->header.len +
-			sizeof(MrvlIEtypesHeader_t) + S_DS_GEN);
+		pcmd->size = sizeof(pdomain_info->action) + domain->header.len +
+			     sizeof(MrvlIEtypesHeader_t) + S_DS_GEN;
+
+		if (pmadapter->domain_reg.dfs_region != NXP_DFS_UNKNOWN) {
+			rgn = (MrvlIEtypes_Rgn_dom_code_t
+				       *)((t_u8 *)&pdomain_info->domain +
+					  domain->header.len +
+					  sizeof(MrvlIEtypesHeader_t));
+			rgn->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_REGION_DOMAIN_CODE);
+			rgn->header.len = 2;
+			rgn->domain_code = pmadapter->domain_reg.dfs_region;
+			pcmd->size += sizeof(MrvlIEtypes_Rgn_dom_code_t);
+		}
 	} else {
-		pcmd->size = wlan_cpu_to_le16(sizeof(pdomain_info->action) +
-					      S_DS_GEN);
+		pcmd->size = sizeof(pdomain_info->action) + S_DS_GEN;
 	}
 	domain->header.len = wlan_cpu_to_le16(domain->header.len);
-
+	pcmd->size = wlan_cpu_to_le16(pcmd->size);
 	HEXDUMP("11D: 802_11D_DOMAIN_INFO", (t_u8 *)pcmd,
 		wlan_le16_to_cpu(pcmd->size));
 
@@ -944,7 +985,7 @@ mlan_status wlan_ret_802_11d_domain_info(mlan_private *pmpriv,
  *
  *  @return             Channel frequency
  */
-t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u8 band)
+t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u16 band)
 {
 	chan_freq_power_t *cf;
 	t_u16 cnt;
@@ -953,15 +994,19 @@ t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u8 band)
 
 	ENTER();
 
+	if (band & (BAND_B | BAND_G | BAND_GN | BAND_GAC)) {
+		cf = channel_freq_power_UN_BG;
+		cnt = NELEMENTS(channel_freq_power_UN_BG);
+	}
 	/* Get channel-frequency-power trios */
-	if (band & (BAND_A | BAND_AN | BAND_AAC)) {
+	else if (band & (BAND_A | BAND_AN | BAND_AAC)) {
 		cf = channel_freq_power_UN_AJ;
 		cnt = NELEMENTS(channel_freq_power_UN_AJ);
 	} else {
-		cf = channel_freq_power_UN_BG;
-		cnt = NELEMENTS(channel_freq_power_UN_BG);
+		PRINTM(MERROR, "11D: Wrong Band [%d]\n", band);
+		LEAVE();
+		return 0;
 	}
-
 	/* Locate channel and return corresponding frequency */
 	for (i = 0; i < cnt; i++) {
 		if (chan == cf[i].channel)
@@ -985,7 +1030,7 @@ t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u8 band)
  */
 mlan_status wlan_11d_parse_domain_info(
 	pmlan_adapter pmadapter, IEEEtypes_CountryInfoFullSet_t *country_info,
-	t_u8 band, parsed_region_chan_11d_t *parsed_region_chan)
+	t_u16 band, parsed_region_chan_11d_t *parsed_region_chan)
 {
 	t_u8 no_of_sub_band, no_of_chan;
 	t_u8 last_chan, first_chan, cur_chan = 0;
@@ -1073,7 +1118,7 @@ mlan_status wlan_11d_parse_domain_info(
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_11d_set_universaltable(mlan_private *pmpriv, t_u8 band)
+mlan_status wlan_11d_set_universaltable(mlan_private *pmpriv, t_u16 band)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	t_u16 i = 0;
@@ -1143,7 +1188,7 @@ mlan_status wlan_11d_set_universaltable(mlan_private *pmpriv, t_u8 band)
  *  @return                     PASSIVE if chan is unknown; ACTIVE
  *                              if chan is known
  */
-t_u8 wlan_11d_get_scan_type(pmlan_adapter pmadapter, t_u8 band, t_u8 chan,
+t_u8 wlan_11d_get_scan_type(pmlan_adapter pmadapter, t_u16 band, t_u8 chan,
 			    parsed_region_chan_11d_t *parsed_region_chan)
 {
 	t_u8 scan_type = MLAN_SCAN_TYPE_PASSIVE;
@@ -1195,7 +1240,7 @@ mlan_status wlan_11d_clear_parsedtable(mlan_private *pmpriv)
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_11d_create_dnld_countryinfo(mlan_private *pmpriv, t_u8 band)
+mlan_status wlan_11d_create_dnld_countryinfo(mlan_private *pmpriv, t_u16 band)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_adapter *pmadapter = pmpriv->adapter;
@@ -1319,8 +1364,7 @@ mlan_status wlan_11d_parse_dnld_countryinfo(mlan_private *pmpriv,
 			/* Parse domain info if available */
 			ret = wlan_11d_parse_domain_info(
 				pmadapter, &pbss_desc->country_info,
-				(t_u8)pbss_desc->bss_band,
-				&bssdesc_region_chan);
+				pbss_desc->bss_band, &bssdesc_region_chan);
 
 			if (ret == MLAN_STATUS_SUCCESS) {
 				/* Update the channel-power table */
@@ -1479,8 +1523,11 @@ mlan_status wlan_11d_cfg_domain_info(pmlan_adapter pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-	if (!wlan_fw_11d_is_enabled(pmpriv))
-		wlan_11d_enable(pmpriv, MNULL, ENABLE_11D);
+	if (!wlan_fw_11d_is_enabled(pmpriv)) {
+		ret = wlan_11d_enable(pmpriv, MNULL, ENABLE_11D);
+		if (ret)
+			PRINTM(MERROR, "Enabling 11D in FW failed\n");
+	}
 
 	cfg_11d = (mlan_ds_11d_cfg *)pioctl_req->pbuf;
 	domain_info = &cfg_11d->param.domain_info;
@@ -1491,7 +1538,8 @@ mlan_status wlan_11d_cfg_domain_info(pmlan_adapter pmadapter,
 		pmpriv, domain_info->band,
 		wlan_11d_map_country_code(pmadapter, domain_info->country_code),
 		domain_info->no_of_sub_band,
-		(IEEEtypes_SubbandSet_t *)domain_info->sub_band);
+		(IEEEtypes_SubbandSet_t *)domain_info->sub_band,
+		domain_info->dfs_region);
 	ret = wlan_11d_send_domain_info(pmpriv, pioctl_req);
 
 	if (ret == MLAN_STATUS_SUCCESS)
@@ -1536,13 +1584,14 @@ mlan_status wlan_11d_cfg_domain_info(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u8 band,
+mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u16 band,
 					    t_u8 *domain_tlv,
 					    t_void *pioctl_buf)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_adapter *pmadapter = pmpriv->adapter;
-	MrvlIEtypes_DomainParamSet_t *pdomain_tlv;
+	MrvlIEtypes_DomainParamSet_t *pdomain_tlv = MNULL;
+	MrvlIEtypes_Rgn_dom_code_t *pregdomain_tlv = MNULL;
 	t_u8 num_sub_band = 0;
 	t_u8 cfp_bg = 0, cfp_a = 0;
 
@@ -1550,6 +1599,12 @@ mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u8 band,
 
 	pdomain_tlv = (MrvlIEtypes_DomainParamSet_t *)domain_tlv;
 
+	if (pdomain_tlv->header.type == TLV_TYPE_DOMAIN) {
+		pregdomain_tlv =
+			(MrvlIEtypes_Rgn_dom_code_t
+				 *)(domain_tlv + sizeof(MrvlIEtypesHeader_t) +
+				    pdomain_tlv->header.len);
+	}
 	/* update region code & table based on country string */
 	if (wlan_misc_country_2_cfp_table_code(
 		    pmadapter, pdomain_tlv->country_code, &cfp_bg, &cfp_a) ==
@@ -1579,8 +1634,18 @@ mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u8 band,
 	/* TODO: don't just clobber pmadapter->domain_reg.
 	 *       Add some checking or merging between STA & UAP domain_info
 	 */
-	wlan_11d_set_domain_info(pmpriv, band, pdomain_tlv->country_code,
-				 num_sub_band, pdomain_tlv->sub_band);
+	if (pregdomain_tlv &&
+	    (pregdomain_tlv->header.type == TLV_TYPE_REGION_DOMAIN_CODE)) {
+		wlan_11d_set_domain_info(pmpriv, band,
+					 pdomain_tlv->country_code,
+					 num_sub_band, pdomain_tlv->sub_band,
+					 pregdomain_tlv->domain_code);
+	} else
+		wlan_11d_set_domain_info(pmpriv, band,
+					 pdomain_tlv->country_code,
+					 num_sub_band, pdomain_tlv->sub_band,
+					 NXP_DFS_UNKNOWN);
+
 	ret = wlan_11d_send_domain_info(pmpriv, pioctl_buf);
 
 done:
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c
old mode 100644
new mode 100755
index 9f1869617..f5d8ea6a6
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.c
@@ -3,7 +3,7 @@
  *  @brief This file contains functions for 802.11H.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -118,6 +118,8 @@ static const IEEEtypes_SupportChan_Subband_t wlan_11h_unii_mid_upper_band_1 = {
 /** U-NII sub-band config : Start Channel = 149, NumChans = 5 */
 static const IEEEtypes_SupportChan_Subband_t wlan_11h_unii_upper_band = {149,
 									 5};
+/** U-NII sub-band config : Start Channel = 169, NumChans = 3 */
+static const IEEEtypes_SupportChan_Subband_t wlan_11h_unii_4_band = {169, 3};
 
 /** Internally passed structure used to send a CMD_802_11_TPC_INFO command */
 typedef struct {
@@ -198,6 +200,92 @@ static t_u32 wlan_11h_convert_ieee_to_mrvl_ie(mlan_adapter *pmadapter,
 	return sizeof(mrvl_ie_hdr) + pin_ie[1];
 }
 
+/**
+ *  @brief find all bonded channel.
+ *
+ *  @param pri_chan   primary channel
+ *  @param bw         channel bandwidth
+ *  @param chan_list  buffer to return channel list.
+ *
+ *  @return           number of channel
+ */
+static t_u8 woal_get_bonded_channels(t_u8 pri_chan, t_u8 bw, t_u8 *chan_list)
+{
+	t_u8 ht40_plus[] = {52, 60, 100, 108, 116, 124, 132, 140};
+	t_u8 ht40_minus[] = {56, 64, 104, 112, 120, 128, 136, 144};
+	t_u8 vht80_dfs[4][4] = {{52, 56, 60, 64},
+				{100, 104, 108, 112},
+				{116, 120, 124, 128},
+				{132, 136, 140, 144}};
+	t_u8 find = MFALSE;
+	int j;
+	int i;
+	t_u8 sec_chan = 0;
+	t_u8 n_chan = 1;
+	ENTER();
+
+	if (bw == CHAN_BW_20MHZ) {
+		chan_list[0] = pri_chan;
+	} else if (bw == CHAN_BW_40MHZ) {
+		chan_list[0] = pri_chan;
+		for (i = 0; i < sizeof(ht40_minus); i++) {
+			if (pri_chan == (t_u8)ht40_plus[i]) {
+				sec_chan = pri_chan + 4;
+				n_chan = 2;
+				break;
+			}
+		}
+		for (i = 0; i < sizeof(ht40_minus); i++) {
+			if (pri_chan == (t_u8)ht40_minus[i]) {
+				sec_chan = pri_chan - 4;
+				n_chan = 2;
+				break;
+			}
+		}
+		chan_list[1] = sec_chan;
+	} else if (bw == CHAN_BW_80MHZ) {
+		for (i = 0; i < 4; i++) {
+			for (j = 0; j < 4; j++) {
+				if (pri_chan == (t_u8)vht80_dfs[i][j]) {
+					find = MTRUE;
+					break;
+				}
+			}
+			if (find)
+				break;
+		}
+		if (find) {
+			n_chan = 4;
+			for (j = 0; j < n_chan; j++) {
+				chan_list[j] = (t_u8)vht80_dfs[i][j];
+			}
+		}
+	}
+	LEAVE();
+	return n_chan;
+}
+
+/**
+ *  @brief Set channel's dfs state
+ *
+ *  @param priv         Private driver information structure
+ *  @param chan         primary channel
+ *  @param bw           channel bandwidth
+ *  @param dfs_state    dfs state
+ *
+ *  @return  N/A
+ */
+t_void wlan_11h_set_chan_dfs_state(mlan_private *priv, t_u8 chan, t_u8 bw,
+				   dfs_state_t dfs_state)
+{
+	t_u8 n_chan;
+	t_u8 chan_list[4] = {0};
+	t_u8 i;
+	n_chan = woal_get_bonded_channels(chan, bw, chan_list);
+	for (i = 0; i < n_chan; i++)
+		wlan_set_chan_dfs_state(priv, BAND_A, chan_list[i], dfs_state);
+}
+
 #ifdef STA_SUPPORT
 /**
  *  @brief Setup the IBSS DFS element passed to the firmware in adhoc start
@@ -298,7 +386,7 @@ static t_u32 wlan_11h_set_ibss_dfs_ie(mlan_private *priv,
  *    - 0 if returned element is not setup
  */
 static t_u16
-wlan_11h_set_supp_channels_ie(mlan_private *priv, t_u8 band,
+wlan_11h_set_supp_channels_ie(mlan_private *priv, t_u16 band,
 			      IEEEtypes_SupportedChannels_t *psup_chan)
 {
 	t_u16 num_subbands = 0;
@@ -352,6 +440,17 @@ wlan_11h_set_supp_channels_ie(mlan_private *priv, t_u8 band,
 		 */
 		switch (cfp_a) {
 		case 0x10: /* USA FCC   */
+			psup_chan->subband[num_subbands++] =
+				wlan_11h_unii_lower_band;
+			psup_chan->subband[num_subbands++] =
+				wlan_11h_unii_middle_band;
+			psup_chan->subband[num_subbands++] =
+				wlan_11h_unii_mid_upper_band;
+			psup_chan->subband[num_subbands++] =
+				wlan_11h_unii_upper_band;
+			psup_chan->subband[num_subbands++] =
+				wlan_11h_unii_4_band;
+			break;
 		case 0x20: /* Canada IC */
 		case 0x30: /* Europe ETSI */
 		default:
@@ -589,6 +688,7 @@ static mlan_status wlan_11h_cmd_chan_rpt_req(mlan_private *priv,
 	wlan_dfs_device_state_t *pstate_dfs = &priv->adapter->state_dfs;
 	MrvlIEtypes_ChanRpt11hBasic_t *ptlv_basic;
 	t_bool is_cancel_req = MFALSE;
+	MrvlIEtypes_ZeroDfsOperation_t *ptlv_zero_dfs;
 	t_u8 dfs53cfg = priv->adapter->dfs53cfg;
 	MrvlIEtypes_DfsW53Cfg_t *ptlv_dfs53cfg;
 
@@ -601,7 +701,8 @@ static mlan_status wlan_11h_cmd_chan_rpt_req(mlan_private *priv,
 	if (pchan_rpt_req->millisec_dwell_time == 0)
 		is_cancel_req = MTRUE;
 
-	if (pstate_dfs->dfs_check_pending && !is_cancel_req) {
+	if (pstate_dfs->dfs_check_pending && !is_cancel_req &&
+	    priv->bss_type != MLAN_BSS_TYPE_DFS) {
 		PRINTM(MERROR,
 		       "11h: ChanRptReq - previous CMD_CHAN_REPORT_REQUEST has"
 		       " not returned its result yet (as EVENT_CHANNEL_READY)."
@@ -650,17 +751,41 @@ static mlan_status wlan_11h_cmd_chan_rpt_req(mlan_private *priv,
 		pcmd_ptr->size += sizeof(MrvlIEtypes_DfsW53Cfg_t);
 	}
 
-	pcmd_ptr->size = wlan_cpu_to_le16(pcmd_ptr->size);
+	if (priv->bss_type == MLAN_BSS_TYPE_DFS) {
+		memcpy_ext(priv->adapter, &priv->chan_rep_req, pchan_rpt_req,
+			   sizeof(mlan_ds_11h_chan_rep_req),
+			   sizeof(priv->chan_rep_req));
+		ptlv_zero_dfs =
+			(MrvlIEtypes_ZeroDfsOperation_t *)(((t_u8 *)(pcmd_ptr)) +
+							   pcmd_ptr->size);
+		ptlv_zero_dfs->Header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ZERO_DFS_OPERATION);
+		ptlv_zero_dfs->Header.len = wlan_cpu_to_le16(sizeof(t_u8));
+		if (!is_cancel_req) {
+			ptlv_zero_dfs->zero_dfs_enbl = MTRUE;
+			PRINTM(MCMND, "DFS: START: chan=%d bw=%d\n",
+			       pchan_rpt_req->chan_desc.chanNum,
+			       pchan_rpt_req->chan_desc.bandcfg.chanWidth);
+		} else {
+			ptlv_zero_dfs->zero_dfs_enbl = MFALSE;
+			PRINTM(MCMND, "DFS: STOP\n");
+		}
+		pcmd_ptr->size += sizeof(MrvlIEtypes_ZeroDfsOperation_t);
+		LEAVE();
+		return MLAN_STATUS_SUCCESS;
+	}
 
 	/* update dfs sturcture.
 	 * dfs_check_pending is set when we receive CMD_RESP == SUCCESS */
 	pstate_dfs->dfs_check_pending = MFALSE;
 	pstate_dfs->dfs_radar_found = MFALSE;
 	pstate_dfs->dfs_check_priv = MNULL;
-
-	if (!is_cancel_req)
+	if (!is_cancel_req) {
 		pstate_dfs->dfs_check_channel =
 			pchan_rpt_req->chan_desc.chanNum;
+		pstate_dfs->dfs_check_bandwidth =
+			pchan_rpt_req->chan_desc.bandcfg.chanWidth;
+	}
 
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -733,7 +858,7 @@ static t_u32 wlan_11h_set_local_power_constraint_tlv(
  *                       buffer (ppbuffer)
  */
 static t_u32 wlan_11h_process_infra_join(mlan_private *priv, t_u8 **ppbuffer,
-					 t_u8 band, t_u32 channel,
+					 t_u16 band, t_u32 channel,
 					 wlan_11h_bss_info_t *p11h_bss_info)
 {
 	MrvlIEtypesHeader_t ie_header;
@@ -955,6 +1080,34 @@ static t_bool wlan_11h_is_slave_active_on_dfs_chan(mlan_private *priv)
 	return ret;
 }
 
+/**
+ *  @brief Check if the current input channel is on radar channel
+ *
+ *
+ *  @param priv    Private driver information structure
+ *  @param channel Channel to determine radar detection requirements
+ *
+ *  @return
+ *    - MTRUE if radar detection is required
+ *    - MFALSE otherwise
+ */
+t_bool wlan_11h_is_radar_channel(mlan_private *priv, t_u8 channel)
+{
+	t_bool required = MFALSE;
+
+	ENTER();
+
+	/*
+	 * No checks for 11h or measurement code being enabled is placed here
+	 * since regulatory requirements exist whether we support them or not.
+	 */
+
+	required = wlan_get_cfp_radar_detect(priv, channel);
+
+	LEAVE();
+	return required;
+}
+
 /**
  *  @brief Return whether the master interface is active, and on DFS channel.
  *  priv is assumed to already be a dfs master interface, doesn't check this.
@@ -1216,14 +1369,12 @@ wlan_11h_prepare_custom_ie_chansw(mlan_adapter *pmadapter,
 					    sizeof(mlan_ioctl_req));
 
 	/* prepare mlan_ioctl_req */
-	memset(pmadapter, pioctl_req, 0x00, sizeof(mlan_ioctl_req));
 	pioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 	pioctl_req->action = MLAN_ACT_SET;
 	pioctl_req->pbuf = (t_u8 *)pds_misc_cfg;
 	pioctl_req->buf_len = sizeof(mlan_ds_misc_cfg);
 
 	/* prepare mlan_ds_misc_cfg */
-	memset(pmadapter, pds_misc_cfg, 0x00, sizeof(mlan_ds_misc_cfg));
 	pds_misc_cfg->sub_command = MLAN_OID_MISC_CUSTOM_IE;
 	pds_misc_cfg->param.cust_ie.type = TLV_TYPE_MGMT_IE;
 	pds_misc_cfg->param.cust_ie.len = (sizeof(custom_ie) - MAX_IE_SIZE);
@@ -1306,6 +1457,8 @@ wlan_11h_prepare_custom_ie_chansw(mlan_adapter *pmadapter,
 				pvhttpcEnv_ie->local_max_tp_20mhz = 0xff;
 				pvhttpcEnv_ie->local_max_tp_40mhz = 0xff;
 				pvhttpcEnv_ie->local_max_tp_80mhz = 0xff;
+				pvhttpcEnv_ie->local_max_tp_160mhz_80_80mhz =
+					0xff;
 				pChanSwWrap_ie->len +=
 					sizeof(IEEEtypes_VhtTpcEnvelope_t);
 
@@ -1332,26 +1485,28 @@ wlan_11h_prepare_custom_ie_chansw(mlan_adapter *pmadapter,
 }
 
 #ifdef UAP_SUPPORT
-/** Bits 2,3 of band config define the band width */
-#define UAP_BAND_WIDTH_MASK 0x0C
-
 /**
  *  @brief Check if start channel 165 is allowed to operate in
  *  previous uAP channel's band config
  *
+ *  @param priv          a pointer to mlan_private structure
  *  @param start_chn     Random Start channel choosen after radar detection
  *  @param uap_band_cfg  Private driver uAP band configuration information
  * structure
  *
  *  @return MFALSE if the channel is not allowed in given band
  */
-static t_bool wlan_11h_is_band_valid(t_u8 start_chn, Band_Config_t uap_band_cfg)
+static t_bool wlan_11h_is_band_valid(mlan_private *priv, t_u8 start_chn,
+				     Band_Config_t uap_band_cfg)
 {
 	/* if band width is not 20MHZ (either 40 or 80MHz)
 	 * return MFALSE, 165 is not allowed in bands other than 20MHZ
 	 */
-	if (start_chn == 165 && (uap_band_cfg.chanWidth != CHAN_BW_20MHZ)) {
-		return MFALSE;
+	if (start_chn == 165) {
+		if (priv->adapter->region_code == COUNTRY_CODE_US)
+			return MTRUE;
+		if (uap_band_cfg.chanWidth != CHAN_BW_20MHZ)
+			return MFALSE;
 	}
 	return MTRUE;
 }
@@ -1446,7 +1601,7 @@ static t_u8 wlan_11h_get_uap_start_channel(mlan_private *priv,
 						  wlan_11h_radar_detect_required(
 							  priv, start_chn)) ||
 						 !(wlan_11h_is_band_valid(
-							 start_chn,
+							 priv, start_chn,
 							 uap_band_cfg)))) &&
 					       (++rand_tries <
 						chn_tbl->num_cfp)) {
@@ -1574,9 +1729,6 @@ static mlan_status wlan_11h_add_dfs_timestamp(mlan_adapter *pmadapter,
 			return MLAN_STATUS_FAILURE;
 		}
 
-		memset(pmadapter, (t_u8 *)pdfs_ts, 0,
-		       sizeof(wlan_dfs_timestamp_t));
-
 		util_enqueue_list_tail(pmadapter->pmoal_handle,
 				       &pmadapter->state_dfs.dfs_ts_head,
 				       (pmlan_linked_list)pdfs_ts, MNULL,
@@ -1601,6 +1753,27 @@ static mlan_status wlan_11h_add_dfs_timestamp(mlan_adapter *pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Add all bonded channel's dfs timestamp to the list
+ *
+ *  @param pmadapter  Pointer to mlan_adapter
+ *  @param repr       Timestamp 'represents' value (see _dfs_timestamp_repr_e)
+ *  @param channel    Channel number
+ *  @param bandwidth  Channel bandwidth
+ *
+ *  @return           Pointer to timestamp if found, or MNULL
+ */
+static void wlan_11h_add_all_dfs_timestamp(mlan_adapter *pmadapter, t_u8 repr,
+					   t_u8 channel, t_u8 bandwidth)
+{
+	t_u8 n_chan;
+	t_u8 chan_list[4] = {0};
+	t_u8 i;
+	n_chan = woal_get_bonded_channels(channel, bandwidth, chan_list);
+	for (i = 0; i < n_chan; i++)
+		wlan_11h_add_dfs_timestamp(pmadapter, repr, chan_list[i]);
+}
+
 /********************************************************
 			Global functions
 ********************************************************/
@@ -1684,6 +1857,217 @@ mlan_status wlan_11h_config_slave_radar_det(mlan_private *priv, t_bool enable)
 	return ret;
 }
 
+#ifdef UAP_SUPPORT
+/**
+ *  @brief Return whether the slave interface is on DFS channel.
+ *  priv is assumed to already be a dfs slave interface, doesn't check this.
+ *
+ *  @param priv  Private driver information structure
+ *
+ *  @return
+ *    - MTRUE if priv is slave, and meets both conditions
+ *    - MFALSE otherwise
+ */
+static t_bool wlan_11h_is_slave_on_dfs_chan(mlan_private *priv)
+{
+	t_bool ret = MFALSE;
+
+	ENTER();
+	if ((priv->media_connected == MTRUE) &&
+	    (priv->curr_bss_params.band & BAND_A) &&
+	    wlan_11h_is_radar_channel(
+		    priv, priv->curr_bss_params.bss_descriptor.channel))
+		ret = MTRUE;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief check if dfs_master and dfs_slave are in same channel
+ *
+ *  @param pmadapter Pointer to mlan_adapter structure
+ *
+ *  @return        MTRUE-dfs_master and dfs_slave interface on same DFS channel
+ *
+ */
+t_u8 static wlan_11h_check_dfs_channel(mlan_adapter *pmadapter)
+{
+	mlan_private *priv_master = MNULL;
+	mlan_private *priv_slave = MNULL;
+	mlan_private *priv_list[MLAN_MAX_BSS_NUM] = {MNULL};
+
+	if (wlan_get_privs_by_two_cond(
+		    pmadapter, wlan_11h_is_master_active_on_dfs_chan,
+		    wlan_11h_is_dfs_master, MTRUE, priv_list)) {
+		priv_master = priv_list[0];
+		PRINTM(MINFO, "%s: found dfs_master priv=%p\n", __func__,
+		       priv_master);
+	}
+	if (wlan_get_privs_by_two_cond(pmadapter, wlan_11h_is_slave_on_dfs_chan,
+				       wlan_11h_is_dfs_slave, MTRUE,
+				       priv_list)) {
+		priv_slave = priv_list[0];
+		PRINTM(MINFO, "%s: found dfs_slave priv=%p\n", __func__,
+		       priv_slave);
+	}
+	if (!priv_slave || !priv_master)
+		return MFALSE;
+	if (priv_master->uap_state_chan_cb.channel !=
+	    priv_slave->curr_bss_params.bss_descriptor.channel)
+		return MFALSE;
+	return MTRUE;
+}
+
+/**
+ *   @brief disable 11h and DFS function
+ *
+ *  @param priv         Private driver information structure
+ *  @param pioctl_buf   A pointer to MLAN IOCTL Request buffer
+ *
+ *  @return      MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status static wlan_11h_disable_dfs(mlan_private *priv, t_void *pioctl_buf)
+{
+	t_u32 enable = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/*
+	 * Send cmd to FW to enable/disable 11h function in firmware
+	 */
+	ret = wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,
+			       HostCmd_ACT_GEN_SET, Dot11H_i,
+			       (t_void *)pioctl_buf, &enable);
+	if (ret)
+		ret = MLAN_STATUS_FAILURE;
+	else
+		/* Set boolean flag in driver 11h state */
+		priv->intf_state_11h.is_11h_active = MFALSE;
+
+	PRINTM(MINFO, "11h: DFS %s\n", "Deactivate");
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief check if we need enable dfs_master
+ *
+ *  @param priv  Pointer to mlan_private structure
+ *				 priv should be UAP priv
+ *
+ *  @return      N/A
+ *
+ */
+void wlan_11h_update_dfs_master_state_by_uap(mlan_private *pmpriv)
+{
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	if (pmadapter->dfs_mode && wlan_11h_check_dfs_channel(pmadapter)) {
+		PRINTM(MCMND,
+		       "11h: disable DFS master when AP+STA on same DFS channel\n");
+		ret = wlan_11h_disable_dfs(pmpriv, MNULL);
+		return;
+	}
+	if (!wlan_11h_is_active(pmpriv)) {
+		/* active 11h extention in Fw */
+		PRINTM(MCMND,
+		       "11h: Enable DFS master after AP up or chan_switch\n");
+		ret = wlan_11h_activate(pmpriv, MNULL, MTRUE);
+		ret = wlan_11h_config_master_radar_det(pmpriv, MTRUE);
+		ret = wlan_11h_check_update_radar_det_state(pmpriv);
+	}
+	if (pmpriv->uap_host_based && !pmpriv->adapter->init_para.dfs_offload)
+		pmpriv->intf_state_11h.is_11h_host = MTRUE;
+	wlan_11h_set_dfs_check_chan(pmpriv, pmpriv->uap_channel,
+				    pmpriv->uap_bandwidth);
+	return;
+}
+
+/**
+ *  @brief check if dfs_master and dfs_slave are in same channel
+ *
+ *  @param pmadapter Pointer to mlan_adapter structure
+ *
+ *  @return        MTRUE-dfs_master and dfs_slave interface on same DFS channel
+ *
+ */
+void wlan_11h_update_dfs_master_state_by_sta(mlan_private *pmpriv)
+{
+	mlan_private *priv_master = MNULL;
+	mlan_private *priv_slave = MNULL;
+	mlan_private *priv_list[MLAN_MAX_BSS_NUM] = {MNULL};
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	if (wlan_get_privs_by_two_cond(
+		    pmadapter, wlan_11h_is_master_active_on_dfs_chan,
+		    wlan_11h_is_dfs_master, MTRUE, priv_list)) {
+		priv_master = priv_list[0];
+		PRINTM(MINFO, "%s: found dfs_master priv=%p\n", __func__,
+		       priv_master);
+	}
+	if (wlan_get_privs_by_two_cond(pmadapter, wlan_11h_is_slave_on_dfs_chan,
+				       wlan_11h_is_dfs_slave, MTRUE,
+				       priv_list)) {
+		priv_slave = priv_list[0];
+		PRINTM(MINFO, "%s: found dfs_slave priv=%p\n", __func__,
+		       priv_slave);
+	}
+	if (!priv_slave || !priv_master)
+		return;
+	if (priv_master->uap_state_chan_cb.channel ==
+	    priv_slave->curr_bss_params.bss_descriptor.channel) {
+		PRINTM(MCMND,
+		       "11h: disable DFS master when AP+STA on same DFS channel\n");
+		ret = wlan_11h_disable_dfs(priv_master, MNULL);
+	}
+	return;
+}
+
+/**
+ *  @brief update the dfs master state on station disconnect
+ *
+ *  @param priv  Pointer to mlan_private structure
+ *				 priv should be UAP priv
+ *
+ *  @return      N/A
+ *
+ */
+void wlan_11h_update_dfs_master_state_on_disconect(mlan_private *priv)
+{
+	mlan_private *priv_master = MNULL;
+	mlan_private *priv_list[MLAN_MAX_BSS_NUM] = {MNULL};
+	mlan_adapter *pmadapter = priv->adapter;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	if (wlan_get_privs_by_two_cond(
+		    pmadapter, wlan_11h_is_master_active_on_dfs_chan,
+		    wlan_11h_is_dfs_master, MTRUE, priv_list)) {
+		priv_master = priv_list[0];
+		PRINTM(MINFO, "%s: found dfs_master priv=%p\n", __func__,
+		       priv_master);
+	}
+	if (!priv_master) {
+		wlan_11h_check_update_radar_det_state(priv);
+		return;
+	}
+	if (!wlan_11h_is_active(priv_master)) {
+		PRINTM(MCMND, "11h: Enable DFS master after STA disconnect\n");
+		/* active 11h extention in Fw */
+		ret = wlan_11h_activate(priv_master, MNULL, MTRUE);
+		ret = wlan_11h_config_master_radar_det(priv_master, MTRUE);
+		ret = wlan_11h_check_update_radar_det_state(priv_master);
+	}
+	if (priv_master->uap_host_based && !pmadapter->init_para.dfs_offload)
+		priv_master->intf_state_11h.is_11h_host = MTRUE;
+	wlan_11h_set_dfs_check_chan(priv_master, priv_master->uap_channel,
+				    priv_master->uap_bandwidth);
+	return;
+}
+#endif
+
 /**
  *  @brief Checks all interfaces and determines if radar_detect flag states
  *         have/should be changed.  If so, sends SNMP_MIB 11H command to FW.
@@ -1896,6 +2280,8 @@ t_void wlan_11h_init(mlan_adapter *adapter)
 	pdfs_test->user_nop_period_sec = 0;
 	pdfs_test->no_channel_change_on_radar = MFALSE;
 	pdfs_test->fixed_new_channel_on_radar = 0;
+	pdfs_test->cac_restart = 0;
+	pdfs_test->millisec_dwell_time = 0;
 	adapter->dfs53cfg = adapter->init_para.dfs53cfg;
 
 	LEAVE();
@@ -1929,7 +2315,6 @@ t_void wlan_11h_cleanup(mlan_adapter *adapter)
 			adapter->pmoal_handle, &pstate_dfs->dfs_ts_head, MNULL,
 			MNULL);
 	}
-
 	LEAVE();
 }
 
@@ -2144,6 +2529,17 @@ t_bool wlan_11h_radar_detect_required(mlan_private *priv, t_u8 channel)
 	return required;
 }
 
+t_s32 wlan_11h_cancel_radar_detect(mlan_private *priv)
+{
+	t_s32 ret;
+	HostCmd_DS_CHAN_RPT_REQ chan_rpt_req;
+	memset(priv->adapter, &chan_rpt_req, 0x00, sizeof(chan_rpt_req));
+	ret = wlan_prepare_cmd(priv, HostCmd_CMD_CHAN_REPORT_REQUEST,
+			       HostCmd_ACT_GEN_SET, 0, (t_void *)MNULL,
+			       (t_void *)&chan_rpt_req);
+	return ret;
+}
+
 /**
  *  @brief Perform a radar measurement if required on given channel
  *
@@ -2232,7 +2628,21 @@ t_s32 wlan_11h_issue_radar_detect(mlan_private *priv,
 				priv->adapter->dfs_test_params
 					.user_cac_period_msec;
 		}
-
+		if (priv->adapter->dfs_test_params.cac_restart) {
+			priv->adapter->dfs_test_params.chan =
+				chan_rpt_req.chan_desc.chanNum;
+			if (chan_rpt_req.millisec_dwell_time)
+				priv->adapter->dfs_test_params
+					.millisec_dwell_time =
+					chan_rpt_req.millisec_dwell_time;
+			else
+				chan_rpt_req.millisec_dwell_time =
+					priv->adapter->dfs_test_params
+						.millisec_dwell_time;
+			memcpy_ext(priv->adapter,
+				   &priv->adapter->dfs_test_params.bandcfg,
+				   &bandcfg, sizeof(bandcfg), sizeof(bandcfg));
+		}
 		PRINTM(MMSG,
 		       "11h: issuing DFS Radar check for channel=%d."
 		       "  Please wait for response...\n",
@@ -2343,10 +2753,15 @@ t_s32 wlan_11h_process_start(mlan_private *priv, t_u8 **ppbuffer,
 	    ((adapter->adhoc_start_band & BAND_A))) {
 		if (!wlan_fw_11d_is_enabled(priv)) {
 			/* No use having 11h enabled without 11d enabled */
-			wlan_11d_enable(priv, MNULL, ENABLE_11D);
+			if (wlan_11d_enable(priv, MNULL, ENABLE_11D)) {
+				ret = MLAN_STATUS_FAILURE;
+				LEAVE();
+				return ret;
+			}
 #ifdef STA_SUPPORT
-			wlan_11d_create_dnld_countryinfo(
-				priv, adapter->adhoc_start_band);
+			if (wlan_11d_create_dnld_countryinfo(
+				    priv, adapter->adhoc_start_band))
+				PRINTM(MERROR, "Dnld_countryinfo_11d failed\n");
 #endif
 		}
 
@@ -2415,11 +2830,10 @@ t_s32 wlan_11h_process_start(mlan_private *priv, t_u8 **ppbuffer,
  *                       network that was parsed out of the scan response.
  *
  *  @return              Integer number of bytes appended to the TLV output
- *                       buffer (ppbuffer), MLAN_STATUS_FAILURE (-1),
- *                       or MLAN_STATUS_SUCCESS (0)
+ *                       buffer (ppbuffer)
  */
 t_s32 wlan_11h_process_join(mlan_private *priv, t_u8 **ppbuffer,
-			    IEEEtypes_CapInfo_t *pcap_info, t_u8 band,
+			    IEEEtypes_CapInfo_t *pcap_info, t_u16 band,
 			    t_u32 channel, wlan_11h_bss_info_t *p11h_bss_info)
 {
 	t_s32 ret = 0;
@@ -2433,11 +2847,12 @@ t_s32 wlan_11h_process_join(mlan_private *priv, t_u8 **ppbuffer,
 			 * long as the current & next APs have the same spectrum
 			 * mgmt capability bit setting
 			 */
-			ret = MLAN_STATUS_SUCCESS;
-
+			PRINTM(MINFO,
+			       "Assume DFS parameters are the same for roaming\n");
 		} else {
 			/* No support for roaming between DFS/non-DFS yet */
-			ret = MLAN_STATUS_FAILURE;
+			PRINTM(MINFO,
+			       "No support for roaming between DFS/non-DFS yet\n");
 		}
 
 		LEAVE();
@@ -2447,7 +2862,11 @@ t_s32 wlan_11h_process_join(mlan_private *priv, t_u8 **ppbuffer,
 	if (p11h_bss_info->sensed_11h) {
 		if (!wlan_fw_11d_is_enabled(priv)) {
 			/* No use having 11h enabled without 11d enabled */
-			wlan_11d_enable(priv, MNULL, ENABLE_11D);
+			if (wlan_11d_enable(priv, MNULL, ENABLE_11D)) {
+				PRINTM(MERROR, "Fail to enable 11D\n");
+				LEAVE();
+				return ret;
+			}
 #ifdef STA_SUPPORT
 			wlan_11d_parse_dnld_countryinfo(
 				priv, priv->pattempted_bss_desc);
@@ -2478,10 +2897,12 @@ t_s32 wlan_11h_process_join(mlan_private *priv, t_u8 **ppbuffer,
 				priv, ppbuffer, band, channel, p11h_bss_info);
 		}
 	} else {
-		/* Deactivate 11h functions in the firmware */
-		wlan_11h_activate(priv, MNULL, MFALSE);
-		pcap_info->spectrum_mgmt = MFALSE;
-		wlan_11h_check_update_radar_det_state(priv);
+		if (pcap_info->ibss) {
+			/* Deactivate 11h functions in the firmware */
+			wlan_11h_activate(priv, MNULL, MFALSE);
+			pcap_info->spectrum_mgmt = MFALSE;
+			wlan_11h_check_update_radar_det_state(priv);
+		}
 	}
 
 	LEAVE();
@@ -2594,11 +3015,13 @@ mlan_status wlan_11h_cmdresp_process(mlan_private *priv,
 		break;
 
 	case HostCmd_CMD_CHAN_REPORT_REQUEST:
+		if (priv->bss_type == MLAN_BSS_TYPE_DFS)
+			break;
 		priv->adapter->state_dfs.dfs_check_priv = priv;
 		priv->adapter->state_dfs.dfs_check_pending = MTRUE;
 
 		if (resp->params.chan_rpt_req.millisec_dwell_time == 0) {
-			/* from wlan_11h_ioctl_dfs_cancel_chan_report */
+			/* from wlan_11h_ioctl_dfs_chan_report */
 			priv->adapter->state_dfs.dfs_check_pending = MFALSE;
 			priv->adapter->state_dfs.dfs_check_priv = MNULL;
 			priv->adapter->state_dfs.dfs_check_channel = 0;
@@ -2744,7 +3167,10 @@ mlan_status wlan_11h_handle_event_chanswann(mlan_private *priv)
 
 	ENTER();
 #ifdef UAP_SUPPORT
-	if (priv->adapter->state_11h.is_master_radar_det_active) {
+	/** No need handle AP if mc_policy is disabled, FW will move the AP to
+	 * client's new channel */
+	if (pmadapter->mc_policy &&
+	    priv->adapter->state_11h.is_master_radar_det_active) {
 		for (i = 0; i < MIN(pmadapter->priv_num, MLAN_MAX_BSS_NUM);
 		     i++) {
 			if (pmadapter->priv[i] &&
@@ -2804,14 +3230,14 @@ mlan_status wlan_11h_handle_event_chanswann(mlan_private *priv)
 			}
 		}
 	}
-	if (pmadapter->ecsa_enable) {
-		t_u8 stop_tx = *(t_u8 *)pmadapter->event_body;
+#endif /* UAP_SUPPORT */
+	if (priv->adapter->ecsa_enable) {
+		t_u8 stop_tx = *(t_u8 *)priv->adapter->event_body;
 		if (stop_tx)
-			pmadapter->state_rdh.tx_block = MTRUE;
+			priv->adapter->state_rdh.tx_block = MTRUE;
 		LEAVE();
 		return ret;
 	}
-#endif
 	priv->adapter->state_11h.recvd_chanswann_event = MTRUE;
 
 	/* unlikely:  clean up previous csa if still on-going */
@@ -2848,7 +3274,7 @@ mlan_status wlan_11h_handle_event_chanswann(mlan_private *priv)
 	       "11h: handle_event_chanswann() - scan blacklist csa channel\n");
 	wlan_set_chan_blacklist(priv, BAND_A,
 				priv->intf_state_11h.dfs_slave_csa_chan, MTRUE);
-#endif
+#endif /* STA_SUPPORT */
 
 	priv->adapter->state_11h.recvd_chanswann_event = MFALSE;
 	LEAVE();
@@ -2885,6 +3311,7 @@ mlan_status wlan_11h_ioctl_dfs_testing(pmlan_adapter pmadapter,
 			pdfs_test_params->no_channel_change_on_radar;
 		dfs_test->usr_fixed_new_chan =
 			pdfs_test_params->fixed_new_channel_on_radar;
+		dfs_test->usr_cac_restart = pdfs_test_params->cac_restart;
 	} else {
 		pdfs_test_params->user_cac_period_msec =
 			dfs_test->usr_cac_period_msec;
@@ -2894,6 +3321,7 @@ mlan_status wlan_11h_ioctl_dfs_testing(pmlan_adapter pmadapter,
 			dfs_test->usr_no_chan_change;
 		pdfs_test_params->fixed_new_channel_on_radar =
 			dfs_test->usr_fixed_new_chan;
+		pdfs_test_params->cac_restart = dfs_test->usr_cac_restart;
 	}
 
 	LEAVE();
@@ -2901,7 +3329,54 @@ mlan_status wlan_11h_ioctl_dfs_testing(pmlan_adapter pmadapter,
 }
 
 /**
- *  @brief 802.11h IOCTL to handle channel NOP status check
+ *  @brief 802.11h IOCTL to get nop channel list
+ *
+ *  @param pmadapter    Pointer to mlan_adapter
+ *  @param pioctl_req   Pointer to mlan_ioctl_req
+ *
+ *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_11h_ioctl_nop_channel_list(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
+{
+	mlan_ds_11h_cfg *ds_11hcfg = MNULL;
+	int i, j;
+	chan_freq_power_t *pcfp = MNULL;
+	t_u8 num_chan = 0;
+	ENTER();
+
+	ds_11hcfg = (mlan_ds_11h_cfg *)pioctl_req->pbuf;
+	/*get the cfp table first */
+	for (i = 0; i < MAX_REGION_CHANNEL_NUM; i++) {
+		if (pmadapter->region_channel[i].band == BAND_A) {
+			pcfp = pmadapter->region_channel[i].pcfp;
+			break;
+		}
+	}
+	if (!pcfp) {
+		/* This means operation in BAND-A is not support, we can
+		 * just return false here, it's harmless
+		 */
+		goto done;
+	}
+	/*get the radar detection requirements according to chan num */
+	for (j = 0; j < pmadapter->region_channel[i].num_cfp; j++) {
+		if (pcfp[j].passive_scan_or_radar_detect) {
+			if (wlan_11h_is_channel_under_nop(pmadapter,
+							  pcfp[j].channel)) {
+				ds_11hcfg->param.nop_chan_list
+					.chan_list[num_chan] = pcfp[j].channel;
+				num_chan++;
+			}
+		}
+	}
+done:
+	ds_11hcfg->param.nop_chan_list.num_chan = num_chan;
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief 802.11h IOCTL to handle channel NOP status check/clear
  *  @brief If given channel is under NOP, return a new non-dfs
  *  @brief channel
  *
@@ -2910,8 +3385,8 @@ mlan_status wlan_11h_ioctl_dfs_testing(pmlan_adapter pmadapter,
  *
  *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_11h_ioctl_get_channel_nop_info(pmlan_adapter pmadapter,
-						pmlan_ioctl_req pioctl_req)
+mlan_status wlan_11h_ioctl_channel_nop_info(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
 {
 	pmlan_private pmpriv = MNULL;
 	mlan_ds_11h_cfg *ds_11hcfg = MNULL;
@@ -2929,22 +3404,31 @@ mlan_status wlan_11h_ioctl_get_channel_nop_info(pmlan_adapter pmadapter,
 			ch_nop_info->chan_under_nop =
 				wlan_11h_is_channel_under_nop(
 					pmadapter, ch_nop_info->curr_chan);
-			if (ch_nop_info->chan_under_nop) {
+			if (ch_nop_info->chan_under_nop &&
+			    ch_nop_info->check_new_chan) {
 				wlan_11h_switch_non_dfs_chan(
 					pmpriv, &ch_nop_info->new_chan.channel);
 				if (ch_nop_info->chan_width == CHAN_BW_80MHZ ||
 				    ch_nop_info->chan_width == CHAN_BW_40MHZ)
 					wlan_11h_update_bandcfg(
+						pmpriv,
 						&ch_nop_info->new_chan.bandcfg,
 						ch_nop_info->new_chan.channel);
 				if (ch_nop_info->chan_width == CHAN_BW_80MHZ)
 					ch_nop_info->new_chan.center_chan =
 						wlan_get_center_freq_idx(
-							pmpriv, BAND_AAC,
+							pmpriv,
+							ch_nop_info->new_chan
+								.bandcfg
+								.chanBand,
 							ch_nop_info->new_chan
 								.channel,
 							ch_nop_info->chan_width);
 			}
+		} else if (pioctl_req->action == MLAN_ACT_CLEAR) {
+			wlan_11h_cleanup(pmadapter);
+			wlan_reset_all_chan_dfs_state(pmpriv, BAND_A,
+						      DFS_USABLE);
 		}
 		ret = MLAN_STATUS_SUCCESS;
 	}
@@ -2985,15 +3469,64 @@ mlan_status wlan_11h_ioctl_chan_switch_count(pmlan_adapter pmadapter,
 }
 
 /**
- *  @brief 802.11h DFS cancel chan report
+ *  @brief Get/Set 802.11h  channel dfs state
+ *
+ *  @param pmadapter    Pointer to mlan_adapter
+ *  @param pioctl_req   Pointer to mlan_ioctl_req
+ *
+ *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_11h_ioctl_chan_dfs_state(pmlan_adapter pmadapter,
+					  pmlan_ioctl_req pioctl_req)
+{
+	mlan_ds_11h_cfg *ds_11hcfg = MNULL;
+	t_s32 ret = MLAN_STATUS_FAILURE;
+	pmlan_private priv = MNULL;
+
+	ENTER();
+
+	if (pioctl_req) {
+		ds_11hcfg = (mlan_ds_11h_cfg *)pioctl_req->pbuf;
+		priv = pmadapter->priv[pioctl_req->bss_index];
+
+		if (pioctl_req->action == MLAN_ACT_GET) {
+			if (MFALSE ==
+			    wlan_11h_is_channel_under_nop(
+				    pmadapter,
+				    ds_11hcfg->param.ch_dfs_state.channel))
+				PRINTM(MINFO, "Channel is not in NOP\n");
+			ds_11hcfg->param.ch_dfs_state.dfs_required =
+				wlan_11h_radar_detect_required(
+					priv,
+					ds_11hcfg->param.ch_dfs_state.channel);
+			if (ds_11hcfg->param.ch_dfs_state.dfs_required)
+				ds_11hcfg->param.ch_dfs_state
+					.dfs_state = wlan_get_chan_dfs_state(
+					priv, BAND_A,
+					ds_11hcfg->param.ch_dfs_state.channel);
+		} else {
+			wlan_set_chan_dfs_state(
+				priv, BAND_A,
+				ds_11hcfg->param.ch_dfs_state.channel,
+				ds_11hcfg->param.ch_dfs_state.dfs_state);
+		}
+		ret = MLAN_STATUS_SUCCESS;
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief 802.11h DFS chan report
  *
  *  @param priv         Pointer to mlan_private
  *  @param pioctl_req   Pointer to mlan_ioctl_req
  *
  *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_11h_ioctl_dfs_cancel_chan_report(mlan_private *priv,
-						  pmlan_ioctl_req pioctl_req)
+mlan_status wlan_11h_ioctl_dfs_chan_report(mlan_private *priv,
+					   pmlan_ioctl_req pioctl_req)
 {
 	mlan_ds_11h_cfg *ds_11hcfg = MNULL;
 	HostCmd_DS_CHAN_RPT_REQ *chan_rpt_req = MNULL;
@@ -3030,6 +3563,7 @@ t_bool wlan_11h_is_channel_under_nop(mlan_adapter *pmadapter, t_u8 channel)
 	wlan_dfs_timestamp_t *pdfs_ts = MNULL;
 	t_u32 now_sec, now_usec;
 	t_bool ret = MFALSE;
+	mlan_private *priv;
 	ENTER();
 	pdfs_ts = wlan_11h_find_dfs_timestamp(pmadapter, channel);
 
@@ -3055,6 +3589,10 @@ t_bool wlan_11h_is_channel_under_nop(mlan_adapter *pmadapter, t_u8 channel)
 		/* if entry is expired, remove it */
 		if (!ret) {
 			wlan_11h_remove_dfs_timestamp(pmadapter, pdfs_ts);
+			priv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
+			if (priv)
+				wlan_set_chan_dfs_state(priv, BAND_A, channel,
+							DFS_USABLE);
 		} else
 			PRINTM(MMSG,
 			       "11h: channel %d is under NOP - can't use.\n",
@@ -3071,12 +3609,15 @@ t_bool wlan_11h_is_channel_under_nop(mlan_adapter *pmadapter, t_u8 channel)
  *
  *  @param priv     Pointer to mlan_private
  *  @param pevent   Pointer to mlan_event
+ *  @param radar_chan 	Pointer to radar channel
+ *  @param bandwidth    Pointer to band width
  *
  *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
 mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 						mlan_event *pevent,
-						t_u8 *radar_chan)
+						t_u8 *radar_chan,
+						t_u8 *bandwidth)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	HostCmd_DS_CHAN_RPT_RSP *pchan_rpt_rsp;
@@ -3089,12 +3630,19 @@ mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 	wlan_dfs_device_state_t *pstate_dfs = &priv->adapter->state_dfs;
 	t_u8 dfs_radar_found = MFALSE;
 	t_u8 dfs_check_channel = pstate_dfs->dfs_check_channel;
+	t_u8 dfs_check_bandwidth = pstate_dfs->dfs_check_bandwidth;
+	MrvlIEtypes_channel_band_t *tlv;
 
 	ENTER();
 	pchan_rpt_rsp = (HostCmd_DS_CHAN_RPT_RSP *)&pevent->event_buf;
 	DBG_HEXDUMP(MCMD_D, "11h: Event ChanRptReady (HostCmd_DS_CHAN_RPT_RSP)",
 		    (t_u8 *)pchan_rpt_rsp, pevent->event_len);
 
+	if (priv->bss_type == MLAN_BSS_TYPE_DFS) {
+		dfs_check_channel = priv->chan_rep_req.chanNum;
+		dfs_check_bandwidth = priv->chan_rep_req.bandcfg.chanWidth;
+	}
+
 	if (wlan_le32_to_cpu(pchan_rpt_rsp->cmd_result) ==
 	    MLAN_CMD_RESULT_SUCCESS) {
 		pbuffer = (t_u8 *)&pchan_rpt_rsp->tlv_buffer;
@@ -3102,7 +3650,7 @@ mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 		evt_len -= sizeof(HostCmd_DS_CHAN_RPT_RSP) -
 			   sizeof(pchan_rpt_rsp->tlv_buffer);
 
-		while (evt_len >= sizeof(MrvlIEtypesHeader_t)) {
+		while (evt_len >= (t_s32)sizeof(MrvlIEtypesHeader_t)) {
 			ptlv = (MrvlIEtypes_Data_t *)pbuffer;
 			tlv_len = wlan_le16_to_cpu(ptlv->header.len);
 
@@ -3113,6 +3661,11 @@ mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 				if (pmeas_rpt_basic->radar)
 					dfs_radar_found = MTRUE;
 				break;
+			case TLV_TYPE_CHANNELBANDLIST:
+				tlv = (MrvlIEtypes_channel_band_t *)ptlv;
+				dfs_check_channel = tlv->channel;
+				dfs_check_bandwidth = tlv->bandcfg.chanWidth;
+				break;
 			default:
 				break;
 			}
@@ -3125,20 +3678,29 @@ mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 		ret = MLAN_STATUS_FAILURE;
 	}
 	if (dfs_radar_found) {
-		PRINTM(MMSG, "RADAR Detected on channel %d!\n",
-		       dfs_check_channel);
+		PRINTM(MMSG, "RADAR Detected on channel %d bw=%d !\n",
+		       dfs_check_channel, dfs_check_bandwidth);
 		/* add channel to NOP list */
-		wlan_11h_add_dfs_timestamp(priv->adapter, DFS_TS_REPR_NOP_START,
-					   dfs_check_channel);
+		wlan_11h_add_all_dfs_timestamp(priv->adapter,
+					       DFS_TS_REPR_NOP_START,
+					       dfs_check_channel,
+					       dfs_check_bandwidth);
 	}
 	*radar_chan = dfs_check_channel;
+	*bandwidth = dfs_check_bandwidth;
+	if (dfs_radar_found)
+		wlan_11h_set_chan_dfs_state(priv, dfs_check_channel,
+					    dfs_check_bandwidth,
+					    DFS_UNAVAILABLE);
+	else
+		wlan_11h_set_chan_dfs_state(priv, dfs_check_channel,
+					    dfs_check_bandwidth, DFS_AVAILABLE);
 	pstate_dfs->dfs_radar_found = dfs_radar_found;
 	/* Update DFS structure. */
 	priv->adapter->callbacks.moal_get_system_time(
 		priv->adapter->pmoal_handle, &sec, &usec);
 	pstate_dfs->dfs_report_time_sec = sec;
 	pstate_dfs->dfs_check_pending = MFALSE;
-	pstate_dfs->dfs_check_priv = MNULL;
 
 	LEAVE();
 	return ret;
@@ -3151,16 +3713,38 @@ mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
  *  @param priv   		Pointer to mlan_private
  *  @param pevent 		Pointer to mlan_event
  *  @param radar_chan 	Pointer to radar channel
+ *  @param bandwidth    Pointer to band width
  *
  *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
 mlan_status wlan_11h_print_event_radar_detected(mlan_private *priv,
 						mlan_event *pevent,
-						t_u8 *radar_chan)
+						t_u8 *radar_chan,
+						t_u8 *bandwidth)
 {
 	wlan_dfs_device_state_t *pstate_dfs = &priv->adapter->state_dfs;
+	t_u8 dfs_check_bandwidth = pstate_dfs->dfs_check_bandwidth;
+	MrvlIEtypes_channel_band_t *tlv;
 	ENTER();
 	*radar_chan = pstate_dfs->dfs_check_channel;
+	if (pevent->event_len >= sizeof(MrvlIEtypes_channel_band_t)) {
+		tlv = (MrvlIEtypes_channel_band_t *)&pevent->event_buf;
+		*radar_chan = tlv->channel;
+		dfs_check_bandwidth = tlv->bandcfg.chanWidth;
+	} else {
+		if (priv->bss_type == MLAN_BSS_TYPE_DFS) {
+			*radar_chan = priv->chan_rep_req.chanNum;
+			dfs_check_bandwidth =
+				priv->chan_rep_req.bandcfg.chanWidth;
+		}
+	}
+	*bandwidth = dfs_check_bandwidth;
+	wlan_11h_add_all_dfs_timestamp(priv->adapter, DFS_TS_REPR_NOP_START,
+				       *radar_chan, dfs_check_bandwidth);
+	wlan_11h_set_chan_dfs_state(priv, *radar_chan, dfs_check_bandwidth,
+				    DFS_UNAVAILABLE);
+	PRINTM(MEVENT, "DFS: Radar detected on %d bw=%d\n", *radar_chan,
+	       dfs_check_bandwidth);
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
@@ -3229,8 +3813,13 @@ void wlan_dfs_rep_disconnect(mlan_adapter *pmadapter)
 
 		if (wlan_11h_radar_detect_required(pmpriv,
 						   pmadapter->dfsr_channel)) {
-			wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_STOP,
-					 HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
+			mlan_status ret = MLAN_STATUS_SUCCESS;
+			ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_STOP,
+					       HostCmd_ACT_GEN_SET, 0, MNULL,
+					       MNULL);
+			if (ret) {
+				PRINTM(MMSG, "Error sending message to FW\n");
+			}
 		}
 	}
 }
@@ -3247,6 +3836,7 @@ void wlan_dfs_rep_bw_change(mlan_adapter *pmadapter)
 	mlan_private *priv_list[MLAN_MAX_BSS_NUM];
 	mlan_private *pmpriv = MNULL;
 	t_u8 pcount, i;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	memset(pmadapter, priv_list, 0x00, sizeof(priv_list));
 	pcount = wlan_get_privs_by_cond(pmadapter, wlan_is_intf_active,
@@ -3273,8 +3863,12 @@ void wlan_dfs_rep_bw_change(mlan_adapter *pmadapter)
 				    pmpriv, pmadapter->dfsr_channel))
 				return;
 
-			wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_STOP,
-					 HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
+			ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_STOP,
+					       HostCmd_ACT_GEN_SET, 0, MNULL,
+					       MNULL);
+			if (ret) {
+				PRINTM(MERROR, "Error sending message to FW\n");
+			}
 		}
 	}
 
@@ -3283,8 +3877,12 @@ void wlan_dfs_rep_bw_change(mlan_adapter *pmadapter)
 		pmpriv = priv_list[i];
 
 		if (GET_BSS_ROLE(pmpriv) == MLAN_BSS_ROLE_UAP) {
-			wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_START,
-					 HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
+			ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_BSS_START,
+					       HostCmd_ACT_GEN_SET, 0, MNULL,
+					       MNULL);
+			if (ret) {
+				PRINTM(MERROR, "Error sending message to FW\n");
+			}
 		}
 	}
 }
@@ -3298,7 +3896,8 @@ void wlan_dfs_rep_bw_change(mlan_adapter *pmadapter)
  *
  *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE or MLAN_STATUS_PENDING
  */
-void wlan_11h_update_bandcfg(Band_Config_t *uap_band_cfg, t_u8 new_channel)
+void wlan_11h_update_bandcfg(mlan_private *pmpriv, Band_Config_t *uap_band_cfg,
+			     t_u8 new_channel)
 {
 	t_u8 chan_offset;
 	ENTER();
@@ -3307,7 +3906,7 @@ void wlan_11h_update_bandcfg(Band_Config_t *uap_band_cfg, t_u8 new_channel)
 	 * Clear the channel bandwidth for 20MHz
 	 * since channel switch could be happening from 40/80MHz to 20MHz
 	 */
-	chan_offset = wlan_get_second_channel_offset(new_channel);
+	chan_offset = wlan_get_second_channel_offset(pmpriv, new_channel);
 	uap_band_cfg->chan2Offset = chan_offset;
 
 	if (!chan_offset) { /* 40MHz/80MHz */
@@ -3317,6 +3916,7 @@ void wlan_11h_update_bandcfg(Band_Config_t *uap_band_cfg, t_u8 new_channel)
 	LEAVE();
 }
 
+#ifdef UAP_SUPPORT
 /**
  * @brief Get priv current index -- this is used to enter correct rdh_state
  * during radar handling
@@ -3326,8 +3926,9 @@ void wlan_11h_update_bandcfg(Band_Config_t *uap_band_cfg, t_u8 new_channel)
  *
  * @return                 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_11h_get_priv_curr_idx(mlan_private *pmpriv,
-				       wlan_radar_det_hndlg_state_t *pstate_rdh)
+static mlan_status
+wlan_11h_get_priv_curr_idx(mlan_private *pmpriv,
+			   wlan_radar_det_hndlg_state_t *pstate_rdh)
 {
 	t_bool found = MFALSE;
 	ENTER();
@@ -3344,6 +3945,7 @@ mlan_status wlan_11h_get_priv_curr_idx(mlan_private *pmpriv,
 	}
 	return (found == MTRUE) ? MLAN_STATUS_SUCCESS : MLAN_STATUS_FAILURE;
 }
+#endif
 
 /**
  *  @brief Driver handling for remove customeie
@@ -3629,7 +4231,8 @@ mlan_status wlan_11h_radar_detected_handling(mlan_adapter *pmadapter,
 
 		/* check next intf */
 		while ((++pstate_rdh->priv_curr_idx) <
-		       pstate_rdh->priv_list_count) {
+			       pstate_rdh->priv_list_count &&
+		       (pstate_rdh->priv_curr_idx < MLAN_MAX_BSS_NUM)) {
 			pmpriv =
 				pstate_rdh->priv_list[pstate_rdh->priv_curr_idx];
 
@@ -3868,7 +4471,7 @@ mlan_status wlan_11h_radar_detected_handling(mlan_adapter *pmadapter,
 
 				/* DFS only in 5GHz */
 				wlan_11h_update_bandcfg(
-					&pstate_rdh->uap_band_cfg,
+					pmpriv, &pstate_rdh->uap_band_cfg,
 					pstate_rdh->new_channel);
 				PRINTM(MCMD_D,
 				       "RDH_SET_NEW_CHANNEL: uAP band config = 0x%x channel=%d\n",
@@ -4067,7 +4670,7 @@ mlan_status wlan_11h_dfs_event_preprocessing(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_FAILURE;
 	mlan_private *pmpriv = MNULL;
-	mlan_private *priv_list[MLAN_MAX_BSS_NUM] = {0};
+	mlan_private *priv_list[MLAN_MAX_BSS_NUM] = {MNULL};
 
 	ENTER();
 	switch (pmadapter->event_cause & EVENT_ID_MASK) {
@@ -4086,7 +4689,8 @@ mlan_status wlan_11h_dfs_event_preprocessing(mlan_adapter *pmadapter)
 			pmpriv = priv_list[0];
 			PRINTM(MINFO, "%s: found dfs_slave priv=%p\n", __func__,
 			       pmpriv);
-		} else if (pmadapter->state_dfs.dfs_check_pending) {
+		} else if (pmadapter->state_dfs.dfs_check_pending ||
+			   pmadapter->state_dfs.dfs_check_channel) {
 			pmpriv = (mlan_private *)(pmadapter->state_dfs
 							  .dfs_check_priv);
 			PRINTM(MINFO, "%s: found dfs priv=%p\n", __func__,
@@ -4202,14 +4806,16 @@ mlan_status wlan_11h_switch_non_dfs_chan(mlan_private *priv, t_u8 *chan)
  *  @param priv    Void pointer to mlan_private
  *
  *  @param chan    pointer to channel
+ *  @param bandwidth    band width
  *
  *  @return  N/A
  */
-void wlan_11h_set_dfs_check_chan(mlan_private *priv, t_u8 chan)
+void wlan_11h_set_dfs_check_chan(mlan_private *priv, t_u8 chan, t_u8 bandwidth)
 {
 	wlan_dfs_device_state_t *pstate_dfs = &priv->adapter->state_dfs;
 	ENTER();
 	pstate_dfs->dfs_check_channel = chan;
+	pstate_dfs->dfs_check_bandwidth = bandwidth;
 	PRINTM(MCMND, "Set dfs_check_channel=%d\n", chan);
 	LEAVE();
 }
@@ -4243,3 +4849,29 @@ mlan_status wlan_11h_ioctl_dfs_w53_cfg(pmlan_adapter pmadapter,
 
 	return MLAN_STATUS_SUCCESS;
 }
+
+/**
+ *  @brief 802.11h DFS mode configuration
+ *
+ *  @param pmadapter    Pointer to mlan_adapter
+ *  @param pioctl_req   Pointer to mlan_ioctl_req
+ *
+ *  @return MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_11h_ioctl_dfs_mode(pmlan_adapter pmadapter,
+				    pmlan_ioctl_req pioctl_req)
+{
+	mlan_ds_11h_cfg *ds_11hcfg = MNULL;
+
+	ENTER();
+
+	ds_11hcfg = (mlan_ds_11h_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_GET) {
+		ds_11hcfg->param.dfs_mode = pmadapter->dfs_mode;
+	} else {
+		pmadapter->dfs_mode = ds_11hcfg->param.dfs_mode;
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h
old mode 100644
new mode 100755
index 534ffd6a2..4d0f563dc
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11h.h
@@ -4,7 +4,7 @@
  *  function declarations of 802.11h
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -63,6 +63,14 @@ extern mlan_status wlan_11h_config_slave_radar_det(mlan_private *priv,
 
 /** Checks all interfaces and updates radar detect flags if necessary */
 extern mlan_status wlan_11h_check_update_radar_det_state(mlan_private *pmpriv);
+#ifdef UAP_SUPPORT
+/** update dfs master state from uap interface */
+void wlan_11h_update_dfs_master_state_by_uap(mlan_private *pmpriv);
+/** update dfs master when station disconnected */
+void wlan_11h_update_dfs_master_state_on_disconect(mlan_private *priv);
+/** update dfs master state from STA interface */
+void wlan_11h_update_dfs_master_state_by_sta(mlan_private *pmpriv);
+#endif
 
 /** Return 1 if 11h is active in the firmware, 0 if it is inactive */
 extern t_bool wlan_11h_is_active(mlan_private *priv);
@@ -111,7 +119,7 @@ extern t_s32 wlan_11h_process_start(mlan_private *priv, t_u8 **ppbuffer,
 
 /** Add any 11h TLVs necessary to complete a join command (adhoc or infra) */
 extern t_s32 wlan_11h_process_join(mlan_private *priv, t_u8 **ppbuffer,
-				   IEEEtypes_CapInfo_t *pcap_info, t_u8 band,
+				   IEEEtypes_CapInfo_t *pcap_info, t_u16 band,
 				   t_u32 channel,
 				   wlan_11h_bss_info_t *p11h_bss_info);
 
@@ -135,30 +143,40 @@ extern mlan_status wlan_11h_handle_event_chanswann(mlan_private *priv);
 /** Handler for EVENT_CHANNEL_REPORT_RDY */
 extern mlan_status wlan_11h_handle_event_chanrpt_ready(mlan_private *priv,
 						       mlan_event *pevent,
-						       t_u8 *radar_chan);
+						       t_u8 *radar_chan,
+						       t_u8 *bandwidth);
 
 /** Debug output for EVENT_RADAR_DETECTED */
 mlan_status wlan_11h_print_event_radar_detected(mlan_private *priv,
 						mlan_event *pevent,
-						t_u8 *radar_chan);
+						t_u8 *radar_chan,
+						t_u8 *bandwidth);
 
+t_s32 wlan_11h_cancel_radar_detect(mlan_private *priv);
 /** Handler for DFS_TESTING IOCTL */
 extern mlan_status wlan_11h_ioctl_dfs_testing(pmlan_adapter pmadapter,
 					      pmlan_ioctl_req pioctl_req);
-extern mlan_status
-wlan_11h_ioctl_get_channel_nop_info(pmlan_adapter pmadapter,
-				    pmlan_ioctl_req pioctl_req);
+extern mlan_status wlan_11h_ioctl_channel_nop_info(pmlan_adapter pmadapter,
+						   pmlan_ioctl_req pioctl_req);
+extern mlan_status wlan_11h_ioctl_nop_channel_list(pmlan_adapter pmadapter,
+						   pmlan_ioctl_req pioctl_req);
 
-extern mlan_status
-wlan_11h_ioctl_dfs_cancel_chan_report(mlan_private *priv,
-				      pmlan_ioctl_req pioctl_req);
+extern mlan_status wlan_11h_ioctl_dfs_chan_report(mlan_private *priv,
+						  pmlan_ioctl_req pioctl_req);
 extern mlan_status wlan_11h_ioctl_chan_switch_count(pmlan_adapter pmadapter,
 						    pmlan_ioctl_req pioctl_req);
 
+/** get/set channel dfs state */
+mlan_status wlan_11h_ioctl_chan_dfs_state(pmlan_adapter pmadapter,
+					  pmlan_ioctl_req pioctl_req);
+
 /** get/set dfs w53 cfg */
 mlan_status wlan_11h_ioctl_dfs_w53_cfg(pmlan_adapter pmadapter,
 				       pmlan_ioctl_req pioctl_req);
 
+/** get/set dfs mode */
+mlan_status wlan_11h_ioctl_dfs_mode(pmlan_adapter pmadapter,
+				    pmlan_ioctl_req pioctl_req);
 /** Check if channel is under a NOP duration (should not be used) */
 extern t_bool wlan_11h_is_channel_under_nop(mlan_adapter *pmadapter,
 					    t_u8 channel);
@@ -169,7 +187,7 @@ extern t_bool wlan_11h_radar_detected_tx_blocked(mlan_adapter *pmadapter);
 /** Callback for RADAR_DETECTED (for UAP cmdresp) */
 extern mlan_status wlan_11h_radar_detected_callback(t_void *priv);
 /** set dfs check channel */
-void wlan_11h_set_dfs_check_chan(mlan_private *priv, t_u8 chan);
+void wlan_11h_set_dfs_check_chan(mlan_private *priv, t_u8 chan, t_u8 bandwidth);
 
 #ifdef UAP_SUPPORT
 /** BW_change event Handler for dfs_repeater */
@@ -192,7 +210,8 @@ extern mlan_status wlan_11h_dfs_event_preprocessing(mlan_adapter *pmadapter);
 /** DFS switch to non-DFS channel */
 extern mlan_status wlan_11h_switch_non_dfs_chan(mlan_private *priv, t_u8 *chan);
 
-extern void wlan_11h_update_bandcfg(Band_Config_t *uap_band_cfg,
+extern void wlan_11h_update_bandcfg(mlan_private *pmpriv,
+				    Band_Config_t *uap_band_cfg,
 				    t_u8 new_channel);
 
 /** function checks if interface is active. **/
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c
old mode 100644
new mode 100755
index 6be3969ea..ce5e49bb4
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.c
@@ -3,7 +3,7 @@
  *  @brief This file contains functions for 11n handling.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -61,9 +61,24 @@ static mlan_status wlan_11n_ioctl_max_tx_buf_size(pmlan_adapter pmadapter,
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_11n_cfg *cfg = MNULL;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 
 	ENTER();
 	cfg = (mlan_ds_11n_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET) {
+		if (cfg->param.tx_buf_size == 0xffff) {
+			PRINTM(MIOCTL, "Send reconfigure tx buf to FW\n");
+			ret = wlan_prepare_cmd(pmpriv,
+					       HostCmd_CMD_RECONFIGURE_TX_BUFF,
+					       HostCmd_ACT_GEN_SET, 0,
+					       (t_void *)pioctl_req,
+					       &cfg->param.tx_buf_size);
+			if (ret == MLAN_STATUS_SUCCESS)
+				ret = MLAN_STATUS_PENDING;
+			LEAVE();
+			return ret;
+		}
+	}
 	cfg->param.tx_buf_size = (t_u32)pmadapter->max_tx_buf_size;
 	pioctl_req->data_read_written = sizeof(t_u32) + MLAN_SUB_COMMAND_SIZE;
 
@@ -354,6 +369,81 @@ static mlan_status wlan_11n_ioctl_coex_rx_winsize(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief This function will send delba request to
+ *          the peer in the TxBAStreamTbl
+ *
+ *  @param priv     A pointer to mlan_private
+ *  @param ra       MAC Address to send DELBA
+ *
+ *  @return         N/A
+ */
+void wlan_11n_send_delba_to_peer(mlan_private *priv, t_u8 *ra)
+{
+	TxBAStreamTbl *ptx_tbl;
+
+	ENTER();
+	wlan_request_ralist_lock(priv);
+	ptx_tbl = (TxBAStreamTbl *)util_peek_list(priv->adapter->pmoal_handle,
+						  &priv->tx_ba_stream_tbl_ptr,
+						  MNULL, MNULL);
+	if (!ptx_tbl) {
+		wlan_release_ralist_lock(priv);
+		LEAVE();
+		return;
+	}
+
+	while (ptx_tbl != (TxBAStreamTbl *)&priv->tx_ba_stream_tbl_ptr) {
+		if (!memcmp(priv->adapter, ptx_tbl->ra, ra,
+			    MLAN_MAC_ADDR_LENGTH)) {
+			PRINTM(MIOCTL, "Tx:Send delba to tid=%d, " MACSTR "\n",
+			       ptx_tbl->tid, MAC2STR(ptx_tbl->ra));
+			wlan_send_delba(priv, MNULL, ptx_tbl->tid, ptx_tbl->ra,
+					1);
+		}
+		ptx_tbl = ptx_tbl->pnext;
+	}
+	wlan_release_ralist_lock(priv);
+	/* Signal MOAL to trigger mlan_main_process */
+	wlan_recv_event(priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING, MNULL);
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief Set/Get control to TX AMPDU configuration on infra link
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+static mlan_status wlan_11n_ioctl_txaggrctrl(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_11n_cfg *cfg = MNULL;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	cfg = (mlan_ds_11n_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_GET)
+		cfg->param.txaggrctrl = pmpriv->txaggrctrl;
+	else if (pioctl_req->action == MLAN_ACT_SET)
+		pmpriv->txaggrctrl = (t_u8)cfg->param.txaggrctrl;
+
+	if (pmpriv->media_connected == MTRUE) {
+		if (pioctl_req->action == MLAN_ACT_SET && !pmpriv->txaggrctrl &&
+		    pmpriv->adapter->tdls_status != TDLS_NOT_SETUP)
+			wlan_11n_send_delba_to_peer(
+				pmpriv, pmpriv->curr_bss_params.bss_descriptor
+						.mac_address);
+	}
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief This function will resend addba request to all
  *          the peer in the TxBAStreamTbl
@@ -956,7 +1046,7 @@ static void wlan_send_delba_txbastream_tbl(pmlan_private priv, t_u8 tid)
  *
  *  @return		N/A
  */
-void wlan_update_all_stations_ampdu(mlan_private *priv)
+static void wlan_update_all_stations_ampdu(mlan_private *priv)
 {
 	sta_node *sta_ptr;
 	mlan_adapter *pmadapter = priv->adapter;
@@ -975,7 +1065,7 @@ void wlan_update_all_stations_ampdu(mlan_private *priv)
 	}
 	while (sta_ptr != (sta_node *)&priv->sta_list) {
 		for (i = 0; i < MAX_NUM_TID; i++) {
-			if (sta_ptr->is_11n_enabled)
+			if (sta_ptr->is_11n_enabled || sta_ptr->is_11ax_enabled)
 				sta_ptr->ampdu_sta[i] =
 					priv->aggr_prio_tbl[i].ampdu_user;
 		}
@@ -1158,7 +1248,8 @@ static mlan_status wlan_11n_ioctl_supported_mcs_set(pmlan_adapter pmadapter,
 	if ((ISSUPP_CHANWIDTH40(pmpriv->usr_dot_11n_dev_cap_bg) ||
 	     ISSUPP_CHANWIDTH40(pmpriv->usr_dot_11n_dev_cap_a)) &&
 	    !(pmpriv->curr_chan_flags & CHAN_FLAGS_NO_HT40PLUS &&
-	      pmpriv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS))
+	      pmpriv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS) &&
+	    pmadapter->init_para.mcs32 == 1)
 		SETHT_MCS32(mcs_set);
 
 	cfg = (mlan_ds_11n_cfg *)pioctl_req->pbuf;
@@ -1255,7 +1346,7 @@ static TxBAStreamTbl *wlan_11n_get_txbastream_status(mlan_private *priv,
  *
  *  @return             N/A
  */
-static void wlan_fill_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u8 bands)
+static void wlan_fill_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u16 bands)
 {
 	t_u32 usr_dot_11n_dev_cap;
 
@@ -1319,11 +1410,18 @@ static void wlan_fill_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u8 bands)
 
 	/* Need change to support 8k AMSDU receive */
 	RESETHT_MAXAMSDU(ht_cap->ht_cap_info);
+
 	/* SM power save */
-	if (ISSUPP_MIMOPS(priv->adapter->hw_dot_11n_dev_cap))
-		RESETHT_SM_POWERSAVE(ht_cap->ht_cap_info); /* Enable HT SMPS*/
-	else
-		SETHT_STATIC_SMPS(ht_cap->ht_cap_info); /* Disable HT SMPS */
+	RESETHT_SM_POWERSAVE(ht_cap->ht_cap_info); /* Clear to HT SMPS static
+						      mode*/
+	if (ISSUPP_MIMOPS(usr_dot_11n_dev_cap)) {
+		if (ISSUPP_SMPS_DYNAMIC_MODE(usr_dot_11n_dev_cap))
+			SETHT_SMPS_DYNAMIC(ht_cap->ht_cap_info); /* Set to HT
+								    SMPS dynamic
+								    mode */
+	} else {
+		SETHT_SMPS_DISABLE(ht_cap->ht_cap_info); /* Disable HT SMPS */
+	}
 
 	LEAVE();
 }
@@ -1337,7 +1435,8 @@ static void wlan_fill_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u8 bands)
  *
  *  @return             N/A
  */
-static void wlan_reset_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u8 bands)
+static void wlan_reset_cap_info(mlan_private *priv, HTCap_t *ht_cap,
+				t_u16 bands)
 {
 	t_u32 usr_dot_11n_dev_cap;
 
@@ -1386,8 +1485,8 @@ static void wlan_reset_cap_info(mlan_private *priv, HTCap_t *ht_cap, t_u8 bands)
 	/* Need change to support 8k AMSDU receive */
 	RESETHT_MAXAMSDU(ht_cap->ht_cap_info);
 	/* SM power save */
-	if (!ISSUPP_MIMOPS(priv->adapter->hw_dot_11n_dev_cap))
-		SETHT_STATIC_SMPS(ht_cap->ht_cap_info); /* Disable HT SMPS */
+	if (!ISSUPP_MIMOPS(usr_dot_11n_dev_cap))
+		SETHT_SMPS_DISABLE(ht_cap->ht_cap_info); /* Disable HT SMPS */
 
 	LEAVE();
 }
@@ -1427,12 +1526,12 @@ void wlan_fill_ht_cap_tlv(mlan_private *priv, MrvlIETypes_HTCap_t *pht_cap,
 
 	/* Set ampdu param */
 	SETAMPDU_SIZE(pht_cap->ht_cap.ampdu_param, AMPDU_FACTOR_64K);
-	SETAMPDU_SPACING(pht_cap->ht_cap.ampdu_param, 0);
+	SETAMPDU_SPACING(pht_cap->ht_cap.ampdu_param,
+			 pmadapter->hw_mpdu_density);
 
 	rx_mcs_supp = GET_RXMCSSUPP(priv->usr_dev_mcs_support);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	if (IS_CARD9098(pmadapter->card_type) ||
+	    IS_CARDIW62X(pmadapter->card_type) ||
 	    IS_CARD9097(pmadapter->card_type)) {
 		if (bands & BAND_A)
 			rx_mcs_supp = MIN(
@@ -1443,7 +1542,6 @@ void wlan_fill_ht_cap_tlv(mlan_private *priv, MrvlIETypes_HTCap_t *pht_cap,
 				MIN(rx_mcs_supp,
 				    GET_RXMCSSUPP(pmadapter->user_htstream));
 	}
-#endif
 	memset(pmadapter, (t_u8 *)pht_cap->ht_cap.supported_mcs_set, 0xff,
 	       rx_mcs_supp);
 	/* Clear all the other values to get the minimum mcs set btw STA and AP
@@ -1456,7 +1554,8 @@ void wlan_fill_ht_cap_tlv(mlan_private *priv, MrvlIETypes_HTCap_t *pht_cap,
 	 * supprot*/
 	if (ISSUPP_CHANWIDTH40(usr_dot_11n_dev_cap) &&
 	    !(priv->curr_chan_flags & CHAN_FLAGS_NO_HT40PLUS &&
-	      priv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS))
+	      priv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS) &&
+	    pmadapter->init_para.mcs32 == 1)
 		SETHT_MCS32(pht_cap->ht_cap.supported_mcs_set);
 
 	/* Clear RD responder bit */
@@ -1504,9 +1603,8 @@ void wlan_fill_ht_cap_ie(mlan_private *priv, IEEEtypes_HTCap_t *pht_cap,
 	SETAMPDU_SPACING(pht_cap->ht_cap.ampdu_param, 0);
 
 	rx_mcs_supp = GET_RXMCSSUPP(priv->usr_dev_mcs_support);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	if (IS_CARD9098(pmadapter->card_type) ||
+	    IS_CARDIW62X(pmadapter->card_type) ||
 	    IS_CARD9097(pmadapter->card_type)) {
 		if (bands & BAND_A)
 			rx_mcs_supp = MIN(
@@ -1517,7 +1615,6 @@ void wlan_fill_ht_cap_ie(mlan_private *priv, IEEEtypes_HTCap_t *pht_cap,
 				MIN(rx_mcs_supp,
 				    GET_RXMCSSUPP(pmadapter->user_htstream));
 	}
-#endif
 	memset(pmadapter, (t_u8 *)pht_cap->ht_cap.supported_mcs_set, 0xff,
 	       rx_mcs_supp);
 	/* Clear all the other values to get the minimum mcs set btw STA and AP
@@ -1530,7 +1627,8 @@ void wlan_fill_ht_cap_ie(mlan_private *priv, IEEEtypes_HTCap_t *pht_cap,
 	 * supprot*/
 	if (ISSUPP_CHANWIDTH40(usr_dot_11n_dev_cap) &&
 	    !(priv->curr_chan_flags & CHAN_FLAGS_NO_HT40PLUS &&
-	      priv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS))
+	      priv->curr_chan_flags & CHAN_FLAGS_NO_HT40MINUS) &&
+	    pmadapter->init_para.mcs32 == 1)
 		SETHT_MCS32(pht_cap->ht_cap.supported_mcs_set);
 
 	/* Clear RD responder bit */
@@ -1761,6 +1859,9 @@ mlan_status wlan_ret_11n_addba_req(mlan_private *priv, HostCmd_DS_COMMAND *resp)
 				disable_station_ampdu(
 					priv, tid, padd_ba_rsp->peer_mac_addr);
 #endif /* UAP_SUPPORT */
+			if (ra_list && ra_list->is_tdls_link)
+				disable_station_ampdu(
+					priv, tid, padd_ba_rsp->peer_mac_addr);
 			priv->aggr_prio_tbl[tid].ampdu_ap =
 				BA_STREAM_NOT_ALLOWED;
 
@@ -2159,7 +2260,7 @@ mlan_status wlan_ret_tx_bf_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			txbf->no_of_peers = *(t_u8 *)&txbfcfg->body;
 			tx_bf_peer = (bf_peer_args *)((t_u8 *)&txbfcfg->body +
 						      sizeof(t_u8));
-			for (i = 0; i < txbf->no_of_peers; i++) {
+			for (i = 0; i < (int)txbf->no_of_peers; i++) {
 				memcpy_ext(pmadapter,
 					   txbf->body.tx_bf_peer[i].peer_mac,
 					   (t_u8 *)tx_bf_peer->peer_mac,
@@ -2178,7 +2279,7 @@ mlan_status wlan_ret_tx_bf_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			txbf->no_of_peers = *(t_u8 *)&txbfcfg->body;
 			bf_snr = (bf_snr_thr_t *)((t_u8 *)&txbfcfg->body +
 						  sizeof(t_u8));
-			for (i = 0; i < txbf->no_of_peers; i++) {
+			for (i = 0; i < (int)txbf->no_of_peers; i++) {
 				memcpy_ext(pmadapter,
 					   txbf->body.bf_snr[i].peer_mac,
 					   (t_u8 *)bf_snr->peer_mac,
@@ -2204,10 +2305,14 @@ mlan_status wlan_ret_tx_bf_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
  * @param chan            channel num
  * @return                second channel offset
  */
-t_u8 wlan_get_second_channel_offset(int chan)
+t_u8 wlan_get_second_channel_offset(mlan_private *priv, int chan)
 {
 	t_u8 chan2Offset = SEC_CHAN_NONE;
 
+	/* Special Case: 20Mhz-only Channel */
+	if (priv->adapter->region_code != COUNTRY_CODE_US && chan == 165)
+		return chan2Offset;
+
 	switch (chan) {
 	case 36:
 	case 44:
@@ -2221,6 +2326,8 @@ t_u8 wlan_get_second_channel_offset(int chan)
 	case 140:
 	case 149:
 	case 157:
+	case 165:
+	case 173:
 		chan2Offset = SEC_CHAN_ABOVE;
 		break;
 	case 40:
@@ -2235,12 +2342,10 @@ t_u8 wlan_get_second_channel_offset(int chan)
 	case 144:
 	case 153:
 	case 161:
+	case 169:
+	case 177:
 		chan2Offset = SEC_CHAN_BELOW;
 		break;
-	case 165:
-		/* Special Case: 20Mhz-only Channel */
-		chan2Offset = SEC_CHAN_NONE;
-		break;
 	}
 	return chan2Offset;
 }
@@ -2286,7 +2391,8 @@ t_u8 wlan_validate_chan_offset(mlan_private *pmpriv, t_u16 band, t_u32 chan,
 				if ((chan == 8) || (chan == 9))
 					chan_offset = SEC_CHAN_BELOW;
 		} else if (band & BAND_AN)
-			chan_offset = wlan_get_second_channel_offset(chan);
+			chan_offset =
+				wlan_get_second_channel_offset(pmpriv, chan);
 	}
 	return chan_offset;
 }
@@ -2387,7 +2493,6 @@ int wlan_cmd_append_11n_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	MrvlIETypes_2040BSSCo_t *p2040_bss_co;
 	MrvlIETypes_ExtCap_t *pext_cap;
 	t_u32 usr_dot_11n_dev_cap, orig_usr_dot_11n_dev_cap = 0;
-	t_u32 usr_vht_cap_info;
 	t_u8 usr_dot_11ac_bw;
 	int ret_len = 0;
 
@@ -2412,10 +2517,6 @@ int wlan_cmd_append_11n_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 	else
 		usr_dot_11n_dev_cap = pmpriv->usr_dot_11n_dev_cap_bg;
 
-	if (pbss_desc->bss_band & BAND_A)
-		usr_vht_cap_info = pmpriv->usr_dot_11ac_dev_cap_a;
-	else
-		usr_vht_cap_info = pmpriv->usr_dot_11ac_dev_cap_bg;
 	if (pmpriv->bss_mode == MLAN_BSS_MODE_IBSS)
 		usr_dot_11ac_bw = BW_FOLLOW_VHTCAP;
 	else
@@ -2474,7 +2575,7 @@ int wlan_cmd_append_11n_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 		pchan_list->chan_scan_param[0].chan_number =
 			pbss_desc->pht_info->ht_info.pri_chan;
 		pchan_list->chan_scan_param[0].bandcfg.chanBand =
-			wlan_band_to_radio_type((t_u8)pbss_desc->bss_band);
+			wlan_band_to_radio_type(pbss_desc->bss_band);
 		/* support the VHT if the network to be join has the VHT
 		 * operation */
 		if (ISSUPP_11ACENABLED(pmadapter->fw_cap_info) &&
@@ -2544,6 +2645,8 @@ int wlan_cmd_append_11n_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 			   (t_u8 *)pext_cap + sizeof(MrvlIEtypesHeader_t),
 			   (t_u8 *)&pmpriv->ext_cap, sizeof(ExtCap_t),
 			   pext_cap->header.len);
+		if (pbss_desc && pbss_desc->multi_bssid_ap)
+			SET_EXTCAP_MULTI_BSSID(pext_cap->ext_cap);
 		if (!pmadapter->ecsa_enable)
 			RESET_EXTCAP_EXT_CHANNEL_SWITCH(pext_cap->ext_cap);
 		else
@@ -2638,6 +2741,9 @@ mlan_status wlan_11n_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_11N_CFG_COEX_RX_WINSIZE:
 		status = wlan_11n_ioctl_coex_rx_winsize(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_11N_CFG_TX_AGGR_CTRL:
+		status = wlan_11n_ioctl_txaggrctrl(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_11N_CFG_IBSS_AMPDU_PARAM:
 		status = wlan_11n_ioctl_ibss_ampdu_param(pmadapter, pioctl_req);
 		break;
@@ -2790,7 +2896,7 @@ void wlan_11n_create_txbastream_tbl(mlan_private *priv, t_u8 *ra, int tid,
 
 	if (pmadapter->callbacks.moal_malloc(
 		    pmadapter->pmoal_handle, sizeof(TxBAStreamTbl),
-		    MLAN_MEM_DEF, (t_u8 **)&new_node)) {
+		    MLAN_MEM_DEF | MLAN_MEM_FLAG_ATOMIC, (t_u8 **)&new_node)) {
 		PRINTM(MERROR,
 		       "wlan_11n_create_txbastream_tbl Failed to allocate new_node\n");
 		LEAVE();
@@ -2967,6 +3073,7 @@ int wlan_get_rxreorder_tbl(mlan_private *priv, rx_reorder_tbl *buf)
 			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 		ptbl->start_win = rx_reorder_tbl_ptr->start_win;
 		ptbl->win_size = rx_reorder_tbl_ptr->win_size;
+
 		ptbl->amsdu = rx_reorder_tbl_ptr->amsdu;
 		for (i = 0; i < rx_reorder_tbl_ptr->win_size; ++i) {
 			if (rx_reorder_tbl_ptr->rx_reorder_ptr[i])
@@ -3024,7 +3131,7 @@ int wlan_get_txbastream_tbl(mlan_private *priv, tx_ba_stream_tbl *buf)
 		ptxtbl = ptxtbl->pnext;
 		ptbl++;
 		count++;
-		if (count >= bastream_max)
+		if (count >= (int)bastream_max)
 			break;
 	}
 	wlan_release_ralist_lock(priv);
@@ -3040,7 +3147,7 @@ int wlan_get_txbastream_tbl(mlan_private *priv, tx_ba_stream_tbl *buf)
  *
  *  @return 0--not allowed, other value allowed
  */
-t_u8 wlan_11n_bandconfig_allowed(mlan_private *pmpriv, t_u8 bss_band)
+t_u8 wlan_11n_bandconfig_allowed(mlan_private *pmpriv, t_u16 bss_band)
 {
 	if (pmpriv->bss_mode == MLAN_BSS_MODE_IBSS) {
 		if (bss_band & BAND_G)
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h
old mode 100644
new mode 100755
index 9e3de59c5..0a2a990e6
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n.h
@@ -6,7 +6,7 @@
  *    implemented in mlan_11n.c.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -65,7 +65,7 @@ mlan_status wlan_cmd_tx_bf_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 mlan_status wlan_ret_tx_bf_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			       mlan_ioctl_req *pioctl_buf);
 #ifdef STA_SUPPORT
-t_u8 wlan_11n_bandconfig_allowed(mlan_private *pmpriv, t_u8 bss_band);
+t_u8 wlan_11n_bandconfig_allowed(mlan_private *pmpriv, t_u16 bss_band);
 /** Append the 802_11N tlv */
 int wlan_cmd_append_11n_tlv(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 			    t_u8 **ppbuffer);
@@ -123,7 +123,7 @@ mlan_status wlan_cmd_amsdu_aggr_ctrl(mlan_private *priv,
 t_u8 wlan_validate_chan_offset(mlan_private *pmpriv, t_u16 band, t_u32 chan,
 			       t_u8 chan_bw);
 /** get channel offset */
-t_u8 wlan_get_second_channel_offset(int chan);
+t_u8 wlan_get_second_channel_offset(mlan_private *priv, int chan);
 
 void wlan_update_11n_cap(mlan_private *pmpriv);
 
@@ -234,6 +234,11 @@ static INLINE void reset_station_ampdu(mlan_private *priv, t_u8 tid, t_u8 *ra)
 static INLINE t_u8 wlan_is_ampdu_allowed(mlan_private *priv, raListTbl *ptr,
 					 int tid)
 {
+	if (ptr->is_tdls_link)
+		return is_station_ampdu_allowed(priv, ptr, tid);
+	if (priv->adapter->tdls_status != TDLS_NOT_SETUP && !priv->txaggrctrl)
+		return MFALSE;
+
 	if ((!priv->is_data_rate_auto) && IS_BG_RATE)
 		return MFALSE;
 #ifdef UAP_SUPPORT
@@ -266,12 +271,8 @@ static INLINE void wlan_update_station_del_ba_count(mlan_private *priv,
 static INLINE void wlan_update_del_ba_count(mlan_private *priv, raListTbl *ptr)
 {
 	t_s8 rssi;
-#ifdef UAP_802_11N
-#ifdef UAP_SUPPORT
-	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)
+	if (ptr->is_tdls_link)
 		return wlan_update_station_del_ba_count(priv, ptr);
-#endif /* UAP_SUPPORT */
-#endif /* UAP_802_11N */
 	rssi = priv->snr - priv->nf;
 	if (rssi > BA_RSSI_HIGH_THRESHOLD)
 		ptr->del_ba_count = 0;
@@ -304,6 +305,11 @@ static INLINE t_u8 wlan_is_amsdu_allowed(mlan_private *priv, raListTbl *ptr,
 		}
 	}
 #endif /* UAP_SUPPORT */
+	if (ptr->is_tdls_link)
+		return (priv->aggr_prio_tbl[tid].amsdu !=
+			BA_STREAM_NOT_ALLOWED) ?
+			       MTRUE :
+			       MFALSE;
 #define TXRATE_BITMAP_INDEX_MCS0_7 2
 	return ((priv->aggr_prio_tbl[tid].amsdu != BA_STREAM_NOT_ALLOWED) &&
 		((priv->is_data_rate_auto) ||
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c
old mode 100644
new mode 100755
index 1997523af..11511665a
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.c
@@ -3,7 +3,7 @@
  *  @brief This file contains functions for 11n Aggregation.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -120,13 +120,13 @@ static void wlan_11n_form_amsdu_txpd(mlan_private *priv, mlan_buffer *mbuf)
 	 * Original priority has been overwritten
 	 */
 	ptx_pd->priority = (t_u8)mbuf->priority;
-	ptx_pd->pkt_delay_2ms =
-		wlan_wmm_compute_driver_packet_delay(priv, mbuf);
 	ptx_pd->bss_num = GET_BSS_NUM(priv);
 	ptx_pd->bss_type = priv->bss_type;
 	/* Always zero as the data is followed by TxPD */
 	ptx_pd->tx_pkt_offset = sizeof(TxPD);
 	ptx_pd->tx_pkt_type = PKT_TYPE_AMSDU;
+	if (mbuf->flags & MLAN_BUF_FLAG_TDLS)
+		ptx_pd->flags = MRVDRV_TxPD_FLAGS_TDLS_PACKET;
 	if (ptx_pd->tx_control == 0)
 		/* TxCtrl set by user or default */
 		ptx_pd->tx_control = priv->pkt_tx_ctrl;
@@ -154,6 +154,9 @@ static INLINE void wlan_11n_update_pktlen_amsdu_txpd(mlan_private *priv,
 	ptx_pd = (TxPD *)mbuf->pbuf;
 	ptx_pd->tx_pkt_length =
 		(t_u16)wlan_cpu_to_le16(mbuf->data_len - sizeof(TxPD));
+	ptx_pd->pkt_delay_2ms =
+		wlan_wmm_compute_driver_packet_delay(priv, mbuf);
+
 #ifdef STA_SUPPORT
 	if ((GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) &&
 	    (priv->adapter->pps_uapsd_mode)) {
@@ -227,6 +230,13 @@ mlan_status wlan_11n_deaggregate_pkt(mlan_private *priv, pmlan_buffer pmbuf)
 						      0x00, 0x00, 0x00};
 	t_u8 hdr_len = sizeof(Eth803Hdr_t);
 	t_u8 eapol_type[2] = {0x88, 0x8e};
+	t_u8 tdls_action_type[2] = {0x89, 0x0d};
+	t_u32 in_ts_sec, in_ts_usec;
+	t_u32 out_ts_sec, out_ts_usec;
+	t_u32 in_copy_ts_sec, in_copy_ts_usec;
+	t_u32 out_copy_ts_sec, out_copy_ts_usec;
+	t_u32 copy_delay = 0;
+	t_u32 delay = 0;
 
 	ENTER();
 
@@ -250,16 +260,41 @@ mlan_status wlan_11n_deaggregate_pkt(mlan_private *priv, pmlan_buffer pmbuf)
 		}
 	}
 #endif
-	if (total_pkt_len > max_rx_data_size) {
+	if (total_pkt_len > (int)max_rx_data_size) {
 		PRINTM(MERROR,
 		       "Total packet length greater than tx buffer"
 		       " size %d\n",
 		       total_pkt_len);
 		goto done;
 	}
-
+	if (pmadapter->tp_state_on)
+		pmadapter->callbacks.moal_get_system_time(
+			pmadapter->pmoal_handle, &in_ts_sec, &in_ts_usec);
 	pmbuf->use_count = wlan_11n_get_num_aggrpkts(data, total_pkt_len);
 
+	// rx_trace 7
+	if (pmadapter->tp_state_on) {
+		pmadapter->callbacks.moal_tp_accounting(
+			pmadapter->pmoal_handle, pmbuf, 7 /*RX_DROP_P3*/);
+		pmadapter->callbacks.moal_tp_accounting_rx_param(
+			pmadapter->pmoal_handle, 4, pmbuf->use_count);
+	}
+	if (pmadapter->tp_state_drop_point == 7 /*RX_DROP_P3*/)
+		goto done;
+	prx_pkt = (RxPacketHdr_t *)data;
+	if (pmbuf->pdesc && !memcmp(pmadapter, prx_pkt->eth803_hdr.dest_addr,
+				    priv->curr_addr, MLAN_MAC_ADDR_LENGTH)) {
+		if (pmadapter->callbacks.moal_recv_amsdu_packet) {
+			ret = pmadapter->callbacks.moal_recv_amsdu_packet(
+				pmadapter->pmoal_handle, pmbuf);
+			if (ret == MLAN_STATUS_PENDING) {
+				priv->msdu_in_rx_amsdu_cnt += pmbuf->use_count;
+				priv->amsdu_rx_cnt++;
+				return ret;
+			}
+			goto done;
+		}
+	}
 	while (total_pkt_len >= hdr_len) {
 		prx_pkt = (RxPacketHdr_t *)data;
 		/* Length will be in network format, change it to host */
@@ -304,12 +339,27 @@ mlan_status wlan_11n_deaggregate_pkt(mlan_private *priv, pmlan_buffer pmbuf)
 		daggr_mbuf->data_len = pkt_len;
 		daggr_mbuf->in_ts_sec = pmbuf->in_ts_sec;
 		daggr_mbuf->in_ts_usec = pmbuf->in_ts_usec;
+		daggr_mbuf->extra_ts_sec = pmbuf->extra_ts_sec;
+		daggr_mbuf->extra_ts_usec = pmbuf->extra_ts_usec;
 		daggr_mbuf->pparent = pmbuf;
 		daggr_mbuf->priority = pmbuf->priority;
+		if (pmadapter->tp_state_on)
+			pmadapter->callbacks.moal_get_system_time(
+				pmadapter->pmoal_handle, &in_copy_ts_sec,
+				&in_copy_ts_usec);
 		memcpy_ext(pmadapter,
 			   daggr_mbuf->pbuf + daggr_mbuf->data_offset, data,
 			   pkt_len, daggr_mbuf->data_len);
-
+		if (pmadapter->tp_state_on) {
+			pmadapter->callbacks.moal_get_system_time(
+				pmadapter->pmoal_handle, &out_copy_ts_sec,
+				&out_copy_ts_usec);
+			copy_delay +=
+				(t_s32)(out_copy_ts_sec - in_copy_ts_sec) *
+				1000000;
+			copy_delay +=
+				(t_s32)(out_copy_ts_usec - in_copy_ts_usec);
+		}
 #ifdef UAP_SUPPORT
 		if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
 			ret = wlan_uap_recv_packet(priv, daggr_mbuf);
@@ -334,6 +384,20 @@ mlan_status wlan_11n_deaggregate_pkt(mlan_private *priv, pmlan_buffer pmbuf)
 				data += pkt_len + pad;
 				continue;
 			}
+			/**process tdls packet*/
+			if (!memcmp(pmadapter,
+				    daggr_mbuf->pbuf + daggr_mbuf->data_offset +
+					    MLAN_ETHER_PKT_TYPE_OFFSET,
+				    tdls_action_type,
+				    sizeof(tdls_action_type))) {
+				PRINTM(MEVENT,
+				       "Recevie AMSDU TDLS action frame\n");
+				wlan_process_tdls_action_frame(
+					priv,
+					daggr_mbuf->pbuf +
+						daggr_mbuf->data_offset,
+					daggr_mbuf->data_len);
+			}
 
 			ret = pmadapter->callbacks.moal_recv_packet(
 				pmadapter->pmoal_handle, daggr_mbuf);
@@ -356,6 +420,14 @@ mlan_status wlan_11n_deaggregate_pkt(mlan_private *priv, pmlan_buffer pmbuf)
 
 		data += pkt_len + pad;
 	}
+	if (pmadapter->tp_state_on) {
+		pmadapter->callbacks.moal_get_system_time(
+			pmadapter->pmoal_handle, &out_ts_sec, &out_ts_usec);
+		delay += (t_s32)(out_ts_sec - in_ts_sec) * 1000000;
+		delay += (t_s32)(out_ts_usec - in_ts_usec);
+		pmadapter->callbacks.moal_amsdu_tp_accounting(
+			pmadapter->pmoal_handle, delay, copy_delay);
+	}
 
 done:
 	priv->msdu_in_rx_amsdu_cnt += pmbuf->use_count;
@@ -395,6 +467,7 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 	TxPD *ptx_pd = MNULL;
 #endif
 	t_u32 max_amsdu_size = MIN(pra_list->max_amsdu, pmadapter->tx_buf_size);
+	t_u32 msdu_in_tx_amsdu_cnt = 0;
 	ENTER();
 
 	PRINTM(MDAT_D, "Handling Aggr packet\n");
@@ -402,9 +475,9 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 	pmbuf_src = (pmlan_buffer)util_peek_list(
 		pmadapter->pmoal_handle, &pra_list->buf_head, MNULL, MNULL);
 	if (pmbuf_src) {
-		pmbuf_aggr = wlan_alloc_mlan_buffer(pmadapter,
-						    pmadapter->tx_buf_size, 0,
-						    MOAL_MALLOC_BUFFER);
+		pmbuf_aggr = wlan_alloc_mlan_buffer(
+			pmadapter, pmadapter->tx_buf_size, 0,
+			MOAL_MALLOC_BUFFER | MOAL_MEM_FLAG_ATOMIC);
 		if (!pmbuf_aggr) {
 			PRINTM(MERROR, "Error allocating mlan_buffer\n");
 			pmadapter->callbacks.moal_spin_unlock(
@@ -422,6 +495,10 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 		pmbuf_aggr->data_offset = 0;
 		pmbuf_aggr->in_ts_sec = pmbuf_src->in_ts_sec;
 		pmbuf_aggr->in_ts_usec = pmbuf_src->in_ts_usec;
+		pmbuf_aggr->extra_ts_sec = pmbuf_src->extra_ts_sec;
+		pmbuf_aggr->extra_ts_usec = pmbuf_src->extra_ts_usec;
+		if (pmbuf_src->flags & MLAN_BUF_FLAG_TDLS)
+			pmbuf_aggr->flags |= MLAN_BUF_FLAG_TDLS;
 		if (pmbuf_src->flags & MLAN_BUF_FLAG_TCP_ACK)
 			pmbuf_aggr->flags |= MLAN_BUF_FLAG_TCP_ACK;
 
@@ -445,7 +522,10 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 			(pmlan_buffer)util_dequeue_list(pmadapter->pmoal_handle,
 							&pra_list->buf_head,
 							MNULL, MNULL);
-
+		/* Collects TP statistics */
+		if (pmadapter->tp_state_on && (pkt_size > sizeof(TxPD)))
+			pmadapter->callbacks.moal_tp_accounting(
+				pmadapter->pmoal_handle, pmbuf_src, 3);
 		pra_list->total_pkts--;
 
 		/* decrement for every PDU taken from the list */
@@ -484,6 +564,7 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 						     &pra_list->buf_head, MNULL,
 						     MNULL);
 		priv->msdu_in_tx_amsdu_cnt++;
+		msdu_in_tx_amsdu_cnt++;
 	}
 
 	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
@@ -497,9 +578,21 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 	pmbuf_aggr->pbuf = data - headroom;
 	tx_param.next_pkt_len =
 		((pmbuf_src) ? pmbuf_src->data_len + sizeof(TxPD) : 0);
+	/* Collects TP statistics */
+	if (pmadapter->tp_state_on) {
+		pmadapter->callbacks.moal_tp_accounting(pmadapter->pmoal_handle,
+							pmbuf_aggr, 4);
+		pmadapter->callbacks.moal_tp_accounting_rx_param(
+			pmadapter->pmoal_handle, 5, msdu_in_tx_amsdu_cnt);
+	}
 
-	ret = pmadapter->ops.host_to_card(priv, MLAN_TYPE_DATA, pmbuf_aggr,
-					  &tx_param);
+	/* Drop Tx packets at drop point 4 */
+	if (pmadapter->tp_state_drop_point == 4) {
+		wlan_write_data_complete(pmadapter, pmbuf_aggr, ret);
+		goto exit;
+	} else
+		ret = pmadapter->ops.host_to_card(priv, MLAN_TYPE_DATA,
+						  pmbuf_aggr, &tx_param);
 	switch (ret) {
 #ifdef USB
 	case MLAN_STATUS_PRESOURCE:
@@ -580,5 +673,5 @@ int wlan_11n_aggregate_pkt(mlan_private *priv, raListTbl *pra_list,
 
 exit:
 	LEAVE();
-	return pkt_size + headroom;
+	return MIN((pkt_size + headroom), INT_MAX);
 }
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h
old mode 100644
new mode 100755
index 96a278312..922d4a8ca
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_aggr.h
@@ -4,7 +4,7 @@
  *  of 11n aggregation functionalities
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.c
old mode 100644
new mode 100755
index 68dbd07d9..023700e14
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.c
@@ -4,7 +4,7 @@
  *  driver.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -79,10 +79,12 @@ static mlan_status wlan_11n_dispatch_amsdu_pkt(mlan_private *priv,
  *
  *  @param priv     A pointer to mlan_private
  *  @param payload  A pointer to rx packet payload
+ *  @param rx_reor_tbl_ptr       pointer to RxReorderTbl
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-static mlan_status wlan_11n_dispatch_pkt(t_void *priv, t_void *payload)
+static mlan_status wlan_11n_dispatch_pkt(t_void *priv, t_void *payload,
+					 RxReorderTbl *rx_reor_tbl_ptr)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 #ifdef STA_SUPPORT
@@ -93,6 +95,7 @@ static mlan_status wlan_11n_dispatch_pkt(t_void *priv, t_void *payload)
 		LEAVE();
 		return ret;
 	}
+
 #ifdef UAP_SUPPORT
 	if (GET_BSS_ROLE((mlan_private *)priv) == MLAN_BSS_ROLE_UAP) {
 		if (MLAN_STATUS_SUCCESS ==
@@ -131,13 +134,14 @@ static mlan_status wlan_11n_dispatch_pkt(t_void *priv, t_void *payload)
 static void mlan_11n_rxreorder_timer_restart(pmlan_adapter pmadapter,
 					     RxReorderTbl *rx_reor_tbl_ptr)
 {
-	t_u16 min_flush_time = 0;
+	t_u16 min_flush_time = DEF_FLUSH_TIME_AC_BE_BK;
+	mlan_wmm_ac_e wmm_ac;
 	ENTER();
 
-	if (rx_reor_tbl_ptr->win_size >= 32)
-		min_flush_time = MIN_FLUSH_TIMER_15_MS;
-	else
-		min_flush_time = MIN_FLUSH_TIMER_MS;
+	wmm_ac = wlan_wmm_convert_tos_to_ac(pmadapter, rx_reor_tbl_ptr->tid);
+	if ((WMM_AC_VI == wmm_ac) || (WMM_AC_VO == wmm_ac)) {
+		min_flush_time = DEF_FLUSH_TIME_AC_VI_VO;
+	}
 
 	if (rx_reor_tbl_ptr->timer_context.timer_is_set)
 		pmadapter->callbacks.moal_stop_timer(
@@ -146,7 +150,7 @@ static void mlan_11n_rxreorder_timer_restart(pmlan_adapter pmadapter,
 
 	pmadapter->callbacks.moal_start_timer(
 		pmadapter->pmoal_handle, rx_reor_tbl_ptr->timer_context.timer,
-		MFALSE, (rx_reor_tbl_ptr->win_size * min_flush_time));
+		MFALSE, min_flush_time);
 
 	rx_reor_tbl_ptr->timer_context.timer_is_set = MTRUE;
 	LEAVE();
@@ -165,7 +169,7 @@ static void mlan_11n_rxreorder_timer_restart(pmlan_adapter pmadapter,
 static mlan_status wlan_11n_dispatch_pkt_until_start_win(
 	t_void *priv, RxReorderTbl *rx_reor_tbl_ptr, int start_win)
 {
-	int no_pkt_to_send, i, xchg;
+	t_u32 no_pkt_to_send, i, xchg;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	void *rx_tmp_ptr = MNULL;
 	mlan_private *pmpriv = (mlan_private *)priv;
@@ -188,7 +192,8 @@ static mlan_status wlan_11n_dispatch_pkt_until_start_win(
 		pmpriv->adapter->callbacks.moal_spin_unlock(
 			pmpriv->adapter->pmoal_handle, pmpriv->rx_pkt_lock);
 		if (rx_tmp_ptr)
-			wlan_11n_dispatch_pkt(priv, rx_tmp_ptr);
+			wlan_11n_dispatch_pkt(priv, rx_tmp_ptr,
+					      rx_reor_tbl_ptr);
 	}
 
 	pmpriv->adapter->callbacks.moal_spin_lock(pmpriv->adapter->pmoal_handle,
@@ -204,6 +209,9 @@ static mlan_status wlan_11n_dispatch_pkt_until_start_win(
 		rx_reor_tbl_ptr->rx_reorder_ptr[no_pkt_to_send + i] = MNULL;
 	}
 
+	/* clear the bits of reorder bitmap that has been dispatched */
+	rx_reor_tbl_ptr->bitmap = rx_reor_tbl_ptr->bitmap >> no_pkt_to_send;
+
 	rx_reor_tbl_ptr->start_win = start_win;
 	pmpriv->adapter->callbacks.moal_spin_unlock(
 		pmpriv->adapter->pmoal_handle, pmpriv->rx_pkt_lock);
@@ -264,7 +272,7 @@ static mlan_status wlan_11n_scan_and_dispatch(t_void *priv,
 		rx_reor_tbl_ptr->rx_reorder_ptr[i] = MNULL;
 		pmpriv->adapter->callbacks.moal_spin_unlock(
 			pmpriv->adapter->pmoal_handle, pmpriv->rx_pkt_lock);
-		wlan_11n_dispatch_pkt(priv, rx_tmp_ptr);
+		wlan_11n_dispatch_pkt(priv, rx_tmp_ptr, rx_reor_tbl_ptr);
 	}
 
 	pmpriv->adapter->callbacks.moal_spin_lock(pmpriv->adapter->pmoal_handle,
@@ -282,6 +290,9 @@ static mlan_status wlan_11n_scan_and_dispatch(t_void *priv,
 		}
 	}
 
+	/* clear the bits of reorder bitmap that has been dispatched */
+	rx_reor_tbl_ptr->bitmap = rx_reor_tbl_ptr->bitmap >> i;
+
 	rx_reor_tbl_ptr->start_win =
 		(rx_reor_tbl_ptr->start_win + i) & (MAX_TID_VALUE - 1);
 
@@ -503,15 +514,22 @@ static t_void wlan_11n_create_rxreorder_tbl(mlan_private *priv, t_u8 *ta,
 		PRINTM(MINFO, "UAP/ADHOC:last_seq=%d start_win=%d\n", last_seq,
 		       new_node->start_win);
 	} else {
-		last_seq = priv->rx_seq[tid];
+		sta_ptr = wlan_get_station_entry(priv, ta);
+		if (sta_ptr)
+			last_seq = sta_ptr->rx_seq[tid];
+		else
+			last_seq = priv->rx_seq[tid];
 	}
 	new_node->last_seq = last_seq;
 	new_node->win_size = win_size;
 	new_node->force_no_drop = MFALSE;
 	new_node->check_start_win = MTRUE;
+	new_node->bitmap = 0;
+
 	new_node->ba_status = BA_STREAM_SETUP_INPROGRESS;
 	for (i = 0; i < win_size; ++i)
 		new_node->rx_reorder_ptr[i] = MNULL;
+
 	mlan_block_rx_process(pmadapter, MFALSE);
 	LEAVE();
 }
@@ -603,8 +621,12 @@ mlan_status wlan_cmd_11n_addba_req(mlan_private *priv, HostCmd_DS_COMMAND *cmd,
  *
  *  @return            MTRUE/MFALSE
  */
-t_u8 wlan_is_addba_reject(mlan_private *priv, t_u8 tid)
+static t_u8 wlan_is_addba_reject(mlan_private *priv, t_u8 tid)
 {
+	if (tid >= MAX_NUM_TID) {
+		PRINTM(MERROR, "Wrong TID =%d", tid);
+		return ADDBA_RSP_STATUS_REJECT;
+	}
 #ifdef STA_SUPPORT
 #endif
 	return priv->addba_reject[tid];
@@ -627,7 +649,7 @@ mlan_status wlan_cmd_11n_addba_rspgen(mlan_private *priv,
 	HostCmd_DS_11N_ADDBA_REQ *pevt_addba_req =
 		(HostCmd_DS_11N_ADDBA_REQ *)pdata_buf;
 	t_u8 tid = 0;
-	int win_size = 0;
+	t_u32 win_size = 0;
 
 	ENTER();
 
@@ -672,21 +694,26 @@ mlan_status wlan_cmd_11n_addba_rspgen(mlan_private *priv,
 	else
 		padd_ba_rsp->status_code =
 			wlan_cpu_to_le16(ADDBA_RSP_STATUS_ACCEPT);
+
+	win_size = (padd_ba_rsp->block_ack_param_set &
+		    BLOCKACKPARAM_WINSIZE_MASK) >>
+		   BLOCKACKPARAM_WINSIZE_POS;
+
 	padd_ba_rsp->block_ack_param_set &= ~BLOCKACKPARAM_WINSIZE_MASK;
 	if (!priv->add_ba_param.rx_amsdu)
 		/* We do not support AMSDU inside AMPDU, hence reset the bit */
 		padd_ba_rsp->block_ack_param_set &=
 			~BLOCKACKPARAM_AMSDU_SUPP_MASK;
 
-	padd_ba_rsp->block_ack_param_set |=
-		(priv->add_ba_param.rx_win_size << BLOCKACKPARAM_WINSIZE_POS);
-	win_size = (padd_ba_rsp->block_ack_param_set &
-		    BLOCKACKPARAM_WINSIZE_MASK) >>
-		   BLOCKACKPARAM_WINSIZE_POS;
+	/*cert failure observed due to BA setup failure
+	 if win_size requested from client is 0 */
+	if (win_size)
+		win_size = MIN(win_size, priv->add_ba_param.rx_win_size);
+	else
+		win_size = priv->add_ba_param.rx_win_size;
 
-	if (win_size == 0)
-		padd_ba_rsp->status_code =
-			wlan_cpu_to_le16(ADDBA_RSP_STATUS_DECLINED);
+	padd_ba_rsp->block_ack_param_set |= win_size
+					    << BLOCKACKPARAM_WINSIZE_POS;
 
 	padd_ba_rsp->block_ack_param_set =
 		wlan_cpu_to_le16(padd_ba_rsp->block_ack_param_set);
@@ -759,7 +786,7 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 		wlan_11n_get_rxreorder_tbl((mlan_private *)priv, tid, ta);
 	if (!rx_reor_tbl_ptr || rx_reor_tbl_ptr->win_size <= 1) {
 		if (pkt_type != PKT_TYPE_BAR)
-			wlan_11n_dispatch_pkt(priv, payload);
+			wlan_11n_dispatch_pkt(priv, payload, rx_reor_tbl_ptr);
 
 		LEAVE();
 		return ret;
@@ -770,7 +797,7 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 			wlan_start_flush_data(priv, rx_reor_tbl_ptr);
 		}
 		if ((pkt_type == PKT_TYPE_AMSDU) && !rx_reor_tbl_ptr->amsdu) {
-			wlan_11n_dispatch_pkt(priv, payload);
+			wlan_11n_dispatch_pkt(priv, payload, rx_reor_tbl_ptr);
 			LEAVE();
 			return ret;
 		}
@@ -797,7 +824,8 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 							seq_num;
 						if (pkt_type != PKT_TYPE_BAR)
 							wlan_11n_dispatch_pkt(
-								priv, payload);
+								priv, payload,
+								rx_reor_tbl_ptr);
 					}
 					LEAVE();
 					return ret;
@@ -946,6 +974,8 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 				rx_reor_tbl_ptr
 					->rx_reorder_ptr[seq_num - start_win] =
 					payload;
+				MLAN_SET_BIT(rx_reor_tbl_ptr->bitmap,
+					     seq_num - start_win);
 			} else { /* Wrap condition */
 				if (rx_reor_tbl_ptr
 					    ->rx_reorder_ptr[(seq_num +
@@ -959,6 +989,9 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 					->rx_reorder_ptr[(seq_num +
 							  (MAX_TID_VALUE)) -
 							 start_win] = payload;
+				MLAN_SET_BIT(rx_reor_tbl_ptr->bitmap,
+					     (seq_num + (MAX_TID_VALUE)) -
+						     start_win);
 			}
 		}
 
@@ -974,11 +1007,20 @@ mlan_status mlan_11n_rxreorder_pkt(void *priv, t_u16 seq_num, t_u16 tid,
 	}
 
 done:
-	if (!rx_reor_tbl_ptr->timer_context.timer_is_set ||
-	    (prev_start_win != rx_reor_tbl_ptr->start_win)) {
-		mlan_11n_rxreorder_timer_restart(pmadapter, rx_reor_tbl_ptr);
+	if (rx_reor_tbl_ptr->bitmap == 0) {
+		if (rx_reor_tbl_ptr->timer_context.timer_is_set) {
+			pmadapter->callbacks.moal_stop_timer(
+				pmadapter->pmoal_handle,
+				rx_reor_tbl_ptr->timer_context.timer);
+			rx_reor_tbl_ptr->timer_context.timer_is_set = MFALSE;
+		}
+	} else {
+		if (!rx_reor_tbl_ptr->timer_context.timer_is_set ||
+		    (prev_start_win != rx_reor_tbl_ptr->start_win)) {
+			mlan_11n_rxreorder_timer_restart(pmadapter,
+							 rx_reor_tbl_ptr);
+		}
 	}
-
 	LEAVE();
 	return ret;
 }
@@ -1142,6 +1184,7 @@ void wlan_11n_ba_stream_timeout(mlan_private *priv,
 				HostCmd_DS_11N_BATIMEOUT *event)
 {
 	HostCmd_DS_11N_DELBA delba;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
@@ -1155,7 +1198,10 @@ void wlan_11n_ba_stream_timeout(mlan_private *priv,
 	delba.del_ba_param_set |= (t_u16)event->origninator
 				  << DELBA_INITIATOR_POS;
 	delba.reason_code = REASON_CODE_STA_TIMEOUT;
-	wlan_prepare_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, MNULL, &delba);
+	ret = wlan_prepare_cmd(priv, HostCmd_CMD_11N_DELBA, 0, 0, MNULL,
+			       &delba);
+	if (ret)
+		PRINTM(MERROR, "Failed to send cmd to FW\n");
 
 	LEAVE();
 	return;
@@ -1206,7 +1252,7 @@ void wlan_11n_rxba_sync_event(mlan_private *priv, t_u8 *event_buf, t_u16 len)
 	ENTER();
 
 	DBG_HEXDUMP(MEVT_D, "RXBA_SYNC_EVT", event_buf, len);
-	while (tlv_buf_left >= sizeof(MrvlIEtypes_RxBaSync_t)) {
+	while (tlv_buf_left >= (int)sizeof(MrvlIEtypes_RxBaSync_t)) {
 		tlv_type = wlan_le16_to_cpu(tlv_rxba->header.type);
 		tlv_len = wlan_le16_to_cpu(tlv_rxba->header.len);
 		if (tlv_type != TLV_TYPE_RXBA_SYNC) {
@@ -1293,7 +1339,7 @@ void wlan_cleanup_reorder_tbl(mlan_private *priv, t_u8 *ta)
  *
  *  @return        N/A
  */
-void wlan_set_rxreorder_tbl_no_drop_flag(mlan_private *priv, t_u8 flag)
+static void wlan_set_rxreorder_tbl_no_drop_flag(mlan_private *priv, t_u8 flag)
 {
 	RxReorderTbl *rx_reor_tbl_ptr;
 
@@ -1345,7 +1391,7 @@ void wlan_update_rxreorder_tbl(pmlan_adapter pmadapter, t_u8 flag)
  *
  *  @return        N/A
  */
-void wlan_flush_priv_rxreorder_tbl(mlan_private *priv)
+static void wlan_flush_priv_rxreorder_tbl(mlan_private *priv)
 {
 	RxReorderTbl *rx_reor_tbl_ptr;
 
@@ -1399,9 +1445,10 @@ void wlan_flush_rxreorder_tbl(pmlan_adapter pmadapter)
  *
  *  @return             N/A
  */
-void wlan_update_ampdu_rxwinsize(pmlan_adapter pmadapter, t_u8 coex_flag)
+static void wlan_update_ampdu_rxwinsize(pmlan_adapter pmadapter, t_u8 coex_flag)
 {
 	t_u8 i;
+	t_u8 j;
 	t_u32 rx_win_size = 0;
 	pmlan_private priv = MNULL;
 
@@ -1431,7 +1478,9 @@ void wlan_update_ampdu_rxwinsize(pmlan_adapter pmadapter, t_u8 coex_flag)
 					priv->add_ba_param.rx_win_size =
 						MLAN_UAP_COEX_AMPDU_DEF_RXWINSIZE;
 #endif
-
+				priv->add_ba_param.rx_win_size =
+					MIN(priv->add_ba_param.rx_win_size,
+					    priv->user_rxwinsize);
 			} else {
 				priv->add_ba_param.rx_win_size =
 					priv->user_rxwinsize;
@@ -1442,8 +1491,8 @@ void wlan_update_ampdu_rxwinsize(pmlan_adapter pmadapter, t_u8 coex_flag)
 					pmadapter->coex_rx_win_size;
 			if (rx_win_size != priv->add_ba_param.rx_win_size) {
 				if (priv->media_connected == MTRUE) {
-					for (i = 0; i < MAX_NUM_TID; i++)
-						wlan_11n_delba(priv, i);
+					for (j = 0; j < MAX_NUM_TID; j++)
+						wlan_11n_delba(priv, j);
 					wlan_recv_event(
 						priv,
 						MLAN_EVENT_ID_DRV_DEFER_HANDLING,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.h
old mode 100644
new mode 100755
index 7cab4350b..d409e852f
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_11n_rxreorder.h
@@ -4,7 +4,7 @@
  *  of 11n RxReordering functionalities
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c
old mode 100644
new mode 100755
index 6ad3cca77..e9be8524d
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cfp.c
@@ -5,7 +5,7 @@
  *  related code
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -32,6 +32,7 @@
 #include "mlan_fw.h"
 #include "mlan_join.h"
 #include "mlan_main.h"
+#include "mlan_11h.h"
 
 /********************************************************
  *			Local Variables
@@ -48,10 +49,6 @@
 /** 200mW */
 #define WLAN_TX_PWR_JP_A_DEFAULT 23
 /** 100mW */
-#define WLAN_TX_PWR_FR_100MW 20
-/** 10mW */
-#define WLAN_TX_PWR_FR_10MW 10
-/** 100mW */
 #define WLAN_TX_PWR_EMEA_DEFAULT 20
 /** 2000mW */
 #define WLAN_TX_PWR_CN_2000MW 33
@@ -59,12 +56,6 @@
 #define WLAN_TX_PWR_200MW 23
 /** 1000mW */
 #define WLAN_TX_PWR_1000MW 30
-/** 30mW */
-#define WLAN_TX_PWR_SP_30MW 14
-/** 60mW */
-#define WLAN_TX_PWR_SP_60MW 17
-/** 25mW */
-#define WLAN_TX_PWR_25MW 14
 /** 250mW */
 #define WLAN_TX_PWR_250MW 24
 
@@ -97,15 +88,21 @@ static country_code_mapping_t country_code_mapping[] = {
 	{"IN", 0x10, 0x06}, /* India       */
 	{"MY", 0x30, 0x06}, /* Malaysia    */
 	{"NZ", 0x30, 0x30}, /* New Zeland  */
-	{"MX", 0x10, 0x07}, /* Mexico */
+	{"MX", 0x30, 0x07}, /* Mexico */
 };
 
 /** Country code for ETSI */
 static t_u8 eu_country_code_table[][COUNTRY_CODE_LEN] = {
-	"AL", "AD", "AT", "AU", "BY", "BE", "BA", "BG", "HR", "CY", "CZ", "DK",
-	"EE", "FI", "FR", "MK", "DE", "GR", "HU", "IS", "IE", "IT", "KR", "LV",
-	"LI", "LT", "LU", "MT", "MD", "MC", "ME", "NL", "NO", "PL", "RO", "RU",
-	"SM", "RS", "SI", "SK", "ES", "SE", "CH", "TR", "UA", "UK", "GB", "NZ"};
+	"AL", "AD", "AT", "AU", "BE", "BA", "BG", "HR", "CY", "CZ", "DK", "EE",
+	"FI", "FR", "MK", "DE", "GR", "HU", "IS", "IE", "IT", "LV", "LI", "LT",
+	"LU", "MT", "MD", "MC", "ME", "NL", "NO", "PL", "RO", "SM", "RS", "SI",
+	"SK", "ES", "SE", "CH", "TR", "UA", "UK", "GB", "NZ", "DZ", "AO", "AM",
+	"AW", "BH", "BD", "BT", "BO", "BQ", "BW", "VG", "BF", "BI", "KH", "CL",
+	"KM", "CG", "CD", "CW", "EG", "FO", "GF", "PF", "GE", "GI", "GP", "HK",
+	"IN", "ID", "IM", "IL", "JE", "KE", "XK", "KW", "LA", "LR", "MW", "MV",
+	"MQ", "MR", "YT", "MA", "MZ", "MM", "NA", "NC", "NE", "NG", "OM", "PS",
+	"PT", "QA", "RW", "RE", "BL", "MF", "VC", "SA", "SC", "ZA", "SZ", "SY",
+	"TZ", "TG", "TN", "AE", "VA", "EH", "YE", "ZM", "ZW"};
 
 /**
  * The structure for Channel-Frequency-Power table
@@ -122,119 +119,118 @@ typedef struct _cfp_table {
 /* Format { Channel, Frequency (MHz), MaxTxPower } */
 /** Band : 'B/G', Region: World Wide Safe */
 static chan_freq_power_t channel_freq_power_00_BG[] = {
-	{1, 2412, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{2, 2417, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{3, 2422, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{4, 2427, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{5, 2432, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{6, 2437, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{7, 2442, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{8, 2447, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{9, 2452, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{10, 2457, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{11, 2462, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0}},
-	{12, 2467, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x1f, 0}},
-	{13, 2472, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x1f, 0}}};
+	{1, 2412, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x1d, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x1d, 0, 0}}};
 /* Format { Channel, Frequency (MHz), MaxTxPower } */
 /** Band: 'B/G', Region: USA FCC/Canada IC */
 static chan_freq_power_t channel_freq_power_US_BG[] = {
-	{1, 2412, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{2, 2417, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{3, 2422, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{4, 2427, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{5, 2432, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{6, 2437, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{7, 2442, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{8, 2447, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{9, 2452, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{10, 2457, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{11, 2462, WLAN_TX_PWR_US_DEFAULT, MFALSE}};
+	{1, 2412, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x1c, 0, 0}}};
 
 /** Band: 'B/G', Region: Europe ETSI/China */
 static chan_freq_power_t channel_freq_power_EU_BG[] = {
-	{1, 2412, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{2, 2417, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{3, 2422, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{4, 2427, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{5, 2432, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{6, 2437, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{7, 2442, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{8, 2447, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{9, 2452, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{10, 2457, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{11, 2462, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{12, 2467, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{13, 2472, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE}};
+	{1, 2412, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x1c, 0, 0}}};
 
 /** Band: 'B/G', Region: Japan */
 static chan_freq_power_t channel_freq_power_JPN41_BG[] = {
-	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE}};
+	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}}};
 
 /** Band: 'B/G', Region: Japan */
 static chan_freq_power_t channel_freq_power_JPN40_BG[] = {
-	{14, 2484, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE}};
+	{14, 2484, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1d, 0, 0}}};
 
 /** Band: 'B/G', Region: Japan */
 static chan_freq_power_t channel_freq_power_JPNFE_BG[] = {
-	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MTRUE},
-	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MTRUE}};
+	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MTRUE, {0x1d, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MTRUE, {0x1d, 0, 0}}};
 
 /** Band : 'B/G', Region: Brazil */
 static chan_freq_power_t channel_freq_power_BR_BG[] = {
-	{1, 2412, WLAN_TX_PWR_1000MW, MFALSE},
-	{2, 2417, WLAN_TX_PWR_1000MW, MFALSE},
-	{3, 2422, WLAN_TX_PWR_1000MW, MFALSE},
-	{4, 2427, WLAN_TX_PWR_1000MW, MFALSE},
-	{5, 2432, WLAN_TX_PWR_1000MW, MFALSE},
-	{6, 2437, WLAN_TX_PWR_1000MW, MFALSE},
-	{7, 2442, WLAN_TX_PWR_1000MW, MFALSE},
-	{8, 2447, WLAN_TX_PWR_1000MW, MFALSE},
-	{9, 2452, WLAN_TX_PWR_1000MW, MFALSE},
-	{10, 2457, WLAN_TX_PWR_1000MW, MFALSE},
-	{11, 2462, WLAN_TX_PWR_1000MW, MFALSE},
-	{12, 2467, WLAN_TX_PWR_1000MW, MFALSE},
-	{13, 2472, WLAN_TX_PWR_1000MW, MFALSE},
-};
+	{1, 2412, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_1000MW, MFALSE, {0x1c, 0, 0}}};
 
 /** Band : 'B/G', Region: Special */
 static chan_freq_power_t channel_freq_power_SPECIAL_BG[] = {
-	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE},
-	{14, 2484, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE}};
+	{1, 2412, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{2, 2417, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{3, 2422, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{4, 2427, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{5, 2432, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{6, 2437, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{7, 2442, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{8, 2447, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{9, 2452, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{10, 2457, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{11, 2462, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{12, 2467, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{13, 2472, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}},
+	{14, 2484, WLAN_TX_PWR_JP_BG_DEFAULT, MFALSE, {0x1c, 0, 0}}};
 
 /**
  * The 2.4GHz CFP tables
@@ -299,302 +295,299 @@ static cfp_table_t cfp_table_BG[] = {
 /* Format { Channel, Frequency (MHz), MaxTxPower, DFS } */
 /** Band: 'A', Region: World Wide Safe */
 static chan_freq_power_t channel_freq_power_00_A[] = {
-	{36, 5180, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0}},
-	{40, 5200, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0}},
-	{44, 5220, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0}},
-	{48, 5240, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0}},
-	{52, 5260, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{56, 5280, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{60, 5300, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{64, 5320, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{100, 5500, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{104, 5520, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{108, 5540, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{112, 5560, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{116, 5580, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{120, 5600, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{124, 5620, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{128, 5640, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{132, 5660, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{136, 5680, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{140, 5700, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{144, 5720, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{149, 5745, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{153, 5765, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{157, 5785, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{161, 5805, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}},
-	{165, 5825, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0}}};
+	{36, 5180, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{144, 5720, WLAN_TX_PWR_00_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_00_DEFAULT, MFALSE, {0x10, 0, 0}}};
 /* Format { Channel, Frequency (MHz), MaxTxPower, DFS } */
 /** Band: 'A', Region: USA FCC */
 static chan_freq_power_t channel_freq_power_A[] = {
-	{36, 5180, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{100, 5500, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{120, 5600, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{124, 5620, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{128, 5640, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{144, 5720, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{149, 5745, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_US_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{144, 5720, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{169, 5845, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{173, 5865, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{177, 5885, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Region: Canada IC */
 static chan_freq_power_t channel_freq_power_CAN_A[] = {
-	{36, 5180, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{100, 5500, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{144, 5720, WLAN_TX_PWR_US_DEFAULT, MTRUE},
-	{149, 5745, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_US_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_US_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{144, 5720, WLAN_TX_PWR_US_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_US_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Region: Europe ETSI */
 static chan_freq_power_t channel_freq_power_EU_A[] = {
-	{36, 5180, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{100, 5500, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{120, 5600, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{124, 5620, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{128, 5640, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{149, 5745, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Region: Japan */
 static chan_freq_power_t channel_freq_power_JPN_A[] = {
-	{36, 5180, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{100, 5500, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{120, 5600, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{124, 5620, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{128, 5640, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE},
-	{144, 5720, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE}};
+	{36, 5180, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_JP_A_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{144, 5720, WLAN_TX_PWR_JP_A_DEFAULT, MTRUE, {0x13, 0, 0}}};
 
 /** Band: 'A', Region: China */
 static chan_freq_power_t channel_freq_power_CN_A[] = {
-	{36, 5180, WLAN_TX_PWR_200MW, MFALSE},
-	{40, 5200, WLAN_TX_PWR_200MW, MFALSE},
-	{44, 5220, WLAN_TX_PWR_200MW, MFALSE},
-	{48, 5240, WLAN_TX_PWR_200MW, MFALSE},
-	{52, 5260, WLAN_TX_PWR_200MW, MTRUE},
-	{56, 5280, WLAN_TX_PWR_200MW, MTRUE},
-	{60, 5300, WLAN_TX_PWR_200MW, MTRUE},
-	{64, 5320, WLAN_TX_PWR_200MW, MTRUE},
-	{149, 5745, WLAN_TX_PWR_CN_2000MW, MFALSE},
-	{153, 5765, WLAN_TX_PWR_CN_2000MW, MFALSE},
-	{157, 5785, WLAN_TX_PWR_CN_2000MW, MFALSE},
-	{161, 5805, WLAN_TX_PWR_CN_2000MW, MFALSE},
-	{165, 5825, WLAN_TX_PWR_CN_2000MW, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_CN_2000MW, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_CN_2000MW, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_CN_2000MW, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_CN_2000MW, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_CN_2000MW, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', NULL */
 static chan_freq_power_t channel_freq_power_NULL_A[] = {};
 
 /** Band: 'A', Region: Spain/Austria/Brazil */
 static chan_freq_power_t channel_freq_power_SPN2_A[] = {
-	{36, 5180, WLAN_TX_PWR_200MW, MFALSE},
-	{40, 5200, WLAN_TX_PWR_200MW, MFALSE},
-	{44, 5220, WLAN_TX_PWR_200MW, MFALSE},
-	{48, 5240, WLAN_TX_PWR_200MW, MFALSE},
-	{52, 5260, WLAN_TX_PWR_200MW, MTRUE},
-	{56, 5280, WLAN_TX_PWR_200MW, MTRUE},
-	{60, 5300, WLAN_TX_PWR_200MW, MTRUE},
-	{64, 5320, WLAN_TX_PWR_200MW, MTRUE},
-};
+	{36, 5180, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_200MW, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_200MW, MTRUE, {0x13, 0, 0}}};
 
 /** Band: 'A', Region: Brazil */
 static chan_freq_power_t channel_freq_power_BR1_A[] = {
-	{100, 5500, WLAN_TX_PWR_250MW, MTRUE},
-	{104, 5520, WLAN_TX_PWR_250MW, MTRUE},
-	{108, 5540, WLAN_TX_PWR_250MW, MTRUE},
-	{112, 5560, WLAN_TX_PWR_250MW, MTRUE},
-	{116, 5580, WLAN_TX_PWR_250MW, MTRUE},
-	{120, 5600, WLAN_TX_PWR_250MW, MTRUE},
-	{124, 5620, WLAN_TX_PWR_250MW, MTRUE},
-	{128, 5640, WLAN_TX_PWR_250MW, MTRUE},
-	{132, 5660, WLAN_TX_PWR_250MW, MTRUE},
-	{136, 5680, WLAN_TX_PWR_250MW, MTRUE},
-	{140, 5700, WLAN_TX_PWR_250MW, MTRUE},
-};
+	{100, 5500, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_250MW, MTRUE, {0x13, 0, 0}}};
 
 /** Band: 'A', Region: Brazil */
 static chan_freq_power_t channel_freq_power_BR2_A[] = {
-	{149, 5745, WLAN_TX_PWR_1000MW, MFALSE},
-	{153, 5765, WLAN_TX_PWR_1000MW, MFALSE},
-	{157, 5785, WLAN_TX_PWR_1000MW, MFALSE},
-	{161, 5805, WLAN_TX_PWR_1000MW, MFALSE},
-	{165, 5825, WLAN_TX_PWR_1000MW, MFALSE}};
+	{149, 5745, WLAN_TX_PWR_1000MW, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_1000MW, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_1000MW, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_1000MW, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_1000MW, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Region: Russia */
 static chan_freq_power_t channel_freq_power_RU_A[] = {
-	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{56, 5280, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{60, 5300, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{64, 5320, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{132, 5660, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{136, 5680, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{140, 5700, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE},
-};
+	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Region: Mexico */
 static chan_freq_power_t channel_freq_power_MX_A[] = {
-	{36, 5180, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{100, 5500, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE},
-	{149, 5745, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{100, 5500, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_EMEA_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_EMEA_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Code: 1, Low band (5150-5250 MHz) channels */
 static chan_freq_power_t channel_freq_power_low_band[] = {
-	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE},
-};
+	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Code: 2, Lower middle band (5250-5350 MHz) channels */
 static chan_freq_power_t channel_freq_power_lower_middle_band[] = {
-	{52, 5260, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{56, 5280, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{60, 5300, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{64, 5320, WLAN_TX_PWR_DEFAULT, MTRUE},
-};
+	{52, 5260, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}}};
 
 /** Band: 'A', Code: 3, Upper middle band (5470-5725 MHz) channels */
 static chan_freq_power_t channel_freq_power_upper_middle_band[] = {
-	{100, 5500, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{104, 5520, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{108, 5540, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{112, 5560, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{116, 5580, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{120, 5600, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{124, 5620, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{128, 5640, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{132, 5660, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{136, 5680, WLAN_TX_PWR_DEFAULT, MTRUE},
-	{140, 5700, WLAN_TX_PWR_DEFAULT, MTRUE},
-};
+	{100, 5500, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{104, 5520, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{108, 5540, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{112, 5560, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{116, 5580, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{120, 5600, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{124, 5620, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{128, 5640, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{132, 5660, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{136, 5680, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}},
+	{140, 5700, WLAN_TX_PWR_DEFAULT, MTRUE, {0x13, 0, 0}}};
 
 /** Band: 'A', Code: 4, High band (5725-5850 MHz) channels */
 static chan_freq_power_t channel_freq_power_high_band[] = {
-	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE}};
+	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Code: 5, Low band (5150-5250 MHz) and
  *  High band (5725-5850 MHz) channels
  */
 static chan_freq_power_t channel_freq_power_low_high_band[] = {
-	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /** Band: 'A', Code: 6, Low band (5150-5250 MHz) and
  *  mid low (5260-5320) and High band (5725-5850 MHz) channels
  */
 static chan_freq_power_t channel_freq_power_low_middle_high_band[] = {
-	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{52, 5260, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{56, 5280, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{60, 5300, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{64, 5320, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE},
-	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE}};
+	{36, 5180, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{40, 5200, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{44, 5220, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{48, 5240, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{52, 5260, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{56, 5280, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{60, 5300, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{64, 5320, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{149, 5745, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{153, 5765, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{157, 5785, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{161, 5805, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}},
+	{165, 5825, WLAN_TX_PWR_DEFAULT, MFALSE, {0x10, 0, 0}}};
 
 /**
  * The 5GHz CFP tables
@@ -748,7 +741,7 @@ typedef struct _rate_map {
 /** If user configure to 1x1 or we found peer device only support 1x1,
  * then we need skip the nss1 part when map to Mrvl rate.
  */
-const rate_map rate_map_table_2x2[] = {
+static const rate_map rate_map_table_2x2[] = {
 	/* LG <--> Mrvl rate idx */
 	{2, 0, 0}, // RATEID_DBPSK1Mbps
 	{4, 1, 0}, // RATEID_DQPSK2Mbps
@@ -887,7 +880,7 @@ const rate_map rate_map_table_2x2[] = {
  * For the chip who only support 1x1, Mrvl rate idx define is different with 2x2
  * in FW We need redefine a bitrate to Mrvl rate idx table for 1x1 chip.
  */
-const rate_map rate_map_table_1x1[] = {
+static const rate_map rate_map_table_1x1[] = {
 	/* LG <--> Mrvl rate idx */
 	{2, 0, 0}, // RATEID_DBPSK1Mbps
 	{4, 1, 0}, // RATEID_DQPSK2Mbps
@@ -981,8 +974,6 @@ const rate_map rate_map_table_1x1[] = {
 t_u16 region_code_index[MRVDRV_MAX_REGION_CODE] = {0x00, 0x10, 0x20, 0x30, 0x40,
 						   0x41, 0x50, 0xfe, 0xff};
 
-/** The table to keep CFP code for BG */
-t_u16 cfp_code_index_bg[MRVDRV_MAX_CFP_CODE_BG] = {};
 /** The table to keep CFP code for A */
 t_u16 cfp_code_index_a[MRVDRV_MAX_CFP_CODE_A] = {0x1, 0x2, 0x3, 0x4, 0x5};
 
@@ -1019,7 +1010,7 @@ t_u8 SupportedRates_A[A_SUPPORTED_RATES] = {0x0c, 0x12, 0x18, 0x24, 0xb0,
 /**
  * The rates supported by the card
  */
-t_u16 WlanDataRates[WLAN_SUPPORTED_RATES_EXT] = {
+static t_u16 WlanDataRates[WLAN_SUPPORTED_RATES_EXT] = {
 	0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12, 0x18, 0x24,  0x30, 0x48,
 	0x60, 0x6C, 0x90, 0x0D, 0x1A, 0x27, 0x34, 0x4E, 0x68,  0x75, 0x82,
 	0x0C, 0x1B, 0x36, 0x51, 0x6C, 0xA2, 0xD8, 0xF3, 0x10E, 0x00};
@@ -1050,7 +1041,7 @@ t_u8 SupportedRates_N[N_SUPPORTED_RATES] = {0x02, 0x04, 0};
 #define MCS_NUM_AX 12
 // for MCS0/MCS1/MCS3/MCS4 have 4 additional DCM=1 value
 // note: the value in the table is 2 multiplier of the actual rate
-t_u16 ax_mcs_rate_nss1[12][MCS_NUM_AX + 4] = {
+static t_u16 ax_mcs_rate_nss1[12][MCS_NUM_AX + 4] = {
 	{0x90, 0x48, 0x120, 0x90, 0x1B0, 0x240, 0x120, 0x360, 0x1B0, 0x481,
 	 0x511, 0x5A1, 0x6C1, 0x781, 0x871, 0x962}, /*SG 160M*/
 	{0x88, 0x44, 0x110, 0x88, 0x198, 0x220, 0x110, 0x330, 0x198, 0x440,
@@ -1077,6 +1068,7 @@ t_u16 ax_mcs_rate_nss1[12][MCS_NUM_AX + 4] = {
 	 0xAF, 0xC3, 0xDB, 0xF3} /*LG 20M*/
 };
 
+#if 0
 // note: the value in the table is 2 multiplier of the actual rate
 t_u16 ax_tone_ru_rate_nss1[9][MCS_NUM_AX + 4] = {
 	{0x8, 0x4, 0xF, 0x8, 0x17, 0x1E, 0xF, 0x2D, 0x17, 0x3C, 0x44, 0x4B,
@@ -1098,9 +1090,10 @@ t_u16 ax_tone_ru_rate_nss1[9][MCS_NUM_AX + 4] = {
 	{0x2, 0x1, 0x3, 0x2, 0x5, 0x6, 0x3, 0x9, 0x4, 0xC, 0xE, 0xF, 0x12, 0x14,
 	 0x17, 0x19} /*LG 26-tone*/
 };
+#endif
 
 // note: the value in the table is 2 multiplier of the actual rate
-t_u16 ax_mcs_rate_nss2[12][MCS_NUM_AX + 4] = {
+static t_u16 ax_mcs_rate_nss2[12][MCS_NUM_AX + 4] = {
 	{0x120, 0x90, 0x240, 0x120, 0x360, 0x481, 0x240, 0x61C, 0x360, 0x901,
 	 0xA22, 0xB42, 0xD82, 0xF03, 0x10E3, 0x12C3}, /*SG 160M*/
 	{0x110, 0x88, 0x220, 0x110, 0x330, 0x440, 0x220, 0x661, 0x330, 0x881,
@@ -1127,6 +1120,7 @@ t_u16 ax_mcs_rate_nss2[12][MCS_NUM_AX + 4] = {
 	 0x124, 0x15F, 0x186, 0x1B6, 0x1E7} /*LG 20M*/
 };
 
+#if 0
 // note: the value in the table is 2 multiplier of the actual rate
 t_u16 ax_tone_ru_rate_nss2[9][MCS_NUM_AX + 4] = {
 	{0xF, 0x8, 0x1E, 0xF, 0x2D, 0x3C, 0x1E, 0x5A, 0x2D, 0x78, 0x87, 0x96,
@@ -1148,6 +1142,7 @@ t_u16 ax_tone_ru_rate_nss2[9][MCS_NUM_AX + 4] = {
 	{0x3, 0x2, 0x6, 0x3, 0x9, 0xC, 0x6, 0x12, 0x9, 0x18, 0x1B, 0x1E, 0x24,
 	 0x28, 0x2D, 0x32} /*LG 26-tone*/
 };
+#endif
 
 /********************************************************
  *			Local Functions
@@ -1192,7 +1187,7 @@ static void *wlan_memchr(pmlan_adapter pmadapter, void *s, int c, int n)
  *  @return           A pointer to CFP
  */
 static chan_freq_power_t *wlan_get_region_cfp_table(pmlan_adapter pmadapter,
-						    t_u8 region, t_u8 band,
+						    t_u8 region, t_u16 band,
 						    int *cfp_no)
 {
 	t_u32 i;
@@ -1257,7 +1252,6 @@ static chan_freq_power_t *wlan_get_region_cfp_table(pmlan_adapter pmadapter,
 			}
 		}
 	}
-
 	if (!region)
 		PRINTM(MERROR, "Error Band[0x%x] or code[BG:%#x, A:%#x]\n",
 		       band, cfp_bg, cfp_a);
@@ -1294,9 +1288,10 @@ static t_void wlan_cfp_copy_dynamic(pmlan_adapter pmadapter,
 	}
 
 	/* first clear dest dynamic blacklisted entries */
+	/* do not clear the flags */
 	for (i = 0; i < num_cfp; i++) {
 		cfp[i].dynamic.blacklist = MFALSE;
-		cfp[i].dynamic.flags = 0;
+		cfp[i].dynamic.dfs_state = DFS_USABLE;
 	}
 
 	/* copy dynamic blacklisted entries from source where channels match */
@@ -1306,8 +1301,8 @@ static t_void wlan_cfp_copy_dynamic(pmlan_adapter pmadapter,
 				if (cfp[i].channel == cfp_src[j].channel) {
 					cfp[i].dynamic.blacklist =
 						cfp_src[j].dynamic.blacklist;
-					cfp[i].dynamic.flags =
-						cfp_src[j].dynamic.flags;
+					cfp[i].dynamic.dfs_state =
+						cfp_src[j].dynamic.dfs_state;
 					break;
 				}
 	}
@@ -1336,6 +1331,17 @@ mlan_status wlan_misc_country_2_cfp_table_code(pmlan_adapter pmadapter,
 
 	ENTER();
 
+	if (pmadapter->otp_region) {
+		if (!memcmp(pmadapter, pmadapter->otp_region->country_code,
+			    country_code, COUNTRY_CODE_LEN - 1)) {
+			if (pmadapter->cfp_otp_bg)
+				*cfp_bg = pmadapter->otp_region->region_code;
+			if (pmadapter->cfp_otp_a)
+				*cfp_a = pmadapter->otp_region->region_code;
+			LEAVE();
+			return MLAN_STATUS_SUCCESS;
+		}
+	}
 	/* Look for code in mapping table */
 	for (i = 0; i < NELEMENTS(country_code_mapping); i++) {
 		if (!memcmp(pmadapter, country_code_mapping[i].country_code,
@@ -1389,8 +1395,6 @@ t_bool wlan_is_etsi_country(pmlan_adapter pmadapter, t_u8 *country_code)
 	return MFALSE;
 }
 
-#define BAND_MASK_5G 0x03
-#define ANTENNA_OFFSET 2
 /**
  *   @brief This function adjust the antenna index
  *
@@ -1420,6 +1424,7 @@ t_u8 wlan_adjust_antenna(pmlan_private priv, RxPD *prx_pd)
 	}
 
 #if defined(SD8887) || defined(SD8987)
+#define ANTENNA_OFFSET 2
 	if (MFALSE
 #ifdef SD8887
 	    || IS_SD8887(priv->adapter->card_type)
@@ -1491,6 +1496,60 @@ t_u16 wlan_adjust_data_rate(mlan_private *priv, t_u8 rx_rate, t_u8 rate_info)
 #ifdef STA_SUPPORT
 #endif /* STA_SUPPORT */
 
+/**
+ *  @brief convert TX rate_info from v14 to v15+ FW rate_info
+ *
+ *  @param v14_rate_info      v14 rate info
+ *
+ *  @return             v15+ rate info
+ */
+t_u8 wlan_convert_v14_tx_rate_info(pmlan_private pmpriv, t_u8 v14_rate_info)
+{
+	t_u8 rate_info = 0;
+
+	if (!pmpriv->adapter->pcard_info->v14_fw_api) {
+		PRINTM(MERROR, "%s: Not convert for this is not V14 FW\n",
+		       __func__);
+		return v14_rate_info;
+	}
+
+	rate_info = v14_rate_info & 0x01;
+	/* band */
+	rate_info |= (v14_rate_info & MBIT(1)) << 1;
+	/* short GI */
+	rate_info |= (v14_rate_info & MBIT(2)) << 2;
+	return rate_info;
+}
+
+/**
+ *  @brief convert RX rate_info from v14 to v15+ FW rate_info
+ *
+ *  @param v14_rate_info      v14 rate info
+ *
+ *  @return             v15+ rate info
+ */
+t_u8 wlan_convert_v14_rx_rate_info(pmlan_private pmpriv, t_u8 v14_rate_info)
+{
+	t_u8 rate_info = 0;
+	t_u8 mode = 0;
+	t_u8 bw = 0;
+	t_u8 sgi = 0;
+
+	if (!pmpriv->adapter->pcard_info->v14_fw_api) {
+		PRINTM(MERROR, "%s: Not convert for this is not V14 FW\n",
+		       __func__);
+		return v14_rate_info;
+	}
+
+	mode = v14_rate_info & MBIT(0);
+	bw = v14_rate_info & MBIT(1);
+	sgi = (v14_rate_info & 0x04) >> 2;
+
+	rate_info = (mode & 0x01) | ((bw & 0x01) << 2) | ((sgi & 0x01) << 4);
+
+	return rate_info;
+}
+
 /**
  *  @brief Use index to get the data rate
  *
@@ -1563,7 +1622,7 @@ t_u32 wlan_index_to_data_rate(pmlan_adapter pmadapter, t_u8 index,
 	t_u32 rate = 0;
 	t_u8 mcs_index = 0;
 	t_u8 he_dcm = 0;
-	t_u8 he_tone = 0;
+	//	t_u8 he_tone = 0;
 	t_u8 stbc = 0;
 
 	t_u8 bw = 0;
@@ -1625,10 +1684,12 @@ t_u32 wlan_index_to_data_rate(pmlan_adapter pmadapter, t_u8 index,
 		if (gi > 0)
 			gi = gi - 1;
 
+		//#ifdef ENABLE_802_11AX
 		// TODO: hardcode he_tone here, wait for FW value ready.
-		he_tone = 4;
+		//		he_tone = 4;
 
 		// he_tone = (ext_rate_info & 0xE) >> 1;
+		//#endif
 
 		if ((index >> 4) == 1) {
 			switch (mcs_index) {
@@ -1821,11 +1882,13 @@ t_u32 wlan_get_active_data_rates(mlan_private *pmpriv, t_u32 bss_mode,
  *            present in all the regions.
  *
  *  @param pmpriv       A pointer to mlan_private structure
+ *  @param band      	band.
  *  @param channel      Channel number.
  *
  *  @return             The Tx power
  */
-t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u8 channel)
+t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u16 band,
+				     t_u8 channel)
 {
 	t_u8 i = 0;
 	t_u8 j = 0;
@@ -1837,38 +1900,46 @@ t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u8 channel)
 
 	ENTER();
 
-	for (i = 0; i < MLAN_CFP_TABLE_SIZE_BG; i++) {
-		/* Get CFP */
-		cfp = cfp_table_BG[i].cfp;
-		cfp_no = cfp_table_BG[i].cfp_no;
-		/* Find matching channel and get Tx power */
-		for (j = 0; j < cfp_no; j++) {
-			if ((cfp + j)->channel == channel) {
-				if (tx_power != 0)
-					tx_power = MIN(tx_power,
-						       (cfp + j)->max_tx_power);
-				else
-					tx_power =
-						(t_u8)(cfp + j)->max_tx_power;
-				break;
+	if (band & (BAND_B | BAND_G)) {
+		for (i = 0; i < MLAN_CFP_TABLE_SIZE_BG; i++) {
+			/* Get CFP */
+			cfp = cfp_table_BG[i].cfp;
+			cfp_no = cfp_table_BG[i].cfp_no;
+			/* Find matching channel and get Tx power */
+			for (j = 0; j < cfp_no; j++) {
+				if ((cfp + j)->channel == channel) {
+					if (tx_power != 0)
+						tx_power = MIN(
+							tx_power,
+							(cfp + j)->max_tx_power);
+					else
+						tx_power =
+							(t_u8)(cfp + j)
+								->max_tx_power;
+					break;
+				}
 			}
 		}
 	}
 
-	for (i = 0; i < MLAN_CFP_TABLE_SIZE_A; i++) {
-		/* Get CFP */
-		cfp_a = cfp_table_A[i].cfp;
-		cfp_no_a = cfp_table_A[i].cfp_no;
-		for (j = 0; j < cfp_no_a; j++) {
-			if ((cfp_a + j)->channel == channel) {
-				if (tx_power != 0)
-					tx_power =
-						MIN(tx_power,
-						    (cfp_a + j)->max_tx_power);
-				else
-					tx_power = (t_u8)(
-						(cfp_a + j)->max_tx_power);
-				break;
+	if (band & BAND_A) {
+		for (i = 0; i < MLAN_CFP_TABLE_SIZE_A; i++) {
+			/* Get CFP */
+			cfp_a = cfp_table_A[i].cfp;
+			cfp_no_a = cfp_table_A[i].cfp_no;
+			for (j = 0; j < cfp_no_a; j++) {
+				if ((cfp_a + j)->channel == channel) {
+					if (tx_power != 0)
+						tx_power = MIN(
+							tx_power,
+							(cfp_a + j)
+								->max_tx_power);
+					else
+						tx_power = (t_u8)(
+							(cfp_a + j)
+								->max_tx_power);
+					break;
+				}
 			}
 		}
 	}
@@ -1890,7 +1961,7 @@ t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u8 channel)
  */
 
 chan_freq_power_t *
-wlan_get_cfp_by_band_and_channel(pmlan_adapter pmadapter, t_u8 band,
+wlan_get_cfp_by_band_and_channel(pmlan_adapter pmadapter, t_u16 band,
 				 t_u16 channel, region_chan_t *region_channel)
 {
 	region_chan_t *rc;
@@ -1973,7 +2044,7 @@ wlan_get_cfp_by_band_and_channel(pmlan_adapter pmadapter, t_u8 band,
  * found.
  */
 chan_freq_power_t *wlan_find_cfp_by_band_and_channel(mlan_adapter *pmadapter,
-						     t_u8 band, t_u16 channel)
+						     t_u16 band, t_u16 channel)
 {
 	chan_freq_power_t *cfp = MNULL;
 
@@ -2002,7 +2073,7 @@ chan_freq_power_t *wlan_find_cfp_by_band_and_channel(mlan_adapter *pmadapter,
  *  @return         Pointer to chan_freq_power_t structure; MNULL if not found
  */
 chan_freq_power_t *wlan_find_cfp_by_band_and_freq(mlan_adapter *pmadapter,
-						  t_u8 band, t_u32 freq)
+						  t_u16 band, t_u32 freq)
 {
 	chan_freq_power_t *cfp = MNULL;
 	region_chan_t *rc;
@@ -2125,6 +2196,27 @@ int wlan_get_rate_index(pmlan_adapter pmadapter, t_u16 *rate_bitmap, int size)
 	return -1;
 }
 
+/**
+ *  @brief Convert config_bands to B/G/A band
+ *
+ *  @param config_bands     The specified band configuration
+ *
+ *  @return                 BAND_B|BAND_G|BAND_A
+ */
+t_u16 wlan_convert_config_bands(t_u16 config_bands)
+{
+	t_u16 bands = 0;
+	if (config_bands & BAND_B)
+		bands |= BAND_B;
+	if (config_bands & BAND_G || config_bands & BAND_GN ||
+	    config_bands & BAND_GAC || config_bands & BAND_GAX)
+		bands |= BAND_G;
+	if (config_bands & BAND_A || config_bands & BAND_AN ||
+	    config_bands & BAND_AAC || config_bands & BAND_AAX)
+		bands |= BAND_A;
+	return bands;
+}
+
 /**
  *  @brief Get supported data rates
  *
@@ -2139,109 +2231,64 @@ t_u32 wlan_get_supported_rates(mlan_private *pmpriv, t_u32 bss_mode,
 			       t_u16 config_bands, WLAN_802_11_RATES rates)
 {
 	t_u32 k = 0;
+	t_u16 bands = 0;
 
 	ENTER();
+	bands = wlan_convert_config_bands(config_bands);
 
 	if (bss_mode == MLAN_BSS_MODE_INFRA) {
 		/* Infra. mode */
-		switch (config_bands) {
-		case (t_u8)BAND_B:
-			PRINTM(MINFO, "Infra Band=%d SupportedRates_B\n",
-			       config_bands);
+		if (bands == BAND_B) {
+			/* B only */
+			PRINTM(MINFO, "Band: Infra B\n");
 			k = wlan_copy_rates(rates, k, SupportedRates_B,
 					    sizeof(SupportedRates_B));
-			break;
-		case (t_u8)BAND_G:
-		case BAND_G | BAND_GN:
-		case BAND_G | BAND_GN | BAND_GAC:
-		case BAND_G | BAND_GN | BAND_GAC | BAND_GAX:
-			PRINTM(MINFO, "Infra band=%d SupportedRates_G\n",
-			       config_bands);
+		} else if (bands == BAND_G) {
+			/* G only */
+			PRINTM(MINFO, "Band: Infra G\n");
 			k = wlan_copy_rates(rates, k, SupportedRates_G,
 					    sizeof(SupportedRates_G));
-			break;
-		case BAND_B | BAND_G:
-		case BAND_A | BAND_B | BAND_G:
-		case BAND_A | BAND_B:
-		case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN:
-		case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC:
-		case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC |
-			BAND_GAC:
-		case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC |
-			BAND_AAX:
-		case BAND_A | BAND_B | BAND_G | BAND_GN | BAND_AN | BAND_AAC |
-			BAND_GAC | BAND_AAX | BAND_GAX:
-		case BAND_B | BAND_G | BAND_GN:
-		case BAND_B | BAND_G | BAND_GN | BAND_GAC:
-		case BAND_B | BAND_G | BAND_GN | BAND_GAC | BAND_GAX:
-			PRINTM(MINFO, "Infra band=%d SupportedRates_BG\n",
-			       config_bands);
+
+		} else if (bands & (BAND_B | BAND_G)) {
+			/* BG only */
+			PRINTM(MINFO, "Band: Infra BG\n");
 #ifdef WIFI_DIRECT_SUPPORT
 			if (pmpriv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT)
 				k = wlan_copy_rates(rates, k, SupportedRates_G,
 						    sizeof(SupportedRates_G));
 			else
+#endif
 				k = wlan_copy_rates(rates, k, SupportedRates_BG,
 						    sizeof(SupportedRates_BG));
-#else
-			k = wlan_copy_rates(rates, k, SupportedRates_BG,
-					    sizeof(SupportedRates_BG));
-#endif
-			break;
-		case BAND_A:
-		case BAND_A | BAND_G:
-			PRINTM(MINFO, "Infra band=%d SupportedRates_A\n",
-			       config_bands);
-			k = wlan_copy_rates(rates, k, SupportedRates_A,
-					    sizeof(SupportedRates_A));
-			break;
-		case BAND_AN:
-		case BAND_A | BAND_AN:
-		case BAND_A | BAND_G | BAND_AN | BAND_GN:
-		case BAND_A | BAND_AN | BAND_AAC:
-		case BAND_A | BAND_G | BAND_AN | BAND_GN | BAND_AAC:
-		case BAND_A | BAND_AN | BAND_AAC | BAND_AAX:
-		case BAND_A | BAND_G | BAND_AN | BAND_GN | BAND_AAC | BAND_AAX:
-			PRINTM(MINFO, "Infra band=%d SupportedRates_A\n",
-			       config_bands);
+		} else if (bands & BAND_A) {
+			/* support A */
+			PRINTM(MINFO, "Band: Infra A\n");
 			k = wlan_copy_rates(rates, k, SupportedRates_A,
 					    sizeof(SupportedRates_A));
-			break;
-		case BAND_GN:
-		case BAND_GN | BAND_GAC:
-		case BAND_GN | BAND_GAC | BAND_GAX:
-			PRINTM(MINFO, "Infra band=%d SupportedRates_N\n",
-			       config_bands);
-			k = wlan_copy_rates(rates, k, SupportedRates_N,
-					    sizeof(SupportedRates_N));
-			break;
 		}
 	} else {
-		/* Ad-hoc mode */
-		switch (config_bands) {
-		case (t_u8)BAND_B:
+		/* Adhoc. mode */
+		if (bands == BAND_B) {
+			/* B only */
 			PRINTM(MINFO, "Band: Adhoc B\n");
 			k = wlan_copy_rates(rates, k, AdhocRates_B,
 					    sizeof(AdhocRates_B));
-			break;
-		case (t_u8)BAND_G:
-			PRINTM(MINFO, "Band: Adhoc G only\n");
+		} else if (bands == BAND_G) {
+			/* G only */
+			PRINTM(MINFO, "Band: Adhoc G\n");
 			k = wlan_copy_rates(rates, k, AdhocRates_G,
 					    sizeof(AdhocRates_G));
-			break;
-		case BAND_B | BAND_G:
-			PRINTM(MINFO, "Band: Adhoc BG\n");
-			k = wlan_copy_rates(rates, k, AdhocRates_BG,
-					    sizeof(AdhocRates_BG));
-			break;
-		case BAND_A:
-		case BAND_A | BAND_AN | BAND_AAC:
-		case BAND_A | BAND_AN | BAND_AAC | BAND_AAX:
 
+		} else if (bands & BAND_A) {
+			/* support A */
 			PRINTM(MINFO, "Band: Adhoc A\n");
 			k = wlan_copy_rates(rates, k, AdhocRates_A,
 					    sizeof(AdhocRates_A));
-			break;
+
+		} else {
+			PRINTM(MINFO, "Band: Adhoc BG\n");
+			k = wlan_copy_rates(rates, k, AdhocRates_BG,
+					    sizeof(AdhocRates_BG));
 		}
 	}
 
@@ -2364,8 +2411,8 @@ static oper_bw_chan oper_bw_chan_cn[] = {
  *
  *  @return                   A pointer to oper_bw_chan
  */
-oper_bw_chan *wlan_get_nonglobal_operclass_table(mlan_private *pmpriv,
-						 int *arraysize)
+static oper_bw_chan *wlan_get_nonglobal_operclass_table(mlan_private *pmpriv,
+							int *arraysize)
 {
 	t_u8 country_code[][COUNTRY_CODE_LEN] = {"US", "JP", "CN"};
 	int country_id = 0;
@@ -2400,9 +2447,6 @@ oper_bw_chan *wlan_get_nonglobal_operclass_table(mlan_private *pmpriv,
 		poper_bw_chan = oper_bw_chan_eu;
 		*arraysize = sizeof(oper_bw_chan_eu);
 		break;
-	default:
-		PRINTM(MERROR, "Country not support!\n");
-		break;
 	}
 
 	LEAVE();
@@ -2415,11 +2459,12 @@ oper_bw_chan *wlan_get_nonglobal_operclass_table(mlan_private *pmpriv,
  *  @param pmpriv             A pointer to mlan_private structure
  *  @param channel            Channel number
  *  @param oper_class         operating class
+ *  @param bandwidth          band width
  *
  *  @return                   MLAN_STATUS_PENDING --success, otherwise fail
  */
 mlan_status wlan_check_operclass_validation(mlan_private *pmpriv, t_u8 channel,
-					    t_u8 oper_class)
+					    t_u8 oper_class, t_u8 bandwidth)
 {
 	int arraysize = 0, i = 0, channum = 0;
 	oper_bw_chan *poper_bw_chan = MNULL;
@@ -2428,7 +2473,7 @@ mlan_status wlan_check_operclass_validation(mlan_private *pmpriv, t_u8 channel,
 
 	ENTER();
 
-	for (i = 0; i < sizeof(center_freqs); i++) {
+	for (i = 0; i < (int)sizeof(center_freqs); i++) {
 		if (channel == center_freqs[i]) {
 			PRINTM(MERROR, "Invalid channel number %d!\n", channel);
 			LEAVE();
@@ -2442,7 +2487,7 @@ mlan_status wlan_check_operclass_validation(mlan_private *pmpriv, t_u8 channel,
 	}
 	if (oper_class >= 128) {
 		center_freq_idx = wlan_get_center_freq_idx(
-			pmpriv, BAND_AAC, channel, CHANNEL_BW_80MHZ);
+			pmpriv, BAND_5GHZ, channel, CHANNEL_BW_80MHZ);
 		channel = center_freq_idx;
 	}
 	poper_bw_chan = wlan_get_nonglobal_operclass_table(pmpriv, &arraysize);
@@ -2453,11 +2498,12 @@ mlan_status wlan_check_operclass_validation(mlan_private *pmpriv, t_u8 channel,
 		return MLAN_STATUS_FAILURE;
 	}
 
-	for (i = 0; i < arraysize / sizeof(oper_bw_chan); i++) {
+	for (i = 0; i < (int)(arraysize / sizeof(oper_bw_chan)); i++) {
 		if (poper_bw_chan[i].oper_class == oper_class ||
 		    poper_bw_chan[i].global_oper_class == oper_class) {
 			for (channum = 0;
-			     channum < sizeof(poper_bw_chan[i].channel_list);
+			     channum <
+			     (int)sizeof(poper_bw_chan[i].channel_list);
 			     channum++) {
 				if (poper_bw_chan[i].channel_list[channum] &&
 				    poper_bw_chan[i].channel_list[channum] ==
@@ -2502,7 +2548,7 @@ mlan_status wlan_get_curr_oper_class(mlan_private *pmpriv, t_u8 channel,
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
-	for (i = 0; i < sizeof(center_freqs); i++) {
+	for (i = 0; i < (int)sizeof(center_freqs); i++) {
 		if (channel == center_freqs[i]) {
 			PRINTM(MERROR, "Invalid channel number %d!\n", channel);
 			LEAVE();
@@ -2511,14 +2557,15 @@ mlan_status wlan_get_curr_oper_class(mlan_private *pmpriv, t_u8 channel,
 	}
 	if (bw == BW_80MHZ) {
 		center_freq_idx = wlan_get_center_freq_idx(
-			pmpriv, BAND_AAC, channel, CHANNEL_BW_80MHZ);
+			pmpriv, BAND_5GHZ, channel, CHANNEL_BW_80MHZ);
 		channel = center_freq_idx;
 	}
 
-	for (i = 0; i < arraysize / sizeof(oper_bw_chan); i++) {
+	for (i = 0; i < (int)(arraysize / sizeof(oper_bw_chan)); i++) {
 		if (poper_bw_chan[i].bandwidth == bw) {
 			for (channum = 0;
-			     channum < sizeof(poper_bw_chan[i].channel_list);
+			     channum <
+			     (int)(sizeof(poper_bw_chan[i].channel_list));
 			     channum++) {
 				if (poper_bw_chan[i].channel_list[channum] &&
 				    poper_bw_chan[i].channel_list[channum] ==
@@ -2531,7 +2578,7 @@ mlan_status wlan_get_curr_oper_class(mlan_private *pmpriv, t_u8 channel,
 		}
 	}
 
-	PRINTM(MCMND, "Operating class not find!\n");
+	PRINTM(MCMND, "Operating class not found!\n");
 	LEAVE();
 	return MLAN_STATUS_FAILURE;
 }
@@ -2548,14 +2595,16 @@ mlan_status wlan_get_curr_oper_class(mlan_private *pmpriv, t_u8 channel,
 int wlan_add_supported_oper_class_ie(mlan_private *pmpriv, t_u8 **pptlv_out,
 				     t_u8 curr_oper_class)
 {
-	t_u8 oper_class_us[] = {1,  2,	3,  4,	5,  12, 22, 23,	 24,  25, 26,
-				27, 28, 29, 30, 31, 32, 33, 128, 129, 130};
-	t_u8 oper_class_eu[] = {1, 2,  3,  4,  5,  6,	7,   8,
-				9, 10, 11, 12, 17, 128, 129, 130};
-	t_u8 oper_class_jp[] = {1,  30, 31, 32, 33,  34,  35, 36,
-				37, 38, 39, 40, 41,  42,  43, 44,
-				45, 56, 57, 58, 128, 129, 130};
-	t_u8 oper_class_cn[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 128, 129, 130};
+	t_u8 oper_class_us[] = {115, 118, 124, 121, 125, 81,  116,
+				119, 122, 126, 126, 117, 120, 123,
+				127, 127, 83,  84,  128, 129, 130};
+	t_u8 oper_class_eu[] = {115, 118, 121, 81, 116, 119, 122, 117,
+				120, 123, 83,  84, 125, 128, 129, 130};
+	t_u8 oper_class_jp[] = {115, 81,  82,  118, 118, 121, 121, 116,
+				119, 119, 122, 122, 117, 120, 120, 123,
+				123, 83,  84,  121, 128, 129, 130};
+	t_u8 oper_class_cn[] = {115, 118, 125, 116, 119, 126,
+				81,  83,  84,  128, 129, 130};
 	t_u8 country_code[][COUNTRY_CODE_LEN] = {"US", "JP", "CN"};
 	int country_id = 0, ret = 0;
 	MrvlIETypes_SuppOperClass_t *poper_class = MNULL;
@@ -2617,7 +2666,7 @@ int wlan_add_supported_oper_class_ie(mlan_private *pmpriv, t_u8 **pptlv_out,
  *
  *  @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u8 band)
+mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u16 band)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	int i = 0, j;
@@ -2665,16 +2714,17 @@ mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u8 band)
 
 		if ((j < MAX_REGION_CHANNEL_NUM) &&
 		    (region_chan_old[j].valid == MTRUE)) {
-			wlan_cfp_copy_dynamic(pmadapter, cfp, cfp_no,
+			wlan_cfp_copy_dynamic(pmadapter, cfp, (t_u8)cfp_no,
 					      region_chan_old[j].pcfp,
 					      region_chan_old[j].num_cfp);
-		} else if (region) {
-			wlan_cfp_copy_dynamic(pmadapter, cfp, cfp_no, MNULL, 0);
+		} else if (cfp) {
+			wlan_cfp_copy_dynamic(pmadapter, cfp, (t_u8)cfp_no,
+					      MNULL, 0);
 		}
 		i++;
 	}
 	if (band & (BAND_A | BAND_AN | BAND_AAC)) {
-		if (pmadapter->cfp_code_bg)
+		if (pmadapter->cfp_code_a)
 			cfp_code_a = pmadapter->cfp_code_a;
 		PRINTM(MCMND, "%s: 5G 0x%x\n", __func__, cfp_code_a);
 		cfp = wlan_get_region_cfp_table(pmadapter, cfp_code_a, BAND_A,
@@ -2697,12 +2747,14 @@ mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u8 band)
 				break;
 		}
 		if ((j < MAX_REGION_CHANNEL_NUM) && region_chan_old[j].valid) {
-			wlan_cfp_copy_dynamic(pmadapter, cfp, cfp_no,
+			wlan_cfp_copy_dynamic(pmadapter, cfp, (t_u8)cfp_no,
 					      region_chan_old[j].pcfp,
 					      region_chan_old[j].num_cfp);
-		} else if (region) {
-			wlan_cfp_copy_dynamic(pmadapter, cfp, cfp_no, MNULL, 0);
+		} else if (cfp) {
+			wlan_cfp_copy_dynamic(pmadapter, cfp, (t_u8)cfp_no,
+					      MNULL, 0);
 		}
+		i++;
 	}
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -2764,7 +2816,6 @@ t_bool wlan_get_cfp_radar_detect(mlan_private *priv, t_u8 chnl)
  *    - MTRUE if scan type is passive
  *    - MFALSE otherwise
  */
-
 t_bool wlan_bg_scan_type_is_passive(mlan_private *priv, t_u8 chnl)
 {
 	int i, j;
@@ -2813,7 +2864,7 @@ t_bool wlan_bg_scan_type_is_passive(mlan_private *priv, t_u8 chnl)
  *    - MFALSE otherwise
  */
 
-t_bool wlan_is_chan_passive(mlan_private *priv, t_u8 band, t_u8 chan)
+t_bool wlan_is_chan_passive(mlan_private *priv, t_u16 band, t_u8 chan)
 {
 	int i, j;
 	t_bool passive = MFALSE;
@@ -2856,7 +2907,7 @@ t_bool wlan_is_chan_passive(mlan_private *priv, t_u8 band, t_u8 chan)
  *    - MFALSE otherwise
  */
 
-t_bool wlan_is_chan_disabled(mlan_private *priv, t_u8 band, t_u8 chan)
+t_bool wlan_is_chan_disabled(mlan_private *priv, t_u16 band, t_u8 chan)
 {
 	int i, j;
 	t_bool disabled = MFALSE;
@@ -2900,7 +2951,7 @@ t_bool wlan_is_chan_disabled(mlan_private *priv, t_u8 band, t_u8 chan)
  *    - MFALSE otherwise
  */
 
-t_bool wlan_is_chan_blacklisted(mlan_private *priv, t_u8 band, t_u8 chan)
+t_bool wlan_is_chan_blacklisted(mlan_private *priv, t_u16 band, t_u8 chan)
 {
 	int i, j;
 	t_bool blacklist = MFALSE;
@@ -2943,7 +2994,7 @@ t_bool wlan_is_chan_blacklisted(mlan_private *priv, t_u8 band, t_u8 chan)
  *    - MFALSE otherwise
  */
 
-t_bool wlan_set_chan_blacklist(mlan_private *priv, t_u8 band, t_u8 chan,
+t_bool wlan_set_chan_blacklist(mlan_private *priv, t_u16 band, t_u8 chan,
 			       t_bool bl)
 {
 	int i, j;
@@ -2975,6 +3026,119 @@ t_bool wlan_set_chan_blacklist(mlan_private *priv, t_u8 band, t_u8 chan,
 	return set_bl;
 }
 
+/**
+ *  @brief Set channel's dfs state
+ *
+ *  @param priv         Private driver information structure
+ *  @param band         Band to check
+ *  @param chan         Channel to check
+ *  @param dfs_state    dfs state
+ *
+ *  @return  N/A
+ */
+t_void wlan_set_chan_dfs_state(mlan_private *priv, t_u16 band, t_u8 chan,
+			       dfs_state_t dfs_state)
+{
+	int i, j;
+	chan_freq_power_t *pcfp = MNULL;
+
+	ENTER();
+
+	/*get the cfp table first*/
+	for (i = 0; i < MAX_REGION_CHANNEL_NUM; i++) {
+		if (priv->adapter->region_channel[i].band & band) {
+			pcfp = priv->adapter->region_channel[i].pcfp;
+			break;
+		}
+	}
+
+	if (pcfp) {
+		/*check table according to chan num*/
+		for (j = 0; j < priv->adapter->region_channel[i].num_cfp; j++) {
+			if (pcfp[j].channel == chan) {
+				pcfp[j].dynamic.dfs_state = dfs_state;
+				break;
+			}
+		}
+	}
+
+	LEAVE();
+}
+
+/**
+ *  @brief get channel's dfs state
+ *
+ *  @param priv         Private driver information structure
+ *  @param band         Band to check
+ *  @param chan         Channel to check
+ *
+ *  @return  channel's dfs state
+ */
+dfs_state_t wlan_get_chan_dfs_state(mlan_private *priv, t_u16 band, t_u8 chan)
+{
+	int i, j;
+	chan_freq_power_t *pcfp = MNULL;
+	dfs_state_t dfs_state = DFS_USABLE;
+
+	ENTER();
+
+	/*get the cfp table first*/
+	for (i = 0; i < MAX_REGION_CHANNEL_NUM; i++) {
+		if (priv->adapter->region_channel[i].band & band) {
+			pcfp = priv->adapter->region_channel[i].pcfp;
+			break;
+		}
+	}
+
+	if (pcfp) {
+		/*check table according to chan num*/
+		for (j = 0; j < priv->adapter->region_channel[i].num_cfp; j++) {
+			if (pcfp[j].channel == chan) {
+				dfs_state = pcfp[j].dynamic.dfs_state;
+				break;
+			}
+		}
+	}
+
+	LEAVE();
+	return dfs_state;
+}
+
+/**
+ *  @brief reset all channel's dfs state
+ *
+ *  @param priv         Private driver information structure
+ *  @param band         Band to check
+ *  @param dfs_state    dfs state
+ *
+ *  @return  N/A
+ */
+t_void wlan_reset_all_chan_dfs_state(mlan_private *priv, t_u16 band,
+				     dfs_state_t dfs_state)
+{
+	int i, j;
+	chan_freq_power_t *pcfp = MNULL;
+
+	ENTER();
+
+	/*get the cfp table first*/
+	for (i = 0; i < MAX_REGION_CHANNEL_NUM; i++) {
+		if (priv->adapter->region_channel[i].band & band) {
+			pcfp = priv->adapter->region_channel[i].pcfp;
+			break;
+		}
+	}
+
+	if (pcfp) {
+		/*check table according to chan num*/
+		for (j = 0; j < priv->adapter->region_channel[i].num_cfp; j++) {
+			pcfp[j].dynamic.dfs_state = dfs_state;
+		}
+	}
+
+	LEAVE();
+}
+
 /**
  *  @brief Convert rateid in IEEE format to MRVL format
  *
@@ -3066,6 +3230,43 @@ t_u8 wlan_mrvl_rateid_to_ieee_rateid(t_u8 rate)
 	return rateUnit_500Kbps[rate];
 }
 
+/**
+ *  @brief	 sort cfp otp table
+ *
+ *  @param pmapdater	a pointer to mlan_adapter structure
+ *
+ *  @return
+ *    None
+ */
+static void wlan_sort_cfp_otp_table(mlan_adapter *pmadapter)
+{
+	t_u8 c, d;
+	chan_freq_power_t *ch1;
+	chan_freq_power_t *ch2;
+	chan_freq_power_t swap;
+
+	if (pmadapter->tx_power_table_a_rows <= 1)
+		return;
+	for (c = 0; c < pmadapter->tx_power_table_a_rows - 1; c++) {
+		for (d = 0; d < pmadapter->tx_power_table_a_rows - c - 1; d++) {
+			ch1 = (chan_freq_power_t *)(pmadapter->cfp_otp_a + d);
+			ch2 = (chan_freq_power_t *)(pmadapter->cfp_otp_a + d +
+						    1);
+			if (ch1->channel > ch2->channel) {
+				memcpy_ext(pmadapter, &swap, ch1,
+					   sizeof(chan_freq_power_t),
+					   sizeof(chan_freq_power_t));
+				memcpy_ext(pmadapter, ch1, ch2,
+					   sizeof(chan_freq_power_t),
+					   sizeof(chan_freq_power_t));
+				memcpy_ext(pmadapter, ch2, &swap,
+					   sizeof(chan_freq_power_t),
+					   sizeof(chan_freq_power_t));
+			}
+		}
+	}
+}
+
 /**
  *  @brief	Update CFP tables and power tables from FW
  *
@@ -3100,8 +3301,11 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 		PRINTM(MERROR, "CFP table update failed!\n");
 		goto out;
 	}
-	if (pmadapter->otp_region)
+	if (pmadapter->otp_region) {
+		memset(pmadapter, pmadapter->region_channel, 0,
+		       sizeof(pmadapter->region_channel));
 		wlan_free_fw_cfp_tables(pmadapter);
+	}
 	pmadapter->tx_power_table_bg_rows = FW_CFP_TABLE_MAX_ROWS_BG;
 	pmadapter->tx_power_table_bg_cols = FW_CFP_TABLE_MAX_COLS_BG;
 	pmadapter->tx_power_table_a_rows = FW_CFP_TABLE_MAX_ROWS_A;
@@ -3179,6 +3383,12 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 			pmadapter->domain_reg.country_code[1] =
 				pmadapter->otp_region->country_code[1];
 			pmadapter->domain_reg.country_code[2] = '\0';
+			PRINTM(MCMND,
+			       "OTP region: region_code=%d %c%c dfs_region=%d\n",
+			       pmadapter->otp_region->region_code,
+			       pmadapter->country_code[0],
+			       pmadapter->country_code[1],
+			       pmadapter->otp_region->dfs_region);
 			pmadapter->cfp_code_bg =
 				pmadapter->otp_region->region_code;
 			pmadapter->cfp_code_a =
@@ -3227,6 +3437,11 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 					(pmadapter->cfp_otp_bg + i)
 						->passive_scan_or_radar_detect =
 						MTRUE;
+				PRINTM(MCMD_D,
+				       "OTP Region (BG): chan=%d flags=0x%x\n",
+				       (pmadapter->cfp_otp_bg + i)->channel,
+				       (pmadapter->cfp_otp_bg + i)
+					       ->dynamic.flags);
 				data++;
 			}
 			ret = pcb->moal_malloc(
@@ -3258,10 +3473,18 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 				data++;
 				(pmadapter->cfp_otp_a + i)->dynamic.flags =
 					*data;
+				(pmadapter->cfp_otp_a + i)->dynamic.dfs_state =
+					DFS_USABLE;
 				if (*data & NXP_CHANNEL_DFS)
 					(pmadapter->cfp_otp_a + i)
 						->passive_scan_or_radar_detect =
 						MTRUE;
+				PRINTM(MCMD_D,
+				       "OTP Region (A): chan=%d flags=0x%x\n",
+				       (pmadapter->cfp_otp_a + i)->channel,
+				       (pmadapter->cfp_otp_a + i)
+					       ->dynamic.flags);
+
 				data++;
 			}
 			break;
@@ -3284,7 +3507,7 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 			while ((i <
 				pmadapter->tx_power_table_bg_rows *
 					pmadapter->tx_power_table_bg_cols) &&
-			       (i < tlv_buf_len) && (*tmp != 36)) {
+			       (i < tlv_buf_len)) {
 				i++;
 				tmp++;
 			}
@@ -3336,6 +3559,12 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 				((power_table_attr_t *)data)->rows_5g;
 			pmadapter->tx_power_table_a_cols =
 				((power_table_attr_t *)data)->cols_5g;
+			PRINTM(MCMD_D,
+			       "OTP region: bg_row=%d,bg_cols=%d a_row=%d, a_cols=%d\n",
+			       pmadapter->tx_power_table_bg_rows,
+			       pmadapter->tx_power_table_bg_cols,
+			       pmadapter->tx_power_table_a_rows,
+			       pmadapter->tx_power_table_a_cols);
 			break;
 		default:
 			break;
@@ -3366,7 +3595,8 @@ void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left)
 				NXP_CHANNEL_NO_OFDM;
 		}
 	}
-
+	if (pmadapter->cfp_otp_a)
+		wlan_sort_cfp_otp_table(pmadapter);
 out:
 	LEAVE();
 }
@@ -3475,6 +3705,13 @@ mlan_status wlan_get_cfpinfo(pmlan_adapter pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto out;
 	}
+	ret = wlan_11h_ioctl_nop_channel_list(pmadapter, pioctl_req);
+	if (ret) {
+		PRINTM(MERROR,
+		       "cfpinfo wlan_11h_ioctl_nop_channel_list failed!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto out;
+	}
 	/* Calculate the total response size required to return region,
 	 * country codes, cfp tables and power tables
 	 */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c
old mode 100644
new mode 100755
index ec27a4c3b..499f7bc73
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_cmdevt.c
@@ -4,7 +4,7 @@
  *  @brief This file contains the handling of CMD/EVENT in MLAN
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -57,6 +57,20 @@ Change Log:
 			Local Functions
 ********************************************************/
 #ifdef STA_SUPPORT
+/**
+ *  @brief This function check if the command was cancel scan command
+ *
+ *  @param pcmd    A pointer to HostCmd_DS_COMMAND structure
+ *  @return        N/A
+ */
+static t_u8 wlan_is_cancel_scan_cmd(HostCmd_DS_COMMAND *pcmd)
+{
+	HostCmd_DS_802_11_SCAN_EXT *pext_scan_cmd = &pcmd->params.ext_scan;
+	if (pext_scan_cmd->ext_scan_type == EXT_SCAN_CANCEL)
+		return MTRUE;
+	else
+		return MFALSE;
+}
 /**
  *  @brief This function inserts scan command node to scan_pending_q.
  *
@@ -83,6 +97,173 @@ static t_void wlan_queue_scan_cmd(mlan_private *pmpriv,
 	LEAVE();
 }
 
+/**
+ *  @brief This function check if cmd allowed to send to firmware
+ *         during scan
+ *
+ *  @param cmd_id     cmd id
+ *
+ *  @return           MTRUE/MFALSE
+ */
+static t_u8 wlan_is_cmd_allowed_during_scan(t_u16 cmd_id)
+{
+	t_u8 ret = MTRUE;
+	ENTER();
+	switch (cmd_id) {
+	case HostCmd_CMD_FUNC_INIT:
+	case HostCmd_CMD_CFG_DATA:
+	case HostCmd_CMD_REGION_POWER_CFG:
+	case HostCmd_CHANNEL_TRPC_CONFIG:
+	case HostCmd_CMD_FUNC_SHUTDOWN:
+	case HostCmd_CMD_802_11_ASSOCIATE:
+	case HostCmd_CMD_802_11_DEAUTHENTICATE:
+	case HostCmd_CMD_802_11_DISASSOCIATE:
+	case HostCmd_CMD_802_11_AD_HOC_START:
+	case HostCmd_CMD_802_11_AD_HOC_JOIN:
+	case HostCmd_CMD_802_11_AD_HOC_STOP:
+	case HostCmd_CMD_11N_ADDBA_REQ:
+	case HostCmd_CMD_11N_ADDBA_RSP:
+	case HostCmd_CMD_11N_DELBA:
+	case HostCmd_CMD_802_11_REMAIN_ON_CHANNEL:
+	case HostCmd_CMD_TDLS_CONFIG:
+	case HostCmd_CMD_TDLS_OPERATION:
+	case HostCmd_CMD_SOFT_RESET:
+#ifdef UAP_SUPPORT
+	case HOST_CMD_APCMD_SYS_RESET:
+	case HOST_CMD_APCMD_BSS_START:
+	case HOST_CMD_APCMD_BSS_STOP:
+	case HOST_CMD_APCMD_STA_DEAUTH:
+#endif
+	case HostCmd_CMD_802_11_BG_SCAN_CONFIG:
+	case HostCMD_APCMD_ACS_SCAN:
+		ret = MFALSE;
+		break;
+	default:
+		break;
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function move the cmd from ext_cmd_pending_q to
+ *        cmd_pending_q
+ *
+ *  @param cmd_id     cmd id
+ *
+ *  @return           MTRUE/MFALSE
+ */
+t_void wlan_move_cmd_to_cmd_pending_q(pmlan_adapter pmadapter)
+{
+	cmd_ctrl_node *pcmd_node = MNULL;
+
+	ENTER();
+
+	wlan_request_cmd_lock(pmadapter);
+	while ((pcmd_node = (cmd_ctrl_node *)util_peek_list(
+			pmadapter->pmoal_handle, &pmadapter->ext_cmd_pending_q,
+			MNULL, MNULL))) {
+		util_unlink_list(pmadapter->pmoal_handle,
+				 &pmadapter->ext_cmd_pending_q,
+				 (pmlan_linked_list)pcmd_node, MNULL, MNULL);
+		wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node, MTRUE);
+	}
+	wlan_release_cmd_lock(pmadapter);
+	LEAVE();
+}
+
+/**
+ *  @brief This function inserts scan command node to scan_cmd_pending_q.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param pcmd_node    A pointer to cmd_ctrl_node structure
+ *  @return             N/A
+ */
+static t_void wlan_queue_cmd_to_ext_cmd_pending_queue(mlan_private *pmpriv,
+						      cmd_ctrl_node *pcmd_node)
+{
+	mlan_adapter *pmadapter = pmpriv->adapter;
+
+	ENTER();
+
+	if (pcmd_node == MNULL)
+		goto done;
+
+	util_enqueue_list_tail(pmadapter->pmoal_handle,
+			       &pmadapter->ext_cmd_pending_q,
+			       (pmlan_linked_list)pcmd_node, MNULL, MNULL);
+
+done:
+	LEAVE();
+}
+
+/**
+ *  @brief Internal function used to flush the scan cmd pending queue
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *
+ *  @return             N/A
+ */
+t_void wlan_flush_ext_cmd_pending_queue(pmlan_adapter pmadapter)
+{
+	cmd_ctrl_node *pcmd_node = MNULL;
+	HostCmd_DS_COMMAND *pcmd = MNULL;
+	mlan_ioctl_req *pioctl_buf = MNULL;
+	pmlan_callbacks pcb = &pmadapter->callbacks;
+	ENTER();
+
+	wlan_request_cmd_lock(pmadapter);
+	while ((pcmd_node = (cmd_ctrl_node *)util_peek_list(
+			pmadapter->pmoal_handle, &pmadapter->ext_cmd_pending_q,
+			MNULL, MNULL))) {
+		util_unlink_list(pmadapter->pmoal_handle,
+				 &pmadapter->ext_cmd_pending_q,
+				 (pmlan_linked_list)pcmd_node, MNULL, MNULL);
+		pcmd = (HostCmd_DS_COMMAND *)(pcmd_node->cmdbuf->pbuf +
+					      pcmd_node->cmdbuf->data_offset);
+		PRINTM(MCMND, "flush ext_cmd_pending_queue: cmd 0x%02x\n",
+		       wlan_le16_to_cpu(pcmd->command));
+		if (pcmd_node->pioctl_buf) {
+			pioctl_buf = (mlan_ioctl_req *)pcmd_node->pioctl_buf;
+			pcmd_node->pioctl_buf = MNULL;
+			pioctl_buf->status_code = MLAN_ERROR_CMD_CANCEL;
+			pcb->moal_ioctl_complete(pmadapter->pmoal_handle,
+						 pioctl_buf,
+						 MLAN_STATUS_FAILURE);
+		}
+		wlan_insert_cmd_to_free_q(pmadapter, pcmd_node);
+	}
+	wlan_release_cmd_lock(pmadapter);
+	LEAVE();
+}
+
+/**
+ *  @brief This function inserts command node to scan_pending_q or
+ *  cmd_pending_q
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param pcmd_node    A pointer to cmd_ctrl_node structure
+ *  @return             N/A
+ */
+
+static t_void wlan_queue_cmd(mlan_private *pmpriv, cmd_ctrl_node *pcmd_node,
+			     t_u16 cmd_no)
+{
+	ENTER();
+	if (pmpriv->adapter->scan_processing &&
+	    pmpriv->adapter->ext_scan_type == EXT_SCAN_ENHANCE) {
+		if (MFALSE == wlan_is_cmd_allowed_during_scan(cmd_no)) {
+			PRINTM(MCMND, "QUEUE_CMD: cmd=0x%x ext_cmd_pending_q\n",
+			       cmd_no);
+			wlan_queue_cmd_to_ext_cmd_pending_queue(pmpriv,
+								pcmd_node);
+			return;
+		}
+	}
+	wlan_insert_cmd_to_pending_q(pmpriv->adapter, pcmd_node, MTRUE);
+	LEAVE();
+}
+
 /**
  *  @brief Internal function used to flush the scan pending queue
  *
@@ -90,7 +271,7 @@ static t_void wlan_queue_scan_cmd(mlan_private *pmpriv,
  *
  *  @return             N/A
  */
-void wlan_check_scan_queue(pmlan_adapter pmadapter)
+static void wlan_check_scan_queue(pmlan_adapter pmadapter)
 {
 	cmd_ctrl_node *pcmd_node = MNULL;
 	t_u16 num = 0;
@@ -156,19 +337,19 @@ static void wlan_dump_pending_commands(pmlan_adapter pmadapter)
  *
  *  @return     N/A
  */
-t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
+static t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 {
 	cmd_ctrl_node *pcmd_node = MNULL;
 #ifdef DEBUG_LEVEL1
 	t_u32 sec = 0, usec = 0;
 #endif
-	t_u8 i;
+	t_u16 i;
 #ifdef SDIO
 	t_u8 j;
-	t_u8 mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+	t_u8 mp_aggr_pkt_limit;
 #endif
 	t_u16 cmd_id, cmd_act;
-	mlan_private *pmpriv = MNULL;
+	mlan_private *pmpriv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
 
 	ENTER();
 
@@ -192,10 +373,12 @@ t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 	}
 	if ((reason == REASON_CODE_NO_CMD_NODE) &&
 	    (pmadapter->dbg.num_no_cmd_node > 1)) {
-		if (pmadapter->dbg.num_no_cmd_node >= 5)
-			wlan_recv_event(wlan_get_priv(pmadapter,
-						      MLAN_BSS_ROLE_ANY),
-					MLAN_EVENT_ID_DRV_DBG_DUMP, MNULL);
+		if (pmadapter->dbg.num_no_cmd_node >= 5) {
+			if (pmpriv)
+				wlan_recv_event(pmpriv,
+						MLAN_EVENT_ID_DRV_DBG_DUMP,
+						MNULL);
+		}
 		LEAVE();
 		return;
 	}
@@ -220,9 +403,13 @@ t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 				pcmd_buf = pcmd_node->cmdbuf->pbuf +
 					   pcmd_node->cmdbuf->data_offset +
 					   pmadapter->ops.intf_header_len;
-				for (i = 0; i < 16; i++)
-					PRINTM(MERROR, "%02x ", *pcmd_buf++);
-				PRINTM(MERROR, "\n");
+				if ((pmadapter->ops.intf_header_len + 16) >
+				    pcmd_node->cmdbuf->data_len) {
+					for (i = 0; i < 16; i++)
+						PRINTM(MERROR, "%02x ",
+						       *pcmd_buf++);
+					PRINTM(MERROR, "\n");
+				}
 			}
 #endif
 			pmpriv = pcmd_node->priv;
@@ -318,15 +505,23 @@ t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 	       pmadapter->pps_uapsd_mode, pmadapter->sleep_period.period);
 	PRINTM(MERROR, "tx_lock_flag = %d\n", pmadapter->tx_lock_flag);
 	PRINTM(MERROR, "scan_processing = %d\n", pmadapter->scan_processing);
+	PRINTM(MERROR, "scan_state = 0x%x\n", pmadapter->scan_state);
+	PRINTM(MERROR, "bypass_pkt_count=%d\n", pmadapter->bypass_pkt_count);
 #ifdef SDIO
 	if (IS_SD(pmadapter->card_type)) {
+		mp_aggr_pkt_limit = pmadapter->pcard_sd->mp_aggr_pkt_limit;
 		PRINTM(MERROR, "mp_rd_bitmap=0x%x curr_rd_port=0x%x\n",
 		       pmadapter->pcard_sd->mp_rd_bitmap,
 		       pmadapter->pcard_sd->curr_rd_port);
 		PRINTM(MERROR, "mp_wr_bitmap=0x%x curr_wr_port=0x%x\n",
 		       pmadapter->pcard_sd->mp_wr_bitmap,
 		       pmadapter->pcard_sd->curr_wr_port);
-		PRINTM(MERROR, "mp_invalid_update=%d\n",
+		PRINTM(MMSG, "mp_data_port_mask = 0x%x\n",
+		       pmadapter->pcard_sd->mp_data_port_mask);
+
+		PRINTM(MERROR,
+		       "last_recv_rd_bitmap=0x%x mp_invalid_update=%d\n",
+		       pmadapter->pcard_sd->last_recv_rd_bitmap,
 		       pmadapter->pcard_sd->mp_invalid_update);
 		PRINTM(MERROR, "last_recv_wr_bitmap=0x%x last_mp_index=%d\n",
 		       pmadapter->pcard_sd->last_recv_wr_bitmap,
@@ -360,9 +555,11 @@ t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 		       pmadapter->pcard_pcie->evtbd_wrptr);
 		PRINTM(MERROR, "last_wr_index:%d\n",
 		       pmadapter->pcard_pcie->txbd_wrptr &
-			       (MLAN_MAX_TXRX_BD - 1));
+			       (pmadapter->pcard_pcie->txrx_bd_size - 1));
+		PRINTM(MERROR, " txrx_bd_size = %d\n",
+		       pmadapter->pcard_pcie->txrx_bd_size);
 		PRINTM(MERROR, "Tx pkt size:\n");
-		for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
+		for (i = 0; i < pmadapter->pcard_pcie->txrx_bd_size; i++) {
 			PRINTM(MERROR, "%04d ",
 			       pmadapter->pcard_pcie->last_tx_pkt_size[i]);
 			if (((i + 1) % 16) == 0)
@@ -383,11 +580,15 @@ t_void wlan_dump_info(mlan_adapter *pmadapter, t_u8 reason)
 				wlan_recv_event(pmpriv,
 						MLAN_EVENT_ID_DRV_DBG_DUMP,
 						MNULL);
-			else
-				wlan_recv_event(
-					wlan_get_priv(pmadapter,
-						      MLAN_BSS_ROLE_ANY),
-					MLAN_EVENT_ID_DRV_DBG_DUMP, MNULL);
+			else {
+				pmpriv = wlan_get_priv(pmadapter,
+						       MLAN_BSS_ROLE_ANY);
+				if (pmpriv)
+					wlan_recv_event(
+						pmpriv,
+						MLAN_EVENT_ID_DRV_DBG_DUMP,
+						MNULL);
+			}
 		}
 	}
 	PRINTM(MERROR, "-------- Dump info End---------\n", reason);
@@ -422,7 +623,7 @@ static t_u32 wlan_hexval(t_u8 chr)
  *  @return             The converted hex value if param a is a valid hex, else
  * 0
  */
-int wlan_atox(t_u8 *a)
+static int wlan_atox(t_u8 *a)
 {
 	int i = 0;
 
@@ -479,7 +680,7 @@ static t_u32 wlan_parse_cal_cfg(t_u8 *src, t_size len, t_u8 *dst)
  *  @return             Location of the first occurrence of the char
  *                      if found, else NULL
  */
-t_u8 *wlan_strchr(t_u8 *s, int c)
+static t_u8 *wlan_strchr(t_u8 *s, int c)
 {
 	t_u8 *pos = s;
 	while (*pos != '\0') {
@@ -905,10 +1106,12 @@ static mlan_status wlan_ret_host_cmd(pmlan_private pmpriv,
  *  @param pmpriv       A pointer to mlan_private structure
  *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
  *  @param pdata_buf    A pointer to data buffer
+ *  @param cmd_no       A pointer to cmd_no
  *  @return             MLAN_STATUS_SUCCESS
  */
 static mlan_status wlan_cmd_host_cmd(pmlan_private pmpriv,
-				     HostCmd_DS_COMMAND *cmd, t_void *pdata_buf)
+				     HostCmd_DS_COMMAND *cmd, t_void *pdata_buf,
+				     t_u16 *cmd_no)
 {
 	mlan_ds_misc_cmd *pcmd_ptr = (mlan_ds_misc_cmd *)pdata_buf;
 
@@ -917,7 +1120,9 @@ static mlan_status wlan_cmd_host_cmd(pmlan_private pmpriv,
 	/* Copy the HOST command to command buffer */
 	memcpy_ext(pmpriv->adapter, (void *)cmd, pcmd_ptr->cmd, pcmd_ptr->len,
 		   MRVDRV_SIZE_OF_CMD_BUFFER);
-	PRINTM(MINFO, "Host command size = %d\n", pcmd_ptr->len);
+	*cmd_no = wlan_le16_to_cpu(cmd->command);
+	PRINTM(MCMND, "Prepare Host command: 0x%x size = %d\n", *cmd_no,
+	       pcmd_ptr->len);
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
@@ -929,9 +1134,9 @@ static mlan_status wlan_cmd_host_cmd(pmlan_private pmpriv,
  *
  *  @return           timeout value for this command
  */
-static t_u16 wlan_get_cmd_timeout(t_u16 cmd_id)
+static t_u32 wlan_get_cmd_timeout(t_u16 cmd_id)
 {
-	t_u16 timeout;
+	t_u32 timeout;
 	ENTER();
 	switch (cmd_id) {
 	case HostCmd_CMD_802_11_SCAN:
@@ -950,6 +1155,8 @@ static t_u16 wlan_get_cmd_timeout(t_u16 cmd_id)
 	case HostCmd_CMD_11N_ADDBA_RSP:
 	case HostCmd_CMD_11N_DELBA:
 	case HostCmd_CMD_802_11_REMAIN_ON_CHANNEL:
+	case HostCmd_CMD_TDLS_CONFIG:
+	case HostCmd_CMD_TDLS_OPERATION:
 	case HostCmd_CMD_SUPPLICANT_PMK:
 	case HostCmd_CMD_SUPPLICANT_PROFILE:
 	case HostCmd_CMD_SOFT_RESET:
@@ -963,7 +1170,22 @@ static t_u16 wlan_get_cmd_timeout(t_u16 cmd_id)
 		timeout = MRVDRV_TIMER_5S;
 		break;
 	default:
-		timeout = MRVDRV_TIMER_1S * 2;
+#ifdef IMX_SUPPORT
+		/*
+		 * During the roaming test and the 5AP connection test, cmd
+		 * timeout are observed for commands like 0x5e, 0x16, 0xd1.
+		 * Observed that response has come just after default timeout of
+		 * 2 seconds for these commands. This random timeout is not
+		 * observed when the default timeout is increased to 5 seconds
+		 * (As an work around, Increase the default timeout to 5
+		 * seconds. Need to further debug exact reason for delay in cmd
+		 * responses)
+		 *
+		 */
+		timeout = MRVDRV_TIMER_1S * 5;
+#else
+		timeout = MRVDRV_TIMER_1S * 5;
+#endif
 		break;
 	}
 	LEAVE();
@@ -995,7 +1217,7 @@ static mlan_status wlan_dnld_cmd_to_fw(mlan_private *pmpriv,
 #ifdef DEBUG_LEVEL1
 	t_u32 sec = 0, usec = 0;
 #endif
-	t_u16 timeout = 0;
+	t_u32 timeout = 0;
 
 	ENTER();
 
@@ -1082,6 +1304,9 @@ static mlan_status wlan_dnld_cmd_to_fw(mlan_private *pmpriv,
 	}
 #endif
 
+	if (pcmd->command == HostCmd_CMD_802_11_SCAN_EXT)
+		pmadapter->scan_state |= wlan_get_ext_scan_state(pcmd);
+
 	PRINTM_GET_SYS_TIME(MCMND, &sec, &usec);
 	PRINTM_NETINTF(MCMND, pmpriv);
 	PRINTM(MCMND,
@@ -1268,12 +1493,18 @@ static mlan_status wlan_dnld_sleep_confirm_cmd(mlan_adapter *pmadapter)
 		}
 #endif /* STA_SUPPORT */
 
-		PRINTM_NETINTF(MEVENT, pmpriv);
 #define NUM_SC_PER_LINE 16
-		if (++i % NUM_SC_PER_LINE == 0)
-			PRINTM(MEVENT, "+\n");
-		else
-			PRINTM(MEVENT, "+");
+		if (++i % NUM_SC_PER_LINE == 0) {
+			if (pmadapter->second_mac)
+				PRINTM(MEVENT, "++\n");
+			else
+				PRINTM(MEVENT, "+\n");
+		} else {
+			if (pmadapter->second_mac)
+				PRINTM(MEVENT, "++");
+			else
+				PRINTM(MEVENT, "+");
+		}
 	}
 
 done:
@@ -1281,6 +1512,25 @@ static mlan_status wlan_dnld_sleep_confirm_cmd(mlan_adapter *pmadapter)
 	return ret;
 }
 
+/**
+ *  @brief Fetch bitmap rate index
+ *
+ *  @param rate_scope	A pointer to MrvlRateScope_t
+ *
+ *  @return		bitmap rate index
+ */
+static t_u16 wlan_get_bitmap_index(MrvlRateScope_t *rate_scope)
+{
+	t_u16 index = 0;
+
+	if (rate_scope != MNULL) {
+		index += NELEMENTS(rate_scope->ht_mcs_rate_bitmap);
+		index += NELEMENTS(rate_scope->vht_mcs_rate_bitmap);
+	}
+
+	return index;
+}
+
 /********************************************************
 			Global Functions
 ********************************************************/
@@ -1357,7 +1607,6 @@ mlan_status wlan_alloc_cmd_buffer(mlan_adapter *pmadapter)
 	}
 
 	pmadapter->cmd_pool = pcmd_array;
-	memset(pmadapter, pmadapter->cmd_pool, 0, buf_size);
 
 #if defined(PCIE) || defined(SDIO)
 	if (!IS_USB(pmadapter->card_type)) {
@@ -1479,20 +1728,28 @@ mlan_status wlan_process_event(pmlan_adapter pmadapter)
 		(t_u16)eventcause;
 
 	if ((eventcause & EVENT_ID_MASK) == EVENT_RADAR_DETECTED) {
-		if (wlan_11h_dfs_event_preprocessing(pmadapter) ==
-		    MLAN_STATUS_SUCCESS) {
-			memcpy_ext(pmadapter, (t_u8 *)&eventcause,
-				   pmbuf->pbuf + pmbuf->data_offset,
-				   sizeof(eventcause), sizeof(eventcause));
-		} else {
-			priv = wlan_get_priv_by_id(
-				pmadapter, EVENT_GET_BSS_NUM(eventcause),
-				EVENT_GET_BSS_TYPE(eventcause));
-			if (priv)
-				PRINTM_NETINTF(MEVENT, priv);
-			PRINTM(MERROR, "Error processing DFS Event: 0x%x\n",
-			       eventcause);
-			goto done;
+		priv = wlan_get_priv_by_id(pmadapter,
+					   EVENT_GET_BSS_NUM(eventcause),
+					   EVENT_GET_BSS_TYPE(eventcause));
+		if (priv && priv->bss_type != MLAN_BSS_TYPE_DFS) {
+			if (wlan_11h_dfs_event_preprocessing(pmadapter) ==
+			    MLAN_STATUS_SUCCESS) {
+				memcpy_ext(pmadapter, (t_u8 *)&eventcause,
+					   pmbuf->pbuf + pmbuf->data_offset,
+					   sizeof(eventcause),
+					   sizeof(eventcause));
+			} else {
+				priv = wlan_get_priv_by_id(
+					pmadapter,
+					EVENT_GET_BSS_NUM(eventcause),
+					EVENT_GET_BSS_TYPE(eventcause));
+				if (priv)
+					PRINTM_NETINTF(MEVENT, priv);
+				PRINTM(MERROR,
+				       "Error processing DFS Event: 0x%x\n",
+				       eventcause);
+				goto done;
+			}
 		}
 	}
 	/* Get BSS number and corresponding priv */
@@ -1667,7 +1924,7 @@ mlan_status wlan_prepare_cmd(mlan_private *pmpriv, t_u16 cmd_no,
 					      cmd_oid, pioctl_buf, pdata_buf,
 					      cmd_ptr);
 	else {
-		ret = wlan_cmd_host_cmd(pmpriv, cmd_ptr, pdata_buf);
+		ret = wlan_cmd_host_cmd(pmpriv, cmd_ptr, pdata_buf, &cmd_no);
 		pcmd_node->cmd_flag |= CMD_F_HOSTCMD;
 	}
 
@@ -1692,10 +1949,12 @@ mlan_status wlan_prepare_cmd(mlan_private *pmpriv, t_u16 cmd_no,
 	    cmd_no == HostCmd_CMD_802_11_SCAN_EXT) {
 		if (cmd_no == HostCmd_CMD_802_11_SCAN_EXT &&
 		    pmadapter->ext_scan && pmadapter->ext_scan_enh &&
-		    pmadapter->ext_scan_type == EXT_SCAN_ENHANCE) {
+		    pmadapter->ext_scan_type == EXT_SCAN_ENHANCE &&
+		    wlan_is_cancel_scan_cmd(cmd_ptr)) {
 			wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node,
 						     MFALSE);
 		} else
+
 			wlan_queue_scan_cmd(pmpriv, pcmd_node);
 	} else {
 #endif
@@ -1705,8 +1964,7 @@ mlan_status wlan_prepare_cmd(mlan_private *pmpriv, t_u16 cmd_no,
 			wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node,
 						     MFALSE);
 		else
-			wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node,
-						     MTRUE);
+			wlan_queue_cmd(pmpriv, pcmd_node, cmd_no);
 #ifdef STA_SUPPORT
 	}
 #endif
@@ -2035,7 +2293,8 @@ mlan_status wlan_process_cmdresp(mlan_adapter *pmadapter)
 	if (pmadapter->hw_status == WlanHardwareStatusInitializing ||
 	    pmadapter->hw_status == WlanHardwareStatusGetHwSpec) {
 		if (ret == MLAN_STATUS_FAILURE) {
-#ifdef STA_SUPPORT
+#if 0
+            //ignore command error for WARM RESET
 			if (pmadapter->pwarm_reset_ioctl_req) {
 				/* warm reset failure */
 				pmadapter->pwarm_reset_ioctl_req->status_code =
@@ -2060,9 +2319,7 @@ mlan_status wlan_process_cmdresp(mlan_adapter *pmadapter)
 		if (IS_PCIE(pmadapter->card_type) &&
 		    cmdresp_no == HostCmd_CMD_FUNC_SHUTDOWN &&
 		    pmadapter->pwarm_reset_ioctl_req) {
-#if defined(PCIE9098) || defined(PCIE9097)
 			if (pmadapter->pcard_pcie->reg->use_adma)
-#endif
 				wlan_pcie_init_fw(pmadapter);
 		}
 #endif
@@ -2090,12 +2347,23 @@ mlan_status wlan_process_cmdresp(mlan_adapter *pmadapter)
 		i = pmpriv->bss_index + 1;
 		while (i < pmadapter->priv_num &&
 		       (!(pmpriv_next = pmadapter->priv[i]) ||
-			pmpriv_next->bss_virtual))
+			pmpriv_next->bss_virtual ||
+			pmpriv_next->bss_type == MLAN_BSS_TYPE_DFS))
 			i++;
 		if (!pmpriv_next || i >= pmadapter->priv_num) {
 #ifdef STA_SUPPORT
 			if (pmadapter->pwarm_reset_ioctl_req) {
+				for (i = 0; i < pmadapter->priv_num; i++) {
+					if (pmadapter->priv[i]->curr_addr[0] ==
+					    0xff)
+						memmove(pmadapter,
+							pmadapter->priv[i]
+								->curr_addr,
+							pmadapter->permanent_addr,
+							MLAN_MAC_ADDR_LENGTH);
+				}
 				/* warm reset complete */
+				PRINTM(MMSG, "wlan: warm reset complete\n");
 				pmadapter->hw_status = WlanHardwareStatusReady;
 				pcb->moal_ioctl_complete(
 					pmadapter->pmoal_handle,
@@ -2174,9 +2442,12 @@ t_void wlan_cmd_timeout_func(t_void *function_context)
 		pcmd_buf = pcmd_node->cmdbuf->pbuf +
 			   pcmd_node->cmdbuf->data_offset +
 			   pmadapter->ops.intf_header_len;
-		for (i = 0; i < 16; i++)
-			PRINTM(MERROR, "%02x ", *pcmd_buf++);
-		PRINTM(MERROR, "\n");
+		if ((pmadapter->ops.intf_header_len + 16) <
+		    pcmd_node->cmdbuf->data_len) {
+			for (i = 0; i < 16; i++)
+				PRINTM(MERROR, "%02x ", *pcmd_buf++);
+			PRINTM(MERROR, "\n");
+		}
 	}
 #endif
 #ifdef PCIE
@@ -2220,7 +2491,10 @@ t_void wlan_cmd_timeout_func(t_void *function_context)
 t_void wlan_flush_scan_queue(pmlan_adapter pmadapter)
 {
 	cmd_ctrl_node *pcmd_node = MNULL;
-
+	mlan_ioctl_req *pioctl_buf = MNULL;
+	HostCmd_DS_COMMAND *pcmd = MNULL;
+	t_u16 cmd_no = 0;
+	pmlan_callbacks pcb = &pmadapter->callbacks;
 	ENTER();
 
 	wlan_request_cmd_lock(pmadapter);
@@ -2230,7 +2504,20 @@ t_void wlan_flush_scan_queue(pmlan_adapter pmadapter)
 		util_unlink_list(pmadapter->pmoal_handle,
 				 &pmadapter->scan_pending_q,
 				 (pmlan_linked_list)pcmd_node, MNULL, MNULL);
-		pcmd_node->pioctl_buf = MNULL;
+		pcmd = (HostCmd_DS_COMMAND *)(pcmd_node->cmdbuf->pbuf +
+					      pcmd_node->cmdbuf->data_offset);
+		cmd_no = wlan_le16_to_cpu(pcmd->command);
+		PRINTM(MCMND, "flush scan queue: cmd 0x%02x\n", cmd_no);
+		if (pcmd_node->pioctl_buf &&
+		    cmd_no != HostCmd_CMD_802_11_SCAN &&
+		    cmd_no != HostCmd_CMD_802_11_SCAN_EXT) {
+			pioctl_buf = (mlan_ioctl_req *)pcmd_node->pioctl_buf;
+			pcmd_node->pioctl_buf = MNULL;
+			pioctl_buf->status_code = MLAN_ERROR_CMD_CANCEL;
+			pcb->moal_ioctl_complete(pmadapter->pmoal_handle,
+						 pioctl_buf,
+						 MLAN_STATUS_FAILURE);
+		}
 		wlan_insert_cmd_to_free_q(pmadapter, pcmd_node);
 	}
 
@@ -2296,18 +2583,19 @@ mlan_status wlan_cancel_pending_scan_cmd(pmlan_adapter pmadapter,
 	if (pmadapter->scan_processing &&
 	    pmadapter->ext_scan_type == EXT_SCAN_ENHANCE) {
 		if (priv) {
-			if (MLAN_STATUS_FAILURE ==
+			if (MLAN_STATUS_SUCCESS ==
 			    wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SCAN_EXT,
 					     HostCmd_ACT_GEN_SET, 0, pioctl_req,
-					     MNULL))
-				PRINTM(MERROR, "Failed to prepare command");
-			wlan_recv_event(priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
+					     MNULL)) {
+				wlan_recv_event(
+					priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
 					MNULL);
-			status = MLAN_STATUS_PENDING;
+				status = MLAN_STATUS_PENDING;
+			}
 		}
-	} else
-		/* Cancel all pending scan command */
-		wlan_flush_scan_queue(pmadapter);
+	}
+	/* Cancel all pending scan command */
+	wlan_flush_scan_queue(pmadapter);
 	LEAVE();
 	return status;
 }
@@ -2348,11 +2636,11 @@ t_void wlan_cancel_all_pending_cmd(pmlan_adapter pmadapter, t_u8 flag)
 		pcmd_node = pmadapter->curr_cmd;
 		if (pcmd_node->pioctl_buf) {
 			pioctl_buf = (mlan_ioctl_req *)pcmd_node->pioctl_buf;
+			pcmd_node->pioctl_buf = MNULL;
 			pioctl_buf->status_code = MLAN_ERROR_CMD_CANCEL;
 			pcb->moal_ioctl_complete(pmadapter->pmoal_handle,
 						 pioctl_buf,
 						 MLAN_STATUS_FAILURE);
-			pcmd_node->pioctl_buf = MNULL;
 		}
 		if (flag) {
 			pmadapter->curr_cmd = MNULL;
@@ -2378,22 +2666,10 @@ t_void wlan_cancel_all_pending_cmd(pmlan_adapter pmadapter, t_u8 flag)
 		wlan_insert_cmd_to_free_q(pmadapter, pcmd_node);
 	}
 	wlan_release_cmd_lock(pmadapter);
-#ifdef STA_SUPPORT
-	if (pmadapter->scan_processing &&
-	    pmadapter->ext_scan_type == EXT_SCAN_ENHANCE) {
-		if (priv) {
-			if (MLAN_STATUS_FAILURE ==
-			    wlan_prepare_cmd(priv, HostCmd_CMD_802_11_SCAN_EXT,
-					     HostCmd_ACT_GEN_SET, 0, MNULL,
-					     MNULL))
-				PRINTM(MERROR, "Failed to prepare command");
-			wlan_recv_event(priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
-					MNULL);
-		}
-	} else
-		/* Cancel all pending scan command */
-		wlan_flush_scan_queue(pmadapter);
-#endif
+	/* Cancel all pending scan command */
+	wlan_flush_scan_queue(pmadapter);
+	/* Cancel all pending command in scan_cmd_pending_q command */
+	wlan_flush_ext_cmd_pending_queue(pmadapter);
 	LEAVE();
 }
 
@@ -2483,9 +2759,9 @@ t_void wlan_cancel_bss_pending_cmd(pmlan_adapter pmadapter, t_u32 bss_index)
 					priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
 					MNULL);
 			}
-		} else
-			/* Cancel all pending scan command */
-			wlan_flush_scan_queue(pmadapter);
+		}
+		/* Cancel all pending scan command */
+		wlan_flush_scan_queue(pmadapter);
 	}
 #endif
 	LEAVE();
@@ -2560,9 +2836,9 @@ t_void wlan_cancel_pending_ioctl(pmlan_adapter pmadapter,
 					priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
 					MNULL);
 			}
-		} else
-			/* Cancel all pending scan command */
-			wlan_flush_scan_queue(pmadapter);
+		}
+		/* Cancel all pending scan command */
+		wlan_flush_scan_queue(pmadapter);
 	}
 #endif
 	if (find) {
@@ -2627,26 +2903,486 @@ t_void wlan_fill_hal_wifi_rate(pmlan_private pmpriv, mlan_wifi_rate *pmlan_rate,
 }
 
 /**
- *  @brief Handle the version_ext resp
+ *  @brief This function prepares command of ftm config session params.
  *
  *  @param pmpriv       A pointer to mlan_private structure
- *  @param resp         A pointer to HostCmd_DS_COMMAND
- *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   The action: GET or SET
+ *  @param cmd_oid      OID: CONFIG or CANCEL
+ *  @param pdata_buf    A pointer to data buffer
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_ret_ver_ext(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
-			     mlan_ioctl_req *pioctl_buf)
+mlan_status wlan_cmd_802_11_ftm_config_session_params(pmlan_private pmpriv,
+						      HostCmd_DS_COMMAND *cmd,
+						      t_u16 cmd_action,
+						      t_u32 cmd_oid,
+						      t_void *pdata_buf)
 {
-	HostCmd_DS_VERSION_EXT *ver_ext = &resp->params.verext;
-	mlan_ds_get_info *info;
+	HostCmd_DS_FTM_CONFIG_SESSION_PARAMS *ftm_config =
+		&cmd->params.ftm_config;
+	t_u8 *tlv = MNULL;
+	mlan_rtt_config_params *rtt_params = MNULL;
+	MrvlIEtypes_RTTRangeRequest_t *tlv_rtt_rr = MNULL;
+	mlan_rtt_cancel_params *rtt_cancel = MNULL;
+	MrvlIEtypes_RTTRangeCancel_t *tlv_rtt_rc = MNULL;
+	t_u32 i = 0;
+
 	ENTER();
-	if (pioctl_buf) {
-		info = (mlan_ds_get_info *)pioctl_buf->pbuf;
-		info->param.ver_ext.version_str_sel = ver_ext->version_str_sel;
-		memcpy_ext(pmpriv->adapter, info->param.ver_ext.version_str,
-			   ver_ext->version_str, sizeof(char) * 128,
-			   sizeof(char) * MLAN_MAX_VER_STR_LEN);
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS);
+	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_FTM_CONFIG_SESSION_PARAMS);
+
+	ftm_config->action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+	tlv = ftm_config->tlv_buffer;
+
+	if (cmd_oid == OID_RTT_REQUEST) {
+		rtt_params = (mlan_rtt_config_params *)pdata_buf;
+		for (i = 0; i < rtt_params->rtt_config_num; i++) {
+			tlv_rtt_rr = (MrvlIEtypes_RTTRangeRequest_t *)tlv;
+			tlv_rtt_rr->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_RTT_RANGE_REQUEST);
+			tlv_rtt_rr->header.len =
+				wlan_cpu_to_le16((sizeof(*tlv_rtt_rr) -
+						  sizeof(MrvlIEtypesHeader_t)));
+			memcpy_ext(pmpriv->adapter, tlv_rtt_rr->addr,
+				   rtt_params->rtt_config[i].addr,
+				   sizeof(rtt_params->rtt_config[i].addr),
+				   sizeof(tlv_rtt_rr->addr));
+			tlv_rtt_rr->type = rtt_params->rtt_config[i].type;
+			tlv_rtt_rr->peer = rtt_params->rtt_config[i].peer;
+			tlv_rtt_rr->channel = rtt_params->rtt_config[i].channel;
+			tlv_rtt_rr->bandcfg = rtt_params->rtt_config[i].bandcfg;
+			tlv_rtt_rr->burst_period =
+				rtt_params->rtt_config[i].burst_period;
+			tlv_rtt_rr->num_burst =
+				rtt_params->rtt_config[i].num_burst;
+			tlv_rtt_rr->num_frames_per_burst =
+				rtt_params->rtt_config[i].num_frames_per_burst;
+			tlv_rtt_rr->num_retries_per_rtt_frame =
+				rtt_params->rtt_config[i]
+					.num_retries_per_rtt_frame;
+			tlv_rtt_rr->num_retries_per_ftmr =
+				rtt_params->rtt_config[i].num_retries_per_ftmr;
+			tlv_rtt_rr->LCI_request =
+				rtt_params->rtt_config[i].LCI_request;
+			tlv_rtt_rr->LCR_request =
+				rtt_params->rtt_config[i].LCR_request;
+			tlv_rtt_rr->burst_duration =
+				rtt_params->rtt_config[i].burst_duration;
+			tlv_rtt_rr->preamble =
+				rtt_params->rtt_config[i].preamble;
+			tlv_rtt_rr->bw = rtt_params->rtt_config[i].bw;
+			cmd->size += sizeof(*tlv_rtt_rr);
+			tlv += sizeof(*tlv_rtt_rr);
+		}
+	} else if (cmd_oid == OID_RTT_CANCEL) {
+		rtt_cancel = (mlan_rtt_cancel_params *)pdata_buf;
+		for (i = 0; i < rtt_cancel->rtt_cancel_num; i++) {
+			tlv_rtt_rc = (MrvlIEtypes_RTTRangeCancel_t *)tlv;
+			tlv_rtt_rc->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_RTT_RANGE_CANCEL);
+			tlv_rtt_rc->header.len =
+				wlan_cpu_to_le16(sizeof(*tlv_rtt_rc) -
+						 sizeof(MrvlIEtypesHeader_t));
+			memcpy_ext(pmpriv->adapter, tlv_rtt_rc->addr,
+				   rtt_cancel->rtt_cancel[i],
+				   sizeof(rtt_cancel->rtt_cancel[i]),
+				   sizeof(tlv_rtt_rc->addr));
+			cmd->size += sizeof(*tlv_rtt_rc);
+			tlv += sizeof(*tlv_rtt_rc);
+		}
+	} else {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of ftm config session
+ * params.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status
+wlan_ret_802_11_ftm_config_session_params(pmlan_private pmpriv,
+					  HostCmd_DS_COMMAND *resp,
+					  mlan_ioctl_req *pioctl_buf)
+{
+	ENTER();
+
+	PRINTM(MCMND, "ftm config successfully\n");
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function transform Event_WLS_FTM_t to wifi_rtt_result in
+ * mlan_event.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param event_ftm  A pointer to Event_WLS_FTM_t
+ *  @param event_ftm_len   length of event_ftm
+ *  @param pevent       A pointer to mlan_event
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_fill_hal_rtt_results(pmlan_private pmpriv,
+				      Event_WLS_FTM_t *event_ftm,
+				      t_u32 event_ftm_len, mlan_event *pevent)
+{
+	/** For input buffer Event_WLS_FTM_t */
+	t_u8 *tlv = event_ftm->u.rtt_results.tlv_buffer;
+	int event_left_len = event_ftm_len - (tlv - (t_u8 *)event_ftm);
+	MrvlIEtypes_RTTResult_t *tlv_rtt_result = MNULL;
+	t_u16 tlv_rtt_result_len = 0;
+	IEEEtypes_Header_t *tlv_ie = MNULL;
+	int tlv_ie_len = 0;
+	int tlv_left_len = 0;
+	t_u8 *tlv_pos = MNULL;
+	/** For output buffer mlan_event */
+	t_u8 *pos = pevent->event_buf;
+	wifi_rtt_result_element *rtt_result_elem = MNULL;
+	wifi_rtt_result *rtt_result = MNULL;
+	t_u32 i = 0;
+
+	ENTER();
+	PRINTM(MCMND,
+	       "wlan_fill_hal_rtt_results event_ftm_len=%d event_left_len=%d event_ftm=%p tlv=%p\n",
+	       event_ftm_len, event_left_len, event_ftm, tlv);
+
+	pevent->event_id = MLAN_EVENT_ID_DRV_RTT_RESULT;
+
+	/** Event format for moal is: [complete(u8)] + [multiple number of rtt
+	 * result(len(u16) + body)] */
+
+	/** [complete(u8)] */
+	*pos = event_ftm->u.rtt_results.complete;
+	pos += sizeof(event_ftm->u.rtt_results.complete);
+
+	/** multiple number of rtt result(wifi_rtt_result_element) */
+	/** Fill rtt results, 1 tlv at least contain 1 MrvlIEtypes_RTTResult_t
+	 */
+	while (event_left_len >= sizeof(MrvlIEtypes_RTTResult_t)) {
+		PRINTM(MCMND, "[%d] event_left_len=%d tlv=%p\n", i,
+		       event_left_len, tlv);
+		tlv_rtt_result = (MrvlIEtypes_RTTResult_t *)tlv;
+		tlv_rtt_result_len =
+			wlan_le16_to_cpu(tlv_rtt_result->header.len);
+
+		rtt_result_elem = (wifi_rtt_result_element *)pos;
+		pos += sizeof(*rtt_result_elem);
+
+		rtt_result = (wifi_rtt_result *)(rtt_result_elem->data);
+		memcpy_ext(pmpriv->adapter, rtt_result->addr,
+			   tlv_rtt_result->addr, sizeof(tlv_rtt_result->addr),
+			   sizeof(rtt_result->addr));
+		rtt_result->burst_num =
+			wlan_le32_to_cpu(tlv_rtt_result->burst_num);
+		rtt_result->measurement_number =
+			wlan_le32_to_cpu(tlv_rtt_result->measurement_number);
+		rtt_result->success_number =
+			wlan_le32_to_cpu(tlv_rtt_result->success_number);
+		rtt_result->number_per_burst_peer =
+			tlv_rtt_result->number_per_burst_peer;
+		rtt_result->status = tlv_rtt_result->status;
+		rtt_result->retry_after_duration =
+			tlv_rtt_result->retry_after_duration;
+		rtt_result->type = tlv_rtt_result->type;
+		rtt_result->rssi = wlan_le32_to_cpu(tlv_rtt_result->rssi);
+		rtt_result->rssi_spread =
+			wlan_le32_to_cpu(tlv_rtt_result->rssi_spread);
+		wlan_fill_hal_wifi_rate(pmpriv, &tlv_rtt_result->tx_rate,
+					&rtt_result->tx_rate);
+		wlan_fill_hal_wifi_rate(pmpriv, &tlv_rtt_result->rx_rate,
+					&rtt_result->rx_rate);
+		rtt_result->rtt = wlan_le64_to_cpu(tlv_rtt_result->rtt);
+		rtt_result->rtt_sd = wlan_le64_to_cpu(tlv_rtt_result->rtt_sd);
+		rtt_result->rtt_spread =
+			wlan_le64_to_cpu(tlv_rtt_result->rtt_spread);
+		rtt_result->distance_mm =
+			wlan_le32_to_cpu(tlv_rtt_result->distance_mm);
+		rtt_result->distance_sd_mm =
+			wlan_le32_to_cpu(tlv_rtt_result->distance_sd_mm);
+		rtt_result->distance_spread_mm =
+			wlan_le32_to_cpu(tlv_rtt_result->distance_spread_mm);
+		rtt_result->ts = wlan_le64_to_cpu(tlv_rtt_result->ts);
+		rtt_result->burst_duration =
+			wlan_le32_to_cpu(tlv_rtt_result->burst_duration);
+		rtt_result->negotiated_burst_num =
+			wlan_le32_to_cpu(tlv_rtt_result->negotiated_burst_num);
+		pos += sizeof(*rtt_result);
+
+		tlv_ie = (IEEEtypes_Header_t *)(tlv_rtt_result->tlv_buffer);
+		tlv_pos = (t_u8 *)tlv_ie;
+		tlv_left_len =
+			tlv_rtt_result_len - (sizeof(*tlv_rtt_result) -
+					      sizeof(tlv_rtt_result->header));
+		PRINTM(MCMND, "tlv_ie=%p tlv_left_len=%d\n", tlv_ie,
+		       tlv_left_len);
+		/** Get the standard IEEEIE: MEASUREMENT_REPORT for LCI/LCR*/
+		while ((tlv_left_len > 0) && (tlv_left_len > sizeof(*tlv_ie))) {
+			tlv_ie_len = tlv_ie->len;
+			PRINTM(MCMND,
+			       "[-] tlv_ie=%p tlv_ie_len=%d   tlv_left_len=%d  jump=%d\n",
+			       tlv_ie, tlv_ie_len, tlv_left_len,
+			       sizeof(*tlv_ie) + tlv_ie_len);
+			if ((tlv_ie_len > 0) &&
+			    (tlv_ie->element_id == MEASUREMENT_REPORT)) {
+				PRINTM(MCMND, "LCI/LCR IE: id=%d len=%d\n",
+				       tlv_ie->element_id, tlv_ie->len);
+				memcpy_ext(pmpriv->adapter, pos, (t_u8 *)tlv_ie,
+					   sizeof(*tlv_ie) + tlv_ie_len,
+					   sizeof(*tlv_ie) + tlv_ie_len);
+				pos += sizeof(*tlv_ie) + tlv_ie_len;
+			}
+			tlv_left_len -= sizeof(*tlv_ie) + tlv_ie_len;
+			tlv_pos += sizeof(*tlv_ie) + tlv_ie_len;
+			tlv_ie = (IEEEtypes_Header_t *)tlv_pos;
+			PRINTM(MCMND,
+			       "[+] tlv_ie=%p tlv_ie_len=%d   tlv_left_len=%d \n",
+			       tlv_ie, tlv_ie_len, tlv_left_len);
+		}
+
+		rtt_result_elem->len = pos - rtt_result_elem->data;
+
+		tlv += tlv_rtt_result_len + sizeof(tlv_rtt_result->header);
+		event_left_len -=
+			tlv_rtt_result_len + sizeof(tlv_rtt_result->header);
+		i++;
+	}
+
+	/** event_len include the mlan_event header and payload */
+	pevent->event_len = pos - pevent->event_buf;
+	PRINTM(MCMND, "pevent->event_len=%d \n", pevent->event_len);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of ftm config responder.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_802_11_ftm_config_responder(pmlan_private pmpriv,
+						 HostCmd_DS_COMMAND *cmd,
+						 t_u16 cmd_action,
+						 t_u32 cmd_oid,
+						 t_void *pdata_buf)
+{
+	mlan_rtt_responder *rtt_rsp_cfg = (mlan_rtt_responder *)pdata_buf;
+	HostCmd_DS_FTM_CONFIG_RESPONDER *responder =
+		&cmd->params.ftm_rtt_responder;
+	t_u8 *tlv = responder->tlv_buffer;
+	MrvlIEtypes_RTTResponderEnCfg_t *tlv_rsp_en = MNULL;
+	MrvlIEtypes_RTTLCICfg_t *tlv_lci = MNULL;
+	MrvlIEtypes_RTTLCRCfg_t *tlv_lcr = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_FTM_CONFIG_RESPONDER);
+	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_FTM_CONFIG_RESPONDER);
+
+	switch (rtt_rsp_cfg->action) {
+	case RTT_GET_RESPONDER_INFO:
+		responder->action =
+			wlan_cpu_to_le16(HostCmd_ACT_RTT_GET_RSP_INFO);
+		break;
+	case RTT_SET_RESPONDER_ENABLE:
+		tlv_rsp_en = (MrvlIEtypes_RTTResponderEnCfg_t *)tlv;
+		responder->action =
+			wlan_cpu_to_le16(HostCmd_ACT_RTT_SET_RSP_EN);
+		tlv_rsp_en->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_RTT_RESPONDER_EN_CFG);
+		tlv_rsp_en->header.len = wlan_cpu_to_le16(
+			sizeof(*tlv_rsp_en) - sizeof(MrvlIEtypesHeader_t));
+		tlv_rsp_en->channel = rtt_rsp_cfg->u.encfg.channel;
+		tlv_rsp_en->bandcfg = rtt_rsp_cfg->u.encfg.bandcfg;
+		tlv_rsp_en->max_duration_seconds =
+			wlan_cpu_to_le32(rtt_rsp_cfg->u.encfg.max_dur_sec);
+		cmd->size += sizeof(*tlv_rsp_en);
+		break;
+	case RTT_SET_RESPONDER_DISABLE:
+		responder->action =
+			wlan_cpu_to_le16(HostCmd_ACT_RTT_SET_RSP_DIS);
+		break;
+	case RTT_SET_RESPONDER_LCI:
+		tlv_lci = (MrvlIEtypes_RTTLCICfg_t *)tlv;
+		responder->action =
+			wlan_cpu_to_le16(HostCmd_ACT_RTT_SET_RSP_LCI);
+		tlv_lci->header.type = wlan_cpu_to_le16(TLV_TYPE_RTT_LCI_CFG);
+		tlv_lci->header.len = wlan_cpu_to_le16(
+			sizeof(*tlv_lci) - sizeof(MrvlIEtypesHeader_t));
+		tlv_lci->latitude =
+			wlan_cpu_to_le64(rtt_rsp_cfg->u.lci.latitude);
+		tlv_lci->longitude =
+			wlan_cpu_to_le64(rtt_rsp_cfg->u.lci.longitude);
+		tlv_lci->altitude =
+			wlan_cpu_to_le32(rtt_rsp_cfg->u.lci.altitude);
+		tlv_lci->latitude_unc = rtt_rsp_cfg->u.lci.latitude_unc;
+		tlv_lci->longitude_unc = rtt_rsp_cfg->u.lci.longitude_unc;
+		tlv_lci->altitude_unc = rtt_rsp_cfg->u.lci.altitude_unc;
+		tlv_lci->motion_pattern = rtt_rsp_cfg->u.lci.motion_pattern;
+		tlv_lci->floor = wlan_cpu_to_le32(rtt_rsp_cfg->u.lci.floor);
+		tlv_lci->height_above_floor =
+			wlan_cpu_to_le32(rtt_rsp_cfg->u.lci.height_above_floor);
+		tlv_lci->height_unc =
+			wlan_cpu_to_le32(rtt_rsp_cfg->u.lci.height_unc);
+		cmd->size += sizeof(*tlv_lci);
+		break;
+	case RTT_SET_RESPONDER_LCR:
+		tlv_lcr = (MrvlIEtypes_RTTLCRCfg_t *)tlv;
+		responder->action =
+			wlan_cpu_to_le16(HostCmd_ACT_RTT_SET_RSP_LCR);
+		tlv_lcr->header.type = wlan_cpu_to_le16(TLV_TYPE_RTT_LCR_CFG);
+		tlv_lcr->header.len = wlan_cpu_to_le16(
+			sizeof(*tlv_lcr) - sizeof(MrvlIEtypesHeader_t));
+		memcpy_ext(pmpriv->adapter, tlv_lcr->country_code,
+			   rtt_rsp_cfg->u.lcr.country_code,
+			   sizeof(rtt_rsp_cfg->u.lcr.country_code),
+			   sizeof(tlv_lcr->country_code));
+		tlv_lcr->length = wlan_cpu_to_le32(rtt_rsp_cfg->u.lcr.length);
+		memcpy_ext(pmpriv->adapter, tlv_lcr->civic_info,
+			   rtt_rsp_cfg->u.lcr.civic_info,
+			   sizeof(rtt_rsp_cfg->u.lcr.civic_info),
+			   sizeof(tlv_lcr->civic_info));
+		cmd->size += sizeof(*tlv_lcr);
+		break;
+	default:
+		PRINTM(MERROR,
+		       "wlan_cmd_802_11_ftm_config_responder: action not found\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+		break;
+	}
+
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function handles the command response of ftm config responder
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_802_11_ftm_config_responder(pmlan_private pmpriv,
+						 HostCmd_DS_COMMAND *resp,
+						 mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)(pioctl_buf->pbuf);
+	mlan_rtt_responder *rtt_rsp_cfg = &(misc->param.rtt_rsp_cfg);
+	HostCmd_DS_FTM_CONFIG_RESPONDER *responder = MNULL;
+	t_u32 cmdrsp_len = wlan_le16_to_cpu(resp->size);
+	int left_len = 0;
+	t_u8 *tlv = MNULL;
+	MrvlIEtypes_RTTResponderInfo_t *tlv_rsp_info = MNULL;
+
+	ENTER();
+
+	PRINTM(MCMND, "ftm config responder successfully cmdrsp_len=%d\n",
+	       cmdrsp_len);
+
+	if ((cmdrsp_len < S_DS_GEN) ||
+	    (cmdrsp_len - S_DS_GEN < sizeof(HostCmd_DS_FTM_CONFIG_RESPONDER)))
+		goto done;
+
+	responder = &resp->params.ftm_rtt_responder;
+	left_len = cmdrsp_len - (S_DS_GEN + sizeof(*responder));
+	PRINTM(MCMND, "left_len=%d\n", left_len);
+
+	tlv = responder->tlv_buffer;
+	while ((left_len > 0) && (left_len > sizeof(MrvlIEtypesHeader_t))) {
+		PRINTM(MCMND, "left_len=%d tlv: type=0x%x len=%d\n", left_len,
+		       ((MrvlIEtypesHeader_t *)tlv)->type,
+		       ((MrvlIEtypesHeader_t *)tlv)->len);
+		if (((MrvlIEtypesHeader_t *)tlv)->type ==
+		    TLV_TYPE_RTT_RESPONDER_INFO) {
+			if (((MrvlIEtypesHeader_t *)tlv)->len >=
+			    (sizeof(MrvlIEtypes_RTTResponderInfo_t) -
+			     sizeof(MrvlIEtypesHeader_t))) {
+				tlv_rsp_info =
+					(MrvlIEtypes_RTTResponderInfo_t *)tlv;
+				PRINTM(MCMND, "rtt_rsp_cfg->action=0x%x\n",
+				       rtt_rsp_cfg->action);
+				if (rtt_rsp_cfg->action ==
+					    RTT_GET_RESPONDER_INFO ||
+				    rtt_rsp_cfg->action ==
+					    RTT_SET_RESPONDER_ENABLE) {
+					rtt_rsp_cfg->u.info.channel =
+						tlv_rsp_info->channel;
+					rtt_rsp_cfg->u.info.bandcfg =
+						tlv_rsp_info->bandcfg;
+					rtt_rsp_cfg->u.info.preamble =
+						tlv_rsp_info->preamble;
+					PRINTM(MCMND,
+					       "set to rtt_rsp_cfg channel=%d bandcfg=%d %d %d %d preamble=%d\n",
+					       rtt_rsp_cfg->u.info.channel,
+					       rtt_rsp_cfg->u.info.bandcfg
+						       .chanBand,
+					       rtt_rsp_cfg->u.info.bandcfg
+						       .chanWidth,
+					       rtt_rsp_cfg->u.info.bandcfg
+						       .chan2Offset,
+					       rtt_rsp_cfg->u.info.bandcfg
+						       .chan2Offset,
+					       rtt_rsp_cfg->u.info.preamble);
+					break;
+				}
+			}
+		}
+		left_len -= ((MrvlIEtypesHeader_t *)tlv)->len +
+			    sizeof(MrvlIEtypesHeader_t);
+		tlv += ((MrvlIEtypesHeader_t *)tlv)->len +
+		       sizeof(MrvlIEtypesHeader_t);
+	}
+
+done:
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief Handle the version_ext resp
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_ver_ext(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+			     mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_VERSION_EXT *ver_ext = &resp->params.verext;
+	mlan_ds_get_info *info;
+	ENTER();
+	if (pioctl_buf) {
+		info = (mlan_ds_get_info *)pioctl_buf->pbuf;
+		info->param.ver_ext.version_str_sel = ver_ext->version_str_sel;
+		memcpy_ext(pmpriv->adapter, info->param.ver_ext.version_str,
+			   ver_ext->version_str, sizeof(char) * 128,
+			   sizeof(char) * MLAN_MAX_VER_STR_LEN);
 	}
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -2875,8 +3611,10 @@ void wlan_process_sleep_confirm_resp(pmlan_adapter pmadapter, t_u8 *pbuf,
 		LEAVE();
 		return;
 	}
-	PRINTM_NETINTF(MEVENT, pmpriv);
-	PRINTM(MEVENT, "#\n");
+	if (pmadapter->second_mac)
+		PRINTM(MEVENT, "##\n");
+	else
+		PRINTM(MEVENT, "#\n");
 	if (cmd->result != MLAN_STATUS_SUCCESS) {
 		PRINTM(MERROR, "Sleep confirm command failed\n");
 		pmadapter->pm_wakeup_card_req = MFALSE;
@@ -3253,6 +3991,15 @@ mlan_status wlan_ret_802_11_tx_rate_query(pmlan_private pmpriv,
 
 	pmpriv->tx_rate = resp->params.tx_rate.tx_rate;
 	pmpriv->tx_rate_info = resp->params.tx_rate.tx_rate_info;
+	if (pmpriv->adapter->pcard_info->v14_fw_api) {
+		pmpriv->tx_rate_info = wlan_convert_v14_tx_rate_info(
+			pmpriv, pmpriv->tx_rate_info);
+		PRINTM(MINFO,
+		       "%s: v14_fw_api=%d tx_rate=%d tx_rate_info=0x%x->0x%x\n",
+		       __func__, pmpriv->adapter->pcard_info->v14_fw_api,
+		       pmpriv->tx_rate, resp->params.tx_rate.tx_rate_info,
+		       pmpriv->tx_rate_info);
+	}
 	if ((pmpriv->tx_rate_info & 0x3) == MLAN_RATE_FORMAT_HE)
 		pmpriv->ext_tx_rate_info =
 			resp->params.tx_rate.ext_tx_rate_info;
@@ -3700,6 +4447,7 @@ mlan_status wlan_cmd_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_TX_RATE_CFG);
 
 	rate_cfg->action = wlan_cpu_to_le16(cmd_action);
+	rate_cfg->cfg_index = 0;
 
 	rate_scope = (MrvlRateScope_t *)rate_cfg->tlv_buf;
 	rate_scope->type = wlan_cpu_to_le16(TLV_TYPE_RATE_SCOPE);
@@ -3725,15 +4473,10 @@ mlan_status wlan_cmd_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 			     i < NELEMENTS(rate_scope->he_mcs_rate_bitmap); i++)
 				rate_scope->he_mcs_rate_bitmap
 					[i] = wlan_cpu_to_le16(
-					pbitmap_rates
-						[2 +
-						 NELEMENTS(
-							 rate_scope
-								 ->ht_mcs_rate_bitmap) +
-						 NELEMENTS(
-							 rate_scope
-								 ->vht_mcs_rate_bitmap) +
-						 i]);
+					pbitmap_rates[2 +
+						      wlan_get_bitmap_index(
+							      rate_scope) +
+						      i]);
 		} else {
 			rate_scope->length = wlan_cpu_to_le16(
 				sizeof(MrvlRateScope_t) -
@@ -3759,17 +4502,13 @@ mlan_status wlan_cmd_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 			for (i = 0;
 			     i < NELEMENTS(rate_scope->vht_mcs_rate_bitmap);
 			     i++)
-				rate_scope->he_mcs_rate_bitmap
-					[i] = wlan_cpu_to_le16(
-					pmpriv->bitmap_rates
-						[2 +
-						 NELEMENTS(
-							 rate_scope
-								 ->ht_mcs_rate_bitmap) +
-						 NELEMENTS(
-							 rate_scope
-								 ->vht_mcs_rate_bitmap) +
-						 i]);
+				rate_scope->he_mcs_rate_bitmap[i] =
+					wlan_cpu_to_le16(
+						pmpriv->bitmap_rates
+							[2 +
+							 wlan_get_bitmap_index(
+								 rate_scope) +
+							 i]);
 		} else {
 			rate_scope->length = wlan_cpu_to_le16(
 				sizeof(MrvlRateScope_t) -
@@ -3786,9 +4525,10 @@ mlan_status wlan_cmd_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	rate_drop->length = wlan_cpu_to_le16(sizeof(rate_drop->rate_drop_mode));
 	rate_drop->rate_drop_mode = 0;
 
-	cmd->size = wlan_cpu_to_le16(
-		S_DS_GEN + sizeof(HostCmd_DS_TX_RATE_CFG) + rate_scope->length +
-		sizeof(MrvlIEtypesHeader_t) + sizeof(MrvlRateDropPattern_t));
+	cmd->size = wlan_cpu_to_le16(S_DS_GEN + sizeof(HostCmd_DS_TX_RATE_CFG) +
+				     wlan_le16_to_cpu(rate_scope->length) +
+				     sizeof(MrvlIEtypesHeader_t) +
+				     sizeof(MrvlRateDropPattern_t));
 	if (pioctl_buf && pmpriv->adapter->pcard_info->v17_fw_api) {
 		ds_rate = (mlan_ds_rate *)pioctl_buf->pbuf;
 		rate_setting_tlv = (MrvlIETypes_rate_setting_t
@@ -3804,7 +4544,8 @@ mlan_status wlan_cmd_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		       rate_setting_tlv->rate_setting);
 		cmd->size = wlan_cpu_to_le16(
 			S_DS_GEN + sizeof(HostCmd_DS_TX_RATE_CFG) +
-			rate_scope->length + sizeof(MrvlIEtypesHeader_t) +
+			wlan_le16_to_cpu(rate_scope->length) +
+			sizeof(MrvlIEtypesHeader_t) +
 			sizeof(MrvlRateDropPattern_t) +
 			sizeof(MrvlIETypes_rate_setting_t));
 	}
@@ -3846,11 +4587,7 @@ mlan_status wlan_ret_tx_rate_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	prate_cfg = (HostCmd_DS_TX_RATE_CFG *)&(resp->params.tx_rate_cfg);
 
 	tlv_buf = (t_u8 *)prate_cfg->tlv_buf;
-	if (tlv_buf) {
-		tlv_buf_len = resp->size -
-			      (sizeof(HostCmd_DS_TX_RATE_CFG) + S_DS_GEN);
-		tlv_buf_len = wlan_le16_to_cpu(tlv_buf_len);
-	}
+	tlv_buf_len = resp->size - (sizeof(HostCmd_DS_TX_RATE_CFG) + S_DS_GEN);
 
 	while (tlv_buf && tlv_buf_len > 0) {
 		tlv = (*tlv_buf);
@@ -4007,6 +4744,8 @@ mlan_status wlan_adapter_get_hw_spec(pmlan_adapter pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_private priv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
+
+	ENTER();
 #if defined(SDIO)
 	/*
 	 * This should be issued in the very first to config
@@ -4079,13 +4818,11 @@ mlan_status wlan_adapter_get_hw_spec(pmlan_adapter pmadapter)
 		pmadapter->cal_data_len = 0;
 	}
 	/* Get FW region and cfp tables */
-	if (pmadapter->init_para.fw_region) {
-		ret = wlan_prepare_cmd(priv, HostCmd_CMD_CHAN_REGION_CFG,
-				       HostCmd_ACT_GEN_GET, 0, MNULL, MNULL);
-		if (ret) {
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
-		}
+	ret = wlan_prepare_cmd(priv, HostCmd_CMD_CHAN_REGION_CFG,
+			       HostCmd_ACT_GEN_GET, 0, MNULL, MNULL);
+	if (ret) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
 	}
 	/*
 	 * Get HW spec
@@ -4176,6 +4913,17 @@ mlan_status wlan_adapter_init_cmd(pmlan_adapter pmadapter)
 		}
 	}
 
+#define DEF_AUTO_NULL_PKT_PERIOD 30
+	if (pmpriv_sta) {
+		t_u32 value = DEF_AUTO_NULL_PKT_PERIOD;
+		ret = wlan_prepare_cmd(pmpriv_sta, HostCmd_CMD_802_11_SNMP_MIB,
+				       HostCmd_ACT_GEN_SET, NullPktPeriod_i,
+				       MNULL, &value);
+		if (ret) {
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+	}
 	if (pmadapter->init_para.indrstcfg != 0xffffffff) {
 		mlan_ds_ind_rst_cfg ind_rst_cfg;
 		ind_rst_cfg.ir_mode = pmadapter->init_para.indrstcfg & 0xff;
@@ -4201,6 +4949,32 @@ mlan_status wlan_adapter_init_cmd(pmlan_adapter pmadapter)
 			goto done;
 		}
 	}
+	if (pmadapter->init_para.drcs_chantime_mode) {
+		mlan_ds_drcs_cfg drcs_init_cfg[2];
+		drcs_init_cfg[0].chan_idx = 0x1;
+		drcs_init_cfg[0].chantime =
+			(t_u8)(pmadapter->init_para.drcs_chantime_mode >> 8);
+		/* switchtime use default value in fw*/
+		drcs_init_cfg[0].switchtime = 10;
+		drcs_init_cfg[0].undozetime = 5;
+		drcs_init_cfg[0].mode =
+			(t_u8)(pmadapter->init_para.drcs_chantime_mode);
+		drcs_init_cfg[1].chan_idx = 0x2;
+		drcs_init_cfg[1].chantime =
+			(t_u8)(pmadapter->init_para.drcs_chantime_mode >> 24);
+		/* switchtime use default value in fw*/
+		drcs_init_cfg[1].switchtime = 10;
+		drcs_init_cfg[1].undozetime = 5;
+		drcs_init_cfg[1].mode =
+			(t_u8)(pmadapter->init_para.drcs_chantime_mode >> 16);
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_DRCS_CONFIG,
+				       HostCmd_ACT_GEN_SET, 0, MNULL,
+				       (t_void *)drcs_init_cfg);
+		if (ret) {
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+	}
 	/* Send request to firmware */
 	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_RF_ANTENNA,
 			       HostCmd_ACT_GEN_GET, 0, MNULL, MNULL);
@@ -4214,76 +4988,6 @@ mlan_status wlan_adapter_init_cmd(pmlan_adapter pmadapter)
 	return ret;
 }
 
-#ifdef RX_PACKET_COALESCE
-mlan_status wlan_cmd_rx_pkt_coalesce_cfg(pmlan_private pmpriv,
-					 HostCmd_DS_COMMAND *cmd,
-					 t_u16 cmd_action, t_void *pdata_buf)
-{
-	mlan_ds_misc_rx_packet_coalesce *rx_pkt_cfg =
-		(mlan_ds_misc_rx_packet_coalesce *)pdata_buf;
-	HostCmd_DS_RX_PKT_COAL_CFG *prx_coal_cfg =
-		(HostCmd_DS_RX_PKT_COAL_CFG *)&cmd->params.rx_pkt_coal_cfg;
-
-	ENTER();
-
-	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_RX_PKT_COALESCE_CFG);
-	prx_coal_cfg->action = wlan_cpu_to_le16(cmd_action);
-
-	if (cmd_action == HostCmd_ACT_GEN_SET) {
-		prx_coal_cfg->packet_threshold =
-			wlan_cpu_to_le32(rx_pkt_cfg->packet_threshold);
-		prx_coal_cfg->delay = wlan_cpu_to_le16(rx_pkt_cfg->delay);
-		PRINTM(MCMND,
-		       "Set RX coal config: packet threshold=%d delay=%d\n",
-		       rx_pkt_cfg->packet_threshold, rx_pkt_cfg->delay);
-		cmd->size = wlan_cpu_to_le16(
-			S_DS_GEN + sizeof(HostCmd_DS_RX_PKT_COAL_CFG));
-	} else {
-		cmd->size = wlan_cpu_to_le16(S_DS_GEN + sizeof(cmd_action));
-	}
-
-	LEAVE();
-	return MLAN_STATUS_SUCCESS;
-}
-
-/**
- *  @brief This function handles the command response of RX_PACKET_COAL_CFG
- *
- *  @param pmpriv       A pointer to mlan_private structure
- *  @param resp         A pointer to HostCmd_DS_COMMAND
- *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
- *
- *  @return             MLAN_STATUS_SUCCESS
- */
-mlan_status wlan_ret_rx_pkt_coalesce_cfg(pmlan_private pmpriv,
-					 const HostCmd_DS_COMMAND *resp,
-					 mlan_ioctl_req *pioctl_buf)
-{
-	mlan_ds_misc_cfg *pcfg = MNULL;
-	const HostCmd_DS_RX_PKT_COAL_CFG *presp_cfg =
-		&resp->params.rx_pkt_coal_cfg;
-
-	ENTER();
-
-	if (pioctl_buf) {
-		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
-		pcfg->param.rx_coalesce.packet_threshold =
-			wlan_le32_to_cpu(presp_cfg->packet_threshold);
-		pcfg->param.rx_coalesce.delay =
-			wlan_le16_to_cpu(presp_cfg->delay);
-		PRINTM(MCMND,
-		       "Get rx pkt coalesce info: packet threshold=%d delay=%d\n",
-		       pcfg->param.rx_coalesce.packet_threshold,
-		       pcfg->param.rx_coalesce.delay);
-		pioctl_buf->buf_len = sizeof(mlan_ds_misc_rx_packet_coalesce);
-	}
-
-	LEAVE();
-	return MLAN_STATUS_SUCCESS;
-}
-
-#endif
-
 /**
  *  @brief This function download the vdll block.
  *
@@ -4334,6 +5038,10 @@ mlan_status wlan_download_vdll_block(mlan_adapter *pmadapter, t_u8 *block,
 		PRINTM(MERROR, "dnld vdll: Fail to alloc vdll buf");
 		goto done;
 	}
+	if (!pmpriv) {
+		PRINTM(MERROR, "dnld vdll: Fail to get pmpriv");
+		goto done;
+	}
 	cmd_hdr = (HostCmd_DS_GEN *)(pmbuf->pbuf + pmbuf->data_offset);
 	cmd_hdr->command = wlan_cpu_to_le16(HostCmd_CMD_VDLL);
 	cmd_hdr->seq_num = wlan_cpu_to_le16(0xFF00);
@@ -4397,10 +5105,19 @@ static mlan_status wlan_get_vdll_image(pmlan_adapter pmadapter, t_u32 vdll_len)
 	ENTER();
 
 	if (ctrl->vdll_mem) {
-		PRINTM(MCMND, "VDLL mem is not empty: %p len=%d\n",
-		       ctrl->vdll_mem, ctrl->vdll_len);
-		goto done;
+		PRINTM(MCMND,
+		       "VDLL mem is not empty: %p old_len=%d new_len=%d\n",
+		       ctrl->vdll_mem, ctrl->vdll_len, vdll_len);
+		if (pcb->moal_vmalloc && pcb->moal_vfree)
+			pcb->moal_vfree(pmadapter->pmoal_handle,
+					(t_u8 *)ctrl->vdll_mem);
+		else
+			pcb->moal_mfree(pmadapter->pmoal_handle,
+					(t_u8 *)ctrl->vdll_mem);
+		ctrl->vdll_mem = MNULL;
+		ctrl->vdll_len = 0;
 	}
+
 	if (pcb->moal_vmalloc && pcb->moal_vfree)
 		status = pcb->moal_vmalloc(pmadapter->pmoal_handle, vdll_len,
 					   (t_u8 **)&ctrl->vdll_mem);
@@ -4490,6 +5207,12 @@ mlan_status wlan_process_vdll_event(pmlan_private pmpriv, pmlan_buffer pevent)
 		PRINTM(MEVENT, "VDLL_IND (OFFSET): offset=0x%x\n", offset);
 		wlan_get_vdll_image(pmadapter, offset);
 		break;
+	case VDLL_IND_TYPE_ERR_SIG:
+		PRINTM(MERROR, "VDLL_IND (SIG ERR).\n");
+		break;
+	case VDLL_IND_TYPE_ERR_ID:
+		PRINTM(MERROR, "VDLL_IND (ID ERR).\n");
+		break;
 	default:
 		PRINTM(MERROR, "unknow vdll ind type=%d\n", ind->type);
 		break;
@@ -4499,49 +5222,553 @@ mlan_status wlan_process_vdll_event(pmlan_private pmpriv, pmlan_buffer pevent)
 }
 
 /**
- *  @brief This function prepares command of get_hw_spec.
+ *  @brief This function handle the csi event
  *
  *  @param pmpriv       A pointer to mlan_private structure
- *  @param pcmd         A pointer to HostCmd_DS_COMMAND structure
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_cmd_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *pcmd)
+mlan_status wlan_process_csi_event(pmlan_private pmpriv)
 {
-	HostCmd_DS_GET_HW_SPEC *hw_spec = &pcmd->params.hw_spec;
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	mlan_status status;
+	t_u32 eventcause = pmadapter->event_cause;
+	t_u8 *evt_buf = MNULL;
+	pmlan_buffer pmbuf = pmadapter->pmlan_buffer_event;
+	pmlan_callbacks pcb = &pmadapter->callbacks;
+	pmlan_event pevent;
 
 	ENTER();
 
-	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);
-	pcmd->size =
-		wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_HW_SPEC) + S_DS_GEN);
-	memcpy_ext(pmpriv->adapter, hw_spec->permanent_addr, pmpriv->curr_addr,
-		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	/* Allocate memory for event buffer */
+	status = pcb->moal_malloc(pmadapter->pmoal_handle, MAX_EVENT_SIZE,
+				  MLAN_MEM_DEF, &evt_buf);
+	if ((status == MLAN_STATUS_SUCCESS) && evt_buf) {
+		t_u16 csi_sig;
+		pcsi_record_ds csi_record = (pcsi_record_ds)(
+			pmbuf->pbuf + pmbuf->data_offset + sizeof(eventcause));
+		/* Check CSI signature */
+		csi_sig = csi_record->CSI_Sign;
+		if (csi_sig != CSI_SIGNATURE) {
+			PRINTM(MERROR,
+			       "Wrong CSI signature 0x%04x. Should be 0x%04x",
+			       csi_sig, CSI_SIGNATURE);
+			status = MLAN_STATUS_FAILURE;
+		} else {
+			/* Send event to moal */
+			pevent = (pmlan_event)evt_buf;
+			pevent->bss_index = pmpriv->bss_index;
+			pevent->event_id = MLAN_EVENT_ID_CSI;
+			/* Event length is the CSI record length in byte */
+			pevent->event_len = csi_record->Len * 4;
+			if (pevent->event_len >
+			    pmbuf->data_len - sizeof(eventcause))
+				pevent->event_len =
+					pmbuf->data_len - sizeof(eventcause);
+			memcpy_ext(pmadapter, (t_u8 *)pevent->event_buf,
+				   csi_record, pevent->event_len,
+				   pevent->event_len);
+			wlan_recv_event(pmpriv, pevent->event_id, pevent);
+		}
+		pcb->moal_mfree(pmadapter->pmoal_handle, evt_buf);
+	}
 
 	LEAVE();
-	return MLAN_STATUS_SUCCESS;
+	return status;
 }
 
-#ifdef SDIO
 /**
- *  @brief This function prepares command of sdio rx aggr command.
+ *  @brief This function handle the multi_chan info event
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param pevent       A pointer to event buffer
  *
- *  @param pcmd         A pointer to HostCmd_DS_COMMAND structure
- *  @param cmd_action   Command action: GET or SET
- *  @param pdata_buf    A pointer to new setting buf
-
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_cmd_sdio_rx_aggr_cfg(HostCmd_DS_COMMAND *pcmd,
-				      t_u16 cmd_action, t_void *pdata_buf)
+mlan_status wlan_handle_event_multi_chan_info(pmlan_private pmpriv,
+					      pmlan_buffer pevent)
 {
-	HostCmd_DS_SDIO_SP_RX_AGGR_CFG *cfg = &pcmd->params.sdio_rx_aggr;
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	t_u32 interfaces = 0;
+	MrvlIEtypes_multi_chan_info_t *pmulti_chan_info = MNULL;
+	MrvlIEtypes_multi_chan_group_info_t *pmulti_chan_grp_info = MNULL;
+	int tlv_buf_left = pevent->data_len - sizeof(mlan_event_id);
+	t_u16 tlv_type, tlv_len;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	pmlan_private intf_priv = MNULL;
+	int num_intf = 0, bss_type = 0, bss_num = 0;
+	MrvlIEtypesHeader_t *tlv = MNULL;
+
+	ENTER();
+
+	PRINTM(MEVENT, "multi channel event\n");
+	pmulti_chan_info =
+		(MrvlIEtypes_multi_chan_info_t *)(pevent->pbuf +
+						  pevent->data_offset +
+						  sizeof(mlan_event_id));
+	if (tlv_buf_left < (int)(sizeof(MrvlIEtypes_multi_chan_info_t)) ||
+	    wlan_le16_to_cpu(pmulti_chan_info->header.type) !=
+		    TLV_TYPE_MULTI_CHAN_INFO) {
+		PRINTM(MERROR, "Invalid multi channel event\n");
+		goto done;
+	}
+
+	pmadapter->mc_status = wlan_le16_to_cpu(pmulti_chan_info->status);
+	PRINTM(MEVENT, "mc_status=%d\n", pmadapter->mc_status);
+	tlv_buf_left -= sizeof(MrvlIEtypes_multi_chan_info_t);
+	tlv = (MrvlIEtypesHeader_t *)pmulti_chan_info->tlv_buffer;
+
+	while (tlv_buf_left >= (int)sizeof(MrvlIEtypesHeader_t)) {
+		tlv_type = wlan_le16_to_cpu(tlv->type);
+		tlv_len = wlan_le16_to_cpu(tlv->len);
+		if ((sizeof(MrvlIEtypesHeader_t) + tlv_len) >
+		    (unsigned int)tlv_buf_left) {
+			PRINTM(MERROR, "wrong tlv: tlvLen=%d, tlvBufLeft=%d\n",
+			       tlv_len, tlv_buf_left);
+			break;
+		}
+		if (tlv_type != TLV_TYPE_MULTI_CHAN_GROUP_INFO_TLV_ID) {
+			PRINTM(MERROR, "wrong tlv type:0x%x\n", tlv_type);
+			break;
+		}
+		pmulti_chan_grp_info =
+			(MrvlIEtypes_multi_chan_group_info_t *)tlv;
+		PRINTM(MEVENT, "mc_info: groupid=%d chan=%d, numintf=%d\n",
+		       pmulti_chan_grp_info->chan_group_id,
+		       pmulti_chan_grp_info->chan_band_info.chan_num,
+		       pmulti_chan_grp_info->num_intf);
+		num_intf = pmulti_chan_grp_info->num_intf;
+		for (interfaces = 0; interfaces < (t_u32)num_intf;
+		     interfaces++) {
+			bss_type = pmulti_chan_grp_info
+					   ->bss_type_numlist[interfaces] >>
+				   4;
+			bss_num = pmulti_chan_grp_info
+					  ->bss_type_numlist[interfaces] &
+				  BSS_NUM_MASK;
+			PRINTM(MEVENT, "intf%d: bss_type=%d bss_num=%d\n",
+			       interfaces, bss_type, bss_num);
+			intf_priv = wlan_get_priv_by_id(pmadapter, bss_num,
+							bss_type);
+			if (intf_priv) {
+#ifdef USB
+				if (IS_USB(pmadapter->card_type)) {
+					if (pmulti_chan_grp_info->hid_num
+							    .usb_epnum ==
+						    MLAN_USB_EP_DATA ||
+					    pmulti_chan_grp_info->hid_num
+							    .usb_epnum ==
+						    MLAN_USB_EP_DATA_CH2 ||
+					    pmulti_chan_grp_info->hid_num
+							    .usb_epnum ==
+						    MLAN_USB_EP_DATA_IF2 ||
+					    pmulti_chan_grp_info->hid_num
+							    .usb_epnum ==
+						    MLAN_USB_EP_DATA_CH2_IF2) {
+						intf_priv->port =
+							pmulti_chan_grp_info
+								->hid_num
+								.usb_epnum;
+						intf_priv->port_index =
+							wlan_get_port_index(
+								pmadapter,
+								intf_priv->port);
+						PRINTM(MEVENT,
+						       "intf%d: bss_type=%d bss_num=%d port=%d index=%d\n",
+						       interfaces, bss_type,
+						       bss_num, intf_priv->port,
+						       intf_priv->port_index);
+
+					} else
+						PRINTM(MERROR,
+						       "Invalid Endpoint num in multi_channel event\n");
+				}
+#endif
+			} else {
+				PRINTM(MERROR,
+				       "Invalid bss_type, bss_num in multi_channel event\n");
+			}
+		}
+
+		tlv_buf_left -= (sizeof(MrvlIEtypesHeader_t) + tlv_len);
+		tlv = (MrvlIEtypesHeader_t *)((t_u8 *)tlv + tlv_len +
+					      sizeof(MrvlIEtypesHeader_t));
+	}
+
+#ifdef USB
+	if (IS_USB(pmadapter->card_type)) {
+		wlan_resync_usb_port(pmadapter);
+	}
+#endif
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function prepares the command MULTI_CHAN_CFG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Command action: GET or SET
+ *  @param pdata_buf    A pointer to new setting buf
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_multi_chan_cfg(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				    t_void *pdata_buf)
+{
+	mlan_ds_multi_chan_cfg *multi_chan_cfg =
+		(mlan_ds_multi_chan_cfg *)pdata_buf;
+	HostCmd_DS_MULTI_CHAN_CFG *pmchan_cfg =
+		(HostCmd_DS_MULTI_CHAN_CFG *)&cmd->params.multi_chan_cfg;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_MULTI_CHAN_CONFIG);
+	pmchan_cfg->action = wlan_cpu_to_le16(cmd_action);
+
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		pmchan_cfg->buffer_weight = multi_chan_cfg->buffer_weight;
+		pmchan_cfg->channel_time =
+			wlan_cpu_to_le32(multi_chan_cfg->channel_time);
+		PRINTM(MCMND,
+		       "Set multi-channel: buffer_weight=%d channel_time=%d\n",
+		       multi_chan_cfg->buffer_weight,
+		       multi_chan_cfg->channel_time);
+		cmd->size = wlan_cpu_to_le16(S_DS_GEN +
+					     sizeof(HostCmd_DS_MULTI_CHAN_CFG));
+	} else {
+		cmd->size = wlan_cpu_to_le16(S_DS_GEN + sizeof(cmd_action));
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of MULTI_CHAN_CFG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_multi_chan_cfg(pmlan_private pmpriv,
+				    const HostCmd_DS_COMMAND *resp,
+				    mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *pcfg = MNULL;
+	const HostCmd_DS_MULTI_CHAN_CFG *presp_cfg =
+		&resp->params.multi_chan_cfg;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		pcfg->param.multi_chan_cfg.channel_time =
+			wlan_le32_to_cpu(presp_cfg->channel_time);
+		pcfg->param.multi_chan_cfg.buffer_weight =
+			presp_cfg->buffer_weight;
+		pcfg->param.multi_chan_cfg.tlv_len =
+			resp->size - (sizeof(HostCmd_DS_GEN) +
+				      sizeof(HostCmd_DS_MULTI_CHAN_CFG));
+		PRINTM(MCMND,
+		       "Get multi-channel: buffer_weight=%d channel_time=%d tlv_len=%d\n",
+		       pcfg->param.multi_chan_cfg.buffer_weight,
+		       pcfg->param.multi_chan_cfg.channel_time,
+		       pcfg->param.multi_chan_cfg.tlv_len);
+		memcpy_ext(pmpriv->adapter, pcfg->param.multi_chan_cfg.tlv_buf,
+			   presp_cfg->tlv_buf,
+			   pcfg->param.multi_chan_cfg.tlv_len,
+			   pcfg->param.multi_chan_cfg.tlv_len);
+		pioctl_buf->buf_len = sizeof(mlan_ds_multi_chan_cfg) +
+				      pcfg->param.multi_chan_cfg.tlv_len;
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares the command MULTI_CHAN_POLICY
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Command action: GET or SET
+ *  @param pdata_buf    A pointer to new setting buf
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_multi_chan_policy(pmlan_private pmpriv,
+				       HostCmd_DS_COMMAND *cmd,
+				       t_u16 cmd_action, t_void *pdata_buf)
+{
+	t_u16 policy = 0;
+	HostCmd_DS_MULTI_CHAN_POLICY *pmulti_chan_policy =
+		(HostCmd_DS_MULTI_CHAN_POLICY *)&cmd->params.multi_chan_policy;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_MULTI_CHAN_POLICY);
+	pmulti_chan_policy->action = wlan_cpu_to_le16(cmd_action);
+	cmd->size = wlan_cpu_to_le16(S_DS_GEN +
+				     sizeof(HostCmd_DS_MULTI_CHAN_POLICY));
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		policy = *((t_u16 *)pdata_buf);
+		pmulti_chan_policy->policy = wlan_cpu_to_le16(policy);
+		PRINTM(MCMND, "Set multi-channel policy: %d\n", policy);
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of MULTI_CHAN_POLICY
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_multi_chan_policy(pmlan_private pmpriv,
+				       const HostCmd_DS_COMMAND *resp,
+				       mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *pcfg = MNULL;
+	const HostCmd_DS_MULTI_CHAN_POLICY *presp_cfg =
+		&resp->params.multi_chan_policy;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		pcfg->param.multi_chan_policy =
+			wlan_le16_to_cpu(presp_cfg->policy);
+
+		if (pioctl_buf->action == HostCmd_ACT_GEN_SET) {
+			if (pcfg->param.multi_chan_policy)
+				pmpriv->adapter->mc_policy = MTRUE;
+			else
+				pmpriv->adapter->mc_policy = MFALSE;
+		}
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares the command DRCD_CFG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Command action: GET or SET
+ *  @param pdata_buf    A pointer to new setting buf
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_drcs_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+			      t_u16 cmd_action, t_void *pdata_buf)
+{
+	mlan_ds_drcs_cfg *drcs_cfg = (mlan_ds_drcs_cfg *)pdata_buf;
+	HostCmd_DS_DRCS_CFG *pdrcs_cfg =
+		(HostCmd_DS_DRCS_CFG *)&cmd->params.drcs_cfg;
+	MrvlTypes_DrcsTimeSlice_t *channel_time_slicing =
+		&pdrcs_cfg->time_slicing;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_DRCS_CONFIG);
+	pdrcs_cfg->action = wlan_cpu_to_le16(cmd_action);
+
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		channel_time_slicing->header.type =
+			wlan_cpu_to_le16(MRVL_DRCS_TIME_SLICE_TLV_ID);
+		channel_time_slicing->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlTypes_DrcsTimeSlice_t) -
+					 sizeof(MrvlIEtypesHeader_t));
+		channel_time_slicing->chan_idx =
+			wlan_cpu_to_le16(drcs_cfg->chan_idx);
+		channel_time_slicing->chantime = drcs_cfg->chantime;
+		channel_time_slicing->switchtime = drcs_cfg->switchtime;
+		channel_time_slicing->undozetime = drcs_cfg->undozetime;
+		channel_time_slicing->mode = drcs_cfg->mode;
+		PRINTM(MCMND,
+		       "Set multi-channel: chan_idx=%d chantime=%d switchtime=%d undozetime=%d mode=%d\n",
+		       channel_time_slicing->chan_idx,
+		       channel_time_slicing->chantime,
+		       channel_time_slicing->switchtime,
+		       channel_time_slicing->undozetime,
+		       channel_time_slicing->mode);
+		cmd->size = wlan_cpu_to_le16(S_DS_GEN +
+					     sizeof(HostCmd_DS_DRCS_CFG));
+		/* Set two channels different parameters */
+		if (0x3 != channel_time_slicing->chan_idx) {
+			drcs_cfg++;
+			channel_time_slicing = pdrcs_cfg->drcs_buf;
+			channel_time_slicing->header.type =
+				wlan_cpu_to_le16(MRVL_DRCS_TIME_SLICE_TLV_ID);
+			channel_time_slicing->header.len = wlan_cpu_to_le16(
+				sizeof(MrvlTypes_DrcsTimeSlice_t) -
+				sizeof(MrvlIEtypesHeader_t));
+			channel_time_slicing->chan_idx =
+				wlan_cpu_to_le16(drcs_cfg->chan_idx);
+			channel_time_slicing->chantime = drcs_cfg->chantime;
+			channel_time_slicing->switchtime = drcs_cfg->switchtime;
+			channel_time_slicing->undozetime = drcs_cfg->undozetime;
+			channel_time_slicing->mode = drcs_cfg->mode;
+			PRINTM(MCMND,
+			       "Set multi-channel: chan_idx=%d chantime=%d switchtime=%d undozetime=%d mode=%d\n",
+			       channel_time_slicing->chan_idx,
+			       channel_time_slicing->chantime,
+			       channel_time_slicing->switchtime,
+			       channel_time_slicing->undozetime,
+			       channel_time_slicing->mode);
+			cmd->size += wlan_cpu_to_le16(
+				sizeof(MrvlTypes_DrcsTimeSlice_t));
+		}
+	} else {
+		cmd->size = wlan_cpu_to_le16(S_DS_GEN + sizeof(cmd_action));
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of DRCS_CFG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_drcs_cfg(pmlan_private pmpriv,
+			      const HostCmd_DS_COMMAND *resp,
+			      mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *pcfg = MNULL;
+	const HostCmd_DS_DRCS_CFG *presp_cfg = &resp->params.drcs_cfg;
+	const MrvlTypes_DrcsTimeSlice_t *channel_time_slicing =
+		&presp_cfg->time_slicing;
+	const MrvlTypes_DrcsTimeSlice_t *channel_time_slicing1 = MNULL;
+	mlan_ds_drcs_cfg *drcs_cfg1 = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		if (wlan_le16_to_cpu(channel_time_slicing->header.type) !=
+			    MRVL_DRCS_TIME_SLICE_TLV_ID ||
+		    wlan_le16_to_cpu(channel_time_slicing->header.len) !=
+			    sizeof(MrvlTypes_DrcsTimeSlice_t) -
+				    sizeof(MrvlIEtypesHeader_t)) {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		pcfg->param.drcs_cfg[0].chan_idx =
+			wlan_le16_to_cpu(channel_time_slicing->chan_idx);
+		pcfg->param.drcs_cfg[0].chantime =
+			channel_time_slicing->chantime;
+		pcfg->param.drcs_cfg[0].switchtime =
+			channel_time_slicing->switchtime;
+		pcfg->param.drcs_cfg[0].undozetime =
+			channel_time_slicing->undozetime;
+		pcfg->param.drcs_cfg[0].mode = channel_time_slicing->mode;
+		PRINTM(MCMND,
+		       "multi-channel: chan_idx=%d chantime=%d switchtime=%d undozetime=%d mode=%d\n",
+		       pcfg->param.drcs_cfg[0].chan_idx,
+		       channel_time_slicing->chantime,
+		       channel_time_slicing->switchtime,
+		       channel_time_slicing->undozetime,
+		       channel_time_slicing->mode);
+		pioctl_buf->buf_len = sizeof(mlan_ds_drcs_cfg);
+		/*Channel for chan_idx 1 and 2 have different parameters*/
+		if (0x3 != pcfg->param.drcs_cfg[0].chan_idx) {
+			channel_time_slicing1 = presp_cfg->drcs_buf;
+			if (wlan_le16_to_cpu(
+				    channel_time_slicing1->header.type) !=
+				    MRVL_DRCS_TIME_SLICE_TLV_ID ||
+			    wlan_le16_to_cpu(
+				    channel_time_slicing1->header.len) !=
+				    sizeof(MrvlTypes_DrcsTimeSlice_t) -
+					    sizeof(MrvlIEtypesHeader_t)) {
+				LEAVE();
+				return MLAN_STATUS_FAILURE;
+			}
+			drcs_cfg1 =
+				(mlan_ds_drcs_cfg *)&pcfg->param.drcs_cfg[1];
+			drcs_cfg1->chan_idx = wlan_le16_to_cpu(
+				channel_time_slicing1->chan_idx);
+			drcs_cfg1->chantime = channel_time_slicing1->chantime;
+			drcs_cfg1->switchtime =
+				channel_time_slicing1->switchtime;
+			drcs_cfg1->undozetime =
+				channel_time_slicing1->undozetime;
+			drcs_cfg1->mode = channel_time_slicing1->mode;
+			PRINTM(MCMND,
+			       "multi-channel: chan_idx=%d chantime=%d switchtime=%d undozetime=%d mode=%d\n",
+			       drcs_cfg1->chan_idx, drcs_cfg1->chantime,
+			       drcs_cfg1->switchtime, drcs_cfg1->undozetime,
+			       drcs_cfg1->mode);
+			pioctl_buf->buf_len += sizeof(mlan_ds_drcs_cfg);
+		}
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of get_hw_spec.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param pcmd         A pointer to HostCmd_DS_COMMAND structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *pcmd)
+{
+	HostCmd_DS_GET_HW_SPEC *hw_spec = &pcmd->params.hw_spec;
+
+	ENTER();
+
+	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_GET_HW_SPEC);
+	pcmd->size =
+		wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_HW_SPEC) + S_DS_GEN);
+	memcpy_ext(pmpriv->adapter, hw_spec->permanent_addr, pmpriv->curr_addr,
+		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+#ifdef SDIO
+/**
+ *  @brief This function prepares command of sdio rx aggr command.
+ *
+ *  @param pcmd         A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Command action: GET or SET
+ *  @param pdata_buf    A pointer to new setting buf
+
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_sdio_rx_aggr_cfg(HostCmd_DS_COMMAND *pcmd,
+				      t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_SDIO_SP_RX_AGGR_CFG *cfg = &pcmd->params.sdio_rx_aggr;
 
 	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_SDIO_SP_RX_AGGR_CFG);
 	pcmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_SDIO_SP_RX_AGGR_CFG) +
 				      S_DS_GEN);
 	cfg->action = cmd_action;
-	if (cmd_action == HostCmd_ACT_GEN_SET)
+	if (pdata_buf && (cmd_action == HostCmd_ACT_GEN_SET))
 		cfg->enable = *(t_u8 *)pdata_buf;
 	return MLAN_STATUS_SUCCESS;
 }
@@ -4664,7 +5891,7 @@ mlan_status wlan_ret_cfg_data(IN pmlan_private pmpriv,
 			pevent->bss_index = pmpriv->bss_index;
 			pevent->event_id = MLAN_EVENT_ID_STORE_HOST_CMD_RESP;
 			pevent->resp = (t_u8 *)resp;
-			pevent->event_len = wlan_le16_to_cpu(resp->size);
+			pevent->event_len = resp->size;
 			wlan_recv_event(pmpriv,
 					MLAN_EVENT_ID_STORE_HOST_CMD_RESP,
 					(mlan_event *)pevent);
@@ -4689,7 +5916,7 @@ mlan_status wlan_cmd_mac_control(pmlan_private pmpriv, HostCmd_DS_COMMAND *pcmd,
 				 t_u16 cmd_action, t_void *pdata_buf)
 {
 	HostCmd_DS_MAC_CONTROL *pmac = &pcmd->params.mac_ctrl;
-	t_u32 action = *((t_u32 *)pdata_buf);
+	t_u32 action = 0;
 
 	ENTER();
 
@@ -4702,7 +5929,10 @@ mlan_status wlan_cmd_mac_control(pmlan_private pmpriv, HostCmd_DS_COMMAND *pcmd,
 	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_MAC_CONTROL);
 	pcmd->size =
 		wlan_cpu_to_le16(sizeof(HostCmd_DS_MAC_CONTROL) + S_DS_GEN);
-	pmac->action = wlan_cpu_to_le32(action);
+	if (pdata_buf) {
+		action = *((t_u32 *)pdata_buf);
+		pmac->action = wlan_cpu_to_le32(action);
+	}
 
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -4752,6 +5982,8 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	MrvlIEtypes_Extension_t *ext_tlv = MNULL;
 	MrvlIEtypes_fw_cap_info_t *fw_cap_tlv = MNULL;
 
+	MrvlIEtypes_Secure_Boot_Uuid_t *sb_uuid_tlv = MNULL;
+
 	ENTER();
 
 	pmadapter->fw_cap_info = wlan_le32_to_cpu(hw_spec->fw_cap_info);
@@ -4838,6 +6070,9 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	pmadapter->hw_dot_11n_dev_cap =
 		wlan_le32_to_cpu(hw_spec->dot_11n_dev_cap);
 	pmadapter->hw_dev_mcs_support = hw_spec->dev_mcs_support;
+	pmadapter->hw_mpdu_density = GET_MPDU_DENSITY(hw_spec->hw_dev_cap);
+	PRINTM(MCMND, "GET_HW_SPEC: hw_mpdu_density=%d dev_mcs_support=0x%x\n",
+	       pmadapter->hw_mpdu_density, hw_spec->dev_mcs_support);
 	for (i = 0; i < pmadapter->priv_num; i++) {
 		if (pmadapter->priv[i])
 			wlan_update_11n_cap(pmadapter->priv[i]);
@@ -4845,15 +6080,12 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 
 	wlan_show_dot11ndevcap(pmadapter, pmadapter->hw_dot_11n_dev_cap);
 	wlan_show_devmcssupport(pmadapter, pmadapter->hw_dev_mcs_support);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	pmadapter->user_htstream = pmadapter->hw_dev_mcs_support;
 	/** separate stream config for 2.4G and 5G, will be changed according to
 	 * antenna cfg*/
 	if (pmadapter->fw_bands & BAND_A)
 		pmadapter->user_htstream |= (pmadapter->user_htstream << 8);
 	PRINTM(MCMND, "user_htstream=0x%x\n", pmadapter->user_htstream);
-#endif
 
 	if (ISSUPP_BEAMFORMING(pmadapter->hw_dot_11n_dev_cap)) {
 		PRINTM(MCMND, "Enable Beamforming\n");
@@ -4881,11 +6113,11 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 		pmadapter->pcard_sd->mp_end_port =
 			wlan_le16_to_cpu(hw_spec->mp_end_port);
 
-		for (i = 1; i <= (unsigned)(MAX_PORT -
+		for (i = 1; i <= (unsigned)(pmadapter->pcard_sd->max_ports -
 					    pmadapter->pcard_sd->mp_end_port);
 		     i++)
 			pmadapter->pcard_sd->mp_data_port_mask &=
-				~(1 << (MAX_PORT - i));
+				~(1 << (pmadapter->pcard_sd->max_ports - i));
 	}
 #endif
 
@@ -4937,18 +6169,10 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 		}
 	}
 #endif
-
-	if (wlan_set_regiontable(pmpriv, (t_u8)pmadapter->region_code,
-				 pmadapter->fw_bands)) {
-		if (pioctl_req)
-			pioctl_req->status_code = MLAN_ERROR_CMD_SCAN_FAIL;
-		ret = MLAN_STATUS_FAILURE;
-		goto done;
-	}
 #ifdef STA_SUPPORT
 	if (wlan_11d_set_universaltable(pmpriv, pmadapter->fw_bands)) {
 		if (pioctl_req)
-			pioctl_req->status_code = MLAN_ERROR_CMD_SCAN_FAIL;
+			pioctl_req->status_code = MLAN_ERROR_IOCTL_FAIL;
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
@@ -5000,6 +6224,11 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 				PRINTM(MCMND, "chanrpt api ver=%d.%d\n",
 				       api_rev->major_ver, api_rev->minor_ver);
 				break;
+			case FW_HOTFIX_VER_ID:
+				pmadapter->fw_hotfix_ver = api_rev->major_ver;
+				PRINTM(MCMND, "fw hotfix ver=%d\n",
+				       api_rev->major_ver);
+				break;
 			default:
 				break;
 			}
@@ -5032,7 +6261,6 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 					pmadapter,
 					(MrvlIEtypes_Extension_t *)ext_tlv);
 			}
-
 			break;
 		case TLV_TYPE_FW_CAP_INFO:
 			fw_cap_tlv = (MrvlIEtypes_fw_cap_info_t *)tlv;
@@ -5043,6 +6271,13 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			PRINTM(MCMND, "fw_cap_info=0x%x fw_cap_ext=0x%x\n",
 			       pmadapter->fw_cap_info, pmadapter->fw_cap_ext);
 			break;
+		case TLV_TYPE_SECURE_BOOT_UUID:
+			sb_uuid_tlv = (MrvlIEtypes_Secure_Boot_Uuid_t *)tlv;
+			pmadapter->uuid_lo = sb_uuid_tlv->uuid_lo;
+			pmadapter->uuid_hi = sb_uuid_tlv->uuid_hi;
+			PRINTM(MMSG, "uuid: %016llx%016llx\n",
+			       pmadapter->uuid_lo, pmadapter->uuid_hi);
+			break;
 		default:
 			break;
 		}
@@ -5050,6 +6285,13 @@ mlan_status wlan_ret_get_hw_spec(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 		tlv = (MrvlIEtypesHeader_t *)((t_u8 *)tlv + tlv_len +
 					      sizeof(MrvlIEtypesHeader_t));
 	}
+	if (wlan_set_regiontable(pmpriv, (t_u8)pmadapter->region_code,
+				 pmadapter->fw_bands)) {
+		if (pioctl_req)
+			pioctl_req->status_code = MLAN_ERROR_IOCTL_FAIL;
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
 done:
 	LEAVE();
 	return ret;
@@ -5070,7 +6312,7 @@ mlan_status wlan_cmd_802_11_radio_control(pmlan_private pmpriv,
 					  t_u16 cmd_action, t_void *pdata_buf)
 {
 	HostCmd_DS_802_11_RADIO_CONTROL *pradio_control = &cmd->params.radio;
-	t_u32 radio_ctl;
+	t_u32 radio_ctl = 0;
 	ENTER();
 	cmd->size = wlan_cpu_to_le16((sizeof(HostCmd_DS_802_11_RADIO_CONTROL)) +
 				     S_DS_GEN);
@@ -5432,6 +6674,320 @@ mlan_status wlan_ret_p2p_params_config(pmlan_private pmpriv,
 }
 #endif
 
+/**
+ *  @brief This function prepares command of GPIO TSF LATCH.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   The action: GET or SET
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req buf
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_gpio_tsf_latch(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				    mlan_ioctl_req *pioctl_buf,
+				    t_void *pdata_buf)
+{
+	HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG *gpio_tsf_config =
+		&cmd->params.gpio_tsf_latch;
+	mlan_ds_gpio_tsf_latch *cfg = (mlan_ds_gpio_tsf_latch *)pdata_buf;
+	mlan_ds_misc_cfg *misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+
+	mlan_ds_tsf_info *tsf_info = (mlan_ds_tsf_info *)pdata_buf;
+	MrvlIEtypes_GPIO_TSF_LATCH_CONFIG *gpio_tsf_latch_config = MNULL;
+	MrvlIEtypes_GPIO_TSF_LATCH_REPORT *gpio_tsf_latch_report = MNULL;
+	t_u8 *tlv = MNULL;
+	ENTER();
+
+	cmd->size = sizeof(HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG) + S_DS_GEN;
+	cmd->command = wlan_cpu_to_le16(HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG);
+	gpio_tsf_config->action = wlan_cpu_to_le16(cmd_action);
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		tlv = (t_u8 *)gpio_tsf_config->tlv_buf;
+		if (misc_cfg->sub_command == MLAN_OID_MISC_GPIO_TSF_LATCH) {
+			gpio_tsf_latch_config =
+				(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG *)tlv;
+			gpio_tsf_latch_config->header.type = wlan_cpu_to_le16(
+				TLV_TYPE_GPIO_TSF_LATCH_CONFIG);
+			gpio_tsf_latch_config->header.len = wlan_cpu_to_le16(
+				sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG) -
+				sizeof(MrvlIEtypesHeader_t));
+			gpio_tsf_latch_config->clock_sync_mode =
+				cfg->clock_sync_mode;
+			gpio_tsf_latch_config->clock_sync_Role =
+				cfg->clock_sync_Role;
+			gpio_tsf_latch_config->clock_sync_gpio_pin_number =
+				cfg->clock_sync_gpio_pin_number;
+			gpio_tsf_latch_config->clock_sync_gpio_level_toggle =
+				cfg->clock_sync_gpio_level_toggle;
+			gpio_tsf_latch_config->clock_sync_gpio_pulse_width =
+				wlan_cpu_to_le16(
+					cfg->clock_sync_gpio_pulse_width);
+			cmd->size += sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG);
+			tlv += sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG);
+			PRINTM(MCMND,
+			       "Set GPIO TSF latch config: Mode=%d Role=%d, GPIO Pin Number=%d, GPIO level/toggle=%d GPIO pulse width=%d\n",
+			       cfg->clock_sync_mode, cfg->clock_sync_Role,
+			       cfg->clock_sync_gpio_pin_number,
+			       cfg->clock_sync_gpio_level_toggle,
+			       (int)cfg->clock_sync_gpio_pulse_width);
+		}
+	} else if (cmd_action == HostCmd_ACT_GEN_GET) {
+		tlv = (t_u8 *)gpio_tsf_config->tlv_buf;
+		if (misc_cfg->sub_command == MLAN_OID_MISC_GPIO_TSF_LATCH) {
+			gpio_tsf_latch_config =
+				(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG *)tlv;
+			gpio_tsf_latch_config->header.type = wlan_cpu_to_le16(
+				TLV_TYPE_GPIO_TSF_LATCH_CONFIG);
+			gpio_tsf_latch_config->header.len = wlan_cpu_to_le16(
+				sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG) -
+				sizeof(MrvlIEtypesHeader_t));
+			cmd->size += sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG);
+			tlv += sizeof(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG);
+		}
+
+		if (misc_cfg->sub_command == MLAN_OID_MISC_GET_TSF_INFO) {
+			gpio_tsf_latch_report =
+				(MrvlIEtypes_GPIO_TSF_LATCH_REPORT *)tlv;
+			gpio_tsf_latch_report->header.type = wlan_cpu_to_le16(
+				TLV_TYPE_GPIO_TSF_LATCH_REPORT);
+			gpio_tsf_latch_report->header.len = wlan_cpu_to_le16(
+				sizeof(MrvlIEtypes_GPIO_TSF_LATCH_REPORT) -
+				sizeof(MrvlIEtypesHeader_t));
+			gpio_tsf_latch_report->tsf_format =
+				wlan_cpu_to_le16(tsf_info->tsf_format);
+			PRINTM(MCMND, "Get TSF info: format=%d\n",
+			       tsf_info->tsf_format);
+			cmd->size += sizeof(MrvlIEtypes_GPIO_TSF_LATCH_REPORT);
+		}
+	}
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of GPIO TSF Latch
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_gpio_tsf_latch(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *resp,
+				    mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG *gpio_tsf_config =
+		&resp->params.gpio_tsf_latch;
+	mlan_ds_misc_cfg *cfg = MNULL;
+	MrvlIEtypes_GPIO_TSF_LATCH_CONFIG *gpio_tsf_latch_config = MNULL;
+	MrvlIEtypes_GPIO_TSF_LATCH_REPORT *gpio_tsf_latch_report = MNULL;
+	MrvlIEtypesHeader_t *tlv = MNULL;
+	t_u16 tlv_buf_left = 0;
+	t_u16 tlv_type = 0;
+	t_u16 tlv_len = 0;
+
+	ENTER();
+	if (wlan_le16_to_cpu(gpio_tsf_config->action) == HostCmd_ACT_GEN_GET) {
+		if (pioctl_buf) {
+			cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+			tlv = (MrvlIEtypesHeader_t *)(gpio_tsf_config->tlv_buf);
+			tlv_buf_left =
+				resp->size -
+				(sizeof(HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG) +
+				 S_DS_GEN);
+			while (tlv_buf_left >= sizeof(MrvlIEtypesHeader_t)) {
+				tlv_type = wlan_le16_to_cpu(tlv->type);
+				tlv_len = wlan_le16_to_cpu(tlv->len);
+				if (tlv_buf_left <
+				    (tlv_len + sizeof(MrvlIEtypesHeader_t))) {
+					PRINTM(MERROR,
+					       "Error processing gpio tsf latch config TLVs, bytes left < TLV length\n");
+					break;
+				}
+				switch (tlv_type) {
+				case TLV_TYPE_GPIO_TSF_LATCH_CONFIG:
+					if (cfg->sub_command ==
+					    MLAN_OID_MISC_GPIO_TSF_LATCH) {
+						gpio_tsf_latch_config =
+							(MrvlIEtypes_GPIO_TSF_LATCH_CONFIG
+								 *)tlv;
+						cfg->param.gpio_tsf_latch_config
+							.clock_sync_mode =
+							gpio_tsf_latch_config
+								->clock_sync_mode;
+						cfg->param.gpio_tsf_latch_config
+							.clock_sync_Role =
+							gpio_tsf_latch_config
+								->clock_sync_Role;
+						cfg->param.gpio_tsf_latch_config
+							.clock_sync_gpio_pin_number =
+							gpio_tsf_latch_config
+								->clock_sync_gpio_pin_number;
+						cfg->param.gpio_tsf_latch_config
+							.clock_sync_gpio_level_toggle =
+							gpio_tsf_latch_config
+								->clock_sync_gpio_level_toggle;
+						cfg->param.gpio_tsf_latch_config
+							.clock_sync_gpio_pulse_width =
+							wlan_le16_to_cpu(
+								gpio_tsf_latch_config
+									->clock_sync_gpio_pulse_width);
+						PRINTM(MCMND,
+						       "Get GPIO TSF latch config: Mode=%d Role=%d, GPIO Pin Number=%d, GPIO level/toggle=%d GPIO pulse width=%d\n",
+						       cfg->param
+							       .gpio_tsf_latch_config
+							       .clock_sync_mode,
+						       cfg->param
+							       .gpio_tsf_latch_config
+							       .clock_sync_Role,
+						       cfg->param
+							       .gpio_tsf_latch_config
+							       .clock_sync_gpio_pin_number,
+						       cfg->param
+							       .gpio_tsf_latch_config
+							       .clock_sync_gpio_level_toggle,
+						       (int)cfg->param
+							       .gpio_tsf_latch_config
+							       .clock_sync_gpio_pulse_width);
+					}
+					break;
+				case TLV_TYPE_GPIO_TSF_LATCH_REPORT:
+					if (cfg->sub_command ==
+					    MLAN_OID_MISC_GET_TSF_INFO) {
+						gpio_tsf_latch_report =
+							(MrvlIEtypes_GPIO_TSF_LATCH_REPORT
+								 *)tlv;
+						cfg->param.tsf_info
+							.tsf_format = wlan_le16_to_cpu(
+							gpio_tsf_latch_report
+								->tsf_format);
+						cfg->param.tsf_info
+							.tsf_info = wlan_le16_to_cpu(
+							gpio_tsf_latch_report
+								->tsf_info);
+						cfg->param.tsf_info
+							.tsf = wlan_le64_to_cpu(
+							gpio_tsf_latch_report
+								->tsf);
+						cfg->param.tsf_info
+							.tsf_offset = wlan_le16_to_cpu(
+							gpio_tsf_latch_report
+								->tsf_offset);
+						PRINTM(MCMND,
+						       "Get GPIO TSF latch report : format=%d\n info=%d tsf=%llu offset=%d",
+						       cfg->param.tsf_info
+							       .tsf_format,
+						       cfg->param.tsf_info
+							       .tsf_info,
+						       cfg->param.tsf_info.tsf,
+						       cfg->param.tsf_info
+							       .tsf_offset);
+					}
+					break;
+				default:
+					break;
+				}
+				tlv_buf_left -=
+					tlv_len + sizeof(MrvlIEtypesHeader_t);
+				tlv = (MrvlIEtypesHeader_t
+					       *)((t_u8 *)tlv + tlv_len +
+						  sizeof(MrvlIEtypesHeader_t));
+			}
+			if (cfg->sub_command == MLAN_OID_MISC_GPIO_TSF_LATCH)
+				pioctl_buf->data_read_written =
+					sizeof(mlan_ds_gpio_tsf_latch);
+			else if (cfg->sub_command == MLAN_OID_MISC_GET_TSF_INFO)
+				pioctl_buf->data_read_written =
+					sizeof(mlan_ds_tsf_info);
+		}
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of CROSS CHIP SYNCH.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   The action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_cross_chip_synch(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				      t_void *pdata_buf)
+{
+	HostCmd_DS_CROSS_CHIP_SYNCH *cross_chip_synch =
+		&cmd->params.cross_chip_synch;
+	mlan_ds_cross_chip_synch *cfg = (mlan_ds_cross_chip_synch *)pdata_buf;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_CROSS_CHIP_SYNCH);
+	cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_CROSS_CHIP_SYNCH) +
+				     S_DS_GEN);
+	cross_chip_synch->action = wlan_cpu_to_le16(cmd_action);
+
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		cross_chip_synch->start_stop = cfg->start_stop;
+		cross_chip_synch->role = cfg->role;
+		cross_chip_synch->period = wlan_cpu_to_le32(cfg->period);
+		cross_chip_synch->init_tsf_low =
+			wlan_cpu_to_le32(cfg->init_tsf_low);
+		cross_chip_synch->init_tsf_high =
+			wlan_cpu_to_le32(cfg->init_tsf_high);
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of CROSS CHIP SYNCH.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND structure
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req buf
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_cross_chip_synch(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *resp,
+				      mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_CROSS_CHIP_SYNCH *cross_chip_synch =
+		&resp->params.cross_chip_synch;
+	mlan_ds_misc_cfg *cfg = MNULL;
+	ENTER();
+	if (pioctl_buf) {
+		cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+
+		if (wlan_le16_to_cpu(cross_chip_synch->action) ==
+		    HostCmd_ACT_GEN_GET) {
+			cfg->param.cross_chip_synch.start_stop =
+				cross_chip_synch->start_stop;
+			cfg->param.cross_chip_synch.role =
+				cross_chip_synch->role;
+			cfg->param.cross_chip_synch.period =
+				wlan_le32_to_cpu(cross_chip_synch->period);
+			cfg->param.cross_chip_synch.init_tsf_low =
+				wlan_le32_to_cpu(
+					cross_chip_synch->init_tsf_low);
+			cfg->param.cross_chip_synch.init_tsf_high =
+				wlan_le32_to_cpu(
+					cross_chip_synch->init_tsf_high);
+		}
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares command of mimo switch configuration.
  *
@@ -5562,7 +7118,8 @@ mlan_status wlan_ret_tx_rx_pkt_stats(pmlan_private pmpriv,
 	HostCmd_DS_TX_RX_HISTOGRAM *ptx_rx_histogram =
 		&resp->params.tx_rx_histogram;
 	mlan_ds_misc_cfg *info;
-	t_u16 cmdsize = wlan_le16_to_cpu(resp->size), length;
+	t_u16 cmdsize = resp->size;
+	t_u16 length;
 	t_u32 *pos, count = 0;
 
 	ENTER();
@@ -5750,10 +7307,7 @@ mlan_status wlan_ret_802_11_rf_antenna(pmlan_private pmpriv,
 	HostCmd_DS_802_11_RF_ANTENNA *pantenna = &resp->params.antenna;
 	t_u16 tx_ant_mode = wlan_le16_to_cpu(pantenna->tx_antenna_mode);
 	t_u16 rx_ant_mode = wlan_le16_to_cpu(pantenna->rx_antenna_mode);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	mlan_adapter *pmadapter = pmpriv->adapter;
-#endif
 	typedef struct _HostCmd_DS_802_11_RF_ANTENNA_1X1 {
 		/** Action */
 		t_u16 action;
@@ -5779,9 +7333,9 @@ mlan_status wlan_ret_802_11_rf_antenna(pmlan_private pmpriv,
 		       " Rx action = 0x%x, Rx Mode = 0x%04x\n",
 		       wlan_le16_to_cpu(pantenna->action_tx), tx_ant_mode,
 		       wlan_le16_to_cpu(pantenna->action_rx), rx_ant_mode);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if (IS_CARD9098(pmadapter->card_type) ||
+		    IS_CARDIW62X(pmadapter->card_type) ||
+		    IS_CARDAW693(pmadapter->card_type) ||
 		    IS_CARD9097(pmadapter->card_type)) {
 			tx_ant_mode &= 0x0303;
 			rx_ant_mode &= 0x0303;
@@ -5814,7 +7368,6 @@ mlan_status wlan_ret_802_11_rf_antenna(pmlan_private pmpriv,
 			       pmadapter->user_htstream, tx_ant_mode,
 			       rx_ant_mode);
 		}
-#endif
 	} else
 		PRINTM(MINFO,
 		       "RF_ANT_RESP: action = 0x%x, Mode = 0x%04x, Evaluate time = %d, Current antenna = %d\n",
@@ -5851,11 +7404,8 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				t_u16 cmd_action, t_void *pdata_buf)
 {
 	mlan_ds_reg_rw *reg_rw;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	MrvlIEtypes_Reg_type_t *tlv;
 	mlan_adapter *pmadapter = pmpriv->adapter;
-#endif
 
 	ENTER();
 
@@ -5869,10 +7419,10 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		mac_reg->action = wlan_cpu_to_le16(cmd_action);
 		mac_reg->offset = wlan_cpu_to_le16((t_u16)reg_rw->offset);
 		mac_reg->value = wlan_cpu_to_le32(reg_rw->value);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 		if ((reg_rw->type == MLAN_REG_MAC2) &&
 		    (IS_CARD9098(pmadapter->card_type) ||
+		     IS_CARDIW62X(pmadapter->card_type) ||
+		     IS_CARDAW693(pmadapter->card_type) ||
 		     IS_CARD9097(pmadapter->card_type))) {
 			tlv = (MrvlIEtypes_Reg_type_t
 				       *)((t_u8 *)cmd +
@@ -5886,7 +7436,17 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				sizeof(HostCmd_DS_MAC_REG_ACCESS) + S_DS_GEN +
 				sizeof(MrvlIEtypes_Reg_type_t));
 		}
-#endif
+		break;
+	}
+	case HostCmd_CMD_REG_ACCESS: {
+		HostCmd_DS_REG_ACCESS *reg;
+		cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_REG_ACCESS) +
+					     S_DS_GEN);
+		reg = (HostCmd_DS_REG_ACCESS *)&cmd->params.reg;
+		reg->action = wlan_cpu_to_le16(cmd_action);
+		reg->reg_type = wlan_cpu_to_le16((t_u16)reg_rw->type);
+		reg->offset = wlan_cpu_to_le16((t_u16)reg_rw->offset);
+		reg->value = wlan_cpu_to_le32(reg_rw->value);
 		break;
 	}
 	case HostCmd_CMD_BBP_REG_ACCESS: {
@@ -5897,10 +7457,10 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		bbp_reg->action = wlan_cpu_to_le16(cmd_action);
 		bbp_reg->offset = wlan_cpu_to_le16((t_u16)reg_rw->offset);
 		bbp_reg->value = (t_u8)reg_rw->value;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 		if ((reg_rw->type == MLAN_REG_BBP2) &&
 		    (IS_CARD9098(pmadapter->card_type) ||
+		     IS_CARDIW62X(pmadapter->card_type) ||
+		     IS_CARDAW693(pmadapter->card_type) ||
 		     IS_CARD9097(pmadapter->card_type))) {
 			tlv = (MrvlIEtypes_Reg_type_t
 				       *)((t_u8 *)cmd +
@@ -5914,7 +7474,6 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				sizeof(HostCmd_DS_BBP_REG_ACCESS) + S_DS_GEN +
 				sizeof(MrvlIEtypes_Reg_type_t));
 		}
-#endif
 		break;
 	}
 	case HostCmd_CMD_RF_REG_ACCESS: {
@@ -5925,10 +7484,10 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		rf_reg->action = wlan_cpu_to_le16(cmd_action);
 		rf_reg->offset = wlan_cpu_to_le16((t_u16)reg_rw->offset);
 		rf_reg->value = (t_u8)reg_rw->value;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 		if ((reg_rw->type == MLAN_REG_RF2) &&
 		    (IS_CARD9098(pmadapter->card_type) ||
+		     IS_CARDIW62X(pmadapter->card_type) ||
+		     IS_CARDAW693(pmadapter->card_type) ||
 		     IS_CARD9097(pmadapter->card_type))) {
 			tlv = (MrvlIEtypes_Reg_type_t
 				       *)((t_u8 *)cmd +
@@ -5942,7 +7501,6 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				sizeof(HostCmd_DS_RF_REG_ACCESS) + S_DS_GEN +
 				sizeof(MrvlIEtypes_Reg_type_t));
 		}
-#endif
 		break;
 	}
 	case HostCmd_CMD_CAU_REG_ACCESS: {
@@ -5988,10 +7546,10 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 		bca_reg->action = wlan_cpu_to_le16(cmd_action);
 		bca_reg->offset = wlan_cpu_to_le16((t_u16)reg_rw->offset);
 		bca_reg->value = wlan_cpu_to_le32(reg_rw->value);
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 		if ((reg_rw->type == MLAN_REG_BCA2) &&
 		    (IS_CARD9098(pmadapter->card_type) ||
+		     IS_CARDIW62X(pmadapter->card_type) ||
+		     IS_CARDAW693(pmadapter->card_type) ||
 		     IS_CARD9097(pmadapter->card_type))) {
 			tlv = (MrvlIEtypes_Reg_type_t
 				       *)((t_u8 *)cmd +
@@ -6005,7 +7563,6 @@ mlan_status wlan_cmd_reg_access(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				sizeof(HostCmd_DS_BCA_REG_ACCESS) + S_DS_GEN +
 				sizeof(MrvlIEtypes_Reg_type_t));
 		}
-#endif
 		break;
 	}
 	default:
@@ -6048,6 +7605,13 @@ mlan_status wlan_ret_reg_access(mlan_adapter *pmadapter, t_u16 type,
 			reg_rw->value = wlan_le32_to_cpu(reg->value);
 			break;
 		}
+		case HostCmd_CMD_REG_ACCESS: {
+			HostCmd_DS_REG_ACCESS *reg;
+			reg = (HostCmd_DS_REG_ACCESS *)&resp->params.reg;
+			reg_rw->offset = (t_u32)wlan_le16_to_cpu(reg->offset);
+			reg_rw->value = wlan_le32_to_cpu(reg->value);
+			break;
+		}
 		case HostCmd_CMD_BBP_REG_ACCESS: {
 			HostCmd_DS_BBP_REG_ACCESS *reg;
 			reg = (HostCmd_DS_BBP_REG_ACCESS *)&resp->params.bbp_reg;
@@ -6205,11 +7769,11 @@ void wlan_bt_coex_wlan_param_update_event(pmlan_private priv,
 
 	ENTER();
 
-	while (len >= sizeof(MrvlIEtypesHeader_t)) {
+	while (len >= (t_s32)sizeof(MrvlIEtypesHeader_t)) {
 		tlv = (MrvlIEtypesHeader_t *)pCurrent_ptr;
 		tlv_len = wlan_le16_to_cpu(tlv->len);
 		tlv_type = wlan_le16_to_cpu(tlv->type);
-		if ((tlv_len + sizeof(MrvlIEtypesHeader_t)) > len)
+		if ((tlv_len + (t_s32)sizeof(MrvlIEtypesHeader_t)) > len)
 			break;
 		switch (tlv_type) {
 		case TLV_BTCOEX_WL_AGGR_WINSIZE:
@@ -6270,35 +7834,64 @@ mlan_status wlan_cmd_802_11_supplicant_pmk(pmlan_private pmpriv,
 	t_u8 zero_mac[] = {0, 0, 0, 0, 0, 0};
 	t_u8 ssid_flag = 0, bssid_flag = 0, pmk_flag = 0, passphrase_flag = 0;
 	t_u8 sae_password_flag = 0;
+	t_u8 zero[MLAN_MAX_KEY_LENGTH] = {0};
+	MrvlIEtypes_fw_roam_enable_t *proam_tlv = MNULL;
+	MrvlIEtypes_keyParams_t *key_tlv = MNULL;
+	int length = 0;
+	t_u8 userset_passphrase = 0;
 
 	ENTER();
-	psk = (mlan_ds_passphrase *)&sec->param.passphrase;
-
-	/*
-	 * Parse the rest of the buf here
-	 *  1) <ssid="valid ssid"> - This will get the passphrase, AKMP
-	 *     for specified ssid, if none specified then it will get all.
-	 *     Eg: iwpriv <mlanX> passphrase 0:ssid=nxp
-	 *  2) <psk="psk">:<passphrase="passphare">:<bssid="00:50:43:ef:23:f3">
-	 *     <ssid="valid ssid"> - passphrase and psk cannot be provided to
-	 *     the same SSID, Takes one SSID at a time, If ssid= is present
-	 *     the it should contain a passphrase or psk. If no arguments are
-	 *     provided then AKMP=802.1x, and passphrase should be provided
-	 *     after association.
-	 *     End of each parameter should be followed by a ':'(except for the
-	 *     last parameter) as the delimiter. If ':' has to be used in
-	 *     an SSID then a '/' should be preceded to ':' as a escape.
-	 *     Eg:iwpriv <mlanX> passphrase
-	 *               "1:ssid=mrvl AP:psk=abcdefgh:bssid=00:50:43:ef:23:f3"
-	 *     iwpriv <mlanX> passphrase
-	 *            "1:ssid=nxp/: AP:psk=abcdefgd:bssid=00:50:43:ef:23:f3"
-	 *     iwpriv <mlanX> passphrase "1:ssid=mrvlAP:psk=abcdefgd"
-	 *  3) <ssid="valid ssid"> - This will clear the passphrase
-	 *     for specified ssid, if none specified then it will clear all.
-	 *     Eg: iwpriv <mlanX> passphrase 2:ssid=nxp
-	 */
+	if (sec->multi_passphrase)
+		psk = (mlan_ds_passphrase *)&sec->param
+			      .roam_passphrase[userset_passphrase];
+	else
+		psk = (mlan_ds_passphrase *)&sec->param.passphrase;
+	if (cmd_action == HostCmd_ACT_GEN_REMOVE) {
+		cmd->size =
+			sizeof(HostCmd_DS_802_11_SUPPLICANT_PMK) + S_DS_GEN - 1;
+		proam_tlv = (MrvlIEtypes_fw_roam_enable_t *)ptlv_buffer;
+		proam_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_ROAM);
+		proam_tlv->header.len = sizeof(MrvlIEtypes_fw_roam_enable_t) -
+					sizeof(MrvlIEtypesHeader_t);
+		proam_tlv->roam_enable = MTRUE;
+		ptlv_buffer +=
+			(proam_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
+		cmd->size +=
+			(proam_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
+		proam_tlv->header.len = wlan_cpu_to_le16(proam_tlv->header.len);
 
-	/* -1 is for t_u8 TlvBuffer[1] as this should not be included */
+		cmd->command = wlan_cpu_to_le16(HostCmd_CMD_SUPPLICANT_PMK);
+		pesupplicant_psk->action = wlan_cpu_to_le16(cmd_action);
+		pesupplicant_psk->cache_result = 0;
+		cmd->size = wlan_cpu_to_le16(cmd->size);
+		LEAVE();
+		return MLAN_STATUS_SUCCESS;
+	}
+
+	// Parse the rest of the buf here
+	//  1) <ssid="valid ssid"> - This will get the passphrase, AKMP
+	//     for specified ssid, if none specified then it will get all.
+	//     Eg: iwpriv <mlanX> passphrase 0:ssid=nxp
+	//  2) <psk="psk">:<passphrase="passphare">:<bssid="00:50:43:ef:23:f3">
+	//     <ssid="valid ssid"> - passphrase and psk cannot be provided to
+	//     the same SSID, Takes one SSID at a time, If ssid= is present
+	//     the it should contain a passphrase or psk. If no arguments are
+	//     provided then AKMP=802.1x, and passphrase should be provided
+	//     after association.
+	//     End of each parameter should be followed by a ':'(except for the
+	//     last parameter) as the delimiter. If ':' has to be used in
+	//     an SSID then a '/' should be preceded to ':' as a escape.
+	//     Eg:iwpriv <mlanX> passphrase
+	//               "1:ssid=mrvl AP:psk=abcdefgh:bssid=00:50:43:ef:23:f3"
+	//     iwpriv <mlanX> passphrase
+	//            "1:ssid=nxp/: AP:psk=abcdefgd:bssid=00:50:43:ef:23:f3"
+	//     iwpriv <mlanX> passphrase "1:ssid=mrvlAP:psk=abcdefgd"
+	//  3) <ssid="valid ssid"> - This will clear the passphrase
+	//     for specified ssid, if none specified then it will clear all.
+	//     Eg: iwpriv <mlanX> passphrase 2:ssid=nxp
+	//
+	//
+	//    -1 is for t_u8 TlvBuffer[1] as this should not be included */
 	cmd->size = sizeof(HostCmd_DS_802_11_SUPPLICANT_PMK) + S_DS_GEN - 1;
 	if (psk && memcmp(pmpriv->adapter, (t_u8 *)&psk->bssid, zero_mac,
 			  sizeof(zero_mac))) {
@@ -6328,60 +7921,133 @@ mlan_status wlan_cmd_802_11_supplicant_pmk(pmlan_private pmpriv,
 			(ppmk_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
 		ppmk_tlv->header.len = wlan_cpu_to_le16(ppmk_tlv->header.len);
 		pmk_flag = 1;
+		if (memcmp(pmpriv->adapter, psk->psk.pmk.pmk_r0, zero,
+			   MLAN_MAX_KEY_LENGTH)) {
+			ppmk_tlv = (MrvlIEtypes_PMK_t *)ptlv_buffer;
+			ppmk_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_PMK_R0);
+			ppmk_tlv->header.len = MLAN_MAX_KEY_LENGTH;
+			memcpy_ext(pmpriv->adapter, ppmk_tlv->pmk,
+				   psk->psk.pmk.pmk_r0, MLAN_MAX_KEY_LENGTH,
+				   MLAN_MAX_KEY_LENGTH);
+			ptlv_buffer += (ppmk_tlv->header.len +
+					sizeof(MrvlIEtypesHeader_t));
+			cmd->size += (ppmk_tlv->header.len +
+				      sizeof(MrvlIEtypesHeader_t));
+			ppmk_tlv->header.len =
+				wlan_cpu_to_le16(ppmk_tlv->header.len);
+		}
+		if (memcmp(pmpriv->adapter, psk->psk.pmk.pmk_r0_name, zero,
+			   MLAN_MAX_PMKR0_NAME_LENGTH)) {
+			ppmk_tlv = (MrvlIEtypes_PMK_t *)ptlv_buffer;
+			ppmk_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_PMK_R0_NAME);
+			ppmk_tlv->header.len = MLAN_MAX_PMKR0_NAME_LENGTH;
+			memcpy_ext(pmpriv->adapter, ppmk_tlv->pmk,
+				   psk->psk.pmk.pmk_r0_name,
+				   MLAN_MAX_PMKR0_NAME_LENGTH,
+				   MLAN_MAX_PMKR0_NAME_LENGTH);
+			ptlv_buffer += (ppmk_tlv->header.len +
+					sizeof(MrvlIEtypesHeader_t));
+			cmd->size += (ppmk_tlv->header.len +
+				      sizeof(MrvlIEtypesHeader_t));
+			ppmk_tlv->header.len =
+				wlan_cpu_to_le16(ppmk_tlv->header.len);
+		}
 	}
-	if (psk->ssid.ssid_len) {
-		pssid_tlv = (MrvlIEtypes_SsIdParamSet_t *)ptlv_buffer;
-		pssid_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_SSID);
-		pssid_tlv->header.len =
-			(t_u16)MIN(MLAN_MAX_SSID_LENGTH, psk->ssid.ssid_len);
-		memcpy_ext(pmpriv->adapter, (t_u8 *)pssid_tlv->ssid,
-			   (t_u8 *)psk->ssid.ssid, psk->ssid.ssid_len,
-			   MLAN_MAX_SSID_LENGTH);
+	if (pmpriv->adapter->fw_roaming &&
+	    (pmpriv->adapter->userset_passphrase ||
+	     (psk && psk->psk_type == MLAN_PSK_PMK))) {
+		proam_tlv = (MrvlIEtypes_fw_roam_enable_t *)ptlv_buffer;
+		proam_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_ROAM);
+		proam_tlv->header.len = sizeof(MrvlIEtypes_fw_roam_enable_t) -
+					sizeof(MrvlIEtypesHeader_t);
+		proam_tlv->roam_enable = MTRUE;
+		proam_tlv->userset_passphrase =
+			pmpriv->adapter->userset_passphrase;
 		ptlv_buffer +=
-			(pssid_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
+			(proam_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
 		cmd->size +=
-			(pssid_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
-		pssid_tlv->header.len = wlan_cpu_to_le16(pssid_tlv->header.len);
-		ssid_flag = 1;
-	}
-	if (psk->psk_type == MLAN_PSK_PASSPHRASE) {
-		ppassphrase_tlv = (MrvlIEtypes_Passphrase_t *)ptlv_buffer;
-		ppassphrase_tlv->header.type =
-			wlan_cpu_to_le16(TLV_TYPE_PASSPHRASE);
-		ppassphrase_tlv->header.len =
-			(t_u16)MIN(MLAN_MAX_PASSPHRASE_LENGTH,
-				   psk->psk.passphrase.passphrase_len);
-		memcpy_ext(pmpriv->adapter, ppassphrase_tlv->passphrase,
-			   psk->psk.passphrase.passphrase,
-			   psk->psk.passphrase.passphrase_len,
-			   MLAN_MAX_PASSPHRASE_LENGTH);
-		ptlv_buffer += (ppassphrase_tlv->header.len +
-				sizeof(MrvlIEtypesHeader_t));
-		cmd->size += (ppassphrase_tlv->header.len +
-			      sizeof(MrvlIEtypesHeader_t));
-		ppassphrase_tlv->header.len =
-			wlan_cpu_to_le16(ppassphrase_tlv->header.len);
-		passphrase_flag = 1;
-	}
-	if (psk->psk_type == MLAN_PSK_SAE_PASSWORD) {
-		psae_password_tlv = (MrvlIEtypes_SAE_Password_t *)ptlv_buffer;
-		psae_password_tlv->header.type =
-			wlan_cpu_to_le16(TLV_TYPE_SAE_PASSWORD);
-		psae_password_tlv->header.len =
-			(t_u16)MIN(MLAN_MAX_SAE_PASSWORD_LENGTH,
-				   psk->psk.sae_password.sae_password_len);
-		memcpy_ext(pmpriv->adapter, psae_password_tlv->sae_password,
-			   psk->psk.sae_password.sae_password,
-			   psk->psk.sae_password.sae_password_len,
-			   MLAN_MAX_SAE_PASSWORD_LENGTH);
-		ptlv_buffer += (psae_password_tlv->header.len +
-				sizeof(MrvlIEtypesHeader_t));
-		cmd->size += (psae_password_tlv->header.len +
-			      sizeof(MrvlIEtypesHeader_t));
-		psae_password_tlv->header.len =
-			wlan_cpu_to_le16(psae_password_tlv->header.len);
-		sae_password_flag = 1;
-	}
+			(proam_tlv->header.len + sizeof(MrvlIEtypesHeader_t));
+		proam_tlv->header.len = wlan_cpu_to_le16(proam_tlv->header.len);
+	}
+	do {
+		if (pmpriv->adapter->userset_passphrase &&
+		    sec->multi_passphrase) {
+			key_tlv = (MrvlIEtypes_keyParams_t *)ptlv_buffer;
+			key_tlv->header.type = wlan_cpu_to_le16(
+				TLV_TYPE_ROAM_OFFLOAD_USER_SET_PMK);
+			ptlv_buffer += sizeof(MrvlIEtypesHeader_t);
+			cmd->size += sizeof(MrvlIEtypesHeader_t);
+			length = cmd->size;
+		}
+		if (psk->ssid.ssid_len) {
+			pssid_tlv = (MrvlIEtypes_SsIdParamSet_t *)ptlv_buffer;
+			pssid_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_SSID);
+			pssid_tlv->header.len = (t_u16)MIN(MLAN_MAX_SSID_LENGTH,
+							   psk->ssid.ssid_len);
+			memcpy_ext(pmpriv->adapter, (t_u8 *)pssid_tlv->ssid,
+				   (t_u8 *)psk->ssid.ssid, psk->ssid.ssid_len,
+				   MLAN_MAX_SSID_LENGTH);
+			ptlv_buffer += (pssid_tlv->header.len +
+					sizeof(MrvlIEtypesHeader_t));
+			cmd->size += (pssid_tlv->header.len +
+				      sizeof(MrvlIEtypesHeader_t));
+			pssid_tlv->header.len =
+				wlan_cpu_to_le16(pssid_tlv->header.len);
+			ssid_flag = 1;
+		}
+		if (psk->psk_type == MLAN_PSK_PASSPHRASE) {
+			ppassphrase_tlv =
+				(MrvlIEtypes_Passphrase_t *)ptlv_buffer;
+			ppassphrase_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_PASSPHRASE);
+			ppassphrase_tlv->header.len =
+				(t_u16)MIN(MLAN_MAX_PASSPHRASE_LENGTH,
+					   psk->psk.passphrase.passphrase_len);
+			memcpy_ext(pmpriv->adapter, ppassphrase_tlv->passphrase,
+				   psk->psk.passphrase.passphrase,
+				   psk->psk.passphrase.passphrase_len,
+				   MLAN_MAX_PASSPHRASE_LENGTH);
+			ptlv_buffer += (ppassphrase_tlv->header.len +
+					sizeof(MrvlIEtypesHeader_t));
+			cmd->size += (ppassphrase_tlv->header.len +
+				      sizeof(MrvlIEtypesHeader_t));
+			ppassphrase_tlv->header.len =
+				wlan_cpu_to_le16(ppassphrase_tlv->header.len);
+			passphrase_flag = 1;
+		}
+		if (psk->psk_type == MLAN_PSK_SAE_PASSWORD) {
+			psae_password_tlv =
+				(MrvlIEtypes_SAE_Password_t *)ptlv_buffer;
+			psae_password_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_SAE_PASSWORD);
+			psae_password_tlv->header.len = (t_u16)MIN(
+				MLAN_MAX_SAE_PASSWORD_LENGTH,
+				psk->psk.sae_password.sae_password_len);
+			memcpy_ext(pmpriv->adapter,
+				   psae_password_tlv->sae_password,
+				   psk->psk.sae_password.sae_password,
+				   psk->psk.sae_password.sae_password_len,
+				   MLAN_MAX_SAE_PASSWORD_LENGTH);
+			ptlv_buffer += (psae_password_tlv->header.len +
+					sizeof(MrvlIEtypesHeader_t));
+			cmd->size += (psae_password_tlv->header.len +
+				      sizeof(MrvlIEtypesHeader_t));
+			psae_password_tlv->header.len =
+				wlan_cpu_to_le16(psae_password_tlv->header.len);
+			sae_password_flag = 1;
+		}
+		if (key_tlv)
+			key_tlv->header.len =
+				wlan_cpu_to_le16(cmd->size - length);
+		userset_passphrase++;
+		psk = (mlan_ds_passphrase *)&sec->param
+			      .roam_passphrase[userset_passphrase];
+	} while (psk && sec->multi_passphrase &&
+		 userset_passphrase < pmpriv->adapter->userset_passphrase);
+	pmpriv->adapter->userset_passphrase = 0;
 	if ((cmd_action == HostCmd_ACT_GEN_SET) &&
 	    ((ssid_flag || bssid_flag) && (!pmk_flag && !passphrase_flag) &&
 	     (!pmk_flag && !sae_password_flag))) {
@@ -6750,7 +8416,7 @@ mlan_status wlan_ret_chan_region_cfg(pmlan_private pmpriv,
 	t_u16 action;
 	HostCmd_DS_CHAN_REGION_CFG *reg = MNULL;
 	t_u8 *tlv_buf = MNULL;
-	t_u16 tlv_buf_left;
+	t_u16 tlv_buf_left = 0;
 	mlan_ds_misc_cfg *misc_cfg = MNULL;
 	mlan_ds_misc_chnrgpwr_cfg *cfg = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -6770,11 +8436,22 @@ mlan_status wlan_ret_chan_region_cfg(pmlan_private pmpriv,
 	}
 
 	tlv_buf = (t_u8 *)reg + sizeof(*reg);
-	tlv_buf_left = wlan_le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*reg);
+	if (resp->size > (S_DS_GEN + sizeof(*reg))) {
+		tlv_buf_left = resp->size - S_DS_GEN - sizeof(*reg);
+	} else {
+		PRINTM(MERROR, "Region size calculation ERROR.\n");
+	}
 
 	/* Add FW cfp tables and region info */
 	wlan_add_fw_cfp_tables(pmpriv, tlv_buf, tlv_buf_left);
-
+	if (pmadapter->otp_region) {
+		if (wlan_set_regiontable(pmpriv, (t_u8)pmadapter->region_code,
+					 pmadapter->fw_bands)) {
+			PRINTM(MERROR,
+			       "Set region table failure!! region_code = 0x%X, fw_bands = 0x%X\n",
+			       pmadapter->region_code, pmadapter->fw_bands);
+		}
+	}
 	if (!pioctl_buf)
 		goto done;
 
@@ -6788,7 +8465,7 @@ mlan_status wlan_ret_chan_region_cfg(pmlan_private pmpriv,
 	if (misc_cfg->sub_command == MLAN_OID_MISC_GET_REGIONPWR_CFG) {
 		cfg = (mlan_ds_misc_chnrgpwr_cfg *)&(
 			misc_cfg->param.rgchnpwr_cfg);
-		cfg->length = wlan_le16_to_cpu(resp->size);
+		cfg->length = resp->size;
 		memcpy_ext(pmpriv->adapter, cfg->chnrgpwr_buf, (t_u8 *)resp,
 			   cfg->length, sizeof(cfg->chnrgpwr_buf));
 	} else {
@@ -7067,10 +8744,12 @@ static void wlan_fill_link_statistic(mlan_private *priv,
 			.get_link_statistic;
 
 	/* TLV parse */
-	left_len = resp->size - sizeof(HostCmd_DS_802_11_LINK_STATISTIC) -
-		   S_DS_GEN;
+	if (resp->size > (sizeof(HostCmd_DS_802_11_LINK_STATISTIC) - S_DS_GEN))
+		left_len = resp->size -
+			   sizeof(HostCmd_DS_802_11_LINK_STATISTIC) - S_DS_GEN;
+
 	tlv = (MrvlIEtypesHeader_t *)(plink_stat->value);
-	DBG_HEXDUMP(MCMD_D, "tlv:", (void *)tlv, 1024);
+	DBG_HEXDUMP(MDAT_D, "tlv:", (void *)tlv, 1024);
 	while (left_len > sizeof(MrvlIEtypesHeader_t)) {
 		tlv_type = wlan_le16_to_cpu(tlv->type);
 		tlv_len = wlan_le16_to_cpu(tlv->len);
@@ -7314,7 +8993,7 @@ static void wlan_fill_link_statistic(mlan_private *priv,
 				fw_ifaceStat->peer_info[peerIdx]
 					.rate_stats[rate_idx]
 					.retries_long);
-			PRINTM(MCMND,
+			PRINTM(MDAT_D,
 			       "0x%x  0x%x  0x%x  0x%x  0x%x  0x%x  0x%x\n",
 			       iface_stat->peer_info[peerIdx]
 				       .rate_stats[rate_idx]
@@ -7406,7 +9085,7 @@ mlan_status wlan_cmd_boot_sleep(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	boot_sleep->action = wlan_cpu_to_le16(cmd_action);
 	boot_sleep->enable = wlan_cpu_to_le16(enable);
 
-	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_BOOT_SLEEP);
+	cmd->size = wlan_cpu_to_le16(S_DS_GEN + sizeof(HostCmd_DS_BOOT_SLEEP));
 
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -7784,6 +9463,40 @@ mlan_status wlan_cmd_rxabortcfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of OFDM DESENSE cfg
+ *
+ *  @param pmpriv      A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_ofdmdesense_cfg(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				     t_void *pdata_buf)
+{
+	HostCmd_DS_CMD_OFDM_DESENSE_CFG *cfg_cmd =
+		(HostCmd_DS_CMD_OFDM_DESENSE_CFG *)&cmd->params.ofdm_desense_cfg;
+	mlan_ds_misc_ofdm_desense_cfg *cfg =
+		(mlan_ds_misc_ofdm_desense_cfg *)pdata_buf;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_OFDM_DESENSE_CFG);
+	cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_CMD_OFDM_DESENSE_CFG) +
+				     S_DS_GEN);
+	cfg_cmd->action = wlan_cpu_to_le16(cmd_action);
+
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		cfg_cmd->enable = (t_u8)cfg->enable;
+		cfg_cmd->cca_threshold = (t_s8)cfg->cca_threshold;
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function handles the command response of Rx Abort Cfg
  *
@@ -7811,6 +9524,35 @@ mlan_status wlan_ret_rxabortcfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
+/**
+ *  @brief This function handles the command response of OFDM DESENSE CFG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_ofdmdesense_cfg(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *resp,
+				     mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_CMD_OFDM_DESENSE_CFG *cfg_cmd =
+		(HostCmd_DS_CMD_OFDM_DESENSE_CFG *)&resp->params
+			.ofdm_desense_cfg;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		misc_cfg->param.ofdm_desense_cfg.enable = (t_u8)cfg_cmd->enable;
+		misc_cfg->param.ofdm_desense_cfg.cca_threshold =
+			(t_s8)cfg_cmd->cca_threshold;
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
 
 /**
  *  @brief This function prepares command of Rx abort cfg ext
@@ -7841,6 +9583,11 @@ mlan_status wlan_cmd_rxabortcfg_ext(pmlan_private pmpriv,
 		cfg_cmd->enable = (t_u8)cfg->enable;
 		cfg_cmd->rssi_margin = (t_s8)cfg->rssi_margin;
 		cfg_cmd->ceil_rssi_threshold = (t_s8)cfg->ceil_rssi_threshold;
+		cfg_cmd->floor_rssi_threshold = (t_s8)cfg->floor_rssi_threshold;
+		cfg_cmd->current_dynamic_rssi_threshold =
+			(t_s8)cfg->current_dynamic_rssi_threshold;
+		cfg_cmd->rssi_default_config = (t_u8)cfg->rssi_default_config;
+		cfg_cmd->edmac_enable = (t_u8)cfg->edmac_enable;
 	}
 
 	LEAVE();
@@ -7874,11 +9621,99 @@ mlan_status wlan_ret_rxabortcfg_ext(pmlan_private pmpriv,
 			cfg_cmd->rssi_margin;
 		misc_cfg->param.rx_abort_cfg_ext.ceil_rssi_threshold =
 			cfg_cmd->ceil_rssi_threshold;
+		misc_cfg->param.rx_abort_cfg_ext.floor_rssi_threshold =
+			cfg_cmd->floor_rssi_threshold;
+		misc_cfg->param.rx_abort_cfg_ext.current_dynamic_rssi_threshold =
+			cfg_cmd->current_dynamic_rssi_threshold;
+		misc_cfg->param.rx_abort_cfg_ext.rssi_default_config =
+			cfg_cmd->rssi_default_config;
+		misc_cfg->param.rx_abort_cfg_ext.edmac_enable =
+			cfg_cmd->edmac_enable;
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ * @brief This function sets the hal/phy cfg params
+ *
+ * @param pmpriv       A pointer to mlan_private structure
+ * @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ * @param cmd_action   The action: GET or SET
+ * @param pdata_buf    A pointer to data buffer
+ *
+ * @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_hal_phy_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_u16 *pdata_buf)
+{
+	HostCmd_DS_HAL_PHY_CFG *hal_phy_cfg_cmd =
+		&cmd->params.hal_phy_cfg_params;
+	mlan_ds_hal_phy_cfg_params *hal_phy_cfg_params = MNULL;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_HAL_PHY_CFG);
+	cmd->size = sizeof(HostCmd_DS_HAL_PHY_CFG) + S_DS_GEN;
+	hal_phy_cfg_cmd->action = wlan_cpu_to_le16(cmd_action);
+	hal_phy_cfg_params = (mlan_ds_hal_phy_cfg_params *)pdata_buf;
+	hal_phy_cfg_cmd->dot11b_psd_mask_cfg =
+		hal_phy_cfg_params->dot11b_psd_mask_cfg;
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of hal_phy_cfg
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_hal_phy_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_HAL_PHY_CFG *cfg_cmd =
+		(HostCmd_DS_HAL_PHY_CFG *)&resp->params.hal_phy_cfg_params;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		misc_cfg->param.hal_phy_cfg_params.dot11b_psd_mask_cfg =
+			cfg_cmd->dot11b_psd_mask_cfg;
 	}
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
 
+mlan_status wlan_cmd_ips_config(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_IPS_CONFIG *ips_cfg = MNULL;
+	t_u32 enable = *(t_u32 *)pdata_buf;
+
+	ENTER();
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_IPS_CONFIG);
+	ips_cfg = &cmd->params.ips_cfg;
+	ips_cfg->enable = wlan_cpu_to_le32(enable);
+	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_IPS_CONFIG);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+mlan_status wlan_ret_ips_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+			     mlan_ioctl_req *pioctl_buf)
+{
+	ENTER();
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares command of Dot11mc unassoc ftm cfg
  *
@@ -8313,7 +10148,7 @@ mlan_status wlan_ret_get_chan_trpc_config(pmlan_private pmpriv,
 		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
 		cfg = (mlan_ds_misc_chan_trpc_cfg *)&(misc->param.trpc_cfg);
 		cfg->sub_band = wlan_le16_to_cpu(trpc_cfg->sub_band);
-		cfg->length = wlan_le16_to_cpu(resp->size);
+		cfg->length = resp->size;
 		memcpy_ext(pmadapter, cfg->trpc_buf, (t_u8 *)resp, cfg->length,
 			   sizeof(cfg->trpc_buf));
 	}
@@ -8321,6 +10156,112 @@ mlan_status wlan_ret_get_chan_trpc_config(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of mc_aggr_cfg
+ *
+ *  @param pmpriv      A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_mc_aggr_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_MC_AGGR_CFG *cfg_cmd =
+		(HostCmd_DS_MC_AGGR_CFG *)&cmd->params.mc_aggr_cfg;
+	mlan_ds_mc_aggr_cfg *cfg = (mlan_ds_mc_aggr_cfg *)pdata_buf;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_MC_AGGR_CFG);
+	cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_MC_AGGR_CFG) + S_DS_GEN);
+	cfg_cmd->action = wlan_cpu_to_le16(cmd_action);
+
+	cfg_cmd->enable_bitmap = (t_u8)cfg->enable_bitmap;
+	cfg_cmd->mask_bitmap = (t_u8)cfg->mask_bitmap;
+	cfg_cmd->cts2self_offset = wlan_cpu_to_le16(cfg->cts2self_offset);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of mc_aggr_cfg
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_mc_aggr_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_MC_AGGR_CFG *cfg_cmd =
+		(HostCmd_DS_MC_AGGR_CFG *)&resp->params.mc_aggr_cfg;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		misc_cfg->param.mc_aggr_cfg.enable_bitmap =
+			(t_u8)cfg_cmd->enable_bitmap;
+		misc_cfg->param.mc_aggr_cfg.mask_bitmap =
+			(t_u8)cfg_cmd->mask_bitmap;
+		misc_cfg->param.mc_aggr_cfg.cts2self_offset =
+			(t_u8)cfg_cmd->cts2self_offset;
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of ch_load
+ *
+ *  @param pmpriv      A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_get_ch_load(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_GET_CH_LOAD *cfg_cmd =
+		(HostCmd_DS_GET_CH_LOAD *)&cmd->params.ch_load;
+	mlan_ds_ch_load *cfg = (mlan_ds_ch_load *)pdata_buf;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_GET_CH_LOAD);
+	cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_GET_CH_LOAD) + S_DS_GEN);
+	cfg_cmd->action = wlan_cpu_to_le16(cmd_action);
+	cfg_cmd->ch_load = wlan_cpu_to_le16(cfg->ch_load_param);
+	cfg_cmd->noise = wlan_cpu_to_le16(cfg->noise);
+	cfg_cmd->rx_quality = wlan_cpu_to_le16(cfg->rx_quality);
+	cfg_cmd->duration = wlan_cpu_to_le16(cfg->duration);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of ch_load
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_ch_load(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+			     mlan_ioctl_req *pioctl_buf)
+{
+	ENTER();
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares command of RANGE_EXT
  *
@@ -8377,3 +10318,59 @@ mlan_status wlan_ret_range_ext(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
+
+/**
+ *  @brief This function prepares command of get_sensor_temp
+ *
+ *  @param pmpriv      A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_get_sensor_temp(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *cmd, t_u16 cmd_action)
+{
+	ENTER();
+
+	if (cmd_action != HostCmd_ACT_GEN_GET) {
+		PRINTM(MERROR, "wlan_cmd_get_sensor_temp: support GET only.\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_DS_GET_SENSOR_TEMP);
+	cmd->size = wlan_cpu_to_le16(S_DS_GEN + 4);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+/**
+ *  @brief This function handles the command response of get_sensor_temp
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_get_sensor_temp(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *resp,
+				     mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *pcfg = MNULL;
+	const HostCmd_DS_SENSOR_TEMP *pSensorT = &resp->params.temp_sensor;
+
+	ENTER();
+
+	if (pioctl_buf) {
+		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		pcfg->param.sensor_temp.temperature =
+			wlan_le32_to_cpu(pSensorT->temperature);
+		PRINTM(MCMND, "get SOC temperature %u C \n",
+		       pSensorT->temperature);
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h
old mode 100644
new mode 100755
index 9037910c1..53eefff5c
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_decl.h
@@ -3,7 +3,7 @@
  *  @brief This file declares the generic data structures and APIs.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -24,7 +24,7 @@
 #define _MLAN_DECL_H_
 
 /** MLAN release version */
-#define MLAN_RELEASE_VERSION "210"
+#define MLAN_RELEASE_VERSION "391.p3"
 
 /** Re-define generic data types for MLAN/MOAL */
 /** Signed char (1-byte) */
@@ -98,6 +98,8 @@ typedef t_s32 t_sval;
 /** MLAN FALSE */
 #define MFALSE (0)
 
+#define CHANNEL_SPEC_SNIFFER_MODE 1
+
 #ifndef MACSTR
 /** MAC address security format */
 #define MACSTR "%02x:XX:XX:XX:%02x:%02x"
@@ -127,17 +129,15 @@ typedef t_s32 t_sval;
 /** Return aligned offset */
 #define OFFSET_ALIGN_ADDR(p, a) (t_u32)(ALIGN_ADDR(p, a) - (t_ptr)p)
 
-#if defined(WIFI_DIRECT_SUPPORT)
 /** Maximum BSS numbers */
 #define MLAN_MAX_BSS_NUM (16)
-#else
-/** Maximum BSS numbers */
-#define MLAN_MAX_BSS_NUM (2)
-#endif
 
 /** NET IP alignment */
 #define MLAN_NET_IP_ALIGN 2
 
+/** US country code */
+#define COUNTRY_CODE_US 0x10
+
 /** DMA alignment */
 /* SDIO3.0 Inrevium Adapter require 32 bit DMA alignment */
 #define DMA_ALIGNMENT 32
@@ -233,12 +233,12 @@ typedef t_s32 t_sval;
 /** MU beamformer */
 #define DEFALUT_11AC_CAP_BEAMFORMING_RESET_MASK (MBIT(19))
 
-/** Size of rx data buffer 4096+256 */
-#define MLAN_RX_DATA_BUF_SIZE 4352
+/** Size of rx data buffer 3839+256 */
+#define MLAN_RX_DATA_BUF_SIZE 4096
 
 /** Size of command buffer */
 /** because cal_data_size 2.4 k */
-#define MRVDRV_SIZE_OF_CMD_BUFFER (4 * 1024)
+#define MRVDRV_SIZE_OF_CMD_BUFFER (3 * 1024)
 /** Size of rx command buffer */
 #define MLAN_RX_CMD_BUF_SIZE MRVDRV_SIZE_OF_CMD_BUFFER
 /** Upload size */
@@ -262,10 +262,12 @@ typedef t_s32 t_sval;
 #define FW_RELOAD_NO_EMULATION 2
 /** out band reset with interface re-emulation */
 #define FW_RELOAD_WITH_EMULATION 3
-#ifdef PCIE
 /** pcie card reset */
 #define FW_RELOAD_PCIE_RESET 4
-#endif
+/** sdio hw reset */
+#define FW_RELOAD_SDIO_HW_RESET 5
+/** pcie inband reset */
+#define FW_RELOAD_PCIE_INBAND_RESET 6
 
 #ifdef USB
 #define MLAN_USB_BLOCK_SIZE (512)
@@ -330,6 +332,8 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define ALLOC_BUF_SIZE MLAN_RX_DATA_BUF_SIZE
 /** SDIO MP aggr pkt limit */
 #define SDIO_MP_AGGR_DEF_PKT_LIMIT (16)
+/** SDIO MP aggr pkt limit 8 */
+#define SDIO_MP_AGGR_DEF_PKT_LIMIT_8 (8)
 /** max SDIO MP aggr pkt limit */
 #define SDIO_MP_AGGR_DEF_PKT_LIMIT_MAX (16)
 
@@ -365,6 +369,14 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_9097 0x07
 /** 8978 card type */
 #define CARD_TYPE_8978 0x08
+/** 9177 card type */
+#define CARD_TYPE_9177 0x09
+/** 8801 card type */
+#define CARD_TYPE_8801 0x0a
+/** OWL card type */
+#define CARD_TYPE_IW62X 0x0b
+/** Black bird card type */
+#define CARD_TYPE_AW693 0x0c
 
 /** 9098 A0 reverion num */
 #define CHIP_9098_REV_A0 1
@@ -392,6 +404,14 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_SD9097 (CARD_TYPE_9097 | (INTF_SD << 8))
 /** SD9098 card type */
 #define CARD_TYPE_SD9098 (CARD_TYPE_9098 | (INTF_SD << 8))
+/** SD9177 card type */
+#define CARD_TYPE_SD9177 (CARD_TYPE_9177 | (INTF_SD << 8))
+/** SD8801 card type */
+#define CARD_TYPE_SD8801 (CARD_TYPE_8801 | (INTF_SD << 8))
+/** SD_IW62X card type */
+#define CARD_TYPE_SDIW62X (CARD_TYPE_IW62X | (INTF_SD << 8))
+/** SD_IW62X card type */
+#define CARD_TYPE_SDAW693 (CARD_TYPE_AW693 | (INTF_SD << 8))
 
 #define IS_SD8887(ct) (CARD_TYPE_SD8887 == (ct))
 #define IS_SD8897(ct) (CARD_TYPE_SD8897 == (ct))
@@ -401,6 +421,10 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define IS_SD8987(ct) (CARD_TYPE_SD8987 == (ct))
 #define IS_SD9097(ct) (CARD_TYPE_SD9097 == (ct))
 #define IS_SD9098(ct) (CARD_TYPE_SD9098 == (ct))
+#define IS_SD9177(ct) (CARD_TYPE_SD9177 == (ct))
+#define IS_SD8801(ct) (CARD_TYPE_SD8801 == (ct))
+#define IS_SDIW62X(ct) (CARD_TYPE_SDIW62X == (ct))
+#define IS_SDAW693(ct) (CARD_TYPE_SDAW693 == (ct))
 
 /** SD8887 Card */
 #define CARD_SD8887 "SD8887"
@@ -409,15 +433,23 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 /** SD8977 Card */
 #define CARD_SD8977 "SD8977"
 /** SD8978 Card */
-#define CARD_SD8978 "SD8978"
+#define CARD_SD8978 "SDIW416"
 /** SD8997 Card */
 #define CARD_SD8997 "SD8997"
 /** SD8987 Card */
 #define CARD_SD8987 "SD8987"
 /** SD9097 Card */
-#define CARD_SD9097 "SD9097"
+#define CARD_SD9097 "SDIW620"
 /** SD9098 Card */
 #define CARD_SD9098 "SD9098"
+/** SD9177 Card */
+#define CARD_SD9177 "SDIW612"
+/** SD8801 Card */
+#define CARD_SD8801 "SD8801"
+/** SDIW62X Card */
+#define CARD_SDIW62X "SDIW62X"
+/** SDAW693 Card */
+#define CARD_SDAW693 "SDAW693"
 #endif
 
 #ifdef PCIE
@@ -429,25 +461,41 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_PCIE9097 (CARD_TYPE_9097 | (INTF_PCIE << 8))
 /** PCIE9098 card type */
 #define CARD_TYPE_PCIE9098 (CARD_TYPE_9098 | (INTF_PCIE << 8))
+/** PCIEIW62X card type */
+#define CARD_TYPE_PCIEIW62X (CARD_TYPE_IW62X | (INTF_PCIE << 8))
+/** PCIEAW693 card type */
+#define CARD_TYPE_PCIEAW693 (CARD_TYPE_AW693 | (INTF_PCIE << 8))
 
 #define IS_PCIE8897(ct) (CARD_TYPE_PCIE8897 == (ct))
 #define IS_PCIE8997(ct) (CARD_TYPE_PCIE8997 == (ct))
 #define IS_PCIE9097(ct) (CARD_TYPE_PCIE9097 == (ct))
 #define IS_PCIE9098(ct) (CARD_TYPE_PCIE9098 == (ct))
+#define IS_PCIEIW62X(ct) (CARD_TYPE_PCIEIW62X == (ct))
+#define IS_PCIEAW693(ct) (CARD_TYPE_PCIEAW693 == (ct))
 
 /** PCIE8897 Card */
 #define CARD_PCIE8897 "PCIE8897"
 /** PCIE8997 Card */
 #define CARD_PCIE8997 "PCIE8997"
 /** PCIE9097 Card */
-#define CARD_PCIE9097 "PCIE9097"
+#define CARD_PCIE9097 "PCIEIW620"
 /** PCIE9000S Card */
 #define CARD_PCIE9000S "PCIE9000S"
 /** PCIE9098 Card */
 #define CARD_PCIE9098 "PCIE9098"
+/** PCIEAW690 Card */
+#define CARD_PCIEAW690 "PCIEAW690"
+/** PCIEIW62X Card */
+#define CARD_PCIEIW62X "PCIEIW62X"
+/** PCIEAW693 Card */
+#define CARD_PCIEAW693 "PCIEAW693"
+/** PCIEIW629 Card */
+#define CARD_PCIEIW629 "PCIEIW629"
 #endif
 
 #ifdef USB
+/** USB8801 card type */
+#define CARD_TYPE_USB8801 (CARD_TYPE_8801 | (INTF_USB << 8))
 /** USB8897 card type */
 #define CARD_TYPE_USB8897 (CARD_TYPE_8897 | (INTF_USB << 8))
 /** USB8997 card type */
@@ -458,25 +506,34 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_USB9098 (CARD_TYPE_9098 | (INTF_USB << 8))
 /** USB9097 card type */
 #define CARD_TYPE_USB9097 (CARD_TYPE_9097 | (INTF_USB << 8))
+/** USBIW62X card type */
+#define CARD_TYPE_USBIW62X (CARD_TYPE_IW62X | (INTF_USB << 8))
 
+#define IS_USB8801(ct) (CARD_TYPE_USB8801 == (ct))
 #define IS_USB8897(ct) (CARD_TYPE_USB8897 == (ct))
 #define IS_USB8997(ct) (CARD_TYPE_USB8997 == (ct))
 #define IS_USB8978(ct) (CARD_TYPE_USB8978 == (ct))
 #define IS_USB9098(ct) (CARD_TYPE_USB9098 == (ct))
 #define IS_USB9097(ct) (CARD_TYPE_USB9097 == (ct))
+#define IS_USBIW62X(ct) (CARD_TYPE_USBIW62X == (ct))
 
+/** USB8801 Card */
+#define CARD_USB8801 "USB8801"
 /** USB8897 Card */
 #define CARD_USB8897 "USB8897"
 /** USB8997 Card */
 #define CARD_USB8997 "USB8997"
 /** USB8978 Card */
-#define CARD_USB8978 "USB8978"
+#define CARD_USB8978 "USBIW416"
 /** USB9098 Card */
 #define CARD_USB9098 "USB9098"
 /** USB9097 Card */
-#define CARD_USB9097 "USB9097"
+#define CARD_USB9097 "USBIW620"
+/** USBIW62X Card */
+#define CARD_USBIW62X "USBIW62X"
 #endif
 
+#define IS_CARD8801(ct) (CARD_TYPE_8801 == ((ct)&0xf))
 #define IS_CARD8887(ct) (CARD_TYPE_8887 == ((ct)&0xf))
 #define IS_CARD8897(ct) (CARD_TYPE_8897 == ((ct)&0xf))
 #define IS_CARD8977(ct) (CARD_TYPE_8977 == ((ct)&0xf))
@@ -484,6 +541,9 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define IS_CARD8987(ct) (CARD_TYPE_8987 == ((ct)&0xf))
 #define IS_CARD9098(ct) (CARD_TYPE_9098 == ((ct)&0xf))
 #define IS_CARD9097(ct) (CARD_TYPE_9097 == ((ct)&0xf))
+#define IS_CARD9177(ct) (CARD_TYPE_9177 == ((ct)&0xf))
+#define IS_CARDIW62X(ct) (CARD_TYPE_IW62X == ((ct)&0xf))
+#define IS_CARDAW693(ct) (CARD_TYPE_AW693 == ((ct)&0xf))
 
 typedef struct _card_type_entry {
 	t_u16 card_type;
@@ -534,12 +594,18 @@ typedef enum {
 #define MLAN_BUF_FLAG_USB_TX_AGGR MBIT(7)
 #endif
 
+/** Buffer flag for TDLS */
+#define MLAN_BUF_FLAG_TDLS MBIT(8)
+
 /** Buffer flag for TCP_ACK */
 #define MLAN_BUF_FLAG_TCP_ACK MBIT(9)
 
 /** Buffer flag for TX_STATUS */
 #define MLAN_BUF_FLAG_TX_STATUS MBIT(10)
 
+/** Buffer flag for NET_MONITOR */
+#define MLAN_BUF_FLAG_NET_MONITOR MBIT(11)
+
 /** Buffer flag for NULL data packet */
 #define MLAN_BUF_FLAG_NULL_PKT MBIT(12)
 /** Buffer flag for Diag pkt */
@@ -547,6 +613,10 @@ typedef enum {
 
 #define MLAN_BUF_FLAG_TX_CTRL MBIT(14)
 
+#define MLAN_BUF_FLAG_EASYMESH MBIT(16)
+
+#define MLAN_BUF_FLAG_MC_AGGR_PKT MBIT(17)
+
 #ifdef DEBUG_LEVEL1
 /** Debug level bit definition */
 #define MMSG MBIT(0)
@@ -575,6 +645,8 @@ typedef enum {
 
 /** Memory allocation type: DMA */
 #define MLAN_MEM_DMA MBIT(0)
+/** Memory allocation flag: ATOMIC */
+#define MLAN_MEM_FLAG_ATOMIC MBIT(1)
 
 /** Default memory allocation flag */
 #define MLAN_MEM_DEF 0
@@ -633,6 +705,18 @@ typedef enum _mlan_buf_type {
 #endif
 } mlan_buf_type;
 
+#define SCAN_STATE_SCAN_START MBIT(0)
+#define SCAN_STATE_EXT_SCAN MBIT(1)
+#define SCAN_STATE_EXT_SCAN_ENH MBIT(2)
+#define SCAN_STATE_EXT_SCAN_CANCEL MBIT(3)
+#define SCAN_STATE_EXT_SCAN_CMDRESP MBIT(4)
+#define SCAN_STATE_EXT_SCAN_ENH_CMDRESP MBIT(5)
+#define SCAN_STATE_EXT_SCAN_CANCEL_CMDRESP MBIT(6)
+#define SCAN_STATE_EXT_SCAN_RESULT MBIT(7)
+#define SCAN_STATE_LAST_EXT_SCAN_RESULT MBIT(8)
+#define SCAN_STATE_EXT_SCAN_STATUS MBIT(9)
+#define SCAN_STATE_SCAN_COMPLETE MBIT(10)
+
 #ifdef USB
 /** mlan_usb_ep */
 typedef enum _mlan_usb_ep {
@@ -656,6 +740,7 @@ typedef enum _mlan_bss_type {
 #ifdef WIFI_DIRECT_SUPPORT
 	MLAN_BSS_TYPE_WIFIDIRECT = 2,
 #endif
+	MLAN_BSS_TYPE_DFS = 8,
 	MLAN_BSS_TYPE_ANY = 0xff,
 } mlan_bss_type;
 
@@ -729,6 +814,7 @@ typedef enum _mlan_event_id {
 #if defined(PCIE)
 	MLAN_EVENT_ID_SSU_DUMP_FILE = 0x00000039,
 #endif /* SSU_SUPPORT */
+	MLAN_EVENT_ID_CSI = 0x00000040,
 	/* Event generated by MLAN driver (MSB=1) */
 	MLAN_EVENT_ID_DRV_CONNECTED = 0x80000001,
 	MLAN_EVENT_ID_DRV_DEFER_HANDLING = 0x80000002,
@@ -745,11 +831,14 @@ typedef enum _mlan_event_id {
 	MLAN_EVENT_ID_DRV_BGSCAN_RESULT = 0x80000013,
 	MLAN_EVENT_ID_DRV_FLUSH_RX_WORK = 0x80000015,
 	MLAN_EVENT_ID_DRV_DEFER_RX_WORK = 0x80000016,
+	MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ = 0x80000017,
 	MLAN_EVENT_ID_DRV_FT_RESPONSE = 0x80000018,
 	MLAN_EVENT_ID_DRV_FLUSH_MAIN_WORK = 0x80000019,
 #ifdef UAP_SUPPORT
 	MLAN_EVENT_ID_DRV_UAP_CHAN_INFO = 0x80000020,
 #endif
+	MLAN_EVENT_ID_FW_ROAM_OFFLOAD_RESULT = 0x80000023,
+	MLAN_EVENT_ID_DRV_RTT_RESULT = 0x80000025,
 	MLAN_EVENT_ID_DRV_ASSOC_FAILURE_LOGGER = 0x80000026,
 	MLAN_EVENT_ID_DRV_ASSOC_SUCC_LOGGER = 0x80000027,
 	MLAN_EVENT_ID_DRV_DISCONNECT_LOGGER = 0x80000028,
@@ -835,7 +924,8 @@ enum mlan_channel_type {
 /** channel band */
 enum { BAND_2GHZ = 0,
        BAND_5GHZ = 1,
-       BAND_4GHZ = 2,
+       BAND_6GHZ = 2,
+       BAND_4GHZ = 3,
 };
 
 /** channel offset */
@@ -857,6 +947,24 @@ enum { SCAN_MODE_MANUAL = 0,
        SCAN_MODE_USER,
 };
 
+/** DFS state */
+typedef enum _dfs_state_t {
+	/** Channel can be used, CAC (Channel Availability Check) must be done
+	   before using it */
+	DFS_USABLE = 0,
+	/** Channel is not available, radar was detected */
+	DFS_UNAVAILABLE = 1,
+	/** Channel is Available, CAC is done and is free of radar */
+	DFS_AVAILABLE = 2,
+} dfs_state_t;
+
+/** max cac time 10 minutes */
+#define MAX_CAC_DWELL_TIME 600000
+/** default cac time 60 seconds */
+#define DEF_CAC_DWELL_TIME 60000
+/** start freq for 5G */
+#define START_FREQ_11A_BAND 5000
+
 typedef enum _dfs_w53_cfg_t {
 	/** DFS W53 Default Fw Value */
 	DFS_W53_DEFAULT_FW = 0,
@@ -866,6 +974,14 @@ typedef enum _dfs_w53_cfg_t {
 	DFS_W53_OLD = 2
 } dfs_w53_cfg_t;
 
+typedef enum _dfs_moe_t {
+	/** driver default DFS behavior */
+	DFS_MODE_DEFAULT = 0,
+	/* disable DFS master when uap and station operate in same DFS channel
+	 */
+	DFS_MODE_ENH = 1,
+} dfs_mode_t;
+
 /** Band_Config_t */
 typedef MLAN_PACK_START struct _Band_Config_t {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -875,10 +991,10 @@ typedef MLAN_PACK_START struct _Band_Config_t {
 	t_u8 chan2Offset : 2;
 	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
 	t_u8 chanWidth : 2;
-	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	/** Band Info - (00)=2.4GHz, (01)=5GHz, (10)=6GHz */
 	t_u8 chanBand : 2;
 #else
-	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	/** Band Info - (00)=2.4GHz, (01)=5GHz, (10)=6GHz */
 	t_u8 chanBand : 2;
 	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
 	t_u8 chanWidth : 2;
@@ -901,7 +1017,7 @@ typedef MLAN_PACK_START struct _chan_band_info {
 	t_u8 center_chan;
 	/** dfs channel flag */
 	t_u8 is_dfs_chan;
-} MLAN_PACK_END chan_band_info, *pchan_band_info;
+} MLAN_PACK_END chan_band_info;
 
 /** Channel usability flags */
 #define NXP_CHANNEL_NO_OFDM MBIT(9)
@@ -930,6 +1046,9 @@ typedef struct _cfp_dyn_t {
 	t_u16 flags;
 	/** TRUE: Channel is blacklisted (do not use) */
 	t_bool blacklist;
+	/** DFS state of the channel
+	 * 0:DFS_USABLE  1:DFS_AVAILABLE  2:DFS_UNAVAILABLE */
+	dfs_state_t dfs_state;
 } cfp_dyn_t;
 
 /** Chan-Freq-TxPower mapping table*/
@@ -973,6 +1092,45 @@ typedef struct _mlan_cmdresp_event {
 } mlan_cmdresp_event, *pmlan_cmdresp_event;
 
 /** csi event data structure */
+typedef MLAN_PACK_START struct _csi_record_ds {
+	/** Length in DWORDS, including header */
+	t_u16 Len;
+	/** CSI signature. 0xABCD fixed */
+	t_u16 CSI_Sign;
+	/** User defined HeaderID  */
+	t_u32 CSI_HeaderID;
+	/** Packet info field */
+	t_u16 PKT_info;
+	/** Frame control field for the received packet*/
+	t_u16 FCF;
+	/** Timestamp when packet received */
+	t_u64 TSF;
+	/** Received Packet Destination MAC Address */
+	t_u8 Dst_MAC[6];
+	/** Received Packet Source MAC Address */
+	t_u8 Src_MAC[6];
+	/** RSSI for antenna A */
+	t_u8 Rx_RSSI_A;
+	/** RSSI for antenna B */
+	t_u8 Rx_RSSI_B;
+	/** Noise floor for antenna A */
+	t_u8 Rx_NF_A;
+	/** Noise floor for antenna A */
+	t_u8 Rx_NF_B;
+	/** Rx signal strength above noise floor */
+	t_u8 Rx_SINR;
+	/** Channel */
+	t_u8 channel;
+	/** user defined Chip ID */
+	t_u16 chip_id;
+	/** Reserved */
+	t_u32 rsvd;
+	/** CSI data length in DWORDs */
+	t_u32 CSI_Data_Length;
+	/** Start of CSI data */
+	t_u8 CSI_Data[0];
+	/** At the end of CSI raw data, user defined TailID of 4 bytes*/
+} MLAN_PACK_END csi_record_ds, *pcsi_record_ds;
 
 /** mlan_ioctl_req data structure */
 typedef struct _mlan_ioctl_req {
@@ -1000,6 +1158,56 @@ typedef struct _mlan_ioctl_req {
 	t_ptr reserved_1;
 } mlan_ioctl_req, *pmlan_ioctl_req;
 
+typedef MLAN_PACK_START struct _mix_rate_info {
+	/**  bit0: LGI: gi=0, SGI: gi= 1 */
+	/**  bit1-2: 20M: bw=0, 40M: bw=1, 80M: bw=2, 160M: bw=3  */
+	/**  bit3-4: LG: format=0, HT: format=1, VHT: format=2 */
+	/**  bit5: LDPC: 0-not support,  1-support */
+	/**  bit6-7:reserved */
+	t_u8 rate_info;
+	/** MCS index */
+	t_u8 mcs_index;
+	/** bitrate, in 500Kbps */
+	t_u16 bitrate;
+	/** NSS */
+	t_u8 nss_index;
+	/** DCM */
+	t_u8 dcm;
+} MLAN_PACK_END mix_rate_info, *pmix_rate_info;
+
+typedef MLAN_PACK_START struct _rxpd_extra_info {
+	/** flags */
+	t_u8 flags;
+	/** channel.flags */
+	t_u16 channel_flags;
+	/** mcs.known */
+	t_u8 mcs_known;
+	/** mcs.flags */
+	t_u8 mcs_flags;
+	/** vht/he sig1 */
+	t_u32 vht_he_sig1;
+	/** vht/he sig2 */
+	t_u32 vht_he_sig2;
+	/** HE user idx */
+	t_u32 user_idx;
+} MLAN_PACK_END rxpd_extra_info, *prxpd_extra_info;
+
+typedef MLAN_PACK_START struct _radiotap_info {
+	/** Rate Info */
+	mix_rate_info rate_info;
+	/** SNR */
+	t_s8 snr;
+	/** Noise Floor */
+	t_s8 nf;
+	/** band config */
+	t_u8 band_config;
+	/** chan number */
+	t_u8 chan_num;
+	t_u8 antenna;
+	/** extra rxpd info from FW */
+	rxpd_extra_info extra_info;
+} MLAN_PACK_END radiotap_info, *pradiotap_info;
+
 /** txpower structure */
 typedef MLAN_PACK_START struct {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -1051,6 +1259,25 @@ typedef MLAN_PACK_START struct _pkt_rxinfo {
 	t_u8 rssi;
 } MLAN_PACK_END pkt_rxinfo, *ppkt_rxinfo;
 
+#define MC_FLAG_RETRY MBIT(0)
+#define MC_FLAG_START_CYCLE MBIT(1)
+#define MC_FLAG_END_CYCLE MBIT(2)
+#define MC_FLAG_START_AMPDU MBIT(3)
+#define MC_FLAG_END_AMPDU MBIT(4)
+/* mc pkt txcontrol */
+typedef MLAN_PACK_START struct _mc_txcontrol {
+	/** Data rate in mcs index, 0-7 */
+	t_u8 mcs_index;
+	/** band width 0-20Mhz, 1-40Mhz */
+	t_u8 bandwidth;
+	/** seq_num */
+	t_u16 seq_num;
+	/** packet expiry time */
+	t_u32 pkt_expiry;
+	/** mc_pkt_flags */
+	t_u8 mc_pkt_flags;
+} MLAN_PACK_END mc_txcontrol, *pmc_txcontrol;
+
 /** mlan_buffer data structure */
 typedef struct _mlan_buffer {
 	/** Pointer to previous mlan_buffer */
@@ -1092,21 +1319,28 @@ typedef struct _mlan_buffer {
 	t_u32 out_ts_usec;
 	/** tx_seq_num */
 	t_u32 tx_seq_num;
-
+	/** Time stamp when packet is deque from rx_q(seconds) */
+	t_u32 extra_ts_sec;
+	/** Time stamp when packet is dequed from rx_q(micro seconds) */
+	t_u32 extra_ts_usec;
+	/** When TX ra mac address,  When Rx Ta mac address*/
+	t_u8 mac[MLAN_MAC_ADDR_LENGTH];
 	/** Fields below are valid for MLAN module only */
 	/** Pointer to parent mlan_buffer */
 	struct _mlan_buffer *pparent;
 	/** Use count for this buffer */
 	t_u32 use_count;
 	union {
+		mc_txcontrol mc_tx_info;
 		pkt_txctrl tx_info;
 		pkt_rxinfo rx_info;
 	} u;
 } mlan_buffer, *pmlan_buffer, **ppmlan_buffer;
 
-/** mlan_fw_info data structure */
+/** mlan_hw_info data structure */
 typedef struct _mlan_hw_info {
 	t_u32 fw_cap;
+	t_u32 fw_cap_ext;
 } mlan_hw_info, *pmlan_hw_info;
 
 /** mlan_bss_attr data structure */
@@ -1245,6 +1479,242 @@ typedef MLAN_PACK_START struct _tlvbuf_custom_ie {
 	tlvbuf_max_mgmt_ie max_mgmt_ie;
 } MLAN_PACK_END mlan_ds_misc_custom_ie;
 
+/** Max TDLS config data length */
+#define MAX_TDLS_DATA_LEN 1024
+
+/** Action commands for TDLS enable/disable */
+#define WLAN_TDLS_CONFIG 0x00
+/** Action commands for TDLS configuration :Set */
+#define WLAN_TDLS_SET_INFO 0x01
+/** Action commands for TDLS configuration :Discovery Request */
+#define WLAN_TDLS_DISCOVERY_REQ 0x02
+/** Action commands for TDLS configuration :Setup Request */
+#define WLAN_TDLS_SETUP_REQ 0x03
+/** Action commands for TDLS configuration :Tear down Request */
+#define WLAN_TDLS_TEAR_DOWN_REQ 0x04
+/** Action ID for TDLS power mode */
+#define WLAN_TDLS_POWER_MODE 0x05
+/**Action ID for init TDLS Channel Switch*/
+#define WLAN_TDLS_INIT_CHAN_SWITCH 0x06
+/** Action ID for stop TDLS Channel Switch */
+#define WLAN_TDLS_STOP_CHAN_SWITCH 0x07
+/** Action ID for configure CS related parameters */
+#define WLAN_TDLS_CS_PARAMS 0x08
+/** Action ID for Disable CS */
+#define WLAN_TDLS_CS_DISABLE 0x09
+/** Action ID for TDLS link status */
+#define WLAN_TDLS_LINK_STATUS 0x0A
+/** Action ID for Host TDLS config uapsd and CS */
+#define WLAN_HOST_TDLS_CONFIG 0x0D
+/** Action ID for TDLS CS immediate return */
+#define WLAN_TDLS_DEBUG_CS_RET_IM 0xFFF7
+/** Action ID for TDLS Stop RX */
+#define WLAN_TDLS_DEBUG_STOP_RX 0xFFF8
+/** Action ID for TDLS Allow weak security for links establish */
+#define WLAN_TDLS_DEBUG_ALLOW_WEAK_SECURITY 0xFFF9
+/** Action ID for TDLS Ignore key lifetime expiry */
+#define WLAN_TDLS_DEBUG_IGNORE_KEY_EXPIRY 0xFFFA
+/** Action ID for TDLS Higher/Lower mac Test */
+#define WLAN_TDLS_DEBUG_HIGHER_LOWER_MAC 0xFFFB
+/** Action ID for TDLS Prohibited Test */
+#define WLAN_TDLS_DEBUG_SETUP_PROHIBITED 0xFFFC
+/** Action ID for TDLS Existing link Test */
+#define WLAN_TDLS_DEBUG_SETUP_SAME_LINK 0xFFFD
+/** Action ID for TDLS Fail Setup Confirm */
+#define WLAN_TDLS_DEBUG_FAIL_SETUP_CONFIRM 0xFFFE
+/** Action commands for TDLS debug: Wrong BSS Request */
+#define WLAN_TDLS_DEBUG_WRONG_BSS 0xFFFF
+
+/** tdls each link rate information */
+typedef MLAN_PACK_START struct _tdls_link_rate_info {
+	/** Tx Data Rate */
+	t_u8 tx_data_rate;
+	/** Tx Rate HT info*/
+	t_u8 tx_rate_htinfo;
+} MLAN_PACK_END tdls_link_rate_info;
+
+/** tdls each link status */
+typedef MLAN_PACK_START struct _tdls_each_link_status {
+	/** peer mac Address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** Link Flags */
+	t_u8 link_flags;
+	/** Traffic Status */
+	t_u8 traffic_status;
+	/** Tx Failure Count */
+	t_u8 tx_fail_count;
+	/** Channel Number */
+	t_u32 active_channel;
+	/** Last Data RSSI in dBm */
+	t_s16 data_rssi_last;
+	/** Last Data NF in dBm */
+	t_s16 data_nf_last;
+	/** AVG DATA RSSI in dBm */
+	t_s16 data_rssi_avg;
+	/** AVG DATA NF in dBm */
+	t_s16 data_nf_avg;
+	union {
+		/** tdls rate info */
+		tdls_link_rate_info rate_info;
+		/** tdls link final rate*/
+		t_u16 final_data_rate;
+	} u;
+	/** Security Method */
+	t_u8 security_method;
+	/** Key Lifetime in milliseconds */
+	t_u32 key_lifetime;
+	/** Key Length */
+	t_u8 key_length;
+	/** actual key */
+	t_u8 key[1];
+} MLAN_PACK_END tdls_each_link_status;
+
+/** TDLS configuration data */
+typedef MLAN_PACK_START struct _tdls_all_config {
+	union {
+		/** TDLS state enable disable */
+		MLAN_PACK_START struct _tdls_config {
+			/** enable or disable */
+			t_u16 enable;
+		} MLAN_PACK_END tdls_config;
+		/** Host tdls config */
+		MLAN_PACK_START struct _host_tdls_cfg {
+			/** support uapsd */
+			t_u8 uapsd_support;
+			/** channel_switch */
+			t_u8 cs_support;
+			/** TLV  length */
+			t_u16 tlv_len;
+			/** tdls info */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END host_tdls_cfg;
+		/** TDLS set info */
+		MLAN_PACK_START struct _tdls_set_data {
+			/** (tlv + capInfo) length */
+			t_u16 tlv_length;
+			/** Cap Info */
+			t_u16 cap_info;
+			/** TLV buffer */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END tdls_set;
+
+		/** TDLS discovery and others having mac argument */
+		MLAN_PACK_START struct _tdls_discovery_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+		} MLAN_PACK_END tdls_discovery, tdls_stop_chan_switch,
+			tdls_link_status_req;
+
+		/** TDLS discovery Response */
+		MLAN_PACK_START struct _tdls_discovery_resp {
+			/** payload length */
+			t_u16 payload_len;
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** RSSI */
+			t_s8 rssi;
+			/** Cap Info */
+			t_u16 cap_info;
+			/** TLV buffer */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END tdls_discovery_resp;
+
+		/** TDLS setup request */
+		MLAN_PACK_START struct _tdls_setup_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** timeout value in milliseconds */
+			t_u32 setup_timeout;
+			/** key lifetime in milliseconds */
+			t_u32 key_lifetime;
+		} MLAN_PACK_END tdls_setup;
+
+		/** TDLS tear down info */
+		MLAN_PACK_START struct _tdls_tear_down_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** reason code */
+			t_u16 reason_code;
+		} MLAN_PACK_END tdls_tear_down, tdls_cmd_resp;
+
+		/** TDLS power mode info */
+		MLAN_PACK_START struct _tdls_power_mode_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** Power Mode */
+			t_u16 power_mode;
+		} MLAN_PACK_END tdls_power_mode;
+
+		/** TDLS channel switch info */
+		MLAN_PACK_START struct _tdls_chan_switch {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** Channel Switch primary channel no */
+			t_u8 primary_channel;
+			/** Channel Switch secondary channel offset */
+			t_u8 secondary_channel_offset;
+			/** Channel Switch Band */
+			t_u8 band;
+			/** Channel Switch time in milliseconds */
+			t_u16 switch_time;
+			/** Channel Switch timeout in milliseconds */
+			t_u16 switch_timeout;
+			/** Channel Regulatory class*/
+			t_u8 regulatory_class;
+			/** peridicity flag*/
+			t_u8 periodicity;
+		} MLAN_PACK_END tdls_chan_switch;
+
+		/** TDLS channel switch paramters */
+		MLAN_PACK_START struct _tdls_cs_params {
+			/** unit time, multiples of 10ms */
+			t_u8 unit_time;
+			/** threshold for other link */
+			t_u8 threshold_otherlink;
+			/** threshold for direct link */
+			t_u8 threshold_directlink;
+		} MLAN_PACK_END tdls_cs_params;
+
+		/** tdls disable channel switch */
+		MLAN_PACK_START struct _tdls_disable_cs {
+			/** Data*/
+			t_u16 data;
+		} MLAN_PACK_END tdls_disable_cs;
+		/** TDLS debug data */
+		MLAN_PACK_START struct _tdls_debug_data {
+			/** debug data */
+			t_u16 debug_data;
+		} MLAN_PACK_END tdls_debug_data;
+
+		/** TDLS link status Response */
+		MLAN_PACK_START struct _tdls_link_status_resp {
+			/** payload length */
+			t_u16 payload_len;
+			/** number of links */
+			t_u8 active_links;
+			/** structure for link status */
+			tdls_each_link_status link_stats[1];
+		} MLAN_PACK_END tdls_link_status_resp;
+
+	} u;
+} MLAN_PACK_END tdls_all_config;
+
+/** TDLS configuration buffer */
+typedef MLAN_PACK_START struct _buf_tdls_config {
+	/** TDLS Action */
+	t_u16 tdls_action;
+	/** TDLS data */
+	t_u8 tdls_data[MAX_TDLS_DATA_LEN];
+} MLAN_PACK_END mlan_ds_misc_tdls_config;
+
+/** Event structure for tear down */
+typedef struct _tdls_tear_down_event {
+	/** Peer mac address */
+	t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Reason code */
+	t_u16 reason_code;
+} tdls_tear_down_event;
+
 /** channel width */
 typedef enum wifi_channel_width {
 	WIFI_CHAN_WIDTH_20 = 0,
@@ -1302,6 +1772,15 @@ typedef struct {
 	t_u32 time_usec;
 } wifi_timeval;
 
+#define timeval_to_msec(timeval)                                               \
+	(t_u64)((t_u64)(timeval.time_sec) * 1000 +                             \
+		(t_u64)(timeval.time_usec) / 1000)
+#define timeval_to_usec(timeval)                                               \
+	(t_u64)((t_u64)(timeval.time_sec) * 1000 * 1000 +                      \
+		(t_u64)(timeval.time_usec))
+#define is_zero_timeval(timeval)                                               \
+	((timeval.time_sec == 0) && (timeval.time_usec == 0))
+
 #define MAX_NUM_RATE 32
 #define MAX_RADIO 2
 #define MAX_NUM_CHAN 1
@@ -1383,15 +1862,6 @@ typedef struct {
 	t_u32 cca_busy_time;
 } wifi_channel_stat;
 
-#define timeval_to_msec(timeval)                                               \
-	(t_u64)((t_u64)(timeval.time_sec) * 1000 +                             \
-		(t_u64)(timeval.time_usec) / 1000)
-#define timeval_to_usec(timeval)                                               \
-	(t_u64)((t_u64)(timeval.time_sec) * 1000 * 1000 +                      \
-		(t_u64)(timeval.time_usec))
-#define is_zero_timeval(timeval)                                               \
-	((timeval.time_sec == 0) && (timeval.time_usec == 0))
-
 /** radio statistics */
 typedef struct {
 	/** wifi radio (if multiple radio supported) */
@@ -1585,9 +2055,320 @@ typedef struct {
 	0x00000080 /** all contention (min, max, avg) statistics (within ac    \
 		      statisctics) */
 
+/** =========== Define Copied from HAL START =========== */
+/** Ranging status */
+typedef enum {
+	RTT_STATUS_SUCCESS = 0,
+	/** general failure status */
+	RTT_STATUS_FAILURE = 1,
+	/** target STA does not respond to request */
+	RTT_STATUS_FAIL_NO_RSP = 2,
+	/** request rejected. Applies to 2-sided RTT only */
+	RTT_STATUS_FAIL_REJECTED = 3,
+	RTT_STATUS_FAIL_NOT_SCHEDULED_YET = 4,
+	/** timing measurement times out */
+	RTT_STATUS_FAIL_TM_TIMEOUT = 5,
+	/** Target on different channel, cannot range */
+	RTT_STATUS_FAIL_AP_ON_DIFF_CHANNEL = 6,
+	/** ranging not supported */
+	RTT_STATUS_FAIL_NO_CAPABILITY = 7,
+	/** request aborted for unknown reason */
+	RTT_STATUS_ABORTED = 8,
+	/** Invalid T1-T4 timestamp */
+	RTT_STATUS_FAIL_INVALID_TS = 9,
+	/** 11mc protocol failed */
+	RTT_STATUS_FAIL_PROTOCOL = 10,
+	/** request could not be scheduled */
+	RTT_STATUS_FAIL_SCHEDULE = 11,
+	/** responder cannot collaborate at time of request */
+	RTT_STATUS_FAIL_BUSY_TRY_LATER = 12,
+	/** bad request args */
+	RTT_STATUS_INVALID_REQ = 13,
+	/** WiFi not enabled */
+	RTT_STATUS_NO_WIFI = 14,
+	/** Responder overrides param info, cannot range with new params */
+	RTT_STATUS_FAIL_FTM_PARAM_OVERRIDE = 15
+} wifi_rtt_status;
+
+/** RTT peer type */
+typedef enum {
+	RTT_PEER_AP = 0x1,
+	RTT_PEER_STA = 0x2,
+	RTT_PEER_P2P_GO = 0x3,
+	RTT_PEER_P2P_CLIENT = 0x4,
+	RTT_PEER_NAN = 0x5
+} rtt_peer_type;
+
+/** RTT Measurement Bandwidth */
+typedef enum {
+	WIFI_RTT_BW_5 = 0x01,
+	WIFI_RTT_BW_10 = 0x02,
+	WIFI_RTT_BW_20 = 0x04,
+	WIFI_RTT_BW_40 = 0x08,
+	WIFI_RTT_BW_80 = 0x10,
+	WIFI_RTT_BW_160 = 0x20
+} wifi_rtt_bw;
+
+/** RTT Type */
+typedef enum {
+	RTT_TYPE_1_SIDED = 0x1,
+	RTT_TYPE_2_SIDED = 0x2,
+} wifi_rtt_type;
+
+/** RTT configuration */
+typedef struct {
+	/** peer device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** 1-sided or 2-sided RTT */
+	wifi_rtt_type type;
+	/** optional - peer device hint (STA, P2P, AP) */
+	rtt_peer_type peer;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	wifi_channel_info channel;
+	/** Time interval between bursts (units: 100 ms).
+	 * Applies to 1-sided and 2-sided RTT multi-burst requests.
+	 * Range: 0-31, 0: no preference by initiator (2-sided RTT) */
+	t_u32 burst_period;
+	/** Total number of RTT bursts to be executed. It will be
+	 * specified in the same way as the parameter "Number of
+	 * Burst Exponent" found in the FTM frame format. It
+	 * applies to both: 1-sided RTT and 2-sided RTT. Valid
+	 * values are 0 to 15 as defined in 802.11mc std.
+	 * 0 means single shot
+	 * The implication of this parameter on the maximum
+	 * number of RTT results is the following:
+	 * for 1-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst)
+	 * for 2-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst - 1) */
+	t_u32 num_burst;
+	/** num of frames per burst. Minimum value = 1, Maximum value = 31
+	 * For 2-sided this equals the number of FTM frames to be attempted in a
+	 * single burst. This also equals the number of FTM frames that the
+	 * initiator will request that the responder send in a single frame. */
+	t_u32 num_frames_per_burst;
+	/** number of retries for a failed RTT frame. Applies
+	 * to 1-sided RTT only. Minimum value = 0, Maximum value = 3 */
+	t_u32 num_retries_per_rtt_frame;
+
+	/** following fields are only valid for 2-side RTT */
+	/** Maximum number of retries that the initiator can retry an FTMR
+	 * frame. Minimum value = 0, Maximum value = 3 */
+	t_u32 num_retries_per_ftmr;
+	/** 1: request LCI, 0: do not request LCI */
+	t_u8 LCI_request;
+	/** 1: request LCR, 0: do not request LCR */
+	t_u8 LCR_request;
+	/** Applies to 1-sided and 2-sided RTT. Valid values will
+	 * be 2-11 and 15 as specified by the 802.11mc std for
+	 * the FTM parameter burst duration. In a multi-burst
+	 * request, if responder overrides with larger value,
+	 * the initiator will return failure. In a single-burst
+	 * request if responder overrides with larger value,
+	 * the initiator will sent TMR_STOP to terminate RTT
+	 * at the end of the burst_duration it requested. */
+	t_u32 burst_duration;
+	/** RTT preamble to be used in the RTT frames */
+	wifi_preamble preamble;
+	/** RTT BW to be used in the RTT frames */
+	wifi_rtt_bw bw;
+} wifi_rtt_config;
+
+/** Format of information elements found in the beacon */
+typedef struct {
+	/** element identifier */
+	t_u8 id;
+	/** number of bytes to follow */
+	t_u8 len;
+	t_u8 data[];
+} wifi_information_element;
+
+/** RTT results */
+typedef struct {
+	/** device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** burst number in a multi-burst request */
+	t_u32 burst_num;
+	/** Total RTT measurement frames attempted */
+	t_u32 measurement_number;
+	/** Total successful RTT measurement frames */
+	t_u32 success_number;
+	/** Maximum number of "FTM frames per burst" supported by
+	 * the responder STA. Applies to 2-sided RTT only.
+	 * If reponder overrides with larger value:
+	 * - for single-burst request initiator will truncate the
+	 * larger value and send a TMR_STOP after receiving as
+	 * many frames as originally requested.
+	 * - for multi-burst request, initiator will return
+	 * failure right away */
+	t_u8 number_per_burst_peer;
+	/** ranging status */
+	wifi_rtt_status status;
+	/** When status == RTT_STATUS_FAIL_BUSY_TRY_LATER,
+	 * this will be the time provided by the responder as to
+	 * when the request can be tried again. Applies to 2-sided
+	 * RTT only. In sec, 1-31sec. */
+	t_u8 retry_after_duration;
+	/** RTT type */
+	wifi_rtt_type type;
+	/** average rssi in 0.5 dB steps e.g. 143 implies -71.5 dB */
+	int rssi;
+	/** rssi spread in 0.5 dB steps e.g. 5 implies 2.5 dB spread (optional)
+	 */
+	int rssi_spread;
+	/** 1-sided RTT: TX rate of RTT frame.
+	 * 2-sided RTT: TX rate of initiator's Ack in response to FTM frame. */
+	wifi_rate tx_rate;
+	/** 1-sided RTT: TX rate of Ack from other side.
+	 * 2-sided RTT: TX rate of FTM frame coming from responder. */
+	wifi_rate rx_rate;
+	/** round trip time in picoseconds */
+	t_s64 rtt;
+	/** rtt standard deviation in picoseconds */
+	t_s64 rtt_sd;
+	/** difference between max and min rtt times recorded in picoseconds */
+	t_s64 rtt_spread;
+	/** distance in mm (optional) */
+	int distance_mm;
+	/** standard deviation in mm (optional) */
+	int distance_sd_mm;
+	/** difference between max and min distance recorded in mm (optional) */
+	int distance_spread_mm;
+	/** time of the measurement (in microseconds since boot) */
+	t_s64 ts;
+	/** in ms, actual time taken by the FW to finish one burst
+	 * measurement. Applies to 1-sided and 2-sided RTT. */
+	int burst_duration;
+	/** Number of bursts allowed by the responder. Applies
+	 * to 2-sided RTT only. */
+	int negotiated_burst_num;
+	/** for 11mc only */
+	wifi_information_element *LCI;
+	/** for 11mc only */
+	wifi_information_element *LCR;
+} wifi_rtt_result;
+
+/** Preamble definition for bit mask used in wifi_rtt_capabilities */
+#define PREAMBLE_LEGACY 0x1
+#define PREAMBLE_HT 0x2
+#define PREAMBLE_VHT 0x4
+
+/** BW definition for bit mask used in wifi_rtt_capabilities */
+#define BW_5_SUPPORT 0x1
+#define BW_10_SUPPORT 0x2
+#define BW_20_SUPPORT 0x4
+#define BW_40_SUPPORT 0x8
+#define BW_80_SUPPORT 0x10
+#define BW_160_SUPPORT 0x20
+
+/** RTT Capabilities */
+typedef struct {
+	/** if 1-sided rtt data collection is supported */
+	t_u8 rtt_one_sided_supported;
+	/** if ftm rtt data collection is supported */
+	t_u8 rtt_ftm_supported;
+	/** if initiator supports LCI request. Applies to 2-sided RTT */
+	t_u8 lci_support;
+	/** if initiator supports LCR request. Applies to 2-sided RTT */
+	t_u8 lcr_support;
+	/** bit mask indicates what preamble is supported by initiator */
+	t_u8 preamble_support;
+	/** bit mask indicates what BW is supported by initiator */
+	t_u8 bw_support;
+	/** if 11mc responder mode is supported */
+	t_u8 responder_supported;
+	/** draft 11mc spec version supported by chip. For instance,
+	 * version 4.0 should be 40 and version 4.3 should be 43 etc. */
+	t_u8 mc_version;
+} wifi_rtt_capabilities;
+
+/** API for setting LCI/LCR information to be provided to a requestor */
+typedef enum {
+	/** Not expected to change location */
+	WIFI_MOTION_NOT_EXPECTED = 0,
+	/** Expected to change location */
+	WIFI_MOTION_EXPECTED = 1,
+	/** Movement pattern unknown */
+	WIFI_MOTION_UNKNOWN = 2,
+} wifi_motion_pattern;
+
+/** LCI information */
+typedef struct {
+	/** latitude in degrees * 2^25 , 2's complement */
+	long latitude;
+	/** latitude in degrees * 2^25 , 2's complement */
+	long longitude;
+	/** Altitude in units of 1/256 m */
+	int altitude;
+	/** As defined in Section 2.3.2 of IETF RFC 6225 */
+	t_u8 latitude_unc;
+	/** As defined in Section 2.3.2 of IETF RFC 6225 */
+	t_u8 longitude_unc;
+	/** As defined in Section 2.4.5 from IETF RFC 6225: */
+	t_u8 altitude_unc;
+	/** Following element for configuring the Z subelement */
+	wifi_motion_pattern motion_pattern;
+	/** floor in units of 1/16th of floor. 0x80000000 if unknown. */
+	int floor;
+	/** in units of 1/64 m */
+	int height_above_floor;
+	/** in units of 1/64 m. 0 if unknown */
+	int height_unc;
+} wifi_lci_information;
+
+/** LCR information */
+typedef struct {
+	/** country code */
+	char country_code[2];
+	/** length of the info field */
+	int length;
+	/** Civic info to be copied in FTM frame */
+	char civic_info[256];
+} wifi_lcr_information;
+
+/**
+ * RTT Responder information
+ */
+typedef struct {
+	wifi_channel_info channel;
+	wifi_preamble preamble;
+} wifi_rtt_responder;
+
+/** =========== Define Copied from HAL END =========== */
+
+#define MAX_RTT_CONFIG_NUM 10
+
+/** RTT config params */
+typedef struct wifi_rtt_config_params {
+	t_u8 rtt_config_num;
+	wifi_rtt_config rtt_config[MAX_RTT_CONFIG_NUM];
+} wifi_rtt_config_params_t;
+
+#define OID_RTT_REQUEST 0
+#define OID_RTT_CANCEL 1
+
+/** Pass RTT result element between mlan and moal */
+typedef struct {
+	/** element identifier  */
+	t_u16 id;
+	/** number of bytes to follow  */
+	t_u16 len;
+	/** data: fill with one wifi_rtt_result  */
+	t_u8 data[];
+} wifi_rtt_result_element;
+
 /** station stats */
 typedef struct _sta_stats {
+	/** last_rx_in_msec */
 	t_u64 last_rx_in_msec;
+	/** rx_packets */
+	t_u32 rx_packets;
+	/** tx packets */
+	t_u32 tx_packets;
+	/** rx bytes */
+	t_u32 rx_bytes;
+	/** tx bytes */
+	t_u32 tx_bytes;
 } sta_stats;
 
 #ifdef PRAGMA_PACK
@@ -1597,156 +2378,156 @@ typedef struct _sta_stats {
 /** mlan_callbacks data structure */
 typedef struct _mlan_callbacks {
 	/** moal_get_fw_data */
-	mlan_status (*moal_get_fw_data)(t_void *pmoal_handle, t_u32 offset,
-					t_u32 len, t_u8 *pbuf);
-	mlan_status (*moal_get_vdll_data)(t_void *pmoal_handle, t_u32 len,
-					  t_u8 *pbuf);
+	mlan_status (*moal_get_fw_data)(t_void *pmoal, t_u32 offset, t_u32 len,
+					t_u8 *pbuf);
+	mlan_status (*moal_get_vdll_data)(t_void *pmoal, t_u32 len, t_u8 *pbuf);
 	/** moal_get_hw_spec_complete */
-	mlan_status (*moal_get_hw_spec_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_get_hw_spec_complete)(t_void *pmoal,
 						 mlan_status status,
 						 pmlan_hw_info phw,
 						 pmlan_bss_tbl ptbl);
 	/** moal_init_fw_complete */
-	mlan_status (*moal_init_fw_complete)(t_void *pmoal_handle,
-					     mlan_status status);
+	mlan_status (*moal_init_fw_complete)(t_void *pmoal, mlan_status status);
 	/** moal_shutdown_fw_complete */
-	mlan_status (*moal_shutdown_fw_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_shutdown_fw_complete)(t_void *pmoal,
 						 mlan_status status);
 	/** moal_send_packet_complete */
-	mlan_status (*moal_send_packet_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_send_packet_complete)(t_void *pmoal,
 						 pmlan_buffer pmbuf,
 						 mlan_status status);
 	/** moal_recv_complete */
-	mlan_status (*moal_recv_complete)(t_void *pmoal_handle,
-					  pmlan_buffer pmbuf, t_u32 port,
-					  mlan_status status);
+	mlan_status (*moal_recv_complete)(t_void *pmoal, pmlan_buffer pmbuf,
+					  t_u32 port, mlan_status status);
 	/** moal_recv_packet */
-	mlan_status (*moal_recv_packet)(t_void *pmoal_handle,
-					pmlan_buffer pmbuf);
+	mlan_status (*moal_recv_packet)(t_void *pmoal, pmlan_buffer pmbuf);
+	/** moal_recv_amsdu_packet */
+	mlan_status (*moal_recv_amsdu_packet)(t_void *pmoal,
+					      pmlan_buffer pmbuf);
 	/** moal_recv_event */
-	mlan_status (*moal_recv_event)(t_void *pmoal_handle,
-				       pmlan_event pmevent);
+	mlan_status (*moal_recv_event)(t_void *pmoal, pmlan_event pmevent);
 	/** moal_ioctl_complete */
-	mlan_status (*moal_ioctl_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_ioctl_complete)(t_void *pmoal,
 					   pmlan_ioctl_req pioctl_req,
 					   mlan_status status);
 
 	/** moal_alloc_mlan_buffer */
-	mlan_status (*moal_alloc_mlan_buffer)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_alloc_mlan_buffer)(t_void *pmoal, t_u32 size,
 					      ppmlan_buffer pmbuf);
 	/** moal_free_mlan_buffer */
-	mlan_status (*moal_free_mlan_buffer)(t_void *pmoal_handle,
-					     pmlan_buffer pmbuf);
+	mlan_status (*moal_free_mlan_buffer)(t_void *pmoal, pmlan_buffer pmbuf);
 
 #ifdef USB
 	/** moal_write_data_async */
-	mlan_status (*moal_write_data_async)(t_void *pmoal_handle,
-					     pmlan_buffer pmbuf, t_u32 port);
+	mlan_status (*moal_write_data_async)(t_void *pmoal, pmlan_buffer pmbuf,
+					     t_u32 port);
 #endif /* USB */
 #if defined(SDIO) || defined(PCIE)
 	/** moal_write_reg */
-	mlan_status (*moal_write_reg)(t_void *pmoal_handle, t_u32 reg,
-				      t_u32 data);
+	mlan_status (*moal_write_reg)(t_void *pmoal, t_u32 reg, t_u32 data);
 	/** moal_read_reg */
-	mlan_status (*moal_read_reg)(t_void *pmoal_handle, t_u32 reg,
-				     t_u32 *data);
+	mlan_status (*moal_read_reg)(t_void *pmoal, t_u32 reg, t_u32 *data);
 #endif /* SDIO || PCIE */
 	/** moal_write_data_sync */
-	mlan_status (*moal_write_data_sync)(t_void *pmoal_handle,
-					    pmlan_buffer pmbuf, t_u32 port,
-					    t_u32 timeout);
+	mlan_status (*moal_write_data_sync)(t_void *pmoal, pmlan_buffer pmbuf,
+					    t_u32 port, t_u32 timeout);
 	/** moal_read_data_sync */
-	mlan_status (*moal_read_data_sync)(t_void *pmoal_handle,
-					   pmlan_buffer pmbuf, t_u32 port,
-					   t_u32 timeout);
+	mlan_status (*moal_read_data_sync)(t_void *pmoal, pmlan_buffer pmbuf,
+					   t_u32 port, t_u32 timeout);
 	/** moal_malloc */
-	mlan_status (*moal_malloc)(t_void *pmoal_handle, t_u32 size, t_u32 flag,
+	mlan_status (*moal_malloc)(t_void *pmoal, t_u32 size, t_u32 flag,
 				   t_u8 **ppbuf);
 	/** moal_mfree */
-	mlan_status (*moal_mfree)(t_void *pmoal_handle, t_u8 *pbuf);
+	mlan_status (*moal_mfree)(t_void *pmoal, t_u8 *pbuf);
 	/** moal_vmalloc */
-	mlan_status (*moal_vmalloc)(t_void *pmoal_handle, t_u32 size,
-				    t_u8 **ppbuf);
+	mlan_status (*moal_vmalloc)(t_void *pmoal, t_u32 size, t_u8 **ppbuf);
 	/** moal_vfree */
-	mlan_status (*moal_vfree)(t_void *pmoal_handle, t_u8 *pbuf);
+	mlan_status (*moal_vfree)(t_void *pmoal, t_u8 *pbuf);
 #ifdef PCIE
 	/** moal_malloc_consistent */
-	mlan_status (*moal_malloc_consistent)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_malloc_consistent)(t_void *pmoal, t_u32 size,
 					      t_u8 **ppbuf, t_u64 *pbuf_pa);
 	/** moal_mfree_consistent */
-	mlan_status (*moal_mfree_consistent)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_mfree_consistent)(t_void *pmoal, t_u32 size,
 					     t_u8 *pbuf, t_u64 buf_pa);
 	/** moal_map_memory */
-	mlan_status (*moal_map_memory)(t_void *pmoal_handle, t_u8 *pbuf,
+	mlan_status (*moal_map_memory)(t_void *pmoal, t_u8 *pbuf,
 				       t_u64 *pbuf_pa, t_u32 size, t_u32 flag);
 	/** moal_unmap_memory */
-	mlan_status (*moal_unmap_memory)(t_void *pmoal_handle, t_u8 *pbuf,
+	mlan_status (*moal_unmap_memory)(t_void *pmoal, t_u8 *pbuf,
 					 t_u64 buf_pa, t_u32 size, t_u32 flag);
 #endif /* PCIE */
 	/** moal_memset */
-	t_void *(*moal_memset)(t_void *pmoal_handle, t_void *pmem, t_u8 byte,
+	t_void *(*moal_memset)(t_void *pmoal, t_void *pmem, t_u8 byte,
 			       t_u32 num);
 	/** moal_memcpy */
-	t_void *(*moal_memcpy)(t_void *pmoal_handle, t_void *pdest,
-			       const t_void *psrc, t_u32 num);
+	t_void *(*moal_memcpy)(t_void *pmoal, t_void *pdest, const t_void *psrc,
+			       t_u32 num);
 	/** moal_memcpy_ext */
-	t_void *(*moal_memcpy_ext)(t_void *pmoal_handle, t_void *pdest,
+	t_void *(*moal_memcpy_ext)(t_void *pmoal, t_void *pdest,
 				   const t_void *psrc, t_u32 num,
 				   t_u32 dest_size);
 	/** moal_memmove */
-	t_void *(*moal_memmove)(t_void *pmoal_handle, t_void *pdest,
+	t_void *(*moal_memmove)(t_void *pmoal, t_void *pdest,
 				const t_void *psrc, t_u32 num);
 	/** moal_memcmp */
-	t_s32 (*moal_memcmp)(t_void *pmoal_handle, const t_void *pmem1,
+	t_s32 (*moal_memcmp)(t_void *pmoal, const t_void *pmem1,
 			     const t_void *pmem2, t_u32 num);
 	/** moal_udelay */
-	t_void (*moal_udelay)(t_void *pmoal_handle, t_u32 udelay);
+	t_void (*moal_udelay)(t_void *pmoal, t_u32 udelay);
 	/** moal_usleep_range */
-	t_void (*moal_usleep_range)(t_void *pmoal_handle, t_u32 min_delay,
+	t_void (*moal_usleep_range)(t_void *pmoal, t_u32 min_delay,
 				    t_u32 max_delay);
 	/** moal_get_boot_ktime */
-	mlan_status (*moal_get_boot_ktime)(t_void *pmoal_handle, t_u64 *pnsec);
+	mlan_status (*moal_get_boot_ktime)(t_void *pmoal, t_u64 *pnsec);
 	/** moal_get_system_time */
-	mlan_status (*moal_get_system_time)(t_void *pmoal_handle, t_u32 *psec,
+	mlan_status (*moal_get_system_time)(t_void *pmoal, t_u32 *psec,
 					    t_u32 *pusec);
 	/** moal_init_timer*/
-	mlan_status (*moal_init_timer)(t_void *pmoal_handle, t_void **pptimer,
+	mlan_status (*moal_init_timer)(t_void *pmoal, t_void **pptimer,
 				       IN t_void (*callback)(t_void *pcontext),
 				       t_void *pcontext);
 	/** moal_free_timer */
-	mlan_status (*moal_free_timer)(t_void *pmoal_handle, t_void *ptimer);
+	mlan_status (*moal_free_timer)(t_void *pmoal, t_void *ptimer);
 	/** moal_start_timer*/
-	mlan_status (*moal_start_timer)(t_void *pmoal_handle, t_void *ptimer,
+	mlan_status (*moal_start_timer)(t_void *pmoal, t_void *ptimer,
 					t_u8 periodic, t_u32 msec);
 	/** moal_stop_timer*/
-	mlan_status (*moal_stop_timer)(t_void *pmoal_handle, t_void *ptimer);
+	mlan_status (*moal_stop_timer)(t_void *pmoal, t_void *ptimer);
 	/** moal_init_lock */
-	mlan_status (*moal_init_lock)(t_void *pmoal_handle, t_void **pplock);
+	mlan_status (*moal_init_lock)(t_void *pmoal, t_void **pplock);
 	/** moal_free_lock */
-	mlan_status (*moal_free_lock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_free_lock)(t_void *pmoal, t_void *plock);
 	/** moal_spin_lock */
-	mlan_status (*moal_spin_lock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_spin_lock)(t_void *pmoal, t_void *plock);
 	/** moal_spin_unlock */
-	mlan_status (*moal_spin_unlock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_spin_unlock)(t_void *pmoal, t_void *plock);
 	/** moal_print */
-	t_void (*moal_print)(t_void *pmoal_handle, t_u32 level, char *pformat,
-			     IN...);
+	t_void (*moal_print)(t_void *pmoal, t_u32 level, char *pformat, IN...);
 	/** moal_print_netintf */
-	t_void (*moal_print_netintf)(t_void *pmoal_handle, t_u32 bss_index,
+	t_void (*moal_print_netintf)(t_void *pmoal, t_u32 bss_index,
 				     t_u32 level);
 	/** moal_assert */
-	t_void (*moal_assert)(t_void *pmoal_handle, t_u32 cond);
+	t_void (*moal_assert)(t_void *pmoal, t_u32 cond);
 
 	/** moal_hist_data_add */
-	t_void (*moal_hist_data_add)(t_void *pmoal_handle, t_u32 bss_index,
+	t_void (*moal_hist_data_add)(t_void *pmoal, t_u32 bss_index,
 				     t_u16 rx_rate, t_s8 snr, t_s8 nflr,
 				     t_u8 antenna);
+	t_void (*moal_updata_peer_signal)(t_void *pmoal, t_u32 bss_index,
+					  t_u8 *peer_addr, t_s8 snr, t_s8 nflr);
+	t_u64 (*moal_do_div)(t_u64 num, t_u32 base);
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
-	mlan_status (*moal_wait_hostcmd_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_wait_hostcmd_complete)(t_void *pmoal,
 						  t_u32 bss_index);
-	mlan_status (*moal_notify_hostcmd_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_notify_hostcmd_complete)(t_void *pmoal,
 						    t_u32 bss_index);
 #endif
+	void (*moal_tp_accounting)(t_void *pmoal, t_void *buf,
+				   t_u32 drop_point);
+	void (*moal_tp_accounting_rx_param)(t_void *pmoal, unsigned int type,
+					    unsigned int rsvd1);
+	void (*moal_amsdu_tp_accounting)(t_void *pmoal, t_s32 delay,
+					 t_s32 copy_delay);
 } mlan_callbacks, *pmlan_callbacks;
 
 /** Parameter unchanged, use MLAN default setting */
@@ -1809,6 +2590,9 @@ typedef struct _mlan_device {
 	/** MFG mode */
 	t_u32 mfg_mode;
 #endif
+#ifdef PCIE
+	t_u16 ring_size;
+#endif
 #if defined(SDIO)
 	/** SDIO interrupt mode (0: INT_MODE_SDIO, 1: INT_MODE_GPIO) */
 	t_u32 int_mode;
@@ -1865,6 +2649,8 @@ typedef struct _mlan_device {
 	t_u8 indication_gpio;
 	/** Dynamic MIMO-SISO switch for hscfg*/
 	t_u8 hs_mimo_switch;
+	/** channel time and mode for DRCS*/
+	t_u32 drcs_chantime_mode;
 #ifdef USB
 	/** Tx CMD endpoint address */
 	t_u8 tx_cmd_ep;
@@ -1875,9 +2661,9 @@ typedef struct _mlan_device {
 	t_u8 rx_data_ep;
 	/** Tx data endpoint address */
 	t_u8 tx_data_ep;
+	/** Tx data second endpoint address */
+	t_u8 tx_data2_ep;
 #endif
-	/** fw region */
-	t_bool fw_region;
 	/** passive to active scan */
 	t_u8 passive_to_active_scan;
 	/** uap max supported station per chip */
@@ -1886,6 +2672,14 @@ typedef struct _mlan_device {
 	t_u32 drv_mode;
 	/** dfs w53 cfg */
 	t_u8 dfs53cfg;
+	/** dfs_offload */
+	t_u8 dfs_offload;
+	/** extend enhance scan */
+	t_u8 ext_scan;
+	/* mcs32 setting */
+	t_u8 mcs32;
+	/** second mac flag */
+	t_u8 second_mac;
 } mlan_device, *pmlan_device;
 
 /** MLAN API function prototype */
@@ -1896,51 +2690,53 @@ MLAN_API mlan_status mlan_register(pmlan_device pmdevice,
 				   t_void **ppmlan_adapter);
 
 /** Un-registration */
-MLAN_API mlan_status mlan_unregister(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_unregister(t_void *padapter);
 
 /** Firmware Downloading */
-MLAN_API mlan_status mlan_dnld_fw(t_void *pmlan_adapter, pmlan_fw_image pmfw);
+MLAN_API mlan_status mlan_dnld_fw(t_void *padapter, pmlan_fw_image pmfw);
 
 /** Custom data pass API */
-MLAN_API mlan_status mlan_set_init_param(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_set_init_param(t_void *padapter,
 					 pmlan_init_param pparam);
 
 /** Firmware Initialization */
-MLAN_API mlan_status mlan_init_fw(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_init_fw(t_void *padapter);
 
 /** Firmware Shutdown */
-MLAN_API mlan_status mlan_shutdown_fw(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_shutdown_fw(t_void *padapter);
 
 /** Main Process */
-MLAN_API mlan_status mlan_main_process(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_main_process(t_void *padapter);
 
 /** Rx process */
-mlan_status mlan_rx_process(t_void *pmlan_adapter, t_u8 *rx_pkts);
+mlan_status mlan_rx_process(t_void *padapter, t_u8 *rx_pkts);
 
 /** Packet Transmission */
-MLAN_API mlan_status mlan_send_packet(t_void *pmlan_adapter,
-				      pmlan_buffer pmbuf);
+MLAN_API mlan_status mlan_send_packet(t_void *padapter, pmlan_buffer pmbuf);
 
 #ifdef USB
 /** mlan_write_data_async_complete */
-MLAN_API mlan_status mlan_write_data_async_complete(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_write_data_async_complete(t_void *padapter,
 						    pmlan_buffer pmbuf,
 						    t_u32 port,
 						    mlan_status status);
 
 /** Packet Reception */
-MLAN_API mlan_status mlan_recv(t_void *pmlan_adapter, pmlan_buffer pmbuf,
+MLAN_API mlan_status mlan_recv(t_void *padapter, pmlan_buffer pmbuf,
 			       t_u32 port);
 #endif /* USB */
 
 /** Packet Reception complete callback */
-MLAN_API mlan_status mlan_recv_packet_complete(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_recv_packet_complete(t_void *padapter,
 					       pmlan_buffer pmbuf,
 					       mlan_status status);
 
+/** handle amsdu deaggregated packet */
+void mlan_process_deaggr_pkt(t_void *padapter, pmlan_buffer pmbuf, t_u8 *drop);
+
 #if defined(SDIO) || defined(PCIE)
 /** interrupt handler */
-MLAN_API mlan_status mlan_interrupt(t_u16 msg_id, t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_interrupt(t_u16 msg_id, t_void *padapter);
 
 #if defined(SYSKT)
 /** GPIO IRQ callback function */
@@ -1948,7 +2744,7 @@ MLAN_API t_void mlan_hs_callback(t_void *pctx);
 #endif /* SYSKT_MULTI || SYSKT */
 #endif /* SDIO || PCIE */
 
-MLAN_API t_void mlan_pm_wakeup_card(t_void *pmlan_adapter, t_u8 keep_wakeup);
+MLAN_API t_void mlan_pm_wakeup_card(t_void *padapter, t_u8 keep_wakeup);
 
 MLAN_API t_u8 mlan_is_main_process_running(t_void *adapter);
 #ifdef PCIE
@@ -1956,10 +2752,15 @@ MLAN_API t_void mlan_set_int_mode(t_void *adapter, t_u32 int_mode,
 				  t_u8 func_num);
 #endif
 /** mlan ioctl */
-MLAN_API mlan_status mlan_ioctl(t_void *pmlan_adapter,
-				pmlan_ioctl_req pioctl_req);
+MLAN_API mlan_status mlan_ioctl(t_void *padapter, pmlan_ioctl_req pioctl_req);
 /** mlan select wmm queue */
-MLAN_API t_u8 mlan_select_wmm_queue(t_void *pmlan_adapter, t_u8 bss_num,
-				    t_u8 tid);
+MLAN_API t_u8 mlan_select_wmm_queue(t_void *padapter, t_u8 bss_num, t_u8 tid);
+
+/** mlan mask host interrupt */
+MLAN_API mlan_status mlan_disable_host_int(t_void *padapter);
+/** mlan unmask host interrupt */
+MLAN_API mlan_status mlan_enable_host_int(t_void *padapter);
+
+#define CSI_SIGNATURE 0xABCD
 
 #endif /* !_MLAN_DECL_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h
old mode 100644
new mode 100755
index cddbce415..1d8dd99d5
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_fw.h
@@ -5,7 +5,7 @@
  *  in MLAN module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -94,6 +94,9 @@ typedef MLAN_PACK_START struct {
 /** Setup the number of rates passed in the driver/firmware API */
 #define A_SUPPORTED_RATES 9
 
+/** IEEEtypes Data Frame Subtype of QoS pkt */
+#define QOS_DATA 8
+
 /** CapInfo Short Slot Time Disabled */
 /* #define SHORT_SLOT_TIME_DISABLED(CapInfo)
  * ((IEEEtypes_CapInfo_t)(CapInfo).short_slot_time = 0) */
@@ -185,6 +188,10 @@ typedef enum _KEY_TYPE_ID {
 	KEY_TYPE_ID_GCMP_256 = 6,
 	/** Key type : CCMP_256 */
 	KEY_TYPE_ID_CCMP_256 = 7,
+	/** Key type : GMAC_128 */
+	KEY_TYPE_ID_BIP_GMAC_128 = 8,
+	/** Key type : GMAC_256 */
+	KEY_TYPE_ID_BIP_GMAC_256 = 9,
 } KEY_TYPE_ID;
 
 /** Key Info flag for multicast key */
@@ -222,6 +229,7 @@ typedef enum _KEY_INFO_AES {
 #define CMAC_AES_KEY_LEN 16
 /** IGTK key length */
 #define WPA_IGTK_KEY_LEN 16
+#define WPA_IGTK_256_KEY_LEN 32
 
 /** WAPI key length */
 #define WAPI_KEY_LEN 50
@@ -247,7 +255,7 @@ typedef enum _KEY_INFO_WAPI {
 #define MAX_MULTI_INTERFACE_POLL_TRIES 150
 /** The number of times to try when waiting for downloaded firmware to
      become active. (polling the scratch register). */
-#define MAX_FIRMWARE_POLL_TRIES 100
+#define MAX_FIRMWARE_POLL_TRIES 300
 
 /** FW fill in rx_len with extra 204 bytes */
 #define EXTRA_LEN 256
@@ -326,6 +334,12 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /**TLV type : Host MLME Flag*/
 #define TLV_TYPE_HOST_MLME (PROPRIETARY_TLV_BASE_ID + 307)
 
+/** TLV type: MULTI AP Flag */
+#define TLV_TYPE_MULTI_AP (PROPRIETARY_TLV_BASE_ID + 326)
+
+/** TLV type : AP wacp mode */
+#define TLV_TYPE_UAP_WACP_MODE (PROPRIETARY_TLV_BASE_ID + 0x147) /* 0x0247 */
+
 /** TLV type : Vendor Specific IE */
 #define TLV_TYPE_VENDOR_SPECIFIC_IE 0x00dd
 
@@ -359,6 +373,8 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define TLV_TYPE_WILDCARDSSID (PROPRIETARY_TLV_BASE_ID + 0x12) /* 0x0112 */
 /** TLV type : TSF timestamp */
 #define TLV_TYPE_TSFTIMESTAMP (PROPRIETARY_TLV_BASE_ID + 0x13) /* 0x0113 */
+/** TLV type : ARP filter */
+#define TLV_TYPE_ARP_FILTER (PROPRIETARY_TLV_BASE_ID + 0x15) /* 0x0115 */
 /** TLV type : Beacon RSSI high */
 #define TLV_TYPE_RSSI_HIGH (PROPRIETARY_TLV_BASE_ID + 0x16) /* 0x0116 */
 /** TLV type : Beacon SNR high */
@@ -396,6 +412,9 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define TLV_TYPE_PASSPHRASE (PROPRIETARY_TLV_BASE_ID + 0x3c) /* 0x013c */
 /** TLV type : SAE Password */
 #define TLV_TYPE_SAE_PASSWORD (PROPRIETARY_TLV_BASE_ID + 0x141) /* 0x0241 */
+/** TLV type : SAE PWE Derivation Mode */
+#define TLV_TYPE_WPA3_SAE_PWE_DERIVATION_MODE                                  \
+	(PROPRIETARY_TLV_BASE_ID + 339) /* 0x0100 + 0x153 */
 /** TLV type : Encryption Protocol TLV */
 #define TLV_TYPE_ENCRYPTION_PROTO                                              \
 	(PROPRIETARY_TLV_BASE_ID + 0x40) /* 0x0140                             \
@@ -408,6 +427,31 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** TLV type : BCN miss */
 #define TLV_TYPE_PRE_BCNMISS (PROPRIETARY_TLV_BASE_ID + 0x49) /* 0x0149 */
 
+/** TLV type : ENABLE ROAM IE */
+#define TLV_TYPE_ROAM (PROPRIETARY_TLV_BASE_ID + 245)
+/** TLV type : AP LIST IE */
+#define TLV_TYPE_APLIST (PROPRIETARY_TLV_BASE_ID + 246)
+/** TLV type : PMK */
+#define TLV_TYPE_PMK_R0 (PROPRIETARY_TLV_BASE_ID + 247)
+/** TLV type : PMK */
+#define TLV_TYPE_PMK_R0_NAME (PROPRIETARY_TLV_BASE_ID + 248)
+/** TLV type : TRIGGER CONDITION*/
+#define TLV_TYPE_ROM_TRIGGER (PROPRIETARY_TLV_BASE_ID + 264)
+/** TLV type : RETRY_COUNT*/
+#define TLV_TYPE_ROM_RETRY_COUNT (PROPRIETARY_TLV_BASE_ID + 265)
+/** TLV type : BGSCAN SETTING*/
+#define TLV_TYPE_ROM_BGSCAN (PROPRIETARY_TLV_BASE_ID + 266)
+/** TLV type : PARA RSSI*/
+#define TLV_TYPE_ROM_PARA_RSSI (PROPRIETARY_TLV_BASE_ID + 267)
+/** TLV type : BSSID blacklist*/
+#define TLV_TYPE_BLACKLIST_BSSID (PROPRIETARY_TLV_BASE_ID + 0x11d)
+/** TLV type : BAND & RSSI*/
+#define TLV_TYPE_BAND_RSSI (PROPRIETARY_TLV_BASE_ID + 0x11e)
+/** TLV type : ESS scan*/
+#define TLV_TYPE_ENERGYEFFICIENTSCAN (PROPRIETARY_TLV_BASE_ID + 0xda)
+/** TLV type : KEY params*/
+#define TLV_TYPE_ROAM_OFFLOAD_USER_SET_PMK (PROPRIETARY_TLV_BASE_ID + 291)
+
 /** TLV type: WAPI IE */
 #define TLV_TYPE_WAPI_IE (PROPRIETARY_TLV_BASE_ID + 0x5e) /* 0x015e */
 
@@ -416,6 +460,10 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** TLV type: MAX_MGMT_IE */
 #define TLV_TYPE_MAX_MGMT_IE (PROPRIETARY_TLV_BASE_ID + 0xaa) /* 0x01aa */
 
+/** TLV : Region Domain Code */
+#define TLV_TYPE_REGION_DOMAIN_CODE                                            \
+	(PROPRIETARY_TLV_BASE_ID + 0xab) /* 0x01ab */
+
 /** TLV type: key param v2 */
 #define TLV_TYPE_KEY_PARAM_V2 (PROPRIETARY_TLV_BASE_ID + 0x9C) /* 0x019C */
 
@@ -439,6 +487,11 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 
 #define TLV_TYPE_DMCS_STATUS (PROPRIETARY_TLV_BASE_ID + 0x13A) /* 0x023A */
 
+/** TLV type : TDLS IDLE TIMEOUT */
+#define TLV_TYPE_TDLS_IDLE_TIMEOUT                                             \
+	(PROPRIETARY_TLV_BASE_ID + 0xC2) /* 0x01C2                             \
+					  */
+
 /** TLV type : HT Capabilities */
 #define TLV_TYPE_HT_CAP (PROPRIETARY_TLV_BASE_ID + 0x4a) /* 0x014a */
 /** TLV type : HT Information */
@@ -470,6 +523,10 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** TLV type : p2p opp ps */
 #define TLV_TYPE_WIFI_DIRECT_OPP_PS (PROPRIETARY_TLV_BASE_ID + 0x84)
 #endif /* WIFI_DIRECT_SUPPORT */
+/** TLV type : GPIO TSF LATCH CONFIG */
+#define TLV_TYPE_GPIO_TSF_LATCH_CONFIG (PROPRIETARY_TLV_BASE_ID + 0x154)
+/** TLV type : GPIO TSF LATCH REPORT*/
+#define TLV_TYPE_GPIO_TSF_LATCH_REPORT (PROPRIETARY_TLV_BASE_ID + 0x155)
 
 /** TLV : 20/40 coex config */
 #define TLV_TYPE_2040_BSS_COEX_CONTROL                                         \
@@ -495,6 +552,9 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** TLV type: fw cap info */
 #define TLV_TYPE_FW_CAP_INFO (PROPRIETARY_TLV_BASE_ID + 318)
 
+/** TLV type: secure boot uuid */
+#define TLV_TYPE_SECURE_BOOT_UUID (PROPRIETARY_TLV_BASE_ID + 348)
+
 /** ADDBA TID mask */
 #define ADDBA_TID_MASK (MBIT(2) | MBIT(3) | MBIT(4) | MBIT(5))
 /** DELBA TID mask */
@@ -543,8 +603,12 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** Non green field station */
 #define NON_GREENFIELD_STAS 0x04
 
+/** Max AMSDU size support */
+#define HWSPEC_MAX_AMSDU_SUPP MBIT(31)
 /** Greenfield support */
 #define HWSPEC_GREENFIELD_SUPP MBIT(29)
+/** SM Power Save enable */
+#define CAPINFO_SMPS_ENABLE MBIT(27)
 /** RX STBC support */
 #define HWSPEC_RXSTBC_SUPP MBIT(26)
 /** ShortGI @ 40Mhz support */
@@ -555,6 +619,8 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define HWSPEC_LDPC_SUPP MBIT(22)
 /** Channel width 40Mhz support */
 #define HWSPEC_CHANBW40_SUPP MBIT(17)
+/** SM Power Save mode */
+#define CAPINFO_SMPS_MODE MBIT(9)
 /** 40Mhz intolarent enable */
 #define CAPINFO_40MHZ_INTOLARENT MBIT(8)
 
@@ -564,7 +630,8 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** Default 11n capability mask for 5GHz */
 #define DEFAULT_11N_CAP_MASK_A                                                 \
 	(HWSPEC_CHANBW40_SUPP | HWSPEC_SHORTGI20_SUPP |                        \
-	 HWSPEC_SHORTGI40_SUPP | HWSPEC_RXSTBC_SUPP | HWSPEC_LDPC_SUPP)
+	 HWSPEC_MAX_AMSDU_SUPP | HWSPEC_SHORTGI40_SUPP | HWSPEC_RXSTBC_SUPP |  \
+	 HWSPEC_LDPC_SUPP)
 
 /** Default 11n TX BF capability 2X2 chip **/
 #define DEFAULT_11N_TX_BF_CAP_2X2 0x19E74618
@@ -572,7 +639,11 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define DEFAULT_11N_TX_BF_CAP_1X1 0x19E74608
 
 /** Bits to ignore in hw_dev_cap as these bits are set in get_hw_spec */
-#define IGN_HW_DEV_CAP (CAPINFO_40MHZ_INTOLARENT)
+#define IGN_HW_DEV_CAP                                                         \
+	(CAPINFO_40MHZ_INTOLARENT | (CAPINFO_SMPS_ENABLE | CAPINFO_SMPS_MODE))
+
+/** HW_SPEC FwCapInfo : If FW support RSN Replay Detection */
+#define ISSUPP_RSN_REPLAY_DETECTION(FwCapInfo) (FwCapInfo & MBIT(28))
 
 /** HW_SPEC FwCapInfo */
 #define ISSUPP_11NENABLED(FwCapInfo) (FwCapInfo & MBIT(11))
@@ -607,6 +678,8 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define ISSUPP_CHANWIDTH20(Dot11nDevCap) (Dot11nDevCap & MBIT(16))
 /** HW_SPEC Dot11nDevCap : Channel BW support @ 10Mhz  support */
 #define ISSUPP_CHANWIDTH10(Dot11nDevCap) (Dot11nDevCap & MBIT(15))
+/** Dot11nUsrCap : SMPS static/dynamic mode if BIT27 MIMO PS support eanbled */
+#define ISSUPP_SMPS_DYNAMIC_MODE(Dot11nDevCap) (Dot11nDevCap & MBIT(9))
 /** Dot11nUsrCap : 40Mhz intolarance enabled */
 #define ISENABLED_40MHZ_INTOLARENT(Dot11nDevCap) (Dot11nDevCap & MBIT(8))
 /** Dot11nUsrCap : Reset 40Mhz intolarance enabled */
@@ -638,6 +711,9 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** DevMCSSupported : Rx MCS supported */
 #define GET_RXMCSSUPP(DevMCSSupported) (DevMCSSupported & 0x0f)
 
+/** hw_dev_cap : MPDU DENSITY */
+#define GET_MPDU_DENSITY(hw_dev_cap) (hw_dev_cap & 0x7)
+
 /** GET HTCapInfo : Supported Channel BW */
 #define GETHT_SUPPCHANWIDTH(HTCapInfo) (HTCapInfo & MBIT(1))
 /** GET HTCapInfo : Support for Greenfield */
@@ -681,8 +757,11 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define SETHT_DSSSCCK40(HTCapInfo) (HTCapInfo |= MBIT(12))
 /** SET HTCapInfo : Enable 40Mhz Intolarence */
 #define SETHT_40MHZ_INTOLARANT(HTCapInfo) (HTCapInfo |= MBIT(14))
-/** SET HTCapInfo : Disable Static SM power save */
-#define SETHT_STATIC_SMPS(HTCapInfo) ((HTCapInfo) |= (MBIT(2) | MBIT(3)))
+
+/** SET HTCapInfo : Set SM power save disabled */
+#define SETHT_SMPS_DISABLE(HTCapInfo) ((HTCapInfo) |= (MBIT(2) | MBIT(3)))
+/** SET HTCapInfo : Set Dynamic SM power save */
+#define SETHT_SMPS_DYNAMIC(HTCapInfo) ((HTCapInfo) |= MBIT(2))
 
 /** RESET HTCapInfo : Set support for LDPC coding capability */
 #define RESETHT_LDPCCODINGCAP(HTCapInfo) (HTCapInfo &= ~MBIT(0))
@@ -816,7 +895,14 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define SET_EXTCAP_TWT_REQ(ext_cap) (ext_cap.TWTReq = 1)
 /** ExtCap : ReSet support Ext TWT REQ */
 #define RESET_EXTCAP_TWT_REQ(ext_cap) (ext_cap.TWTReq = 0)
-
+/** ExtCap : Support for Beacon Protection */
+#define ISSUPP_EXTCAP_EXT_BEACON_PROT(ext_cap) (ext_cap.beacon_prot)
+/** ExtCap : Set support Beacon Protection */
+#define SET_EXTCAP_BEACON_PROT(ext_cap) (ext_cap.beacon_prot = 1)
+
+/** ExtCap : Set FTMI bit(bit 71) */
+#define SET_EXTCAP_FTMI(ext_cap) (ext_cap.FTMI = 1)
+#define SET_EXTCAP_INTERNETWORKING(ext_cap) (ext_cap.Interworking = 1)
 /** LLC/SNAP header len   */
 #define LLC_SNAP_LEN 8
 
@@ -863,6 +949,9 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 
 /** Set VHT Cap Info: Max MPDU length */
 #define SET_VHTCAP_MAXMPDULEN(VHTCapInfo, value) (VHTCapInfo |= (value & 0x03))
+/** Reset VHT Cap Info: Max MPDU length */
+#define RESET_VHTCAP_MAXMPDULEN(VHTCapInfo) (VHTCapInfo &= ~(MBIT(0) | MBIT(1)))
+
 /** SET VHT CapInfo:  Supported Channel Width SET (2 bits)*/
 #define SET_VHTCAP_CHWDSET(VHTCapInfo, value)                                  \
 	(VHTCapInfo |= ((value & 0x3) << 2))
@@ -957,6 +1046,7 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define SET_OPER_MODE_1NSS(oper_mode)                                          \
 	(oper_mode &= ~(MBIT(4) | MBIT(5) | MBIT(6)))
 
+#define NO_NSS_SUPPORT 0x3
 #define GET_VHTMCS(MCSMapSet) (MCSMapSet & 0xFFFF)
 #define GET_VHTNSSMCS(MCSMapSet, nss) ((MCSMapSet >> (2 * (nss - 1))) & 0x3)
 #define RET_VHTNSSMCS(MCSMapSet, nss) ((MCSMapSet >> (2 * (nss - 1))) & 0x3)
@@ -1020,6 +1110,8 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 	(PROPRIETARY_TLV_BASE_ID + 0x5b) /* 0x015b                             \
 					  */
 
+/** TLV type : ZERO DFS Operation */
+#define TLV_TYPE_ZERO_DFS_OPERATION (PROPRIETARY_TLV_BASE_ID + 0x13b) // + 315
 /** TLV type : DFS W53 Configuration */
 #define TLV_TYPE_DFS_W53_CFG (PROPRIETARY_TLV_BASE_ID + 0x145) // + 325
 #ifdef OPCHAN
@@ -1219,11 +1311,23 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 
 /** Host Command ID : 802.11 RSSI INFO EXT*/
 #define HostCmd_CMD_RSSI_INFO_EXT 0x0237
-
-#ifdef RX_PACKET_COALESCE
-/** TLV ID for RX pkt coalesce config */
-#define TLV_TYPE_RX_PKT_COAL_CONFIG (PROPRIETARY_TLV_BASE_ID + 0xC9)
-#endif
+/** Host Command ID : ROAMING OFFLOAD TO FW*/
+#define HostCmd_CMD_ROAM_OFFLOAD 0x0245
+
+/** Host Command ID: Multi chan config */
+#define HostCmd_CMD_MULTI_CHAN_CONFIG 0x011e
+/** Host Command ID: Multi chan policy */
+#define HostCmd_CMD_MULTI_CHAN_POLICY 0x0121
+/** TLV ID for multi chan info */
+#define TLV_TYPE_MULTI_CHAN_INFO (PROPRIETARY_TLV_BASE_ID + 0xb7)
+/** TLV ID for multi chan group info */
+#define TLV_TYPE_MULTI_CHAN_GROUP_INFO_TLV_ID (PROPRIETARY_TLV_BASE_ID + 0xb8)
+/** TLV ID for DRCS TimeSlice */
+#define MRVL_DRCS_TIME_SLICE_TLV_ID (PROPRIETARY_TLV_BASE_ID + 263)
+/** Host Command ID: DRCS config */
+#define HostCmd_CMD_DRCS_CONFIG 0x024a
+
+#define TLV_TYPE_PREV_BSSID (PROPRIETARY_TLV_BASE_ID + 330)
 
 /** Host Command ID : Channel report request */
 #define HostCmd_CMD_CHAN_REPORT_REQUEST 0x00dd
@@ -1272,6 +1376,18 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define HostCmd_CMD_MGMT_IE_LIST 0x00f2
 
 #define HostCmd_CMD_802_11_BAND_STEERING 0x026f
+/*** Host Command ID " MC_AGGR_CFG */
+#define HostCmd_CMD_MC_AGGR_CFG 0x027a
+#define HostCmd_CMD_802_11_STATS 0x0014
+#define HostCmd_CMD_GET_CH_LOAD 0x027b
+
+/** Host Command ID: CROSS CHIP SYNCH */
+#define HostCmd_CMD_CROSS_CHIP_SYNCH 0x027d
+
+/** Host Command ID : TDLS configuration */
+#define HostCmd_CMD_TDLS_CONFIG 0x0100
+/** Host Command ID : TDLS operation */
+#define HostCmd_CMD_TDLS_OPERATION 0x0122
 
 #ifdef SDIO
 /** Host Command ID : SDIO single port RX aggr */
@@ -1294,6 +1410,9 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** fw_cap_info bit23 for embedded authenticator support*/
 #define FW_CAPINFO_AUTH_SUPPORT MBIT(22)
 
+/** fw_cap_info bit23 for firmware roaming*/
+#define FW_ROAMING_SUPPORT MBIT(23)
+
 /** fw_cap_info bit25 for adhoc support*/
 #define FW_CAPINFO_ADHOC_SUPPORT MBIT(25)
 /** Check if adhoc is supported by firmware */
@@ -1326,6 +1445,18 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 #define FW_CAPINFO_EXT_802_11AX MBIT(7)
 /** FW cap info bit 8: 80MHZ disabled */
 #define FW_CAPINFO_EXT_NO_80MHZ MBIT(8)
+/** FW cap info bit 9: Multi BSSID Support */
+#define FW_CAPINFO_EXT_MULTI_BSSID MBIT(9)
+/** FW cap info bit 10: Beacon Protection Support */
+#define FW_CAPINFO_EXT_BEACON_PROT MBIT(10)
+/** FW cap info bit 11: OTP cal data */
+#define FW_CAPINFO_EXT_OTP_CALDATA MBIT(11)
+/** FW cap info bit 12: RTT Support */
+#define FW_CAPINFO_EXT_RTT MBIT(12)
+/** FW cap info bit 13: Channel Tracking Support */
+#define FW_CAPINFO_EXT_CHAN_TRACK MBIT(13)
+/** FW cap info bit 14: 6G Support */
+#define FW_CAPINFO_EXT_6G MBIT(14)
 
 /** Check if 5G 1x1 only is supported by firmware */
 #define IS_FW_SUPPORT_5G_1X1_ONLY(_adapter)                                    \
@@ -1351,6 +1482,27 @@ typedef enum _WLAN_802_11_WEP_STATUS {
 /** Check if 80MHZ disabled in firmware */
 #define IS_FW_SUPPORT_NO_80MHZ(_adapter)                                       \
 	(_adapter->fw_cap_ext & FW_CAPINFO_EXT_NO_80MHZ)
+/** Check if Multi BSSID supported by firmware */
+#define IS_FW_SUPPORT_MULTIBSSID(_adapter)                                     \
+	(_adapter->fw_cap_ext & FW_CAPINFO_EXT_MULTI_BSSID)
+/** Check if Beacon Protection supported by firmware */
+#define IS_FW_SUPPORT_BEACON_PROT(_adapter)                                    \
+	(_adapter->fw_cap_ext & FW_CAPINFO_EXT_BEACON_PROT)
+/** Check if RTT supported by firmware */
+#define IS_FW_SUPPORT_RTT(_adapter) (_adapter->fw_cap_ext & FW_CAPINFO_EXT_RTT)
+/** Check if Channel Tracking supported by firmware */
+#define IS_FW_SUPPORT_CHAN_TRACK(_adapter)                                     \
+	(_adapter->fw_cap_ext & FW_CAPINFO_EXT_CHAN_TRACK)
+/** Check if 6G supported by firmware */
+#define IS_FW_SUPPORT_6G(_adapter) (_adapter->fw_cap_ext & FW_CAPINFO_EXT_6G)
+
+/** MrvlIEtypes_PrevBssid_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_PrevBssid_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** prev_bssid **/
+	t_u8 prev_bssid[6];
+} MLAN_PACK_END MrvlIEtypes_PrevBssid_t;
 
 /** FW cap info TLV */
 typedef MLAN_PACK_START struct _MrvlIEtypes_fw_cap_info_t {
@@ -1376,7 +1528,7 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_Extension_t {
 	/** Element id extension */
 	t_u8 ext_id;
 	/** payload */
-	t_u8 data[];
+	t_u8 data[1];
 } MLAN_PACK_END MrvlIEtypes_Extension_t, *pMrvlIEtypes_Extension_t;
 
 /* HE MAC Capabilities Information field BIT 1 for TWT Req */
@@ -1394,20 +1546,45 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 	t_u8 he_mac_cap[6];
 	/** he phy capability info */
 	t_u8 he_phy_cap[11];
-	/** he txrx mcs support , size would be 4 or 8 or 12 */
-	t_u8 he_txrx_mcs_support[4];
-	/** 160Mhz tx rx mcs support*/
-	t_u8 he160_txrx_mcs_support[4];
-	/** 80+80 Mhz tx rx mcs suport */
-	t_u8 he8080_txrx_mcs_support[4];
+	/** rx mcs for 80 */
+	t_u16 rx_mcs_80;
+	/** tx mcs for 80 */
+	t_u16 tx_mcs_80;
+	/** rx mcs for bw 160 */
+	t_u16 rx_mcs_160;
+	/** tx mcs for bw 160 */
+	t_u16 tx_mcs_160;
+	/** rx mcs for bw 80+80 */
+	t_u16 rx_mcs_80p80;
+	/** tx mcs for bw 80+80 */
+	t_u16 tx_mcs_80p80;
 	/** PPE Thresholds (optional) */
 	t_u8 val[20];
 } MLAN_PACK_END MrvlIEtypes_He_cap_t, *pMrvlIEtypes_he_cap_t;
 
-#ifdef RX_PACKET_COALESCE
-/** Host Command ID : Rx packet coalescing configuration */
-#define HostCmd_CMD_RX_PKT_COALESCE_CFG 0x012c
-#endif
+typedef MLAN_PACK_START struct _MrvlIEtypes_He_Op_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Element id extension */
+	t_u8 ext_id;
+	/** HE Operation Parameters */
+	t_u16 he_op_param1;
+	/** HE Operation Parameters */
+	t_u8 he_op_param2;
+	/** BSS Color Info */
+	t_u8 bss_color_info;
+	/** Basic HE-MCS and NSS Set */
+	t_u16 basic_he_mcs_nss;
+	/** Optional Field, including VHT Operation Info Max Co-Hosted BSSID
+	 * Indicator, and 6Ghz Operation Info  */
+	t_u8 option[9];
+} MLAN_PACK_END MrvlIEtypes_He_Op_t;
+
+/** fw_cap_info bit30 for Embedded OWE Support*/
+#define FW_CAPINFO_EMBEDDED_OWE_SUPPORT MBIT(30)
+/** Check if Embedded OWE is supported by firmware */
+#define IS_FW_SUPPORT_EMBEDDED_OWE(_adapter)                                   \
+	(_adapter->fw_cap_info & FW_CAPINFO_EMBEDDED_OWE_SUPPORT)
 
 /** Host Command ID : Extended scan support */
 #define HostCmd_CMD_802_11_SCAN_EXT 0x0107
@@ -1448,6 +1625,9 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 /** Host Command id: PMIC CONFIGURE*/
 #define HOST_CMD_PMIC_CONFIGURE 0x23E
 
+/** Host Command ID: 802.11 Network Monitor */
+#define HostCmd_CMD_802_11_NET_MONITOR 0x0102
+
 /** Host Command ID: Tx data pause */
 #define HostCmd_CMD_CFG_TX_DATA_PAUSE 0x0103
 
@@ -1458,6 +1638,8 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 #define HOST_CMD_WIFI_DIRECT_MODE_CONFIG 0x00eb
 #endif
 
+/** Host Command ID: GPIO TSF LATCH */
+#define HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG 0x0278
 /** Host Command ID: Remain On Channel */
 #define HostCmd_CMD_802_11_REMAIN_ON_CHANNEL 0x010d
 
@@ -1469,6 +1651,9 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 /** Host Command ID : OTP user data */
 #define HostCmd_CMD_OTP_READ_USER_DATA 0x0114
 
+/** Host Command ID: fw auto reconnect */
+#define HostCmd_CMD_FW_AUTO_RECONNECT 0x0115
+
 /** Host Command ID: HS wakeup reason */
 #define HostCmd_CMD_HS_WAKEUP_REASON 0x0116
 
@@ -1484,6 +1669,8 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 
 /** Host Command ID: BCA device access */
 #define HostCmd_CMD_BCA_REG_ACCESS 0x0272
+/** Host Command ID: register device access */
+#define HostCmd_CMD_REG_ACCESS 0x027C
 
 /** Host Command ID: DFS repeater mode */
 #define HostCmd_DFS_REPEATER_MODE 0x012b
@@ -1497,6 +1684,8 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 /** Host Command ID : Configure ADHOC_OVER_IP parameters */
 #define HostCmd_CMD_WMM_PARAM_CONFIG 0x023a
 
+#define HostCmd_CMD_IPV6_RA_OFFLOAD_CFG 0x0238
+
 #ifdef STA_SUPPORT
 /** Host Command ID :  set/get sta configure */
 #define HostCmd_CMD_STA_CONFIGURE 0x023f
@@ -1505,8 +1694,6 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_He_cap_t {
 /** Host Command ID : GPIO independent reset configure */
 #define HostCmd_CMD_INDEPENDENT_RESET_CFG 0x0243
 
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 /* TLV type: reg type */
 #define TLV_TYPE_REG_ACCESS_CTRL (PROPRIETARY_TLV_BASE_ID + 0x13C) /* 0x023c*/
 /** MrvlIEtypes_Reg_type_t*/
@@ -1516,9 +1703,11 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_Reg_type_t {
 	/** type: 0x81/0x82/0x83 */
 	t_u8 type;
 } MLAN_PACK_END MrvlIEtypes_Reg_type_t;
-
-#endif
+/** use to query chan region cfg setting in firmware */
 #define HostCmd_CMD_CHAN_REGION_CFG 0x0242
+/** used in hostcmd to download region power cfg setting to firmware */
+#define HostCmd_CMD_REGION_POWER_CFG 0x0249
+
 /* mod_grp */
 typedef enum _mod_grp {
 	MOD_CCK, // 0
@@ -1578,11 +1767,25 @@ typedef MLAN_PACK_START struct _power_table_attr {
 #define HostCmd_CMD_TX_AMPDU_PROT_MODE 0x0263
 #define HostCmd_CMD_RATE_ADAPT_CFG 0x0264
 #define HostCmd_CMD_CCK_DESENSE_CFG 0x0265
+#define HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS 0x024d
+#define HostCmd_CMD_FTM_SESSION_CTRL 0x024e
+#define HostCmd_CMD_FTM_FEATURE_CTRL 0x024f
+#define HostCmd_CMD_WLS_REQ_FTM_RANGE 0x0250
+
+#define HostCmd_CMD_FTM_CONFIG_RESPONDER 0x0255
+#define HostCmd_ACT_RTT_GET_RSP_INFO 0x0000
+#define HostCmd_ACT_RTT_SET_RSP_EN 0x0001
+#define HostCmd_ACT_RTT_SET_RSP_DIS 0x0002
+#define HostCmd_ACT_RTT_SET_RSP_LCI 0x0003
+#define HostCmd_ACT_RTT_SET_RSP_LCR 0x0004
 
 #define HostCmd_CMD_VDLL 0x0240
 #if defined(PCIE)
 #define HostCmd_CMD_SSU 0x0259
 #endif
+#define HostCmd_CMD_CSI 0x025b
+#define CSI_CMD_ENABLE 0x0001
+#define CSI_CMD_DISABLE 0x0002
 
 #define HostCmd_CMD_DMCS_CONFIG 0x0260
 
@@ -1599,6 +1802,14 @@ typedef MLAN_PACK_START struct _power_table_attr {
 #define HostCmd_CMD_UAP_BEACON_STUCK_CFG 0x0271
 #define HostCmd_CMD_ARB_CONFIG 0x0273
 #define HostCmd_CMD_DOT11MC_UNASSOC_FTM_CFG 0x0275
+#define HostCmd_CMD_HAL_PHY_CFG 0x0276
+
+/** Host Command ID : IPS Config */
+#define HostCmd_CMD_IPS_CONFIG 0x0279
+#define HostCmd_CMD_OFDM_DESENSE_CFG 0x027f
+typedef MLAN_PACK_START struct {
+	t_u32 enable;
+} MLAN_PACK_END HostCmd_DS_IPS_CONFIG;
 
 /** Enhanced PS modes */
 typedef enum _ENH_PS_MODES {
@@ -1728,6 +1939,7 @@ typedef enum _ENH_PS_MODES {
 /** Get BSS type from Host Command (bit 15:12) */
 #define HostCmd_GET_BSS_TYPE(seq) (((seq)&HostCmd_BSS_TYPE_MASK) >> 12)
 
+/* EVENT ID*/
 /** Card Event definition : Dummy host wakeup signal */
 #define EVENT_DUMMY_HOST_WAKEUP_SIGNAL 0x00000001
 /** Card Event definition : Link lost */
@@ -1806,6 +2018,22 @@ typedef enum _ENH_PS_MODES {
 /** Card Event definition : Port release event */
 #define EVENT_PORT_RELEASE 0x0000002b
 
+#ifdef UAP_SUPPORT
+/** Event ID: STA deauth */
+#define EVENT_MICRO_AP_STA_DEAUTH 0x0000002c
+/** Event ID: STA assoicated */
+#define EVENT_MICRO_AP_STA_ASSOC 0x0000002d
+/** Event ID: BSS started */
+#define EVENT_MICRO_AP_BSS_START 0x0000002e
+/** Event ID: BSS idle event */
+#define EVENT_MICRO_AP_BSS_IDLE 0x00000043
+/** Event ID: BSS active event */
+#define EVENT_MICRO_AP_BSS_ACTIVE 0x00000044
+
+/** Event ID: MIC countermeasures event */
+#define EVENT_MICRO_AP_MIC_COUNTERMEASURES 0x0000004c
+#endif /* UAP_SUPPORT */
+
 /** Card Event definition : Pre-Beacon Lost */
 #define EVENT_PRE_BEACON_LOST 0x00000031
 
@@ -1839,6 +2067,9 @@ typedef enum _ENH_PS_MODES {
 /** Remain on Channel expired event */
 #define EVENT_REMAIN_ON_CHANNEL_EXPIRED 0x0000005f
 
+/** TDLS generic event */
+#define EVENT_TDLS_GENERIC_EVENT 0x00000052
+
 #define EVENT_MEF_HOST_WAKEUP 0x0000004f
 
 /** Card Event definition: Channel switch pending announcment */
@@ -1855,49 +2086,53 @@ typedef enum _ENH_PS_MODES {
 /** Enhance ext scan done event */
 #define EVENT_EXT_SCAN_STATUS_REPORT 0x0000007f
 
-/** Event definition : FW debug information */
-#define EVENT_FW_DEBUG_INFO 0x00000063
-
 /** Event definition: RXBA_SYNC */
 #define EVENT_RXBA_SYNC 0x00000059
 
-#ifdef UAP_SUPPORT
-/** Event ID: STA deauth */
-#define EVENT_MICRO_AP_STA_DEAUTH 0x0000002c
-/** Event ID: STA assoicated */
-#define EVENT_MICRO_AP_STA_ASSOC 0x0000002d
-/** Event ID: BSS started */
-#define EVENT_MICRO_AP_BSS_START 0x0000002e
-/** Event ID: BSS idle event */
-#define EVENT_MICRO_AP_BSS_IDLE 0x00000043
-/** Event ID: BSS active event */
-#define EVENT_MICRO_AP_BSS_ACTIVE 0x00000044
-
-/** Event ID: MIC countermeasures event */
-#define EVENT_MICRO_AP_MIC_COUNTERMEASURES 0x0000004c
-#endif /* UAP_SUPPORT */
-
 /** Event ID: TX data pause event */
 #define EVENT_TX_DATA_PAUSE 0x00000055
 
+/** Event definition : FW debug information */
+#define EVENT_FW_DEBUG_INFO 0x00000063
+
 /** Event ID: SAD Report */
 #define EVENT_SAD_REPORT 0x00000066
 
+/** Event ID: Multi Chan Info*/
+#define EVENT_MULTI_CHAN_INFO 0x0000006a
+
+#define EVENT_FW_DUMP_INFO 0x00000073
 /** Event ID: Tx status */
 #define EVENT_TX_STATUS_REPORT 0x00000074
 
 #define EVENT_BT_COEX_WLAN_PARA_CHANGE 0x00000076
 
+#define EVENT_VDLL_IND 0x00000081
+
+#define EVENT_ROAM_OFFLOAD 0x00000083
+
+#define EVENT_WLS_FTM_COMPLETE 0x00000086
+
+#define WLS_SUB_EVENT_FTM_COMPLETE 0
+#define WLS_SUB_EVENT_RADIO_RECEIVED 1
+#define WLS_SUB_EVENT_RADIO_RPT_RECEIVED 2
+#define WLS_SUB_EVENT_ANQP_RESP_RECEIVED 3
+#define WLS_SUB_EVENT_RTT_RESULTS 4
+
+#define EVENT_EXCEED_MAX_P2P_CONN 0x00000089
+
 #if defined(PCIE)
 #define EVENT_SSU_DUMP_DMA 0x0000008C
 #endif
 
-#define EVENT_VDLL_IND 0x00000081
-#define EVENT_EXCEED_MAX_P2P_CONN 0x00000089
-
+#define EVENT_CSI 0x0000008D
 #define EVENT_FW_HANG_REPORT 0x0000008F
+/** Card Event definition : RESET PN */
+
+#define EVENT_ASSOC_REQ_IE 0x00000095
+
+#define CHAN_LOAD_EVENT 0x00000099
 
-#define EVENT_FW_DUMP_INFO 0x00000073
 /** Event ID mask */
 #define EVENT_ID_MASK 0xffff
 
@@ -1910,6 +2145,82 @@ typedef enum _ENH_PS_MODES {
 /** Get BSS type from event cause (bit 31:24) */
 #define EVENT_GET_BSS_TYPE(event_cause) (((event_cause) >> 24) & 0x00ff)
 
+/** event type for tdls setup failure */
+#define TDLS_EVENT_TYPE_SETUP_FAILURE 1
+/** event type for tdls setup request received */
+#define TDLS_EVENT_TYPE_SETUP_REQ 2
+/** event type for tdls link torn down */
+#define TDLS_EVENT_TYPE_LINK_TORN_DOWN 3
+/** event type for tdls link established */
+#define TDLS_EVENT_TYPE_LINK_ESTABLISHED 4
+/** event type for tdls debug */
+#define TDLS_EVENT_TYPE_DEBUG 5
+/** event type for tdls packet */
+#define TDLS_EVENT_TYPE_PACKET 6
+/** event type for channel switch result */
+#define TDLS_EVENT_TYPE_CHAN_SWITCH_RESULT 7
+/** event type for start channel switch */
+#define TDLS_EVENT_TYPE_START_CHAN_SWITCH 8
+/** event type for stop channel switch */
+#define TDLS_EVENT_TYPE_CHAN_SWITCH_STOPPED 9
+
+/** Packet received on direct link */
+#define RXPD_FLAG_PKT_DIRECT_LINK MBIT(0)
+/** TDLS base channel */
+#define TDLS_BASE_CHANNEL 0
+/** TDLS off channel */
+#define TDLS_OFF_CHANNEL 1
+
+#define RXPD_FLAG_PKT_EASYMESH MBIT(4)
+
+/** structure for channel switch result from TDLS FW */
+typedef MLAN_PACK_START struct _chan_switch_result {
+	/** current channel, 0 - base channel, 1 - off channel*/
+	t_u8 current_channel;
+	/** channel switch status*/
+	t_u8 status;
+	/** channel switch fauilure reason code*/
+	t_u8 reason;
+} MLAN_PACK_END chan_switch_result;
+
+typedef MLAN_PACK_START struct _ie_data {
+	/** IE Length */
+	t_u16 ie_length;
+	/** IE pointer */
+	t_u8 ie_ptr[1];
+} MLAN_PACK_END tdls_ie_data;
+
+/** Event structure for generic events from TDLS FW */
+typedef MLAN_PACK_START struct _Event_tdls_generic {
+	/** Event Type */
+	t_u16 event_type;
+	/** Peer mac address */
+	t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+	union {
+		/** channel switch result structure*/
+		chan_switch_result switch_result;
+		/** channel switch stop reason*/
+		t_u8 cs_stop_reason;
+		/** Reason code */
+		t_u16 reason_code;
+		/** IE data */
+		tdls_ie_data ie_data;
+	} u;
+} MLAN_PACK_END Event_tdls_generic;
+
+typedef enum _tdls_error_code_e {
+	NO_ERROR = 0,
+	INTERNAL_ERROR,
+	MAX_TDLS_LINKS_EST,
+	TDLS_LINK_EXISTS,
+	TDLS_LINK_NONEXISTENT,
+	TDLS_PEER_STA_UNREACHABLE = 25,
+} tdls_error_code_e;
+
+#define RXPD_FLAG_EXTRA_HEADER (1 << 1)
+
+#define RXPD_FLAG_UCAST_PKT (1 << 3)
+
 /** Event_WEP_ICV_ERR structure */
 typedef MLAN_PACK_START struct _Event_WEP_ICV_ERR {
 	/** Reason code */
@@ -1945,11 +2256,24 @@ typedef MLAN_PACK_START struct _WLAN_802_11_VARIABLE_IEs {
 } MLAN_PACK_END WLAN_802_11_VARIABLE_IEs;
 
 /** TLV related data structures*/
+/*TDLS TIMEOUT VALUE (seconds)*/
+#define TDLS_IDLE_TIMEOUT 60
+/** MrvlIEtypes_Data_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_TDLS_Idle_Timeout_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** value */
+	t_u16 value;
+} MLAN_PACK_END MrvlIEtypes_TDLS_Idle_Timeout_t;
 #if defined(STA_SUPPORT)
 /** Pairwise Cipher Suite length */
 #define PAIRWISE_CIPHER_SUITE_LEN 4
 /** AKM Suite length */
 #define AKM_SUITE_LEN 4
+/** PMKID length */
+#define PMKID_LEN 16
+/** Group mgmt Cipher Suite length */
+#define GROUP_MGMT_CIPHER_SUITE_LEN 4
 /** MFPC bit in RSN capability */
 #define MFPC_BIT 7
 /** MFPR bit in RSN capability */
@@ -1960,11 +2284,18 @@ typedef MLAN_PACK_START struct _WLAN_802_11_VARIABLE_IEs {
 /** Bit mask for TxPD status field for last packet */
 #define MRVDRV_TxPD_POWER_MGMT_LAST_PACKET 0x08
 
+/** Bit mask for TxPD flags field for TDLS packet */
+#define MRVDRV_TxPD_FLAGS_TDLS_PACKET MBIT(4)
+
 /** Bit mask for TxPD flags field for Tx status report */
 #define MRVDRV_TxPD_FLAGS_TX_PACKET_STATUS MBIT(5)
 
+/** Bit mask for TxPD flags field for EASYMESH */
+#define MRVDRV_TxPD_FLAGS_EASYMESH MBIT(7)
+
 /** Packet type: 802.11 */
 #define PKT_TYPE_802DOT11 0x05
+
 #define PKT_TYPE_MGMT_FRAME 0xE5
 /** Packet type: AMSDU */
 #define PKT_TYPE_AMSDU 0xE6
@@ -1974,10 +2305,14 @@ typedef MLAN_PACK_START struct _WLAN_802_11_VARIABLE_IEs {
 /** Packet type: debugging */
 #define PKT_TYPE_DEBUG 0xEF
 
+#define PKT_TYPE_802DOT11_MC_AGGR 11
+
 /** channel number at bit 5-13 */
 #define RXPD_CHAN_MASK 0x3FE0
 /** Rate control mask  15-23 */
 #define TXPD_RATE_MASK 0xff8000
+/** DCM at bit 16 */
+#define RXPD_DCM_MASK 0x10000
 /** enable bw ctrl in TxPD */
 #define TXPD_BW_ENABLE MBIT(20)
 /** enable tx power ctrl in TxPD */
@@ -1989,6 +2324,89 @@ typedef MLAN_PACK_START struct _WLAN_802_11_VARIABLE_IEs {
 /** enable retry limit in TxPD */
 #define TXPD_RETRY_ENABLE MBIT(12)
 
+/** tx_control*/
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _tx_ctrl {
+	/** reserved */
+	t_u32 reserved : 3;
+	/** mc retry packet */
+	t_u32 mc_pkt_retry : 1;
+	/** end of mc AMPDU */
+	t_u32 mc_ampdu_end : 1;
+	/** start of mc AMPDU */
+	t_u32 mc_ampdu_start : 1;
+	/** End of mc cycle */
+	t_u32 mc_cycle_end : 1;
+	/** start of mc cycle */
+	t_u32 mc_cycle_start : 1;
+	/** bw 0-20MHz, 1-40MHz */
+	t_u32 bw : 3;
+	/** Rate used for transmission MCS0-7*/
+	t_u32 tx_rate : 5;
+	/** Control the use of txRate. 0 - use FW setting, 1 - use the specified
+	 * txRate;*/
+	t_u32 host_txrate_ctrl : 1;
+	/**  0/1 - use FW setting, 2 - ACK_IMMD, 3 - NO_ACK.*/
+	t_u32 ack_policy : 2;
+	/** Control the use of retryLimit. 0 - use FW setting, 1 - use the
+	 * specified retryLimit.*/
+	t_u32 host_retry_ctrl : 1;
+	/** retry limit */
+	t_u32 retry_limit : 4;
+	/** Control the use of txPower. 0 - use FW power setting, 1 - use the
+	 * specified txPower.*/
+	t_u32 host_tx_powerctrl : 1;
+	/** Sign of the txPower, 0 - positive_sign(+), 1 - negative_sign(-). */
+	t_u32 tx_power_sign : 1;
+	/** Power used for transmission(in dBm); */
+	t_u32 tx_power : 6;
+} MLAN_PACK_END tx_ctrl;
+#else
+typedef MLAN_PACK_START struct _tx_ctrl {
+	/** Power used for transmission(in dBm); */
+	t_u32 tx_power : 6;
+	/** Sign of the txPower, 0 - positive_sign(+), 1 - negative_sign(-). */
+	t_u32 tx_power_sign : 1;
+	/** Control the use of txPower. 0 - use FW power setting, 1 - use the
+	 * specified txPower.*/
+	t_u32 host_tx_powerctrl : 1;
+	/** retry limit */
+	t_u32 retry_limit : 4;
+	/** Control the use of retryLimit. 0 - use FW setting, 1 - use the
+	 * specified retryLimit.*/
+	t_u32 host_retry_ctrl : 1;
+	/**  0/1 - use FW setting, 2 - ACK_IMMD, 3 - NO_ACK.*/
+	t_u32 ack_policy : 2;
+	/** Control the use of txRate. 0 - use FW setting, 1 - use the specified
+	 * txRate;*/
+	t_u32 host_txrate_ctrl : 1;
+	/** Rate used for transmission MCS0-7*/
+	t_u32 tx_rate : 5;
+	/** bw 0-20MHz 1-40MHz*/
+	t_u32 bw : 3;
+	/** start of mc cycle */
+	t_u32 mc_cycle_start : 1;
+	/** End of mc cycle */
+	t_u32 mc_cycle_end : 1;
+	/** start of mc AMPDU */
+	t_u32 mc_ampdu_start : 1;
+	/** end of mc AMPDU */
+	t_u32 mc_ampdu_end : 1;
+	/** mc retry packet */
+	t_u32 mc_pkt_retry : 1;
+	/** reserved */
+	t_u32 reserved : 3;
+} MLAN_PACK_END tx_ctrl;
+#endif
+
+/** mc tx ctrl */
+typedef MLAN_PACK_START struct _mc_tx_ctrl {
+	/** mc seq */
+	t_u16 mc_seq;
+	/** abs_tsf_expirytime*/
+	t_u32 abs_tsf_expirytime;
+} MLAN_PACK_END mc_tx_ctrl;
+
 /** TxPD descriptor */
 typedef MLAN_PACK_START struct _TxPD {
 	/** BSS type */
@@ -2014,6 +2432,9 @@ typedef MLAN_PACK_START struct _TxPD {
 	t_u8 reserved;
 	/** Tx Control */
 	t_u32 tx_control_1;
+	/** ra mac address */
+	t_u8 ra_mac[6];
+	t_u8 reserved3[2];
 } MLAN_PACK_END TxPD, *PTxPD;
 
 /** RxPD Descriptor */
@@ -2056,6 +2477,11 @@ typedef MLAN_PACK_START struct _RxPD {
 	t_u64 toa_tod_tstamps;
 	/** rx info */
 	t_u32 rx_info;
+
+	/** Reserved */
+	t_u8 reserved3[8];
+	t_u8 ta_mac[6];
+	t_u8 reserved4[2];
 } MLAN_PACK_END RxPD, *PRxPD;
 
 /** IEEEtypes_FrameCtl_t*/
@@ -2202,7 +2628,7 @@ typedef MLAN_PACK_START struct _chan_power_11d {
 	/** 11D channel */
 	t_u8 chan;
 	/** Band for channel */
-	t_u8 band;
+	t_u16 band;
 	/** 11D channel power */
 	t_u8 pwr;
 	/** AP seen on channel */
@@ -2221,8 +2647,8 @@ typedef MLAN_PACK_START struct _parsed_region_chan_11d {
 /** ChanScanMode_t */
 typedef MLAN_PACK_START struct _ChanScanMode_t {
 #ifdef BIG_ENDIAN_SUPPORT
-	/** Reserved */
-	t_u8 reserved_7 : 1;
+	/** rnr_flag, host use only */
+	t_u8 rnr_flag : 1;
 	/** First passive scan then active scan */
 	t_u8 passive_to_active_scan : 1;
 	/** First channel in scan */
@@ -2252,8 +2678,8 @@ typedef MLAN_PACK_START struct _ChanScanMode_t {
 	t_u8 first_chan : 1;
 	/** First passive scan then active scan */
 	t_u8 passive_to_active_scan : 1;
-	/** Reserved */
-	t_u8 reserved_7 : 1;
+	/** rnr_flag, host use only */
+	t_u8 rnr_flag : 1;
 #endif
 } MLAN_PACK_END ChanScanMode_t;
 
@@ -2361,6 +2787,14 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_HostMlme_t {
 	t_u8 host_mlme;
 } MLAN_PACK_END MrvlIEtypes_HostMlme_t;
 
+/** MrvlIEtypes_MultiAp_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_MultiAp_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Multi AP flag */
+	t_u8 flag;
+} MLAN_PACK_END MrvlIEtypes_MultiAp_t;
+
 /** MrvlIEtypes_NumProbes_t */
 typedef MLAN_PACK_START struct _MrvlIEtypes_NumProbes_t {
 	/** Header */
@@ -2625,6 +3059,16 @@ typedef MLAN_PACK_START struct _cmac_aes_param {
 	t_u8 key[CMAC_AES_KEY_LEN];
 } MLAN_PACK_END cmac_aes_param;
 
+/** gmac_aes_256_param */
+typedef MLAN_PACK_START struct _gmac_aes_256_param {
+	/** IGTK pn */
+	t_u8 ipn[IGTK_PN_SIZE];
+	/** key_len */
+	t_u16 key_len;
+	/** aes key */
+	t_u8 key[WPA_IGTK_256_KEY_LEN];
+} MLAN_PACK_END gmac_aes_256_param;
+
 /** gmac_param */
 typedef MLAN_PACK_START struct _gcmp_param {
 	/** GCMP pn */
@@ -2670,6 +3114,7 @@ typedef MLAN_PACK_START struct _MrvlIEtype_KeyParamSetV2_t {
 		wapi_param wapi;
 		/** IGTK key param */
 		cmac_aes_param cmac_aes;
+		gmac_aes_256_param gmac_aes;
 		/** gcmp key param */
 		gcmp_param gcmp;
 		/** ccmp 256 key parameters */
@@ -2824,7 +3269,7 @@ typedef MLAN_PACK_START struct _MrvlIETypes_ChanTRPCConfig_t {
 	/** channel number */
 	t_u8 chan_num;
 	/** mode groups */
-	mod_group_setting mod_group[];
+	mod_group_setting mod_group[1];
 } MLAN_PACK_END MrvlIETypes_ChanTRPCConfig_t;
 
 /* HostCmd_DS_CHANNEL_TRPC_CONFIG */
@@ -2834,9 +3279,42 @@ typedef MLAN_PACK_START struct _HostCmd_DS_CHANNEL_TRPC_CONFIG {
 	/** 0/1/2/3 */
 	t_u16 sub_band;
 	/** chan TRPC config */
-	MrvlIETypes_ChanTRPCConfig_t tlv[];
+	// MrvlIETypes_ChanTRPCConfig_t tlv[];
 } MLAN_PACK_END HostCmd_DS_CHANNEL_TRPC_CONFIG;
 
+/** Address type: broadcast */
+#define ADDR_TYPE_BROADCAST 1
+/* Address type: unicast */
+#define ADDR_TYPE_UNICAST 2
+/* Address type: multicast */
+#define ADDR_TYPE_MULTICAST 3
+
+/** Ether type: any */
+#define ETHER_TYPE_ANY 0xffff
+/** Ether type: ARP */
+#define ETHER_TYPE_ARP 0x0608
+
+/** IPv4 address any */
+#define IPV4_ADDR_ANY 0xffffffff
+
+/** Header structure for ARP filter */
+typedef MLAN_PACK_START struct _arpfilter_header {
+	/** Type */
+	t_u16 type;
+	/** TLV length */
+	t_u16 len;
+} MLAN_PACK_END arpfilter_header;
+
+/** Filter entry structure */
+typedef MLAN_PACK_START struct _filter_entry {
+	/** Address type */
+	t_u16 addr_type;
+	/** Ether type */
+	t_u16 eth_type;
+	/** IPv4 address */
+	t_u32 ipv4_addr;
+} MLAN_PACK_END filter_entry;
+
 typedef MLAN_PACK_START struct _HostCmd_DS_MEF_CFG {
 	/** Criteria */
 	t_u32 criteria;
@@ -2873,6 +3351,14 @@ typedef MLAN_PACK_START struct _mef_op {
 	t_u8 val[MAX_NUM_BYTE_SEQ + 1];
 } MLAN_PACK_END mef_op;
 
+/** Structure definition for low power mode cfg command */
+typedef MLAN_PACK_START struct _HostCmd_DS_LOW_POWER_MODE_CFG {
+	/** Action */
+	t_u16 action;
+	/** Low power mode */
+	t_u16 lpm;
+} MLAN_PACK_END HostCmd_DS_LOW_POWER_MODE_CFG;
+
 /* HostCmd_DS_802_11_SLEEP_PERIOD */
 typedef MLAN_PACK_START struct _HostCmd_DS_802_11_SLEEP_PERIOD {
 	/** ACT_GET/ACT_SET */
@@ -2999,14 +3485,6 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_bcn_timeout_t {
 	t_u16 bcn_rq_tmo_period;
 } MLAN_PACK_END MrvlIEtypes_bcn_timeout_t;
 
-/** Structure definition for low power mode cfg command */
-typedef MLAN_PACK_START struct _HostCmd_DS_LOW_POWER_MODE_CFG {
-	/** Action */
-	t_u16 action;
-	/** Low power mode */
-	t_u16 lpm;
-} MLAN_PACK_END HostCmd_DS_LOW_POWER_MODE_CFG;
-
 /** Structure definition for new power save command */
 typedef MLAN_PACK_START struct _HostCmd_DS_PS_MODE_ENH {
 	/** Action */
@@ -3062,6 +3540,7 @@ enum API_VER_ID {
 	FW_API_VER_ID = 2,
 	UAP_FW_API_VER_ID = 3,
 	CHANRPT_API_VER_ID = 4,
+	FW_HOTFIX_VER_ID = 5,
 };
 
 /** FW AP V15 */
@@ -3098,8 +3577,8 @@ typedef MLAN_PACK_START struct _HostCmd_DS_GET_HW_SPEC {
 	t_u16 number_of_antenna;
 	/** FW release number, example 0x1234=1.2.3.4 */
 	t_u32 fw_release_number;
-	/** Reserved field */
-	t_u32 reserved_1;
+	/** hw dev cap */
+	t_u32 hw_dev_cap;
 	/** Reserved field */
 	t_u32 reserved_2;
 	/** Reserved field */
@@ -3190,6 +3669,57 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_RSSI_EXT_t {
 	t_s16 bcn_nf_avg;
 } MLAN_PACK_END MrvlIEtypes_RSSI_EXT_t;
 
+/**  HostCmd_DS_CMD_MC_AGGR_CFG */
+typedef MLAN_PACK_START struct _HostCmd_DS_MC_AGGR_CFG {
+	/** Action */
+	t_u16 action;
+	/** Reserved field 1 */
+	t_u16 reserved_1;
+	/* 1 enable, 0 disable
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 enable_bitmap;
+	/* 1 valid, 0 invalid
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 mask_bitmap;
+	/** CTS2Self duration offset */
+	t_u16 cts2self_offset;
+} MLAN_PACK_END HostCmd_DS_MC_AGGR_CFG;
+
+/** Stats_Cfg_Params_TLV */
+typedef struct MLAN_PACK_START _Stats_Cfg_Params_TLV {
+	/** tlvHeader */
+	MrvlIEtypesHeader_t tlvHeader;
+	/** op */
+	t_u8 op;
+	/** reserved */
+	t_u8 reserved;
+	/** mac */
+	mlan_802_11_mac_addr mac;
+} MLAN_PACK_END Stats_Cfg_Params_TLV_t;
+
+/** HostCmd_DS_STATS */
+typedef MLAN_PACK_START struct _HostCmd_DS_STATS {
+	/** Action */
+	t_u16 action;
+	/** TLV buffer */
+	t_u8 tlv_buffer[1];
+} MLAN_PACK_END HostCmd_DS_STATS;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_GET_CH_LOAD {
+	/** Action */
+	t_u16 action;
+	t_u16 ch_load;
+	t_s16 noise;
+	t_u16 rx_quality;
+	t_u16 duration;
+} MLAN_PACK_END HostCmd_DS_GET_CH_LOAD;
+
 /**  HostCmd_DS_CMD_802_11_RSSI_INFO */
 typedef MLAN_PACK_START struct _HostCmd_DS_802_11_RSSI_INFO {
 	/** Action */
@@ -3246,6 +3776,18 @@ typedef MLAN_PACK_START struct _HostCmd_DS_MAC_CONTROL {
 	t_u32 action;
 } MLAN_PACK_END HostCmd_DS_MAC_CONTROL;
 
+/** HostCmd_DS_802_11_NET_MONITOR */
+typedef MLAN_PACK_START struct _HostCmd_802_11_DS_NET_MONITOR {
+	/** Action */
+	t_u16 action;
+	/** Enable/disable net monitor */
+	t_u16 enable_net_mon;
+	/** set net monitor filer flag */
+	t_u16 filter_flag;
+	/** Channel to monitor */
+	MrvlIEtypes_ChanBandListParamSet_t monitor_chan;
+} MLAN_PACK_END HostCmd_DS_802_11_NET_MONITOR;
+
 /** HostCmd_DS_CMD_TX_DATA_PAUSE */
 typedef MLAN_PACK_START struct _HostCmd_DS_CMD_TX_DATA_PAUSE {
 	/** Action */
@@ -3533,6 +4075,54 @@ typedef MLAN_PACK_START struct _HostCmd_DS_802_11_GET_LOG {
 	t_u64 rx_octets_in_ampdu_cnt;
 	/** ampdu delimiter CRC error count */
 	t_u32 ampdu_delimiter_crc_error_cnt;
+	/** Rx Stuck Related Info*/
+	/** Rx Stuck Issue count */
+	t_u32 rx_stuck_issue_cnt[2];
+	/** Rx Stuck Recovery count */
+	t_u32 rx_stuck_recovery_cnt;
+	/** Rx Stuck TSF */
+	t_u64 rx_stuck_tsf[2];
+	/** Tx Watchdog Recovery Related Info */
+	/** Tx Watchdog Recovery count */
+	t_u32 tx_watchdog_recovery_cnt;
+	/** Tx Watchdog TSF */
+	t_u64 tx_watchdog_tsf[2];
+	/** Channel Switch Related Info */
+	/** Channel Switch Announcement Sent */
+	t_u32 channel_switch_ann_sent;
+	/** Channel Switch State */
+	t_u32 channel_switch_state;
+	/** Register Class */
+	t_u32 reg_class;
+	/** Channel Number */
+	t_u32 channel_number;
+	/** Channel Switch Mode */
+	t_u32 channel_switch_mode;
+	/** Reset Rx Mac Count */
+	t_u32 rx_reset_mac_recovery_cnt;
+	/** ISR2 Not Done Count*/
+	t_u32 rx_Isr2_NotDone_Cnt;
+	/** GDMA Abort Count */
+	t_u32 gdma_abort_cnt;
+	/** Rx Reset MAC Count */
+	t_u32 g_reset_rx_mac_cnt;
+	// Ownership error counters
+	/*Error Ownership error count*/
+	t_u32 dwCtlErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwBcnErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwMgtErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwDatErrCnt;
+	/*BIGTK MME good count*/
+	t_u32 bigtk_mmeGoodCnt;
+	/*BIGTK Replay error count*/
+	t_u32 bigtk_replayErrCnt;
+	/*BIGTK MIC error count*/
+	t_u32 bigtk_micErrCnt;
+	/*BIGTK MME not included count*/
+	t_u32 bigtk_mmeNotFoundCnt;
 } MLAN_PACK_END HostCmd_DS_802_11_GET_LOG;
 
 /* maln wifi rate */
@@ -3766,6 +4356,10 @@ typedef MLAN_PACK_START struct _HostCmd_DS_802_11_LINK_STATISTIC {
 typedef MLAN_PACK_START struct _HostCmd_TX_RATE_QUERY {
 	/** Tx rate */
 	t_u8 tx_rate;
+	/** V14 FW: Ht Info
+	 * [Bit 0] RxRate format: LG=0, HT=1
+	 * [Bit 1] HT Bandwidth: BW20 = 0, BW40 = 1
+	 * [Bit 2] HT Guard Interval: LGI = 0, SGI = 1 */
 	/** Tx Rate Info:
 	 * [Bit 0-1] tx rate formate: LG = 0, HT = 1, VHT = 2
 	 * [Bit 2-3] HT/VHT Bandwidth: BW20 = 0, BW40 = 1, BW80 = 2, BW160 = 3
@@ -3887,6 +4481,31 @@ typedef MLAN_PACK_START struct _HostCmd_DS_SSU_CFG {
 } MLAN_PACK_END HostCmd_DS_SSU_CFG;
 #endif
 
+/** HostCmd_CMD_CSI_START */
+typedef MLAN_PACK_START struct _HostCmd_DS_CSI_CFG {
+	/** Action */
+	t_u16 action;
+	/** Header ID*/
+	t_u32 head_id;
+	/** Tail ID */
+	t_u32 tail_id;
+	/** Number of CSI filters */
+	t_u8 csi_filter_cnt;
+	/** Chip ID */
+	t_u8 chip_id;
+	/** CSI filters */
+	mlan_csi_filter_t csi_filter[CSI_FILTER_MAX];
+} MLAN_PACK_END HostCmd_DS_CSI_CFG;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_HAL_PHY_CFG {
+	/** Action */
+	t_u16 action;
+	/** 11b pwr spectral density mask enable/disable */
+	t_u8 dot11b_psd_mask_cfg;
+	/** reserved fields for future hal/phy cfg use */
+	t_u8 reserved[7];
+} MLAN_PACK_END HostCmd_DS_HAL_PHY_CFG;
+
 /** SNMP_MIB_INDEX */
 typedef enum _SNMP_MIB_INDEX {
 	OpRateSet_i = 1,
@@ -3903,6 +4522,8 @@ typedef enum _SNMP_MIB_INDEX {
 	SignalextEnable_i = 41,
 	ECSAEnable_i = 42,
 	StopDeauth_i = 44,
+	Dot11H_fakeRadar = 45,
+	ChanTrackParam_i = 46,
 } SNMP_MIB_INDEX;
 
 /** max SNMP buf size */
@@ -3981,7 +4602,9 @@ typedef MLAN_PACK_START struct _MrvlIETypes_rate_setting_t {
 typedef MLAN_PACK_START struct _HostCmd_DS_TX_RATE_CFG {
 	/** Action */
 	t_u16 action;
-	t_u16 reserved_1;
+	/** V14 FW: cfg_index */
+	/** V15+ FW: reserved_1 */
+	t_u16 cfg_index;
 	/* MrvlRateScope_t RateScope;
 	 * MrvlRateDropPattern_t RateDrop; */
 	t_u8 tlv_buf[];
@@ -4133,6 +4756,64 @@ typedef MLAN_PACK_START struct _HostCmd_DS_WIFI_DIRECT_PARAM_CONFIG {
 } MLAN_PACK_END HostCmd_DS_WIFI_DIRECT_PARAM_CONFIG;
 #endif
 
+/** MrvlIEtypes_GPIO_TSF_LATCH_CONFIG*/
+typedef MLAN_PACK_START struct _MrvlIEtypes_GPIO_TSF_LATCH_CONFIG {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/**clock sync Mode */
+	t_u8 clock_sync_mode;
+	/**clock sync Role */
+	t_u8 clock_sync_Role;
+	/**clock sync GPIO Pin Number */
+	t_u8 clock_sync_gpio_pin_number;
+	/**clock sync GPIO Level or Toggle */
+	t_u8 clock_sync_gpio_level_toggle;
+	/**clock sync GPIO Pulse Width */
+	t_u16 clock_sync_gpio_pulse_width;
+
+} MLAN_PACK_END MrvlIEtypes_GPIO_TSF_LATCH_CONFIG;
+
+/** MrvlIEtypes_GPIO_TSF_LATCH_REPORT */
+typedef MLAN_PACK_START struct _MrvlIEtypes_GPIO_TSF_LATCH_REPORT {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/**get tsf info format */
+	t_u16 tsf_format;
+	/**tsf info */
+	t_u16 tsf_info;
+	/**tsf */
+	t_u64 tsf;
+	/**Positive or negative offset in microsecond from Beacon TSF to GPIO
+	 * toggle TSF  */
+	t_s32 tsf_offset;
+} MLAN_PACK_END MrvlIEtypes_GPIO_TSF_LATCH_REPORT;
+
+/** HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG */
+typedef MLAN_PACK_START struct _HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG {
+	/** Action 0-GET, 1-SET */
+	t_u16 action;
+	/** MrvlIEtypes_GPIO_TSF_LATCH_CONFIG
+	 *  MrvlIEtypes_GPIO_TSF_LATCH_REPORT
+	 */
+	t_u8 tlv_buf[];
+} MLAN_PACK_END HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG;
+
+/** MrvlIEtypes_CROSS_CHIP_SYNCH_CONFIG */
+typedef MLAN_PACK_START struct _HostCmd_DS_CROSS_CHIP_SYNCH {
+	/** Action 0-GET, 1-SET */
+	t_u16 action;
+	/**cross chip sync start/stop */
+	t_u8 start_stop;
+	/**cross chip synch role, master or slave */
+	t_u8 role;
+	/**cross chip synch periodicty of toggle in us */
+	t_u32 period;
+	/**cross chip synch initial TSF low */
+	t_u32 init_tsf_low;
+	/**cross chip synch intial TSF high */
+	t_u32 init_tsf_high;
+} MLAN_PACK_END HostCmd_DS_CROSS_CHIP_SYNCH;
+
 MLAN_PACK_START struct coalesce_filt_field_param {
 	t_u8 operation;
 	t_u8 operand_len;
@@ -4145,7 +4826,7 @@ MLAN_PACK_START struct coalesce_receive_filt_rule {
 	t_u8 num_of_fields;
 	t_u8 pkt_type;
 	t_u16 max_coalescing_delay;
-	struct coalesce_filt_field_param params[];
+	struct coalesce_filt_field_param params[1];
 } MLAN_PACK_END;
 
 /** HostCmd_DS_COALESCE_CONFIG */
@@ -4153,7 +4834,7 @@ typedef MLAN_PACK_START struct _HostCmd_DS_COALESCE_CONFIG {
 	/** Action 0-GET, 1-SET */
 	t_u16 action;
 	t_u16 num_of_rules;
-	struct coalesce_receive_filt_rule rule[];
+	struct coalesce_receive_filt_rule rule[1];
 } MLAN_PACK_END HostCmd_DS_COALESCE_CONFIG;
 
 /** TLV type : FW support max connection TLV */
@@ -4673,6 +5354,16 @@ typedef struct MLAN_PACK_START _hostcmd_twt_teardown {
 	t_u8 reserved[3];
 } MLAN_PACK_END hostcmd_twt_teardown, *phostcmd_twt_teardown;
 
+/** Type definition of hostcmd_twt_report */
+typedef MLAN_PACK_START struct _hostcmd_twt_report {
+	/** TWT report type, 0: BTWT id */
+	t_u8 type;
+	/** TWT report length of value in data */
+	t_u8 length;
+	t_u8 reserve[2];
+	/** TWT report payload for FW response to fill */
+	t_u8 data[36];
+} MLAN_PACK_END hostcmd_twt_report, *phostcmd_twt_report;
 /** HostCmd_DS_TWT_CFG */
 typedef MLAN_PACK_START struct _HostCmd_DS_TWT_CFG {
 	/** Action */
@@ -4686,6 +5377,8 @@ typedef MLAN_PACK_START struct _HostCmd_DS_TWT_CFG {
 		/** TWT Teardown config for Sub ID: MLAN_11AX_TWT_TEARDOWN_SUBID
 		 */
 		hostcmd_twt_teardown twt_teardown;
+		/** TWT report for Sub ID: MLAN_11AX_TWT_REPORT_SUBID */
+		hostcmd_twt_report twt_report;
 	} param;
 } MLAN_PACK_END HostCmd_DS_TWT_CFG;
 
@@ -4921,6 +5614,16 @@ typedef MLAN_PACK_START struct _MrvlIETypes_SuppOperClass_t {
 	t_u8 oper_class[1];
 } MLAN_PACK_END MrvlIETypes_SuppOperClass_t;
 
+/*  Supported Transmit Power Envelope Element */
+typedef MLAN_PACK_START struct {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Transmit Power Information */
+	t_u8 tpc_info;
+	/** Maximum Transmit Power Spectral Density */
+	t_u8 max_tp_spectral_density;
+} MLAN_PACK_END MrvlIETypes_TpcEnvelope_t;
+
 /** Oper_class channel bandwidth element */
 typedef MLAN_PACK_START struct _MrvlIEtypes_chan_bw_oper_t {
 	/** Header */
@@ -5124,6 +5827,18 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_psk_t {
 } MLAN_PACK_END MrvlIEtypes_psk_t;
 #endif /* WIFI_DIRECT_SUPPORT */
 
+/** Data structure for Link ID */
+typedef MLAN_PACK_START struct _MrvlIETypes_LinkIDElement_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Bssid */
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/** initial sta address*/
+	t_u8 init_sta[MLAN_MAC_ADDR_LENGTH];
+	/** respose sta address */
+	t_u8 resp_sta[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END MrvlIETypes_LinkIDElement_t;
+
 /** MrvlIEtypes_PMK_t */
 typedef MLAN_PACK_START struct _MrvlIEtypes_PMK_t {
 	/** Header */
@@ -5148,6 +5863,17 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_SAE_Password_t {
 	char sae_password[1];
 } MLAN_PACK_END MrvlIEtypes_SAE_Password_t;
 
+/** MrvlIEtypes_SAE_PWE_Mode_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_SAE_PWE_Mode_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** WPA3 SAE mechanism for PWE derivation */
+	char pwe[1];
+} MLAN_PACK_END MrvlIEtypes_SAE_PWE_Mode_t;
+
+/** SAE H2E capability bit in RSNX */
+#define SAE_H2E_BIT 5
+
 /* rsnMode -
  *      Bit 0    : No RSN
  *      Bit 1-2  : RFU
@@ -5332,6 +6058,28 @@ typedef MLAN_PACK_START struct _HostCmd_DS_MGMT_IE_LIST {
 	mlan_ds_misc_custom_ie ds_mgmt_ie;
 } MLAN_PACK_END HostCmd_DS_MGMT_IE_LIST_CFG;
 
+/** HostCmd_DS_TDLS_CONFIG */
+typedef MLAN_PACK_START struct _HostCmd_DS_TDLS_CONFIG {
+	/** Set TDLS configuration */
+	mlan_ds_misc_tdls_config tdls_info;
+} MLAN_PACK_END HostCmd_DS_TDLS_CONFIG;
+
+/**Action ID for TDLS delete link*/
+#define TDLS_DELETE 0x00
+/**Action ID for TDLS create link*/
+#define TDLS_CREATE 0x01
+/**Action ID for TDLS config link*/
+#define TDLS_CONFIG 0x02
+/** HostCmd_DS_TDLS_OPER */
+typedef MLAN_PACK_START struct _HostCmd_DS_TDLS_OPER {
+	/** Action */
+	t_u16 tdls_action;
+	/**reason*/
+	t_u16 reason;
+	/** peer mac */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END HostCmd_DS_TDLS_OPER;
+
 /** HostCmd_CMD_MAC_REG_ACCESS */
 typedef MLAN_PACK_START struct _HostCmd_DS_MAC_REG_ACCESS {
 	/** Action */
@@ -5401,6 +6149,20 @@ typedef MLAN_PACK_START struct _HostCmd_DS_MEM_ACCESS {
 	t_u32 value;
 } MLAN_PACK_END HostCmd_DS_MEM_ACCESS;
 
+/** HostCmd_CMD_REG_ACCESS */
+typedef MLAN_PACK_START struct _HostCmd_DS_REG_ACCESS {
+	/** Action */
+	t_u16 action;
+	/** reg type */
+	t_u16 reg_type;
+	/** reserved */
+	t_u16 reserved;
+	/** register offset */
+	t_u16 offset;
+	/** register value */
+	t_u32 value;
+} MLAN_PACK_END HostCmd_DS_REG_ACCESS;
+
 /** HostCmd_DS_TARGET_ACCESS */
 typedef MLAN_PACK_START struct _HostCmd_DS_TARGET_ACCESS {
 	/** Action */
@@ -5433,6 +6195,25 @@ typedef MLAN_PACK_START struct _HostCmd_DS_OTP_USER_DATA {
 	t_u8 user_data[1];
 } MLAN_PACK_END HostCmd_DS_OTP_USER_DATA;
 
+/** HostCmd_DS_FW_AUTO_RECONNECT */
+typedef MLAN_PACK_START struct _HostCmd_DS_FW_AUTO_RECONNECT {
+	/** ACT_GET/ACT_SET */
+	t_u16 action;
+	/** reconnect counter:
+	 * [0x0]: Do not attempt auto reconnect i.e. disable auto-reconnect
+	 * [0x1-0xFE]: Number of times reconnection needs to be attempted
+	 * [0xFF]: Attempt auto-reconnection forever */
+	t_u8 reconnect_counter;
+	/** reconnect interval */
+	t_u8 reconnect_interval;
+	/** flags:
+	 * [Bit 0]: Set to 1: Firmware should report link-loss to host if AP
+	 * rejects authentication/association while reconnecting Set to 0:
+	 * Default behavior: Firmware does not report link-loss to host on AP
+	 * rejection and continues internally [Bit 1-15]: Reserved */
+	t_u16 flags;
+} MLAN_PACK_END HostCmd_DS_FW_AUTO_RECONNECT;
+
 /** HostCmd_CMD_HS_WAKEUP_REASON */
 typedef MLAN_PACK_START struct _HostCmd_DS_HS_WAKEUP_REASON {
 	/** wakeupReason:
@@ -5499,7 +6280,7 @@ typedef MLAN_PACK_START struct _dmcs_chan_status {
 	t_u8 sta_count;
 } MLAN_PACK_END dmcs_chan_status;
 
-typedef MLAN_PACK_START struct _dmcs_status {
+typedef MLAN_PACK_START struct _dmcs_status_data {
 	/** radio ID */
 	t_u8 radio_id;
 	/** Running mode
@@ -5510,7 +6291,7 @@ typedef MLAN_PACK_START struct _dmcs_status {
 	t_u8 running_mode;
 	/** Channel status of this radio */
 	dmcs_chan_status chan_status[2];
-} MLAN_PACK_END dmcs_status;
+} MLAN_PACK_END dmcs_status_data;
 
 /** MrvlIEtypes_DmcsConfig_t */
 typedef MLAN_PACK_START struct _MrvlIEtypes_DmcsConfig_t {
@@ -5519,7 +6300,7 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_DmcsConfig_t {
 	/** Mapping policy */
 	t_u8 mapping_policy;
 	/** Radio status of DMCS */
-	dmcs_status radio_status[MAX_NUM_MAC];
+	dmcs_status_data radio_status[MAX_NUM_MAC];
 } MLAN_PACK_END MrvlIEtypes_DmcsStatus_t;
 
 #define ANTMODE_FW_DECISION 0xff
@@ -5546,7 +6327,7 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_WakeupExtend_t {
 	t_u8 gpio_wave;
 } MLAN_PACK_END MrvlIEtypes_WakeupExtend_t;
 
-#define EVENT_MANAGEMENT_FRAME_WAKEUP 136
+#define EVENT_MANAGEMENT_FRAME_WAKEUP 0x00000088
 typedef MLAN_PACK_START struct _mgmt_frame_filter {
 	/** action - bitmap
 	 ** On matching rx'd pkt and filter during NON_HOSTSLEEP mode:
@@ -5763,9 +6544,12 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_MacAddr_t {
 /** TLV type :  AP WMM params */
 #define TLV_TYPE_AP_WMM_PARAM (PROPRIETARY_TLV_BASE_ID + 0xd0) /* 0x01d0 */
 /** TLV type : AP Tx beacon rate */
-#define TLV_TYPE_UAP_TX_BEACON_RATE                                            \
-	(PROPRIETARY_TLV_BASE_ID + 288) /* 0x0220                              \
-					 */
+#define TLV_TYPE_UAP_TX_BEACON_RATE (PROPRIETARY_TLV_BASE_ID + 288) /* 0x0220  \
+								     */
+#define NXP_802_11_PER_PEER_STATS_CFG_TLV_ID                                   \
+	(PROPRIETARY_TLV_BASE_ID + 346) /* 0x025A */
+#define NXP_802_11_PER_PEER_STATS_ENTRY_TLV_ID                                 \
+	(PROPRIETARY_TLV_BASE_ID + 347) /* 0x025B */
 
 /** MrvlIEtypes_beacon_period_t */
 typedef MLAN_PACK_START struct _MrvlIEtypes_beacon_period_t {
@@ -5849,6 +6633,22 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_uap_max_sta_cnt_t {
 	t_u16 uap_max_sta;
 } MLAN_PACK_END MrvlIEtypes_uap_max_sta_cnt_t;
 
+#define MRVL_ACTION_CHAN_SWITCH_ANNOUNCE (PROPRIETARY_TLV_BASE_ID + 342)
+
+/** MrvlIEtypes_uap_chan_switch */
+typedef MLAN_PACK_START struct _MrvlIEtypes_action_chan_switch_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/* 0 send broadcast CSA action frame, 1 send unicast CSA action frame */
+	t_u8 mode;
+	/* number of frame */
+	t_u8 num_pkt;
+	/** reserved */
+	t_u16 reserved;
+	/**ie buf*/
+	t_u8 ie_buf[];
+} MLAN_PACK_END MrvlIEtypes_action_chan_switch_t;
+
 /** MrvlIEtypes_sta_ageout_t */
 typedef MLAN_PACK_START struct _MrvlIEtypes_sta_ageout_t {
 	/** Header */
@@ -5939,6 +6739,10 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_auth_type_t {
 	MrvlIEtypesHeader_t header;
 	/** Authentication type */
 	t_u8 auth_type;
+	/** PWE derivation */
+	t_u8 PWE_derivation;
+	/** transition disable */
+	t_u8 transition_disable;
 } MLAN_PACK_END MrvlIEtypes_auth_type_t;
 
 /** MrvlIEtypes_encrypt_protocol_t */
@@ -6041,6 +6845,14 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_wmm_parameter_t {
 	WmmParameter_t wmm_para;
 } MLAN_PACK_END MrvlIEtypes_wmm_parameter_t;
 
+/** MrvlIEtypes_wacp_mode_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_wacp_mode_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** wacp_mode */
+	t_u8 wacp_mode;
+} MLAN_PACK_END MrvlIEtypes_wacp_mode_t;
+
 /** SNMP_MIB_UAP_INDEX */
 typedef enum _SNMP_MIB_UAP_INDEX {
 	tkip_mic_failures = 0x0b,
@@ -6263,16 +7075,196 @@ typedef MLAN_PACK_START struct _HostCmd_DS_MIMO_SWITCH {
 	t_u8 rxpath_antmode;
 } MLAN_PACK_END HostCmd_DS_MIMO_SWITCH;
 
-#ifdef RX_PACKET_COALESCE
-typedef MLAN_PACK_START struct _HostCmd_DS_RX_PKT_COAL_CFG {
+typedef MLAN_PACK_START struct _MrvlTypes_DrcsTimeSlice_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Channel Index*/
+	t_u16 chan_idx;
+	/** Channel time (in TU) for chan_idx*/
+	t_u8 chantime;
+	/** Channel swith time (in TU) for chan_idx*/
+	t_u8 switchtime;
+	/** Undoze time (in TU) for chan_idx*/
+	t_u8 undozetime;
+	/** Rx traffic control scheme when channel switch*/
+	/** only valid for GC/STA interface*/
+	t_u8 mode;
+} MLAN_PACK_END MrvlTypes_DrcsTimeSlice_t;
+typedef MLAN_PACK_START struct _HostCmd_DS_MULTI_CHAN_CFG {
 	/** Action */
 	t_u16 action;
-	/** Packet threshold */
-	t_u32 packet_threshold;
-	/** Timeout */
-	t_u16 delay;
-} MLAN_PACK_END HostCmd_DS_RX_PKT_COAL_CFG;
-#endif
+	/** Channel time */
+	t_u32 channel_time;
+	/** Buffer weight */
+	t_u8 buffer_weight;
+	/** TLV buffer */
+	t_u8 tlv_buf[];
+	/* t_u8 *tlv_buf; */
+} MLAN_PACK_END HostCmd_DS_MULTI_CHAN_CFG;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_DRCS_CFG {
+	/** Action */
+	t_u16 action;
+	/** TLV buffer */
+	MrvlTypes_DrcsTimeSlice_t time_slicing;
+	/** TLV buffer */
+	MrvlTypes_DrcsTimeSlice_t drcs_buf[];
+	/* t_u8 *tlv_buf; */
+} MLAN_PACK_END HostCmd_DS_DRCS_CFG;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_MULTI_CHAN_POLICY {
+	/** Action */
+	t_u16 action;
+	/** Multi-channel Policy */
+	t_u16 policy;
+} MLAN_PACK_END HostCmd_DS_MULTI_CHAN_POLICY;
+
+/** Channel band info */
+typedef MLAN_PACK_START struct _ChannelBandInfo {
+	/* band config */
+	Band_Config_t bandcfg;
+	/** channel num for specificed band */
+	t_u8 chan_num;
+} MLAN_PACK_END ChannelBandInfo;
+
+/** MrvlIETypes_mutli_chan_group_info_t */
+typedef MLAN_PACK_START struct _MrvlIETypes_mutli_chan_group_info_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** channel group id */
+	t_u8 chan_group_id;
+	/** buffer weight for this channel group */
+	t_u8 chan_buff_weight;
+	/** channel number and band information */
+	ChannelBandInfo chan_band_info;
+	/** Max channel time (us) */
+	t_u32 channel_time;
+	/** Reserved */
+	t_u32 reserved;
+	MLAN_PACK_START union {
+		t_u8 sdio_func_num;
+		t_u8 usb_epnum;
+	} MLAN_PACK_END hid_num;
+	/** interface number in this group */
+	t_u8 num_intf;
+	/** bss_type list */
+	t_u8 bss_type_numlist[];
+} MLAN_PACK_END MrvlIEtypes_multi_chan_group_info_t;
+
+/** MrvlIEtypes_multi_chan_info_t */
+typedef MLAN_PACK_START struct _MrvlIETypes_mutli_chan_info_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** multi channel operation status */
+	t_u16 status;
+	/** Tlv buffer */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END MrvlIEtypes_multi_chan_info_t;
+
+/** TLV buffer : firmware roam keys */
+typedef MLAN_PACK_START struct _MrvlIEtypes_keyParams_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Tlv buffer */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END MrvlIEtypes_keyParams_t;
+
+/** TLV buffer : firmware roam enable */
+typedef MLAN_PACK_START struct _MrvlIEtypes_fw_roam_enable_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Enable */
+	t_u8 roam_enable;
+	/** User set passphrase*/
+	t_u8 userset_passphrase;
+} MLAN_PACK_END MrvlIEtypes_fw_roam_enable_t;
+/** HostCmd_DS_ROAM_OFFLOAD */
+typedef MLAN_PACK_START struct _HostCmd_DS_ROAM_OFFLOAD {
+	/** Action */
+	t_u16 action;
+	/** tlv */
+	t_u8 tlv[];
+} MLAN_PACK_END HostCmd_DS_ROAM_OFFLOAD;
+/** HostCmd_DS_ROAM_OFFLOAD_APLIST */
+typedef MLAN_PACK_START struct _MrvlIEtypes_roam_aplist_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** AP mac addrs**/
+	t_u8 ap_mac[][MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END MrvlIEtypes_roam_aplist_t;
+/** MrvlIEtypes_fw_roam_trigger_condition_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_fw_roam_trigger_condition_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Roam offload trigger condition**/
+	t_u16 trigger_condition;
+} MLAN_PACK_END MrvlIEtypes_fw_roam_trigger_condition_t;
+/** MrvlIEtypes_fw_roam_retry_count_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_fw_roam_retry_count_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Roam offload retry count**/
+	t_u16 retry_count;
+} MLAN_PACK_END MrvlIEtypes_fw_roam_retry_count_t;
+/** MrvlIEtypes_fw_roam_bgscan_setting_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_fw_roam_bgscan_setting_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Bss type of BG scan during fw roam**/
+	t_u8 bss_type;
+	/** Number of channels scanned during each scan**/
+	t_u8 channels_perscan;
+	/** Interval between consecutive scans**/
+	t_u32 scan_interval;
+	/** Condition to trigger report to host**/
+	t_u32 report_condition;
+} MLAN_PACK_END MrvlIEtypes_fw_roam_bgscan_setting_t;
+/** MrvlIEtypes_para_rssi_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_para_rssi_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Max value of RSSI threshold**/
+	t_u8 max_rssi;
+	/** Min value of RSSI threshold**/
+	t_u8 min_rssi;
+	/** Adjusting step value of RSSI threshold**/
+	t_u8 step_rssi;
+} MLAN_PACK_END MrvlIEtypes_para_rssi_t;
+/** MrvlIEtypes_band_rssi_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_band_rssi_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** BAND and RSSI gap*/
+	mlan_ds_misc_band_rssi band_rssi;
+} MLAN_PACK_END MrvlIEtypes_band_rssi_t;
+/** MrvlIEtypes_ees_param_set_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_ees_param_set_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** ees params*/
+	mlan_ds_misc_ees_cfg ees_cfg;
+} MLAN_PACK_END MrvlIEtypes_ees_param_set_t;
+/** MrvlIEtypes_roam_blacklist_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_roam_blacklist_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/* Black list(BSSID list)*/
+	mlan_ds_misc_roam_offload_aplist blacklist;
+} MLAN_PACK_END MrvlIEtypes_roam_blacklist_t;
+/** MrvlIEtypes_beacon_miss_threshold_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_beacon_miss_threshold_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/* Beacon miss threshold*/
+	t_u8 bcn_miss_threshold;
+} MLAN_PACK_END MrvlIEtypes_beacon_miss_threshold_t;
+/** MrvlIEtypes_pre_beacon_miss_threshold_t */
+typedef MLAN_PACK_START struct _MrvlIEtypes_pre_beacon_miss_threshold_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/* Pre-Beacon miss threshold*/
+	t_u8 pre_bcn_miss_threshold;
+} MLAN_PACK_END MrvlIEtypes_pre_beacon_miss_threshold_t;
 
 /** HostCmd_DS_DYN_BW */
 typedef MLAN_PACK_START struct _HostCmd_DS_DYN_BW {
@@ -6669,6 +7661,15 @@ typedef MLAN_PACK_START struct {
 	MeasRptBasicMap_t map; /**< IEEE 802.11h basic meas report */
 } MLAN_PACK_END MrvlIEtypes_ChanRpt11hBasic_t;
 
+/* MrvlIEtypes_ZeroDfsOperation_t */
+typedef MLAN_PACK_START struct {
+	/* header */
+	MrvlIEtypesHeader_t Header;
+	/**< 0-DFS Enable/Disable> */
+	t_u8 zero_dfs_enbl;
+
+} MLAN_PACK_END MrvlIEtypes_ZeroDfsOperation_t;
+
 /* MrvlIEtypes_DfsW53Cfg_t*/
 typedef MLAN_PACK_START struct {
 	/* header */
@@ -6677,6 +7678,16 @@ typedef MLAN_PACK_START struct {
 	t_u8 dfs53cfg;
 } MLAN_PACK_END MrvlIEtypes_DfsW53Cfg_t;
 
+/* MrvlIEtypes_Rgn_dom_code_t*/
+typedef MLAN_PACK_START struct {
+	/* header */
+	MrvlIEtypesHeader_t header;
+	/** Domain Code */
+	t_u8 domain_code;
+	/** Reserved field */
+	t_u8 reserved;
+} MLAN_PACK_END MrvlIEtypes_Rgn_dom_code_t;
+
 typedef MLAN_PACK_START struct {
 	MrvlChannelDesc_t chan_desc; /**< Channel band, number */
 	t_u32 millisec_dwell_time; /**< Channel dwell time in milliseconds */
@@ -6792,6 +7803,22 @@ typedef MLAN_PACK_START struct _HostCmd_DS_SENSOR_TEMP {
 	t_u32 temperature;
 } MLAN_PACK_END HostCmd_DS_SENSOR_TEMP;
 
+#define TLV_TYPE_IPV6_RA_OFFLOAD (PROPRIETARY_TLV_BASE_ID + 0xE6) /** 0x1E6*/
+typedef MLAN_PACK_START struct {
+	MrvlIEtypesHeader_t Header;
+	t_u8 ipv6_addr[16];
+} MLAN_PACK_END MrvlIETypes_IPv6AddrParamSet_t;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_IPV6_RA_OFFLOAD {
+	/** 0x0000: Get IPv6 RA Offload configuration
+	 *  0x0001: Set IPv6 RA Offload configuration
+	 */
+	t_u16 action;
+	/** 0x00: disable IPv6 RA Offload; 0x01: enable IPv6 RA offload */
+	t_u8 enable;
+	MrvlIETypes_IPv6AddrParamSet_t ipv6_addr_param;
+} MLAN_PACK_END HostCmd_DS_IPV6_RA_OFFLOAD;
+
 #ifdef STA_SUPPORT
 typedef MLAN_PACK_START struct _HostCmd_DS_STA_CONFIGURE {
 	/** Action Set or get */
@@ -6811,7 +7838,7 @@ typedef MLAN_PACK_START struct _HostCmd_DS_AUTO_TX {
 } MLAN_PACK_END HostCmd_DS_AUTO_TX;
 
 #define OID_CLOUD_KEEP_ALIVE 0
-#define EVENT_CLOUD_KEEP_ALIVE_RETRY_FAIL 133
+#define EVENT_CLOUD_KEEP_ALIVE_RETRY_FAIL 0x00000085
 /** TLV for cloud keep alive control info */
 #define TLV_TYPE_CLOUD_KEEP_ALIVE                                              \
 	(PROPRIETARY_TLV_BASE_ID + 0x102) /* 0x0100 + 258 */
@@ -6852,6 +7879,22 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_Keep_Alive_Pkt_t {
 	t_u8 ip_packet[];
 } MLAN_PACK_END MrvlIEtypes_Keep_Alive_Pkt_t;
 
+#define OID_CLOUD_KEEP_ALIVE_ACK 1
+#define TLV_TYPE_CLOUD_KEEP_ALIVE_ACK                                          \
+	(PROPRIETARY_TLV_BASE_ID + 0x15D) /* 0x0100 + 349 */
+
+typedef MLAN_PACK_START struct _MrvlIEtypes_Cloud_Keep_Alive_Rx_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** ID for cloud keep alive */
+	t_u8 keep_alive_id;
+	/** Enable/disable for this ID */
+	t_u8 enable;
+	/** Ethernet Header */
+	Eth803Hdr_t eth_header;
+	/** packet buffer*/
+	t_u8 ip_packet[];
+} MLAN_PACK_END MrvlIEtypes_Cloud_Keep_Alive_Rx_t;
 /** TLV to indicate firmware only keep probe response while scan */
 #define TLV_TYPE_ONLYPROBERESP (PROPRIETARY_TLV_BASE_ID + 0xE9) /* 0x01E9 */
 typedef MLAN_PACK_START struct _MrvlIEtypes_OnlyProberesp_t {
@@ -6861,6 +7904,230 @@ typedef MLAN_PACK_START struct _MrvlIEtypes_OnlyProberesp_t {
 	t_u8 proberesp_only;
 } MLAN_PACK_END MrvlIEtypes_OnlyProberesp_t;
 
+/** TLV for RTT Range Request */
+#define TLV_TYPE_RTT_RANGE_REQUEST                                             \
+	(PROPRIETARY_TLV_BASE_ID + 0x125) /* 0x0100 + 0x125 */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTRangeRequest_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Peer device MAC address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** 1-sided or 2-sided RTT */
+	t_u8 type;
+	/** peer device hint (STA, P2P, AP) */
+	t_u8 peer;
+	/** channel number */
+	t_u8 channel;
+	/** Band Config */
+	Band_Config_t bandcfg;
+	/** Time interval between bursts (units: 100 ms) */
+	t_u8 burst_period;
+	/** Total number of RTT bursts to be executed. */
+	t_u8 num_burst;
+	/** num of frames per burst. */
+	t_u8 num_frames_per_burst;
+	/** number of retries for a failed RTT frame. */
+	t_u8 num_retries_per_rtt_frame;
+	/** Maximum number of retries that the initiator can retry an FTMR
+	 * frame. */
+	t_u8 num_retries_per_ftmr;
+	/** LCI request */
+	t_u8 LCI_request;
+	/** LCR request */
+	t_u8 LCR_request;
+	/** burst duration */
+	t_u8 burst_duration;
+	/** RTT preamble to be used in the RTT frames */
+	t_u8 preamble;
+	/** RTT BW to be used in the RTT frames */
+	t_u8 bw;
+} MLAN_PACK_END MrvlIEtypes_RTTRangeRequest_t;
+
+/** TLV for RTT Range Cancel */
+#define TLV_TYPE_RTT_RANGE_CANCEL                                              \
+	(PROPRIETARY_TLV_BASE_ID + 0x126) /* 0x0100 + 0x126 */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTRangeCancel_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Peer device MAC address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END MrvlIEtypes_RTTRangeCancel_t;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_FTM_CONFIG_SESSION_PARAMS {
+	/** Action */
+	t_u16 action;
+	/** TLV buffer */
+	/** MrvlIEtypes_RTTRangeRequest_t */
+	/** MrvlIEtypes_RTTRangeCancel_t */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END HostCmd_DS_FTM_CONFIG_SESSION_PARAMS;
+
+typedef MLAN_PACK_START struct _WLS_Sub_Event_RTTResults_t {
+	/** complete */
+	t_u8 complete;
+	/** tlv buffer */
+	/** MrvlIEtypes_RTTResult_t */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END WLS_SUB_EVENT_RTTResults_t;
+
+/** TLV for RTT Result */
+#define TLV_TYPE_RTT_RESULT                                                    \
+	(PROPRIETARY_TLV_BASE_ID + 0x127) /* 0x0100 + 0x127 */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTResult_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Peer device MAC address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** burst number in a multi-burst request */
+	t_u32 burst_num;
+	/** Total RTT measurement frames attempted */
+	t_u32 measurement_number;
+	/** Total successful RTT measurement frames */
+	t_u32 success_number;
+	/** Maximum number of "FTM frames per burst" supported by the responder
+	 * STA. */
+	t_u8 number_per_burst_peer;
+	/** ranging status */
+	t_u8 status;
+	/** The time provided by the responder when the request can be tried
+	 * again. */
+	t_u8 retry_after_duration;
+	/** RTT type */
+	t_u8 type;
+	/** average rssi in 0.5 dB steps e.g. 143 implies -71.5 dB */
+	t_s32 rssi;
+	/** rssi spread in 0.5 dB steps e.g. 5 implies 2.5 dB spread (optional)
+	 */
+	t_s32 rssi_spread;
+	/** TX rate */
+	mlan_wifi_rate tx_rate;
+	/** RX rate */
+	mlan_wifi_rate rx_rate;
+	/** round trip time in picoseconds */
+	t_s64 rtt;
+	/** rtt standard deviation in picoseconds */
+	t_s64 rtt_sd;
+	/** difference between max and min rtt times recorded in picoseconds */
+	t_s64 rtt_spread;
+	/** distance in mm (optional) */
+	t_s32 distance_mm;
+	/** standard deviation in mm (optional) */
+	t_s32 distance_sd_mm;
+	/** difference between max and min distance recorded in mm (optional) */
+	t_s32 distance_spread_mm;
+	/** time of the measurement (in microseconds since boot) */
+	t_s64 ts;
+	/** in ms, actual time taken by the FW to finish one burst */
+	t_s32 burst_duration;
+	/** Number of bursts allowed by the responder. */
+	t_s32 negotiated_burst_num;
+	/** tlv buffer */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END MrvlIEtypes_RTTResult_t;
+
+/** TLV for IEEEI IE */
+typedef MLAN_PACK_START struct _MrvlIEtypes_IEEEIE_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** data */
+	t_u8 data[];
+} MLAN_PACK_END MrvlIEtypes_IEEEIE_t;
+
+/** auto link switch network info */
+typedef MLAN_PACK_START struct _Event_WLS_FTM_t {
+	/** Event ID */
+	t_u16 event_id;
+	/** BSS index number for multiple BSS support */
+	t_u8 bss_index;
+	/** BSS type */
+	t_u8 bss_type;
+	/** sub event id */
+	t_u8 sub_event_id;
+	union {
+		/** RTT Results Sub Event */
+		WLS_SUB_EVENT_RTTResults_t rtt_results;
+	} u;
+} MLAN_PACK_END Event_WLS_FTM_t;
+
+typedef MLAN_PACK_START struct _HostCmd_DS_FTM_CONFIG_RESPONDER {
+	/** Action */
+	t_u16 action;
+	/** TLV buffer */
+	/** MrvlIEtypes_RTTResponderInfo_t */
+	/** MrvlIEtypes_RTTResponderEnCfg_t */
+	t_u8 tlv_buffer[];
+} MLAN_PACK_END HostCmd_DS_FTM_CONFIG_RESPONDER;
+
+/** TLV for RTTResponderInfo */
+#define TLV_TYPE_RTT_RESPONDER_INFO                                            \
+	(PROPRIETARY_TLV_BASE_ID + 0x128) /* 0x0100 + 0x128 */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTResponderInfo_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** channel */
+	t_u8 channel;
+	/** bandcfg */
+	Band_Config_t bandcfg;
+	/** bandcfg */
+	t_u8 preamble;
+} MLAN_PACK_END MrvlIEtypes_RTTResponderInfo_t;
+
+/** TLV for RTTResponderEnCfg */
+#define TLV_TYPE_RTT_RESPONDER_EN_CFG                                          \
+	(PROPRIETARY_TLV_BASE_ID + 0x129) /* 0x0100 + 0x129 */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTResponderEnCfg_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** channel */
+	t_u8 channel;
+	/** bandcfg */
+	Band_Config_t bandcfg;
+	/** bandcfg */
+	t_u32 max_duration_seconds;
+} MLAN_PACK_END MrvlIEtypes_RTTResponderEnCfg_t;
+
+/** TLV for RTTLCICfg */
+#define TLV_TYPE_RTT_LCI_CFG                                                   \
+	(PROPRIETARY_TLV_BASE_ID + 0x12A) /* 0x0100 + 0x12A */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTLCICfg_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** latitude */
+	t_u64 latitude;
+	/** longitude */
+	t_u64 longitude;
+	/** altitude */
+	t_u32 altitude;
+	/** latitude_unc */
+	t_u8 latitude_unc;
+	/** longitude_unc */
+	t_u8 longitude_unc;
+	/** altitude_unc */
+	t_u8 altitude_unc;
+	/** motion_pattern */
+	t_u8 motion_pattern;
+	/** floor */
+	t_u32 floor;
+	/** height_above_floor */
+	t_u32 height_above_floor;
+	/** height_unc */
+	t_u32 height_unc;
+} MLAN_PACK_END MrvlIEtypes_RTTLCICfg_t;
+
+/** TLV for RTTLCRCfg */
+#define TLV_TYPE_RTT_LCR_CFG                                                   \
+	(PROPRIETARY_TLV_BASE_ID + 0x12B) /* 0x0100 + 0x12B */
+typedef MLAN_PACK_START struct _MrvlIEtypes_RTTLCRCfg_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** country_code */
+	char country_code[2];
+	/** length of the info field */
+	t_u32 length;
+	/** Civic info to be copied in FTM frame */
+	char civic_info[256];
+} MLAN_PACK_END MrvlIEtypes_RTTLCRCfg_t;
+
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
 #define HostCmd_CMD_CRYPTO 0x025e
 
@@ -7004,6 +8271,16 @@ typedef MLAN_PACK_START struct _HostCmd_DS_CMD_RX_ABORT_CFG {
 	/** rx weak rssi pkt threshold */
 	t_s8 rssi_threshold;
 } MLAN_PACK_END HostCmd_DS_CMD_RX_ABORT_CFG;
+
+/** HostCmd_CMD_OFDM_DESENSE_CFG */
+typedef MLAN_PACK_START struct _HostCmd_DS_CMD_OFDM_DESENSE_CFG {
+	/** Action */
+	t_u16 action;
+	/** Enable/disable cca desense on pkt  */
+	t_u8 enable;
+	/**  cca pkt threshold */
+	t_s8 cca_threshold;
+} MLAN_PACK_END HostCmd_DS_CMD_OFDM_DESENSE_CFG;
 /** HostCmd_CMD_RX_ABORT_CFG_EXT */
 typedef MLAN_PACK_START struct _HostCmd_DS_CMD_RX_ABORT_CFG_EXT {
 	/** Action */
@@ -7014,6 +8291,14 @@ typedef MLAN_PACK_START struct _HostCmd_DS_CMD_RX_ABORT_CFG_EXT {
 	t_s8 rssi_margin;
 	/** specify ceil rssi threshold */
 	t_s8 ceil_rssi_threshold;
+	/** specify floor rssi threshold */
+	t_s8 floor_rssi_threshold;
+	/** current dynamic rssi threshold */
+	t_s8 current_dynamic_rssi_threshold;
+	/** rssi config: default or user configured */
+	t_u8 rssi_default_config;
+	/** EDMAC status */
+	t_u8 edmac_enable;
 } MLAN_PACK_END HostCmd_DS_CMD_RX_ABORT_CFG_EXT;
 
 /** HostCmd_CMD_ARB_CONFIG */
@@ -7223,6 +8508,10 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		HostCmd_DS_802_11_IBSS_STATUS ibss_coalescing;
 		/** Mgmt IE list configuration */
 		HostCmd_DS_MGMT_IE_LIST_CFG mgmt_ie_list;
+		/** TDLS configuration command */
+		HostCmd_DS_TDLS_CONFIG tdls_config_data;
+		/** TDLS operation command */
+		HostCmd_DS_TDLS_OPER tdls_oper_data;
 		/** System clock configuration */
 		HostCmd_DS_ECL_SYSTEM_CLOCK_CONFIG sys_clock_cfg;
 		/** MAC register access */
@@ -7239,6 +8528,8 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		HostCmd_DS_TARGET_ACCESS target;
 		/** BCA register access */
 		HostCmd_DS_BCA_REG_ACCESS bca_reg;
+		/** register access */
+		HostCmd_DS_REG_ACCESS reg;
 		/** Inactivity timeout extend */
 		HostCmd_DS_INACTIVITY_TIMEOUT_EXT inactivity_to;
 #ifdef UAP_SUPPORT
@@ -7263,6 +8554,7 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		HostCmd_DS_SDIO_PULL_CTRL sdio_pull_ctl;
 #endif
 		HostCmd_DS_SET_BSS_MODE bss_mode;
+		HostCmd_DS_802_11_NET_MONITOR net_mon;
 		HostCmd_DS_CMD_TX_DATA_PAUSE tx_data_pause;
 #if defined(PCIE)
 #if defined(PCIE8997) || defined(PCIE8897)
@@ -7274,36 +8566,43 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		HostCmd_DS_WIFI_DIRECT_MODE wifi_direct_mode;
 		HostCmd_DS_WIFI_DIRECT_PARAM_CONFIG p2p_params_config;
 #endif
+		HostCmd_DS_GPIO_TSF_LATCH_PARAM_CONFIG gpio_tsf_latch;
 		HostCmd_DS_COALESCE_CONFIG coalesce_config;
+		HostCmd_DS_FW_AUTO_RECONNECT fw_auto_reconnect_cmd;
 		HostCmd_DS_HS_WAKEUP_REASON hs_wakeup_reason;
 		HostCmd_DS_PACKET_AGGR_CTRL aggr_ctrl;
 #ifdef USB
 		HostCmd_DS_PACKET_AGGR_OVER_HOST_INTERFACE packet_aggr;
 #endif
+		HostCmd_DS_MULTI_CHAN_CFG multi_chan_cfg;
+		HostCmd_DS_MULTI_CHAN_POLICY multi_chan_policy;
+		HostCmd_DS_DRCS_CFG drcs_cfg;
 		HostCmd_CONFIG_LOW_PWR_MODE low_pwr_mode_cfg;
 		HostCmd_DS_TSF tsf;
 		HostCmd_DS_DFS_REPEATER_MODE dfs_repeater;
-#ifdef RX_PACKET_COALESCE
-		HostCmd_DS_RX_PKT_COAL_CFG rx_pkt_coal_cfg;
-#endif
 		HostCmd_DS_EAPOL_PKT eapol_pkt;
 		HostCmd_DS_SENSOR_TEMP temp_sensor;
 		HostCMD_DS_APCMD_ACS_SCAN acs_scan;
 		HostCmd_DS_MIMO_SWITCH mimo_switch;
+		HostCmd_DS_IPV6_RA_OFFLOAD ipv6_ra_offload;
 #ifdef STA_SUPPORT
 		HostCmd_DS_STA_CONFIGURE sta_cfg;
 #endif
 		/** GPIO Independent reset configure */
 		HostCmd_DS_INDEPENDENT_RESET_CFG ind_rst_cfg;
 		HostCmd_DS_802_11_PS_INACTIVITY_TIMEOUT ps_inact_tmo;
+		HostCmd_DS_ROAM_OFFLOAD roam_offload;
 		HostCmd_DS_CHAN_REGION_CFG reg_cfg;
 		HostCmd_DS_AUTO_TX auto_tx;
+		HostCmd_DS_FTM_CONFIG_SESSION_PARAMS ftm_config;
+		HostCmd_DS_FTM_CONFIG_RESPONDER ftm_rtt_responder;
 		HostCmd_DS_DYN_BW dyn_bw;
 		HostCmd_DS_802_11_ROBUSTCOEX robustcoexparams;
 		HostCmd_DS_DMCS_CFG dmcs;
 #if defined(PCIE)
 		HostCmd_DS_SSU_CFG ssu_params;
 #endif
+		HostCmd_DS_CSI_CFG csi_params;
 		/** boot sleep configure */
 		HostCmd_DS_BOOT_SLEEP boot_sleep;
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
@@ -7323,6 +8622,7 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		HostCmd_DS_TWT_CFG twtcfg;
 
 		HostCmd_DS_CMD_RX_ABORT_CFG rx_abort_cfg;
+		HostCmd_DS_CMD_OFDM_DESENSE_CFG ofdm_desense_cfg;
 		HostCmd_DS_CMD_RX_ABORT_CFG_EXT rx_abort_cfg_ext;
 		HostCmd_DS_CMD_TX_AMPDU_PROT_MODE tx_ampdu_prot_mode;
 		HostCmd_DS_CMD_RATE_ADAPT_CFG rate_adapt_cfg;
@@ -7335,8 +8635,16 @@ typedef struct MLAN_PACK_START _HostCmd_DS_COMMAND {
 		struct mfg_cmd_generic_cfg mfg_generic_cfg;
 		struct mfg_cmd_tx_cont mfg_tx_cont;
 		struct mfg_cmd_tx_frame2 mfg_tx_frame2;
+		struct mfg_Cmd_HE_TBTx_t mfg_he_power;
+		mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t mfg_tx_trigger_config;
 		HostCmd_DS_CMD_ARB_CONFIG arb_cfg;
 		HostCmd_DS_CMD_DOT11MC_UNASSOC_FTM_CFG dot11mc_unassoc_ftm_cfg;
+		HostCmd_DS_HAL_PHY_CFG hal_phy_cfg_params;
+		HostCmd_DS_IPS_CONFIG ips_cfg;
+		HostCmd_DS_MC_AGGR_CFG mc_aggr_cfg;
+		HostCmd_DS_STATS stats;
+		HostCmd_DS_GET_CH_LOAD ch_load;
+		HostCmd_DS_CROSS_CHIP_SYNCH cross_chip_synch;
 	} params;
 } MLAN_PACK_END HostCmd_DS_COMMAND, *pHostCmd_DS_COMMAND;
 
@@ -7364,10 +8672,23 @@ typedef struct MLAN_PACK_START _opt_sleep_confirm_buffer {
 	OPT_Confirm_Sleep ps_cfm_sleep;
 } MLAN_PACK_END opt_sleep_confirm_buffer;
 
+typedef MLAN_PACK_START struct _MrvlIEtypes_Secure_Boot_Uuid_t {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+
+	/** Secure boot uuid lower and higher 8 bytes */
+	t_u64 uuid_lo;
+	t_u64 uuid_hi;
+} MLAN_PACK_END MrvlIEtypes_Secure_Boot_Uuid_t;
+
 /** req host side download vdll block */
 #define VDLL_IND_TYPE_REQ 0
 /** notify vdll start offset in firmware image */
 #define VDLL_IND_TYPE_OFFSET 1
+/** notify vdll download error: signature error */
+#define VDLL_IND_TYPE_ERR_SIG 2
+/** notify vdll download error: ID error */
+#define VDLL_IND_TYPE_ERR_ID 3
 
 /** vdll indicate event structure */
 typedef MLAN_PACK_START struct _vdll_ind {
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h
old mode 100644
new mode 100755
index 03b5fd4ff..e0a73ad4a
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ieee.h
@@ -4,7 +4,7 @@
  *  definitions used in MLAN and MOAL module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -48,7 +48,7 @@ typedef enum _WLAN_802_11_NETWORK_TYPE {
 
 #ifdef BIG_ENDIAN_SUPPORT
 /** Frame control: Type Mgmt frame */
-#define IEEE80211_FC_MGMT_FRAME_TYPE_MASK 0x3000
+#define IEEE80211_FC_MGMT_FRAME_TYPE_MASK 0x0c00
 /** Frame control: SubType Mgmt frame */
 #define IEEE80211_GET_FC_MGMT_FRAME_SUBTYPE(fc) (((fc)&0xF000) >> 12)
 #else
@@ -67,7 +67,8 @@ typedef enum _WLAN_802_11_NETWORK_TYPE {
 
 typedef enum _IEEEtypes_Ext_ElementId_e {
 	HE_CAPABILITY = 35,
-	HE_OPERATION = 36
+	HE_OPERATION = 36,
+	HE_6G_CAPABILITY = 59
 } IEEEtypes_Ext_ElementId_e;
 
 /** IEEE Type definitions  */
@@ -89,6 +90,8 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	EXTEND_CHANNEL_SWITCH_ANN = 60,
 	QUIET = 40,
 	IBSS_DFS = 41,
+	MEASUREMENT_REQUEST = 38,
+	MEASUREMENT_REPORT = 39,
 	SUPPORTED_CHANNELS = 36,
 	REGULATORY_CLASS = 59,
 	HT_CAPABILITY = 45,
@@ -100,6 +103,7 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	NONTX_BSSID_CAP = 83,
 	MBSSID_INDEX = 85,
 	EXT_CAPABILITY = 127,
+	LINK_ID = 101,
 	/*IEEE802.11r*/
 	MOBILITY_DOMAIN = 54,
 	FAST_BSS_TRANSITION = 55,
@@ -131,6 +135,7 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	VS_IE = VENDOR_SPECIFIC_221,
 	WAPI_IE = 68,
 	FRAGMENT = 242,
+	RSNX_IE = 244,
 	EXTENSION = 255
 } MLAN_PACK_END IEEEtypes_ElementId_e;
 
@@ -174,6 +179,33 @@ typedef MLAN_PACK_START struct _IEEEtypes_Generic_t {
 	t_u8 data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_Header_t)];
 } MLAN_PACK_END IEEEtypes_Generic_t, *pIEEEtypes_Generic_t;
 
+#define MEASURE_TYPE_CLI 8
+#define MEASURE_TYPE_LOCATION_CIVIC 9
+
+/** Measurement Report IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MeasurementReport_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Measurement Token */
+	t_u8 ms_token;
+	/** Measurement Report Mode */
+	t_u8 ms_rp_mode;
+	/** Measurement Type, value in MEASURE_TYPE_XXX */
+	t_u8 ms_type;
+	/** variable */
+	t_u8 variable[];
+} MLAN_PACK_END IEEEtypes_MeasurementReport_t;
+
+/** Report */
+typedef MLAN_PACK_START struct _IEEEtypes_Report_t {
+	/** Subelement ID */
+	t_u8 subelement_id;
+	/** length */
+	t_u8 length;
+	/** variable */
+	t_u8 variable[];
+} MLAN_PACK_END IEEEtypes_Report_t;
+
 /**ft capability policy*/
 typedef MLAN_PACK_START struct _IEEEtypes_FtCapPolicy_t {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -734,25 +766,27 @@ typedef MLAN_PACK_START struct {
 	t_u8 Schedule : 1;
 	IEEEtypes_WMM_TSPEC_TS_Info_AckPolicy_e AckPolicy : 2;
 	t_u8 UserPri : 3; /* ! 802.1d User Priority */
-	IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
-								    Legacy/Trigg
-								  */
+	// IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /*
+	// !Legacy/Trigg*/
+	t_u8 PowerSaveBehavior : 1;
 	t_u8 Aggregation : 1; /* ! Reserved */
 	t_u8 AccessPolicy2 : 1; /* ! */
 	t_u8 AccessPolicy1 : 1; /* ! */
 	IEEEtypes_WMM_TSPEC_TS_Info_Direction_e Direction : 2;
 	t_u8 TID : 4; /* ! Unique identifier */
-	IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	// IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	t_u8 TrafficType : 1;
 #else
-	IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	// IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	t_u8 TrafficType : 1;
 	t_u8 TID : 4; /* ! Unique identifier */
 	IEEEtypes_WMM_TSPEC_TS_Info_Direction_e Direction : 2;
 	t_u8 AccessPolicy1 : 1; /* ! */
 	t_u8 AccessPolicy2 : 1; /* ! */
 	t_u8 Aggregation : 1; /* ! Reserved */
-	IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
-								    Legacy/Trigg
-								  */
+	// IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
+	// Legacy/Trigg*/
+	t_u8 PowerSaveBehavior : 1;
 	t_u8 UserPri : 3; /* ! 802.1d User Priority */
 	IEEEtypes_WMM_TSPEC_TS_Info_AckPolicy_e AckPolicy : 2;
 	t_u8 Schedule : 1;
@@ -938,6 +972,20 @@ typedef MLAN_PACK_START struct _IEEEtypes_CountryInfoFullSet_t {
 
 #endif /* STA_SUPPORT */
 
+/** Data structure for Link ID */
+typedef MLAN_PACK_START struct _IEEEtypes_LinkIDElement_t {
+	/** Element ID */
+	t_u8 element_id;
+	/** Length */
+	t_u8 len;
+	/** bssid */
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/** initial sta address */
+	t_u8 init_sta[MLAN_MAC_ADDR_LENGTH];
+	/** respose sta address */
+	t_u8 resp_sta[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END IEEEtypes_LinkIDElement_t, *pIEEEtypes_LinkIDElement_t;
+
 /** HT Capabilities Data */
 typedef struct MLAN_PACK_START _HTCap_t {
 	/** HT Capabilities Info field */
@@ -1025,6 +1073,53 @@ typedef MLAN_PACK_START struct _IEEEtypes_HTInfo_t {
 	HTInfo_t ht_info;
 } MLAN_PACK_END IEEEtypes_HTInfo_t, *pIEEEtypes_HTInfo_t;
 
+/** the AP which send the multi_bssid IE */
+#define MULTI_BSSID_AP 1
+/** the AP which don't send beacon */
+#define MULTI_BSSID_SUB_AP 2
+/** IEEEtypes_NotxBssCap_t */
+typedef MLAN_PACK_START struct _IEEEtypes_NotxBssCap_t {
+	/** Nontransmitted BSSID Capability: Element ID */
+	t_u8 element_id;
+	/** Nontransmitted BSSID Capability : Length */
+	t_u8 len;
+	/** capability */
+	t_u16 cap;
+} MLAN_PACK_END IEEEtypes_NotxBssCap_t, *pIEEEtypes_NotxBssCap_t;
+
+/** Multi BSSID IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MultiBSSIDIndex_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** BSSID Index */
+	t_u8 bssid_index;
+	/** DTIM Period (Optional, not Present in ProbeRsp) */
+	t_u8 dtim_period;
+	/** DTIM Count (Optional, not Present in ProbeRsp) */
+	t_u8 dtim_count;
+} MLAN_PACK_END IEEEtypes_MultiBSSIDIndex_t, *pIEEEtypes_MultiBSSIDIndex_t;
+
+/** NonTransmitted BSSID Profile Subelement IE */
+/** SUBID for IEEEtypes_NonTransBSSIDCap_t */
+#define NONTRANS_BSSID_PROFILE_SUBELEM_ID 0
+
+/** NonTransmitted BSSID Capability IE */
+typedef MLAN_PACK_START struct _IEEEtypes_NonTransBSSIDProfile_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	t_u8 profile_data[];
+} MLAN_PACK_END IEEEtypes_NonTransBSSIDProfile_t,
+	*pIEEEtypes_NonTransBSSIDProfile_t;
+
+/** Multi BSSID IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MultiBSSID_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Max BSSID Indicator */
+	t_u8 max_bssid_indicator;
+	/** Optional Subelement data*/
+	t_u8 sub_elem_data[];
+} MLAN_PACK_END IEEEtypes_MultiBSSID_t, *pIEEEtypes_MultiBSSID_t;
 /** 20/40 BSS Coexistence IE */
 typedef MLAN_PACK_START struct _IEEEtypes_2040BSSCo_t {
 	/** Generic IE header */
@@ -1207,6 +1302,51 @@ typedef MLAN_PACK_START struct _IEEEtypes_Extension_t {
 	t_u8 data[];
 } MLAN_PACK_END IEEEtypes_Extension_t, *pIEEEtypes_Extension_t;
 
+typedef MLAN_PACK_START struct _IEEEtypes_HeMcsMap_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Max HE-MAC for 8 SS */
+	t_u8 max_mcs_8ss : 2;
+	/** Max HE-MAC for 7 SS */
+	t_u8 max_mcs_7ss : 2;
+	/** Max HE-MAC for 6 SS */
+	t_u8 max_mcs_6ss : 2;
+	/** Max HE-MAC for 5 SS */
+	t_u8 max_mcs_5ss : 2;
+	/** Max HE-MAC for 4 SS */
+	t_u8 max_mcs_4ss : 2;
+	/** Max HE-MAC for 3 SS */
+	t_u8 max_mcs_3ss : 2;
+	/** Max HE-MAC for 2 SS */
+	t_u8 max_mcs_2ss : 2;
+	/** Max HE-MAC for 1 SS */
+	t_u8 max_mcs_1ss : 2;
+#else
+	/** Max HE-MAC for 1 SS */
+	t_u8 max_mcs_1ss : 2;
+	/** Max HE-MAC for 2 SS */
+	t_u8 max_mcs_2ss : 2;
+	/** Max HE-MAC for 3 SS */
+	t_u8 max_mcs_3ss : 2;
+	/** Max HE-MAC for 4 SS */
+	t_u8 max_mcs_4ss : 2;
+	/** Max HE-MAC for 5 SS */
+	t_u8 max_mcs_5ss : 2;
+	/** Max HE-MAC for 6 SS */
+	t_u8 max_mcs_6ss : 2;
+	/** Max HE-MAC for 7 SS */
+	t_u8 max_mcs_7ss : 2;
+	/** Max HE-MAC for 8 SS */
+	t_u8 max_mcs_8ss : 2;
+#endif
+} MLAN_PACK_END IEEEtypes_HeMcsMap_t, *pIEEEtypes_HeMcsMap_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeMcsNss_t {
+	/** HE Rx MCS and NSS Set */
+	t_u16 rx_mcs;
+	/** HE Tx MCS and NSS Set*/
+	t_u16 tx_mcs;
+} MLAN_PACK_END IEEEtypes_HeMcsNss_t, *pIEEEtypes_HeMcsNss_t;
+
 typedef MLAN_PACK_START struct _IEEEtypes_HECap_t {
 	/** Generic IE header */
 	IEEEtypes_Header_t ieee_hdr;
@@ -1216,14 +1356,121 @@ typedef MLAN_PACK_START struct _IEEEtypes_HECap_t {
 	t_u8 he_mac_cap[6];
 	/** he phy capability info */
 	t_u8 he_phy_cap[11];
-	/** he txrx mcs support , size would be 4 or 8 or 12 */
+	/** he txrx mcs support (for 80 MHz) */
 	t_u8 he_txrx_mcs_support[4];
-	/** PPE Thresholds (optional) */
+	/** Optional Field, including he_txrx_mcs_support for 160 and 80+80 MHz,
+	 * and PPE Thresholds */
+	t_u8 option[28];
 } MLAN_PACK_END IEEEtypes_HECap_t, *pIEEEtypes_HECap_t;
 
-/** Maximum number of subbands in the IEEEtypes_SupportedChannels_t structure */
-#define WLAN_11H_MAX_SUBBANDS 5
+typedef MLAN_PACK_START struct _IEEEtypes_HeOpParam_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Reserved, including 6G Operation Info Pressent (bit17) */
+	t_u8 reserved : 6; /* bit 18-23 */
+	/* 6g operation info present */
+	t_u8 he_6g_op_info_present : 1; /* bit 17 */
+	/** ER SU Disable */
+	t_u8 er_su_disable : 1; /* bit 16 */
+	/** Co-Hosted BSS */
+	t_u16 co_located_bss : 1; /* bit 15 */
+	/** VHT Operation Info Present */
+	t_u16 vht_op_info_present : 1; /* bit 14 */
+	/** TXOP Duration RTS Threshold */
+	t_u16 txop_dur_rts_threshold : 10; /* bit 4-13 */
+	/** TWT Required */
+	t_u16 twt_req : 1; /* bit 3 */
+	/** Default PE Duration */
+	t_u16 default_pe_dur : 3; /* bit 0-2 */
+#else
+	/** Default PE Duration */
+	t_u16 default_pe_dur : 3; /* bit 0-2 */
+	/** TWT Required */
+	t_u16 twt_req : 1; /* bit 3 */
+	/** TXOP Duration RTS Threshold */
+	t_u16 txop_dur_rts_threshold : 10; /* bit 4-13 */
+	/** VHT Operation Info Present */
+	t_u16 vht_op_info_present : 1; /* bit 14 */
+	/** Co-Hosted BSS */
+	t_u16 co_located_bss : 1; /* bit 15 */
+	/** ER SU Disable */
+	t_u8 er_su_disable : 1; /* bit 16 */
+	/* 6g operation info present */
+	t_u8 he_6g_op_info_present : 1; /* bit 17 */
+	/** Reserved bit 18-23 */
+	t_u8 reserved : 6; /* bit 18-23 */
+#endif
+} MLAN_PACK_END IEEEtypes_HeOpParam_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeBssColorInfo_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** BSS Color Disabled */
+	t_u8 bss_color_disabled : 1; /* bit 7 */
+	/** Partial BSS Color */
+	t_u8 partial_bss_color : 1; /* bit 6 */
+	/** BSS Color */
+	t_u8 bss_color : 6; /* bit 0-5 */
+#else
+	/** BSS Color */
+	t_u8 bss_color : 6; /* bit 0-5 */
+	/** Partial BSS Color */
+	t_u8 partial_bss_color : 1; /* bit 6 */
+	/** BSS Color Disabled */
+	t_u8 bss_color_disabled : 1; /* bit 7 */
+#endif
+} MLAN_PACK_END IEEEtypes_HeBssColorInfo_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeOp_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Element id extension */
+	t_u8 ext_id;
+	/** HE Operation Parameters */
+	IEEEtypes_HeOpParam_t he_op_param;
+	/** BSS Color Info */
+	IEEEtypes_HeBssColorInfo_t bss_color_info;
+	/** Basic HE-MCS and NSS Set */
+	IEEEtypes_HeMcsMap_t basic_he_mcs_nss;
+	/** Optional Field, including VHT Operation Info Max Co-Hosted BSSID
+	 * Indicator, and 6Ghz Operation Info  */
+	t_u8 option[9];
+} MLAN_PACK_END IEEEtypes_HeOp_t;
+
+/** default channel switch count */
+#define DEF_CHAN_SWITCH_COUNT 5
+
+/*  IEEE Channel Switch Announcement Element (7.3.2.20) */
+/**
+ *  Provided in beacons and probe responses.  Used to advertise when
+ *    and to which channel it is changing to.  Only starting STAs in
+ *    an IBSS and APs are allowed to originate a chan switch element.
+ */
+typedef MLAN_PACK_START struct {
+	t_u8 element_id; /**< IEEE Element ID = 37 */
+	t_u8 len; /**< Element length after id and len */
+	t_u8 chan_switch_mode; /**< STA should not transmit any frames if 1 */
+	t_u8 new_channel_num; /**< Channel # that AP/IBSS is moving to */
+	t_u8 chan_switch_count; /**< # of TBTTs before channel switch */
+
+} MLAN_PACK_END IEEEtypes_ChanSwitchAnn_t;
+
+/** data structure for extended channel switch */
+typedef MLAN_PACK_START struct {
+	/** IEEE element ID = 60 */
+	t_u8 element_id;
+	/** Element length after id and len, set to 4 */
+	t_u8 len;
+	/** STA should not transmit any frames if 1 */
+	t_u8 chan_switch_mode;
+	/** Operate class # that AP/IBSS is moving to */
+	t_u8 new_oper_class;
+	/** Channel # that AP/IBSS is moving to */
+	t_u8 new_channel_num;
+	/** of TBTTs before channel switch */
+	t_u8 chan_switch_count;
+} MLAN_PACK_END IEEEtypes_ExtChanSwitchAnn_t;
 
+/** Maximum number of subbands in the IEEEtypes_SupportedChannels_t structure */
+#define WLAN_11H_MAX_SUBBANDS 6
 /** Maximum number of DFS channels configured in IEEEtypes_IBSS_DFS_t */
 #define WLAN_11H_MAX_IBSS_DFS_CHANNELS 25
 
@@ -1276,40 +1523,6 @@ typedef MLAN_PACK_START struct {
 
 } MLAN_PACK_END IEEEtypes_SupportedChannels_t;
 
-/** default channel switch count */
-#define DEF_CHAN_SWITCH_COUNT 5
-
-/*  IEEE Channel Switch Announcement Element (7.3.2.20) */
-/**
- *  Provided in beacons and probe responses.  Used to advertise when
- *    and to which channel it is changing to.  Only starting STAs in
- *    an IBSS and APs are allowed to originate a chan switch element.
- */
-typedef MLAN_PACK_START struct {
-	t_u8 element_id; /**< IEEE Element ID = 37 */
-	t_u8 len; /**< Element length after id and len */
-	t_u8 chan_switch_mode; /**< STA should not transmit any frames if 1 */
-	t_u8 new_channel_num; /**< Channel # that AP/IBSS is moving to */
-	t_u8 chan_switch_count; /**< # of TBTTs before channel switch */
-
-} MLAN_PACK_END IEEEtypes_ChanSwitchAnn_t;
-
-/** data structure for extended channel switch */
-typedef MLAN_PACK_START struct {
-	/** IEEE element ID = 60 */
-	t_u8 element_id;
-	/** Element length after id and len, set to 4 */
-	t_u8 len;
-	/** STA should not transmit any frames if 1 */
-	t_u8 chan_switch_mode;
-	/** Operate class # that AP/IBSS is moving to */
-	t_u8 new_oper_class;
-	/** Channel # that AP/IBSS is moving to */
-	t_u8 new_channel_num;
-	/** of TBTTs before channel switch */
-	t_u8 chan_switch_count;
-} MLAN_PACK_END IEEEtypes_ExtChanSwitchAnn_t;
-
 /*  IEEE Wide Bandwidth Channel Switch Element */
 /**
  *  Provided in beacons and probe responses.  Used to advertise when
@@ -1338,6 +1551,8 @@ typedef MLAN_PACK_START struct {
 	t_u8 local_max_tp_20mhz; /**< Local Maximum Transmit Power for 20 MHZ>*/
 	t_u8 local_max_tp_40mhz; /**< Local Maximum Transmit Power for 40 MHZ>*/
 	t_u8 local_max_tp_80mhz; /**< Local Maximum Transmit Power for 80 MHZ>*/
+	t_u8 local_max_tp_160mhz_80_80mhz; /**< Local Maximum Transmit Power for
+					      160/80+80 MHZ>*/
 } MLAN_PACK_END IEEEtypes_VhtTpcEnvelope_t;
 
 /*  IEEE Quiet Period Element (7.3.2.23) */
@@ -1444,6 +1659,50 @@ typedef struct {
 
 } wlan_11h_bss_info_t;
 
+/** Ethernet packet type for TDLS */
+#define MLAN_ETHER_PKT_TYPE_TDLS_ACTION (0x890D)
+
+/*802.11z  TDLS action frame type and strcuct */
+typedef MLAN_PACK_START struct {
+	/*link indentifier ie =101*/
+	t_u8 element_id;
+	/*len = 18*/
+	t_u8 len;
+	/** bssid */
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/** init sta mac address */
+	t_u8 init_sta[MLAN_MAC_ADDR_LENGTH];
+	/** resp sta mac address */
+	t_u8 resp_sta[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END IEEEtypes_tdls_linkie;
+
+/** action code for tdls setup request */
+#define TDLS_SETUP_REQUEST 0
+/** action code for tdls setup response */
+#define TDLS_SETUP_RESPONSE 1
+/** action code for tdls setup confirm */
+#define TDLS_SETUP_CONFIRM 2
+/** action code for tdls tear down */
+#define TDLS_TEARDOWN 3
+/** action code for tdls traffic indication */
+#define TDLS_PEER_TRAFFIC_INDICATION 4
+/** action code for tdls channel switch request */
+#define TDLS_CHANNEL_SWITCH_REQUEST 5
+/** action code for tdls channel switch response */
+#define TDLS_CHANNEL_SWITCH_RESPONSE 6
+/** action code for tdls psm request */
+#define TDLS_PEER_PSM_REQUEST 7
+/** action code for tdls psm response */
+#define TDLS_PEER_PSM_RESPONSE 8
+/** action code for tdls traffic response */
+#define TDLS_PEER_TRAFFIC_RESPONSE 9
+/** action code for tdls discovery request */
+#define TDLS_DISCOVERY_REQUEST 10
+/** action code for TDLS discovery response */
+#define TDLS_DISCOVERY_RESPONSE 14
+/** category public */
+#define CATEGORY_PUBLIC 4
+
 /** action code for 20/40 BSS Coexsitence Management frame */
 #define BSS_20_40_COEX 0
 
@@ -1488,8 +1747,8 @@ typedef MLAN_PACK_START struct _wlan_user_scan_chan {
 	t_u8 radio_type;
 	/** Scan type: Active = 1, Passive = 2 */
 	t_u8 scan_type;
-	/** Reserved */
-	t_u8 reserved;
+	/** rnr_flag */
+	t_u8 rnr_flag;
 	/** Scan duration in milliseconds; if 0 default used */
 	t_u32 scan_time;
 } MLAN_PACK_END wlan_user_scan_chan;
@@ -1581,6 +1840,8 @@ typedef MLAN_PACK_START struct {
 	t_u8 bssid_num;
 	/** BSSID filter list used in the to limit the scan results */
 	mlan_802_11_mac_addr bssid_list[MAX_BSSID_FILTER_LIST];
+	/** use scan setting from scan_cfg only  */
+	t_u8 scan_cfg_only;
 } MLAN_PACK_END wlan_user_scan_cfg;
 
 /** Default scan interval in millisecond*/
@@ -1602,9 +1863,15 @@ typedef MLAN_PACK_START struct {
 #define BG_SCAN_SSID_RSSI_MATCH 0x0004
 /**wait for all channel scan to complete to report scan result*/
 #define BG_SCAN_WAIT_ALL_CHAN_DONE 0x80000000
-/** Maximum number of channels that can be sent in bg scan config */
+
+#define CHAN_MAX_6G 0
+
+/** max bgscan chan number */
 #define WLAN_BG_SCAN_CHAN_MAX 38
 
+/** max bgscan chan number, include UNII_4 channel */
+#define WLAN_BG_SCAN_CHAN_MAX_UNII_4 41
+
 /** Enumeration definition */
 /** EES MODE */
 typedef enum {
@@ -1671,7 +1938,7 @@ typedef MLAN_PACK_START struct {
 	/** SSID filter list used in the to limit the scan results */
 	wlan_user_scan_ssid ssid_list[MRVDRV_MAX_SSID_LIST_LENGTH];
 	/** Variable number (fixed maximum) of channels to scan up */
-	wlan_user_scan_chan chan_list[WLAN_BG_SCAN_CHAN_MAX];
+	wlan_user_scan_chan chan_list[WLAN_USER_SCAN_CHAN_MAX];
 	/** scan channel gap */
 	t_u16 scan_chan_gap;
 	/** Enable EES configuration */
@@ -1704,6 +1971,11 @@ typedef MLAN_PACK_START struct {
 } MLAN_PACK_END wlan_bgscan_cfg;
 #endif /* STA_SUPPORT */
 
+/** The open AP in OWE transmition Mode */
+#define OWE_TRANS_MODE_OPEN 1
+/** The security AP in OWE trsnsition Mode */
+#define OWE_TRANS_MODE_OWE 2
+
 #ifdef PRAGMA_PACK
 #pragma pack(pop)
 #endif
@@ -1718,6 +1990,15 @@ typedef struct _BSSDescriptor_t {
 	/** SSID */
 	mlan_802_11_ssid ssid;
 
+	/** Transition MAC address */
+	mlan_802_11_mac_addr trans_mac_address;
+
+	/** Transition SSID */
+	mlan_802_11_ssid trans_ssid;
+
+	/** OWE Transition mode */
+	t_u8 owe_transition_mode;
+
 	/** WEP encryption requirement */
 	t_u32 privacy;
 
@@ -1799,6 +2080,10 @@ typedef struct _BSSDescriptor_t {
 	IEEEtypes_HTInfo_t *pht_info;
 	/** HT Information Offset */
 	t_u16 ht_info_offset;
+	/** Flag to indicate this is multi_bssid_ap */
+	t_u8 multi_bssid_ap;
+	/** the mac address of multi-bssid AP */
+	mlan_802_11_mac_addr multi_bssid_ap_addr;
 	/** 20/40 BSS Coexistence IE */
 	IEEEtypes_2040BSSCo_t *pbss_co_2040;
 	/** 20/40 BSS Coexistence Offset */
@@ -1861,6 +2146,10 @@ typedef struct _BSSDescriptor_t {
 	IEEEtypes_Generic_t *prsn_ie;
 	/** RSN IE offset in the beacon buffer */
 	t_u16 rsn_offset;
+	/** RSNX IE */
+	IEEEtypes_Generic_t *prsnx_ie;
+	/** RSNX IE offset in the beacon buffer */
+	t_u16 rsnx_offset;
 #ifdef STA_SUPPORT
 	/** WAPI IE */
 	IEEEtypes_Generic_t *pwapi_ie;
@@ -1882,7 +2171,8 @@ typedef struct _BSSDescriptor_t {
 	t_u32 beacon_buf_size;
 	/** Max allocated size for updated scan response */
 	t_u32 beacon_buf_size_max;
-
+	/** scan age in secs */
+	t_u32 age_in_secs;
 } BSSDescriptor_t, *pBSSDescriptor_t;
 
 #endif /* !_MLAN_IEEE_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c
old mode 100644
new mode 100755
index e81299d69..ebd48c381
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.c
@@ -4,7 +4,7 @@
  *  and HW.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -53,7 +53,7 @@ Change log:
 /********************************************************
 			Global Variables
 ********************************************************/
-extern pmlan_operations mlan_ops[];
+
 /*******************************************************
 			Local Functions
 ********************************************************/
@@ -240,9 +240,10 @@ mlan_status wlan_allocate_adapter(pmlan_adapter pmadapter)
 	t_u32 buf_size;
 	BSSDescriptor_t *ptemp_scan_table = MNULL;
 	t_u8 chan_2g[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
-	t_u8 chan_5g[] = {12,  16,  34,	 38,  42,  46,	36,  40,  44,  48,  52,
-			  56,  60,  64,	 100, 104, 108, 112, 116, 120, 124, 128,
-			  132, 136, 140, 144, 149, 153, 157, 161, 165};
+	t_u8 chan_5g[] = {12,  16,  34,	 38,  42,  46,	36,  40,  44,
+			  48,  52,  56,	 60,  64,  100, 104, 108, 112,
+			  116, 120, 124, 128, 132, 136, 140, 144, 149,
+			  153, 157, 161, 165, 169, 173, 177};
 #endif
 #ifdef SDIO
 	t_u32 max_mp_regs = 0;
@@ -255,8 +256,8 @@ mlan_status wlan_allocate_adapter(pmlan_adapter pmadapter)
 #ifdef SDIO
 	if (IS_SD(pmadapter->card_type)) {
 		max_mp_regs = pmadapter->pcard_sd->reg->max_mp_regs;
-		mp_tx_aggr_buf_size = SDIO_MP_AGGR_BUF_SIZE_MAX;
-		mp_rx_aggr_buf_size = SDIO_MP_AGGR_BUF_SIZE_MAX;
+		mp_tx_aggr_buf_size = pmadapter->pcard_sd->mp_tx_aggr_buf_size;
+		mp_rx_aggr_buf_size = pmadapter->pcard_sd->mp_rx_aggr_buf_size;
 	}
 #endif
 
@@ -283,9 +284,15 @@ mlan_status wlan_allocate_adapter(pmlan_adapter pmadapter)
 		beacon_buffer_size = MAX_SCAN_BEACON_BUFFER;
 	else
 		beacon_buffer_size = DEFAULT_SCAN_BEACON_BUFFER;
-	ret = pmadapter->callbacks.moal_malloc(pmadapter->pmoal_handle,
-					       beacon_buffer_size, MLAN_MEM_DEF,
-					       (t_u8 **)&pmadapter->bcn_buf);
+	if (pmadapter->callbacks.moal_vmalloc &&
+	    pmadapter->callbacks.moal_vfree)
+		ret = pmadapter->callbacks.moal_vmalloc(
+			pmadapter->pmoal_handle, beacon_buffer_size,
+			(t_u8 **)&pmadapter->bcn_buf);
+	else
+		ret = pmadapter->callbacks.moal_malloc(
+			pmadapter->pmoal_handle, beacon_buffer_size,
+			MLAN_MEM_DEF, (t_u8 **)&pmadapter->bcn_buf);
 	if (ret != MLAN_STATUS_SUCCESS || !pmadapter->bcn_buf) {
 		PRINTM(MERROR, "Failed to allocate bcn buf\n");
 		LEAVE();
@@ -310,6 +317,20 @@ mlan_status wlan_allocate_adapter(pmlan_adapter pmadapter)
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
+	if (pmadapter->callbacks.moal_vmalloc &&
+	    pmadapter->callbacks.moal_vfree)
+		ret = pmadapter->callbacks.moal_vmalloc(
+			pmadapter->pmoal_handle, buf_size,
+			(t_u8 **)&pmadapter->pold_chan_stats);
+	else
+		ret = pmadapter->callbacks.moal_malloc(
+			pmadapter->pmoal_handle, buf_size, MLAN_MEM_DEF,
+			(t_u8 **)&pmadapter->pold_chan_stats);
+	if (ret != MLAN_STATUS_SUCCESS || !pmadapter->pold_chan_stats) {
+		PRINTM(MERROR, "Failed to allocate old channel statistics\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 #endif
 
 	/* Allocate command buffer */
@@ -362,7 +383,8 @@ mlan_status wlan_allocate_adapter(pmlan_adapter pmadapter)
 #ifdef DEBUG_LEVEL1
 		if (mlan_drvdbg & MMPA_D) {
 			pmadapter->pcard_sd->mpa_buf_size =
-				SDIO_MP_DBG_NUM * SDIO_MP_AGGR_DEF_PKT_LIMIT *
+				SDIO_MP_DBG_NUM *
+				pmadapter->pcard_sd->mp_aggr_pkt_limit *
 				MLAN_SDIO_BLOCK_SIZE;
 			if (pmadapter->callbacks.moal_vmalloc &&
 			    pmadapter->callbacks.moal_vfree)
@@ -467,6 +489,9 @@ mlan_status wlan_init_priv(pmlan_private priv)
 	wlan_11h_priv_init(priv);
 
 #ifdef UAP_SUPPORT
+	priv->is_11n_enabled = MFALSE;
+	priv->is_11ac_enabled = MFALSE;
+	priv->is_11ax_enabled = MFALSE;
 	priv->uap_bss_started = MFALSE;
 	priv->uap_host_based = MFALSE;
 	memset(pmadapter, &priv->uap_state_chan_cb, 0,
@@ -509,10 +534,13 @@ mlan_status wlan_init_priv(pmlan_private priv)
 #if defined(STA_SUPPORT)
 	priv->pmfcfg.mfpc = 0;
 	priv->pmfcfg.mfpr = 0;
+	memset(pmadapter, &priv->pmfcfg, 0, sizeof(priv->pmfcfg));
 #endif
 	priv->sec_info.wapi_enabled = MFALSE;
 	priv->wapi_ie_len = 0;
 	priv->sec_info.wapi_key_on = MFALSE;
+	priv->osen_ie_len = 0;
+	memset(pmadapter, &priv->osen_ie, 0, sizeof(priv->osen_ie));
 
 	memset(pmadapter, &priv->wps, 0, sizeof(priv->wps));
 	memset(pmadapter, &priv->gen_ie_buf, 0, sizeof(priv->gen_ie_buf));
@@ -520,19 +548,39 @@ mlan_status wlan_init_priv(pmlan_private priv)
 #endif /* STA_SUPPORT */
 	priv->wmm_required = MTRUE;
 	priv->wmm_enabled = MFALSE;
+	priv->disconnect_reason_code = 0;
 	priv->wmm_qosinfo = 0;
+	priv->saved_wmm_qosinfo = 0;
+	priv->host_tdls_cs_support = MTRUE;
+	priv->host_tdls_uapsd_support = MTRUE;
+	priv->tdls_cs_channel = 0;
+	priv->supp_regulatory_class_len = 0;
+	priv->chan_supp_len = 0;
+	memset(pmadapter, &priv->chan_supp, 0, sizeof(priv->chan_supp));
+	memset(pmadapter, &priv->supp_regulatory_class, 0,
+	       sizeof(priv->supp_regulatory_class));
+	priv->tdls_idle_time = TDLS_IDLE_TIMEOUT;
+	priv->txaggrctrl = MTRUE;
+	for (i = 0; i < MAX_MGMT_IE_INDEX; i++)
+		memset(pmadapter, &priv->mgmt_ie[i], 0, sizeof(custom_ie));
+	priv->mgmt_frame_passthru_mask = 0;
 #ifdef STA_SUPPORT
 	priv->pcurr_bcn_buf = MNULL;
 	priv->curr_bcn_size = 0;
 	memset(pmadapter, &priv->ext_cap, 0, sizeof(priv->ext_cap));
 
 	SET_EXTCAP_OPERMODENTF(priv->ext_cap);
+	SET_EXTCAP_TDLS(priv->ext_cap);
 	SET_EXTCAP_QOS_MAP(priv->ext_cap);
 	/* Save default Extended Capability */
 	memcpy_ext(priv->adapter, &priv->def_ext_cap, &priv->ext_cap,
 		   sizeof(priv->ext_cap), sizeof(priv->def_ext_cap));
 #endif /* STA_SUPPORT */
 
+	priv->amsdu_rx_cnt = 0;
+	priv->msdu_in_rx_amsdu_cnt = 0;
+	priv->amsdu_tx_cnt = 0;
+	priv->msdu_in_tx_amsdu_cnt = 0;
 	for (i = 0; i < MAX_NUM_TID; i++)
 		priv->addba_reject[i] = ADDBA_RSP_STATUS_ACCEPT;
 	priv->addba_reject[6] = ADDBA_RSP_STATUS_REJECT;
@@ -562,11 +610,16 @@ mlan_status wlan_init_priv(pmlan_private priv)
 	}
 #endif
 	priv->user_rxwinsize = priv->add_ba_param.rx_win_size;
-
+	memset(pmadapter, priv->rx_seq, 0, sizeof(priv->rx_seq));
 	priv->port_ctrl_mode = MTRUE;
 	priv->port_open = MFALSE;
+	priv->prior_port_status = MFALSE;
+	priv->tx_pause = MFALSE;
+	priv->hotspot_cfg = 0;
 
 	priv->intf_hr_len = pmadapter->ops.intf_header_len;
+	priv->multi_ap_flag = 0;
+	memset(pmadapter, &priv->chan_rep_req, 0, sizeof(priv->chan_rep_req));
 #ifdef USB
 	if (IS_USB(pmadapter->card_type)) {
 		pusb_tx_aggr =
@@ -576,6 +629,7 @@ mlan_status wlan_init_priv(pmlan_private priv)
 			priv->intf_hr_len = MLAN_USB_TX_AGGR_HEADER;
 		}
 		priv->port = pmadapter->tx_data_ep;
+		priv->port_index = 0;
 	}
 #endif
 	ret = wlan_add_bsspriotbl(priv);
@@ -618,7 +672,17 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 #ifdef STA_SUPPORT
 	pmadapter->pwarm_reset_ioctl_req = MNULL;
 #endif
+	pmadapter->pscan_ioctl_req = MNULL;
 	pmadapter->cmd_sent = MFALSE;
+	pmadapter->mlan_processing = MFALSE;
+	pmadapter->main_process_cnt = 0;
+	pmadapter->mlan_rx_processing = MFALSE;
+	pmadapter->more_rx_task_flag = MFALSE;
+	pmadapter->more_task_flag = MFALSE;
+	pmadapter->delay_task_flag = MFALSE;
+	pmadapter->data_sent = MFALSE;
+	pmadapter->data_sent_cnt = 0;
+
 #ifdef SDIO
 	if (IS_SD(pmadapter->card_type)) {
 		pmadapter->pcard_sd->int_mode = pmadapter->init_para.int_mode;
@@ -626,8 +690,10 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 		pmadapter->data_sent = MTRUE;
 		pmadapter->pcard_sd->mp_rd_bitmap = 0;
 		pmadapter->pcard_sd->mp_wr_bitmap = 0;
-		pmadapter->pcard_sd->curr_rd_port = 0;
-		pmadapter->pcard_sd->curr_wr_port = 0;
+		pmadapter->pcard_sd->curr_rd_port =
+			pmadapter->pcard_sd->reg->start_rd_port;
+		pmadapter->pcard_sd->curr_wr_port =
+			pmadapter->pcard_sd->reg->start_wr_port;
 		pmadapter->pcard_sd->mp_data_port_mask =
 			pmadapter->pcard_sd->reg->data_port_mask;
 		pmadapter->pcard_sd->mp_invalid_update = 0;
@@ -635,7 +701,8 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 		       sizeof(pmadapter->pcard_sd->mp_update));
 		pmadapter->pcard_sd->mpa_tx.buf_len = 0;
 		pmadapter->pcard_sd->mpa_tx.pkt_cnt = 0;
-		pmadapter->pcard_sd->mpa_tx.start_port = 0;
+		pmadapter->pcard_sd->mpa_tx.start_port =
+			pmadapter->pcard_sd->reg->start_wr_port;
 
 		if (!pmadapter->init_para.mpa_tx_cfg)
 			pmadapter->pcard_sd->mpa_tx.enabled = MFALSE;
@@ -645,11 +712,12 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 		else
 			pmadapter->pcard_sd->mpa_tx.enabled = MTRUE;
 		pmadapter->pcard_sd->mpa_tx.pkt_aggr_limit =
-			SDIO_MP_AGGR_DEF_PKT_LIMIT;
+			pmadapter->pcard_sd->mp_aggr_pkt_limit;
 
 		pmadapter->pcard_sd->mpa_rx.buf_len = 0;
 		pmadapter->pcard_sd->mpa_rx.pkt_cnt = 0;
-		pmadapter->pcard_sd->mpa_rx.start_port = 0;
+		pmadapter->pcard_sd->mpa_rx.start_port =
+			pmadapter->pcard_sd->reg->start_rd_port;
 
 		if (!pmadapter->init_para.mpa_rx_cfg)
 			pmadapter->pcard_sd->mpa_rx.enabled = MFALSE;
@@ -659,7 +727,7 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 		else
 			pmadapter->pcard_sd->mpa_rx.enabled = MTRUE;
 		pmadapter->pcard_sd->mpa_rx.pkt_aggr_limit =
-			SDIO_MP_AGGR_DEF_PKT_LIMIT;
+			pmadapter->pcard_sd->mp_aggr_pkt_limit;
 	}
 #endif
 
@@ -667,13 +735,22 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 	pmadapter->cmd_resp_received = MFALSE;
 	pmadapter->event_received = MFALSE;
 	pmadapter->data_received = MFALSE;
-
+	pmadapter->seq_num = 0;
+	pmadapter->num_cmd_timeout = 0;
+	pmadapter->last_init_cmd = 0;
+	pmadapter->pending_ioctl = MFALSE;
+	pmadapter->scan_processing = MFALSE;
+	pmadapter->fw_roaming = MFALSE;
+	pmadapter->userset_passphrase = MFALSE;
 	pmadapter->cmd_timer_is_set = MFALSE;
+	pmadapter->dnld_cmd_in_secs = 0;
 
 	/* PnP and power profile */
 	pmadapter->surprise_removed = MFALSE;
 	/* FW hang report */
 	pmadapter->fw_hang_report = MFALSE;
+	pmadapter->ecsa_enable = MFALSE;
+	pmadapter->getlog_enable = MFALSE;
 
 	if (!pmadapter->init_para.ps_mode) {
 		pmadapter->ps_mode = DEFAULT_PS_MODE;
@@ -707,7 +784,14 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 	memset(pmadapter, pmadapter->pscan_table, 0,
 	       (sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST));
 	pmadapter->active_scan_triggered = MFALSE;
-	pmadapter->ext_scan = MTRUE;
+	if (!pmadapter->init_para.ext_scan)
+		pmadapter->ext_scan = EXT_SCAN_TYPE_ENH;
+	else if (pmadapter->init_para.ext_scan == EXT_SCAN_TYPE_ENH)
+		pmadapter->ext_scan = EXT_SCAN_TYPE_ENH;
+	else
+		pmadapter->ext_scan = MTRUE;
+	pmadapter->ext_scan_enh = MFALSE;
+	pmadapter->ext_scan_timeout = MFALSE;
 	pmadapter->scan_probes = DEFAULT_PROBES;
 
 	memset(pmadapter, pmadapter->bcn_buf, 0, pmadapter->bcn_buf_size);
@@ -742,6 +826,7 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 	pmadapter->pm_wakeup_card_req = MFALSE;
 
 	pmadapter->pm_wakeup_fw_try = MFALSE;
+	pmadapter->pm_wakeup_timeout = 0;
 
 	if (!pmadapter->init_para.max_tx_buf)
 		pmadapter->max_tx_buf_size =
@@ -754,6 +839,9 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 
 #ifdef USB
 	if (IS_USB(pmadapter->card_type)) {
+		for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
+			pmadapter->pcard_usb->usb_port_status[i] = MFALSE;
+		}
 		for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
 			pmadapter->pcard_usb->usb_tx_aggr[i].aggr_ctrl.enable =
 				MFALSE;
@@ -773,7 +861,7 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 			pmadapter->pcard_usb->usb_tx_aggr[i].hold_timeout_msec =
 				MLAN_USB_TX_AGGR_TIMEOUT_MSEC;
 			pmadapter->pcard_usb->usb_tx_aggr[i].port =
-				pmadapter->tx_data_ep;
+				pmadapter->usb_tx_ports[i];
 			pmadapter->pcard_usb->usb_tx_aggr[i].phandle =
 				(t_void *)pmadapter;
 		}
@@ -807,6 +895,7 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 	pmadapter->coex_rx_winsize = 1;
 #ifdef STA_SUPPORT
 	pmadapter->chan_bandwidth = 0;
+	pmadapter->tdls_status = TDLS_NOT_SETUP;
 #endif /* STA_SUPPORT */
 
 	pmadapter->min_ba_threshold = MIN_BA_THRESHOLD;
@@ -847,7 +936,11 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 	       sizeof(pmadapter->sleep_params));
 	memset(pmadapter, &pmadapter->sleep_period, 0,
 	       sizeof(pmadapter->sleep_period));
+	memset(pmadapter, &pmadapter->saved_sleep_period, 0,
+	       sizeof(pmadapter->saved_sleep_period));
 	pmadapter->tx_lock_flag = MFALSE;
+	pmadapter->rx_lock_flag = MFALSE;
+	pmadapter->main_lock_flag = MFALSE;
 	pmadapter->null_pkt_interval = 0;
 	pmadapter->fw_bands = 0;
 	pmadapter->config_bands = 0;
@@ -866,6 +959,13 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 		   MRVDRV_DEFAULT_COUNTRY_CODE, COUNTRY_CODE_LEN,
 		   COUNTRY_CODE_LEN);
 	pmadapter->bcn_miss_time_out = DEFAULT_BCN_MISS_TIMEOUT;
+#ifdef STA_SUPPORT
+	memset(pmadapter, &pmadapter->arp_filter, 0,
+	       sizeof(pmadapter->arp_filter));
+	pmadapter->arp_filter_size = 0;
+#endif /* STA_SUPPORT */
+
+	pmadapter->mc_status = MFALSE;
 
 #ifdef PCIE
 	if (IS_PCIE(pmadapter->card_type)) {
@@ -882,12 +982,11 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter)
 				EVT_RW_PTR_ROLLOVER_IND;
 		}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
-			pmadapter->pcard_pcie->rxbd_wrptr = MLAN_MAX_TXRX_BD;
+			pmadapter->pcard_pcie->rxbd_wrptr =
+				pmadapter->pcard_pcie->txrx_bd_size;
 			pmadapter->pcard_pcie->evtbd_wrptr = MLAN_MAX_EVT_BD;
 		}
-#endif
 	}
 #endif
 	LEAVE();
@@ -975,6 +1074,11 @@ mlan_status wlan_init_priv_lock_list(pmlan_adapter pmadapter, t_u8 start_index)
 				(t_void *)pmadapter->pmoal_handle,
 				&priv->sta_list, MTRUE,
 				pmadapter->callbacks.moal_init_lock);
+			/* Initialize tdls_pending_txq */
+			util_init_list_head(
+				(t_void *)pmadapter->pmoal_handle,
+				&priv->tdls_pending_txq, MTRUE,
+				pmadapter->callbacks.moal_init_lock);
 			/* Initialize bypass_txq */
 			util_init_list_head(
 				(t_void *)pmadapter->pmoal_handle,
@@ -1073,7 +1177,10 @@ mlan_status wlan_init_lock_list(pmlan_adapter pmadapter)
 	util_init_list_head((t_void *)pmadapter->pmoal_handle,
 			    &pmadapter->scan_pending_q, MTRUE,
 			    pmadapter->callbacks.moal_init_lock);
-
+	/* Initialize ext_cmd_pending_q */
+	util_init_list_head((t_void *)pmadapter->pmoal_handle,
+			    &pmadapter->ext_cmd_pending_q, MTRUE,
+			    pmadapter->callbacks.moal_init_lock);
 	/* Initialize ioctl_pending_q */
 	util_init_list_head((t_void *)pmadapter->pmoal_handle,
 			    &pmadapter->ioctl_pending_q, MTRUE,
@@ -1165,6 +1272,10 @@ t_void wlan_free_lock_list(pmlan_adapter pmadapter)
 			    &pmadapter->scan_pending_q,
 			    pmadapter->callbacks.moal_free_lock);
 
+	util_free_list_head((t_void *)pmadapter->pmoal_handle,
+			    &pmadapter->ext_cmd_pending_q,
+			    pmadapter->callbacks.moal_free_lock);
+
 	util_free_list_head((t_void *)pmadapter->pmoal_handle,
 			    &pmadapter->ioctl_pending_q,
 			    pmadapter->callbacks.moal_free_lock);
@@ -1181,6 +1292,10 @@ t_void wlan_free_lock_list(pmlan_adapter pmadapter)
 				(t_void *)pmadapter->pmoal_handle,
 				&priv->sta_list,
 				priv->adapter->callbacks.moal_free_lock);
+			util_free_list_head(
+				(t_void *)pmadapter->pmoal_handle,
+				&priv->tdls_pending_txq,
+				pmadapter->callbacks.moal_free_lock);
 			util_free_list_head(
 				(t_void *)pmadapter->pmoal_handle,
 				&priv->bypass_txq,
@@ -1371,9 +1486,10 @@ mlan_status wlan_init_fw(pmlan_adapter pmadapter)
  *  @return		MLAN_STATUS_SUCCESS, MLAN_STATUS_PENDING or
  * MLAN_STATUS_FAILURE
  */
-void wlan_update_hw_spec(pmlan_adapter pmadapter)
+static void wlan_update_hw_spec(pmlan_adapter pmadapter)
 {
 	t_u32 i;
+	MrvlIEtypes_He_cap_t *user_he_cap_tlv = MNULL;
 
 	ENTER();
 
@@ -1486,6 +1602,28 @@ void wlan_update_hw_spec(pmlan_adapter pmadapter)
 					pmadapter->hw_he_cap,
 					pmadapter->hw_hecap_len,
 					sizeof(pmadapter->priv[i]->user_he_cap));
+				user_he_cap_tlv =
+					(MrvlIEtypes_He_cap_t *)&pmadapter
+						->priv[i]
+						->user_2g_he_cap;
+				if (pmadapter->priv[i]->bss_role ==
+				    MLAN_BSS_ROLE_STA)
+					user_he_cap_tlv->he_mac_cap[0] &=
+						~HE_MAC_CAP_TWT_RESP_SUPPORT;
+				else
+					user_he_cap_tlv->he_mac_cap[0] &=
+						~HE_MAC_CAP_TWT_REQ_SUPPORT;
+				user_he_cap_tlv =
+					(MrvlIEtypes_He_cap_t *)&pmadapter
+						->priv[i]
+						->user_he_cap;
+				if (pmadapter->priv[i]->bss_role ==
+				    MLAN_BSS_ROLE_STA)
+					user_he_cap_tlv->he_mac_cap[0] &=
+						~HE_MAC_CAP_TWT_RESP_SUPPORT;
+				else
+					user_he_cap_tlv->he_mac_cap[0] &=
+						~HE_MAC_CAP_TWT_REQ_SUPPORT;
 			}
 		}
 	}
@@ -1501,7 +1639,7 @@ void wlan_update_hw_spec(pmlan_adapter pmadapter)
  *  @return		MLAN_STATUS_SUCCESS, MLAN_STATUS_PENDING or
  * MLAN_STATUS_FAILURE
  */
-mlan_status wlan_init_priv_fw(pmlan_adapter pmadapter)
+static mlan_status wlan_init_priv_fw(pmlan_adapter pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_private priv = MNULL;
@@ -1638,9 +1776,22 @@ t_void wlan_free_adapter(pmlan_adapter pmadapter)
 					(t_u8 *)pmadapter->pchan_stats);
 		pmadapter->pchan_stats = MNULL;
 	}
+	if (pmadapter->pold_chan_stats) {
+		if (pcb->moal_vmalloc && pcb->moal_vfree)
+			pcb->moal_vfree(pmadapter->pmoal_handle,
+					(t_u8 *)pmadapter->pold_chan_stats);
+		else
+			pcb->moal_mfree(pmadapter->pmoal_handle,
+					(t_u8 *)pmadapter->pold_chan_stats);
+		pmadapter->pold_chan_stats = MNULL;
+	}
 	if (pmadapter->bcn_buf) {
-		pcb->moal_mfree(pmadapter->pmoal_handle,
-				(t_u8 *)pmadapter->bcn_buf);
+		if (pcb->moal_vmalloc && pcb->moal_vfree)
+			pcb->moal_vfree(pmadapter->pmoal_handle,
+					(t_u8 *)pmadapter->bcn_buf);
+		else
+			pcb->moal_mfree(pmadapter->pmoal_handle,
+					(t_u8 *)pmadapter->bcn_buf);
 		pmadapter->bcn_buf = MNULL;
 	}
 #endif
@@ -1757,7 +1908,7 @@ t_void wlan_free_priv(mlan_private *pmpriv)
  *
  *  @return             N/A
  */
-mlan_status wlan_init_interface(pmlan_adapter pmadapter)
+static mlan_status wlan_init_interface(pmlan_adapter pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = MNULL;
@@ -1807,7 +1958,9 @@ mlan_status wlan_init_interface(pmlan_adapter pmadapter)
 				pmadapter->priv[i]->bss_role =
 					MLAN_BSS_ROLE_STA;
 			else if (pmadapter->bss_attr[i].bss_type ==
-				 MLAN_BSS_TYPE_UAP)
+					 MLAN_BSS_TYPE_UAP ||
+				 pmadapter->bss_attr[i].bss_type ==
+					 MLAN_BSS_TYPE_DFS)
 				pmadapter->priv[i]->bss_role =
 					MLAN_BSS_ROLE_UAP;
 #ifdef WIFI_DIRECT_SUPPORT
@@ -1874,6 +2027,7 @@ mlan_status wlan_get_hw_spec_complete(pmlan_adapter pmadapter)
 		else {
 			memset(pmadapter, &info, 0, sizeof(info));
 			info.fw_cap = pmadapter->fw_cap_info;
+			info.fw_cap_ext = pmadapter->fw_cap_ext;
 			memset(pmadapter, &bss_tbl, 0, sizeof(bss_tbl));
 			memcpy_ext(pmadapter, bss_tbl.bss_attr,
 				   pmadapter->bss_attr, sizeof(mlan_bss_tbl),
@@ -1923,11 +2077,16 @@ mlan_status wlan_init_fw_complete(pmlan_adapter pmadapter)
 	/* Reconfigure wmm parameter*/
 	if (status == MLAN_STATUS_SUCCESS) {
 		pmpriv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_STA);
-		if (pmpriv)
+		if (pmpriv) {
 			status = wlan_prepare_cmd(pmpriv,
 						  HostCmd_CMD_WMM_PARAM_CONFIG,
 						  HostCmd_ACT_GEN_SET, 0, MNULL,
 						  &pmadapter->ac_params);
+			if (status != MLAN_STATUS_SUCCESS)
+				PRINTM(MERROR,
+				       "ERR: wlan_prepare_cmd returned status=0x%x\n",
+				       status);
+		}
 	}
 	/* Invoke callback */
 	ret = pcb->moal_init_fw_complete(pmadapter->pmoal_handle, status);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h
old mode 100644
new mode 100755
index f32731b6c..65e825914
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_init.h
@@ -4,7 +4,7 @@
  *  structures.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h
old mode 100644
new mode 100755
index caaadb03c..877cb2575
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_ioctl.h
@@ -3,7 +3,7 @@
  *  @brief This file declares the IOCTL data structures and APIs.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -86,6 +86,9 @@ enum _mlan_ioctl_req_id {
 #endif
 
 	MLAN_OID_BSS_FIND_BSSID = 0x0002001D,
+#ifdef UAP_SUPPORT
+	MLAN_OID_ACTION_CHAN_SWITCH = 0x0002001E,
+#endif
 
 	/* Radio Configuration Group */
 	MLAN_IOCTL_RADIO_CFG = 0x00030000,
@@ -107,6 +110,8 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_SNMP_MIB_DTIM_PERIOD = 0x00040006,
 	MLAN_OID_SNMP_MIB_SIGNALEXT_ENABLE = 0x00040007,
 	MLAN_OID_SNMP_MIB_CTRL_DEAUTH = 0x00040008,
+	MLAN_OID_SNMP_MIB_DOT11H_FAKERADAR = 0x00040009,
+	MLAN_OID_SNMP_MIB_CHAN_TRACK = 0x0004000A,
 
 	/* Status Information Group */
 	MLAN_IOCTL_GET_INFO = 0x00050000,
@@ -198,6 +203,7 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_11N_CFG_DELBA = 0x000C000C,
 	MLAN_OID_11N_CFG_REJECT_ADDBA_REQ = 0x000C000D,
 	MLAN_OID_11N_CFG_COEX_RX_WINSIZE = 0x000C000E,
+	MLAN_OID_11N_CFG_TX_AGGR_CTRL = 0x000C000F,
 	MLAN_OID_11N_CFG_IBSS_AMPDU_PARAM = 0x000C0010,
 	MLAN_OID_11N_CFG_MIN_BA_THRESHOLD = 0x000C0011,
 
@@ -228,7 +234,10 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_11H_CHAN_REPORT_REQUEST = 0x00110004,
 	MLAN_OID_11H_CHAN_SWITCH_COUNT = 0x00110005,
 	MLAN_OID_11H_CHAN_NOP_INFO = 0x00110006,
+	MLAN_OID_11H_CHAN_DFS_STATE = 0x00110007,
 	MLAN_OID_11H_DFS_W53_CFG = 0x00110008,
+	MLAN_OID_11H_DFS_MODE = 0x00110009,
+	MLAN_OID_11H_NOP_CHAN_LIST = 0x0011000A,
 
 	/* 802.11n Configuration Group RANDYTODO for value assign */
 	MLAN_IOCTL_11AC_CFG = 0x00120000,
@@ -257,6 +266,8 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_MISC_ASSOC_RSP = 0x0020000C,
 	MLAN_OID_MISC_INIT_SHUTDOWN = 0x0020000D,
 	MLAN_OID_MISC_CUSTOM_IE = 0x0020000F,
+	MLAN_OID_MISC_TDLS_CONFIG = 0x00200010,
+	MLAN_OID_MISC_NET_MONITOR = 0x00200011,
 	MLAN_OID_MISC_TX_DATAPAUSE = 0x00200012,
 	MLAN_OID_MISC_IP_ADDR = 0x00200013,
 	MLAN_OID_MISC_MAC_CONTROL = 0x00200014,
@@ -271,6 +282,7 @@ enum _mlan_ioctl_req_id {
 #endif
 	MLAN_OID_MISC_HOTSPOT_CFG = 0x0020001C,
 	MLAN_OID_MISC_OTP_USER_DATA = 0x0020001D,
+	MLAN_OID_MISC_AUTO_ASSOC = 0x0020001E,
 #ifdef USB
 	MLAN_OID_MISC_USB_AGGR_CTRL = 0x0020001F,
 #endif
@@ -281,25 +293,32 @@ enum _mlan_ioctl_req_id {
 #if defined(STA_SUPPORT)
 	MLAN_OID_MISC_PMFCFG = 0x00200022,
 #endif
+	MLAN_OID_MISC_MULTI_CHAN_CFG = 0x00200023,
+	MLAN_OID_MISC_MULTI_CHAN_POLICY = 0x00200024,
 #ifdef WIFI_DIRECT_SUPPORT
 	MLAN_OID_MISC_WIFI_DIRECT_CONFIG = 0x00200025,
 #endif
+	MLAN_OID_MISC_TDLS_OPER = 0x00200026,
+	MLAN_OID_MISC_GET_TDLS_IES = 0x00200027,
 	MLAN_OID_MISC_LOW_PWR_MODE = 0x00200029,
 	MLAN_OID_MISC_MEF_FLT_CFG = 0x0020002A,
 	MLAN_OID_MISC_DFS_REAPTER_MODE = 0x0020002B,
-#ifdef RX_PACKET_COALESCE
-	MLAN_OID_MISC_RX_PACKET_COALESCE = 0x0020002C,
-#endif
+	MLAN_OID_MISC_TDLS_CS_CHANNEL = 0x0020002D,
 	MLAN_OID_MISC_COALESCE_CFG = 0x0020002E,
+	MLAN_OID_MISC_TDLS_IDLE_TIME = 0x0020002F,
 	MLAN_OID_MISC_GET_SENSOR_TEMP = 0x00200030,
+	MLAN_OID_MISC_IPV6_RA_OFFLOAD = 0x00200036,
 	MLAN_OID_MISC_GTK_REKEY_OFFLOAD = 0x00200037,
 	MLAN_OID_MISC_OPER_CLASS = 0x00200038,
 	MLAN_OID_MISC_PMIC_CFG = 0x00200039,
 	MLAN_OID_MISC_IND_RST_CFG = 0x00200040,
+	MLAN_OID_MISC_ROAM_OFFLOAD = 0x00200042,
+	MLAN_OID_MISC_ROAM_OFFLOAD_APLIST = 0x00200043,
 	MLAN_OID_MISC_GET_TSF = 0x00200045,
 	MLAN_OID_MISC_GET_CHAN_REGION_CFG = 0x00200046,
 	MLAN_OID_MISC_CLOUD_KEEP_ALIVE = 0x00200048,
 	MLAN_OID_MISC_OPER_CLASS_CHECK = 0x00200049,
+	MLAN_OID_MISC_DRCS_CFG = 0x00200050,
 
 	MLAN_OID_MISC_CWMODE_CTRL = 0x00200051,
 	MLAN_OID_MISC_AGGR_CTRL = 0x00200052,
@@ -309,11 +328,15 @@ enum _mlan_ioctl_req_id {
 
 	MLAN_OID_MISC_ROBUSTCOEX = 0x00200056,
 	MLAN_OID_MISC_GET_TX_RX_HISTOGRAM = 0x00200057,
+	MLAN_OID_MISC_CONFIG_RTT = 0x00200059,
+	MLAN_OID_MISC_CANCEL_RTT = 0x0020005A,
+	MLAN_OID_MISC_RTT_RESPONDER_CFG = 0x0020005B,
 	MLAN_OID_MISC_CFP_INFO = 0x00200060,
 	MLAN_OID_MISC_BOOT_SLEEP = 0x00200061,
 #if defined(PCIE)
 	MLAN_OID_MISC_SSU = 0x00200062,
 #endif
+	MLAN_OID_MISC_CSI = 0x00200064,
 	MLAN_OID_MISC_DMCS_CONFIG = 0x00200065,
 	MLAN_OID_MISC_RX_ABORT_CFG = 0x00200066,
 	MLAN_OID_MISC_RX_ABORT_CFG_EXT = 0x00200067,
@@ -331,6 +354,25 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_MISC_CFP_TABLE = 0x0020007A,
 	MLAN_OID_MISC_RANGE_EXT = 0x0020007B,
 	MLAN_OID_MISC_DOT11MC_UNASSOC_FTM_CFG = 0x0020007C,
+	MLAN_OID_MISC_TP_STATE = 0x0020007D,
+	MLAN_OID_MISC_HAL_PHY_CFG = 0x0020007E,
+	MLAN_OID_MISC_RF_TEST_HE_POWER = 0X0020007F,
+	MLAN_OID_MISC_MULTI_AP_CFG = 0x00200080,
+#ifdef UAP_SUPPORT
+	MLAN_OID_MISC_WACP_MODE = 0x00200081,
+#endif
+	MLAN_OID_MISC_GPIO_TSF_LATCH = 0x00200082,
+	MLAN_OID_MISC_GET_TSF_INFO = 0x00200083,
+	MLAN_OID_MISC_ASSOC_REQ = 0x00200084,
+	MLAN_OID_MISC_IPS_CFG = 0x00200085,
+	MLAN_OID_MISC_MC_AGGR_CFG = 0x00200086,
+	MLAN_OID_MISC_CH_LOAD = 0x00200087,
+	MLAN_OID_MISC_STATS = 0x00200088,
+	MLAN_OID_MISC_CH_LOAD_RESULTS = 0x00200089,
+	MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX = 0x0020008A,
+	MLAN_OID_MISC_CROSS_CHIP_SYNCH = 0x0020008B,
+	MLAN_OID_MISC_RF_TEST_CONFIG_TRIGGER_FRAME = 0x0020008C,
+	MLAN_OID_MISC_OFDM_DESENSE_CFG = 0x0020008D,
 };
 
 /** Sub command size */
@@ -372,6 +414,14 @@ enum _mlan_pass_to_act_scan {
 	MLAN_PASS_TO_ACT_SCAN_DIS
 };
 
+/** Enumeration for passive to active scan */
+enum _mlan_ext_scan {
+	MLAN_EXTENDED_SCAN_UNCHANGED = 0,
+	MLAN_LEGACY_SCAN,
+	MLAN_EXT_SCAN,
+	MLAN_EXT_SCAN_ENH
+};
+
 /** Max number of supported rates */
 #define MLAN_SUPPORTED_RATES 32
 
@@ -580,6 +630,8 @@ enum _mlan_bss_mode {
 
 /** Maximum key length */
 #define MLAN_MAX_KEY_LENGTH 32
+/** Maximum PMK R0 NAME key length */
+#define MLAN_MAX_PMKR0_NAME_LENGTH 16
 
 /** Maximum atim window in milliseconds */
 #define MLAN_MAX_ATIM_WINDOW 50
@@ -612,7 +664,7 @@ typedef struct _mlan_multicast_list {
 } mlan_multicast_list, *pmlan_multicast_list;
 
 /** Max channel */
-#define MLAN_MAX_CHANNEL 165
+#define MLAN_MAX_CHANNEL 177
 /** Maximum number of channels in table */
 #define MLAN_MAX_CHANNEL_NUM 128
 
@@ -674,6 +726,26 @@ typedef struct _mlan_ds_misc_assoc_rsp {
 	t_u32 assoc_resp_len;
 } mlan_ds_misc_assoc_rsp, *pmlan_ds_misc_assoc_rsp;
 
+/** Type definition of mlan_ds_misc_assoc_req for MLAN_OID_MISC_ASSOC_REQ */
+typedef struct _mlan_ds_misc_assoc_req {
+	/** Associate req buffer */
+	t_u8 assoc_req_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_req_len;
+} mlan_ds_misc_assoc_req, *pmlan_ds_misc_assoc_req;
+
+/** mlan_ds_assoc_info */
+typedef struct _mlan_ds_assoc_info {
+	/** Associate req buffer */
+	t_u8 assoc_resp_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_resp_len;
+	/** Associate req buffer */
+	t_u8 assoc_req_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_req_len;
+} mlan_ds_assoc_info, *pmlan_ds_assoc_info;
+
 /** mlan_ssid_bssid  data structure for
  *  MLAN_OID_BSS_START and MLAN_OID_BSS_FIND_BSS
  */
@@ -686,6 +758,8 @@ typedef struct _mlan_ssid_bssid {
 	t_u32 idx;
 	/** Receive signal strength in dBm */
 	t_s32 rssi;
+	/* previous bssid */
+	mlan_802_11_mac_addr prev_bssid;
 	/**channel*/
 	t_u16 channel;
 	/**mobility domain value*/
@@ -700,6 +774,11 @@ typedef struct _mlan_ssid_bssid {
 	t_u8 host_mlme;
 	/** assoicate resp frame/ie from firmware */
 	mlan_ds_misc_assoc_rsp assoc_rsp;
+	t_u8 owe_transition_mode;
+	/** Transition SSID */
+	mlan_802_11_ssid trans_ssid;
+	/** Transition BSSID */
+	mlan_802_11_mac_addr trans_bssid;
 } mlan_ssid_bssid, *pmlan_ssid_bssid;
 
 /** Data structure of WMM ECW */
@@ -845,6 +924,8 @@ typedef struct _mlan_deauth_param {
 #define PROTOCOL_WAPI 0x80
 /** WPA3 SAE */
 #define PROTOCOL_WPA3_SAE 0x100
+/** OWE */
+#define PROTOCOL_OWE 0x200
 
 /** Key_mgmt_psk */
 #define KEY_MGMT_NONE 0x04
@@ -1044,6 +1125,10 @@ typedef struct _mlan_uap_bss_param {
 	t_u8 channel;
 	/** auth mode */
 	t_u16 auth_mode;
+	/** PWE derivation */
+	t_u8 pwe_derivation;
+	/** transition disable */
+	t_u8 transition_disable;
 	/** encryption protocol */
 	t_u16 protocol;
 	/** key managment type */
@@ -1088,6 +1173,8 @@ typedef struct _mlan_uap_bss_param {
 
 	/** uap host based config */
 	t_u32 uap_host_based_config;
+	/** multi ap flag */
+	t_u8 multi_ap_flag;
 } mlan_uap_bss_param, *pmlan_uap_bss_param;
 
 /** mlan_uap_scan_channels */
@@ -1102,6 +1189,27 @@ typedef struct _mlan_uap_scan_channels {
 	scan_chan_list chan_list[MLAN_MAX_CHANNEL];
 } mlan_uap_scan_channels;
 
+#define MAX_NUM_PKTS 9
+#define DEF_NUM_PKTS 3
+
+/** Default channel mode and retry packets for channel switch */
+#define DEFAULT_RETRY_PKTS 9
+#define DEFAULT_CHAN_MODE_MASK 3
+
+/** mlan_chan_switch_param */
+typedef struct _mlan_action_chan_switch {
+	/** mode*/
+	t_u8 mode;
+	/** switch mode*/
+	t_u8 chan_switch_mode;
+	/** oper class*/
+	t_u8 new_oper_class;
+	/** new channel */
+	t_u8 new_channel_num;
+	/** chan_switch_count */
+	t_u8 chan_switch_count;
+} mlan_action_chan_switch;
+
 /** mlan_uap_oper_ctrl */
 typedef struct _mlan_uap_oper_ctrl {
 	/** control value
@@ -1215,6 +1323,8 @@ typedef struct _mlan_ds_bss {
 		wmm_parameter_t ap_wmm_para;
 		/** ap scan channels for MLAN_OID_UAP_SCAN_CHANNELS*/
 		mlan_uap_scan_channels ap_scan_channels;
+		/** channel switch for MLAN_OID_UAP_CHAN_SWITCH */
+		mlan_action_chan_switch chanswitch;
 		/** ap channel for MLAN_OID_UAP_CHANNEL*/
 		chan_band_info ap_channel;
 		/** ap operation control for MLAN_OID_UAP_OPER_CTRL*/
@@ -1248,8 +1358,9 @@ typedef MLAN_PACK_START struct _otp_region_info {
 	t_u8 country_code[2];
 	t_u8 region_code;
 	t_u8 environment;
-	t_u16 force_reg : 1;
-	t_u16 reserved : 15;
+	t_u8 force_reg : 1;
+	t_u8 reserved : 7;
+	t_u8 dfs_region;
 } MLAN_PACK_END otp_region_info_t;
 
 /** Type definition of mlan_ds_custom_reg_domain */
@@ -1276,7 +1387,6 @@ enum _mlan_band_def {
 	BAND_AAC = 64,
 	BAND_GAX = 256,
 	BAND_AAX = 512,
-
 };
 
 /** Channel bandwidth */
@@ -1423,6 +1533,7 @@ typedef struct _mlan_ds_snmp_mib {
 		t_u8 signalext_enable;
 		/** Control deauth when uap switch channel */
 		t_u8 deauthctrl;
+		t_u8 chan_track;
 	} param;
 } mlan_ds_snmp_mib, *pmlan_ds_snmp_mib;
 
@@ -1594,6 +1705,54 @@ typedef struct _mlan_ds_get_stats {
 	t_u64 rx_octets_in_ampdu_cnt;
 	/** ampdu delimiter CRC error count */
 	t_u32 ampdu_delimiter_crc_error_cnt;
+	/** Rx Stuck Related Info*/
+	/** Rx Stuck Issue count */
+	t_u32 rx_stuck_issue_cnt[2];
+	/** Rx Stuck Recovery count */
+	t_u32 rx_stuck_recovery_cnt;
+	/** Rx Stuck TSF */
+	t_u64 rx_stuck_tsf[2];
+	/** Tx Watchdog Recovery Related Info */
+	/** Tx Watchdog Recovery count */
+	t_u32 tx_watchdog_recovery_cnt;
+	/** Tx Watchdog TSF */
+	t_u64 tx_watchdog_tsf[2];
+	/** Channel Switch Related Info */
+	/** Channel Switch Announcement Sent */
+	t_u32 channel_switch_ann_sent;
+	/** Channel Switch State */
+	t_u32 channel_switch_state;
+	/** Register Class */
+	t_u32 reg_class;
+	/** Channel Number */
+	t_u32 channel_number;
+	/** Channel Switch Mode */
+	t_u32 channel_switch_mode;
+	/** Reset Rx Mac Count */
+	t_u32 rx_reset_mac_recovery_cnt;
+	/** ISR2 Not Done Count*/
+	t_u32 rx_Isr2_NotDone_Cnt;
+	/** GDMA Abort Count */
+	t_u32 gdma_abort_cnt;
+	/** Rx Reset MAC Count */
+	t_u32 g_reset_rx_mac_cnt;
+	// Ownership error counters
+	/*Error Ownership error count*/
+	t_u32 dwCtlErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwBcnErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwMgtErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwDatErrCnt;
+	/*BIGTK MME good count*/
+	t_u32 bigtk_mmeGoodCnt;
+	/*BIGTK Replay error count*/
+	t_u32 bigtk_replayErrCnt;
+	/*BIGTK MIC error count*/
+	t_u32 bigtk_micErrCnt;
+	/*BIGTK MME not included count*/
+	t_u32 bigtk_mmeNotFoundCnt;
 } mlan_ds_get_stats, *pmlan_ds_get_stats;
 
 /** Type definition of mlan_ds_uap_stats for MLAN_OID_GET_STATS */
@@ -1729,12 +1888,18 @@ typedef struct _mlan_ds_get_signal {
 typedef struct _mlan_fw_info {
 	/** Firmware version */
 	t_u32 fw_ver;
+	/** Firmware Hotfix version */
+	t_u8 hotfix_version;
+	/** tx buf size */
+	t_u16 tx_buf_size;
 	/** MAC address */
 	mlan_802_11_mac_addr mac_addr;
 	/** 802.11n device capabilities */
 	t_u32 hw_dot_11n_dev_cap;
 	/** Device support for MIMO abstraction of MCSs */
 	t_u8 hw_dev_mcs_support;
+	/** mpdu density */
+	t_u8 hw_mpdu_density;
 	/** user's MCS setting */
 	t_u8 usr_dev_mcs_support;
 	/** 802.11ac device capabilities */
@@ -1771,13 +1936,28 @@ typedef struct _mlan_fw_info {
 	t_u8 antinfo;
 	/** max AP associated sta count supported by fw */
 	t_u8 max_ap_assoc_sta;
+	/** FW support roaming offload */
+	t_u8 fw_roaming_support;
 	/** Bandwidth not support 80Mhz */
 	t_u8 prohibit_80mhz;
+	/** FW support beacon protection */
+	t_u8 fw_beacon_prot;
+	/** FW RTT support */
+	t_u8 rtt_support;
+
+	/* lower 8 bytes of uuid */
+	t_u64 uuid_lo;
+
+	/* higher 8 bytes of uuid */
+	t_u64 uuid_hi;
 } mlan_fw_info, *pmlan_fw_info;
 
 /** Version string buffer length */
 #define MLAN_MAX_VER_STR_LEN 128
 
+/** Maximum length of secure boot uuid */
+#define MLAN_MAX_UUID_LEN 32
+
 /** mlan_ver_ext data structure for MLAN_OID_GET_VER_EXT */
 typedef struct _mlan_ver_ext {
 	/** Selected version string */
@@ -1790,6 +1970,14 @@ typedef struct _mlan_ver_ext {
 /** Extended Capabilities Data */
 typedef struct MLAN_PACK_START _ExtCap_t {
 	/** Extended Capabilities value */
+	t_u8 rsvdBit87 : 1; /* bit 87 */
+	t_u8 rsvdBit86 : 1; /* bit 86 */
+	t_u8 rsvdBit85 : 1; /* bit 85 */
+	t_u8 beacon_prot : 1; /* bit 84 */
+	t_u8 rsvdBit83 : 1; /* bit 83 */
+	t_u8 rsvdBit82 : 1; /* bit 82 */
+	t_u8 rsvdBit81 : 1; /* bit 81 */
+	t_u8 rsvdBit80 : 1; /* bit 80 */
 	t_u8 rsvdBit79 : 1; /* bit 79 */
 	t_u8 TWTResp : 1; /* bit 78 */
 	t_u8 TWTReq : 1; /* bit 77 */
@@ -1955,6 +2143,14 @@ typedef struct MLAN_PACK_START _ExtCap_t {
 	t_u8 TWTReq : 1; /* bit 77 */
 	t_u8 TWTResp : 1; /* bit 78 */
 	t_u8 rsvdBit79 : 1; /* bit 79 */
+	t_u8 rsvdBit80 : 1; /* bit 80 */
+	t_u8 rsvdBit81 : 1; /* bit 81 */
+	t_u8 rsvdBit82 : 1; /* bit 82 */
+	t_u8 rsvdBit83 : 1; /* bit 83 */
+	t_u8 beacon_prot : 1; /* bit 84 */
+	t_u8 rsvdBit85 : 1; /* bit 85 */
+	t_u8 rsvdBit86 : 1; /* bit 86 */
+	t_u8 rsvdBit87 : 1; /* bit 87 */
 } MLAN_PACK_END ExtCap_t, *pExtCap_t;
 #endif
 
@@ -1974,7 +2170,7 @@ typedef struct _mlan_bss_info {
 	/** Channel */
 	t_u32 bss_chan;
 	/** Band */
-	t_u8 bss_band;
+	t_u16 bss_band;
 	/** Region code */
 	t_u32 region_code;
 	/** Connection status */
@@ -2063,13 +2259,29 @@ typedef struct {
 #define SDIO_MP_DBG_NUM 10
 #endif
 
-#ifdef PCIE
-#define MLAN_MAX_TXRX_BD 0x20
-#endif
-
 /** Maximum size of IEEE Information Elements */
 #define IEEE_MAX_IE_SIZE 256
 
+/** support up to 8 TDLS peer */
+#define MLAN_MAX_TDLS_PEER_SUPPORTED 8
+/** TDLS peer info */
+typedef struct _tdls_peer_info {
+	/** station mac address */
+	t_u8 mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** SNR */
+	t_s8 snr;
+	/** Noise Floor */
+	t_s8 nf;
+	/** Extended Capabilities IE */
+	t_u8 ext_cap[IEEE_MAX_IE_SIZE];
+	/** HT Capabilities IE */
+	t_u8 ht_cap[IEEE_MAX_IE_SIZE];
+	/** VHT Capabilities IE */
+	t_u8 vht_cap[IEEE_MAX_IE_SIZE];
+	/** HE Capabilities IE */
+	t_u8 he_cap[IEEE_MAX_IE_SIZE];
+} tdls_peer_info;
+
 /** max ralist num */
 #define MLAN_MAX_RALIST_NUM 8
 /** ralist info */
@@ -2108,6 +2320,10 @@ typedef struct _mlan_debug_info {
 	t_u32 rx_tbl_num;
 	/** Rx reorder table*/
 	rx_reorder_tbl rx_tbl[MLAN_MAX_RX_BASTREAM_SUPPORTED];
+	/** TDLS peer number */
+	t_u32 tdls_peer_num;
+	/** TDLS peer list*/
+	tdls_peer_info tdls_peer_list[MLAN_MAX_TDLS_PEER_SUPPORTED];
 	/** ralist num */
 	t_u32 ralist_num;
 	/** ralist info */
@@ -2143,9 +2359,11 @@ typedef struct _mlan_debug_info {
 	/** Corresponds to port_open member of mlan_private */
 	t_u8 port_open;
 	/** bypass pkt count */
-	t_u16 bypass_pkt_count;
+	t_u32 bypass_pkt_count;
 	/** Corresponds to scan_processing member of mlan_adapter */
 	t_u32 scan_processing;
+	/** Corresponds to scan_state member of mlan_adapter */
+	t_u32 scan_state;
 	/** Corresponds to mlan_processing member of mlan_adapter */
 	t_u32 mlan_processing;
 	/** Corresponds to main_lock_flag member of mlan_adapter */
@@ -2193,6 +2411,10 @@ typedef struct _mlan_debug_info {
 	t_u32 mpa_sent_no_ports;
 	/** last recv wr_bitmap */
 	t_u32 last_recv_wr_bitmap;
+	/** last recv rd_bitmap */
+	t_u32 last_recv_rd_bitmap;
+	/** mp_data_port_mask */
+	t_u32 mp_data_port_mask;
 	/** last mp_wr_bitmap */
 	t_u32 last_mp_wr_bitmap[SDIO_MP_DBG_NUM];
 	/** last ports for cmd53 write data */
@@ -2257,6 +2479,8 @@ typedef struct _mlan_debug_info {
 	t_u32 dnld_cmd_in_secs;
 	/** Corresponds to data_sent member of mlan_adapter */
 	t_u8 data_sent;
+	/** Corresponds to data_sent_cnt member of mlan_adapter */
+	t_u32 data_sent_cnt;
 	/** Corresponds to cmd_sent member of mlan_adapter */
 	t_u8 cmd_sent;
 	/** SDIO multiple port read bitmap */
@@ -2280,8 +2504,8 @@ typedef struct _mlan_debug_info {
 	t_u32 eventbd_rdptr;
 	/** PCIE eventbd write pointer */
 	t_u32 eventbd_wrptr;
-	/** Last pkt size in transmit */
-	t_u32 last_tx_pkt_size[MLAN_MAX_TXRX_BD];
+	/** txrx_bd_size */
+	t_u16 txrx_bd_size;
 	/** txbd ring vbase */
 	t_u8 *txbd_ring_vbase;
 	/** txbd ring size */
@@ -2326,7 +2550,7 @@ typedef struct _mlan_debug_info {
 #define MAX_NUM_CLIENTS MAX_STA_COUNT
 
 /** station info */
-typedef struct _sta_info {
+typedef struct _sta_info_data {
 	/** STA MAC address */
 	t_u8 mac_address[MLAN_MAC_ADDR_LENGTH];
 	/** Power mgmt status */
@@ -2339,16 +2563,18 @@ typedef struct _sta_info {
 	sta_stats stats;
 	/** ie length */
 	t_u16 ie_len;
-	/** ie buffer */
-	t_u8 ie_buf[];
-} sta_info;
+} sta_info_data;
+
+/** Per station Maximum IE buffer SIZE */
+#define MAX_STA_LIST_IE_SIZE 13
 
 /** mlan_ds_sta_list structure for MLAN_OID_UAP_STA_LIST */
 typedef struct _mlan_ds_sta_list {
 	/** station count */
 	t_u16 sta_count;
 	/** station list */
-	sta_info info[MAX_NUM_CLIENTS];
+	sta_info_data info[MAX_NUM_CLIENTS];
+	/* ie_buf will be append at the end */
 } mlan_ds_sta_list, *pmlan_ds_sta_list;
 #endif
 
@@ -2395,6 +2621,7 @@ enum _mlan_auth_mode {
 	MLAN_AUTH_MODE_SHARED = 0x01,
 	MLAN_AUTH_MODE_FT = 0x02,
 	MLAN_AUTH_MODE_SAE = 0x03,
+	MLAN_AUTH_MODE_OWE = 0x04,
 	MLAN_AUTH_MODE_NETWORKEAP = 0x80,
 	MLAN_AUTH_MODE_AUTO = 0xFF,
 };
@@ -2406,7 +2633,8 @@ typedef enum {
 	AssocAgentAuth_FastBss,
 	AssocAgentAuth_FastBss_Skip,
 	AssocAgentAuth_Network_EAP,
-	AssocAgentAuth_Wpa3Sae,
+	AssocAgentAuth_Wpa3Sae = 6,
+	AssocAgentAuth_Owe = 7,
 	AssocAgentAuth_Auto,
 } AssocAgentAuthType_e;
 
@@ -2475,6 +2703,10 @@ enum _mlan_psk_type {
 #define KEY_FLAG_GCMP_256 0x00000040
 /** key flag for ccmp 256 */
 #define KEY_FLAG_CCMP_256 0x00000080
+/** key flag for GMAC_128 */
+#define KEY_FLAG_GMAC_128 0x00000100
+/** key flag for GMAC_256 */
+#define KEY_FLAG_GMAC_256 0x00000200
 
 /** Type definition of mlan_ds_encrypt_key for MLAN_OID_SEC_CFG_ENCRYPT_KEY */
 typedef struct _mlan_ds_encrypt_key {
@@ -2526,6 +2758,8 @@ typedef struct _mlan_sae_password_t {
 typedef struct _mlan_pmk_t {
 	/** PMK */
 	t_u8 pmk[MLAN_MAX_KEY_LENGTH];
+	t_u8 pmk_r0[MLAN_MAX_KEY_LENGTH];
+	t_u8 pmk_r0_name[MLAN_MAX_PMKR0_NAME_LENGTH];
 } mlan_pmk_t;
 
 /** Embedded supplicant RSN type: No RSN */
@@ -2576,10 +2810,20 @@ typedef struct _mlan_ds_ewpa_mode {
 	t_u32 act_groupcipher;
 } mlan_ds_esupp_mode, *pmlan_ds_esupp_mode;
 
+/* Security SSID MAX number support by firmware*/
+#define MAX_SEC_SSID_NUM 6
+
 /** Type definition of mlan_ds_sec_cfg for MLAN_IOCTL_SEC_CFG */
 typedef struct _mlan_ds_sec_cfg {
 	/** Sub-command */
 	t_u32 sub_command;
+	/** Flag to extend some structures to support multiple values.
+	 ** For example, mlan_ds_passphrase can only contain one value,
+	 ** if need use mlan_ds_passphrase[N], just set this flag and
+	 ** use mlan_ds_passphrase[] instead to avoid modify
+	 ** more already exist code.
+	 */
+	t_u8 multi_passphrase;
 	/** Security configuration parameter */
 	union {
 		/** Authentication mode for MLAN_OID_SEC_CFG_AUTH_MODE */
@@ -2605,6 +2849,7 @@ typedef struct _mlan_ds_sec_cfg {
 #ifdef UAP_SUPPORT
 		t_u8 sta_mac[MLAN_MAC_ADDR_LENGTH];
 #endif
+		mlan_ds_passphrase roam_passphrase[MAX_SEC_SSID_NUM];
 	} param;
 } mlan_ds_sec_cfg, *pmlan_ds_sec_cfg;
 
@@ -2871,7 +3116,9 @@ typedef struct _mlan_ds_beacon_stuck_param_cfg {
 #define HOST_SLEEP_COND_IPV6_PACKET MBIT(31)
 
 /** Host sleep config conditions: Default */
-#define HOST_SLEEP_DEF_COND 0
+#define HOST_SLEEP_DEF_COND                                                    \
+	(HOST_SLEEP_COND_BROADCAST_DATA | HOST_SLEEP_COND_UNICAST_DATA |       \
+	 HOST_SLEEP_COND_MAC_EVENT)
 
 /** Host sleep config GPIO : Default */
 #define HOST_SLEEP_DEF_GPIO 0xff
@@ -2917,6 +3164,8 @@ typedef struct _mlan_ds_hs_cfg {
 	t_u8 ext_gap;
 	/** GPIO wave level for extend hscfg*/
 	t_u8 gpio_wave;
+	/** Minimum delay between HsActive and HostWake (in msec) */
+	t_u16 min_wake_holdoff;
 } mlan_ds_hs_cfg, *pmlan_ds_hs_cfg;
 
 #define MAX_MGMT_FRAME_FILTER 2
@@ -3185,15 +3434,6 @@ typedef struct _mlan_ds_pm_cfg {
 	} param;
 } mlan_ds_pm_cfg, *pmlan_ds_pm_cfg;
 
-#ifdef RX_PACKET_COALESCE
-typedef struct {
-	mlan_cmd_result_e cmd_result; /**< Firmware execution result */
-
-	t_u32 pkt_threshold; /** Packet threshold */
-	t_u16 delay; /** Timeout value in milliseconds */
-} wlan_ioctl_rx_pkt_coalesce_config_t;
-#endif
-
 /*-----------------------------------------------------------------*/
 /** WMM Configuration Group */
 /*-----------------------------------------------------------------*/
@@ -3657,6 +3897,8 @@ typedef struct _mlan_ds_11n_cfg {
 		mlan_ds_reject_addba_req reject_addba_req;
 		/** Control coex RX window size configuration */
 		t_u32 coex_rx_winsize;
+		/** Control TX AMPDU configuration */
+		t_u32 txaggrctrl;
 		/** aggrprirotity table for MLAN_OID_11N_CFG_IBSS_AMPDU_PARAM */
 		mlan_ds_ibss_ampdu_param ibss_ampdu;
 		/** Minimum BA Threshold for MLAN_OID_11N_CFG_MIN_BA_THRESHOLD
@@ -3762,7 +4004,7 @@ typedef MLAN_PACK_START struct _mlan_ds_11ax_he_capa {
 
 /** Type definition of mlan_ds_11ax_he_cfg for MLAN_OID_11AX_HE_CFG */
 typedef struct _mlan_ds_11ax_he_cfg {
-	/** band, BIT0:2.4G, BIT1:5G*/
+	/** band, BIT0:2.4G, BIT1:5G BIT2:6G*/
 	t_u8 band;
 	/** mlan_ds_11ax_he_capa */
 	mlan_ds_11ax_he_capa he_cap;
@@ -3795,6 +4037,7 @@ typedef struct _mlan_ds_11ax_cfg {
 
 #define MLAN_11AX_TWT_SETUP_SUBID 0x114
 #define MLAN_11AX_TWT_TEARDOWN_SUBID 0x115
+#define MLAN_11AX_TWT_REPORT_SUBID 0x116
 
 #define MRVL_DOT11AX_ENABLE_SR_TLV_ID (PROPRIETARY_TLV_BASE_ID + 322)
 #define MRVL_DOT11AX_OBSS_PD_OFFSET_TLV_ID (PROPRIETARY_TLV_BASE_ID + 323)
@@ -3845,10 +4088,19 @@ typedef struct _mlan_ds_11ax_txop_cmd {
 } mlan_ds_11ax_txop_cmd, *pmlan_ds_11ax_txop_cmd;
 
 /** Type definition of mlan_ds_11ax_htc_cmd for MLAN_OID_11AX_CMD_CFG */
-typedef struct _mlan_ds_11ax_txomi_cmd {
+typedef struct MLAN_PACK_START_mlan_ds_11ax_txomi_cmd {
 	/* 11ax spec 9.2.4.6a.2 OM Control 12 bits. Bit 0 to bit 11 */
 	t_u16 omi;
-} mlan_ds_11ax_txomi_cmd, *pmlan_ds_11ax_txomi_cmd;
+	/* tx option
+	 * 0: send OMI in QoS NULL; 1: send OMI in QoS data; 0xFF: set OMI in
+	 * both
+	 */
+	t_u8 tx_option;
+	/* if OMI is sent in QoS data, specify the number of consecutive data
+	 * packets containing the OMI
+	 */
+	t_u8 num_data_pkts;
+} MLAN_PACK_END mlan_ds_11ax_txomi_cmd, *pmlan_ds_11ax_txomi_cmd;
 
 /** Type definition of mlan_ds_11ax_toltime_cmd for MLAN_OID_11AX_CMD_CFG */
 typedef struct _mlan_ds_11ax_toltime_cmd {
@@ -3922,6 +4174,17 @@ typedef struct MLAN_PACK_START _mlan_ds_twt_teardown {
 	t_u8 teardown_all_twt;
 } MLAN_PACK_END mlan_ds_twt_teardown, *pmlan_ds_twt_teardown;
 
+/** Type definition of mlan_ds_twt_report for MLAN_OID_11AX_TWT_CFG */
+typedef MLAN_PACK_START struct _mlan_ds_twt_report {
+	/** TWT report type, 0: BTWT id */
+	t_u8 type;
+	/** TWT report length of value in data */
+	t_u8 length;
+	t_u8 reserve[2];
+	/** TWT report payload for FW response to fill */
+	t_u8 data[36];
+} MLAN_PACK_END mlan_ds_twt_report, *pmlan_ds_twt_report;
+
 /** Type definition of mlan_ds_twtcfg for MLAN_OID_11AX_TWT_CFG */
 typedef struct MLAN_PACK_START _mlan_ds_twtcfg {
 	/** Sub-command */
@@ -3935,6 +4198,8 @@ typedef struct MLAN_PACK_START _mlan_ds_twtcfg {
 		/** TWT Teardown config for Sub ID: MLAN_11AX_TWT_TEARDOWN_SUBID
 		 */
 		mlan_ds_twt_teardown twt_teardown;
+		/** TWT report for Sub ID: MLAN_11AX_TWT_REPORT_SUBID */
+		mlan_ds_twt_report twt_report;
 	} param;
 } MLAN_PACK_END mlan_ds_twtcfg, *pmlan_ds_twtcfg;
 
@@ -3957,12 +4222,19 @@ typedef struct _mlan_ds_subband_set_t {
 	t_u8 max_tx_pwr;
 } mlan_ds_subband_set_t;
 
+#define NXP_DFS_UNSET 0
+#define NXP_DFS_FCC 1
+#define NXP_DFS_ETSI 2
+#define NXP_DFS_JP 3
+#define NXP_DFS_UNKNOWN 0xFF
 /** Domain regulatory information */
 typedef struct _mlan_ds_11d_domain_info {
+	/** DFS region code */
+	t_u8 dfs_region;
 	/** Country Code */
 	t_u8 country_code[COUNTRY_CODE_LEN];
 	/** Band that channels in sub_band belong to */
-	t_u8 band;
+	t_u16 band;
 	/** No. of subband in below */
 	t_u8 no_of_sub_band;
 	/** Subband data to send/last sent */
@@ -4005,13 +4277,11 @@ enum _mlan_reg_type {
 	MLAN_REG_CAU = 5,
 	MLAN_REG_PSU = 6,
 	MLAN_REG_BCA = 7,
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
+	MLAN_REG_CIU = 8,
 	MLAN_REG_MAC2 = 0x81,
 	MLAN_REG_BBP2 = 0x82,
 	MLAN_REG_RF2 = 0x83,
 	MLAN_REG_BCA2 = 0x87
-#endif
 };
 
 /** Type definition of mlan_ds_reg_rw for MLAN_OID_REG_RW */
@@ -4077,6 +4347,8 @@ typedef struct _mlan_ds_11h_dfs_testing {
 	/** User-configured fixed channel to change to, 0 to use random channel
 	 */
 	t_u8 usr_fixed_new_chan;
+	/** User-configured cac restart */
+	t_u8 usr_cac_restart;
 } mlan_ds_11h_dfs_testing, *pmlan_ds_11h_dfs_testing;
 
 /** Type definition of mlan_ds_11h_dfs_testing for MLAN_OID_11H_CHAN_NOP_INFO */
@@ -4085,12 +4357,23 @@ typedef struct _mlan_ds_11h_chan_nop_info {
 	t_u8 curr_chan;
 	/** channel_width */
 	t_u8 chan_width;
+	/** check new channel flag */
+	t_u8 check_new_chan;
 	/** flag for chan under nop */
 	t_bool chan_under_nop;
 	/** chan_ban_info for new channel */
 	chan_band_info new_chan;
 } mlan_ds_11h_chan_nop_info, *pmlan_ds_11h_chan_nop_info;
 
+/** Type definition of mlan_ds_11h_nop_chan_list for MLAN_OID_11H_NOP_CHAN_LIST
+ */
+typedef struct _mlan_ds_11h_nop_chan_list {
+	/** number of nop channel */
+	t_u8 num_chan;
+	/** chan list array */
+	t_u8 chan_list[20];
+} mlan_ds_11h_nop_chan_list, *pmlan_ds_11h_nop_chan_list;
+
 typedef struct _mlan_ds_11h_chan_rep_req {
 	t_u16 startFreq;
 	Band_Config_t bandcfg;
@@ -4099,6 +4382,16 @@ typedef struct _mlan_ds_11h_chan_rep_req {
 	t_u8 host_based;
 } mlan_ds_11h_chan_rep_req;
 
+/** channel dfs state for MLAN_OID_11H_CHAN_DFS_STATE */
+typedef struct _mlan_ds_11h_chan_dfs_state {
+	/** channel */
+	t_u8 channel;
+	/** is dfs channel */
+	t_u8 dfs_required;
+	/** dfs state */
+	dfs_state_t dfs_state;
+} mlan_ds_11h_chan_dfs_state;
+
 typedef struct _mlan_ds_11h_dfs_w53_cfg {
 	/** dfs w53 cfg */
 	t_u8 dfs53cfg;
@@ -4116,11 +4409,17 @@ typedef struct _mlan_ds_11h_cfg {
 		mlan_ds_11h_dfs_testing dfs_testing;
 		/** channel NOP information for MLAN_OID_11H_CHAN_NOP_INFO */
 		mlan_ds_11h_chan_nop_info ch_nop_info;
+		/** NOP channel list for MLAN_OID_11H_NOP_CHAN_LIST */
+		mlan_ds_11h_nop_chan_list nop_chan_list;
 		/** channel report req for MLAN_OID_11H_CHAN_REPORT_REQUEST */
 		mlan_ds_11h_chan_rep_req chan_rpt_req;
 		/** channel switch count for MLAN_OID_11H_CHAN_SWITCH_COUNT*/
 		t_s8 cs_count;
+		/** channel dfs state for MLAN_OID_11H_CHAN_DFS_STATE */
+		mlan_ds_11h_chan_dfs_state ch_dfs_state;
 		mlan_ds_11h_dfs_w53_cfg dfs_w53_cfg;
+		/** dfs_mode for MLAN_OID_11H_DFS_MODE */
+		t_u8 dfs_mode;
 	} param;
 } mlan_ds_11h_cfg, *pmlan_ds_11h_cfg;
 
@@ -4139,6 +4438,9 @@ typedef struct _mlan_ds_11h_cfg {
 /** Enumeration for IE type */
 enum _mlan_ie_type {
 	MLAN_IE_TYPE_GEN_IE = 0,
+#ifdef STA_SUPPORT
+	MLAN_IE_TYPE_ARP_FILTER,
+#endif /* STA_SUPPORT */
 };
 
 /** Type definition of mlan_ds_misc_gen_ie for MLAN_OID_MISC_GEN_IE */
@@ -4205,6 +4507,33 @@ enum _mlan_func_cmd {
 	MLAN_FUNC_SHUTDOWN,
 };
 
+/* Net monitor filters: */
+/* management frame */
+#define MLAN_NETMON_MANAGEMENT MBIT(0)
+/* control frame */
+#define MLAN_NETMON_CONTROL MBIT(1)
+/* data frame */
+#define MLAN_NETMON_DATA MBIT(2)
+/* only unicast destined frame (no promiscuous) */
+#define MLAN_NETMON_NOPROM MBIT(3)
+/* capture non-bss Rx beacons */
+#define MLAN_NETMON_NON_BSS_BCN MBIT(5)
+/* capture Tx frames */
+#define MLAN_NETMON_TX MBIT(6)
+
+typedef struct _mlan_ds_misc_net_monitor {
+	/** Enable/disable network monitor */
+	t_u32 enable_net_mon;
+	/** Set net monitor filer flag */
+	t_u32 filter_flag;
+	/** Radio type */
+	t_u32 band;
+	/** Channel */
+	t_u32 channel;
+	/** Secondary channel bandwidth */
+	t_u32 chan_bandwidth;
+} mlan_ds_misc_net_monitor;
+
 /** Type definition of mlan_ds_misc_tx_datapause
  * for MLAN_OID_MISC_TX_DATAPAUSE
  */
@@ -4224,6 +4553,15 @@ typedef struct _mlan_ds_misc_rx_abort_cfg {
 	/** Rx weak RSSI pkt threshold */
 	t_s8 rssi_threshold;
 } mlan_ds_misc_rx_abort_cfg;
+/** Type definition of mlan_ds_misc_ofdm_desense_cfg
+ * for MLAN_OID_MISC_OFDM_DESENSE_CFG
+ */
+typedef struct _mlan_ds_misc_ofdm_desense_cfg {
+	/** enable/disable ofdm desense cfg */
+	t_u8 enable;
+	/** OFDM  CCA pkt threshold */
+	t_s8 cca_threshold;
+} mlan_ds_misc_ofdm_desense_cfg;
 
 /** Type definition of mlan_ds_misc_rx_abort_cfg_ext
  * for MLAN_OID_MISC_RX_ABORT_CFG_EXT
@@ -4235,6 +4573,14 @@ typedef struct _mlan_ds_misc_rx_abort_cfg_ext {
 	t_s8 rssi_margin;
 	/** specify ceil rssi threshold */
 	t_s8 ceil_rssi_threshold;
+	/** specify floor rssi threshold */
+	t_s8 floor_rssi_threshold;
+	/** current dynamic rssi threshold */
+	t_s8 current_dynamic_rssi_threshold;
+	/** rssi config: default or user configured */
+	t_u8 rssi_default_config;
+	/** EDMAC status */
+	t_u8 edmac_enable;
 } mlan_ds_misc_rx_abort_cfg_ext;
 
 /** Type definition of mlan_ds_misc_rx_abort_cfg_ext
@@ -4296,8 +4642,13 @@ typedef struct _mlan_ds_misc_cck_desense_cfg {
 #define IPADDR_TYPE_IPV4 (1)
 /** IP operation remove */
 #define MLAN_IPADDR_OP_IP_REMOVE (0)
+/** IP operation ARP filter */
+#define MLAN_IPADDR_OP_ARP_FILTER MBIT(0)
 /** IP operation ARP response */
 #define MLAN_IPADDR_OP_AUTO_ARP_RESP MBIT(1)
+/** Enable opcode bit for MDNS & NS when device enter into suspend **/
+#define MLAN_OP_ADD_MDNS MBIT(2)
+#define MLAN_OP_ADD_IPV6_NS MBIT(3)
 
 /** Type definition of mlan_ds_misc_ipaddr_cfg for MLAN_OID_MISC_IP_ADDR */
 typedef struct _mlan_ds_misc_ipaddr_cfg {
@@ -4311,6 +4662,14 @@ typedef struct _mlan_ds_misc_ipaddr_cfg {
 	t_u8 ip_addr[MAX_IPADDR][IPADDR_LEN];
 } mlan_ds_misc_ipaddr_cfg;
 
+/** Type definnition of mlan_ds_misc_ipv6_ra_offload for
+ * MLAN_OID_MISC_IPV6_RA_OFFLOAD*/
+typedef struct _mlan_ds_misc_ipv6_ra_offload {
+	/** 0: disable; 1: enable*/
+	t_u8 enable;
+	t_u8 ipv6_addr[16];
+} mlan_ds_misc_ipv6_ra_offload;
+
 /* MEF configuration disable */
 #define MEF_CFG_DISABLE 0
 /* MEF configuration Rx filter enable */
@@ -4347,6 +4706,16 @@ typedef struct _mlan_ds_misc_arb_cfg {
 	t_u32 arb_mode;
 } mlan_ds_misc_arb_cfg;
 
+/** Type definition of mlan_ds_misc_tp_state
+ *  for MLAN_OID_MISC_TP_STATE
+ */
+typedef struct _mlan_ds_misc_tp_state {
+	/** TP account mode 0-disable 1-enable */
+	t_u32 on;
+	/** Packet drop point */
+	t_u32 drop_point;
+} mlan_ds_misc_tp_state;
+
 /** Type definition of mlan_ds_misc_country_code
  *  for MLAN_OID_MISC_COUNTRY_CODE
  */
@@ -4483,7 +4852,17 @@ typedef struct _mlan_ds_misc_otp_user_data {
 	t_u8 user_data[MAX_OTP_USER_DATA_LEN];
 } mlan_ds_misc_otp_user_data;
 
-typedef struct _aggr_ctrl {
+/** Type definition of mlan_ds_fw_reconnect for MLAN_OID_MISC_AUTO_ASSOC */
+typedef struct _mlan_ds_fw_reconnect {
+	/* fw auto re-connect counter */
+	t_u8 fw_reconn_counter;
+	/* fw auto re-connect interval */
+	t_u8 fw_reconn_interval;
+	/* fw auto re-connect flags */
+	t_u16 fw_reconn_flags;
+} mlan_ds_fw_reconnect;
+
+typedef struct _aggr_ctrl_cfg {
 	/** Enable */
 	t_u16 enable;
 	/** Aggregation alignment */
@@ -4494,18 +4873,18 @@ typedef struct _aggr_ctrl {
 	t_u16 aggr_max_num;
 	/** Aggrgation timeout, in microseconds */
 	t_u16 aggr_tmo;
-} aggr_ctrl;
+} aggr_ctrl_cfg;
 
 /** Type definition of mlan_ds_misc_aggr_ctrl
  *  for MLAN_OID_MISC_AGGR_CTRL
  */
 typedef struct _mlan_ds_misc_aggr_ctrl {
 	/** Tx aggregation control */
-	aggr_ctrl tx;
+	aggr_ctrl_cfg tx;
 } mlan_ds_misc_aggr_ctrl;
 
 #ifdef USB
-typedef struct _usb_aggr_ctrl {
+typedef struct _usb_aggr_ctrl_cfg {
 	/** Enable */
 	t_u16 enable;
 	/** Aggregation mode */
@@ -4516,16 +4895,16 @@ typedef struct _usb_aggr_ctrl {
 	t_u16 aggr_max;
 	/** Aggrgation timeout, in microseconds */
 	t_u16 aggr_tmo;
-} usb_aggr_ctrl;
+} usb_aggr_ctrl_cfg;
 
 /** Type definition of mlan_ds_misc_usb_aggr_ctrl
  *  for MLAN_OID_MISC_USB_AGGR_CTRL
  */
 typedef struct _mlan_ds_misc_usb_aggr_ctrl {
 	/** Tx aggregation control */
-	usb_aggr_ctrl tx_aggr_ctrl;
+	usb_aggr_ctrl_cfg tx_aggr_ctrl;
 	/** Rx deaggregation control */
-	usb_aggr_ctrl rx_deaggr_ctrl;
+	usb_aggr_ctrl_cfg rx_deaggr_ctrl;
 } mlan_ds_misc_usb_aggr_ctrl;
 #endif
 
@@ -4557,6 +4936,33 @@ typedef struct _mlan_ds_wifi_direct_config {
 } mlan_ds_wifi_direct_config;
 #endif
 
+/** Type definition of mlan_ds_gpio_tsf_latch */
+typedef struct _mlan_ds_gpio_tsf_latch {
+	/**clock sync Mode */
+	t_u8 clock_sync_mode;
+	/**clock sync Role */
+	t_u8 clock_sync_Role;
+	/**clock sync GPIO Pin Number */
+	t_u8 clock_sync_gpio_pin_number;
+	/**clock sync GPIO Level or Toggle */
+	t_u8 clock_sync_gpio_level_toggle;
+	/**clock sync GPIO Pulse Width */
+	t_u16 clock_sync_gpio_pulse_width;
+} mlan_ds_gpio_tsf_latch;
+
+/** Type definition of mlan_ds_tsf_info */
+typedef struct _mlan_ds_tsf_info {
+	/**get tsf info format */
+	t_u16 tsf_format;
+	/**tsf info */
+	t_u16 tsf_info;
+	/**tsf */
+	t_u64 tsf;
+	/**Positive or negative offset in microsecond from Beacon TSF to GPIO
+	 * toggle TSF  */
+	t_s32 tsf_offset;
+} mlan_ds_tsf_info;
+
 #if defined(STA_SUPPORT)
 typedef struct _mlan_ds_misc_pmfcfg {
 	/** Management Frame Protection Capable */
@@ -4566,17 +4972,278 @@ typedef struct _mlan_ds_misc_pmfcfg {
 } mlan_ds_misc_pmfcfg;
 #endif
 
+typedef MLAN_PACK_START struct _mlan_ds_multi_chan_cfg {
+	/** Channel Time */
+	t_u32 channel_time;
+	/** Buffer Weight */
+	t_u8 buffer_weight;
+	/** tlv len */
+	t_u16 tlv_len;
+	/** TLV buffer */
+	t_u8 tlv_buf[];
+} MLAN_PACK_END mlan_ds_multi_chan_cfg;
+
+typedef MLAN_PACK_START struct _mlan_ds_drcs_cfg {
+	/** Channel Index*/
+	t_u16 chan_idx;
+	/** Channel time (in TU) for chan_idx */
+	t_u8 chantime;
+	/** Channel swith time (in TU) for chan_idx */
+	t_u8 switchtime;
+	/** Undoze time (in TU) for chan_idx */
+	t_u8 undozetime;
+	/** Rx traffic control scheme when channel switch*/
+	/** only valid for GC/STA interface*/
+	t_u8 mode;
+} MLAN_PACK_END mlan_ds_drcs_cfg;
+
 #define MAX_SSID_NUM 16
 #define MAX_AP_LIST 8
-
-#ifdef RX_PACKET_COALESCE
-typedef struct _mlan_ds_misc_rx_packet_coalesce {
-	/** packet threshold */
-	t_u32 packet_threshold;
-	/** timeout value */
-	t_u16 delay;
-} mlan_ds_misc_rx_packet_coalesce;
-#endif
+#define RETRY_UNLIMITED_TIME 0xFF
+
+#define FW_ROAM_ENABLE MBIT(0)
+#define FW_ROAM_TRIGGER_COND MBIT(1)
+#define FW_ROAM_BSSID MBIT(2)
+#define FW_ROAM_SSID MBIT(3)
+#define FW_ROAM_RETRY_COUNT MBIT(4)
+#define FW_ROAM_RSSI_PARA MBIT(5)
+#define FW_ROAM_BAND_RSSI MBIT(6)
+#define FW_ROAM_BGSCAN_PARAM MBIT(7)
+#define FW_ROAM_EES_PARAM MBIT(8)
+#define FW_ROAM_BCN_MISS_THRESHOLD MBIT(9)
+#define FW_ROAM_PRE_BCN_MISS_THRESHOLD MBIT(10)
+#define FW_ROAM_BLACKLIST MBIT(11)
+#define FW_ROAM_REPEAT_CNT MBIT(12)
+
+/*Roam offload configuration for auto reconnection when suspend and resume*/
+typedef enum _roam_offload_config_mode {
+	ROAM_OFFLOAD_ENABLE = 1,
+	ROAM_OFFLOAD_SUSPEND_CFG,
+	ROAM_OFFLOAD_RESUME_CFG,
+	ROAM_OFFLOAD_PARAM_CFG,
+} roam_offload_config_mode;
+
+typedef enum _roam_offload_set_mode {
+	ROAM_OFFLOAD_DISABLE = 0,
+	ROAM_OFFLOAD_WITH_APLIST,
+	ROAM_OFFLOAD_WITHOUT_APLIST,
+	ROAM_OFFLOAD_WITH_BSSID,
+	ROAM_OFFLOAD_WITH_SSID,
+	AUTO_RECONNECT,
+} roam_offload_set_mode;
+
+typedef enum _roam_offload_trigger_mode {
+	NO_TRIGGER = 0x00,
+	RSSI_LOW_TRIGGER = 0x01,
+	PRE_BEACON_LOST_TRIGGER = 0x02,
+	LINK_LOST_TRIGGER = 0x04,
+	DEAUTH_WITH_EXT_AP_TRIGGER = 0x08,
+} roam_offload_trigger_mode;
+
+/** mlan_ds_misc_ees_cfg structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_ees_cfg {
+	/* EES mode*/
+	t_u16 ees_mode;
+	/* EES report condition*/
+	t_u16 ees_rpt_condition;
+	/* High scan period(milliseconds)*/
+	t_u16 high_scan_period;
+	/* High scan count*/
+	t_u16 high_scan_count;
+	/* Middle scan period(milliseconds)*/
+	t_u16 mid_scan_period;
+	/* Middle scan count*/
+	t_u16 mid_scan_count;
+	/* Low scan period(milliseconds)*/
+	t_u16 low_scan_period;
+	/* Low scan count*/
+	t_u16 low_scan_count;
+} MLAN_PACK_END mlan_ds_misc_ees_cfg;
+
+/** mlan_ds_misc_bgscan_cfg structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_bgscan_cfg {
+	/* BSS Type  0x1-bss independent, 0x2-bss infrastructure, 0x3-bss any*/
+	t_u8 bss_type;
+	/* Number of channels scanned for each scan*/
+	t_u8 channels_per_scan;
+	/* Interval between consective scans*/
+	t_u32 scan_interval;
+	/* Conditons to trigger report to host*/
+	t_u32 bg_rpt_condition;
+} MLAN_PACK_END mlan_ds_misc_bgscan_cfg;
+
+/** mlan_ds_misc_band_rssi structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_band_rssi {
+	/* RSSI hysteresis*/
+	t_u8 rssi_hysteresis;
+	/*  Preferred channel band for fw roaming
+	 *  0:2.4G band; 1: 5G band; 2:4G band; 0xFF:band not set(invalid)
+	 */
+	t_u8 band_preferred;
+} MLAN_PACK_END mlan_ds_misc_band_rssi;
+
+/** mlan_ds_misc_ssid_list structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_ssid_list {
+	/* SSID number*/
+	t_u8 ssid_num;
+	/* SSID for fw roaming/auto_reconnect*/
+	mlan_802_11_ssid ssids[MAX_SSID_NUM];
+} MLAN_PACK_END mlan_ds_misc_ssid_list;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload_aplist {
+	/** Number of AP**/
+	t_u8 ap_num;
+	/** AP mac addrs**/
+	t_u8 ap_mac[MAX_AP_LIST][MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END mlan_ds_misc_roam_offload_aplist;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload_para_rssi {
+	/** Setting flag**/
+	t_u8 set_flag;
+	/** Max value of RSSI threshold**/
+	t_u8 max_rssi;
+	/** Min value of RSSI threshold**/
+	t_u8 min_rssi;
+	/** Adjusting step value of RSSI threshold**/
+	t_u8 step_rssi;
+} MLAN_PACK_END mlan_ds_misc_roam_offload_para_rssi;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload {
+	/** Enable roam offload**/
+	t_u8 enable;
+	/** User set passphrase**/
+	t_u8 userset_passphrase;
+	/* Condition to trigger roaming
+	 * Bit0 : RSSI low trigger
+	 * Bit1 : Pre-beacon lost trigger
+	 * Bit2 : Link Lost trigger
+	 * Bit3 : Deauth by ext-AP trigger
+	 * Bit4 ~ Bit15 : Reserved
+	 * value 0 : no trigger
+	 * value 0xff : invalid
+	 */
+	t_u16 trigger_condition;
+	/** AP list**/
+	mlan_ds_misc_roam_offload_aplist aplist;
+	/*Roam offload configuration mode for auto connection when suspend and
+	 * resume*/
+	roam_offload_config_mode config_mode;
+	/** Retry count**/
+	t_u8 retry_count;
+	/** RSSI para**/
+	mlan_ds_misc_roam_offload_para_rssi para_rssi;
+	/** BSSID of reconnection**/
+	mlan_802_11_mac_addr bssid_reconnect;
+	/* SSID List(White list)*/
+	mlan_ds_misc_ssid_list ssid_list;
+	/* Black list(BSSID list)*/
+	mlan_ds_misc_roam_offload_aplist black_list;
+	/* BAND and RSSI_HYSTERESIS set flag*/
+	t_u8 band_rssi_flag;
+	mlan_ds_misc_band_rssi band_rssi;
+
+	/* BGSCAN params set flag*/
+	t_u8 bgscan_set_flag;
+	mlan_ds_misc_bgscan_cfg bgscan_cfg;
+
+	/* EES mode params set flag*/
+	t_u8 ees_param_set_flag;
+	mlan_ds_misc_ees_cfg ees_cfg;
+
+	/* Beacon miss threshold*/
+	t_u8 bcn_miss_threshold;
+
+	/* Beacon miss threshold*/
+	t_u8 pre_bcn_miss_threshold;
+
+	/* Scan repeat count*/
+	t_u16 repeat_count;
+} MLAN_PACK_END mlan_ds_misc_roam_offload;
+
+/**Action ID for TDLS disable link*/
+#define WLAN_TDLS_DISABLE_LINK 0x00
+/**Action ID for TDLS enable link*/
+#define WLAN_TDLS_ENABLE_LINK 0x01
+/**Action ID for TDLS create link*/
+#define WLAN_TDLS_CREATE_LINK 0x02
+/**Action ID for TDLS config link*/
+#define WLAN_TDLS_CONFIG_LINK 0x03
+/*reason code*/
+#define MLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED 26
+/** TDLS operation buffer */
+typedef struct _mlan_ds_misc_tdls_oper {
+	/** TDLS Action */
+	t_u16 tdls_action;
+	/** TDLS peer address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** peer capability */
+	t_u16 capability;
+	/** peer qos info */
+	t_u8 qos_info;
+	/** peer extend capability */
+	t_u8 *ext_capab;
+	/** extend capability len */
+	t_u8 ext_capab_len;
+	/** support rates */
+	t_u8 *supported_rates;
+	/** supported rates len */
+	t_u8 supported_rates_len;
+	/** peer ht_cap */
+	t_u8 *ht_capa;
+	/** peer vht capability */
+	t_u8 *vht_cap;
+} mlan_ds_misc_tdls_oper;
+
+/** flag for TDLS extcap */
+#define TDLS_IE_FLAGS_EXTCAP 0x0001
+/** flag for TDLS HTCAP */
+#define TDLS_IE_FLAGS_HTCAP 0x0002
+/** flag for TDLS HTINFO */
+#define TDLS_IE_FLAGS_HTINFO 0x0004
+/** flag for TDLS VHTCAP */
+#define TDLS_IE_FLAGS_VHTCAP 0x0008
+/** flag for TDLS VHTOPRAT */
+#define TDLS_IE_FLAGS_VHTOPRAT 0x0010
+/** flag for TDLS AID inof */
+#define TDLS_IE_FLAGS_AID 0x0020
+/** flag for TDLS Supported channels and regulatory class IE*/
+#define TDLS_IE_FLAGS_SUPP_CS_IE 0x0040
+/** flag for TDLS Qos info */
+#define TDLS_IE_FLAGS_QOS_INFO 0x0080
+/** flag for TDLS SETUP */
+#define TDLS_IE_FLAGS_SETUP 0x0100
+#define TDLS_IE_FLAGS_HECAP 0x0200
+#define TDLS_IE_FLAGS_HEOP 0x0400
+
+/** TDLS ie buffer */
+typedef struct _mlan_ds_misc_tdls_ies {
+	/** TDLS peer address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** flags for request IEs */
+	t_u16 flags;
+	/** Qos info */
+	t_u8 QosInfo;
+	/** Extended Capabilities IE */
+	t_u8 ext_cap[IEEE_MAX_IE_SIZE];
+	/** HT Capabilities IE */
+	t_u8 ht_cap[IEEE_MAX_IE_SIZE];
+	/** HT Information IE */
+	t_u8 ht_info[IEEE_MAX_IE_SIZE];
+	/** VHT Capabilities IE */
+	t_u8 vht_cap[IEEE_MAX_IE_SIZE];
+	/** VHT Operations IE */
+	t_u8 vht_oprat[IEEE_MAX_IE_SIZE];
+	/** aid Info */
+	t_u8 aid_info[IEEE_MAX_IE_SIZE];
+	/** HE Capabilities IE */
+	t_u8 he_cap[IEEE_MAX_IE_SIZE];
+	/** HE Operation IE */
+	t_u8 he_op[IEEE_MAX_IE_SIZE];
+	/** supported channels */
+	t_u8 supp_chan[IEEE_MAX_IE_SIZE];
+	/** supported regulatory class */
+	t_u8 regulatory_class[IEEE_MAX_IE_SIZE];
+} mlan_ds_misc_tdls_ies;
 
 typedef struct _mlan_ds_misc_dfs_repeater {
 	/** Set or Get */
@@ -4682,6 +5349,8 @@ typedef struct _mef_entry_t {
 typedef struct _mlan_ds_misc_mef_flt_cfg {
 	/** Type of action*/
 	int mef_act_type;
+	/** Operation code*/
+	t_u32 op_code;
 	/** NV Filter Criteria*/
 	t_u32 criteria;
 	/** NV MEF entry*/
@@ -4752,6 +5421,21 @@ typedef struct _mlan_ds_misc_keep_alive {
 	t_u16 ether_type;
 } mlan_ds_misc_keep_alive, *pmlan_ds_misc_keep_alive;
 
+#define MKEEP_ALIVE_ACK_PKT_MAX 100
+typedef struct _mlan_ds_misc_keep_alive_rx {
+	t_u8 mkeep_alive_id;
+	t_u8 enable;
+	/** enable/disable tcp reset*/
+	t_u8 reset;
+	/**True means saved in driver, false means not saved or download*/
+	t_u8 cached;
+	t_u8 dst_mac[MLAN_MAC_ADDR_LENGTH];
+	t_u8 src_mac[MLAN_MAC_ADDR_LENGTH];
+	t_u16 pkt_len;
+	t_u8 packet[MKEEP_ALIVE_ACK_PKT_MAX];
+	/** Ethernet type */
+	t_u16 ether_type;
+} mlan_ds_misc_keep_alive_rx, *pmlan_ds_misc_keep_alive_rx;
 /** TX and RX histogram statistic parameters*/
 typedef MLAN_PACK_START struct _mlan_ds_misc_tx_rx_histogram {
 	/** Enable or disable get tx/rx histogram statistic */
@@ -4806,6 +5490,115 @@ typedef struct _mlan_ds_misc_robustcoex_params {
 	t_u8 gpio_polarity;
 } mlan_ds_misc_robustcoex_params;
 
+/** RTT configuration */
+typedef struct _mlan_rtt_config {
+	/** peer device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** 1-sided or 2-sided RTT */
+	t_u8 type;
+	/** optional - peer device hint (STA, P2P, AP) */
+	t_u8 peer;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	t_u8 channel;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	Band_Config_t bandcfg;
+	/** Time interval between bursts (units: 100 ms).
+	 * Applies to 1-sided and 2-sided RTT multi-burst requests.
+	 * Range: 0-31, 0: no preference by initiator (2-sided RTT) */
+	t_u8 burst_period;
+	/** Total number of RTT bursts to be executed. It will be
+	 * specified in the same way as the parameter "Number of
+	 * Burst Exponent" found in the FTM frame format. It
+	 * applies to both: 1-sided RTT and 2-sided RTT. Valid
+	 * values are 0 to 15 as defined in 802.11mc std.
+	 * 0 means single shot
+	 * The implication of this parameter on the maximum
+	 * number of RTT results is the following:
+	 * for 1-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst)
+	 * for 2-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst - 1) */
+	t_u8 num_burst;
+	/** num of frames per burst.
+	 * Minimum value = 1, Maximum value = 31
+	 * For 2-sided this equals the number of FTM frames
+	 * to be attempted in a single burst. This also
+	 * equals the number of FTM frames that the
+	 * initiator will request that the responder send
+	 * in a single frame. */
+	t_u8 num_frames_per_burst;
+	/** number of retries for a failed RTT frame. Applies
+	 * to 1-sided RTT only. Minimum value = 0, Maximum value = 3 */
+	t_u8 num_retries_per_rtt_frame;
+
+	/** following fields are only valid for 2-side RTT */
+	/** Maximum number of retries that the initiator can
+	 * retry an FTMR frame.
+	 * Minimum value = 0, Maximum value = 3 */
+	t_u8 num_retries_per_ftmr;
+	/** 1: request LCI, 0: do not request LCI */
+	t_u8 LCI_request;
+	/** 1: request LCR, 0: do not request LCR */
+	t_u8 LCR_request;
+	/** Applies to 1-sided and 2-sided RTT. Valid values will
+	 * be 2-11 and 15 as specified by the 802.11mc std for
+	 * the FTM parameter burst duration. In a multi-burst
+	 * request, if responder overrides with larger value,
+	 * the initiator will return failure. In a single-burst
+	 * request if responder overrides with larger value,
+	 * the initiator will sent TMR_STOP to terminate RTT
+	 * at the end of the burst_duration it requested. */
+	t_u8 burst_duration;
+	/** RTT preamble to be used in the RTT frames */
+	t_u8 preamble;
+	/** RTT BW to be used in the RTT frames */
+	t_u8 bw;
+} mlan_rtt_config, *pmlan_rtt_config;
+
+/** RTT config params */
+typedef struct _mlan_rtt_config_params {
+	t_u8 rtt_config_num;
+	mlan_rtt_config rtt_config[MAX_RTT_CONFIG_NUM];
+} mlan_rtt_config_params;
+
+/** RTT cancel params */
+typedef struct _mlan_rtt_cancel_params {
+	t_u8 rtt_cancel_num;
+	t_u8 rtt_cancel[MAX_RTT_CONFIG_NUM][MLAN_MAC_ADDR_LENGTH];
+} mlan_rtt_cancel_params;
+
+/** RTT responder info */
+typedef struct _rtt_responder_info {
+	t_u8 channel;
+	Band_Config_t bandcfg;
+	t_u8 preamble;
+} rtt_responder_info;
+
+/** RTT responder enable configure */
+typedef struct _rtt_responder_encfg {
+	t_u8 channel;
+	Band_Config_t bandcfg;
+	t_u32 max_dur_sec;
+} rtt_responder_encfg;
+
+/** Define for mlan_rtt_responder.action */
+#define RTT_GET_RESPONDER_INFO 0
+#define RTT_SET_RESPONDER_ENABLE 1
+#define RTT_SET_RESPONDER_DISABLE 2
+#define RTT_SET_RESPONDER_LCI 3
+#define RTT_SET_RESPONDER_LCR 4
+
+/** RTT responder configure for MLAN_OID_MISC_RTT_RESPONDER_CFG */
+typedef struct _mlan_rtt_responder {
+	t_u8 action;
+	union {
+		rtt_responder_info info;
+		rtt_responder_encfg encfg;
+		wifi_lci_information lci;
+		wifi_lcr_information lcr;
+	} u;
+} mlan_rtt_responder;
+
 #if defined(PCIE)
 typedef struct _mlan_ds_ssu_params {
 	t_u32 nskip;
@@ -4819,6 +5612,41 @@ typedef struct _mlan_ds_ssu_params {
 } mlan_ds_ssu_params;
 #endif
 
+#define CSI_FILTER_MAX 16
+/** Structure of CSI filters */
+typedef MLAN_PACK_START struct _mlan_csi_filter_t {
+	/** Source address of the packet to receive */
+	t_u8 mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Pakcet type of the interested CSI */
+	t_u8 pkt_type;
+	/* Packet subtype of the interested CSI */
+	t_u8 subtype;
+	/* Other filter flags */
+	t_u8 flags;
+} MLAN_PACK_END mlan_csi_filter_t;
+/** Structure of CSI parameters */
+typedef MLAN_PACK_START struct _mlan_ds_csi_params {
+	/** CSI enable flag. 1: enable, 0: disable */
+	t_u16 csi_enable;
+	/** Header ID*/
+	t_u32 head_id;
+	/** Tail ID */
+	t_u32 tail_id;
+	/** Number of CSI filters */
+	t_u8 csi_filter_cnt;
+	/** Chip ID */
+	t_u8 chip_id;
+	/** CSI filters */
+	mlan_csi_filter_t csi_filter[CSI_FILTER_MAX];
+} MLAN_PACK_END mlan_ds_csi_params;
+
+typedef MLAN_PACK_START struct _mlan_ds_hal_phy_cfg_params {
+	/** 11b pwr spectral density mask enable/disable */
+	t_u8 dot11b_psd_mask_cfg;
+	/** reserved fields for future hal/phy cfg use */
+	t_u8 reserved[7];
+} MLAN_PACK_END mlan_ds_hal_phy_cfg_params;
+
 #define MAX_NUM_MAC 2
 /** Type definition of mlan_ds_misc_mapping_policy */
 typedef struct _mlan_ds_misc_mapping_policy {
@@ -4878,6 +5706,9 @@ typedef struct _mlan_ds_misc_chan_trpc_cfg {
 #define MFG_CMD_RFPWR 0x1033
 #define MFG_CMD_RF_BAND_AG 0x1034
 #define MFG_CMD_RF_CHANNELBW 0x1044
+#define MFG_CMD_RADIO_MODE_CFG 0x1211
+#define MFG_CMD_CONFIG_MAC_HE_TB_TX 0x110A
+#define MFG_CMD_CONFIG_TRIGGER_FRAME 0x110C
 /** MFG CMD generic cfg */
 struct MLAN_PACK_START mfg_cmd_generic_cfg {
 	/** MFG command code */
@@ -4936,6 +5767,21 @@ struct MLAN_PACK_START mfg_cmd_tx_frame2 {
 	t_u32 stbc;
 	/** power id */
 	t_u32 rsvd[2];
+	/** NumPkt */
+	t_u32 NumPkt;
+	/** MaxPE */
+	t_u32 MaxPE;
+	/** BeamChange */
+	t_u32 BeamChange;
+	/** Dcm */
+	t_u32 Dcm;
+	/** Doppler */
+	t_u32 Doppler;
+	/** MidP */
+	t_u32 MidP;
+	/** QNum */
+	t_u32 QNum;
+
 } MLAN_PACK_END;
 
 /* MFG CMD Tx Continuous */
@@ -4964,6 +5810,199 @@ struct MLAN_PACK_START mfg_cmd_tx_cont {
 	t_u32 rsvd;
 } MLAN_PACK_END;
 
+struct MLAN_PACK_START mfg_Cmd_HE_TBTx_t {
+	/** MFG command code */
+	t_u32 mfg_cmd;
+	/** Action */
+	t_u16 action;
+	/** Device ID */
+	t_u16 device_id;
+	/** MFG Error code */
+	t_u32 error;
+	/** Enable Tx */
+	t_u16 enable;
+	/** Q num */
+	t_u16 qnum;
+	/** AID */
+	t_u16 aid;
+	/** AXQ Mu Timer */
+	t_u16 axq_mu_timer;
+	/** Tx Power */
+	t_s16 tx_power;
+} MLAN_PACK_END;
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigComInfo_t {
+	t_u64 reserved : 1;
+	t_u64 he_sig2 : 9;
+	t_u64 doppler : 1;
+	t_u64 spatial_reuse : 16;
+	t_u64 pe_disambig : 1;
+	t_u64 pre_fec_pad_fct : 2;
+	t_u64 ap_tx_pwr : 6;
+
+	t_u64 ldpc_ess : 1;
+	t_u64 ul_stbc : 1;
+	t_u64 ltf_symbol : 3;
+	t_u64 ltf_mode : 1;
+	t_u64 ltf_type : 2;
+
+	t_u64 ul_bw : 2;
+	t_u64 cs_required : 1;
+	t_u64 more_tf : 1;
+	t_u64 ul_len : 12;
+	t_u64 trigger_type : 4;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigComInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigComInfo_t {
+	t_u64 trigger_type : 4;
+	t_u64 ul_len : 12;
+	t_u64 more_tf : 1;
+	t_u64 cs_required : 1;
+	t_u64 ul_bw : 2;
+
+	t_u64 ltf_type : 2;
+	t_u64 ltf_mode : 1;
+	t_u64 ltf_symbol : 3;
+	t_u64 ul_stbc : 1;
+	t_u64 ldpc_ess : 1;
+
+	t_u64 ap_tx_pwr : 6;
+	t_u64 pre_fec_pad_fct : 2;
+	t_u64 pe_disambig : 1;
+	t_u64 spatial_reuse : 16;
+	t_u64 doppler : 1;
+	t_u64 he_sig2 : 9;
+	t_u64 reserved : 1;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigComInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigUserInfo_t {
+	t_u8 reserved : 1;
+	t_u8 ul_target_rssi : 7;
+	t_u32 ss_alloc : 6;
+	t_u32 ul_dcm : 1;
+	t_u32 ul_mcs : 4;
+	t_u32 ul_coding_type : 1;
+	t_u32 ru_alloc : 7;
+	t_u32 ru_alloc_reg : 1;
+	t_u32 aid12 : 12;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigUserInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigUserInfo_t {
+	t_u32 aid12 : 12;
+	t_u32 ru_alloc_reg : 1;
+	t_u32 ru_alloc : 7;
+	t_u32 ul_coding_type : 1;
+	t_u32 ul_mcs : 4;
+	t_u32 ul_dcm : 1;
+	t_u32 ss_alloc : 6;
+	t_u8 ul_target_rssi : 7;
+	t_u8 reserved : 1;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigUserInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEETypes_BasicHETrigUserInfo_t {
+	t_u8 pref_ac : 2;
+	t_u8 ac_pl : 1;
+	t_u8 tid_al : 3;
+	t_u8 mpdu_mu_sf : 2;
+} MLAN_PACK_END mfg_cmd_IEEETypes_BasicHETrigUserInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEETypes_BasicHETrigUserInfo_t {
+	t_u8 mpdu_mu_sf : 2;
+	t_u8 tid_al : 3;
+	t_u8 ac_pl : 1;
+	t_u8 pref_ac : 2;
+} MLAN_PACK_END mfg_cmd_IEEETypes_BasicHETrigUserInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_FrameCtrl_t {
+	/** Order */
+	t_u8 order : 1;
+	/** Wep */
+	t_u8 wep : 1;
+	/** More Data */
+	t_u8 more_data : 1;
+	/** Power Mgmt */
+	t_u8 pwr_mgmt : 1;
+	/** Retry */
+	t_u8 retry : 1;
+	/** More Frag */
+	t_u8 more_frag : 1;
+	/** From DS */
+	t_u8 from_ds : 1;
+	/** To DS */
+	t_u8 to_ds : 1;
+	/** Sub Type */
+	t_u8 sub_type : 4;
+	/** Type */
+	t_u8 type : 2;
+	/** Protocol Version */
+	t_u8 protocol_version : 2;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_FrameCtrl_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_FrameCtrl_t {
+	/** Protocol Version */
+	t_u8 protocol_version : 2;
+	/** Type */
+	t_u8 type : 2;
+	/** Sub Type */
+	t_u8 sub_type : 4;
+	/** To DS */
+	t_u8 to_ds : 1;
+	/** From DS */
+	t_u8 from_ds : 1;
+	/** More Frag */
+	t_u8 more_frag : 1;
+	/** Retry */
+	t_u8 retry : 1;
+	/** Power Mgmt */
+	t_u8 pwr_mgmt : 1;
+	/** More Data */
+	t_u8 more_data : 1;
+	/** Wep */
+	t_u8 wep : 1;
+	/** Order */
+	t_u8 order : 1;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_FrameCtrl_t;
+#endif
+
+typedef MLAN_PACK_START struct _mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t {
+	/** MFG command code */
+	t_u32 mfg_cmd;
+	/** Action */
+	t_u16 action;
+	/** Device ID */
+	t_u16 device_id;
+	/** MFG Error code */
+	t_u32 error;
+	/** enable Tx*/
+	t_u32 enable_tx;
+	/** enable Stand Alone HE TB */
+	t_u32 standalone_hetb;
+	/** Frame Control */
+	mfg_cmd_IEEEtypes_FrameCtrl_t frmCtl;
+	/** Duration */
+	t_u16 duration;
+	/** Destination MAC Address */
+	t_u8 dest_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Source MAC Address */
+	t_u8 src_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Common Info Field **/
+	mfg_cmd_IEEEtypes_HETrigComInfo_t trig_common_field;
+	/** User Info Field **/
+	mfg_cmd_IEEEtypes_HETrigUserInfo_t trig_user_info_field;
+	/** Trigger Dependent User Info Field **/
+	mfg_cmd_IEEETypes_BasicHETrigUserInfo_t basic_trig_user_info;
+} MLAN_PACK_END mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t;
+
 typedef struct _mlan_ds_misc_chnrgpwr_cfg {
 	/** length */
 	t_u16 length;
@@ -4981,6 +6020,61 @@ typedef struct _mlan_ds_misc_cfp_tbl {
 	chan_freq_power_t cfp_tbl[];
 } mlan_ds_misc_cfp_tbl;
 
+/** mlan_ds_mc_aggr_cfg for MLAN_OID_MISC_MC_AGGR_CFG */
+typedef struct _mlan_ds_mc_aggr_cfg {
+	/** action */
+	t_u8 action;
+	/* 1 enable, 0 disable
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 enable_bitmap;
+	/* 1 valid, 0 invalid
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 mask_bitmap;
+	/** CTS2Self duration offset */
+	t_u16 cts2self_offset;
+} mlan_ds_mc_aggr_cfg;
+
+/** mlan_ds_stats */
+typedef struct _mlan_ds_stats {
+	/** action */
+	t_u16 action;
+	/** tlv len */
+	t_u16 tlv_len;
+	/** TLV buffer */
+	t_u8 tlv_buf[1];
+} mlan_ds_stats;
+
+typedef struct _mlan_ds_ch_load {
+	/** action */
+	t_u8 action;
+	t_u16 ch_load_param;
+	t_s16 noise;
+	t_u16 rx_quality;
+	t_u16 duration;
+} mlan_ds_ch_load;
+
+/** Type definition of mlan_ds_cross_chip_synch */
+typedef struct _mlan_ds_cross_chip_synch {
+	/**cross chip sync action 0-GET, 1-SET */
+	t_u16 action;
+	/**cross chip sync start or stop */
+	t_u8 start_stop;
+	/**cross chip sync role, master or slave */
+	t_u8 role;
+	/**cross chip sync periodicty of toggle in us */
+	t_u32 period;
+	/**cross chip sync initial TSF low */
+	t_u32 init_tsf_low;
+	/**cross chip sync intial TSF high */
+	t_u32 init_tsf_high;
+} mlan_ds_cross_chip_synch;
+
 /** Type definition of mlan_ds_misc_cfg for MLAN_IOCTL_MISC_CFG */
 typedef struct _mlan_ds_misc_cfg {
 	/** Sub-command */
@@ -5003,16 +6097,31 @@ typedef struct _mlan_ds_misc_cfg {
 		t_u32 wws_cfg;
 		/** Get associate response for MLAN_OID_MISC_ASSOC_RSP */
 		mlan_ds_misc_assoc_rsp assoc_resp;
+		/** Get associate request for MLAN_OID_MISC_ASSOC_REQ */
+		mlan_ds_misc_assoc_req assoc_req;
 		/** Function init/shutdown for MLAN_OID_MISC_INIT_SHUTDOWN */
 		t_u32 func_init_shutdown;
 		/** Custom IE for MLAN_OID_MISC_CUSTOM_IE */
 		mlan_ds_misc_custom_ie cust_ie;
+		t_u16 tdls_idle_time;
 		/** Config dynamic bandwidth*/
 		t_u16 dyn_bw;
+		/** TDLS configuration for MLAN_OID_MISC_TDLS_CONFIG */
+		mlan_ds_misc_tdls_config tdls_config;
+		/** TDLS operation for MLAN_OID_MISC_TDLS_OPER */
+		mlan_ds_misc_tdls_oper tdls_oper;
+		/** TDLS ies for  MLAN_OID_MISC_GET_TDLS_IES */
+		mlan_ds_misc_tdls_ies tdls_ies;
+		/**tdls cs off channel*/
+		t_u8 tdls_cs_channel;
+		/** Net monitor for MLAN_OID_MISC_NET_MONITOR */
+		mlan_ds_misc_net_monitor net_mon;
 		/** Tx data pause for MLAN_OID_MISC_TX_DATAPAUSE */
 		mlan_ds_misc_tx_datapause tx_datapause;
 		/** IP address configuration */
 		mlan_ds_misc_ipaddr_cfg ipaddr_cfg;
+		/** IPv6 Router Advertisement offload configuration */
+		mlan_ds_misc_ipv6_ra_offload ipv6_ra_offload;
 		/** MAC control for MLAN_OID_MISC_MAC_CONTROL */
 		t_u32 mac_ctrl;
 		/** MEF configuration for MLAN_OID_MISC_MEF_CFG */
@@ -5033,10 +6142,14 @@ typedef struct _mlan_ds_misc_cfg {
 #endif
 		/** Hotspot config param set */
 		t_u32 hotspot_cfg;
+		/** Multi AP flag */
+		t_u8 multi_ap_flag;
 #ifdef STA_SUPPORT
 		ExtCap_t ext_cap;
 #endif
 		mlan_ds_misc_otp_user_data otp_user_data;
+		/** fw re-connect cfg param set */
+		mlan_ds_fw_reconnect fw_auto_reconnect;
 #ifdef USB
 		/** USB aggregation parameters for MLAN_OID_MISC_USB_AGGR_CTRL
 		 */
@@ -5048,17 +6161,23 @@ typedef struct _mlan_ds_misc_cfg {
 #if defined(STA_SUPPORT)
 		mlan_ds_misc_pmfcfg pmfcfg;
 #endif
+		/** Multi-channel config for MLAN_OID_MISC_MULTI_CHAN_CFG */
+		mlan_ds_multi_chan_cfg multi_chan_cfg;
+		/** Multi-channel policy for MLAN_OID_MISC_MULTI_CHAN_POLICY */
+		t_u16 multi_chan_policy;
+		/** channel drcs time slicing config for MLAN_OID_MISC_DRCS_CFG
+		 */
+		mlan_ds_drcs_cfg drcs_cfg[2];
 #ifdef WIFI_DIRECT_SUPPORT
 		mlan_ds_wifi_direct_config p2p_config;
 #endif
+		mlan_ds_gpio_tsf_latch gpio_tsf_latch_config;
+		mlan_ds_tsf_info tsf_info;
 		mlan_ds_coalesce_cfg coalesce_cfg;
 		t_u8 low_pwr_mode;
 		/** MEF-FLT-CONFIG for MLAN_OID_MISC_NV_FLT_CFG */
 		mlan_ds_misc_mef_flt_cfg mef_flt_cfg;
 		mlan_ds_misc_dfs_repeater dfs_repeater;
-#ifdef RX_PACKET_COALESCE
-		mlan_ds_misc_rx_packet_coalesce rx_coalesce;
-#endif
 		/** FW reload flag */
 		t_u8 fw_reload;
 		mlan_ds_sensor_temp sensor_temp;
@@ -5066,23 +6185,34 @@ typedef struct _mlan_ds_misc_cfg {
 		mlan_ds_misc_gtk_rekey_data gtk_rekey;
 		mlan_ds_bw_chan_oper bw_chan_oper;
 		mlan_ds_ind_rst_cfg ind_rst_cfg;
+		/** Roam offload */
+		mlan_ds_misc_roam_offload roam_offload;
 		t_u64 misc_tsf;
 		mlan_ds_custom_reg_domain custom_reg_domain;
 		mlan_ds_misc_keep_alive keep_alive;
+		mlan_ds_misc_keep_alive_rx keep_alive_rx;
 		mlan_ds_misc_tx_rx_histogram tx_rx_histogram;
 		mlan_ds_cw_mode_ctrl cwmode;
 		/**  Tx/Rx per-packet control */
 		t_u8 txrx_pkt_ctrl;
 		mlan_ds_misc_robustcoex_params robustcoexparams;
+		/** config RTT for MLAN_OID_MISC_CONFIG_RTT */
+		mlan_rtt_config_params rtt_params;
+		/** cancel RTT for MLAN_OID_MISC_CANCEL_RTT */
+		mlan_rtt_cancel_params rtt_cancel;
+		/** config RTT responder for MLAN_OID_MISC_RTT_RESPONDER_CFG */
+		mlan_rtt_responder rtt_rsp_cfg;
 #if defined(PCIE)
 		mlan_ds_ssu_params ssu_params;
 #endif
+		mlan_ds_csi_params csi_params;
 		/** boot sleep enable or disable */
 		t_u16 boot_sleep;
 		/** Mapping Policy */
 		mlan_ds_misc_mapping_policy dmcs_policy;
 		mlan_ds_misc_dmcs_status dmcs_status;
 		mlan_ds_misc_rx_abort_cfg rx_abort_cfg;
+		mlan_ds_misc_ofdm_desense_cfg ofdm_desense_cfg;
 		mlan_ds_misc_rx_abort_cfg_ext rx_abort_cfg_ext;
 		mlan_ds_misc_tx_ampdu_prot_mode tx_ampdu_prot_mode;
 		mlan_ds_misc_rate_adapt_cfg rate_adapt_cfg;
@@ -5095,10 +6225,23 @@ typedef struct _mlan_ds_misc_cfg {
 		struct mfg_cmd_generic_cfg mfg_generic_cfg;
 		struct mfg_cmd_tx_cont mfg_tx_cont;
 		struct mfg_cmd_tx_frame2 mfg_tx_frame2;
+		struct mfg_Cmd_HE_TBTx_t mfg_he_power;
+		mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t mfg_tx_trigger_config;
 		mlan_ds_misc_arb_cfg arb_cfg;
 		mlan_ds_misc_cfp_tbl cfp;
 		t_u8 range_ext_mode;
+		mlan_ds_twt_report twt_report_info;
 		mlan_ds_misc_dot11mc_unassoc_ftm_cfg dot11mc_unassoc_ftm_cfg;
+		mlan_ds_misc_tp_state tp_state;
+		mlan_ds_hal_phy_cfg_params hal_phy_cfg_params;
+		mlan_ds_mc_aggr_cfg mc_aggr_cfg;
+		mlan_ds_stats stats;
+#ifdef UAP_SUPPORT
+		t_u8 wacp_mode;
+#endif
+		t_u32 ips_ctrl;
+		mlan_ds_ch_load ch_load;
+		mlan_ds_cross_chip_synch cross_chip_synch;
 	} param;
 } mlan_ds_misc_cfg, *pmlan_ds_misc_cfg;
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c
old mode 100644
new mode 100755
index 359e0319a..d6e77cd50
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.c
@@ -7,7 +7,7 @@
  *  to the firmware.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -282,7 +282,7 @@ static mlan_status wlan_get_common_rates(mlan_private *pmpriv, t_u8 *rate1,
 	ENTER();
 
 	ret = pcb->moal_malloc(pmpriv->adapter->pmoal_handle, rate1_size,
-			       MLAN_MEM_DEF, &tmp);
+			       MLAN_MEM_DEF | MLAN_MEM_FLAG_ATOMIC, &tmp);
 	if (ret != MLAN_STATUS_SUCCESS || !tmp) {
 		PRINTM(MERROR, "Failed to allocate buffer\n");
 		ret = MLAN_STATUS_FAILURE;
@@ -309,12 +309,13 @@ static mlan_status wlan_get_common_rates(mlan_private *pmpriv, t_u8 *rate1,
 	PRINTM(MINFO, "Tx DataRate is set to 0x%X\n", pmpriv->data_rate);
 
 	if (!pmpriv->is_data_rate_auto) {
-		while (*ptr) {
+		while (rate1_size && *ptr) {
 			if ((*ptr & 0x7f) == pmpriv->data_rate) {
 				ret = MLAN_STATUS_SUCCESS;
 				goto done;
 			}
 			ptr++;
+			rate1_size--;
 		}
 		PRINTM(MMSG,
 		       "Previously set fixed data rate %#x is not "
@@ -351,7 +352,7 @@ static mlan_status wlan_setup_rates_from_bssdesc(mlan_private *pmpriv,
 						 t_u8 *pout_rates,
 						 t_u32 *pout_rates_size)
 {
-	t_u8 card_rates[WLAN_SUPPORTED_RATES];
+	t_u8 card_rates[WLAN_SUPPORTED_RATES] = {0};
 	t_u32 card_rates_size = 0;
 	ENTER();
 	/* Copy AP supported rates */
@@ -550,33 +551,53 @@ static int wlan_cmd_append_osen_ie(mlan_private *priv, t_u8 **ppbuffer)
 /**
  *  @brief This function get the rsn_cap from RSN ie buffer.
  *
- *  @param pmpriv       A pointer to mlan_private structure
- *
  *  @param data         A pointer to rsn_ie data after IE header
+ *  @param len          Length of ie rsn_ie data after IE header
  *  @param return       rsn_cap
  */
-t_u16 wlan_get_rsn_cap(t_u8 *data)
+static t_u16 wlan_get_rsn_cap(t_u8 *data, t_u8 len)
 {
 	t_u16 rsn_cap = 0;
 	t_u16 *ptr;
+	t_u16 *end_ptr;
 	t_u16 pairwise_cipher_count = 0;
 	t_u16 akm_suite_count = 0;
+
+	if (len < 20) {
+		/* Version(2B)+GRP(4B)+PairwiseCnt(2B)+PairwiseList(4B)+
+			akmCnt(2B)+akmList(4B)+rsnCap(2B) = 20B */
+		PRINTM(MERROR,
+		       "RSNE: IE len should not less than 20 Bytes, len=%d\n",
+		       len);
+		goto done;
+	}
 	/* rsn_cap = data + 2 bytes version + 4 bytes
 	 * group_cipher_suite + 2 bytes pairwise_cipher_count +
 	 * pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN + 2 bytes
 	 * akm_suite_count + akm_suite_count * AKM_SUITE_LEN
 	 */
+	end_ptr = (t_u16 *)(data + len);
 	ptr = (t_u16 *)(data + sizeof(t_u16) + 4 * sizeof(t_u8));
 	pairwise_cipher_count = wlan_le16_to_cpu(*ptr);
 	ptr = (t_u16 *)(data + sizeof(t_u16) + 4 * sizeof(t_u8) +
 			sizeof(t_u16) +
 			pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN);
+	if ((pairwise_cipher_count == 0) || (ptr >= end_ptr)) {
+		PRINTM(MERROR, "RSNE: PAIRWISE_CIPHER not correct\n");
+		goto done;
+	}
 	akm_suite_count = wlan_le16_to_cpu(*ptr);
 	ptr = (t_u16 *)(data + sizeof(t_u16) + 4 * sizeof(t_u8) +
 			sizeof(t_u16) +
 			pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN +
 			sizeof(t_u16) + akm_suite_count * AKM_SUITE_LEN);
+	if ((akm_suite_count == 0) || (ptr > end_ptr)) {
+		PRINTM(MERROR, "RSNE: AKM Suite or RSNCAP not correct\n");
+		goto done;
+	}
 	rsn_cap = wlan_le16_to_cpu(*ptr);
+
+done:
 	PRINTM(MCMND, "rsn_cap=0x%x\n", rsn_cap);
 	return rsn_cap;
 }
@@ -589,7 +610,7 @@ t_u16 wlan_get_rsn_cap(t_u8 *data)
  *  @param BSSDescriptor_t      A pointer to BSSDescriptor_t data structure
  *  @param return       	MTRUE/MFALSE
  */
-t_u8 wlan_use_mfp(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
+static t_u8 wlan_use_mfp(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
 {
 	t_u16 ap_rsn_cap = 0;
 	t_u16 sta_rsn_cap = 0;
@@ -598,10 +619,12 @@ t_u8 wlan_use_mfp(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
 
 	if (pmpriv->wpa_ie[0] != RSN_IE)
 		return 0;
-	sta_rsn_cap = wlan_get_rsn_cap(pmpriv->wpa_ie + 2);
+	sta_rsn_cap =
+		wlan_get_rsn_cap(pmpriv->wpa_ie + 2, *(pmpriv->wpa_ie + 1));
 	if (!pbss_desc->prsn_ie)
 		return 0;
-	ap_rsn_cap = wlan_get_rsn_cap(pbss_desc->prsn_ie->data);
+	ap_rsn_cap = wlan_get_rsn_cap(pbss_desc->prsn_ie->data,
+				      pbss_desc->prsn_ie->ieee_hdr.len);
 	ap_mfpc = ((ap_rsn_cap & (0x1 << MFPC_BIT)) == (0x1 << MFPC_BIT));
 	ap_mfpr = ((ap_rsn_cap & (0x1 << MFPR_BIT)) == (0x1 << MFPR_BIT));
 	sta_mfpc = ((sta_rsn_cap & (0x1 << MFPC_BIT)) == (0x1 << MFPC_BIT));
@@ -624,24 +647,66 @@ t_u8 wlan_use_mfp(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc)
  *
  *  @param ptlv_rsn_ie       A pointer to rsn_ie TLV
  */
-int wlan_update_rsn_ie(mlan_private *pmpriv,
-		       MrvlIEtypes_RsnParamSet_t *ptlv_rsn_ie)
+static int wlan_update_rsn_ie(mlan_private *pmpriv,
+			      MrvlIEtypes_RsnParamSet_t *ptlv_rsn_ie,
+			      t_u16 *rsn_ie_len, t_u8 *akm_type)
 {
 	t_u16 *prsn_cap;
-	t_u16 *ptr;
-	t_u16 *akm_suite_count_ptr;
+	t_u8 *ptr;
+	t_u8 *pairwise_cipher_count_ptr;
+	t_u8 *group_mgmt_cipher_suite_ptr = MNULL;
+	t_u8 *pmkid_list_ptr = MNULL;
+	t_u8 *end_ptr;
 	t_u16 pmf_mask = 0x00;
-	t_u8 *temp;
 	t_u16 pairwise_cipher_count = 0;
 	t_u16 akm_suite_count = 0;
-	t_u16 temp_akm_suite_count = 0;
-	int found = 0;
-	t_u8 sha_256_oui[4] = {0x00, 0x0f, 0xac, 0x06};
-	t_u8 sae_oui[4] = {0x00, 0x0f, 0xac, 0x08};
+	t_u16 pmkid_count = 0;
+	t_u8 i;
+
+#define PREFERENCE_TKIP 1
+	/* Cipher Perference Order:
+	   (5) CIPHER_SYITE_TYPE_GCMP_256 = 9
+	   (4) CIPHER_SYITE_TYPE_GCMP_128 = 8
+	   (3) CIPHER_SYITE_TYPE_CCMP_256 = 10
+	   (2) CIPHER_SYITE_TYPE_CCMP_128 = 4
+	   (1) CIPHER_SYITE_TYPE_TKIP     = 2
+	   (0) Skip
+	*/
+	t_u8 preference_selected;
+	t_u8 cipher_selected_id;
+#if 0 // defined(ENABLE_GCMP_SUPPORT)
+      // embedded supplicant doesn't support GCMP yet
+	t_u8 cipher_preference[11] = {0, 0, 1, 0, 2, 0, 0, 0, 4, 5, 3};
+#else
+	t_u8 cipher_preference[5] = {0, 0, 1, 0, 2};
+#endif
+	t_u8 oui[4] = {0x00, 0x0f, 0xac, 0x00};
+
+	/* AKM Perference Order:
+	   (6) AKM_SUITE_TYPE_FT_SAE     = 9   //Not supported in esupp
+	   (5) AKM_SUITE_TYPE_SAE        = 8
+	   (4) AKM_SUITE_TYPE_OWE        = 18
+	   (3) AKM_SUITE_TYPE_FT_PSK     = 4   //Not supported in esupp
+	   (2) AKM_SUITE_TYPE_PSK_SHA256 = 6
+	   (1) AKM_SUITE_TYPE_PSK        = 2
+	   (0) Skip
+	*/
+	t_u8 akm_type_selected;
+	t_u8 akm_type_id = 0;
+	t_u8 akm_preference[19] = {0, 0, 1, 0, 0, 0, 2, 0, 5, 0,
+				   0, 0, 0, 0, 0, 0, 0, 0, 4};
 	mlan_adapter *pmadapter = pmpriv->adapter;
 
 	int ap_mfpc = 0, ap_mfpr = 0, ret = MLAN_STATUS_SUCCESS;
 
+	if (*rsn_ie_len < 20) {
+		/* Version(2B)+GRP(4B)+PairwiseCnt(2B)+PairwiseList(4B)+
+			akmCnt(2B)+akmList(4B)+rsnCap(2B) = 20B */
+		PRINTM(MERROR,
+		       "RSNE: IE len should not less than 20 Bytes, len=%d\n",
+		       *rsn_ie_len);
+		return MLAN_STATUS_FAILURE;
+	}
 	pmf_mask = (((pmpriv->pmfcfg.mfpc << MFPC_BIT) |
 		     (pmpriv->pmfcfg.mfpr << MFPR_BIT)) |
 		    (~PMF_MASK));
@@ -650,82 +715,129 @@ int wlan_update_rsn_ie(mlan_private *pmpriv,
 	 * pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN + 2 bytes
 	 * akm_suite_count + akm_suite_count * AKM_SUITE_LEN
 	 */
-	ptr = (t_u16 *)(ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8));
-	pairwise_cipher_count = wlan_le16_to_cpu(*ptr);
-	ptr = (t_u16 *)(ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8) +
-			sizeof(t_u16) +
-			pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN);
-	temp_akm_suite_count = wlan_le16_to_cpu(*ptr);
-	akm_suite_count = wlan_le16_to_cpu(*ptr);
-	/* Save pointer to akm_suite_count in RSN IE to update it later */
-	akm_suite_count_ptr = ptr;
-	temp = ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8) +
-	       sizeof(t_u16) +
-	       pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN +
-	       sizeof(t_u16);
-	/* ptr now points to the 1st AKM suite */
-	if (temp_akm_suite_count > 1) {
-		while (temp_akm_suite_count) {
-			if (pmpriv->sec_info.authentication_mode ==
-			    MLAN_AUTH_MODE_SAE) {
-				if (!memcmp(pmadapter, temp, sae_oui,
-					    AKM_SUITE_LEN)) {
-					found = 1;
+	end_ptr = ptlv_rsn_ie->rsn_ie + *rsn_ie_len;
+
+	ptr = ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8);
+
+	pairwise_cipher_count_ptr = ptr;
+	pairwise_cipher_count = wlan_le16_to_cpu(*(t_u16 *)ptr);
+	ptr += sizeof(t_u16);
+
+	if ((pairwise_cipher_count == 0) ||
+	    (ptr + PAIRWISE_CIPHER_SUITE_LEN * pairwise_cipher_count) >=
+		    end_ptr) {
+		PRINTM(MERROR, "RSNE: PAIRWISE_CIPHER not correct\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	preference_selected = 0;
+	cipher_selected_id = 0;
+	for (i = 0; i < pairwise_cipher_count; i++) {
+		if ((ptr[3] < sizeof(cipher_preference)) &&
+		    (cipher_preference[ptr[3]] > preference_selected)) {
+			preference_selected = cipher_preference[ptr[3]];
+			cipher_selected_id = ptr[3];
+		}
+		ptr += PAIRWISE_CIPHER_SUITE_LEN;
+	}
+
+	if (preference_selected == 0) {
+		PRINTM(MERROR, "RSNE: PAIRWISE_CIPHER not supported\n");
+		return MLAN_STATUS_FAILURE;
+	}
+	if ((preference_selected == PREFERENCE_TKIP) &&
+	    ((*akm_type == AssocAgentAuth_Wpa3Sae) ||
+	     (*akm_type == AssocAgentAuth_Owe))) {
+		PRINTM(MERROR,
+		       "RSNE: PAIRWISE_CIPHER TKIP not allowed for AKM %s\n",
+		       (*akm_type == AssocAgentAuth_Wpa3Sae) ? "SAE" : "WE");
+		return MLAN_STATUS_FAILURE;
+	}
+	if ((preference_selected == PREFERENCE_TKIP) &&
+	    (*akm_type == AssocAgentAuth_Auto)) {
+		*akm_type = AssocAgentAuth_Open;
+	}
+	/* Process AKM
+	 * Preference order for AssocAgentAuth_Auto:
+	 *  FT Authentication using SAE 00-0F-AC:9  (not supported in embedded
+	 * supplicant) SAE Authentication 00-0F-AC:8 OWE Authentication
+	 * 00-0F-AC:18 FT Authentication using PSK 00-0F-AC:4  (not supported in
+	 * embedded supplicant) PSK using SHA-256 00-0F-AC:6 PSK 00-0F-AC:2
+	 */
+	ptr = ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8) +
+	      sizeof(t_u16) + pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN;
+	akm_suite_count = wlan_le16_to_cpu(*(t_u16 *)ptr);
+	ptr += sizeof(t_u16); // move pointer to AKM suite
+
+	if ((akm_suite_count == 0) || (ptr + AKM_SUITE_LEN * akm_suite_count +
+				       sizeof(t_u16)) > end_ptr) { // sizeof(t_u16)
+								   // is for
+								   // rsncap
+		PRINTM(MERROR, "RSNE: AKM Suite or RSNCAP not correct\n");
+		return MLAN_STATUS_FAILURE;
+	}
+
+	akm_type_selected = 0;
+	if (*akm_type == AssocAgentAuth_Auto) {
+		// find the best one
+		for (i = 0; i < akm_suite_count; i++) {
+			if ((ptr[3] < sizeof(akm_preference)) &&
+			    (akm_preference[ptr[3]] > akm_type_selected)) {
+				akm_type_selected = akm_preference[ptr[3]];
+				akm_type_id = ptr[3];
+			}
+			ptr += AKM_SUITE_LEN;
+		}
+		if (akm_type_selected) {
+			if (akm_type_id == 6)
+				*akm_type = AssocAgentAuth_Open;
+			else if (akm_type_id == 2)
+				*akm_type = AssocAgentAuth_Open;
+			else if (akm_type_id == 18)
+				*akm_type = AssocAgentAuth_Owe;
+			else if (akm_type_id == 8)
+				*akm_type = AssocAgentAuth_Wpa3Sae;
+		}
+	} else {
+		// find the matched AKM
+		for (i = 0; i < akm_suite_count; i++) {
+			if (ptr[3] < sizeof(akm_preference)) {
+				if ((*akm_type == AssocAgentAuth_Open) &&
+				    (ptr[3] == 6)) {
+					break;
+				} else if ((*akm_type == AssocAgentAuth_Open) &&
+					   (ptr[3] == 2)) {
+					break;
+				} else if ((*akm_type ==
+					    AssocAgentAuth_Wpa3Sae) &&
+					   (ptr[3] == 8)) {
+					break;
+				} else if ((*akm_type == AssocAgentAuth_Owe) &&
+					   (ptr[3] == 18)) {
 					break;
 				}
-			} else if (!memcmp(pmadapter, temp, sha_256_oui,
-					   AKM_SUITE_LEN)) {
-				found = 1;
-				break;
 			}
-			temp += AKM_SUITE_LEN;
-			temp_akm_suite_count--;
+			ptr += AKM_SUITE_LEN;
 		}
-		if (found) {
-			/* Copy SHA256 as AKM suite */
-			memcpy_ext(pmadapter,
-				   ptlv_rsn_ie->rsn_ie +
-					   (sizeof(t_u16) + 4 * sizeof(t_u8) +
-					    sizeof(t_u16) +
-					    pairwise_cipher_count *
-						    PAIRWISE_CIPHER_SUITE_LEN +
-					    sizeof(t_u16)),
-				   temp, AKM_SUITE_LEN, AKM_SUITE_LEN);
-			/* Shift remaining bytes of RSN IE after this */
-			memmove(pmadapter,
-				ptlv_rsn_ie->rsn_ie +
-					(sizeof(t_u16) + 4 * sizeof(t_u8) +
-					 sizeof(t_u16) +
-					 pairwise_cipher_count *
-						 PAIRWISE_CIPHER_SUITE_LEN +
-					 sizeof(t_u16) + AKM_SUITE_LEN),
-				ptlv_rsn_ie->rsn_ie +
-					(sizeof(t_u16) + 4 * sizeof(t_u8) +
-					 sizeof(t_u16) +
-					 pairwise_cipher_count *
-						 PAIRWISE_CIPHER_SUITE_LEN +
-					 sizeof(t_u16) +
-					 akm_suite_count * AKM_SUITE_LEN),
-				ptlv_rsn_ie->header.len -
-					(sizeof(t_u16) + 4 * sizeof(t_u8) +
-					 sizeof(t_u16) +
-					 pairwise_cipher_count *
-						 PAIRWISE_CIPHER_SUITE_LEN +
-					 sizeof(t_u16) +
-					 akm_suite_count * AKM_SUITE_LEN));
-			ptlv_rsn_ie->header.len =
-				ptlv_rsn_ie->header.len -
-				(akm_suite_count - 1) * AKM_SUITE_LEN;
-			/* Update akm suite count */
-			akm_suite_count = 1;
-			*akm_suite_count_ptr = akm_suite_count;
+		if (i == akm_suite_count) {
+			akm_type_selected = 0; // not found
+		} else {
+			akm_type_selected = akm_preference[ptr[3]];
+			akm_type_id = ptr[3];
 		}
 	}
-	ptr = (t_u16 *)(ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8) +
-			sizeof(t_u16) +
-			pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN +
-			sizeof(t_u16) + akm_suite_count * AKM_SUITE_LEN);
-	prsn_cap = ptr;
+
+	if (akm_type_selected == 0) {
+		PRINTM(MERROR, "RSNE: AKM Suite not found for authtype %d\n",
+		       *akm_type);
+		return MLAN_STATUS_FAILURE;
+	}
+	/* Process RSNCAP */
+	ptr = ptlv_rsn_ie->rsn_ie + sizeof(t_u16) + 4 * sizeof(t_u8) +
+	      sizeof(t_u16) +
+	      pairwise_cipher_count * PAIRWISE_CIPHER_SUITE_LEN +
+	      sizeof(t_u16) + akm_suite_count * AKM_SUITE_LEN;
+	prsn_cap = (t_u16 *)ptr;
 
 	ap_mfpc = ((*prsn_cap & (0x1 << MFPC_BIT)) == (0x1 << MFPC_BIT));
 	ap_mfpr = ((*prsn_cap & (0x1 << MFPR_BIT)) == (0x1 << MFPR_BIT));
@@ -734,15 +846,66 @@ int wlan_update_rsn_ie(mlan_private *pmpriv,
 	    ((!ap_mfpc) && ap_mfpr) ||
 	    (ap_mfpc && ap_mfpr && (!pmpriv->pmfcfg.mfpc))) {
 		PRINTM(MERROR,
-		       "Mismatch in PMF config of STA and AP, can't associate to AP\n");
+		       "RSNE: Mismatch in PMF config of STA and AP, can't associate to AP\n");
 		return MLAN_STATUS_FAILURE;
 	}
-	if ((pmpriv->pmfcfg.mfpr && pmpriv->pmfcfg.mfpc) ||
-	    pmpriv->pmfcfg.mfpc) {
-		*prsn_cap |= PMF_MASK;
-		*prsn_cap &= pmf_mask;
-	}
+	*prsn_cap |= PMF_MASK;
+	*prsn_cap &= pmf_mask;
 
+	// PMKID
+	ptr += sizeof(t_u16);
+	if (end_ptr >= (ptr + sizeof(t_u16))) {
+		pmkid_count = wlan_le16_to_cpu(*(t_u16 *)ptr);
+		ptr += sizeof(t_u16);
+
+		if (pmkid_count &&
+		    (end_ptr >= (ptr + pmkid_count * PMKID_LEN))) {
+			pmkid_list_ptr = ptr;
+			ptr += pmkid_count * PMKID_LEN;
+		}
+	}
+	// Group Mgmt Cipher Suite
+	if ((end_ptr >= (ptr + GROUP_MGMT_CIPHER_SUITE_LEN)) &&
+	    (pmf_mask & PMF_MASK)) {
+		group_mgmt_cipher_suite_ptr = ptr;
+	}
+	/* Compose new RSNE */
+	// pairwiase
+	ptr = pairwise_cipher_count_ptr;
+	*(t_u16 *)ptr = wlan_cpu_to_le16(1);
+	ptr += sizeof(t_u16);
+	oui[3] = cipher_selected_id;
+	*(t_u32 *)ptr = *(t_u32 *)oui;
+	ptr += PAIRWISE_CIPHER_SUITE_LEN;
+	// akm
+	*(t_u16 *)ptr = wlan_cpu_to_le16(1);
+	ptr += sizeof(t_u16);
+	oui[3] = akm_type_id;
+	*(t_u32 *)ptr = *(t_u32 *)oui;
+	ptr += AKM_SUITE_LEN;
+	// RSNCAP
+	*(t_u16 *)ptr = wlan_cpu_to_le16(*prsn_cap);
+	ptr += sizeof(t_u16);
+	// PMKID list
+	if (pmkid_list_ptr || group_mgmt_cipher_suite_ptr) {
+		// Add PMKID
+		*(t_u16 *)ptr = wlan_cpu_to_le16(pmkid_count);
+		ptr += sizeof(t_u16);
+		if (pmkid_count) {
+			memcpy_ext(pmadapter, ptr, (t_u8 *)pmkid_list_ptr,
+				   (pmkid_count * PMKID_LEN), (end_ptr - ptr));
+			ptr += pmkid_count * PMKID_LEN;
+		}
+		if (group_mgmt_cipher_suite_ptr) {
+			// Add Group Mgmt Cipher Suite
+			memcpy_ext(pmadapter, ptr,
+				   (t_u8 *)group_mgmt_cipher_suite_ptr,
+				   GROUP_MGMT_CIPHER_SUITE_LEN,
+				   (end_ptr - ptr));
+			ptr += GROUP_MGMT_CIPHER_SUITE_LEN;
+		}
+	}
+	*rsn_ie_len = ptr - ptlv_rsn_ie->rsn_ie;
 	return ret;
 }
 
@@ -816,7 +979,7 @@ t_u8 wlan_ft_akm_is_used(mlan_private *pmpriv, t_u8 *rsn_ie)
  *
  *  @return     MFALSE if not found; MTURE if found
  */
-t_u8 wlan_find_ie(t_u8 *ie, t_u8 ie_len, t_u8 ie_type)
+static t_u8 wlan_find_ie(t_u8 *ie, t_u8 ie_len, t_u8 ie_type)
 {
 	IEEEtypes_Header_t *pheader = MNULL;
 	t_u8 *pos = MNULL;
@@ -829,7 +992,8 @@ t_u8 wlan_find_ie(t_u8 *ie, t_u8 ie_len, t_u8 ie_type)
 	ret_len = ie_len;
 	while (ret_len >= 2) {
 		pheader = (IEEEtypes_Header_t *)pos;
-		if (pheader->len + sizeof(IEEEtypes_Header_t) > ret_len) {
+		if ((t_s8)(pheader->len + sizeof(IEEEtypes_Header_t)) >
+		    ret_len) {
 			PRINTM(MMSG, "invalid IE length = %d left len %d\n",
 			       pheader->len, ret_len);
 			break;
@@ -868,8 +1032,9 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	MrvlIEtypes_PhyParamSet_t *pphy_tlv;
 	MrvlIEtypes_SsParamSet_t *pss_tlv;
 	MrvlIEtypes_RatesParamSet_t *prates_tlv;
-	MrvlIEtypes_AuthType_t *pauth_tlv;
+	MrvlIEtypes_AuthType_t *pauth_tlv = MNULL;
 	MrvlIEtypes_RsnParamSet_t *prsn_ie_tlv = MNULL;
+	MrvlIEtypes_SAE_PWE_Mode_t *prsnx_ie_tlv = MNULL;
 	MrvlIEtypes_SecurityCfg_t *psecurity_cfg_ie = MNULL;
 	MrvlIEtypes_ChanListParamSet_t *pchan_tlv;
 	WLAN_802_11_RATES rates;
@@ -882,7 +1047,11 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	t_u8 ft_akm = 0;
 	t_u8 oper_class;
 	t_u8 oper_class_flag = MFALSE;
+	t_u8 akm_type = 0;
 	MrvlIEtypes_HostMlme_t *host_mlme_tlv = MNULL;
+	MrvlIEtypes_PrevBssid_t *prev_bssid_tlv = MNULL;
+	t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0};
+	MrvlIEtypes_MultiAp_t *multi_ap_tlv = MNULL;
 
 	ENTER();
 
@@ -895,6 +1064,7 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	pmpriv->pattempted_bss_desc = pbss_desc;
 	/* clear assoc_rsp_size */
 	pmpriv->assoc_rsp_size = 0;
+	pmpriv->assoc_req_size = 0;
 
 	memcpy_ext(pmadapter, passo->peer_sta_addr, pbss_desc->mac_address,
 		   sizeof(pbss_desc->mac_address),
@@ -956,7 +1126,8 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	PRINTM(MINFO, "ASSOC_CMD: Rates size = %d\n", rates_size);
 
 	/* Add the Authentication type to be used for Auth frames if needed */
-	if ((pmpriv->sec_info.authentication_mode != MLAN_AUTH_MODE_AUTO)) {
+	if ((pmpriv->sec_info.authentication_mode != MLAN_AUTH_MODE_AUTO) ||
+	    (pbss_desc->owe_transition_mode == OWE_TRANS_MODE_OWE)) {
 		pauth_tlv = (MrvlIEtypes_AuthType_t *)pos;
 		pauth_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_AUTH_TYPE);
 		pauth_tlv->header.len = sizeof(pauth_tlv->auth_type);
@@ -973,13 +1144,41 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 			 MLAN_AUTH_MODE_SAE)
 			pauth_tlv->auth_type =
 				wlan_cpu_to_le16(AssocAgentAuth_Wpa3Sae);
+		else if (!pmpriv->curr_bss_params.host_mlme &&
+			 ((pbss_desc->owe_transition_mode ==
+			   OWE_TRANS_MODE_OWE) ||
+			  pmpriv->sec_info.authentication_mode ==
+				  MLAN_AUTH_MODE_OWE))
+			pauth_tlv->auth_type =
+				wlan_cpu_to_le16(AssocAgentAuth_Owe);
 		else
 			pauth_tlv->auth_type =
-				wlan_cpu_to_le16(MLAN_AUTH_MODE_OPEN);
+				wlan_cpu_to_le16(AssocAgentAuth_Open);
 		pos += sizeof(pauth_tlv->header) + pauth_tlv->header.len;
 		pauth_tlv->header.len = wlan_cpu_to_le16(pauth_tlv->header.len);
 	}
 
+	if ((pauth_tlv != MNULL) &&
+	    (pauth_tlv->auth_type ==
+	     wlan_cpu_to_le16(AssocAgentAuth_Wpa3Sae))) {
+		if (pbss_desc->prsnx_ie && pbss_desc->prsnx_ie->ieee_hdr.len &&
+		    (pbss_desc->prsnx_ie->data[0] & (0x1 << SAE_H2E_BIT))) {
+			MrvlIEtypes_SAE_PWE_Mode_t *psae_pwe_mode_tlv;
+
+			/* Setup the sae pwe derivation mode TLV in the
+			 * association command */
+			psae_pwe_mode_tlv = (MrvlIEtypes_SAE_PWE_Mode_t *)pos;
+			psae_pwe_mode_tlv->header.type = wlan_cpu_to_le16(
+				TLV_TYPE_WPA3_SAE_PWE_DERIVATION_MODE);
+			psae_pwe_mode_tlv->header.len = wlan_cpu_to_le16(
+				sizeof(psae_pwe_mode_tlv->pwe));
+			psae_pwe_mode_tlv->pwe[0] =
+				pbss_desc->prsnx_ie->data[0];
+			pos += sizeof(psae_pwe_mode_tlv->header) +
+			       sizeof(psae_pwe_mode_tlv->pwe);
+		}
+	}
+
 	if (IS_SUPPORT_MULTI_BANDS(pmadapter) &&
 	    (pbss_desc->bss_band & pmpriv->config_bands) &&
 	    !(ISSUPP_11NENABLED(pmadapter->fw_cap_info) &&
@@ -1002,8 +1201,7 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 		       pchan_tlv->chan_scan_param[0].chan_number);
 
 		pchan_tlv->chan_scan_param[0].bandcfg.chanBand =
-			wlan_band_to_radio_type((t_u8)pbss_desc->bss_band);
-
+			wlan_band_to_radio_type(pbss_desc->bss_band);
 		PRINTM(MINFO, "Assoc: TLV Bandcfg = %x\n",
 		       pchan_tlv->chan_scan_param[0].bandcfg);
 		pos += sizeof(pchan_tlv->header) + sizeof(ChanScanParamSet_t);
@@ -1058,6 +1256,8 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 			psecurity_cfg_ie->header.len = sizeof(t_u8);
 			pos += sizeof(psecurity_cfg_ie->header) +
 			       psecurity_cfg_ie->header.len;
+			psecurity_cfg_ie->header.len =
+				wlan_cpu_to_le16(psecurity_cfg_ie->header.len);
 		}
 #ifdef DRV_EMBEDDED_SUPPLICANT
 		else if (supplicantIsEnabled(pmpriv->psapriv)) {
@@ -1072,7 +1272,11 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 				pmpriv->psapriv, rsn_wpa_ie_tmp, prsn_ie_tlv);
 		}
 #endif
-		else if (pmpriv->sec_info.ewpa_enabled) {
+		else if (pmpriv->sec_info.ewpa_enabled ||
+			 (pbss_desc->owe_transition_mode ==
+			  OWE_TRANS_MODE_OWE) ||
+			 (pmpriv->sec_info.authentication_mode ==
+			  MLAN_AUTH_MODE_OWE)) {
 			prsn_ie_tlv = (MrvlIEtypes_RsnParamSet_t *)pos;
 			if (pbss_desc->pwpa_ie) {
 				prsn_ie_tlv->header.type =
@@ -1131,8 +1335,16 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 							     .data[0]),
 						   prsn_ie_tlv->header.len,
 						   prsn_ie_tlv->header.len);
-					ret = wlan_update_rsn_ie(pmpriv,
-								 prsn_ie_tlv);
+					akm_type =
+						pauth_tlv ?
+							wlan_le16_to_cpu(
+								pauth_tlv
+									->auth_type) :
+							AssocAgentAuth_Auto;
+					ret = wlan_update_rsn_ie(
+						pmpriv, prsn_ie_tlv,
+						&prsn_ie_tlv->header.len,
+						&akm_type);
 					if (ret != MLAN_STATUS_SUCCESS) {
 						goto done;
 					}
@@ -1149,6 +1361,58 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 				       prsn_ie_tlv->header.len;
 				prsn_ie_tlv->header.len = wlan_cpu_to_le16(
 					prsn_ie_tlv->header.len);
+
+				if ((pauth_tlv == MNULL) &&
+				    (pmpriv->sec_info.authentication_mode ==
+				     MLAN_AUTH_MODE_AUTO)) {
+					pauth_tlv =
+						(MrvlIEtypes_AuthType_t *)pos;
+					pauth_tlv->header.type =
+						wlan_cpu_to_le16(
+							TLV_TYPE_AUTH_TYPE);
+					pauth_tlv->header.len =
+						sizeof(pauth_tlv->auth_type);
+					pauth_tlv->auth_type =
+						wlan_cpu_to_le16(akm_type);
+
+					pos += sizeof(pauth_tlv->header) +
+					       pauth_tlv->header.len;
+					pauth_tlv->header.len =
+						wlan_cpu_to_le16(
+							pauth_tlv->header.len);
+				}
+			}
+			if ((pbss_desc->prsnx_ie) &&
+			    (akm_type == AssocAgentAuth_Wpa3Sae)) {
+				prsnx_ie_tlv =
+					(MrvlIEtypes_SAE_PWE_Mode_t *)pos;
+				prsnx_ie_tlv->header.type =
+					(t_u16)(*(pbss_desc->prsnx_ie))
+						.ieee_hdr.element_id;
+				prsnx_ie_tlv->header.type =
+					prsnx_ie_tlv->header.type & 0x00FF;
+				prsnx_ie_tlv->header.type = wlan_cpu_to_le16(
+					prsnx_ie_tlv->header.type);
+				prsnx_ie_tlv->header.len =
+					(t_u16)(*(pbss_desc->prsnx_ie))
+						.ieee_hdr.len;
+				prsnx_ie_tlv->header.len =
+					prsnx_ie_tlv->header.len & 0x00FF;
+
+				memcpy_ext(pmadapter, prsnx_ie_tlv->pwe,
+					   &((*(pbss_desc->prsnx_ie)).data[0]),
+					   prsnx_ie_tlv->header.len,
+					   prsnx_ie_tlv->header.len);
+
+				HEXDUMP("ASSOC_CMD: RSNX IE",
+					(t_u8 *)prsnx_ie_tlv,
+					sizeof(prsnx_ie_tlv->header) +
+						prsnx_ie_tlv->header.len);
+
+				pos += sizeof(prsnx_ie_tlv->header) +
+				       prsnx_ie_tlv->header.len;
+				prsnx_ie_tlv->header.len = wlan_cpu_to_le16(
+					prsnx_ie_tlv->header.len);
 			}
 		}
 	}
@@ -1180,12 +1444,11 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	    wlan_11ac_bandconfig_allowed(pmpriv, pbss_desc->bss_band))
 		wlan_cmd_append_11ac_tlv(pmpriv, pbss_desc, &pos);
 
-	if ((IS_FW_SUPPORT_11AX(pmadapter)) && (!pbss_desc->disable_11n) &&
-	    wlan_11ax_bandconfig_allowed(pmpriv, pbss_desc->bss_band))
+	if ((IS_FW_SUPPORT_11AX(pmadapter)) &&
+	    wlan_11ax_bandconfig_allowed(pmpriv, pbss_desc))
 		wlan_cmd_append_11ax_tlv(pmpriv, pbss_desc, &pos);
 
-	wlan_wmm_process_association_req(pmpriv, &pos, &pbss_desc->wmm_ie,
-					 pbss_desc->pht_cap);
+	wlan_wmm_process_association_req(pmpriv, &pos, &pbss_desc->wmm_ie);
 	if (pmpriv->sec_info.wapi_enabled && pmpriv->wapi_ie_len)
 		wlan_cmd_append_wapi_ie(pmpriv, &pos);
 
@@ -1194,7 +1457,7 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 
 	wlan_cmd_append_generic_ie(pmpriv, &pos);
 
-	if (pbss_desc->pmd_ie)
+	if (ft_akm && pbss_desc->pmd_ie)
 		wlan_cmd_append_pass_through_ie(
 			pmpriv, (IEEEtypes_Generic_t *)pbss_desc->pmd_ie, &pos);
 	wlan_cmd_append_tsf_tlv(pmpriv, &pos, pbss_desc);
@@ -1203,15 +1466,41 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 		host_mlme_tlv = (MrvlIEtypes_HostMlme_t *)pos;
 		host_mlme_tlv->header.type =
 			wlan_cpu_to_le16(TLV_TYPE_HOST_MLME);
-		host_mlme_tlv->header.len =
-			wlan_cpu_to_le16(sizeof(host_mlme_tlv->host_mlme));
+		host_mlme_tlv->header.len = sizeof(host_mlme_tlv->host_mlme);
 		host_mlme_tlv->host_mlme = MTRUE;
 		pos += sizeof(host_mlme_tlv->header) +
 		       host_mlme_tlv->header.len;
+		host_mlme_tlv->header.len =
+			wlan_cpu_to_le16(host_mlme_tlv->header.len);
+	}
+	if (memcmp(pmadapter, &pmpriv->curr_bss_params.prev_bssid, zero_mac,
+		   MLAN_MAC_ADDR_LENGTH)) {
+		prev_bssid_tlv = (MrvlIEtypes_PrevBssid_t *)pos;
+		prev_bssid_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_PREV_BSSID);
+		prev_bssid_tlv->header.len =
+			wlan_cpu_to_le16(MLAN_MAC_ADDR_LENGTH);
+		memcpy_ext(pmadapter, prev_bssid_tlv->prev_bssid,
+			   &pmpriv->curr_bss_params.prev_bssid,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		PRINTM(MCMND, "ASSOCIATE: PREV_BSSID = " MACSTR "\n",
+		       MAC2STR(pmpriv->curr_bss_params.prev_bssid));
+		pos += sizeof(prev_bssid_tlv->header) + MLAN_MAC_ADDR_LENGTH;
 	}
 
-	if (wlan_11d_create_dnld_countryinfo(pmpriv,
-					     (t_u8)pbss_desc->bss_band)) {
+	if (pmpriv->multi_ap_flag) {
+		multi_ap_tlv = (MrvlIEtypes_MultiAp_t *)pos;
+		multi_ap_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_MULTI_AP);
+		multi_ap_tlv->header.len = sizeof(multi_ap_tlv->flag);
+		multi_ap_tlv->flag = pmpriv->multi_ap_flag;
+		PRINTM(MINFO, " TLV multi_ap_flag : 0x%x\n",
+		       multi_ap_tlv->flag);
+		pos += sizeof(multi_ap_tlv->header) + multi_ap_tlv->header.len;
+		multi_ap_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(multi_ap_tlv->flag));
+	}
+
+	if (wlan_11d_create_dnld_countryinfo(pmpriv, pbss_desc->bss_band)) {
 		PRINTM(MERROR, "Dnld_countryinfo_11d failed\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
@@ -1240,6 +1529,9 @@ mlan_status wlan_cmd_802_11_associate(mlan_private *pmpriv,
 	if (pmpriv->config_bands == BAND_B)
 		SHORT_SLOT_TIME_DISABLED(tmp_cap);
 
+	if (pmpriv->adapter->pcard_info->support_11mc)
+		RADIO_MEASUREMENT_ENABLED(tmp_cap);
+
 	tmp_cap &= CAPINFO_MASK;
 	PRINTM(MINFO, "ASSOC_CMD: tmp_cap=%4X CAPINFO_MASK=%4lX\n", tmp_cap,
 	       CAPINFO_MASK);
@@ -1344,14 +1636,21 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	assoc_logger_data *assoc_succ;
 	mlan_ds_bss *bss;
+	IEEEtypes_MgmtHdr_t *hdr;
 
 	ENTER();
 
-	if (pmpriv->curr_bss_params.host_mlme)
-		passoc_rsp =
-			(IEEEtypes_AssocRsp_t *)((t_u8 *)(&resp->params) +
+	if (pmpriv->curr_bss_params.host_mlme) {
+		hdr = (IEEEtypes_MgmtHdr_t *)&resp->params;
+		if (!memcmp(pmpriv->adapter, hdr->BssId,
+			    pmpriv->pattempted_bss_desc->mac_address,
+			    MLAN_MAC_ADDR_LENGTH))
+			passoc_rsp = (IEEEtypes_AssocRsp_t
+					      *)((t_u8 *)(&resp->params) +
 						 sizeof(IEEEtypes_MgmtHdr_t));
-	else
+		else
+			passoc_rsp = (IEEEtypes_AssocRsp_t *)&resp->params;
+	} else
 
 		passoc_rsp = (IEEEtypes_AssocRsp_t *)&resp->params;
 	passoc_rsp->status_code = wlan_le16_to_cpu(passoc_rsp->status_code);
@@ -1416,7 +1715,7 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 
 	/* Send a Media Connected event, according to the Spec */
 	pmpriv->media_connected = MTRUE;
-
+	pmpriv->multi_ap_flag = 0;
 	pmpriv->adapter->pps_uapsd_mode = MFALSE;
 	pmpriv->adapter->tx_lock_flag = MFALSE;
 	pmpriv->adapter->delay_null_pkt = MFALSE;
@@ -1437,7 +1736,7 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 	pmpriv->curr_bss_params.bss_descriptor.channel =
 		pbss_desc->phy_param_set.ds_param_set.current_chan;
 
-	pmpriv->curr_bss_params.band = (t_u8)pbss_desc->bss_band;
+	pmpriv->curr_bss_params.band = pbss_desc->bss_band;
 
 	/* Store current channel for further reference.
 	 * This would save one extra call to get current
@@ -1446,7 +1745,7 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 	pmpriv->adapter->dfsr_channel =
 		pmpriv->curr_bss_params.bss_descriptor.channel;
 
-	/*
+	/*`
 	 * Adjust the timestamps in the scan table to be relative to the newly
 	 * associated AP's TSF
 	 */
@@ -1457,10 +1756,7 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 	else
 		pmpriv->curr_bss_params.wmm_enabled = MFALSE;
 
-	if ((pmpriv->wmm_required ||
-	     (pbss_desc->pht_cap &&
-	      (pbss_desc->pht_cap->ieee_hdr.element_id == HT_CAPABILITY))) &&
-	    pmpriv->curr_bss_params.wmm_enabled)
+	if (pmpriv->wmm_required && pmpriv->curr_bss_params.wmm_enabled)
 		pmpriv->wmm_enabled = MTRUE;
 	else
 		pmpriv->wmm_enabled = MFALSE;
@@ -1552,9 +1848,11 @@ mlan_status wlan_ret_802_11_associate(mlan_private *pmpriv,
 			pmpriv->curr_bss_params.bss_descriptor.mac_address);
 
 	wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_CONNECTED, pevent);
+#ifdef UAP_SUPPORT
+	if (pmpriv->adapter->dfs_mode)
+		wlan_11h_update_dfs_master_state_by_sta(pmpriv);
+#endif
 
-	/* Send OBSS scan param to the application if available */
-	wlan_2040_coex_event(pmpriv);
 	wlan_coex_ampdu_rxwinsize(pmpriv->adapter);
 
 	if (!pmpriv->sec_info.wpa_enabled && !pmpriv->sec_info.wpa2_enabled &&
@@ -1954,6 +2252,7 @@ mlan_status wlan_cmd_802_11_ad_hoc_join(mlan_private *pmpriv,
 	t_u32 i, rates_size = 0;
 	t_u32 curr_pkt_filter;
 	t_u8 *pos = (t_u8 *)padhoc_join + sizeof(HostCmd_DS_802_11_AD_HOC_JOIN);
+	t_s32 append_size_11h = 0;
 
 	ENTER();
 
@@ -2046,7 +2345,7 @@ mlan_status wlan_cmd_802_11_ad_hoc_join(mlan_private *pmpriv,
 
 	/* Copy the channel information */
 	pmpriv->curr_bss_params.bss_descriptor.channel = pbss_desc->channel;
-	pmpriv->curr_bss_params.band = (t_u8)pbss_desc->bss_band;
+	pmpriv->curr_bss_params.band = pbss_desc->bss_band;
 
 	if (pmpriv->sec_info.wep_status == Wlan802_11WEPEnabled ||
 	    pmpriv->sec_info.wpa_enabled || pmpriv->sec_info.ewpa_enabled)
@@ -2067,7 +2366,7 @@ mlan_status wlan_cmd_802_11_ad_hoc_join(mlan_private *pmpriv,
 		       pchan_tlv->chan_scan_param[0].chan_number);
 
 		pchan_tlv->chan_scan_param[0].bandcfg.chanBand =
-			wlan_band_to_radio_type((t_u8)pbss_desc->bss_band);
+			wlan_band_to_radio_type(pbss_desc->bss_band);
 
 		PRINTM(MINFO, "ADHOC_J_CMD: TLV Bandcfg = %x\n",
 		       pchan_tlv->chan_scan_param[0].bandcfg);
@@ -2076,8 +2375,7 @@ mlan_status wlan_cmd_802_11_ad_hoc_join(mlan_private *pmpriv,
 			sizeof(pchan_tlv->header) + sizeof(ChanScanParamSet_t);
 	}
 
-	if (wlan_11d_create_dnld_countryinfo(pmpriv,
-					     (t_u8)pbss_desc->bss_band)) {
+	if (wlan_11d_create_dnld_countryinfo(pmpriv, pbss_desc->bss_band)) {
 		PRINTM(MERROR, "Dnld_countryinfo_11d failed\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
@@ -2093,10 +2391,17 @@ mlan_status wlan_cmd_802_11_ad_hoc_join(mlan_private *pmpriv,
 	 *   adhoc/infra 11h behavior can be properly triggered.
 	 *   pos modified if data is appended
 	 */
-	cmd_append_size += wlan_11h_process_join(
-		pmpriv, &pos, &padhoc_join->bss_descriptor.cap,
-		(t_u8)pbss_desc->bss_band, pbss_desc->channel,
-		&pbss_desc->wlan_11h_bss_info);
+	append_size_11h +=
+		wlan_11h_process_join(pmpriv, &pos,
+				      &padhoc_join->bss_descriptor.cap,
+				      pbss_desc->bss_band, pbss_desc->channel,
+				      &pbss_desc->wlan_11h_bss_info);
+	if (append_size_11h >= 0)
+		cmd_append_size += append_size_11h;
+	else {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
 
 	if (pmpriv->sec_info.wpa_enabled) {
 		prsn_ie_tlv = (MrvlIEtypes_RsnParamSet_t *)pos;
@@ -2318,7 +2623,7 @@ mlan_status wlan_ret_802_11_ad_hoc(mlan_private *pmpriv,
 	}
 
 	/** process wmm ie */
-	if (ie_len >= sizeof(IEEEtypes_VendorHeader_t)) {
+	if (ie_len >= (int)sizeof(IEEEtypes_VendorHeader_t)) {
 		if ((pwmm_param_ie->vend_hdr.element_id ==
 		     VENDOR_SPECIFIC_221) &&
 		    !memcmp(pmadapter, pwmm_param_ie->vend_hdr.oui, wmm_oui,
@@ -2595,7 +2900,7 @@ mlan_status wlan_disconnect(mlan_private *pmpriv, mlan_ioctl_req *pioctl_req,
  *
  *  @return         Radio type designator for use in a channel TLV
  */
-t_u8 wlan_band_to_radio_type(t_u8 band)
+t_u8 wlan_band_to_radio_type(t_u16 band)
 {
 	t_u8 ret_radio_type;
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h
old mode 100644
new mode 100755
index 99d6027c5..5a9076134
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_join.h
@@ -8,7 +8,7 @@
  *  both adhoc and infrastructure networks
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h
old mode 100644
new mode 100755
index 5c4ff7136..8675f7333
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_main.h
@@ -5,7 +5,7 @@
  *  in MLAN module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -286,9 +286,6 @@ extern t_u32 mlan_drvdbg;
 		b = t;                                                         \
 	}
 
-/** MLAN MNULL pointer */
-#define MNULL (0)
-
 /** 16 bits byte swap */
 #define swap_byte_16(x)                                                        \
 	((t_u16)((((t_u16)(x)&0x00ffU) << 8) | (((t_u16)(x)&0xff00U) >> 8)))
@@ -349,9 +346,17 @@ extern t_u32 mlan_drvdbg;
 		(x)->rx_pkt_offset = wlan_le16_to_cpu((x)->rx_pkt_offset);     \
 		(x)->rx_pkt_type = wlan_le16_to_cpu((x)->rx_pkt_type);         \
 		(x)->seq_num = wlan_le16_to_cpu((x)->seq_num);                 \
-		(x)->rx_info = wlan_le32_to_cpu((x)->rx_info);                 \
-	}
+		(x)->rx_info = wlan_le32_to_cpu((x)->rx_info);
+}
 
+/** Convert RxPD extra header from little endian format to CPU format */
+#define endian_convert_RxPD_extra_header(x)                                    \
+	do {                                                                   \
+		(x)->channel_flags = wlan_le16_to_cpu((x)->channel_flags);     \
+		(x)->vht_he_sig1 = wlan_le32_to_cpu((x)->vht_he_sig1);         \
+		(x)->vht_he_sig2 = wlan_le32_to_cpu((x)->vht_he_sig2);         \
+		(x)->user_idx = wlan_le32_to_cpu((x)->user_idx);               \
+	} while (0)
 #else
 /** Convert ulong n/w to host */
 #define mlan_ntohl(x) swap_byte_32(x)
@@ -382,6 +387,10 @@ extern t_u32 mlan_drvdbg;
 #define endian_convert_RxPD(x)                                                 \
 	do {                                                                   \
 	} while (0)
+/** Convert RxPD extra header from little endian format to CPU format */
+#define endian_convert_RxPD_extra_header(x)                                    \
+	do {                                                                   \
+	} while (0)
 #endif /* BIG_ENDIAN_SUPPORT */
 
 /** Global moal_assert_callback */
@@ -405,6 +414,11 @@ extern t_void (*assert_callback)(t_void *pmoal_handle, t_u32 cond);
 /** Maximum event buffer size */
 #define MAX_EVENT_SIZE (3 * 1024)
 
+#ifdef STA_SUPPORT
+/** Maximum buffer size for ARP filter */
+#define ARP_FILTER_MAX_BUF_SIZE 68
+#endif /* STA_SUPPORT */
+
 /** 60 seconds */
 #define MRVDRV_TIMER_60S 60000
 /** 10 seconds */
@@ -440,9 +454,9 @@ extern t_void (*assert_callback)(t_void *pmoal_handle, t_u32 cond);
 #define MRVDRV_MAX_CFP_CODE_A 5
 
 /** high rx pending packets */
-#define HIGH_RX_PENDING 100
+#define HIGH_RX_PENDING 1000
 /** low rx pending packets */
-#define LOW_RX_PENDING 80
+#define LOW_RX_PENDING 800
 
 /** Default region code */
 #define MRVDRV_DEFAULT_REGION_CODE 0x10
@@ -476,7 +490,7 @@ extern t_void (*assert_callback)(t_void *pmoal_handle, t_u32 cond);
 #define DEFAULT_BCN_MISS_TIMEOUT 10
 
 /** Maximum buffer space for beacons retrieved from scan responses */
-#define MAX_SCAN_BEACON_BUFFER 49152
+#define MAX_SCAN_BEACON_BUFFER 102400
 /** Default buffer space for beacons retrieved from scan responses */
 #define DEFAULT_SCAN_BEACON_BUFFER 4096
 
@@ -554,16 +568,11 @@ extern t_void (*assert_callback)(t_void *pmoal_handle, t_u32 cond);
 #define SDIO_CMD53_MAX_SIZE 65280
 #define MAX_SUPPORT_AMSDU_SIZE 4096
 /** Maximum numbfer of registers to read for multiple port */
-#if defined(SD8887) || defined(SD8997) || defined(SD8977) ||                   \
-	defined(SD8987) || defined(SD9098) || defined(SD9097) ||               \
-	defined(SD8978)
 #define MAX_MP_REGS 196
-#else
-/* upto 0xB7 */
-#define MAX_MP_REGS 184
-#endif
 /** Maximum port */
 #define MAX_PORT 32
+/** Maximum port 16 */
+#define MAX_PORT_16 (16)
 
 /** max MP REGS */
 #define MAX_MP_REGS_MAX (196)
@@ -594,10 +603,16 @@ extern t_void (*assert_callback)(t_void *pmoal_handle, t_u32 cond);
 #define MFG_CMD_TX_FRAME 0x1021
 #define MFG_CMD_RF_BAND_AG 0x1034
 #define MFG_CMD_RF_CHANNELBW 0x1044
+#define MFG_CMD_RADIO_MODE_CFG 0x1211
+#define MFG_CMD_CONFIG_MAC_HE_TB_TX 0x110A
+#define MFG_CMD_CONFIG_TRIGGER_FRAME 0x110C
 
 /** Debug command number */
 #define DBG_CMD_NUM 10
 
+/** scan GAP value is optional */
+#define GAP_FLAG_OPTIONAL MBIT(15)
+
 /** Info for debug purpose */
 typedef struct _wlan_dbg {
 	/** Number of host to card command failures */
@@ -748,7 +763,7 @@ struct _raListTbl {
 	/** packet count threshold to setup BA */
 	t_u8 ba_packet_threshold;
 	/** is 11n enabled */
-	t_u8 is_11n_enabled;
+	t_u8 is_wmm_enabled;
 	/** max amsdu size */
 	t_u16 max_amsdu;
 	/** BA stream status */
@@ -757,6 +772,8 @@ struct _raListTbl {
 	t_u8 del_ba_count;
 	/** amsdu in ampdu flag */
 	t_u8 amsdu_in_ampdu;
+	/** tdls flag */
+	t_u8 is_tdls_link;
 	/** tx_pause flag */
 	t_u8 tx_pause;
 };
@@ -844,13 +861,14 @@ typedef struct {
 	/** Uapsd enable?*/
 	t_u8 wmm_uapsd_enabled;
 	/** Band */
-	t_u8 band;
+	t_u16 band;
 	/** Number of rates supported */
 	t_u32 num_of_rates;
 	/** Supported rates*/
 	t_u8 data_rates[WLAN_SUPPORTED_RATES];
 	/** Host MLME flag*/
 	t_u8 host_mlme;
+	mlan_802_11_mac_addr prev_bssid;
 	t_u8 use_mfp;
 } current_bss_params_t;
 
@@ -900,7 +918,7 @@ typedef struct _region_chan_t {
 	/** Region code for US, Japan ... */
 	t_u8 region;
 	/** Band B/G/A, used for BAND_CONFIG cmd */
-	t_u8 band;
+	t_u16 band;
 	/** Actual No. of elements in the array below */
 	t_u8 num_cfp;
 	/** chan-freq-txpower mapping table */
@@ -917,10 +935,12 @@ typedef enum _state_11d_t {
 
 /** Domain regulatory information */
 typedef struct _wlan_802_11d_domain_reg {
+	/** dfs_region */
+	t_u8 dfs_region;
 	/** Country Code */
 	t_u8 country_code[COUNTRY_CODE_LEN];
 	/** band that channels in sub_band belong to */
-	t_u8 band;
+	t_u16 band;
 	/** No. of subband in below */
 	t_u8 no_of_sub_band;
 	/** Subband data to send/last sent */
@@ -1163,6 +1183,7 @@ typedef struct _mlan_private {
 	/** AdHoc previous ssid used for Start */
 	mlan_802_11_ssid adhoc_last_start_ssid;
 #endif
+	mlan_ds_11h_chan_rep_req chan_rep_req;
 	/** FSM variable for 11d support */
 	wlan_802_11d_state_t state_11d;
 	/** FSM variable for 11h support */
@@ -1174,6 +1195,8 @@ typedef struct _mlan_private {
 	t_bool uap_host_based;
 	/**UAP operating channel*/
 	t_u8 uap_channel;
+	/**UAP bandwidth*/
+	t_u8 uap_bandwidth;
 	/** state variable for UAP Get Info callback */
 	wlan_uap_get_info_cb_t uap_state_chan_cb;
 #endif /* UAP_SUPPORT */
@@ -1209,6 +1232,9 @@ typedef struct _mlan_private {
 	t_u8 osen_ie_len;
 	/** Pointer to the station table */
 	mlan_list_head sta_list;
+	/** tdls pending queue */
+	mlan_list_head tdls_pending_txq;
+	t_u16 tdls_idle_time;
 
 	/** MGMT IE */
 	custom_ie mgmt_ie[MAX_MGMT_IE_INDEX];
@@ -1220,6 +1246,22 @@ typedef struct _mlan_private {
 	t_u8 wmm_enabled;
 	/** WMM qos info */
 	t_u8 wmm_qosinfo;
+	/** saved WMM qos info */
+	t_u8 saved_wmm_qosinfo;
+	/**host tdls uapsd support*/
+	t_u8 host_tdls_uapsd_support;
+	/**host tdls channel switch support*/
+	t_u8 host_tdls_cs_support;
+	/**supported channel IE len*/
+	t_u8 chan_supp_len;
+	/**save channel support IE*/
+	t_u8 chan_supp[MAX_IE_SIZE];
+	/**supported regulatory classl IE len*/
+	t_u8 supp_regulatory_class_len;
+	/**save support channel regulatory class IE*/
+	t_u8 supp_regulatory_class[MAX_IE_SIZE];
+	/**tdls cs off channel*/
+	t_u8 tdls_cs_channel;
 	/** WMM related variable*/
 	wmm_desc_t wmm;
 
@@ -1250,7 +1292,10 @@ typedef struct _mlan_private {
 	t_u8 assoc_rsp_buf[MRVDRV_ASSOC_RSP_BUF_SIZE];
 	/** Length of the data stored in assoc_rsp_buf */
 	t_u32 assoc_rsp_size;
-
+	/** Buffer to store the association req IEs */
+	t_u8 assoc_req_buf[MRVDRV_ASSOC_RSP_BUF_SIZE];
+	/** Length of the data stored in assoc_rsp_buf */
+	t_u32 assoc_req_size;
 	/** Generic IEEE IEs passed from the application to be inserted into the
 	 *    association request to firmware
 	 */
@@ -1287,6 +1332,7 @@ typedef struct _mlan_private {
 	/** IP address */
 	t_u8 ip_addr[IPADDR_LEN];
 	t_u32 hotspot_cfg;
+	t_u8 multi_ap_flag;
 #ifdef STA_SUPPORT
 	ExtCap_t ext_cap;
 	ExtCap_t def_ext_cap;
@@ -1296,7 +1342,11 @@ typedef struct _mlan_private {
 #ifdef USB
 	/** USB data port */
 	t_u32 port;
+	/** port Index */
+	t_u32 port_index;
 #endif
+	/** Control TX AMPDU on infra link */
+	t_u8 txaggrctrl;
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
 	t_void *psapriv;
 #endif
@@ -1310,6 +1360,12 @@ typedef struct _mlan_private {
 	t_u32 amsdu_tx_cnt;
 	/** tx msdu count in amsdu*/
 	t_u32 msdu_in_tx_amsdu_cnt;
+	/** channel load info for current channel */
+	t_u16 ch_load_param;
+	/** Noise floor value for current channel */
+	t_s16 noise;
+	/** rx quality info */
+	t_u16 rx_quality;
 } mlan_private, *pmlan_private;
 
 typedef struct _assoc_logger {
@@ -1350,6 +1406,12 @@ typedef struct {
 	mlan_private *priv;
 } reorder_tmr_cnxt_t;
 
+#define MLAN_SET_BIT(x, val) ((x) |= (1U << (val)))
+#define MLAN_CLEAR_BIT(x, val) ((x) &= ~(1U << (val)))
+/** default RX reorder table flush time 128 ms for AC_VI, AC_VO*/
+#define DEF_FLUSH_TIME_AC_VI_VO 128
+/** default RX reorder table flush time 500 ms for AC_BE, AC_BK*/
+#define DEF_FLUSH_TIME_AC_BE_BK 500
 /** RX reorder table */
 struct _RxReorderTbl {
 	/** RxReorderTbl previous node */
@@ -1381,6 +1443,8 @@ struct _RxReorderTbl {
 	t_u8 pkt_count;
 	/** flush data flag */
 	t_u8 flush_data;
+	/** BA window bitmap */
+	t_u64 bitmap;
 };
 
 /** BSS priority node */
@@ -1436,6 +1500,22 @@ struct _cmd_ctrl_node {
 #endif
 };
 
+/** default tdls wmm qosinfo */
+#define DEFAULT_TDLS_WMM_QOS_INFO 15
+/** default tdls sleep period */
+#define DEFAULT_TDLS_SLEEP_PERIOD 30
+
+/** TDLS status */
+typedef enum _tdlsStatus_e {
+	TDLS_NOT_SETUP = 0,
+	TDLS_SETUP_INPROGRESS,
+	TDLS_SETUP_COMPLETE,
+	TDLS_SETUP_FAILURE,
+	TDLS_TEAR_DOWN,
+	TDLS_SWITCHING_CHANNEL,
+	TDLS_IN_BASE_CHANNEL,
+	TDLS_IN_OFF_CHANNEL,
+} tdlsStatus_e;
 /** station node */
 typedef struct _sta_node sta_node, *psta_node;
 
@@ -1463,12 +1543,43 @@ struct _sta_node {
 	t_u8 is_11ac_enabled;
 	/** UAP 11ax flag */
 	t_u8 is_11ax_enabled;
+	IEEEtypes_HECap_t he_cap;
 	/** SNR */
 	t_s8 snr;
 	/** Noise Floor */
 	t_s8 nf;
 	/** peer capability */
 	t_u16 capability;
+	/** tdls status */
+	tdlsStatus_e status;
+	/** flag for host based tdls */
+	t_u8 external_tdls;
+	/** peer support rates */
+	t_u8 support_rate[32];
+	/** rate size */
+	t_u8 rate_len;
+	/*Qos capability info*/
+	t_u8 qos_info;
+	/** HT info in TDLS setup confirm*/
+	IEEEtypes_HTInfo_t HTInfo;
+	/** peer BSSCO_20_40*/
+	IEEEtypes_2040BSSCo_t BSSCO_20_40;
+	/*Extended capability*/
+	IEEEtypes_ExtCap_t ExtCap;
+	/*RSN IE*/
+	IEEEtypes_Generic_t rsn_ie;
+	/**Link ID*/
+	IEEEtypes_LinkIDElement_t link_ie;
+	/** AID info */
+	IEEEtypes_AID_t aid_info;
+	/** VHT Capabilities IE */
+	IEEEtypes_VHTCap_t vht_cap;
+	/** VHT Operations IE */
+	IEEEtypes_VHTOprat_t vht_oprat;
+	/** HE Capabilities IE */
+	IEEEtypes_HECap_t tdls_he_cap;
+	/** HE Operations IE */
+	IEEEtypes_HeOp_t he_op;
 	/** wapi key on off flag */
 	t_u8 wapi_key_on;
 	/** tx pause status */
@@ -1479,6 +1590,8 @@ struct _sta_node {
 	t_void *cm_connectioninfo;
 #endif
 	sta_stats stats;
+	/** station aid */
+	t_u16 aid;
 };
 
 /** 802.11h State information kept in the 'mlan_adapter' driver structure */
@@ -1545,6 +1658,8 @@ typedef struct {
 	t_bool dfs_radar_found;
 	/** Channel radar is being checked on.  BAND_A is assumed. */
 	t_u8 dfs_check_channel;
+	/** Channel radar is being checked on bandwidth*/
+	t_u8 dfs_check_bandwidth;
 	/** point to the priv which start the DFS check */
 	t_void *dfs_check_priv;
 	/** Timestamp when we got last report,
@@ -1602,6 +1717,14 @@ typedef struct {
 	t_bool no_channel_change_on_radar;
 	/** user-configured new channel to change to on radar */
 	t_u8 fixed_new_channel_on_radar;
+	/** user-configured cac restart */
+	t_u8 cac_restart;
+	/**  cac channel */
+	t_u8 chan;
+	/** band cfg */
+	Band_Config_t bandcfg;
+	/** cac time */
+	t_u32 millisec_dwell_time;
 } wlan_dfs_testing_settings_t;
 
 /**
@@ -1702,14 +1825,14 @@ typedef struct _sdio_mpa_rx {
 /** data structure for USB Rx Deaggregation */
 typedef struct _usb_rx_deaggr_params {
 	/** Rx aggregation control */
-	usb_aggr_ctrl aggr_ctrl;
+	usb_aggr_ctrl_cfg aggr_ctrl;
 } usb_rx_deaggr_params;
 
-#define MAX_USB_TX_PORT_NUM 1
+#define MAX_USB_TX_PORT_NUM 2
 /** data structure for USB Tx Aggregation */
 typedef struct _usb_tx_aggr_params {
 	/** Tx aggregation control */
-	usb_aggr_ctrl aggr_ctrl;
+	usb_aggr_ctrl_cfg aggr_ctrl;
 	/** allocated pmbuf for tx aggreation */
 	pmlan_buffer pmbuf_aggr;
 	/** packet len used in pmbuf_aggr */
@@ -1730,22 +1853,24 @@ typedef struct _usb_tx_aggr_params {
 #endif
 
 /** Type definition of mef_entry*/
-typedef struct _mef_cfg {
+typedef struct _mef_cfg_data {
 	/** criteria*/
 	t_u32 criteria;
 	/** entry num*/
 	t_u16 entry_num;
 	/** entry pointer*/
 	mef_entry_t *pentry;
-} mef_cfg;
+} mef_cfg_data;
 
 /** Type definition of mef_entry*/
 typedef struct _mef_entry {
+	/** Flag for auto arp entry*/
+	int enable_autoarp_entry;
 	/** Num for wowlan entry*/
 	int num_wowlan_entry;
 	/** Num for IPv6 neighbor solicitation message offload */
 	int num_ipv6_ns_offload;
-
+	int clear_mef_entry;
 	/** criteria*/
 	t_u32 criteria;
 	/** MEF CFG Array to store etted_entry_bitmap;
@@ -1806,14 +1931,22 @@ typedef struct _mlan_init_para {
 	t_u32 dev_cap_mask;
 	/** oob independent reset mode */
 	t_u32 indrstcfg;
-	/** fw region */
-	t_bool fw_region;
+	/** drcs channel time mode */
+	t_u32 drcs_chantime_mode;
 	/** passive to active scan */
 	t_u8 passive_to_active_scan;
 	/** uap max sta */
 	t_u8 uap_max_sta;
 	/** dfs w53 cfg */
 	t_u8 dfs53cfg;
+	/** dfs_offload */
+	t_u8 dfs_offload;
+#ifdef PCIE
+	/** adma ring size */
+	t_u16 ring_size;
+#endif
+	t_u8 ext_scan;
+	t_u8 mcs32;
 } mlan_init_para, *pmlan_init_para;
 
 #ifdef SDIO
@@ -1883,7 +2016,16 @@ typedef struct _mlan_sdio_card_reg {
 
 typedef struct _mlan_sdio_card {
 	const mlan_sdio_card_reg *reg;
-
+	/** maximum ports */
+	t_u8 max_ports;
+	/** mp aggregation packet limit */
+	t_u8 mp_aggr_pkt_limit;
+	/** sdio new mode support */
+	t_bool supports_sdio_new_mode;
+	/** max tx aggr buf size */
+	t_u32 mp_tx_aggr_buf_size;
+	/** max rx aggr buf size */
+	t_u32 mp_rx_aggr_buf_size;
 	/** IO port */
 	t_u32 ioport;
 	/** number of interrupt receive */
@@ -1931,6 +2073,8 @@ typedef struct _mlan_sdio_card {
 	t_u32 mpa_sent_no_ports;
 	/** last wr_bitmap from FW */
 	t_u32 last_recv_wr_bitmap;
+	/** last wr_bitmap from FW */
+	t_u32 last_recv_rd_bitmap;
 	/** last mp_wr_bitmap */
 	t_u32 last_mp_wr_bitmap[SDIO_MP_DBG_NUM];
 	/** last ports for cmd53 write data */
@@ -1968,12 +2112,16 @@ typedef struct _mlan_sdio_card {
 #endif
 
 #ifdef PCIE
-/** 8 Event buffer ring */
-#define MLAN_MAX_EVT_BD 0x08
-/** 32 entry will mapping to 5*/
-#define TX_RX_NUM_DESC 5
+#define MAX_TXRX_BD 32
+#define ADMA_MAX_TXRX_BD 512
+#define ADMA_DEF_TXRX_BD 128
+/** 128 entry will mapping to 7*/
+#define TXRX_DEF_NUM_DESC 7
 /** 8 entry will mapping to 3 */
 #define EVT_NUM_DESC 3
+#define MLAN_MAX_TXRX_BD MAX(ADMA_MAX_TXRX_BD, MAX_TXRX_BD)
+/** 8 Event buffer ring */
+#define MLAN_MAX_EVT_BD 0x08
 typedef struct _mlan_pcie_card_reg {
 	/* TX buffer description rd pointer */
 	t_u32 reg_txbd_rdptr;
@@ -2027,7 +2175,12 @@ typedef struct _mlan_pcie_card_reg {
 	t_u32 host_intr_cmd_done;
 	/** Event ready interrupt for host */
 	t_u32 host_intr_event_rdy;
+	/** cmd dnld interrupt for host */
 	t_u32 host_intr_cmd_dnld;
+	/** adma align size */
+	t_u8 adma_align_size;
+	/** adma min pkt size */
+	t_u8 adma_min_pkt_size;
 	/* TX/RX buffer description mask */
 	t_u32 txrx_rw_ptr_mask;
 	/* TX/RX buffer description wrap mask */
@@ -2066,6 +2219,10 @@ typedef struct _mlan_pcie_card {
 	mlan_buffer *tx_buf_list[MLAN_MAX_TXRX_BD];
 	/** Flush indicator for txbd_ring */
 	t_bool txbd_flush;
+	/** txrx data dma ring size */
+	t_u16 txrx_bd_size;
+	/** txrx num desc */
+	t_u16 txrx_num_desc;
 
 	/** Shadow copy of RXBD write pointer */
 	t_u32 rxbd_wrptr;
@@ -2119,6 +2276,8 @@ typedef struct _mlan_usb_card {
 	/** USB sggregation supported by FW */
 	t_u8 fw_usb_aggr;
 
+	/** port status: MFALSE-port available MTRUE--port busy*/
+	t_u8 usb_port_status[MAX_USB_TX_PORT_NUM];
 } mlan_usb_card, *pmlan_usb_card;
 
 #endif
@@ -2126,6 +2285,8 @@ typedef struct _mlan_usb_card {
 typedef struct _mlan_card_info {
 	/** Max Tx buffer size */
 	t_u32 max_tx_buf_size;
+	/** support V14_FW_API */
+	t_u8 v14_fw_api;
 	/** support V16_FW_API */
 	t_u8 v16_fw_api;
 	/** support V17_FW_API */
@@ -2134,6 +2295,7 @@ typedef struct _mlan_card_info {
 	t_u8 supp_ps_handshake;
 	/** DEFAULT_11N_TX_BF_CAP */
 	t_u32 default_11n_tx_bf_cap;
+	t_u8 support_11mc;
 } mlan_card_info, *pmlan_card_info;
 
 typedef struct _mlan_adapter mlan_adapter, *pmlan_adapter;
@@ -2168,12 +2330,16 @@ typedef struct _adapter_operations {
 					pmlan_buffer pmbuf);
 	/** handle dump interface specific info */
 	mlan_status (*debug_dump)(mlan_adapter *pmadapter);
+	/** disable host interrupt */
+	mlan_status (*disable_host_int)(mlan_adapter *pmadapter);
+	/** enable host interrupt */
+	mlan_status (*enable_host_int)(mlan_adapter *pmadapter);
 	/**Interface header length*/
 	t_u32 intf_header_len;
 } mlan_adapter_operations;
 
 /** Adapter data structure for MLAN */
-typedef struct _mlan_adapter {
+struct _mlan_adapter {
 	/** MOAL handle structure */
 	t_void *pmoal_handle;
 	/** BSS Attributes */
@@ -2240,6 +2406,8 @@ typedef struct _mlan_adapter {
 	t_u8 fw_ver;
 	/** firmware minor version */
 	t_u8 fw_min_ver;
+	/** firmare hotfix version */
+	t_u8 fw_hotfix_ver;
 	/** uap firmware version */
 	t_u8 uap_fw_ver;
 	/** mac address retrun from get_hw_spec */
@@ -2252,12 +2420,9 @@ typedef struct _mlan_adapter {
 	t_u32 fw_cap_info;
 	/** Extended firmware capability information */
 	t_u32 fw_cap_ext;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	/** High byte for 5G, low byte for 2G, like 0x2211 0x22 for 5G, 0x11 for
 	 * 2G */
 	t_u16 user_htstream;
-#endif
 	/** vdll ctrl */
 	vdll_dnld_ctrl vdll_ctrl;
 #if defined(SDIO) || defined(PCIE)
@@ -2294,6 +2459,8 @@ typedef struct _mlan_adapter {
 	 *       FALSE - Tx done received for previous Tx
 	 */
 	t_u8 data_sent;
+	/** Data sent cnt */
+	t_u32 data_sent_cnt;
 	/** CMD sent:
 	 *       TRUE - CMD is sent to fw, no CMD Done received
 	 *       FALSE - CMD done received for previous CMD
@@ -2343,6 +2510,8 @@ typedef struct _mlan_adapter {
 	mlan_list_head cmd_pending_q;
 	/** Command queue for scanning */
 	mlan_list_head scan_pending_q;
+	/** Command pending queue while scanning */
+	mlan_list_head ext_cmd_pending_q;
 	/** ioctl pending queue */
 	mlan_list_head ioctl_pending_q;
 	/** pending_ioctl flag */
@@ -2350,6 +2519,12 @@ typedef struct _mlan_adapter {
 	pmlan_private pending_disconnect_priv;
 	/** mlan_processing */
 	t_u32 scan_processing;
+	/** scan state */
+	t_u32 scan_state;
+	/** firmware support for roaming*/
+	t_u8 fw_roaming;
+	/** User set passphrase*/
+	t_u8 userset_passphrase;
 	/** ext_scan enh support flag */
 	t_u8 ext_scan_enh;
 	/** scan type: 0 legacy, 1: enhance scan*/
@@ -2401,6 +2576,8 @@ typedef struct _mlan_adapter {
 	wlan_dfs_testing_settings_t dfs_test_params;
 	/**  dfs w53 cfg */
 	t_u8 dfs53cfg;
+	/**  dfs_mode */
+	t_u8 dfs_mode;
 	/** FSM variable for MEAS support */
 	wlan_meas_state_t state_meas;
 	/** Scan table */
@@ -2415,6 +2592,9 @@ typedef struct _mlan_adapter {
 	t_u32 num_in_chan_stats;
 	/** index of chan stats */
 	t_u32 idx_chan_stats;
+	ChanStatistics_t *pold_chan_stats;
+	/** index of chan stats */
+	t_u32 old_idx_chan_stats;
 	t_u8 bgscan_reported;
 
 	/** Number of records in the scan table */
@@ -2440,7 +2620,7 @@ typedef struct _mlan_adapter {
 	t_u8 scan_block;
 	/** Extended scan or legacy scan */
 	t_u8 ext_scan;
-	t_u16 bcn_buf_size;
+	t_u32 bcn_buf_size;
 	/** Beacon buffer */
 	t_u8 *bcn_buf;
 	/** Pointer to valid beacon buffer end */
@@ -2473,11 +2653,21 @@ typedef struct _mlan_adapter {
 	/** Tx data endpoint address */
 	t_u8 tx_data_ep;
 #endif
+	/** Multi channel status */
+	t_u8 mc_status;
+#ifdef USB
+	/** port status: MFALSE-port available MTRUE--port busy*/
+	t_u8 usb_port_status[MAX_USB_TX_PORT_NUM];
+	/** usb tx ports */
+	t_u8 usb_tx_ports[MAX_USB_TX_PORT_NUM];
+#endif
 
 	/** sleep_params_t */
 	sleep_params_t sleep_params;
 	/** sleep_period_t (Enhanced Power Save) */
 	sleep_period_t sleep_period;
+	/** saved sleep_period_t (Enhanced Power Save) */
+	sleep_period_t saved_sleep_period;
 
 	/** Power Save mode */
 	/**
@@ -2552,6 +2742,8 @@ typedef struct _mlan_adapter {
 	t_u32 hw_dot_11n_dev_cap;
 	/** Device support for MIMO abstraction of MCSs */
 	t_u8 hw_dev_mcs_support;
+	/** mpdu density */
+	t_u8 hw_mpdu_density;
 #ifdef STA_SUPPORT
 	/** Adhoc Secondary Channel Bandwidth */
 	t_u8 chan_bandwidth;
@@ -2582,6 +2774,12 @@ typedef struct _mlan_adapter {
 	/** RX pending for forwarding packets */
 	mlan_scalar pending_bridge_pkts;
 
+#ifdef STA_SUPPORT
+	/** ARP filter buffer */
+	t_u8 arp_filter[ARP_FILTER_MAX_BUF_SIZE];
+	/** ARP filter buffer size */
+	t_u32 arp_filter_size;
+#endif /* STA_SUPPORT */
 	/** Minimum delay between HsActive and HostWake (in msec) */
 	t_u16 min_wake_holdoff;
 	/** Host sleep wake interval(in msec) */
@@ -2609,7 +2807,7 @@ typedef struct _mlan_adapter {
 	/** management frame wakeup filter config */
 	mlan_mgmt_frame_wakeup mgmt_filter[MAX_MGMT_FRAME_FILTER];
 	/** Bypass TX queue pkt count  */
-	t_u16 bypass_pkt_count;
+	t_u32 bypass_pkt_count;
 #ifdef STA_SUPPORT
 	/** warm-reset IOCTL request buffer pointer */
 	pmlan_ioctl_req pwarm_reset_ioctl_req;
@@ -2628,6 +2826,11 @@ typedef struct _mlan_adapter {
 	t_u8 *pcal_data;
 	/** Cal data length  */
 	t_u32 cal_data_len;
+	/** tdls status */
+	/* TDLS_NOT_SETUP|TDLS_SWITCHING_CHANNEL|TDLS_IN_BASE_CHANNEL|TDLS_IN_SWITCH_CHANNEL*/
+	tdlsStatus_e tdls_status;
+	/** NetMon enabled */
+	t_u32 enable_net_mon;
 	/** Feature control bitmask */
 	t_u32 feature_control;
 
@@ -2635,10 +2838,12 @@ typedef struct _mlan_adapter {
 	t_u8 coex_rx_winsize;
 	t_bool dfs_repeater;
 	t_u32 dfsr_channel;
+	t_bool mc_policy;
 	t_u8 chanrpt_param_bandcfg;
 #if defined(PCIE)
 	mlan_buffer *ssu_buf;
 #endif
+	t_u8 csi_enabled;
 	/** maximum sta connection */
 	t_u8 max_sta_conn;
 	otp_region_info_t *otp_region;
@@ -2658,7 +2863,18 @@ typedef struct _mlan_adapter {
 	/** authenticator_priv */
 	pmlan_private authenticator_priv;
 #endif
-} mlan_adapter, *pmlan_adapter;
+	/** TP accounting mode 1-enable 0-disable */
+	t_u32 tp_state_on;
+	/** Packet drop point */
+	t_u32 tp_state_drop_point;
+	/** second mac flag */
+	t_u8 second_mac;
+	/* lower 8 bytes of uuid */
+	t_u64 uuid_lo;
+
+	/* higher 8 bytes of uuid */
+	t_u64 uuid_hi;
+};
 
 /** Check if stream 2X2 enabled */
 #define IS_STREAM_2X2(x) ((x)&FEATURE_CTRL_STREAM_2X2)
@@ -2677,6 +2893,31 @@ typedef struct _mlan_adapter {
 /** Ethernet packet type offset */
 #define MLAN_ETHER_PKT_TYPE_OFFSET (12)
 
+/** Rx packet Sniffer Operation Mode
+ *
+ * MODE1 : Can be enabled only in disconnected state.
+ *
+ * MODE3 : Can be enabled irrespective of active connection state.
+ *         Both 802.11 and rtap headers are attached to all destined
+ *         unicast data frames in the FW and uploaded to the host driver.
+ *         Such frame will be duplicated in mlan, one for monitor interface
+ *         and other for data interface, by reconstructing the 802.3 header.
+ */
+#define NET_MON_MODE_DISABLED 0
+#define NET_MON_MODE1 1
+#define NET_MON_MODE3 3
+mlan_status wlan_cmd_net_monitor(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf);
+
+mlan_status wlan_ret_net_monitor(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf);
+
+mlan_status wlan_misc_ioctl_net_monitor(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req);
+
+void wlan_rxpdinfo_to_radiotapinfo(pmlan_private priv, RxPD *prx_pd,
+				   radiotap_info *prt_info);
+
 mlan_status wlan_init_lock_list(pmlan_adapter pmadapter);
 mlan_status wlan_init_priv_lock_list(pmlan_adapter pmadapter, t_u8 start_index);
 t_void wlan_free_lock_list(pmlan_adapter pmadapter);
@@ -2705,7 +2946,10 @@ t_void wlan_init_adapter(pmlan_adapter pmadapter);
 
 /** Initialize mlan_private structure */
 mlan_status wlan_init_priv(pmlan_private priv);
-
+#ifdef USB
+/** get pcie device from card type */
+mlan_status wlan_get_usb_device(pmlan_adapter pmadapter);
+#endif
 mlan_status wlan_download_vdll_block(mlan_adapter *pmadapter, t_u8 *block,
 				     t_u16 block_len);
 mlan_status wlan_process_vdll_event(pmlan_private pmpriv, pmlan_buffer pevent);
@@ -2746,7 +2990,8 @@ mlan_status wlan_misc_ioctl_init_shutdown(pmlan_adapter pmadapter,
 mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 				     pmlan_ioctl_req pioctl_req);
 
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
+#if defined(STA_SUPPORT) || defined(UAP_SUPPORT)
+extern pmlan_operations mlan_ops[];
 /** Set/Get BSS role */
 mlan_status wlan_bss_ioctl_bss_role(pmlan_adapter pmadapter,
 				    pmlan_ioctl_req pioctl_req);
@@ -2756,6 +3001,12 @@ mlan_status wlan_bss_ioctl_bss_role(pmlan_adapter pmadapter,
 mlan_status wlan_misc_ssu(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req);
 #endif
 
+mlan_status wlan_misc_csi(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req);
+mlan_status wlan_process_csi_event(pmlan_private pmpriv);
+
+mlan_status wlan_misc_hal_phy_cfg(pmlan_adapter pmadapter,
+				  pmlan_ioctl_req pioctl_req);
+
 mlan_status wlan_set_ewpa_mode(mlan_private *priv, pmlan_ds_passphrase psec_pp);
 mlan_status wlan_find_bss(mlan_private *pmpriv, pmlan_ioctl_req pioctl_req);
 
@@ -2782,6 +3033,7 @@ t_void wlan_release_cmd_lock(mlan_adapter *pmadapter);
 #ifdef STA_SUPPORT
 /** Flush the scan pending queue */
 t_void wlan_flush_scan_queue(pmlan_adapter pmadapter);
+t_void wlan_move_cmd_to_cmd_pending_q(pmlan_adapter pmadapter);
 mlan_status wlan_cancel_pending_scan_cmd(pmlan_adapter pmadapter,
 					 pmlan_ioctl_req pioctl_req);
 #endif
@@ -2911,8 +3163,9 @@ t_u8 wlan_bypass_tx_list_empty(mlan_adapter *pmadapter);
 /** Check if this is the last packet */
 t_u8 wlan_check_last_packet_indication(pmlan_private priv);
 
-#define MOAL_ALLOC_MLAN_BUFFER (0)
-#define MOAL_MALLOC_BUFFER (1)
+#define MOAL_ALLOC_MLAN_BUFFER MBIT(0)
+#define MOAL_MALLOC_BUFFER MBIT(1)
+#define MOAL_MEM_FLAG_ATOMIC MBIT(2)
 
 #ifdef PCIE
 /* This defines the direction arg to the DMA mapping routines. */
@@ -2999,6 +3252,25 @@ mlan_status wlan_ret_p2p_params_config(pmlan_private pmpriv,
 mlan_status wlan_misc_p2p_config(pmlan_adapter pmadapter,
 				 pmlan_ioctl_req pioctl_req);
 #endif
+mlan_status wlan_cmd_gpio_tsf_latch(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				    mlan_ioctl_req *pioctl_buf,
+				    t_void *pdata_buf);
+mlan_status wlan_ret_gpio_tsf_latch(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *resp,
+				    mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_misc_gpio_tsf_latch_config(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req);
+mlan_status wlan_misc_get_tsf_info(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req);
+mlan_status wlan_cmd_cross_chip_synch(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				      t_void *pdata_buf);
+mlan_status wlan_ret_cross_chip_synch(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *resp,
+				      mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_misc_ioctl_cross_chip_synch(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req);
 /** get ralist info */
 int wlan_get_ralist_info(mlan_private *priv, pralist_info buf);
 /** dump ralist */
@@ -3102,19 +3374,61 @@ mlan_status wlan_adapter_init_cmd(pmlan_adapter pmadapter);
 mlan_status wlan_radio_ioctl_band_cfg(pmlan_adapter pmadapter,
 				      pmlan_ioctl_req pioctl_req);
 
-#ifdef RX_PACKET_COALESCE
-mlan_status wlan_cmd_rx_pkt_coalesce_cfg(pmlan_private pmpriv,
-					 HostCmd_DS_COMMAND *cmd,
-					 t_u16 cmd_action, t_void *pdata_buf);
-mlan_status wlan_ret_rx_pkt_coalesce_cfg(pmlan_private pmpriv,
-					 const HostCmd_DS_COMMAND *resp,
-					 mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_handle_event_multi_chan_info(pmlan_private pmpriv,
+					      pmlan_buffer pevent);
+#ifdef USB
+
+/**
+ *  @brief  This function update the port status
+ *
+ *  @param pmadapter	A pointer to mlan_adapter
+ *  @param port         USB port
+ *  @param status       port status
+ *
+ *  @return		N/A
+ */
+static INLINE void wlan_update_port_status(pmlan_adapter pmadapter, t_u32 port,
+					   t_u8 status)
+{
+	int i;
+	for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
+		if (port == pmadapter->usb_tx_ports[i]) {
+			pmadapter->pcard_usb->usb_port_status[i] = status;
+			break;
+		}
+	}
+	return;
+}
+
+inline t_u8 wlan_usb_data_sent(pmlan_adapter pmadapter);
+void wlan_resync_usb_port(pmlan_adapter pmadapter);
+
+/**
+ *  @brief  This function return port index
+ *
+ *  @param pmadapter	A pointer to mlan_adapter
+ *  @param port         USB port
+ *  @return		port index
+ *
+ */
+static INLINE t_u8 wlan_get_port_index(pmlan_adapter pmadapter, t_u32 port)
+{
+	t_u8 i;
+	for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
+		if (port == pmadapter->usb_tx_ports[i]) {
+			return i;
+		}
+	}
+	return 0;
+}
+
 #endif
 
-#ifdef STA_SUPPORT
 /** warm reset */
 mlan_status wlan_misc_ioctl_warm_reset(pmlan_adapter pmadapter,
 				       pmlan_ioctl_req pioctl_req);
+
+#ifdef STA_SUPPORT
 /** Process received packet */
 mlan_status wlan_process_rx_packet(pmlan_adapter pmadapter, pmlan_buffer pmbuf);
 /** ioctl handler for station mode */
@@ -3161,6 +3475,7 @@ mlan_status wlan_cmd_802_11_scan(pmlan_private pmpriv, HostCmd_DS_COMMAND *pcmd,
 mlan_status wlan_ret_802_11_scan(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 				 t_void *pioctl_buf);
 
+t_u8 wlan_get_ext_scan_state(HostCmd_DS_COMMAND *pcmd);
 /** Extended scan command handler */
 mlan_status wlan_cmd_802_11_scan_ext(pmlan_private pmpriv,
 				     HostCmd_DS_COMMAND *pcmd,
@@ -3213,9 +3528,9 @@ t_void wlan_reset_connect_state(pmlan_private priv, t_u8 drv_disconnect);
 t_void wlan_2040_coex_event(pmlan_private pmpriv);
 
 /** convert band to radio type */
-t_u8 wlan_band_to_radio_type(t_u8 band);
+t_u8 wlan_band_to_radio_type(t_u16 band);
 /** convert radio_type to band */
-t_u8 radio_type_to_band(t_u8 chanBand);
+t_u16 radio_type_to_band(t_u8 chanBand);
 
 /** Disconnect */
 mlan_status wlan_disconnect(mlan_private *pmpriv, mlan_ioctl_req *pioctl_req,
@@ -3261,18 +3576,19 @@ mlan_status wlan_ret_802_11_bgscan_query(mlan_private *pmpriv,
 
 /** Get Channel-Frequency-Power by band and channel */
 chan_freq_power_t *
-wlan_get_cfp_by_band_and_channel(pmlan_adapter pmadapter, t_u8 band,
+wlan_get_cfp_by_band_and_channel(pmlan_adapter pmadapter, t_u16 band,
 				 t_u16 channel, region_chan_t *region_channel);
 /** Find Channel-Frequency-Power by band and channel */
 chan_freq_power_t *wlan_find_cfp_by_band_and_channel(mlan_adapter *pmadapter,
-						     t_u8 band, t_u16 channel);
+						     t_u16 band, t_u16 channel);
 /** Find Channel-Frequency-Power by band and frequency */
 chan_freq_power_t *wlan_find_cfp_by_band_and_freq(mlan_adapter *pmadapter,
-						  t_u8 band, t_u32 freq);
+						  t_u16 band, t_u32 freq);
 /** Get Tx power of channel from Channel-Frequency-Power */
-t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u8 channel);
+t_u8 wlan_get_txpwr_of_chan_from_cfp(mlan_private *pmpriv, t_u16 band,
+				     t_u8 channel);
 /** find frequency from band and channel */
-t_u32 wlan_find_freq_from_band_chan(t_u8, t_u8);
+t_u32 wlan_find_freq_from_band_chan(t_u16 band, t_u8 chan);
 
 /*  Save a beacon buffer of the current bss descriptor */
 t_void wlan_save_curr_bcn(mlan_private *pmpriv);
@@ -3282,6 +3598,8 @@ t_void wlan_free_curr_bcn(mlan_private *pmpriv);
 #endif /* STA_SUPPORT */
 
 /* Rate related functions */
+t_u8 wlan_convert_v14_tx_rate_info(pmlan_private pmpriv, t_u8 v14_rate_info);
+t_u8 wlan_convert_v14_rx_rate_info(pmlan_private pmpriv, t_u8 v14_rate_info);
 /** Convert index into data rate */
 t_u32 wlan_index_to_data_rate(pmlan_adapter pmadapter, t_u8 index,
 			      t_u8 rate_info, t_u8 ext_rate_info);
@@ -3301,6 +3619,12 @@ mlan_status wlan_cmd_rxabortcfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 				t_u16 cmd_action, t_void *pdata_buf);
 mlan_status wlan_ret_rxabortcfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 				mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_cmd_ofdmdesense_cfg(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				     t_void *pdata_buf);
+mlan_status wlan_ret_ofdmdesense_cfg(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *resp,
+				     mlan_ioctl_req *pioctl_buf);
 mlan_status wlan_cmd_rxabortcfg_ext(pmlan_private pmpriv,
 				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
 				    t_void *pdata_buf);
@@ -3320,7 +3644,14 @@ mlan_status wlan_cmd_dot11mc_unassoc_ftm_cfg(pmlan_private pmpriv,
 mlan_status wlan_ret_dot11mc_unassoc_ftm_cfg(pmlan_private pmpriv,
 					     HostCmd_DS_COMMAND *resp,
 					     mlan_ioctl_req *pioctl_buf);
-
+mlan_status wlan_cmd_hal_phy_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_u16 *pdata_buf);
+mlan_status wlan_ret_hal_phy_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_cmd_ips_config(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				t_u16 cmd_action, t_void *pdata_buf);
+mlan_status wlan_ret_ips_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+			     mlan_ioctl_req *pioctl_buf);
 mlan_status wlan_cmd_rate_adapt_cfg(pmlan_private pmpriv,
 				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
 				    t_void *pdata_buf);
@@ -3342,6 +3673,8 @@ mlan_status wlan_ret_arb_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 
 mlan_status wlan_misc_ioctl_rxabortcfg(pmlan_adapter pmadapter,
 				       pmlan_ioctl_req pioctl_req);
+mlan_status wlan_misc_ioctl_ofdmdesense_cfg(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req);
 mlan_status wlan_misc_ioctl_rxabortcfg_ext(pmlan_adapter pmadapter,
 					   pmlan_ioctl_req pioctl_req);
 mlan_status wlan_misc_ioctl_tx_ampdu_prot_mode(pmlan_adapter pmadapter,
@@ -3360,32 +3693,41 @@ mlan_status wlan_misc_ioctl_rf_test_cfg(pmlan_adapter pmadapter,
 					pmlan_ioctl_req pioctl_req);
 mlan_status wlan_misc_ioctl_range_ext(pmlan_adapter pmadapter,
 				      pmlan_ioctl_req pioctl_req);
+mlan_status wlan_misc_ioctl_twt_report(pmlan_adapter pmadapter,
+				       pmlan_ioctl_req pioctl_req);
+mlan_status wlan_ret_twt_report(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				mlan_ioctl_req *pioctl_buf);
 mlan_status wlan_misc_ioctl_arb_cfg(pmlan_adapter pmadapter,
 				    pmlan_ioctl_req pioctl_req);
+mlan_status wlan_misc_ioctl_tp_state(pmlan_adapter pmadapter,
+				     pmlan_ioctl_req pioctl_req);
 /* CFP related functions */
 /** Region code index table */
 extern t_u16 region_code_index[MRVDRV_MAX_REGION_CODE];
-/** The table to keep CFP code for BG */
-extern t_u16 cfp_code_index_bg[MRVDRV_MAX_CFP_CODE_BG];
 /** The table to keep CFP code for A */
 extern t_u16 cfp_code_index_a[MRVDRV_MAX_CFP_CODE_A];
 
 /** Set region table */
-mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u8 band);
+mlan_status wlan_set_regiontable(mlan_private *pmpriv, t_u8 region, t_u16 band);
 /** Get radar detection requirements*/
 t_bool wlan_get_cfp_radar_detect(mlan_private *priv, t_u8 chnl);
 /** check if scan type is passive for b/g band*/
 t_bool wlan_bg_scan_type_is_passive(mlan_private *priv, t_u8 chnl);
 /** check if channel is NO_IR (passive) */
-t_bool wlan_is_chan_passive(mlan_private *priv, t_u8 band, t_u8 chan);
+t_bool wlan_is_chan_passive(mlan_private *priv, t_u16 band, t_u8 chan);
 /** check if channel is disabled */
-t_bool wlan_is_chan_disabled(mlan_private *priv, t_u8 band, t_u8 chan);
+t_bool wlan_is_chan_disabled(mlan_private *priv, t_u16 band, t_u8 chan);
 /** check if channel is blacklisted */
-t_bool wlan_is_chan_blacklisted(mlan_private *priv, t_u8 band, t_u8 chan);
+t_bool wlan_is_chan_blacklisted(mlan_private *priv, t_u16 band, t_u8 chan);
 /** set blacklist setting for a channel */
-t_bool wlan_set_chan_blacklist(mlan_private *priv, t_u8 band, t_u8 chan,
+t_bool wlan_set_chan_blacklist(mlan_private *priv, t_u16 band, t_u8 chan,
 			       t_bool bl);
 
+dfs_state_t wlan_get_chan_dfs_state(mlan_private *priv, t_u16 band, t_u8 chan);
+t_void wlan_set_chan_dfs_state(mlan_private *priv, t_u16 band, t_u8 chan,
+			       dfs_state_t dfs_state);
+t_void wlan_reset_all_chan_dfs_state(mlan_private *priv, t_u16 band,
+				     dfs_state_t dfs_state);
 /* 802.11D related functions */
 /** Initialize 11D */
 t_void wlan_11d_priv_init(mlan_private *pmpriv);
@@ -3408,16 +3750,16 @@ mlan_status wlan_cmd_802_11d_domain_info(mlan_private *pmpriv,
 mlan_status wlan_ret_802_11d_domain_info(mlan_private *pmpriv,
 					 HostCmd_DS_COMMAND *resp);
 /** Convert channel to frequency */
-t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u8 band);
+t_u32 wlan_11d_chan_2_freq(pmlan_adapter pmadapter, t_u8 chan, t_u16 band);
 #ifdef STA_SUPPORT
 /** Set 11D universal table */
-mlan_status wlan_11d_set_universaltable(mlan_private *pmpriv, t_u8 band);
+mlan_status wlan_11d_set_universaltable(mlan_private *pmpriv, t_u16 band);
 /** Clear 11D region table */
 mlan_status wlan_11d_clear_parsedtable(mlan_private *pmpriv);
 /** Create 11D country information for downloading */
-mlan_status wlan_11d_create_dnld_countryinfo(mlan_private *pmpriv, t_u8 band);
+mlan_status wlan_11d_create_dnld_countryinfo(mlan_private *pmpriv, t_u16 band);
 /** Get scan type from 11D info */
-t_u8 wlan_11d_get_scan_type(pmlan_adapter pmadapter, t_u8 band, t_u8 chan,
+t_u8 wlan_11d_get_scan_type(pmlan_adapter pmadapter, t_u16 band, t_u8 chan,
 			    parsed_region_chan_11d_t *parsed_region_chan);
 /** Parse 11D country info */
 mlan_status wlan_11d_parse_dnld_countryinfo(mlan_private *pmpriv,
@@ -3427,11 +3769,11 @@ mlan_status wlan_11d_prepare_dnld_domain_info_cmd(mlan_private *pmpriv);
 /** Parse 11D country information into domain info */
 mlan_status wlan_11d_parse_domain_info(
 	pmlan_adapter pmadapter, IEEEtypes_CountryInfoFullSet_t *country_info,
-	t_u8 band, parsed_region_chan_11d_t *parsed_region_chan);
+	t_u16 band, parsed_region_chan_11d_t *parsed_region_chan);
 #endif /* STA_SUPPORT */
 #ifdef UAP_SUPPORT
 /** Handle 11D domain information from UAP */
-mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u8 band,
+mlan_status wlan_11d_handle_uap_domain_info(mlan_private *pmpriv, t_u16 band,
 					    t_u8 *domain_tlv,
 					    t_void *pioctl_buf);
 #endif
@@ -3462,9 +3804,89 @@ sta_node *wlan_add_station_entry(mlan_private *priv, t_u8 *mac);
 void wlan_check_sta_capability(pmlan_private priv, pmlan_buffer pevent,
 			       sta_node *sta_ptr);
 /** find specific ie */
-t_u8 *wlan_get_specific_ie(pmlan_private priv, t_u8 *ie_buf, t_u8 ie_len,
+t_u8 *wlan_get_specific_ie(pmlan_private priv, t_u8 *ie_buf, t_u16 ie_len,
 			   IEEEtypes_ElementId_e id, t_u8 ext_id);
 t_u8 wlan_is_wmm_ie_present(pmlan_adapter pmadapter, t_u8 *pbuf, t_u16 buf_len);
+/** Ethernet II header */
+typedef struct {
+	/** Ethernet II header destination address */
+	t_u8 dest_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Ethernet II header source address */
+	t_u8 src_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Ethernet II header length */
+	t_u16 ethertype;
+} EthII_Hdr_t;
+
+/**
+ *  @brief This function checks whether a station TDLS link is enabled or not
+ *
+ *  @param priv     A pointer to mlan_private
+ *  @param mac      station mac address
+ *  @return
+ * TDLS_NOT_SETUP/TDLS_SETUP_INPROGRESS/TDLS_SETUP_COMPLETE/TDLS_SETUP_FAILURE/TDLS_TEAR_DOWN
+ */
+static INLINE tdlsStatus_e wlan_get_tdls_link_status(mlan_private *priv,
+						     t_u8 *mac)
+{
+	sta_node *sta_ptr = MNULL;
+	sta_ptr = wlan_get_station_entry(priv, mac);
+	if (sta_ptr)
+		return sta_ptr->status;
+	return TDLS_NOT_SETUP;
+}
+
+/**
+ *  @brief This function checks if TDLS link is in channel switching
+ *
+ *  @param status     tdls link status
+ *  @return         MTRUE/MFALSE
+ */
+static INLINE int wlan_is_tdls_link_chan_switching(tdlsStatus_e status)
+{
+	return (status == TDLS_SWITCHING_CHANNEL) ? MTRUE : MFALSE;
+}
+
+/**
+ *  @brief This function checks if send command to firmware is allowed
+ *
+ *  @param status     tdls link status
+ *  @return         MTRUE/MFALSE
+ */
+static INLINE int wlan_is_send_cmd_allowed(tdlsStatus_e status)
+{
+	int ret = MTRUE;
+	switch (status) {
+	case TDLS_SWITCHING_CHANNEL:
+	case TDLS_IN_OFF_CHANNEL:
+		ret = MFALSE;
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
+
+/**
+ *  @brief This function checks if TDLS link is setup
+ *
+ *  @param status     tdls link status
+ *  @return         MTRUE/MFALSE
+ */
+static INLINE int wlan_is_tdls_link_setup(tdlsStatus_e status)
+{
+	int ret = MFALSE;
+	switch (status) {
+	case TDLS_SWITCHING_CHANNEL:
+	case TDLS_IN_OFF_CHANNEL:
+	case TDLS_IN_BASE_CHANNEL:
+	case TDLS_SETUP_COMPLETE:
+		ret = MTRUE;
+		break;
+	default:
+		break;
+	}
+	return ret;
+}
 
 /**
  *  @brief This function checks tx_pause flag for peer
@@ -3484,6 +3906,29 @@ static INLINE int wlan_is_tx_pause(mlan_private *priv, t_u8 *ra)
 }
 t_u16 wlan_update_ralist_tx_pause(pmlan_private priv, t_u8 *mac, t_u8 tx_pause);
 
+#if defined(USB)
+/**
+ *  @brief  This function used to check if specific port is ready
+ *
+ *  @param pmadapter	A pointer to mlan_adapter
+ *  @param port_index   port index;
+ *
+ *  @return		MTRUE -- port is ready.
+ *              MFALSE -- port is busy.
+ */
+static inline t_u8 wlan_is_port_ready(pmlan_adapter pmadapter, t_u32 port_index)
+{
+	if (IS_USB(pmadapter->card_type))
+		return (pmadapter->pcard_usb->usb_port_status[port_index]) ?
+			       MFALSE :
+			       MTRUE;
+	else
+		return MTRUE;
+}
+#endif
+mlan_status wlan_check_easymesh_pkt(mlan_private *priv, pmlan_buffer pmbuf,
+				    RxPD *prx_pd);
+
 #ifdef UAP_SUPPORT
 mlan_status wlan_process_uap_rx_packet(mlan_private *priv, pmlan_buffer pmbuf);
 t_void wlan_drop_tx_pkts(pmlan_private priv);
@@ -3559,6 +4004,55 @@ mlan_status wlan_ret_802_11_mac_address(pmlan_private pmpriv,
 					HostCmd_DS_COMMAND *resp,
 					mlan_ioctl_req *pioctl_buf);
 
+int wlan_get_tdls_list(mlan_private *priv, tdls_peer_info *buf);
+t_void wlan_hold_tdls_packets(pmlan_private priv, t_u8 *mac);
+t_void wlan_restore_tdls_packets(pmlan_private priv, t_u8 *mac,
+				 tdlsStatus_e status);
+t_void wlan_update_non_tdls_ralist(mlan_private *priv, t_u8 *mac,
+				   t_u8 tx_pause);
+mlan_status wlan_misc_ioctl_tdls_config(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req);
+void wlan_11n_send_delba_to_peer(mlan_private *priv, t_u8 *ra);
+void wlan_process_tdls_action_frame(pmlan_private priv, t_u8 *pbuf, t_u32 len);
+mlan_status wlan_misc_ioctl_tdls_oper(pmlan_adapter pmadapter,
+				      pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_misc_ioctl_tdls_get_ies(pmlan_adapter pmadapter,
+					 pmlan_ioctl_req pioctl_req);
+mlan_status wlan_misc_ioctl_tdls_idle_time(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req);
+
+t_void wlan_tdls_config(pmlan_private pmpriv, t_u8 enable);
+mlan_status wlan_misc_ioctl_tdls_cs_channel(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_config_rtt(pmlan_adapter pmadapter,
+			    pmlan_ioctl_req pioctl_req);
+mlan_status wlan_cancel_rtt(pmlan_adapter pmadapter,
+			    pmlan_ioctl_req pioctl_req);
+mlan_status wlan_rtt_responder_cfg(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req);
+mlan_status wlan_cmd_802_11_ftm_config_session_params(pmlan_private pmpriv,
+						      HostCmd_DS_COMMAND *cmd,
+						      t_u16 cmd_action,
+						      t_u32 cmd_oid,
+						      t_void *pdata_buf);
+mlan_status
+wlan_ret_802_11_ftm_config_session_params(pmlan_private pmpriv,
+					  HostCmd_DS_COMMAND *resp,
+					  mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_fill_hal_rtt_results(pmlan_private pmpriv,
+				      Event_WLS_FTM_t *event_ftm,
+				      t_u32 event_ftm_len, mlan_event *pevent);
+mlan_status wlan_cmd_802_11_ftm_config_responder(pmlan_private pmpriv,
+						 HostCmd_DS_COMMAND *cmd,
+						 t_u16 cmd_action,
+						 t_u32 cmd_oid,
+						 t_void *pdata_buf);
+mlan_status wlan_ret_802_11_ftm_config_responder(pmlan_private pmpriv,
+						 HostCmd_DS_COMMAND *resp,
+						 mlan_ioctl_req *pioctl_buf);
+
 mlan_status wlan_get_info_ver_ext(pmlan_adapter pmadapter,
 				  pmlan_ioctl_req pioctl_req);
 
@@ -3584,6 +4078,10 @@ mlan_status wlan_set_drvdbg(pmlan_adapter pmadapter,
 
 mlan_status wlan_misc_hotspot_cfg(pmlan_adapter pmadapter,
 				  pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_misc_multi_ap_cfg(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req);
+
 #ifdef STA_SUPPORT
 mlan_status wlan_misc_ext_capa_cfg(pmlan_adapter pmadapter,
 				   pmlan_ioctl_req pioctl_req);
@@ -3619,7 +4117,7 @@ int wlan_add_supported_oper_class_ie(mlan_private *pmpriv, t_u8 **pptlv_out,
 mlan_status wlan_get_curr_oper_class(mlan_private *pmpriv, t_u8 channel,
 				     t_u8 bw, t_u8 *oper_class);
 mlan_status wlan_check_operclass_validation(mlan_private *pmpriv, t_u8 channel,
-					    t_u8 oper_class);
+					    t_u8 oper_class, t_u8 bandwidth);
 mlan_status wlan_misc_ioctl_operclass_validation(pmlan_adapter pmadapter,
 						 mlan_ioctl_req *pioctl_req);
 mlan_status wlan_misc_ioctl_oper_class(pmlan_adapter pmadapter,
@@ -3632,6 +4130,8 @@ mlan_status wlan_misc_otp_user_data(pmlan_adapter pmadapter,
 				    pmlan_ioctl_req pioctl_req);
 
 #ifdef USB
+extern mlan_adapter_operations mlan_usb_ops;
+
 mlan_status wlan_misc_ioctl_usb_aggr_ctrl(pmlan_adapter pmadapter,
 					  pmlan_ioctl_req pioctl_req);
 #endif
@@ -3650,10 +4150,37 @@ mlan_status wlan_misc_ioctl_txcontrol(pmlan_adapter pmadapter,
 mlan_status wlan_misc_ioctl_region(pmlan_adapter pmadapter,
 				   pmlan_ioctl_req pioctl_req);
 
-#ifdef RX_PACKET_COALESCE
-mlan_status wlan_misc_ioctl_rx_pkt_coalesce_config(pmlan_adapter pmadapter,
-						   pmlan_ioctl_req pioctl_req);
-#endif
+mlan_status wlan_misc_ioctl_multi_chan_config(pmlan_adapter pmadapter,
+					      pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_cmd_multi_chan_cfg(pmlan_private pmpriv,
+				    HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				    t_void *pdata_buf);
+
+mlan_status wlan_ret_multi_chan_cfg(pmlan_private pmpriv,
+				    const HostCmd_DS_COMMAND *resp,
+				    mlan_ioctl_req *pioctl_buf);
+
+mlan_status wlan_misc_ioctl_multi_chan_policy(pmlan_adapter pmadapter,
+					      pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_cmd_multi_chan_policy(pmlan_private pmpriv,
+				       HostCmd_DS_COMMAND *cmd,
+				       t_u16 cmd_action, t_void *pdata_buf);
+
+mlan_status wlan_ret_multi_chan_policy(pmlan_private pmpriv,
+				       const HostCmd_DS_COMMAND *resp,
+				       mlan_ioctl_req *pioctl_buf);
+
+mlan_status wlan_misc_ioctl_drcs_config(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req);
+
+mlan_status wlan_cmd_drcs_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+			      t_u16 cmd_action, t_void *pdata_buf);
+
+mlan_status wlan_ret_drcs_cfg(pmlan_private pmpriv,
+			      const HostCmd_DS_COMMAND *resp,
+			      mlan_ioctl_req *pioctl_buf);
 
 void wlan_bt_coex_wlan_param_update_event(pmlan_private priv,
 					  pmlan_buffer pevent);
@@ -3676,7 +4203,7 @@ mlan_status wlan_misc_ioctl_cwmode_ctrl(pmlan_adapter pmadapter,
 					pmlan_ioctl_req pioctl_req);
 
 mlan_status wlan_set_mef_entry(mlan_private *pmpriv, pmlan_adapter pmadapter,
-			       mef_cfg *pmef);
+			       mef_cfg_data *pmef);
 mlan_status wlan_process_mef_cfg_cmd(mlan_private *pmpriv,
 				     pmlan_adapter pmadapter);
 mlan_status wlan_misc_ioctl_mef_flt_cfg(pmlan_adapter pmadapter,
@@ -3700,6 +4227,21 @@ mlan_status wlan_ret_802_11_supplicant_pmk(pmlan_private pmpriv,
 mlan_status wlan_sec_ioctl_passphrase(pmlan_adapter pmadapter,
 				      pmlan_ioctl_req pioctl_req);
 
+mlan_status wlan_cmd_mc_aggr_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf);
+mlan_status wlan_ret_mc_aggr_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf);
+mlan_status wlan_misc_ioctl_mc_aggr_cfg(pmlan_adapter pmadapter,
+					mlan_ioctl_req *pioctl_req);
+mlan_status wlan_misc_ioctl_ch_load(pmlan_adapter pmadapter,
+				    mlan_ioctl_req *pioctl_req);
+mlan_status wlan_misc_ioctl_ch_load_results(pmlan_adapter pmadapter,
+					    mlan_ioctl_req *pioctl_req);
+mlan_status wlan_cmd_get_ch_load(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf);
+mlan_status wlan_ret_ch_load(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+			     mlan_ioctl_req *pioctl_buf);
+
 mlan_status wlan_misc_ioctl_get_tsf(pmlan_adapter pmadapter,
 				    pmlan_ioctl_req pioctl_req);
 void wlan_add_fw_cfp_tables(pmlan_private pmpriv, t_u8 *buf, t_u16 buf_left);
@@ -3721,6 +4263,8 @@ mlan_status wlan_ret_get_tsf(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 
 t_u8 wlan_ft_akm_is_used(mlan_private *pmpriv, t_u8 *rsn_ie);
 
+mlan_status wlan_clear_fw_roaming_pmk(pmlan_private pmpriv);
+
 mlan_status wlan_get_rgchnpwr_cfg(pmlan_adapter pmadapter,
 				  mlan_ioctl_req *pioctl_req);
 mlan_status wlan_get_chan_trpc_cfg(pmlan_adapter pmadapter,
@@ -3764,6 +4308,12 @@ mlan_status wlan_cmd_config_dyn_bw(pmlan_private pmpriv,
 mlan_status wlan_ret_dyn_bw(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			    mlan_ioctl_req *pioctl_buf);
 
+#ifdef UAP_SUPPORT
+/** wacp mode misc ioctl */
+mlan_status wlan_misc_ioctl_wacp_mode(pmlan_adapter pmadapter,
+				      mlan_ioctl_req *pioctl_req);
+#endif
+
 mlan_status wlan_power_ioctl_set_get_lpm(pmlan_adapter pmadapter,
 					 pmlan_ioctl_req pioctl_req);
 mlan_status wlan_cmd_set_get_low_power_mode_cfg(pmlan_private pmpriv,
@@ -3779,6 +4329,18 @@ mlan_status wlan_cmd_range_ext(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 mlan_status wlan_ret_range_ext(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 			       mlan_ioctl_req *pioctl_buf);
 
+mlan_status wlan_misc_ioctl_get_sensor_temp(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req);
+mlan_status wlan_cmd_get_sensor_temp(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *cmd, t_u16 cmd_action);
+mlan_status wlan_ret_get_sensor_temp(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *resp,
+				     mlan_ioctl_req *pioctl_buf);
+
+/** Set/Get Country code */
+mlan_status wlan_misc_ioctl_country_code(pmlan_adapter pmadapter,
+					 mlan_ioctl_req *pioctl_req);
+
 /**
  *  @brief RA based queueing
  *
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c
old mode 100644
new mode 100755
index 38d16af57..5ed477627
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.c
@@ -12,7 +12,7 @@
  *    - ENABLE_MEAS
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -42,9 +42,6 @@ Change Log:
 #include "mlan_ioctl.h"
 #include "mlan_meas.h"
 
-/** Default measurement duration when not provided by the application */
-#define WLAN_MEAS_DEFAULT_MEAS_DURATION 1000U /* TUs */
-
 #ifdef DEBUG_LEVEL2
 /** String descriptions of the different measurement enums.  Debug display */
 static const char *meas_type_str[WLAN_MEAS_NUM_TYPES] = {
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h
old mode 100644
new mode 100755
index c69f41890..2106391d8
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_meas.h
@@ -9,7 +9,7 @@
  *  @sa mlan_meas.c
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c
old mode 100644
new mode 100755
index a6208fa5e..0ed32ca94
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_misc.c
@@ -4,7 +4,7 @@
  *  @brief This file include miscellaneous functions for MLAN module
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -49,10 +49,6 @@ Change Log:
 /********************************************************
 			Global Variables
 ********************************************************/
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
-extern pmlan_operations mlan_ops[];
-#endif
-extern t_u8 ac_to_tid[4][2];
 
 /********************************************************
 			Local Functions
@@ -65,7 +61,7 @@ extern t_u8 ac_to_tid[4][2];
  *
  *  @return        MTRUE/MFALSE;
  */
-t_u8 wlan_pending_interrupt(pmlan_adapter pmadapter)
+static t_u8 wlan_pending_interrupt(pmlan_adapter pmadapter)
 {
 	if (!IS_USB(pmadapter->card_type) && pmadapter->ireg)
 		return MTRUE;
@@ -228,7 +224,7 @@ static mlan_status wlan_custom_ioctl_auto_delete(pmlan_private pmpriv,
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_adapter pmadapter = pmpriv->adapter;
 	t_u16 index = 0, insert = MFALSE, del_len;
-	t_u8 del_ie[MAX_IE_SIZE], ie[MAX_IE_SIZE];
+	t_u8 del_ie[MAX_IE_SIZE], ie[MAX_IE_SIZE] = {0};
 	t_s32 cnt, tmp_len = 0;
 	t_u8 *tmp_ie;
 
@@ -425,6 +421,8 @@ mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 			wlan_get_txbastream_tbl(pmpriv, debug_info->tx_tbl);
 		debug_info->ralist_num =
 			wlan_get_ralist_info(pmpriv, debug_info->ralist);
+		debug_info->tdls_peer_num =
+			wlan_get_tdls_list(pmpriv, debug_info->tdls_peer_list);
 		debug_info->ps_mode = pmadapter->ps_mode;
 		debug_info->ps_state = pmadapter->ps_state;
 #ifdef STA_SUPPORT
@@ -443,6 +441,7 @@ mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 		debug_info->port_open = pmpriv->port_open;
 		debug_info->bypass_pkt_count = pmadapter->bypass_pkt_count;
 		debug_info->scan_processing = pmadapter->scan_processing;
+		debug_info->scan_state = pmadapter->scan_state;
 		debug_info->mlan_processing = pmadapter->mlan_processing;
 		debug_info->main_lock_flag = pmadapter->main_lock_flag;
 		debug_info->main_process_cnt = pmadapter->main_process_cnt;
@@ -533,6 +532,10 @@ mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 				pmadapter->pcard_sd->mpa_sent_no_ports;
 			debug_info->last_recv_wr_bitmap =
 				pmadapter->pcard_sd->last_recv_wr_bitmap;
+			debug_info->last_recv_rd_bitmap =
+				pmadapter->pcard_sd->last_recv_rd_bitmap;
+			debug_info->mp_data_port_mask =
+				pmadapter->pcard_sd->mp_data_port_mask;
 			debug_info->last_mp_index =
 				pmadapter->pcard_sd->last_mp_index;
 			memcpy_ext(
@@ -568,7 +571,7 @@ mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 				   sizeof(pmadapter->pcard_sd->mpa_rx_count),
 				   sizeof(debug_info->mpa_rx_count));
 			debug_info->mp_aggr_pkt_limit =
-				SDIO_MP_AGGR_DEF_PKT_LIMIT;
+				pmadapter->pcard_sd->mp_aggr_pkt_limit;
 		}
 #endif
 #ifdef PCIE
@@ -597,14 +600,12 @@ mlan_status wlan_get_info_debug_info(pmlan_adapter pmadapter,
 				pmadapter->pcard_pcie->evtbd_ring_vbase;
 			debug_info->evtbd_ring_size =
 				pmadapter->pcard_pcie->evtbd_ring_size;
-			memcpy_ext(
-				pmadapter, debug_info->last_tx_pkt_size,
-				pmadapter->pcard_pcie->last_tx_pkt_size,
-				sizeof(pmadapter->pcard_pcie->last_tx_pkt_size),
-				sizeof(debug_info->last_tx_pkt_size));
+			debug_info->txrx_bd_size =
+				pmadapter->pcard_pcie->txrx_bd_size;
 		}
 #endif
 		debug_info->data_sent = pmadapter->data_sent;
+		debug_info->data_sent_cnt = pmadapter->data_sent_cnt;
 		debug_info->cmd_sent = pmadapter->cmd_sent;
 		debug_info->cmd_resp_received = pmadapter->cmd_resp_received;
 		debug_info->tx_pkts_queued =
@@ -687,15 +688,17 @@ mlan_status wlan_misc_ioctl_mac_control(pmlan_adapter pmadapter,
 t_void wlan_wakeup_card_timeout_func(void *function_context)
 {
 	pmlan_adapter pmadapter = (pmlan_adapter)function_context;
+	mlan_private *pmpriv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
 
 	ENTER();
 
 	PRINTM(MERROR, "%s: ps_state=%d\n", __FUNCTION__, pmadapter->ps_state);
 	if (pmadapter->ps_state != PS_STATE_AWAKE) {
-		PRINTM(MERROR, "Wakeup card timeout!\n");
+		PRINTM_NETINTF(MERROR, pmpriv);
+		PRINTM(MERROR, "Wakeup card timeout(%d)!\n",
+		       pmadapter->pm_wakeup_timeout);
 		pmadapter->pm_wakeup_timeout++;
-		wlan_recv_event(wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY),
-				MLAN_EVENT_ID_DRV_DBG_DUMP, MNULL);
+		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_DBG_DUMP, MNULL);
 	}
 	pmadapter->wakeup_fw_timer_is_set = MFALSE;
 
@@ -784,6 +787,8 @@ mlan_status wlan_pm_ioctl_hscfg(pmlan_adapter pmadapter,
 			pmadapter->gpio_wave = pm->param.hs_cfg.gpio_wave;
 			pmadapter->hs_wake_interval =
 				pm->param.hs_cfg.hs_wake_interval;
+			pmadapter->min_wake_holdoff =
+				pm->param.hs_cfg.min_wake_holdoff;
 		}
 		break;
 	case MLAN_ACT_GET:
@@ -801,6 +806,7 @@ mlan_status wlan_pm_ioctl_hscfg(pmlan_adapter pmadapter,
 		pm->param.hs_cfg.ext_gap = pmadapter->ext_gap;
 		pm->param.hs_cfg.gpio_wave = pmadapter->gpio_wave;
 		pm->param.hs_cfg.hs_wake_interval = pmadapter->hs_wake_interval;
+		pm->param.hs_cfg.min_wake_holdoff = pmadapter->min_wake_holdoff;
 		break;
 	default:
 		pioctl_req->status_code = MLAN_ERROR_IOCTL_INVALID;
@@ -917,6 +923,85 @@ mlan_status wlan_misc_ssu(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
 }
 #endif
 
+/**
+ *  @brief Set the hal/phy cfg params.
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success,
+ * otherwise fail
+ */
+mlan_status wlan_misc_hal_phy_cfg(pmlan_adapter pmadapter,
+				  pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *hal_phy_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	t_u16 cmd_act;
+
+	ENTER();
+
+	cmd_act = HostCmd_ACT_GEN_SET;
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_HAL_PHY_CFG, cmd_act, 0,
+			       (t_void *)pioctl_req,
+			       &hal_phy_cfg->param.hal_phy_cfg_params);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Enable/disable CSI support
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success,
+ * otherwise fail
+ */
+mlan_status wlan_misc_csi(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *csi_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	t_u16 cmd_act;
+
+	ENTER();
+
+	if (csi_cfg->param.csi_params.csi_enable == 1) {
+		if (pmadapter->csi_enabled) {
+			PRINTM(MERROR,
+			       "Enable CSI: CSI was already enabled.\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		cmd_act = CSI_CMD_ENABLE;
+	} else {
+		if (!pmadapter->csi_enabled) {
+			PRINTM(MERROR,
+			       "Disable CSI: CSI was already disabled.\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		cmd_act = CSI_CMD_DISABLE;
+	}
+
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_CSI, cmd_act, 0,
+			       (t_void *)pioctl_req,
+			       &csi_cfg->param.csi_params);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+done:
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief This function allocates a mlan_buffer.
  *
@@ -934,6 +1019,7 @@ pmlan_buffer wlan_alloc_mlan_buffer(mlan_adapter *pmadapter, t_u32 data_len,
 	t_u32 buf_size = 0;
 	t_u8 *tmp_buf = MNULL;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
+	t_u32 mem_flags = MLAN_MEM_DEF | MLAN_MEM_DMA;
 
 	ENTER();
 
@@ -945,18 +1031,17 @@ pmlan_buffer wlan_alloc_mlan_buffer(mlan_adapter *pmadapter, t_u32 data_len,
 #endif
 
 	/* head_room is not implemented for malloc mlan buffer */
-
-	switch (malloc_flag) {
-	case MOAL_MALLOC_BUFFER:
-		buf_size = sizeof(mlan_buffer) + data_len + DMA_ALIGNMENT;
+	if (malloc_flag & MOAL_MALLOC_BUFFER) {
+		buf_size =
+			(t_u32)(sizeof(mlan_buffer) + data_len + DMA_ALIGNMENT);
+		if (malloc_flag & MOAL_MEM_FLAG_ATOMIC)
+			mem_flags |= MLAN_MEM_FLAG_ATOMIC;
 		ret = pcb->moal_malloc(pmadapter->pmoal_handle, buf_size,
-				       MLAN_MEM_DEF | MLAN_MEM_DMA,
-				       (t_u8 **)&pmbuf);
+				       mem_flags, (t_u8 **)&pmbuf);
 		if ((ret != MLAN_STATUS_SUCCESS) || !pmbuf) {
 			pmbuf = MNULL;
 			goto exit;
 		}
-		memset(pmadapter, pmbuf, 0, sizeof(mlan_buffer));
 
 		pmbuf->pdesc = MNULL;
 		/* Align address */
@@ -965,9 +1050,7 @@ pmlan_buffer wlan_alloc_mlan_buffer(mlan_adapter *pmadapter, t_u32 data_len,
 		pmbuf->data_offset = 0;
 		pmbuf->data_len = data_len;
 		pmbuf->flags |= MLAN_BUF_FLAG_MALLOC_BUF;
-		break;
-
-	case MOAL_ALLOC_MLAN_BUFFER:
+	} else if (malloc_flag & MOAL_ALLOC_MLAN_BUFFER) {
 		/* use moal_alloc_mlan_buffer, head_room supported */
 		ret = pcb->moal_alloc_mlan_buffer(
 			pmadapter->pmoal_handle,
@@ -983,7 +1066,6 @@ pmlan_buffer wlan_alloc_mlan_buffer(mlan_adapter *pmadapter, t_u32 data_len,
 			(t_u32)(tmp_buf - (pmbuf->pbuf + pmbuf->data_offset));
 		pmbuf->data_len = data_len;
 		pmbuf->flags = 0;
-		break;
 	}
 
 exit:
@@ -1055,7 +1137,9 @@ t_void wlan_delay_func(mlan_adapter *pmadapter, t_u32 delay, t_delay_unit u)
 			break;
 		case MSEC:
 			delay *= 1000;
-			/* fall through */
+			upto_tv_sec += (delay / 1000000);
+			upto_tv_usec += (delay % 1000000);
+			break;
 		case USEC:
 			upto_tv_sec += (delay / 1000000);
 			upto_tv_usec += (delay % 1000000);
@@ -1160,6 +1244,10 @@ mlan_status wlan_bss_ioctl_bss_role(pmlan_adapter pmadapter,
 			pmpriv->bss_type = MLAN_BSS_TYPE_UAP;
 		/* Initialize private structures */
 		wlan_init_priv(pmpriv);
+		/* restore mac address */
+		memcpy_ext(pmpriv->adapter, pmpriv->curr_addr,
+			   pmpriv->adapter->permanent_addr,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 		mlan_block_rx_process(pmadapter, MFALSE);
 		/* Initialize function table */
 		for (j = 0; mlan_ops[j]; j++) {
@@ -1553,24 +1641,15 @@ mlan_status wlan_reg_mem_ioctl_reg_rw(pmlan_adapter pmadapter,
 
 	switch (reg_mem->param.reg_rw.type) {
 	case MLAN_REG_MAC:
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	case MLAN_REG_MAC2:
-#endif
 		cmd_no = HostCmd_CMD_MAC_REG_ACCESS;
 		break;
 	case MLAN_REG_BBP:
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	case MLAN_REG_BBP2:
-#endif
 		cmd_no = HostCmd_CMD_BBP_REG_ACCESS;
 		break;
 	case MLAN_REG_RF:
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	case MLAN_REG_RF2:
-#endif
 		cmd_no = HostCmd_CMD_RF_REG_ACCESS;
 		break;
 	case MLAN_REG_CAU:
@@ -1580,12 +1659,12 @@ mlan_status wlan_reg_mem_ioctl_reg_rw(pmlan_adapter pmadapter,
 		cmd_no = HostCmd_CMD_TARGET_ACCESS;
 		break;
 	case MLAN_REG_BCA:
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
 	case MLAN_REG_BCA2:
-#endif
 		cmd_no = HostCmd_CMD_BCA_REG_ACCESS;
 		break;
+	case MLAN_REG_CIU:
+		cmd_no = HostCmd_CMD_REG_ACCESS;
+		break;
 	default:
 		pioctl_req->status_code = MLAN_ERROR_IOCTL_INVALID;
 		ret = MLAN_STATUS_FAILURE;
@@ -1714,10 +1793,8 @@ sta_node *wlan_get_station_entry(mlan_private *priv, t_u8 *mac)
 		LEAVE();
 		return MNULL;
 	}
-	sta_ptr = (sta_node *)util_peek_list(
-		priv->adapter->pmoal_handle, &priv->sta_list,
-		priv->adapter->callbacks.moal_spin_lock,
-		priv->adapter->callbacks.moal_spin_unlock);
+	sta_ptr = (sta_node *)util_peek_list(priv->adapter->pmoal_handle,
+					     &priv->sta_list, MNULL, MNULL);
 
 	while (sta_ptr && (sta_ptr != (sta_node *)&priv->sta_list)) {
 		if (!memcmp(priv->adapter, sta_ptr->mac_addr, mac,
@@ -1743,11 +1820,8 @@ sta_node *wlan_get_station_entry(mlan_private *priv, t_u8 *mac)
 sta_node *wlan_add_station_entry(mlan_private *priv, t_u8 *mac)
 {
 	sta_node *sta_ptr = MNULL;
-	mlan_adapter *pmadapter = priv->adapter;
 
 	ENTER();
-	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
-					    priv->wmm.ra_list_spinlock);
 
 	sta_ptr = wlan_get_station_entry(priv, mac);
 	if (sta_ptr)
@@ -1756,12 +1830,9 @@ sta_node *wlan_add_station_entry(mlan_private *priv, t_u8 *mac)
 						 sizeof(sta_node), MLAN_MEM_DEF,
 						 (t_u8 **)&sta_ptr)) {
 		PRINTM(MERROR, "Failed to allocate memory for station node\n");
-		pmadapter->callbacks.moal_spin_unlock(
-			pmadapter->pmoal_handle, priv->wmm.ra_list_spinlock);
 		LEAVE();
 		return MNULL;
 	}
-	memset(priv->adapter, sta_ptr, 0, sizeof(sta_node));
 	memcpy_ext(priv->adapter, sta_ptr->mac_addr, mac, MLAN_MAC_ADDR_LENGTH,
 		   MLAN_MAC_ADDR_LENGTH);
 	util_enqueue_list_tail(priv->adapter->pmoal_handle, &priv->sta_list,
@@ -1775,8 +1846,6 @@ sta_node *wlan_add_station_entry(mlan_private *priv, t_u8 *mac)
 					  &sta_ptr->cm_connectioninfo, mac);
 #endif
 done:
-	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
-					      priv->wmm.ra_list_spinlock);
 	LEAVE();
 	return sta_ptr;
 }
@@ -1793,10 +1862,7 @@ sta_node *wlan_add_station_entry(mlan_private *priv, t_u8 *mac)
 t_void wlan_delete_station_entry(mlan_private *priv, t_u8 *mac)
 {
 	sta_node *sta_ptr = MNULL;
-	mlan_adapter *pmadapter = priv->adapter;
 	ENTER();
-	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
-					    priv->wmm.ra_list_spinlock);
 	sta_ptr = wlan_get_station_entry(priv, mac);
 	if (sta_ptr) {
 #ifdef DRV_EMBEDDED_AUTHENTICATOR
@@ -1812,8 +1878,7 @@ t_void wlan_delete_station_entry(mlan_private *priv, t_u8 *mac)
 		priv->adapter->callbacks.moal_mfree(priv->adapter->pmoal_handle,
 						    (t_u8 *)sta_ptr);
 	}
-	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
-					      priv->wmm.ra_list_spinlock);
+
 	LEAVE();
 	return;
 }
@@ -1848,460 +1913,1188 @@ t_void wlan_delete_station_list(pmlan_private priv)
 }
 
 /**
- *  @brief Set mimo switch configuration
+ *  @brief Get tdls peer list
  *
- *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   A pointer to ioctl request buffer
- *
- *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ *  @param priv         A pointer to mlan_private structure
+ *  @param buf          A pointer to tdls_peer_info buf
+ *  @return             number of tdls peer
  */
-mlan_status wlan_radio_ioctl_mimo_switch_cfg(pmlan_adapter pmadapter,
-					     pmlan_ioctl_req pioctl_req)
+int wlan_get_tdls_list(mlan_private *priv, tdls_peer_info *buf)
 {
-	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_radio_cfg *radio_cfg = (mlan_ds_radio_cfg *)pioctl_req->pbuf;
-	mlan_status ret = MLAN_STATUS_SUCCESS;
+	tdls_peer_info *peer_info = buf;
+	sta_node *sta_ptr = MNULL;
+	int count = 0;
 
 	ENTER();
-
-	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_MIMO_SWITCH, 0, 0,
-			       (t_void *)pioctl_req,
-			       &(radio_cfg->param.mimo_switch_cfg));
-
-	if (ret == MLAN_STATUS_SUCCESS)
-		ret = MLAN_STATUS_PENDING;
-
+	if (priv->bss_type != MLAN_BSS_TYPE_STA) {
+		LEAVE();
+		return count;
+	}
+	sta_ptr = (sta_node *)util_peek_list(
+		priv->adapter->pmoal_handle, &priv->sta_list,
+		priv->adapter->callbacks.moal_spin_lock,
+		priv->adapter->callbacks.moal_spin_unlock);
+	if (!sta_ptr) {
+		LEAVE();
+		return count;
+	}
+	while (sta_ptr != (sta_node *)&priv->sta_list) {
+		if (sta_ptr->status == TDLS_SETUP_COMPLETE) {
+			peer_info->snr = sta_ptr->snr;
+			peer_info->nf = sta_ptr->nf;
+			memcpy_ext(priv->adapter, peer_info->mac_addr,
+				   sta_ptr->mac_addr, MLAN_MAC_ADDR_LENGTH,
+				   MLAN_MAC_ADDR_LENGTH);
+			memcpy_ext(priv->adapter, peer_info->ht_cap,
+				   &sta_ptr->HTcap, sizeof(IEEEtypes_HTCap_t),
+				   sizeof(peer_info->ht_cap));
+			memcpy_ext(priv->adapter, peer_info->ext_cap,
+				   &sta_ptr->ExtCap, sizeof(IEEEtypes_ExtCap_t),
+				   sizeof(peer_info->ext_cap));
+			memcpy_ext(priv->adapter, peer_info->vht_cap,
+				   &sta_ptr->vht_cap,
+				   sizeof(IEEEtypes_VHTCap_t),
+				   sizeof(peer_info->vht_cap));
+			memcpy_ext(priv->adapter, peer_info->he_cap,
+				   &sta_ptr->he_cap, sizeof(IEEEtypes_HECap_t),
+				   sizeof(peer_info->he_cap));
+			peer_info++;
+			count++;
+		}
+		sta_ptr = sta_ptr->pnext;
+		if (count >= MLAN_MAX_TDLS_PEER_SUPPORTED)
+			break;
+	}
 	LEAVE();
-	return ret;
+	return count;
 }
 
 /**
- *  @brief Get extended version information
+ *  @brief Set the TDLS configuration to FW.
  *
- *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   A pointer to ioctl request buffer
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
  *
- *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_get_info_ver_ext(pmlan_adapter pmadapter,
-				  pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_ioctl_tdls_config(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req)
 {
-	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_get_info *pinfo = (mlan_ds_get_info *)pioctl_req->pbuf;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	tdls_all_config *tdls_all_cfg =
+		(tdls_all_config *)misc->param.tdls_config.tdls_data;
+	t_u8 event_buf[100];
+	mlan_event *pevent = (mlan_event *)event_buf;
+	tdls_tear_down_event *tdls_evt =
+		(tdls_tear_down_event *)pevent->event_buf;
+	sta_node *sta_ptr = MNULL;
+	MrvlIEtypes_Data_t *pMrvlTlv = MNULL;
+	t_u8 *pos = MNULL;
+	t_u16 remain_len = 0;
 
 	ENTER();
 
-	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_VERSION_EXT,
-			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
-			       &pinfo->param.ver_ext.version_str_sel);
+	if (misc->param.tdls_config.tdls_action == WLAN_TDLS_TEAR_DOWN_REQ) {
+		sta_ptr = wlan_get_station_entry(
+			pmpriv, tdls_all_cfg->u.tdls_tear_down.peer_mac_addr);
+		if (sta_ptr && sta_ptr->external_tdls) {
+			pevent->bss_index = pmpriv->bss_index;
+			pevent->event_id = MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ;
+			pevent->event_len = sizeof(tdls_tear_down_event);
+			memcpy_ext(pmpriv->adapter,
+				   (t_u8 *)tdls_evt->peer_mac_addr,
+				   tdls_all_cfg->u.tdls_tear_down.peer_mac_addr,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+			tdls_evt->reason_code =
+				tdls_all_cfg->u.tdls_tear_down.reason_code;
+			wlan_recv_event(pmpriv,
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ,
+					pevent);
+			LEAVE();
+			return ret;
+		}
+	}
+	if (misc->param.tdls_config.tdls_action == WLAN_HOST_TDLS_CONFIG) {
+		pmpriv->host_tdls_uapsd_support =
+			tdls_all_cfg->u.host_tdls_cfg.uapsd_support;
+		pmpriv->host_tdls_cs_support =
+			tdls_all_cfg->u.host_tdls_cfg.cs_support;
+		pos = tdls_all_cfg->u.host_tdls_cfg.tlv_buffer;
+		remain_len = tdls_all_cfg->u.host_tdls_cfg.tlv_len;
+		while (remain_len > sizeof(MrvlIEtypesHeader_t)) {
+			remain_len -= sizeof(MrvlIEtypesHeader_t);
+			pMrvlTlv = (MrvlIEtypes_Data_t *)pos;
+			switch (pMrvlTlv->header.type) {
+			case SUPPORTED_CHANNELS:
+				pmpriv->chan_supp_len = (t_u8)MIN(
+					pMrvlTlv->header.len, MAX_IE_SIZE);
+				memset(pmadapter, pmpriv->chan_supp, 0,
+				       sizeof(pmpriv->chan_supp));
+				memcpy_ext(pmadapter, pmpriv->chan_supp,
+					   pMrvlTlv->data, pMrvlTlv->header.len,
+					   MAX_IE_SIZE);
+				DBG_HEXDUMP(MCMD_D, "TDLS supported channel",
+					    pmpriv->chan_supp,
+					    pmpriv->chan_supp_len);
+				break;
+			case REGULATORY_CLASS:
+				pmpriv->supp_regulatory_class_len = (t_u8)MIN(
+					pMrvlTlv->header.len, MAX_IE_SIZE);
+				memset(pmadapter, pmpriv->supp_regulatory_class,
+				       0,
+				       sizeof(pmpriv->supp_regulatory_class));
+				memcpy_ext(pmadapter,
+					   pmpriv->supp_regulatory_class,
+					   pMrvlTlv->data, pMrvlTlv->header.len,
+					   MAX_IE_SIZE);
+				DBG_HEXDUMP(MCMD_D,
+					    "TDLS supported regulatory class",
+					    pmpriv->supp_regulatory_class,
+					    pmpriv->supp_regulatory_class_len);
+				break;
+			default:
+				break;
+			}
+			remain_len -= pMrvlTlv->header.len;
+			pos += sizeof(MrvlIEtypesHeader_t) +
+			       pMrvlTlv->header.len;
+		}
+		LEAVE();
+		return ret;
+	}
+	pioctl_req->action = MLAN_ACT_SET;
+
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_CONFIG,
+			       HostCmd_ACT_GEN_SET, 0, (t_void *)pioctl_req,
+			       &misc->param.tdls_config);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
-
 	LEAVE();
 	return ret;
 }
 
 /**
- *  @brief This function convert mlan_wifi_rate to wifi_rate.
+ *  @brief enable tdls config for cs and uapsd.
  *
- *  @param pmpriv       A pointer to mlan_private structure
- *  @param rateStats   wifi_rate_stat array
- *  @param pnum_rate   A pointer to num_rate
+ *  @param pmpriv	A pointer to mlan_private structure
+ *  @param enable   	MTRUE/MFALSE
  *
- *  @return           N/A
+ *  @return
  */
-t_void wlan_fill_hal_wifi_rate_in_host(pmlan_private pmpriv,
-				       OUT wifi_rate_stat rateStats[],
-				       t_u32 *pnumRate)
+t_void wlan_tdls_config(pmlan_private pmpriv, t_u8 enable)
 {
-	t_u32 total_num_rate = 0;
-	t_u32 mcs_idx = 0;
-	t_u8 index = 0;
-	t_u8 rate_info = 0;
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_callbacks *pcb = (mlan_callbacks *)&pmadapter->callbacks;
+	mlan_ds_misc_tdls_config *tdls_config = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	/* HT MCS */
-	for (mcs_idx = 0; mcs_idx < MCS_NUM_SUPP; mcs_idx++) {
-		/* 0: OFDM, 1:CCK, 2:HT 3:VHT 4..7 reserved */
-		rateStats[total_num_rate].rate.preamble = 2;
-		/* 0:20MHz, 1:40Mhz, 2:80Mhz, 3:160Mhz */
-		rateStats[total_num_rate].rate.bw = 0;
-		rateStats[total_num_rate].rate.rateMcsIdx = mcs_idx;
-		index = rateStats[total_num_rate].rate.rateMcsIdx;
-		rate_info = MLAN_RATE_FORMAT_HT |
-			    (rateStats[total_num_rate].rate.bw << 2);
-		rateStats[total_num_rate].rate.bitrate =
-			wlan_index_to_data_rate(pmpriv->adapter, index,
-						rate_info, 0) *
-			5;
-		PRINTM(MINFO, "HT[%d] index=0x%x rate_info=0x%x bitrate=0x%x\n",
-		       total_num_rate, index, rate_info,
-		       rateStats[total_num_rate].rate.bitrate / 5);
-
-		/* Get Tx mpdu */
-		rateStats[total_num_rate].tx_mpdu = 0;
-		rateStats[total_num_rate].rx_mpdu = 0;
-
-		/* Todo: mpdu_lost/retries*, need extend GetTxRxRateInfo */
-		rateStats[total_num_rate].mpdu_lost = 0xC1;
-		rateStats[total_num_rate].retries = 0xC2;
-		rateStats[total_num_rate].retries_short = 0xC3;
-		rateStats[total_num_rate].retries_long = 0xC4;
-
-		total_num_rate++;
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+			       sizeof(mlan_ds_misc_tdls_config), MLAN_MEM_DEF,
+			       (t_u8 **)&tdls_config);
+	if (ret != MLAN_STATUS_SUCCESS || !tdls_config) {
+		PRINTM(MERROR, "Memory allocation for tdls_config failed!\n");
+		LEAVE();
+		return;
 	}
+	tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+	tdls_all_cfg->u.tdls_config.enable = enable;
+	tdls_config->tdls_action = WLAN_TDLS_CONFIG;
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_CONFIG,
+			       HostCmd_ACT_GEN_SET, 0, MNULL, tdls_config);
+	if (ret)
+		PRINTM(MERROR, "Error sending cmd to FW\n");
 
-	/* VHT MCS */
-	for (mcs_idx = 0; mcs_idx < VHT_NUM_SUPPORT_MCS; mcs_idx++) {
-		/* 0: OFDM, 1:CCK, 2:HT 3:VHT 4..7 reserved */
-		rateStats[total_num_rate].rate.preamble = 3;
-		/* 0:1x1, 1:2x2, 3:3x3, 4:4x4 */
-		rateStats[total_num_rate].rate.nss = 0;
-		/* 0:20MHz, 1:40Mhz, 2:80Mhz, 3:160Mhz */
-		rateStats[total_num_rate].rate.bw = 0;
-		rateStats[total_num_rate].rate.rateMcsIdx = mcs_idx;
-		/* nss 2 ? bw 20MHZ ? */
-		index = rateStats[total_num_rate].rate.rateMcsIdx |
-			(rateStats[total_num_rate].rate.nss << 4);
-		rate_info = MLAN_RATE_FORMAT_VHT |
-			    (rateStats[total_num_rate].rate.bw << 2);
-		rateStats[total_num_rate].rate.bitrate =
-			wlan_index_to_data_rate(pmpriv->adapter, index,
-						rate_info, 0) *
-			5;
-		PRINTM(MINFO,
-		       "VHT[%d] index=0x%x rate_info=0x%x bitrate=0x%x\n",
-		       total_num_rate, index, rate_info,
-		       rateStats[total_num_rate].rate.bitrate / 5);
-
-		rateStats[total_num_rate].tx_mpdu = 0;
-		rateStats[total_num_rate].rx_mpdu = 0;
-
-		/* Todo: mpdu_lost/retries*, need extend GetTxRxRateInfo */
-		rateStats[total_num_rate].mpdu_lost = 0xC1;
-		rateStats[total_num_rate].retries = 0xC2;
-		rateStats[total_num_rate].retries_short = 0xC3;
-		rateStats[total_num_rate].retries_long = 0xC4;
-
-		total_num_rate++;
-	}
+	PRINTM(MCMND, "tdls_config: enable=%d\n", enable);
 
-	*pnumRate = total_num_rate;
+	if (tdls_config)
+		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)tdls_config);
 
 	LEAVE();
 }
 
 /**
- *  @brief This function fill link layer statistic from firmware
+ *  @brief set tdls channel switch parameters.
  *
- *  @param priv       					A pointer to
- * mlan_private structure
- *  @param link_statistic_ioctl_buf,    A pointer to fill ioctl buffer
+ *  @param pmpriv	A pointer to mlan_private structure
  *
- *  @return             MLAN_STATUS_SUCCESS
+ *  @return
  */
-static void wlan_fill_link_statistic_in_host(mlan_private *priv,
-					     char *link_statistic_ioctl_buf)
+static t_void wlan_tdls_cs_param_config(pmlan_private pmpriv)
 {
-	char *link_statistic = link_statistic_ioctl_buf;
-	wifi_radio_stat *radio_stat = MNULL;
-	wifi_iface_stat *iface_stat = MNULL;
-	t_u32 num_radio = MAX_RADIO;
-	int i = 0, chan_idx = 0;
-	t_u32 num_peers = 0;
-	sta_node *sta_ptr = MNULL;
-#ifdef WMM
-	t_u8 *ptid = MNULL;
-#endif
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_callbacks *pcb = (mlan_callbacks *)&pmadapter->callbacks;
+	mlan_ds_misc_tdls_config *tdls_config = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	*((t_u32 *)link_statistic) = num_radio;
-	link_statistic += sizeof(num_radio);
-
-	/* Fill radio stats array */
-	for (i = 0; i < num_radio; i++) {
-		radio_stat = (wifi_radio_stat *)link_statistic;
-		link_statistic += sizeof(wifi_radio_stat);
-
-		radio_stat->radio = 0xF0;
-
-		radio_stat->on_time = 0;
-		radio_stat->tx_time = 0;
-		radio_stat->reserved0 = 0;
-		radio_stat->rx_time = 0;
-		radio_stat->on_time_scan = 0;
-		radio_stat->on_time_nbd = 0;
-		radio_stat->on_time_gscan = 0;
-		radio_stat->on_time_roam_scan = 0;
-		radio_stat->on_time_pno_scan = 0;
-		radio_stat->on_time_hs20 = 0;
-
-		radio_stat->num_channels = 1;
-		for (chan_idx = 0; chan_idx < radio_stat->num_channels;
-		     chan_idx++) {
-			if (radio_stat->num_channels > MAX_NUM_CHAN) {
-				radio_stat->num_channels = MAX_NUM_CHAN;
-				PRINTM(MERROR,
-				       "%s : radio_stat->num_channels=%d\n",
-				       __func__, radio_stat->num_channels);
-				break;
-			}
-
-			if (priv->bss_role == MLAN_BSS_ROLE_STA) {
-				if (priv->media_connected) {
-					radio_stat->channels[chan_idx]
-						.channel.width =
-						priv->curr_bss_params
-							.bss_descriptor
-							.curr_bandwidth;
-					radio_stat->channels[chan_idx]
-						.channel.center_freq =
-						priv->curr_bss_params
-							.bss_descriptor.freq;
-					radio_stat->channels[chan_idx]
-						.channel.center_freq0 = 0;
-					radio_stat->channels[chan_idx]
-						.channel.center_freq1 = 0;
-				}
-			} else {
-				radio_stat->channels[chan_idx].channel.width =
-					priv->uap_state_chan_cb.bandcfg
-						.chanWidth;
-				radio_stat->channels[chan_idx]
-					.channel
-					.center_freq = wlan_11d_chan_2_freq(
-					priv->adapter,
-					priv->uap_state_chan_cb.channel,
-					(priv->uap_state_chan_cb.channel > 14) ?
-						BAND_A :
-						BAND_G);
-				radio_stat->channels[chan_idx]
-					.channel.center_freq0 = 0;
-				radio_stat->channels[chan_idx]
-					.channel.center_freq1 = 0;
-			}
-			radio_stat->channels[chan_idx].on_time = 0xE3;
-			radio_stat->channels[chan_idx].cca_busy_time = 0xE4;
-		}
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+			       sizeof(mlan_ds_misc_tdls_config), MLAN_MEM_DEF,
+			       (t_u8 **)&tdls_config);
+	if (ret != MLAN_STATUS_SUCCESS || !tdls_config) {
+		PRINTM(MERROR, "Memory allocation for tdls_config failed!\n");
+		LEAVE();
+		return;
 	}
 
-	/* Fill iface stats*/
-	iface_stat = (wifi_iface_stat *)link_statistic;
+	tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+	tdls_config->tdls_action = WLAN_TDLS_CS_PARAMS;
+	tdls_all_cfg->u.tdls_cs_params.unit_time = 2;
+	tdls_all_cfg->u.tdls_cs_params.threshold_otherlink = 10;
+	tdls_all_cfg->u.tdls_cs_params.threshold_directlink = 0;
 
-	/* get wifi_interface_link_layer_info in driver, not in firmware */
-	if (priv->bss_role == MLAN_BSS_ROLE_STA) {
-		iface_stat->info.mode = MLAN_INTERFACE_STA;
-		if (priv->media_connected)
-			iface_stat->info.state = MLAN_ASSOCIATING;
-		else
-			iface_stat->info.state = MLAN_DISCONNECTED;
-		iface_stat->info.roaming = MLAN_ROAMING_IDLE;
-		iface_stat->info.capabilities = MLAN_CAPABILITY_QOS;
-		memcpy_ext(priv->adapter, iface_stat->info.ssid,
-			   priv->curr_bss_params.bss_descriptor.ssid.ssid,
-			   MLAN_MAX_SSID_LENGTH, MLAN_MAX_SSID_LENGTH);
-		memcpy_ext(priv->adapter, iface_stat->info.bssid,
-			   priv->curr_bss_params.bss_descriptor.mac_address,
-			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-	} else {
-		iface_stat->info.mode = MLAN_INTERFACE_SOFTAP;
-		iface_stat->info.capabilities = MLAN_CAPABILITY_QOS;
-	}
-	memcpy_ext(priv->adapter, iface_stat->info.mac_addr, priv->curr_addr,
-		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-	memcpy_ext(priv->adapter, iface_stat->info.ap_country_str,
-		   priv->adapter->country_code, COUNTRY_CODE_LEN,
-		   COUNTRY_CODE_LEN);
-	memcpy_ext(priv->adapter, iface_stat->info.country_str,
-		   priv->adapter->country_code, COUNTRY_CODE_LEN,
-		   COUNTRY_CODE_LEN);
-
-	iface_stat->beacon_rx = 0;
-	iface_stat->average_tsf_offset = 0;
-	iface_stat->leaky_ap_detected = 0;
-	iface_stat->leaky_ap_avg_num_frames_leaked = 0;
-	iface_stat->leaky_ap_guard_time = 0;
-
-	/* Value of iface_stat should be Reaccumulate by each peer */
-	iface_stat->mgmt_rx = 0;
-	iface_stat->mgmt_action_rx = 0;
-	iface_stat->mgmt_action_tx = 0;
-
-	iface_stat->rssi_mgmt = 0;
-	iface_stat->rssi_data = 0;
-	iface_stat->rssi_ack = 0;
-
-#ifdef WMM
-	for (i = WMM_AC_BK; i <= WMM_AC_VO; i++) {
-		iface_stat->ac[i].ac = i;
-		ptid = ac_to_tid[i];
-		iface_stat->ac[i].tx_mpdu = priv->wmm.packets_out[ptid[0]] +
-					    priv->wmm.packets_out[ptid[1]];
-		iface_stat->ac[i].rx_mpdu = 0;
-		iface_stat->ac[i].tx_mcast = 0;
-		iface_stat->ac[i].rx_mcast = 0;
-		iface_stat->ac[i].rx_ampdu = 0;
-		iface_stat->ac[i].tx_ampdu = 0;
-		iface_stat->ac[i].mpdu_lost = 0;
-		iface_stat->ac[i].retries = 0;
-		iface_stat->ac[i].retries_short = 0;
-		iface_stat->ac[i].retries_long = 0;
-		iface_stat->ac[i].contention_time_min = 0;
-		iface_stat->ac[i].contention_time_max = 0;
-		iface_stat->ac[i].contention_time_avg = 0;
-		iface_stat->ac[i].contention_num_samples = 0;
-	}
-#endif
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_CONFIG,
+			       HostCmd_ACT_GEN_SET, 0, MNULL, tdls_config);
+	if (ret)
+		PRINTM(MERROR, "Error sending cmd to FW\n");
 
-	if (priv->bss_role == MLAN_BSS_ROLE_STA) {
-		if (priv->media_connected) {
-			iface_stat->peer_info[0].type = WIFI_PEER_AP;
-			memcpy_ext(
-				priv->adapter,
-				iface_stat->peer_info[0].peer_mac_address,
-				priv->curr_bss_params.bss_descriptor.mac_address,
-				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-			iface_stat->peer_info[0].capabilities =
-				MLAN_CAPABILITY_QOS;
-			wlan_fill_hal_wifi_rate_in_host(
-				priv, iface_stat->peer_info[0].rate_stats,
-				&(iface_stat->peer_info[0].num_rate));
-			num_peers = 1;
-		}
-	} else {
-		sta_ptr = (sta_node *)util_peek_list(
-			priv->adapter->pmoal_handle, &priv->sta_list,
-			priv->adapter->callbacks.moal_spin_lock,
-			priv->adapter->callbacks.moal_spin_unlock);
-		if (sta_ptr) {
-			while (sta_ptr != (sta_node *)&priv->sta_list) {
-				iface_stat->peer_info[num_peers].type =
-					WIFI_PEER_STA;
-				memcpy_ext(priv->adapter,
-					   iface_stat->peer_info[num_peers]
-						   .peer_mac_address,
-					   sta_ptr->mac_addr,
-					   MLAN_MAC_ADDR_LENGTH,
-					   MLAN_MAC_ADDR_LENGTH);
-				iface_stat->peer_info[num_peers].capabilities =
-					MLAN_CAPABILITY_QOS;
-				wlan_fill_hal_wifi_rate_in_host(
-					priv,
-					iface_stat->peer_info[num_peers]
-						.rate_stats,
-					&(iface_stat->peer_info[num_peers]
-						  .num_rate));
-				num_peers++;
-
-				sta_ptr = sta_ptr->pnext;
-			}
-		}
-	}
-	iface_stat->num_peers = num_peers;
+	if (tdls_config)
+		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)tdls_config);
 
 	LEAVE();
 }
 
 /**
- *  @brief Set/Get link layer statistics
+ *  @brief start tdls channel switch
  *
- *  @param pmadapter	A pointer to mlan_adapter structure
- *  @param pioctl_req	A pointer to ioctl request buffer
+ *  @param pmpriv	A pointer to mlan_private structure
+ *  @param peer_mac_addr 	A pointer to peer mac address
+ *  @param pioctl_buf   A pointer to ioctl request buffer
  *
- *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ *  @return
  */
-mlan_status wlan_ioctl_link_statistic(mlan_private *pmpriv,
-				      pmlan_ioctl_req pioctl_req)
+static t_void wlan_tdls_cs_start(pmlan_private pmpriv, t_u8 *peer_mac_addr,
+				 pmlan_ioctl_req pioctl_buf)
 {
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_callbacks *pcb = (mlan_callbacks *)&pmadapter->callbacks;
+	mlan_ds_misc_tdls_config *tdls_config = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	mlan_ds_misc_cfg *misc = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_ds_get_info *info = MNULL;
-	t_u8 *link_statistic = MNULL;
 
 	ENTER();
 
-	/* Check buffer length of MLAN IOCTL */
-	if (pioctl_req->buf_len < sizeof(mlan_ds_get_stats)) {
-		PRINTM(MWARN,
-		       "MLAN IOCTL information buffer length is too short.\n");
-		pioctl_req->data_read_written = 0;
-		pioctl_req->buf_len_needed = sizeof(mlan_ds_get_stats);
-		pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
-		ret = MLAN_STATUS_RESOURCE;
-		goto exit;
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+			       sizeof(mlan_ds_misc_tdls_config), MLAN_MEM_DEF,
+			       (t_u8 **)&tdls_config);
+	if (ret != MLAN_STATUS_SUCCESS || !tdls_config) {
+		PRINTM(MERROR, "Memory allocation for tdls_config failed!\n");
+		LEAVE();
+		return;
 	}
 
-	/** We will not send HostCmd_CMD_802_11_LINK_STATS to FW */
-	if (pioctl_req->action == MLAN_ACT_GET) {
-		info = (mlan_ds_get_info *)pioctl_req->pbuf;
-		link_statistic = info->param.link_statistic;
-		/** Get the LL STATS from driver */
-		wlan_fill_link_statistic_in_host(pmpriv, link_statistic);
-		DBG_HEXDUMP(
-			MCMD_D,
-			"wlan_ioctl_link_statistic() link_statistic in host",
-			(t_u8 *)link_statistic, 800);
+	if (pioctl_buf) {
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		memcpy_ext(pmpriv->adapter, tdls_config,
+			   &misc->param.tdls_config,
+			   sizeof(mlan_ds_misc_tdls_config),
+			   sizeof(mlan_ds_misc_tdls_config));
+		tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+		if (tdls_all_cfg->u.tdls_chan_switch.primary_channel > 14) {
+			tdls_all_cfg->u.tdls_chan_switch
+				.secondary_channel_offset =
+				wlan_get_second_channel_offset(
+					pmpriv, tdls_all_cfg->u.tdls_chan_switch
+							.primary_channel);
+		}
+		PRINTM(MCMND, "Start TDLS CS: channel=%d\n",
+		       tdls_all_cfg->u.tdls_chan_switch.primary_channel);
+	} else {
+		tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+		tdls_config->tdls_action = WLAN_TDLS_INIT_CHAN_SWITCH;
+		memcpy_ext(pmpriv->adapter,
+			   tdls_all_cfg->u.tdls_chan_switch.peer_mac_addr,
+			   peer_mac_addr, MLAN_MAC_ADDR_LENGTH,
+			   MLAN_MAC_ADDR_LENGTH);
+		tdls_all_cfg->u.tdls_chan_switch.primary_channel =
+			pmpriv->tdls_cs_channel;
+		if (pmpriv->tdls_cs_channel > 14) {
+			tdls_all_cfg->u.tdls_chan_switch.band = BAND_5GHZ;
+			tdls_all_cfg->u.tdls_chan_switch
+				.secondary_channel_offset =
+				wlan_get_second_channel_offset(
+					pmpriv, pmpriv->tdls_cs_channel);
+		} else {
+			tdls_all_cfg->u.tdls_chan_switch.band = BAND_2GHZ;
+		}
+		PRINTM(MCMND, "Start TDLS CS: channel=%d\n",
+		       pmpriv->tdls_cs_channel);
 	}
-	ret = MLAN_STATUS_SUCCESS;
+	tdls_all_cfg->u.tdls_chan_switch.switch_time = 10;
+	tdls_all_cfg->u.tdls_chan_switch.switch_timeout = 16;
+	tdls_all_cfg->u.tdls_chan_switch.regulatory_class = 12;
+	tdls_all_cfg->u.tdls_chan_switch.periodicity = 1;
+
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_CONFIG,
+			       HostCmd_ACT_GEN_SET, 0, MNULL, tdls_config);
+	if (ret)
+		PRINTM(MERROR, "Error sending cmd to FW\n");
+
+	if (tdls_config)
+		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)tdls_config);
 
-exit:
 	LEAVE();
-	return ret;
 }
 
+#if 0
 /**
- *  @brief Get TX/RX histogram statistic
- *
- *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   A pointer to ioctl request buffer
+ *  @brief stop tdls channel switch
  *
- *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ *  @param pmpriv	A pointer to mlan_private structure
+ *  @param peer_mac_addr 	A pointer to peer mac address
+ *  @param pioctl_buf   A pointer to command buffer
+ *  @return
  */
-mlan_status wlan_get_tx_rx_histogram(pmlan_adapter pmadapter,
-				     pmlan_ioctl_req pioctl_req)
+static t_void wlan_tdls_cs_stop(pmlan_private pmpriv, t_u8 *peer_mac_addr)
 {
-	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_misc_cfg *pmisc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	mlan_callbacks *pcb = (mlan_callbacks *)&pmadapter->callbacks;
+	mlan_ds_misc_tdls_config *tdls_config = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_TX_RX_PKT_STATS,
-			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
-			       &(pmisc->param.tx_rx_histogram));
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+			       sizeof(mlan_ds_misc_tdls_config), MLAN_MEM_DEF,
+			       (t_u8 **)&tdls_config);
+	if (ret != MLAN_STATUS_SUCCESS || !tdls_config) {
+		PRINTM(MERROR, "Memory allocation for tdls_config failed!\n");
+		LEAVE();
+		return;
+	}
+	memset(pmadapter, (t_u8 *)tdls_config, 0,
+	       sizeof(mlan_ds_misc_tdls_config));
 
-	if (ret == MLAN_STATUS_SUCCESS)
-		ret = MLAN_STATUS_PENDING;
+	tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+	tdls_config->tdls_action = WLAN_TDLS_STOP_CHAN_SWITCH;
+
+	memcpy_ext(pmpriv->adapter,
+		   tdls_all_cfg->u.tdls_stop_chan_switch.peer_mac_addr,
+		   peer_mac_addr, MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	PRINTM(MCMND, "Stop TDLS CS\n");
+	/* Send command to firmware */
+	wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_CONFIG, HostCmd_ACT_GEN_SET,
+			 0, MNULL, tdls_config);
+
+	if (tdls_config)
+		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)tdls_config);
 
 	LEAVE();
-	return ret;
 }
+#endif
 
-#ifdef DEBUG_LEVEL1
 /**
- *  @brief Set driver debug bit masks in order to enhance performance
+ *  @brief Set/Get the TDLS off channel.
  *
- *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   A pointer to ioctl request buffer
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
  *
- *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_set_drvdbg(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_ioctl_tdls_cs_channel(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
 {
-	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 
 	ENTER();
 
-	/* Set driver debug bit masks */
-	mlan_drvdbg = misc->param.drvdbg;
-
+	if (MLAN_ACT_GET == pioctl_req->action)
+		misc->param.tdls_cs_channel = pmpriv->tdls_cs_channel;
+	else if (MLAN_ACT_SET == pioctl_req->action) {
+		pmpriv->tdls_cs_channel = misc->param.tdls_cs_channel;
+	}
+	LEAVE();
+	return ret;
+}
+/**
+ *  @brief Set/Get the TDLS idle time.
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_tdls_idle_time(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	ENTER();
+
+	if (MLAN_ACT_GET == pioctl_req->action) {
+		misc->param.tdls_idle_time = pmpriv->tdls_idle_time;
+	} else if (MLAN_ACT_SET == pioctl_req->action) {
+		pmpriv->tdls_idle_time = misc->param.tdls_idle_time;
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set the TDLS operation to FW.
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_tdls_oper(pmlan_adapter pmadapter,
+				      pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_ds_misc_tdls_oper *ptdls_oper = &misc->param.tdls_oper;
+	t_u8 event_buf[100];
+	mlan_event *ptdls_event = (mlan_event *)event_buf;
+	tdls_tear_down_event *tdls_evt =
+		(tdls_tear_down_event *)ptdls_event->event_buf;
+	sta_node *sta_ptr = MNULL;
+	t_u8 i = 0;
+
+	ENTER();
+	sta_ptr = wlan_get_station_entry(pmpriv, ptdls_oper->peer_mac);
+	switch (ptdls_oper->tdls_action) {
+	case WLAN_TDLS_ENABLE_LINK:
+		if (sta_ptr && (sta_ptr->status != TDLS_SETUP_FAILURE)) {
+			PRINTM(MMSG, "TDLS: Enable link " MACSTR " success\n",
+			       MAC2STR(ptdls_oper->peer_mac));
+			sta_ptr->status = TDLS_SETUP_COMPLETE;
+			pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+			if (!pmpriv->txaggrctrl)
+				wlan_11n_send_delba_to_peer(
+					pmpriv,
+					pmpriv->curr_bss_params.bss_descriptor
+						.mac_address);
+			if (sta_ptr->HTcap.ieee_hdr.element_id ==
+			    HT_CAPABILITY) {
+				sta_ptr->is_11n_enabled = MTRUE;
+				if (GETHT_MAXAMSDU(
+					    sta_ptr->HTcap.ht_cap.ht_cap_info))
+					sta_ptr->max_amsdu =
+						MLAN_TX_DATA_BUF_SIZE_8K;
+				else
+					sta_ptr->max_amsdu =
+						MLAN_TX_DATA_BUF_SIZE_4K;
+				for (i = 0; i < MAX_NUM_TID; i++) {
+					if (sta_ptr->is_11n_enabled ||
+					    sta_ptr->is_11ax_enabled)
+						sta_ptr->ampdu_sta[i] =
+							pmpriv->aggr_prio_tbl[i]
+								.ampdu_user;
+					else
+						sta_ptr->ampdu_sta[i] =
+							BA_STREAM_NOT_ALLOWED;
+				}
+				memset(pmpriv->adapter, sta_ptr->rx_seq, 0xff,
+				       sizeof(sta_ptr->rx_seq));
+			}
+			wlan_restore_tdls_packets(pmpriv, ptdls_oper->peer_mac,
+						  TDLS_SETUP_COMPLETE);
+			if (ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+				    sta_ptr->ExtCap.ext_cap)) {
+				wlan_tdls_config(pmpriv, MTRUE);
+				wlan_tdls_cs_param_config(pmpriv);
+				/**tdls cs start*/
+				if (pmpriv->tdls_cs_channel &&
+				    pmpriv->tdls_cs_channel !=
+					    pmpriv->curr_bss_params
+						    .bss_descriptor.channel)
+					wlan_tdls_cs_start(pmpriv,
+							   ptdls_oper->peer_mac,
+							   MNULL);
+			}
+		} else {
+			PRINTM(MMSG, "TDLS: Enable link " MACSTR " fail\n",
+			       MAC2STR(ptdls_oper->peer_mac));
+			/*for supplicant 2.0, we need send event to request
+			 *teardown, *for latest supplicant, we only need return
+			 *fail, and supplicant will send teardown packet and
+			 *disable tdls link*/
+			if (sta_ptr) {
+				ptdls_event->bss_index = pmpriv->bss_index;
+				ptdls_event->event_id =
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ;
+				ptdls_event->event_len =
+					sizeof(tdls_tear_down_event);
+				memcpy_ext(pmpriv->adapter,
+					   (t_u8 *)tdls_evt->peer_mac_addr,
+					   ptdls_oper->peer_mac,
+					   MLAN_MAC_ADDR_LENGTH,
+					   MLAN_MAC_ADDR_LENGTH);
+				tdls_evt->reason_code =
+					MLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;
+				wlan_recv_event(
+					pmpriv,
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ,
+					ptdls_event);
+				wlan_restore_tdls_packets(pmpriv,
+							  ptdls_oper->peer_mac,
+							  TDLS_TEAR_DOWN);
+				if (sta_ptr->is_11n_enabled ||
+				    sta_ptr->is_11ax_enabled) {
+					wlan_cleanup_reorder_tbl(
+						pmpriv, ptdls_oper->peer_mac);
+					wlan_11n_cleanup_txbastream_tbl(
+						pmpriv, ptdls_oper->peer_mac);
+				}
+				wlan_delete_station_entry(pmpriv,
+							  ptdls_oper->peer_mac);
+				if (MTRUE == wlan_is_station_list_empty(pmpriv))
+					pmadapter->tdls_status = TDLS_NOT_SETUP;
+				else
+					pmadapter->tdls_status =
+						TDLS_IN_BASE_CHANNEL;
+			}
+			ret = MLAN_STATUS_FAILURE;
+		}
+		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
+				MNULL);
+		break;
+	case WLAN_TDLS_DISABLE_LINK:
+		/* Send command to firmware to delete tdls link*/
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_OPERATION,
+				       HostCmd_ACT_GEN_SET, 0,
+				       (t_void *)pioctl_req, ptdls_oper);
+		if (ret == MLAN_STATUS_SUCCESS)
+			ret = MLAN_STATUS_PENDING;
+		break;
+	case WLAN_TDLS_CREATE_LINK:
+		PRINTM(MIOCTL, "CREATE TDLS LINK\n");
+		if (sta_ptr && sta_ptr->status == TDLS_SETUP_INPROGRESS) {
+			PRINTM(MIOCTL, "We already create the link\n");
+			break;
+		}
+		if (!sta_ptr)
+			sta_ptr = wlan_add_station_entry(
+				pmpriv, misc->param.tdls_oper.peer_mac);
+		if (sta_ptr) {
+			sta_ptr->status = TDLS_SETUP_INPROGRESS;
+			sta_ptr->external_tdls = MTRUE;
+			wlan_hold_tdls_packets(pmpriv,
+					       misc->param.tdls_oper.peer_mac);
+		}
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_OPERATION,
+				       HostCmd_ACT_GEN_SET, 0,
+				       (t_void *)pioctl_req, ptdls_oper);
+		if (ret == MLAN_STATUS_SUCCESS)
+			ret = MLAN_STATUS_PENDING;
+		break;
+	case WLAN_TDLS_CONFIG_LINK:
+		if (!sta_ptr || sta_ptr->status == TDLS_SETUP_FAILURE) {
+			PRINTM(MERROR, "Can not CONFIG TDLS Link\n");
+			ret = MLAN_STATUS_FAILURE;
+			break;
+		}
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TDLS_OPERATION,
+				       HostCmd_ACT_GEN_SET, 0,
+				       (t_void *)pioctl_req, ptdls_oper);
+		if (ret == MLAN_STATUS_SUCCESS)
+			ret = MLAN_STATUS_PENDING;
+		break;
+	case WLAN_TDLS_INIT_CHAN_SWITCH:
+		if (sta_ptr &&
+		    ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(sta_ptr->ExtCap.ext_cap)) {
+			wlan_tdls_config(pmpriv, MTRUE);
+			wlan_tdls_cs_param_config(pmpriv);
+			/**tdls cs start*/
+			wlan_tdls_cs_start(pmpriv, ptdls_oper->peer_mac,
+					   pioctl_req);
+		}
+		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
+				MNULL);
+		break;
+	default:
+		break;
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get AP's ext capability
+ *
+ *  @param pmpriv	A pointer to mlan_adapter structure
+ *  @param ext_cap  A pointer to ExtCap_t structure
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+static void wlan_get_ap_ext_cap(mlan_private *pmpriv, ExtCap_t *ext_cap)
+{
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	BSSDescriptor_t *pbss_desc;
+	pbss_desc = &pmpriv->curr_bss_params.bss_descriptor;
+	memset(pmadapter, ext_cap, 0, sizeof(ExtCap_t));
+	if (pbss_desc->pext_cap) {
+		memcpy_ext(pmadapter, (t_u8 *)ext_cap,
+			   (t_u8 *)pbss_desc->pext_cap +
+				   sizeof(IEEEtypes_Header_t),
+			   pbss_desc->pext_cap->ieee_hdr.len, sizeof(ExtCap_t));
+	}
+	return;
+}
+
+/**
+ *  @brief Set the TDLS operation to FW.
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_tdls_get_ies(pmlan_adapter pmadapter,
+					 pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_ds_misc_tdls_ies *tdls_ies = &misc->param.tdls_ies;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	BSSDescriptor_t *pbss_desc;
+	t_u32 usr_dot_11n_dev_cap;
+	IEEEtypes_ExtCap_t *ext_cap = MNULL;
+	ExtCap_t ap_ext_cap;
+	IEEEtypes_HTCap_t *ht_cap = MNULL;
+	IEEEtypes_HTInfo_t *ht_info = MNULL;
+	IEEEtypes_VHTCap_t *vht_cap = MNULL;
+	IEEEtypes_VHTOprat_t *vht_oprat = MNULL;
+	IEEEtypes_AssocRsp_t *passoc_rsp = MNULL;
+	IEEEtypes_AID_t *aid_info = MNULL;
+	IEEEtypes_HECap_t *he_cap = MNULL;
+	IEEEtypes_HeOp_t *he_op = MNULL;
+	t_u8 supp_chan[] = {1, 11};
+	t_u8 regulatory_class[] = {1, /**current class*/
+				   1,  2,  3,  4,  12, 22, 23, 24,
+				   25, 27, 28, 29, 30, 32, 33}; /**list
+								   regulatory
+								   class*/
+	IEEEtypes_Generic_t *pSupp_chan = MNULL, *pRegulatory_class = MNULL;
+	sta_node *sta_ptr = MNULL;
+	ENTER();
+
+	/* We don't need peer information for TDLS setup */
+	if (!(tdls_ies->flags & TDLS_IE_FLAGS_SETUP))
+		sta_ptr = wlan_get_station_entry(pmpriv, tdls_ies->peer_mac);
+	pbss_desc = &pmpriv->curr_bss_params.bss_descriptor;
+	wlan_get_ap_ext_cap(pmpriv, &ap_ext_cap);
+	if (pbss_desc->bss_band & BAND_A)
+		usr_dot_11n_dev_cap = pmpriv->usr_dot_11n_dev_cap_a;
+	else
+		usr_dot_11n_dev_cap = pmpriv->usr_dot_11n_dev_cap_bg;
+
+	/** fill the extcap */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_EXTCAP) {
+		ext_cap = (IEEEtypes_ExtCap_t *)tdls_ies->ext_cap;
+		ext_cap->ieee_hdr.element_id = EXT_CAPABILITY;
+		ext_cap->ieee_hdr.len = sizeof(ExtCap_t);
+		SET_EXTCAP_TDLS(ext_cap->ext_cap);
+		RESET_EXTCAP_TDLS_UAPSD(ext_cap->ext_cap);
+		RESET_EXTCAP_TDLS_CHAN_SWITCH(ext_cap->ext_cap);
+
+		if (pmpriv->host_tdls_uapsd_support) {
+			/* uapsd in tdls confirm frame*/
+			if (tdls_ies->flags & TDLS_IE_FLAGS_HTINFO) {
+				if (sta_ptr && ISSUPP_EXTCAP_TDLS_UAPSD(
+						       sta_ptr->ExtCap.ext_cap))
+					SET_EXTCAP_TDLS_UAPSD(ext_cap->ext_cap);
+			} else {
+				SET_EXTCAP_TDLS_UAPSD(ext_cap->ext_cap);
+			}
+		}
+		/*  channel switch support */
+		if (pmpriv->host_tdls_cs_support &&
+		    !IS_EXTCAP_TDLS_CHLSWITCHPROHIB(ap_ext_cap)) {
+			/* channel switch in tdls confirm frame*/
+			if (tdls_ies->flags & TDLS_IE_FLAGS_HTINFO) {
+				if (sta_ptr && ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+						       sta_ptr->ExtCap.ext_cap))
+					SET_EXTCAP_TDLS_CHAN_SWITCH(
+						ext_cap->ext_cap);
+			} else {
+				SET_EXTCAP_TDLS_CHAN_SWITCH(ext_cap->ext_cap);
+			}
+		}
+
+		RESET_EXTCAP_TDLS_WIDER_BANDWIDTH(ext_cap->ext_cap);
+		if ((pmadapter->fw_bands & BAND_AAC) &&
+		    (MFALSE == wlan_is_ap_in_11ac_mode(pmpriv)))
+			SET_EXTCAP_TDLS_WIDER_BANDWIDTH(ext_cap->ext_cap);
+		/* if peer does not support wider bandwidth, don't set wider
+		 * bandwidth*/
+		if (sta_ptr && sta_ptr->rate_len &&
+		    !ISSUPP_EXTCAP_TDLS_WIDER_BANDWIDTH(
+			    sta_ptr->ExtCap.ext_cap))
+			RESET_EXTCAP_TDLS_WIDER_BANDWIDTH(ext_cap->ext_cap);
+		DBG_HEXDUMP(MCMD_D, "TDLS extcap", tdls_ies->ext_cap,
+			    sizeof(IEEEtypes_ExtCap_t));
+	}
+
+	/** default qos info is 0xf, compare with peer device qos info for tdls
+	 * confirm */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_QOS_INFO) {
+		if (sta_ptr && sta_ptr->rate_len)
+			tdls_ies->QosInfo = sta_ptr->qos_info & 0xf;
+		PRINTM(MCMND, "TDLS Qos info=0x%x\n", tdls_ies->QosInfo);
+	}
+
+	/** fill the htcap based on hwspec */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_HTCAP) {
+		ht_cap = (IEEEtypes_HTCap_t *)tdls_ies->ht_cap;
+		memset(pmadapter, ht_cap, 0, sizeof(IEEEtypes_HTCap_t));
+		if ((sta_ptr && !ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+					sta_ptr->ExtCap.ext_cap)) ||
+		    IS_EXTCAP_TDLS_CHLSWITCHPROHIB(ap_ext_cap))
+			wlan_fill_ht_cap_ie(pmpriv, ht_cap,
+					    pbss_desc->bss_band);
+		else if (pmpriv->host_tdls_cs_support &&
+			 (pmadapter->fw_bands & BAND_A))
+			wlan_fill_ht_cap_ie(pmpriv, ht_cap, BAND_A);
+		else
+			wlan_fill_ht_cap_ie(pmpriv, ht_cap,
+					    pbss_desc->bss_band);
+		DBG_HEXDUMP(MCMD_D, "TDLS htcap", tdls_ies->ht_cap,
+			    sizeof(IEEEtypes_HTCap_t));
+	}
+	/** if peer did not support 11AC, do not add vht related ie */
+	if (sta_ptr && sta_ptr->rate_len &&
+	    (sta_ptr->vht_cap.ieee_hdr.element_id != VHT_CAPABILITY))
+		tdls_ies->flags &=
+			~(TDLS_IE_FLAGS_VHTCAP | TDLS_IE_FLAGS_VHTOPRAT |
+			  TDLS_IE_FLAGS_AID);
+	/** fill the vhtcap based on hwspec */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_VHTCAP) {
+		vht_cap = (IEEEtypes_VHTCap_t *)tdls_ies->vht_cap;
+		memset(pmadapter, vht_cap, 0, sizeof(IEEEtypes_VHTCap_t));
+		wlan_fill_vht_cap_ie(pmpriv, vht_cap, pbss_desc->bss_band);
+		if (ht_cap)
+			SETHT_SUPPCHANWIDTH(ht_cap->ht_cap.ht_cap_info);
+		DBG_HEXDUMP(MCMD_D, "TDLS VHT Cap IE", tdls_ies->vht_cap,
+			    sizeof(IEEEtypes_VHTCap_t));
+	}
+	/** fill the vhtoperation based on hwspec */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_VHTOPRAT) {
+		vht_oprat = (IEEEtypes_VHTOprat_t *)tdls_ies->vht_oprat;
+		memset(pmadapter, vht_oprat, 0, sizeof(IEEEtypes_VHTOprat_t));
+		if (sta_ptr &&
+		    (sta_ptr->vht_cap.ieee_hdr.element_id == VHT_CAPABILITY) &&
+		    (pbss_desc->bss_band & BAND_A)) {
+			wlan_fill_tdls_vht_oprat_ie(pmpriv, vht_oprat, sta_ptr);
+		}
+		if (sta_ptr)
+			memcpy_ext(pmadapter, &sta_ptr->vht_oprat,
+				   tdls_ies->vht_oprat,
+				   sizeof(IEEEtypes_VHTOprat_t),
+				   sizeof(IEEEtypes_VHTOprat_t));
+		DBG_HEXDUMP(MCMD_D, "TDLS VHT Operation IE",
+			    tdls_ies->vht_oprat, sizeof(IEEEtypes_VHTOprat_t));
+	}
+	/** fill the AID info */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_AID) {
+		if (pmpriv->curr_bss_params.host_mlme)
+			passoc_rsp = (IEEEtypes_AssocRsp_t
+					      *)(pmpriv->assoc_rsp_buf +
+						 sizeof(IEEEtypes_MgmtHdr_t));
+		else
+			passoc_rsp =
+				(IEEEtypes_AssocRsp_t *)pmpriv->assoc_rsp_buf;
+		aid_info = (IEEEtypes_AID_t *)tdls_ies->aid_info;
+		memset(pmadapter, aid_info, 0, sizeof(IEEEtypes_AID_t));
+		aid_info->ieee_hdr.element_id = AID_INFO;
+		aid_info->ieee_hdr.len = sizeof(t_u16);
+		aid_info->AID = wlan_le16_to_cpu(passoc_rsp->a_id);
+		PRINTM(MCMND, "TDLS AID=0x%x\n", aid_info->AID);
+	}
+	/** fill the hecap based on hwspec */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_HECAP) {
+		he_cap = (IEEEtypes_HECap_t *)tdls_ies->he_cap;
+		memset(pmadapter, he_cap, 0, sizeof(IEEEtypes_HECap_t));
+		wlan_fill_he_cap_ie(pmpriv, he_cap, pbss_desc->bss_band);
+		DBG_HEXDUMP(MCMD_D, "TDLS HE Cap IE", tdls_ies->he_cap,
+			    sizeof(IEEEtypes_Header_t) + he_cap->ieee_hdr.len);
+	}
+
+	if (tdls_ies->flags & TDLS_IE_FLAGS_HEOP) {
+		he_op = (IEEEtypes_HeOp_t *)tdls_ies->he_op;
+		memset(pmadapter, he_op, 0, sizeof(IEEEtypes_HeOp_t));
+		wlan_fill_he_op_ie(pmpriv, he_op);
+	}
+	if (sta_ptr) {
+		memcpy_ext(pmadapter, &sta_ptr->he_op, tdls_ies->he_op,
+			   sizeof(IEEEtypes_HeOp_t), sizeof(IEEEtypes_HeOp_t));
+		DBG_HEXDUMP(MCMD_D, "TDLS HE Operation IE", tdls_ies->he_op,
+			    sizeof(IEEEtypes_HeOp_t));
+	}
+	/** fill the htinfo */
+	if (tdls_ies->flags & TDLS_IE_FLAGS_HTINFO) {
+		ht_info = (IEEEtypes_HTInfo_t *)tdls_ies->ht_info;
+		pbss_desc = &pmpriv->curr_bss_params.bss_descriptor;
+		ht_info->ieee_hdr.element_id = HT_OPERATION;
+		ht_info->ieee_hdr.len = sizeof(HTInfo_t);
+		ht_info->ht_info.pri_chan = pbss_desc->channel;
+		/* follow AP's channel bandwidth */
+		if (ISSUPP_CHANWIDTH40(usr_dot_11n_dev_cap) &&
+		    pbss_desc->pht_info &&
+		    ISALLOWED_CHANWIDTH40(
+			    pbss_desc->pht_info->ht_info.field2)) {
+			ht_info->ht_info.field2 =
+				pbss_desc->pht_info->ht_info.field2;
+		} else {
+			ht_info->ht_info.field2 =
+				wlan_get_second_channel_offset(
+					pmpriv, pbss_desc->channel);
+		}
+		if (vht_oprat &&
+		    vht_oprat->ieee_hdr.element_id == VHT_OPERATION) {
+			ht_info->ht_info.field2 =
+				wlan_get_second_channel_offset(
+					pmpriv, pbss_desc->channel);
+			ht_info->ht_info.field2 |= MBIT(2);
+		}
+		if (sta_ptr)
+			memcpy_ext(pmadapter, &sta_ptr->HTInfo,
+				   tdls_ies->ht_info,
+				   sizeof(IEEEtypes_HTInfo_t),
+				   sizeof(IEEEtypes_HTInfo_t));
+		DBG_HEXDUMP(MCMD_D, "TDLS htinfo", tdls_ies->ht_info,
+			    sizeof(IEEEtypes_HTInfo_t));
+	}
+
+	/** supported channels andl regulatory IE*/
+	if (pmpriv->host_tdls_cs_support &&
+	    (tdls_ies->flags & TDLS_IE_FLAGS_SUPP_CS_IE) &&
+	    !IS_EXTCAP_TDLS_CHLSWITCHPROHIB(ap_ext_cap)) {
+		/** supported channels IE*/
+		pSupp_chan = (IEEEtypes_Generic_t *)tdls_ies->supp_chan;
+		pSupp_chan->ieee_hdr.element_id = SUPPORTED_CHANNELS;
+		if (pmpriv->chan_supp_len) {
+			pSupp_chan->ieee_hdr.len = pmpriv->chan_supp_len;
+			memcpy_ext(pmadapter, pSupp_chan->data,
+				   pmpriv->chan_supp, pmpriv->chan_supp_len,
+				   sizeof(pSupp_chan->data));
+		} else {
+			pSupp_chan->ieee_hdr.len = sizeof(supp_chan);
+			memcpy_ext(pmadapter, pSupp_chan->data, supp_chan,
+				   sizeof(supp_chan), sizeof(pSupp_chan->data));
+		}
+		DBG_HEXDUMP(
+			MCMD_D, "TDLS supported channel", tdls_ies->supp_chan,
+			pSupp_chan->ieee_hdr.len + sizeof(IEEEtypes_Header_t));
+
+		/**fill supported Regulatory Class IE*/
+		pRegulatory_class =
+			(IEEEtypes_Generic_t *)tdls_ies->regulatory_class;
+		pRegulatory_class->ieee_hdr.element_id = REGULATORY_CLASS;
+		if (pmpriv->supp_regulatory_class_len) {
+			pRegulatory_class->ieee_hdr.len =
+				pmpriv->supp_regulatory_class_len;
+			memcpy_ext(pmadapter, pRegulatory_class->data,
+				   pmpriv->supp_regulatory_class,
+				   pmpriv->supp_regulatory_class_len,
+				   sizeof(pRegulatory_class->data));
+		} else {
+			pRegulatory_class->ieee_hdr.len =
+				sizeof(regulatory_class);
+			memcpy_ext(pmadapter, pRegulatory_class->data,
+				   regulatory_class, sizeof(regulatory_class),
+				   sizeof(pRegulatory_class->data));
+		}
+		DBG_HEXDUMP(MCMD_D, "TDLS supported regulatory class",
+			    tdls_ies->regulatory_class,
+			    pRegulatory_class->ieee_hdr.len +
+				    sizeof(IEEEtypes_Header_t));
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set mimo switch configuration
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_radio_ioctl_mimo_switch_cfg(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_radio_cfg *radio_cfg = (mlan_ds_radio_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_MIMO_SWITCH, 0, 0,
+			       (t_void *)pioctl_req,
+			       &(radio_cfg->param.mimo_switch_cfg));
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get extended version information
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_get_info_ver_ext(pmlan_adapter pmadapter,
+				  pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_get_info *pinfo = (mlan_ds_get_info *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_VERSION_EXT,
+			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
+			       &pinfo->param.ver_ext.version_str_sel);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get link layer statistics
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_ioctl_link_statistic(mlan_private *pmpriv,
+				      pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	/* Check buffer length of MLAN IOCTL */
+	if (pioctl_req->buf_len < sizeof(mlan_ds_get_stats)) {
+		PRINTM(MWARN,
+		       "MLAN IOCTL information buffer length is too short.\n");
+		pioctl_req->data_read_written = 0;
+		pioctl_req->buf_len_needed = sizeof(mlan_ds_get_stats);
+		pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
+		ret = MLAN_STATUS_RESOURCE;
+		goto exit;
+	}
+
+	switch (pioctl_req->action) {
+	case MLAN_ACT_GET:
+		cmd_action = HostCmd_ACT_GEN_GET;
+		break;
+	case MLAN_ACT_SET:
+		cmd_action = HostCmd_ACT_GEN_SET;
+		break;
+	case MLAN_ACT_CLEAR:
+		cmd_action = HostCmd_ACT_GEN_REMOVE;
+		break;
+	default:
+		ret = MLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_LINK_STATS,
+			       cmd_action, 0, (t_void *)pioctl_req, MNULL);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief config rtt
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_config_rtt(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = MNULL;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!pioctl_req) {
+		PRINTM(MERROR, "MLAN IOCTL information is not present\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS,
+			       HostCmd_ACT_GEN_SET, OID_RTT_REQUEST,
+			       (t_void *)pioctl_req, &(misc->param.rtt_params));
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief cancel rtt
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_cancel_rtt(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = MNULL;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!pioctl_req) {
+		PRINTM(MERROR, "MLAN IOCTL information is not present\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS,
+			       HostCmd_ACT_GEN_SET, OID_RTT_CANCEL,
+			       (t_void *)pioctl_req, &(misc->param.rtt_cancel));
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief rtt responder cfg
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_rtt_responder_cfg(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = MNULL;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!pioctl_req) {
+		PRINTM(MERROR, "MLAN IOCTL information is not present\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto exit;
+	}
+
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FTM_CONFIG_RESPONDER,
+			       HostCmd_ACT_GEN_SET, 0, (t_void *)pioctl_req,
+			       &(misc->param.rtt_rsp_cfg));
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get TX/RX histogram statistic
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_get_tx_rx_histogram(pmlan_adapter pmadapter,
+				     pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *pmisc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_TX_RX_PKT_STATS,
+			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
+			       &(pmisc->param.tx_rx_histogram));
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+#ifdef DEBUG_LEVEL1
+/**
+ *  @brief Set driver debug bit masks in order to enhance performance
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_set_drvdbg(pmlan_adapter pmadapter, pmlan_ioctl_req pioctl_req)
+{
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/* Set driver debug bit masks */
+	mlan_drvdbg = misc->param.drvdbg;
+
 	LEAVE();
 	return ret;
 }
@@ -2500,15 +3293,15 @@ mlan_status wlan_process_802dot11_mgmt_pkt(mlan_private *priv, t_u8 *payload,
 #endif
 		if (priv->bss_role == MLAN_BSS_ROLE_STA) {
 			if (priv->curr_bss_params.host_mlme) {
-				if (memcmp(pmadapter, pieee_pkt_hdr->addr2,
+				if (memcmp(pmadapter, pieee_pkt_hdr->addr3,
 					   (t_u8 *)priv->curr_bss_params
 						   .bss_descriptor.mac_address,
 					   MLAN_MAC_ADDR_LENGTH)) {
-					PRINTM(MINFO,
-					       "Dropping mgmt frame from others: type=%d " MACSTR
+					PRINTM(MCMND,
+					       "Dropping Deauth frame from other bssid: type=%d " MACSTR
 					       "\n",
 					       sub_type,
-					       MAC2STR(pieee_pkt_hdr->addr2));
+					       MAC2STR(pieee_pkt_hdr->addr3));
 					LEAVE();
 					return ret;
 				}
@@ -2540,6 +3333,16 @@ mlan_status wlan_process_802dot11_mgmt_pkt(mlan_private *priv, t_u8 *payload,
 			LEAVE();
 			return ret;
 		}
+		if ((category == CATEGORY_PUBLIC) &&
+		    (action_code == TDLS_DISCOVERY_RESPONSE)) {
+			pcb->moal_updata_peer_signal(pmadapter->pmoal_handle,
+						     priv->bss_index,
+						     pieee_pkt_hdr->addr2,
+						     prx_pd->snr, prx_pd->nf);
+			PRINTM(MINFO,
+			       "Rx: TDLS discovery response, nf=%d, snr=%d\n",
+			       prx_pd->nf, prx_pd->snr);
+		}
 		if (memcmp(pmadapter, pieee_pkt_hdr->addr1, broadcast,
 			   MLAN_MAC_ADDR_LENGTH))
 			unicast = MTRUE;
@@ -2569,7 +3372,8 @@ mlan_status wlan_process_802dot11_mgmt_pkt(mlan_private *priv, t_u8 *payload,
 	pevent = (pmlan_event)event_buf;
 	pevent->bss_index = priv->bss_index;
 	mgmt = (IEEE80211_MGMT *)payload;
-	if (!priv->curr_bss_params.host_mlme && sub_type == SUBTYPE_ACTION &&
+	if (priv->bss_role == MLAN_BSS_ROLE_STA &&
+	    !priv->curr_bss_params.host_mlme && sub_type == SUBTYPE_ACTION &&
 	    mgmt->u.ft_resp.category == FT_CATEGORY &&
 	    mgmt->u.ft_resp.action == FT_ACTION_RESPONSE &&
 	    mgmt->u.ft_resp.status_code == 0) {
@@ -2586,7 +3390,8 @@ mlan_status wlan_process_802dot11_mgmt_pkt(mlan_private *priv, t_u8 *payload,
 			   payload + FT_ACTION_HEAD_LEN,
 			   payload_len - FT_ACTION_HEAD_LEN,
 			   pevent->event_len - MLAN_MAC_ADDR_LENGTH);
-	} else if (!priv->curr_bss_params.host_mlme &&
+	} else if (priv->bss_role == MLAN_BSS_ROLE_STA &&
+		   !priv->curr_bss_params.host_mlme &&
 		   sub_type == SUBTYPE_AUTH &&
 		   mgmt->u.auth.auth_alg == MLAN_AUTH_MODE_FT &&
 		   mgmt->u.auth.auth_transaction == 2 &&
@@ -2710,7 +3515,55 @@ mlan_status wlan_misc_hotspot_cfg(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Set multi ap flag
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_multi_ap_cfg(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (MLAN_ACT_GET == pioctl_req->action)
+		misc->param.multi_ap_flag = pmpriv->multi_ap_flag;
+	else if (MLAN_ACT_SET == pioctl_req->action)
+		pmpriv->multi_ap_flag = misc->param.multi_ap_flag;
+
+	LEAVE();
+	return ret;
+}
+
 #ifdef STA_SUPPORT
+/**
+ *  @brief This function check if we should enable beacon protection support
+ *
+ *  @param pbss_desc    A pointer to BSSDescriptor_t structure
+ *
+ *  @return        MTRUE/MFALSE
+ */
+t_u8 wlan_check_beacon_prot_supported(mlan_private *pmpriv,
+				      BSSDescriptor_t *pbss_desc)
+{
+	if (pbss_desc && pbss_desc->pext_cap) {
+		if (pbss_desc->pext_cap->ieee_hdr.len < 11)
+			return MFALSE;
+		if (!ISSUPP_EXTCAP_EXT_BEACON_PROT(
+			    pbss_desc->pext_cap->ext_cap))
+			return MFALSE;
+	}
+	if (!IS_FW_SUPPORT_BEACON_PROT(pmpriv->adapter))
+		return MFALSE;
+	return MTRUE;
+}
+
 /**
  *  @brief Add Extended Capabilities IE
  *
@@ -2735,8 +3588,18 @@ void wlan_add_ext_capa_info_ie(mlan_private *pmpriv, BSSDescriptor_t *pbss_desc,
 		SET_EXTCAP_EXT_CHANNEL_SWITCH(pmpriv->ext_cap);
 	else
 		RESET_EXTCAP_EXT_CHANNEL_SWITCH(pmpriv->ext_cap);
+	if (pmpriv->adapter->pcard_info->support_11mc) {
+		SET_EXTCAP_FTMI(pmpriv->ext_cap);
+		SET_EXTCAP_INTERNETWORKING(pmpriv->ext_cap);
+	}
+	if (pbss_desc && pbss_desc->multi_bssid_ap)
+		SET_EXTCAP_MULTI_BSSID(pmpriv->ext_cap);
 	if (wlan_check_11ax_twt_supported(pmpriv, pbss_desc))
 		SET_EXTCAP_TWT_REQ(pmpriv->ext_cap);
+
+	if (wlan_check_beacon_prot_supported(pmpriv, pbss_desc))
+		SET_EXTCAP_BEACON_PROT(pmpriv->ext_cap);
+
 	memcpy_ext(pmpriv->adapter, &pext_cap->ext_cap, &pmpriv->ext_cap,
 		   sizeof(pmpriv->ext_cap), sizeof(pext_cap->ext_cap));
 	*pptlv_out += sizeof(MrvlIETypes_ExtCap_t);
@@ -2781,6 +3644,33 @@ mlan_status wlan_misc_otp_user_data(pmlan_adapter pmadapter,
 	return ret;
 }
 
+#ifdef UAP_SUPPORT
+/**
+ *  @brief	Check 11B support Rates
+ *
+ *
+ *  @param pmadapter	Private mlan adapter structure
+ *
+ *  @return MTRUE/MFALSE
+ *
+ */
+static t_u8 wlan_check_ie_11b_support_rates(pIEEEtypes_Generic_t prates)
+{
+	int i;
+	t_u8 rate;
+	t_u8 ret = MTRUE;
+	for (i = 0; i < prates->ieee_hdr.len; i++) {
+		rate = prates->data[i] & 0x7f;
+		if ((rate != 0x02) && (rate != 0x04) && (rate != 0x0b) &&
+		    (rate != 0x16)) {
+			ret = MFALSE;
+			break;
+		}
+	}
+	return ret;
+}
+#endif
+
 /**
  *  @brief This function will search for the specific ie
  *
@@ -2801,7 +3691,8 @@ void wlan_check_sta_capability(pmlan_private priv, pmlan_buffer pevent,
 	IEEEtypes_VHTCap_t *pvht_cap = MNULL;
 	IEEEtypes_Extension_t *phe_cap = MNULL;
 #ifdef UAP_SUPPORT
-	t_u8 *ext_rate = MNULL, *erp = MNULL;
+	t_u8 *rate = MNULL;
+	t_u8 b_only = MFALSE;
 #endif
 
 	int tlv_buf_left = pevent->data_len - ASSOC_EVENT_FIX_SIZE;
@@ -2920,23 +3811,29 @@ void wlan_check_sta_capability(pmlan_private priv, pmlan_buffer pevent,
 				    (priv->is_11ax_enabled == MTRUE)) {
 					PRINTM(MCMND, "STA supports 11ax\n");
 					sta_ptr->is_11ax_enabled = MTRUE;
+					memcpy_ext(
+						priv->adapter,
+						(t_u8 *)&sta_ptr->he_cap,
+						phe_cap,
+						phe_cap->ieee_hdr.len +
+							sizeof(IEEEtypes_Header_t),
+						sizeof(IEEEtypes_HECap_t));
+					sta_ptr->he_cap.ieee_hdr.len = MIN(
+						phe_cap->ieee_hdr.len,
+						sizeof(IEEEtypes_HECap_t) -
+							sizeof(IEEEtypes_Header_t));
 				} else {
 					PRINTM(MCMND,
 					       "STA doesn't support 11ax\n");
 				}
 #ifdef UAP_SUPPORT
 				/* Note: iphone6 does not have ERP_INFO */
-				ext_rate = wlan_get_specific_ie(
-					priv, assoc_req_ie, ie_len,
-					EXTENDED_SUPPORTED_RATES, 0);
-				erp = wlan_get_specific_ie(priv, assoc_req_ie,
-							   ie_len, ERP_INFO, 0);
-				if (!ext_rate)
-					PRINTM(MCMND,
-					       "STA doesn't support EXTENDED_SUPPORTED_RATES\n");
-				if (!erp)
-					PRINTM(MCMND,
-					       "STA doesn't support ERP_INFO\n");
+				rate = wlan_get_specific_ie(priv, assoc_req_ie,
+							    ie_len,
+							    SUPPORTED_RATES, 0);
+				if (rate)
+					b_only = wlan_check_ie_11b_support_rates(
+						(pIEEEtypes_Generic_t)rate);
 				if (sta_ptr->is_11ax_enabled) {
 					if (priv->uap_channel <= 14)
 						sta_ptr->bandmode = BAND_GAX;
@@ -2952,13 +3849,13 @@ void wlan_check_sta_capability(pmlan_private priv, pmlan_buffer pevent,
 						sta_ptr->bandmode = BAND_GN;
 					else
 						sta_ptr->bandmode = BAND_AN;
-				} else if (ext_rate || erp) {
-					if (priv->uap_channel <= 14)
-						sta_ptr->bandmode = BAND_G;
+				} else if (priv->uap_channel <= 14) {
+					if (b_only)
+						sta_ptr->bandmode = BAND_B;
 					else
-						sta_ptr->bandmode = BAND_A;
+						sta_ptr->bandmode = BAND_G;
 				} else
-					sta_ptr->bandmode = BAND_B;
+					sta_ptr->bandmode = BAND_A;
 #endif
 #ifdef DRV_EMBEDDED_AUTHENTICATOR
 				if (IsAuthenticatorEnabled(priv->psapriv))
@@ -3008,8 +3905,8 @@ t_u8 wlan_is_wmm_ie_present(pmlan_adapter pmadapter, t_u8 *pbuf, t_u16 buf_len)
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 
 		if (bytes_left < total_ie_len) {
-			PRINTM(MERROR, "InterpretIE: Error in processing IE, "
-				       "bytes left < IE length\n");
+			//PRINTM(MERROR, "InterpretIE: Error in processing IE, "
+			//	       "bytes left < IE length\n");
 			bytes_left = 0;
 			continue;
 		}
@@ -3048,7 +3945,7 @@ t_u8 wlan_is_wmm_ie_present(pmlan_adapter pmadapter, t_u8 *pbuf, t_u16 buf_len)
  *
  *  @return	       ie's poiner or MNULL
  */
-t_u8 *wlan_get_specific_ie(pmlan_private priv, t_u8 *ie_buf, t_u8 ie_len,
+t_u8 *wlan_get_specific_ie(pmlan_private priv, t_u8 *ie_buf, t_u16 ie_len,
 			   IEEEtypes_ElementId_e id, t_u8 ext_id)
 {
 	t_u32 bytes_left = ie_len;
@@ -3068,8 +3965,8 @@ t_u8 *wlan_get_specific_ie(pmlan_private priv, t_u8 *ie_buf, t_u8 ie_len,
 		element_eid = *((t_u8 *)pcurrent_ptr + 2);
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 		if (bytes_left < total_ie_len) {
-			PRINTM(MERROR, "InterpretIE: Error in processing IE, "
-				       "bytes left < IE length\n");
+			//PRINTM(MERROR, "InterpretIE: Error in processing IE, "
+			//	       "bytes left < IE length\n");
 			break;
 		}
 		if ((!ext_id && element_id == id) ||
@@ -3244,10 +4141,10 @@ mlan_status wlan_radio_ioctl_ant_cfg(pmlan_adapter pmadapter,
 	if (pioctl_req->action == MLAN_ACT_SET) {
 		/* User input validation */
 		if (IS_STREAM_2X2(pmadapter->feature_control)) {
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 			if (IS_CARD9098(pmadapter->card_type) ||
-			    IS_CARD9097(pmadapter->card_type)) {
+			    IS_CARD9097(pmadapter->card_type) ||
+			    IS_CARDAW693(pmadapter->card_type) ||
+			    IS_CARDIW62X(pmadapter->card_type)) {
 				ant_cfg->tx_antenna &= 0x0303;
 				ant_cfg->rx_antenna &= 0x0303;
 				/** 2G antcfg TX */
@@ -3286,14 +4183,9 @@ mlan_status wlan_radio_ioctl_ant_cfg(pmlan_adapter pmadapter,
 				       ant_cfg->tx_antenna,
 				       ant_cfg->rx_antenna);
 			} else {
-#endif
-
 				ant_cfg->tx_antenna &= 0x0003;
 				ant_cfg->rx_antenna &= 0x0003;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 			}
-#endif
 			if (!ant_cfg->tx_antenna ||
 			    bitcount(ant_cfg->tx_antenna & 0x00FF) >
 				    pmadapter->number_of_antenna ||
@@ -3710,7 +4602,7 @@ static mlan_status wlan_rate_ioctl_set_rate_index(pmlan_adapter pmadapter,
 					ret = MLAN_STATUS_SUCCESS;
 				}
 			} else {
-				PRINTM(MERROR,
+				PRINTM(MINFO,
 				       "Error! Fw doesn't support 11AX\n");
 				LEAVE();
 				return MLAN_STATUS_FAILURE;
@@ -3815,45 +4707,157 @@ mlan_status wlan_rate_ioctl_get_data_rate(pmlan_adapter pmadapter,
 	}
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_TX_RATE_QUERY,
-			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
-			       MNULL);
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_TX_RATE_QUERY,
+			       HostCmd_ACT_GEN_GET, 0, (t_void *)pioctl_req,
+			       MNULL);
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+exit:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get remain on channel setting
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+mlan_status wlan_radio_ioctl_remain_chan_cfg(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_radio_cfg *radio_cfg = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	radio_cfg = (mlan_ds_radio_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_REMAIN_ON_CHANNEL,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &radio_cfg->param.remain_chan);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+#ifdef WIFI_DIRECT_SUPPORT
+/**
+ *  @brief Set/Get wifi_direct_mode
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+mlan_status wlan_bss_ioctl_wifi_direct_mode(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_bss *bss = MNULL;
+
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	bss = (mlan_ds_bss *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_WIFI_DIRECT_MODE_CONFIG,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &bss->param.wfd_mode);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get p2p config
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
+ */
+mlan_status wlan_misc_p2p_config(pmlan_adapter pmadapter,
+				 pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	misc_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_P2P_PARAMS_CONFIG, cmd_action,
+			       0, (t_void *)pioctl_req,
+			       &misc_cfg->param.p2p_config);
+
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
 
-exit:
 	LEAVE();
 	return ret;
 }
+#endif
 
 /**
- *  @brief Set/Get remain on channel setting
+ *  @brief Set/Get GPIO TSF Latch config
  *
  *  @param pmadapter	A pointer to mlan_adapter structure
  *  @param pioctl_req	A pointer to ioctl request buffer
  *
  *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-mlan_status wlan_radio_ioctl_remain_chan_cfg(pmlan_adapter pmadapter,
-					     pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_gpio_tsf_latch_config(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_ds_radio_cfg *radio_cfg = MNULL;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
 	t_u16 cmd_action = 0;
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 
 	ENTER();
 
-	radio_cfg = (mlan_ds_radio_cfg *)pioctl_req->pbuf;
+	misc_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
 	else
 		cmd_action = HostCmd_ACT_GEN_GET;
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_REMAIN_ON_CHANNEL,
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG,
 			       cmd_action, 0, (t_void *)pioctl_req,
-			       &radio_cfg->param.remain_chan);
+			       &misc_cfg->param.gpio_tsf_latch_config);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -3862,37 +4866,31 @@ mlan_status wlan_radio_ioctl_remain_chan_cfg(pmlan_adapter pmadapter,
 	return ret;
 }
 
-#ifdef WIFI_DIRECT_SUPPORT
 /**
- *  @brief Set/Get wifi_direct_mode
+ *  @brief Get TSF info
  *
  *  @param pmadapter	A pointer to mlan_adapter structure
  *  @param pioctl_req	A pointer to ioctl request buffer
  *
  *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-mlan_status wlan_bss_ioctl_wifi_direct_mode(pmlan_adapter pmadapter,
-					    pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_get_tsf_info(pmlan_adapter pmadapter,
+				   pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_ds_bss *bss = MNULL;
-
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
 	t_u16 cmd_action = 0;
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 
 	ENTER();
 
-	bss = (mlan_ds_bss *)pioctl_req->pbuf;
-
-	if (pioctl_req->action == MLAN_ACT_SET)
-		cmd_action = HostCmd_ACT_GEN_SET;
-	else
-		cmd_action = HostCmd_ACT_GEN_GET;
+	misc_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	cmd_action = HostCmd_ACT_GEN_GET;
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_WIFI_DIRECT_MODE_CONFIG,
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG,
 			       cmd_action, 0, (t_void *)pioctl_req,
-			       &bss->param.wfd_mode);
+			       &misc_cfg->param.tsf_info);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -3902,15 +4900,15 @@ mlan_status wlan_bss_ioctl_wifi_direct_mode(pmlan_adapter pmadapter,
 }
 
 /**
- *  @brief Set/Get p2p config
+ *  @brief Set/Get CROSS CHIP SYNCH config
  *
  *  @param pmadapter	A pointer to mlan_adapter structure
  *  @param pioctl_req	A pointer to ioctl request buffer
  *
  *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-mlan_status wlan_misc_p2p_config(pmlan_adapter pmadapter,
-				 pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_ioctl_cross_chip_synch(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_misc_cfg *misc_cfg = MNULL;
@@ -3922,13 +4920,18 @@ mlan_status wlan_misc_p2p_config(pmlan_adapter pmadapter,
 	misc_cfg = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
-	else
+	else if (pioctl_req->action == MLAN_ACT_GET)
 		cmd_action = HostCmd_ACT_GEN_GET;
+	else {
+		PRINTM(MERROR, "Unsupported cmd_action\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_P2P_PARAMS_CONFIG, cmd_action,
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_CROSS_CHIP_SYNCH, cmd_action,
 			       0, (t_void *)pioctl_req,
-			       &misc_cfg->param.p2p_config);
+			       &misc_cfg->param.gpio_tsf_latch_config);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -3936,7 +4939,6 @@ mlan_status wlan_misc_p2p_config(pmlan_adapter pmadapter,
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
  *  @brief Set coalesce config
@@ -4085,17 +5087,16 @@ mlan_status wlan_misc_ioctl_txcontrol(pmlan_adapter pmadapter,
 	return ret;
 }
 
-#ifdef RX_PACKET_COALESCE
 /**
- *  @brief Get/Set RX packet coalescing configuration
+ *  @brief Get/Set channel time and buffer weight configuration
  *
  *  @param pmadapter    A pointer to mlan_adapter structure
  *  @param pioctl_req   A pointer to ioctl request buffer
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_misc_ioctl_rx_pkt_coalesce_config(pmlan_adapter pmadapter,
-						   pmlan_ioctl_req pioctl_req)
+mlan_status wlan_misc_ioctl_multi_chan_config(pmlan_adapter pmadapter,
+					      pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_misc_cfg *misc = MNULL;
@@ -4112,9 +5113,89 @@ mlan_status wlan_misc_ioctl_rx_pkt_coalesce_config(pmlan_adapter pmadapter,
 		cmd_action = HostCmd_ACT_GEN_GET;
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_RX_PKT_COALESCE_CFG,
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MULTI_CHAN_CONFIG,
 			       cmd_action, 0, (t_void *)pioctl_req,
-			       &misc->param.rx_coalesce);
+			       &misc->param.multi_chan_cfg);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get/Set multi-channel policy setting
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_misc_ioctl_multi_chan_policy(pmlan_adapter pmadapter,
+					      pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET) {
+		if (pmadapter->dfs_repeater) {
+			PRINTM(MMSG,
+			       "DFS-Repeater is on, can not enable DRCS\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto fail;
+		}
+		cmd_action = HostCmd_ACT_GEN_SET;
+	} else {
+		cmd_action = HostCmd_ACT_GEN_GET;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MULTI_CHAN_POLICY,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &misc->param.multi_chan_policy);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+fail:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get/Set DRCS configuration
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_misc_ioctl_drcs_config(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_DRCS_CONFIG, cmd_action, 0,
+			       (t_void *)pioctl_req, &misc->param.drcs_cfg);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -4122,7 +5203,6 @@ mlan_status wlan_misc_ioctl_rx_pkt_coalesce_config(pmlan_adapter pmadapter,
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
  *  @brief Is any uAP started or STA connected?
@@ -4189,6 +5269,14 @@ mlan_status wlan_misc_ioctl_dfs_repeater_cfg(pmlan_adapter pmadapter,
 			goto done;
 		}
 
+		/* If DRCS is on then we should not set
+		 * DFS-repeater mode */
+		if (pmadapter->mc_policy) {
+			PRINTM(MERROR,
+			       "DFS-repeater cannot be started when DRCS is on\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
 		cmd_action = HostCmd_ACT_GEN_SET;
 	} else {
 		cmd_action = HostCmd_ACT_GEN_GET;
@@ -4372,8 +5460,8 @@ inline mlan_status mef_push(pmlan_adapter pmadapter, mef_stack *s, mef_op *op)
  *
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
-mlan_status push_filter_dnum_eq(pmlan_adapter pmadapter, mef_stack *s,
-				mef_filter_t *filter)
+static mlan_status push_filter_dnum_eq(pmlan_adapter pmadapter, mef_stack *s,
+				       mef_filter_t *filter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 dnum;
@@ -4443,8 +5531,8 @@ mlan_status push_filter_dnum_eq(pmlan_adapter pmadapter, mef_stack *s,
  *
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
-mlan_status push_filter_byte_eq(pmlan_adapter pmadapter, mef_stack *s,
-				mef_filter_t *filter)
+static mlan_status push_filter_byte_eq(pmlan_adapter pmadapter, mef_stack *s,
+				       mef_filter_t *filter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 dnum;
@@ -4515,8 +5603,8 @@ mlan_status push_filter_byte_eq(pmlan_adapter pmadapter, mef_stack *s,
  *
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
-mlan_status push_filter_bit_eq(pmlan_adapter pmadapter, mef_stack *s,
-			       mef_filter_t *filter)
+static mlan_status push_filter_bit_eq(pmlan_adapter pmadapter, mef_stack *s,
+				      mef_filter_t *filter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 dnum;
@@ -4588,8 +5676,8 @@ mlan_status push_filter_bit_eq(pmlan_adapter pmadapter, mef_stack *s,
  *
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
-mlan_status wlan_push_filter(pmlan_adapter pmadapter, mef_stack *s,
-			     mef_filter_t *filter)
+static mlan_status wlan_push_filter(pmlan_adapter pmadapter, mef_stack *s,
+				    mef_filter_t *filter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
@@ -4620,8 +5708,9 @@ mlan_status wlan_push_filter(pmlan_adapter pmadapter, mef_stack *s,
  *
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
-mlan_status wlan_generate_mef_filter_stack(pmlan_adapter pmadapter,
-					   mef_stack *s, mef_entry_t *entry)
+static mlan_status wlan_generate_mef_filter_stack(pmlan_adapter pmadapter,
+						  mef_stack *s,
+						  mef_entry_t *entry)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mef_op op;
@@ -4660,7 +5749,7 @@ mlan_status wlan_generate_mef_filter_stack(pmlan_adapter pmadapter,
  *  @return             MLAN_STATUS_SUCCESS or FAIL
  */
 mlan_status wlan_set_mef_entry(mlan_private *pmpriv, pmlan_adapter pmadapter,
-			       mef_cfg *pmef)
+			       mef_cfg_data *pmef)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_misc_cmd *hostcmd;
@@ -4691,7 +5780,6 @@ mlan_status wlan_set_mef_entry(mlan_private *pmpriv, pmlan_adapter pmadapter,
 	}
 
 	/** Fill the cmd header data*/
-	memset(pmadapter, hostcmd, 0, sizeof(mlan_ds_misc_cmd));
 	buf = hostcmd->cmd;
 	hostcmd_hdr = (HostCmd_DS_GEN *)buf;
 	hostcmd_hdr->command = wlan_cpu_to_le16(HostCmd_CMD_MEF_CFG);
@@ -4750,38 +5838,47 @@ mlan_status wlan_process_mef_cfg_cmd(mlan_private *pmpriv,
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb;
-	mef_cfg mef;
-	mef_entry_t *pentry;
+	mef_cfg_data mef;
+	mef_entry_t *pentry = MNULL;
 	mef_entry *pmef;
 	t_u16 entry_num = 0;
 
 	ENTER();
 
 	pcb = &pmadapter->callbacks;
+	memset(pmadapter, &mef, 0, sizeof(mef_cfg_data));
 
 	/** check how many entries in adapter*/
 	pmef = &pmadapter->entry_cfg;
+	entry_num += pmef->enable_autoarp_entry;
 	entry_num += pmef->num_wowlan_entry;
 	entry_num += pmef->num_ipv6_ns_offload;
-	if (!entry_num) {
+	if (!entry_num && !pmef->clear_mef_entry) {
 		PRINTM(MIOCTL, "No filter entries\n");
 		goto done;
 	}
-
-	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
-			       sizeof(mef_entry_t) * entry_num, MLAN_MEM_DEF,
-			       (t_u8 **)&mef.pentry);
-	if (ret != MLAN_STATUS_SUCCESS || mef.pentry == MNULL) {
-		PRINTM(MERROR, "Failed to allocate cmd data buffer\n");
-		ret = MLAN_STATUS_FAILURE;
-		goto err_handle;
+	if (entry_num) {
+		ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+				       sizeof(mef_entry_t) * entry_num,
+				       MLAN_MEM_DEF, (t_u8 **)&mef.pentry);
+		if (ret != MLAN_STATUS_SUCCESS || mef.pentry == MNULL) {
+			PRINTM(MERROR, "Failed to allocate cmd data buffer\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto err_handle;
+		}
 	}
+
 	/** Fill mef_cfg structure*/
 	mef.criteria = pmef->criteria;
 	mef.entry_num = entry_num;
-	memset(pmadapter, mef.pentry, 0, sizeof(mef_entry_t) * entry_num);
 	pentry = mef.pentry;
 	/** Fill mef_entry_t structure*/
+	/** Copy Auto arp response entry*/
+	if (pmef->enable_autoarp_entry) {
+		memcpy_ext(pmadapter, pentry, &pmef->entry[5],
+			   sizeof(mef_entry_t), sizeof(mef_entry_t));
+		pentry += pmef->enable_autoarp_entry;
+	}
 	/** Copy wowlan entry*/
 	if (pmef->num_wowlan_entry) {
 		memcpy_ext(pmadapter, pentry, &pmef->entry[6],
@@ -4842,6 +5939,43 @@ mlan_status wlan_misc_ioctl_mef_flt_cfg(pmlan_adapter pmadapter,
 				   &mef_cfg->mef_entry, sizeof(mef_entry_t),
 				   sizeof(mef_entry_t));
 		}
+		/** Set AUTO ARP Entry to adapter*/
+		if (mef_cfg->mef_act_type == MEF_ACT_AUTOARP) {
+			if (mef_cfg->op_code & MLAN_IPADDR_OP_AUTO_ARP_RESP) {
+				pmef->enable_autoarp_entry = 1;
+				pmef->criteria |= mef_cfg->criteria;
+				memcpy_ext(pmadapter, &pmef->entry[5],
+					   &mef_cfg->mef_entry,
+					   sizeof(mef_entry_t),
+					   sizeof(mef_entry_t));
+				if (MLAN_STATUS_SUCCESS !=
+				    wlan_process_mef_cfg_cmd(
+					    pmadapter
+						    ->priv[pioctl_req->bss_index],
+					    pmadapter))
+					PRINTM(MERROR,
+					       "Set MEF Entries Error\n");
+			} else if (!(mef_cfg->op_code &
+				     MLAN_IPADDR_OP_IP_REMOVE)) {
+				pmef->enable_autoarp_entry = 0;
+				pmef->num_wowlan_entry = 0;
+				pmef->num_ipv6_ns_offload = 0;
+				pmef->clear_mef_entry = 1;
+				memset(pmadapter, &pmef->entry[5], 0,
+				       sizeof(mef_entry_t));
+				memset(pmadapter, &pmef->entry[6], 0,
+				       sizeof(mef_entry_t));
+				memset(pmadapter, &pmef->entry[7], 0,
+				       sizeof(mef_entry_t));
+				if (MLAN_STATUS_SUCCESS !=
+				    wlan_process_mef_cfg_cmd(
+					    pmadapter
+						    ->priv[pioctl_req->bss_index],
+					    pmadapter))
+					PRINTM(MERROR,
+					       "Clear MEF Entries Error\n");
+			}
+		}
 		break;
 	case MLAN_ACT_GET:
 		if (mef_cfg->mef_act_type == MEF_ACT_WOWLAN)
@@ -5157,6 +6291,7 @@ mlan_status wlan_misc_ioctl_operclass_validation(pmlan_adapter pmadapter,
 	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_misc_cfg *misc = MNULL;
 	t_u8 channel, oper_class;
+	t_u8 bandwidth;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
@@ -5164,9 +6299,11 @@ mlan_status wlan_misc_ioctl_operclass_validation(pmlan_adapter pmadapter,
 	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	channel = misc->param.bw_chan_oper.channel;
 	oper_class = misc->param.bw_chan_oper.oper_class;
+	bandwidth = misc->param.bw_chan_oper.bandwidth;
+
 	if (pioctl_req->action == MLAN_ACT_GET) {
 		ret = wlan_check_operclass_validation(pmpriv, channel,
-						      oper_class);
+						      oper_class, bandwidth);
 	} else {
 		PRINTM(MERROR, "Unsupported cmd_action\n");
 		LEAVE();
@@ -5191,11 +6328,9 @@ mlan_status wlan_get_rgchnpwr_cfg(pmlan_adapter pmadapter,
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 cmd_action = 0;
-	mlan_ds_misc_cfg *misc = MNULL;
 
 	ENTER();
 
-	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	cmd_action = HostCmd_ACT_GEN_GET;
 
 	/* Send request to firmware */
@@ -5209,6 +6344,111 @@ mlan_status wlan_get_rgchnpwr_cfg(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief  Get/Set mc_aggr_cfg
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_mc_aggr_cfg(pmlan_adapter pmadapter,
+					mlan_ioctl_req *pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+	mlan_ds_misc_cfg *misc = MNULL;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	cmd_action = pioctl_req->action;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MC_AGGR_CFG, cmd_action, 0,
+			       (t_void *)pioctl_req,
+			       (t_void *)&misc->param.mc_aggr_cfg);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+/**
+ *  @brief  get channel load results
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_ch_load_results(pmlan_adapter pmadapter,
+					    mlan_ioctl_req *pioctl_req)
+{
+	mlan_private *pmpriv = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+	mlan_ds_misc_cfg *misc = MNULL;
+
+	ENTER();
+	if (pioctl_req == MNULL)
+		return MLAN_STATUS_FAILURE;
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	cmd_action = pioctl_req->action;
+
+	/* Send request to firmware */
+	if (pmpriv->ch_load_param == 255) {
+		return MLAN_STATUS_FAILURE;
+	} else {
+		misc->param.ch_load.ch_load_param = pmpriv->ch_load_param;
+		misc->param.ch_load.noise = pmpriv->noise;
+		misc->param.ch_load.rx_quality = pmpriv->rx_quality;
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief  get channel load
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_ch_load(pmlan_adapter pmadapter,
+				    mlan_ioctl_req *pioctl_req)
+{
+	mlan_private *pmpriv = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+	mlan_ds_misc_cfg *misc = MNULL;
+
+	ENTER();
+	if (pioctl_req == MNULL)
+		return MLAN_STATUS_FAILURE;
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	cmd_action = pioctl_req->action;
+
+	/* Send request to firmware */
+	pmpriv->ch_load_param = 255; /* Default value for identifying
+					update/non-updated value*/
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_GET_CH_LOAD, cmd_action, 0,
+			       (t_void *)pioctl_req,
+			       (t_void *)&misc->param.ch_load);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief  Get CHAN_TPRC setting
  *
@@ -5292,38 +6532,77 @@ mlan_status wlan_misc_ioctl_oper_class(pmlan_adapter pmadapter,
 }
 
 /**
- *  @brief config dynamic bandwidth
+ *  @brief config dynamic bandwidth
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_misc_ioctl_fw_dump_event(pmlan_adapter pmadapter,
+					  mlan_ioctl_req *pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	t_u16 cmd_action = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else if (pioctl_req->action == MLAN_ACT_GET)
+		cmd_action = HostCmd_ACT_GEN_GET;
+	else {
+		PRINTM(MERROR, "Unsupported cmd_action\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FW_DUMP_EVENT, cmd_action, 0,
+			       (t_void *)pioctl_req, MNULL);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get the network monitor configuration.
  *
  *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *  @param pioctl_req   A pointer to ioctl request buffer
  *
- *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ *  @return             MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_fw_dump_event(pmlan_adapter pmadapter,
-					  mlan_ioctl_req *pioctl_req)
+mlan_status wlan_misc_ioctl_net_monitor(pmlan_adapter pmadapter,
+					pmlan_ioctl_req pioctl_req)
 {
-	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_misc_cfg *misc = MNULL;
-	t_u16 cmd_action = 0;
+	mlan_private *pmpriv;
+	mlan_ds_misc_cfg *misc;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
 
 	ENTER();
 
-	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	if (!pioctl_req) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+	pmpriv = pmadapter->priv[pioctl_req->bss_index];
 
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
-	else if (pioctl_req->action == MLAN_ACT_GET)
+	else
 		cmd_action = HostCmd_ACT_GEN_GET;
-	else {
-		PRINTM(MERROR, "Unsupported cmd_action\n");
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
 
-	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FW_DUMP_EVENT, cmd_action, 0,
-			       (t_void *)pioctl_req, MNULL);
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_NET_MONITOR,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &misc->param.net_mon);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -5531,6 +6810,38 @@ mlan_status wlan_misc_ioctl_rxabortcfg(pmlan_adapter pmadapter,
 	LEAVE();
 	return ret;
 }
+
+/**
+ *  @brief OFDM DESENSE CFG
+ *
+ *  @param pmadapter   A pointer to mlan_adapter structure
+ *  @param pioctl_req  A pointer to ioctl request buffer
+ *
+ *  @return        MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_ofdmdesense_cfg(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *pmisc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_OFDM_DESENSE_CFG, cmd_action,
+			       0, (t_void *)pioctl_req,
+			       &(pmisc->param.ofdm_desense_cfg));
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
 /**
  *  @brief Rx Abort Cfg ext
  *
@@ -5825,7 +7136,33 @@ mlan_status wlan_misc_ioctl_rf_test_cfg(pmlan_adapter pmadapter,
 				       cmd_action, 0, (t_void *)pioctl_req,
 				       &(pmisc->param.mfg_tx_frame2));
 		break;
+	case MLAN_OID_MISC_RF_TEST_CONFIG_TRIGGER_FRAME:
+		if (pioctl_req->action == MLAN_ACT_SET)
+			cmd_action = HostCmd_ACT_GEN_SET;
+		else {
+			PRINTM(MERROR, "Unsupported cmd_action\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MFG_COMMAND,
+				       cmd_action, 0, (t_void *)pioctl_req,
+				       &(pmisc->param.mfg_tx_trigger_config));
+		break;
+
+	case MLAN_OID_MISC_RF_TEST_HE_POWER:
+		if (pioctl_req->action == MLAN_ACT_SET)
+			cmd_action = HostCmd_ACT_GEN_SET;
+		else {
+			PRINTM(MERROR, "Unsupported cmd_action\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MFG_COMMAND,
+				       cmd_action, 0, (t_void *)pioctl_req,
+				       &(pmisc->param.mfg_he_power));
+		break;
 	}
+
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
 done:
@@ -5864,3 +7201,266 @@ mlan_status wlan_misc_ioctl_range_ext(pmlan_adapter pmadapter,
 	LEAVE();
 	return ret;
 }
+
+/**
+ *   @brief twt_report cmd
+ *   @param pmadapter   A pointer to mlan_adapter structure
+ *   @param pioctl_req  A pointer to ioctl request buffer
+ *
+ *   @return        MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_twt_report(pmlan_adapter pmadapter,
+				       pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *pmisc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	cmd_action = HostCmd_ACT_GEN_GET;
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_TWT_CFG, cmd_action, 0,
+			       (t_void *)pioctl_req,
+			       &(pmisc->param.twt_report_info));
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Perform warm reset
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_misc_ioctl_warm_reset(pmlan_adapter pmadapter,
+				       pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	pmlan_callbacks pcb = &pmadapter->callbacks;
+	pmlan_buffer pmbuf;
+	t_s32 i = 0;
+	t_u16 mc_policy = pmadapter->mc_policy;
+	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	ENTER();
+	mlan_block_rx_process(pmadapter, MTRUE);
+
+	/* Cancel all pending commands and complete ioctls */
+	if (misc->param.fw_reload)
+		wlan_cancel_all_pending_cmd(pmadapter, MTRUE);
+
+	/** Init all the head nodes and free all the locks here */
+	for (i = 0; i < pmadapter->priv_num; i++)
+		wlan_free_priv(pmadapter->priv[i]);
+
+	while ((pmbuf = (pmlan_buffer)util_dequeue_list(
+			pmadapter->pmoal_handle, &pmadapter->rx_data_queue,
+			pcb->moal_spin_lock, pcb->moal_spin_unlock))) {
+		pmadapter->ops.data_complete(pmadapter, pmbuf,
+					     MLAN_STATUS_FAILURE);
+	}
+	pmadapter->rx_pkts_queued = 0;
+
+	/* Initialize adapter structure */
+	wlan_init_adapter(pmadapter);
+	pmadapter->hw_status = WlanHardwareStatusInitializing;
+
+	/* Initialize private structures */
+	for (i = 0; i < pmadapter->priv_num; i++) {
+		if (pmadapter->priv[i]) {
+			/* Reset to sta role */
+#ifdef WIFI_DIRECT_SUPPORT
+			if (pmadapter->priv[i]->bss_type ==
+			    MLAN_BSS_TYPE_WIFIDIRECT)
+				pmadapter->priv[i]->bss_role =
+					MLAN_BSS_ROLE_STA;
+#endif
+			wlan_init_priv(pmadapter->priv[i]);
+		}
+	}
+	mlan_block_rx_process(pmadapter, MFALSE);
+
+	if (misc->param.fw_reload != MTRUE) {
+		/* Restart the firmware */
+		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FUNC_SHUTDOWN,
+				       HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
+		if (ret)
+			goto done;
+	}
+
+	/* Issue firmware initialize commands for first BSS,
+	 * for other interfaces it will be called after getting
+	 * the last init command response of previous interface
+	 */
+	pmpriv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
+	if (!pmpriv) {
+		ret = MLAN_STATUS_FAILURE;
+		LEAVE();
+		return ret;
+	}
+	ret = wlan_adapter_get_hw_spec(pmpriv->adapter);
+	if (ret == MLAN_STATUS_FAILURE) {
+		LEAVE();
+		return ret;
+	}
+	ret = pmpriv->ops.init_cmd(pmpriv, MTRUE);
+	if (ret == MLAN_STATUS_FAILURE) {
+		LEAVE();
+		return ret;
+	}
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_MULTI_CHAN_POLICY,
+			       HostCmd_ACT_GEN_SET, 0, MNULL, &mc_policy);
+	if (ret == MLAN_STATUS_FAILURE) {
+		LEAVE();
+		return ret;
+	}
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+	if (ret == MLAN_STATUS_PENDING)
+		pmadapter->pwarm_reset_ioctl_req = pioctl_req;
+done:
+	LEAVE();
+	return ret;
+}
+
+#ifdef UAP_SUPPORT
+/**
+ *  @brief set wacp mode
+ *
+ *  @param pmadapter   A pointer to mlan_adapter structure
+ *  @param pioctl_req  A pointer to ioctl request buffer
+ *
+ *  @return            MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_wacp_mode(IN pmlan_adapter pmadapter,
+				      IN pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_SYS_CONFIGURE, cmd_action,
+			       0, (t_void *)pioctl_req,
+			       (t_void *)&misc->param.wacp_mode);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+#endif
+
+mlan_status wlan_misc_ioctl_get_sensor_temp(pmlan_adapter pmadapter,
+					    pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	if (pioctl_req->action == MLAN_ACT_GET)
+		cmd_action = HostCmd_ACT_GEN_GET;
+	else {
+		PRINTM(MERROR, " Sensor temp only support get operation \n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_DS_GET_SENSOR_TEMP, cmd_action,
+			       0, (t_void *)pioctl_req, MNULL);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function sets up country code and downloads CMD to FW
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_misc_ioctl_country_code(pmlan_adapter pmadapter,
+					 mlan_ioctl_req *pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_country_code *country_code = MNULL;
+	mlan_ds_misc_cfg *cfg_misc = MNULL;
+	t_u8 cfp_bg = 0, cfp_a = 0;
+
+	ENTER();
+
+	cfg_misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	country_code = &cfg_misc->param.country_code;
+
+	if (pioctl_req->action == MLAN_ACT_SET) {
+		if (pmadapter->otp_region && pmadapter->otp_region->force_reg) {
+			PRINTM(MERROR,
+			       "ForceRegionRule is set in the on-chip OTP"
+			       "memory\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		/* Update region code and table based on country code */
+		if (wlan_misc_country_2_cfp_table_code(
+			    pmadapter, country_code->country_code, &cfp_bg,
+			    &cfp_a)) {
+			PRINTM(MERROR, "Country code not found!\n");
+			pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		pmadapter->cfp_code_bg = cfp_bg;
+		pmadapter->cfp_code_a = cfp_a;
+		if (cfp_a)
+			pmadapter->region_code = cfp_a;
+		else if (cfp_bg)
+			pmadapter->region_code = cfp_bg;
+		else
+			pmadapter->region_code = 0;
+		if (wlan_set_regiontable(pmpriv, pmadapter->region_code,
+					 pmadapter->config_bands |
+						 pmadapter->adhoc_start_band)) {
+			pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		memcpy_ext(pmadapter, pmadapter->country_code,
+			   country_code->country_code, COUNTRY_CODE_LEN,
+			   COUNTRY_CODE_LEN);
+	} else {
+		/* GET operation */
+		memcpy_ext(pmadapter, country_code->country_code,
+			   pmadapter->country_code, COUNTRY_CODE_LEN,
+			   COUNTRY_CODE_LEN);
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_module.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_module.c
old mode 100644
new mode 100755
index 4e26b9001..2281d4520
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_module.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_module.c
@@ -3,7 +3,7 @@
  *  @brief This file declares the exported symbols from MLAN.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -45,6 +45,7 @@ EXPORT_SYMBOL(mlan_ioctl);
 EXPORT_SYMBOL(mlan_main_process);
 EXPORT_SYMBOL(mlan_rx_process);
 EXPORT_SYMBOL(mlan_select_wmm_queue);
+EXPORT_SYMBOL(mlan_process_deaggr_pkt);
 #if defined(SDIO) || defined(PCIE)
 EXPORT_SYMBOL(mlan_interrupt);
 #if defined(SYSKT)
@@ -57,6 +58,8 @@ EXPORT_SYMBOL(mlan_is_main_process_running);
 #ifdef PCIE
 EXPORT_SYMBOL(mlan_set_int_mode);
 #endif
+EXPORT_SYMBOL(mlan_disable_host_int);
+EXPORT_SYMBOL(mlan_enable_host_int);
 
 MODULE_DESCRIPTION("M-WLAN MLAN Driver");
 MODULE_AUTHOR("NXP");
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c
old mode 100644
new mode 100755
index 7d4977e52..819617072
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.c
@@ -3,7 +3,7 @@
  *  @brief This file contains PCI-E specific code
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -40,7 +40,198 @@ Change log:
 /********************************************************
 			Local Variables
 ********************************************************/
+#ifdef PCIE8897
+static const struct _mlan_pcie_card_reg mlan_reg_pcie8897 = {
+	.reg_txbd_rdptr = PCIE8897_RD_DATA_PTR_Q0_Q1,
+	.reg_txbd_wrptr = PCIE8897_WR_DATA_PTR_Q0_Q1,
+	.reg_rxbd_rdptr = PCIE8897_RD_DATA_PTR_Q0_Q1,
+	.reg_rxbd_wrptr = PCIE8897_WR_DATA_PTR_Q0_Q1,
+	.reg_evtbd_rdptr = REG_EVTBD_RDPTR,
+	.reg_evtbd_wrptr = REG_EVTBD_WRPTR,
+	.reg_host_int_mask = PCIE_HOST_INT_MASK,
+	.reg_host_int_status_mask = PCIE_HOST_INT_STATUS_MASK,
+	.reg_host_int_status = PCIE_HOST_INT_STATUS,
+	.reg_cpu_int_event = PCIE_CPU_INT_EVENT,
+	.reg_ip_rev = PCIE_IP_REV_REG,
+	.reg_drv_ready = REG_DRV_READY,
+	.reg_cpu_int_status = PCIE_CPU_INT_STATUS,
+	.reg_scratch_0 = PCIE_SCRATCH_0_REG,
+	.reg_scratch_1 = PCIE_SCRATCH_1_REG,
+	.reg_scratch_2 = PCIE_SCRATCH_2_REG,
+	.reg_scratch_3 = PCIE_SCRATCH_3_REG,
+	.host_intr_mask = HOST_INTR_MASK,
+	.host_intr_dnld_done = HOST_INTR_DNLD_DONE,
+	.host_intr_upld_rdy = HOST_INTR_UPLD_RDY,
+	.host_intr_cmd_done = HOST_INTR_CMD_DONE,
+	.host_intr_event_rdy = HOST_INTR_EVENT_RDY,
+	.txrx_rw_ptr_mask = 0x000003FF,
+	.txrx_rw_ptr_wrap_mask = 0x000007FF,
+	.txrx_rw_ptr_rollover_ind = MBIT(10),
+	.use_adma = MFALSE,
+	.msi_int_wr_clr = MTRUE,
+};
+
+static const struct _mlan_card_info mlan_card_info_pcie8897 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 0,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 0,
+};
+#endif
+
+#ifdef PCIE8997
+static const struct _mlan_pcie_card_reg mlan_reg_pcie8997 = {
+	.reg_txbd_rdptr = PCIE8997_RD_DATA_PTR_Q0_Q1,
+	.reg_txbd_wrptr = PCIE8997_WR_DATA_PTR_Q0_Q1,
+	.reg_rxbd_rdptr = PCIE8997_RD_DATA_PTR_Q0_Q1,
+	.reg_rxbd_wrptr = PCIE8997_WR_DATA_PTR_Q0_Q1,
+	.reg_evtbd_rdptr = REG_EVTBD_RDPTR,
+	.reg_evtbd_wrptr = REG_EVTBD_WRPTR,
+	.reg_host_int_mask = PCIE_HOST_INT_MASK,
+	.reg_host_int_status_mask = PCIE_HOST_INT_STATUS_MASK,
+	.reg_host_int_status = PCIE_HOST_INT_STATUS,
+	.reg_cpu_int_event = PCIE_CPU_INT_EVENT,
+	.reg_ip_rev = PCIE_IP_REV_REG,
+	.reg_drv_ready = REG_DRV_READY,
+	.reg_cpu_int_status = PCIE_CPU_INT_STATUS,
+	.reg_scratch_0 = PCIE_SCRATCH_0_REG,
+	.reg_scratch_1 = PCIE_SCRATCH_1_REG,
+	.reg_scratch_2 = PCIE_SCRATCH_2_REG,
+	.reg_scratch_3 = PCIE_SCRATCH_3_REG,
+	.host_intr_mask = HOST_INTR_MASK,
+	.host_intr_dnld_done = HOST_INTR_DNLD_DONE,
+	.host_intr_upld_rdy = HOST_INTR_UPLD_RDY,
+	.host_intr_cmd_done = HOST_INTR_CMD_DONE,
+	.host_intr_event_rdy = HOST_INTR_EVENT_RDY,
+	.txrx_rw_ptr_mask = 0x00000FFF,
+	.txrx_rw_ptr_wrap_mask = 0x00001FFF,
+	.txrx_rw_ptr_rollover_ind = MBIT(12),
+	.use_adma = MFALSE,
+	.msi_int_wr_clr = MTRUE,
+};
+
+static const struct _mlan_card_info mlan_card_info_pcie8997 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
 
+static const struct _mlan_pcie_card_reg mlan_reg_pcieaw693 = {
+	.reg_txbd_rdptr = PCIE9098_TXBD_RDPTR,
+	.reg_txbd_wrptr = PCIE9098_TXBD_WRPTR,
+	.reg_rxbd_rdptr = PCIE9098_RXBD_RDPTR,
+	.reg_rxbd_wrptr = PCIE9098_RXBD_WRPTR,
+	.reg_evtbd_rdptr = PCIE9098_EVTBD_RDPTR,
+	.reg_evtbd_wrptr = PCIE9098_EVTBD_WRPTR,
+	.reg_host_int_mask = PCIE9097_B0_HOST_INT_MASK,
+	.reg_host_int_status_mask = PCIE9097_B0_HOST_INT_STATUS_MASK,
+	.reg_host_int_status = PCIE9097_B0_HOST_INT_STATUS,
+	.reg_host_int_clr_sel = PCIE9097_B0_HOST_INT_CLR_SEL,
+	.reg_cpu_int_event = PCIE9098_CPU_INT_EVENT,
+	.reg_ip_rev = PCIE9098_DEV_ID_REG,
+	.reg_drv_ready = PCIE9098_DRV_READY,
+	.reg_cpu_int_status = PCIE9098_CPU_INT_STATUS,
+	.reg_rev_id = PCIE9098_REV_ID_REG,
+	.reg_scratch_0 = PCIE9098_SCRATCH_0_REG,
+	.reg_scratch_1 = PCIE9098_SCRATCH_1_REG,
+	.reg_scratch_2 = PCIE9098_SCRATCH_2_REG,
+	.reg_scratch_3 = PCIE9098_SCRATCH_3_REG,
+	.reg_scratch_6 = PCIE9098_SCRATCH_6_REG,
+	.reg_scratch_7 = PCIE9098_SCRATCH_7_REG,
+	.host_intr_mask = PCIE9098_HOST_INTR_MASK,
+	.host_intr_dnld_done = PCIE9098_HOST_INTR_DNLD_DONE,
+	.host_intr_upld_rdy = PCIE9098_HOST_INTR_UPLD_RDY,
+	.host_intr_cmd_done = PCIE9098_HOST_INTR_CMD_DONE,
+	.host_intr_event_rdy = PCIE9098_HOST_INTR_EVENT_RDY,
+	.host_intr_cmd_dnld = PCIE9098_HOST_INTR_CMD_DNLD,
+	.adma_align_size = ADMA_ALIGN_SIZE_1,
+	.adma_min_pkt_size = ADMA_MIN_PKT_SIZE_32,
+	.use_adma = MTRUE,
+	.msi_int_wr_clr = MTRUE,
+};
+
+#if defined(PCIE9098) || defined(PCIE9097) || defined(PCIEIW62X)
+static const struct _mlan_pcie_card_reg mlan_reg_pcie9097_b0 = {
+	.reg_txbd_rdptr = PCIE9098_TXBD_RDPTR,
+	.reg_txbd_wrptr = PCIE9098_TXBD_WRPTR,
+	.reg_rxbd_rdptr = PCIE9098_RXBD_RDPTR,
+	.reg_rxbd_wrptr = PCIE9098_RXBD_WRPTR,
+	.reg_evtbd_rdptr = PCIE9098_EVTBD_RDPTR,
+	.reg_evtbd_wrptr = PCIE9098_EVTBD_WRPTR,
+	.reg_host_int_mask = PCIE9097_B0_HOST_INT_MASK,
+	.reg_host_int_status_mask = PCIE9097_B0_HOST_INT_STATUS_MASK,
+	.reg_host_int_status = PCIE9097_B0_HOST_INT_STATUS,
+	.reg_host_int_clr_sel = PCIE9097_B0_HOST_INT_CLR_SEL,
+	.reg_cpu_int_event = PCIE9098_CPU_INT_EVENT,
+	.reg_ip_rev = PCIE9098_DEV_ID_REG,
+	.reg_drv_ready = PCIE9098_DRV_READY,
+	.reg_cpu_int_status = PCIE9098_CPU_INT_STATUS,
+	.reg_rev_id = PCIE9098_REV_ID_REG,
+	.reg_scratch_0 = PCIE9098_SCRATCH_0_REG,
+	.reg_scratch_1 = PCIE9098_SCRATCH_1_REG,
+	.reg_scratch_2 = PCIE9098_SCRATCH_2_REG,
+	.reg_scratch_3 = PCIE9098_SCRATCH_3_REG,
+	.reg_scratch_6 = PCIE9098_SCRATCH_6_REG,
+	.reg_scratch_7 = PCIE9098_SCRATCH_7_REG,
+	.host_intr_mask = PCIE9098_HOST_INTR_MASK,
+	.host_intr_dnld_done = PCIE9098_HOST_INTR_DNLD_DONE,
+	.host_intr_upld_rdy = PCIE9098_HOST_INTR_UPLD_RDY,
+	.host_intr_cmd_done = PCIE9098_HOST_INTR_CMD_DONE,
+	.host_intr_event_rdy = PCIE9098_HOST_INTR_EVENT_RDY,
+	.host_intr_cmd_dnld = PCIE9098_HOST_INTR_CMD_DNLD,
+	.adma_align_size = ADMA_ALIGN_SIZE,
+	.adma_min_pkt_size = ADMA_MIN_PKT_SIZE,
+	.use_adma = MTRUE,
+	.msi_int_wr_clr = MTRUE,
+};
+#endif
+
+static const struct _mlan_pcie_card_reg mlan_reg_pcie9098 = {
+	.reg_txbd_rdptr = PCIE9098_TXBD_RDPTR,
+	.reg_txbd_wrptr = PCIE9098_TXBD_WRPTR,
+	.reg_rxbd_rdptr = PCIE9098_RXBD_RDPTR,
+	.reg_rxbd_wrptr = PCIE9098_RXBD_WRPTR,
+	.reg_evtbd_rdptr = PCIE9098_EVTBD_RDPTR,
+	.reg_evtbd_wrptr = PCIE9098_EVTBD_WRPTR,
+	.reg_host_int_mask = PCIE9098_HOST_INT_MASK,
+	.reg_host_int_status_mask = PCIE9098_HOST_INT_STATUS_MASK,
+	.reg_host_int_status = PCIE9098_HOST_INT_STATUS,
+	.reg_host_int_clr_sel = PCIE9098_HOST_INT_CLR_SEL,
+	.reg_cpu_int_event = PCIE9098_CPU_INT_EVENT,
+	.reg_ip_rev = PCIE9098_DEV_ID_REG,
+	.reg_drv_ready = PCIE9098_DRV_READY,
+	.reg_cpu_int_status = PCIE9098_CPU_INT_STATUS,
+	.reg_rev_id = PCIE9098_REV_ID_REG,
+	.reg_scratch_0 = PCIE9098_SCRATCH_0_REG,
+	.reg_scratch_1 = PCIE9098_SCRATCH_1_REG,
+	.reg_scratch_2 = PCIE9098_SCRATCH_2_REG,
+	.reg_scratch_3 = PCIE9098_SCRATCH_3_REG,
+	.reg_scratch_6 = PCIE9098_SCRATCH_6_REG,
+	.reg_scratch_7 = PCIE9098_SCRATCH_7_REG,
+	.host_intr_mask = PCIE9098_HOST_INTR_MASK,
+	.host_intr_dnld_done = PCIE9098_HOST_INTR_DNLD_DONE,
+	.host_intr_upld_rdy = PCIE9098_HOST_INTR_UPLD_RDY,
+	.host_intr_cmd_done = PCIE9098_HOST_INTR_CMD_DONE,
+	.host_intr_event_rdy = PCIE9098_HOST_INTR_EVENT_RDY,
+	.host_intr_cmd_dnld = PCIE9098_HOST_INTR_CMD_DNLD,
+	.adma_align_size = ADMA_ALIGN_SIZE,
+	.adma_min_pkt_size = ADMA_MIN_PKT_SIZE,
+	.use_adma = MTRUE,
+	.msi_int_wr_clr = MTRUE,
+};
+
+static const struct _mlan_card_info mlan_card_info_pcie9098 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
 /********************************************************
 			Global Variables
 ********************************************************/
@@ -52,7 +243,6 @@ Change log:
 static mlan_status wlan_pcie_delete_evtbd_ring(pmlan_adapter pmadapter);
 static mlan_status wlan_pcie_delete_rxbd_ring(pmlan_adapter pmadapter);
 
-#if defined(PCIE9098) || defined(PCIE9097)
 /**
  *  @brief This function init the adma setting
  *
@@ -67,7 +257,7 @@ static mlan_status wlan_pcie_delete_rxbd_ring(pmlan_adapter pmadapter);
 static mlan_status wlan_init_adma(mlan_adapter *pmadapter, t_u8 type,
 				  t_u64 pbase, t_u16 size, t_u8 init)
 {
-	t_u32 dma_cfg, dma_cfg2, int_mapping;
+	t_u32 dma_cfg, dma_cfg2, dma_cfg3, int_mapping;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 q_addr = 0;
 	t_u8 direction = 0;
@@ -158,6 +348,25 @@ static mlan_status wlan_init_adma(mlan_adapter *pmadapter, t_u8 type,
 					dma_cfg2 |=
 						ADMA_MSI_LEGACY_SRC_DMA_DONE_INT_BYPASS_EN;
 			} else {
+				/* Read the dma_cfg3 register */
+				if (pcb->moal_read_reg(pmadapter->pmoal_handle,
+						       q_addr + ADMA_DMA_CFG3,
+						       &dma_cfg3)) {
+					PRINTM(MERROR,
+					       "Fail to read DMA CFG3 register\n");
+					ret = MLAN_STATUS_FAILURE;
+					goto done;
+				}
+				dma_cfg3 |= ADMA_Q_PTR_CLR;
+				if (pcb->moal_write_reg(pmadapter->pmoal_handle,
+							q_addr + ADMA_DMA_CFG3,
+							(t_u32)dma_cfg3)) {
+					PRINTM(MERROR,
+					       "Failed to write ADMA_DMA_CFG3.\n");
+					ret = MLAN_STATUS_FAILURE;
+					goto done;
+				}
+
 				dma_cfg2 |= ADMA_DST_DMA_DONE_INT_BYPASS_EN;
 				if (pmadapter->pcard_pcie->pcie_int_mode !=
 				    PCIE_INT_MODE_MSIX)
@@ -334,9 +543,41 @@ static mlan_status wlan_init_adma(mlan_adapter *pmadapter, t_u8 type,
 	LEAVE();
 	return ret;
 }
-#endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
+/**
+ *  @brief This function init the adma ring size from user input
+ *
+ *  @param pmadapter  A pointer to mlan_adapter structure
+ *
+ *  @return 	      N/A
+ */
+static void wlan_pcie_init_adma_ring_size(mlan_adapter *pmadapter)
+{
+	t_u16 num_desc = 0;
+	t_u16 ring_size = 0;
+
+	ring_size = pmadapter->init_para.ring_size;
+	if (!ring_size)
+		return;
+	if (ring_size < MAX_TXRX_BD)
+		ring_size = MAX_TXRX_BD;
+	else if (ring_size > ADMA_MAX_TXRX_BD)
+		ring_size = ADMA_MAX_TXRX_BD;
+	if (ring_size != pmadapter->pcard_pcie->txrx_bd_size) {
+		ring_size = ring_size >> 1;
+		while (ring_size > 0) {
+			ring_size = ring_size >> 1;
+			num_desc++;
+		}
+		pmadapter->pcard_pcie->txrx_bd_size = 1 << num_desc;
+		pmadapter->pcard_pcie->txrx_num_desc = num_desc;
+	}
+	PRINTM(MMSG, "ring_size =%d num_desc=%d\n",
+	       pmadapter->pcard_pcie->txrx_bd_size,
+	       pmadapter->pcard_pcie->txrx_num_desc);
+	return;
+}
+
 /**
  *  @brief This function set the host interrupt select mask
  *
@@ -382,9 +623,7 @@ static mlan_status wlan_pcie_set_host_int_select_mask(mlan_adapter *pmadapter,
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
-#endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 /**
  *  @brief This function handles command response completion
  *
@@ -460,7 +699,6 @@ static mlan_status wlan_pcie_send_vdll(mlan_adapter *pmadapter,
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
  *  @brief This function disables the host interrupt
@@ -545,7 +783,7 @@ wlan_pcie_enable_host_int_status_mask(mlan_adapter *pmadapter, t_u8 enable)
  *
  *  @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_disable_pcie_host_int(mlan_adapter *pmadapter)
+static mlan_status wlan_disable_pcie_host_int(mlan_adapter *pmadapter)
 {
 	mlan_status ret;
 
@@ -555,8 +793,9 @@ mlan_status wlan_disable_pcie_host_int(mlan_adapter *pmadapter)
 		LEAVE();
 		return ret;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if ((pmadapter->card_type == CARD_TYPE_PCIE9098) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEIW62X) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEAW693) ||
 	    (pmadapter->card_type == CARD_TYPE_PCIE9097)) {
 		ret = wlan_pcie_set_host_int_select_mask(pmadapter, MFALSE);
 		if (ret) {
@@ -564,7 +803,6 @@ mlan_status wlan_disable_pcie_host_int(mlan_adapter *pmadapter)
 			return ret;
 		}
 	}
-#endif
 	ret = wlan_pcie_disable_host_int_mask(pmadapter);
 	LEAVE();
 	return ret;
@@ -578,7 +816,7 @@ mlan_status wlan_disable_pcie_host_int(mlan_adapter *pmadapter)
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_clear_pending_int_status(mlan_adapter *pmadapter)
+static mlan_status wlan_clear_pending_int_status(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 pcie_ireg = 0;
@@ -621,7 +859,7 @@ mlan_status wlan_clear_pending_int_status(mlan_adapter *pmadapter)
  *
  *  @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_enable_pcie_host_int(mlan_adapter *pmadapter)
+static mlan_status wlan_enable_pcie_host_int(mlan_adapter *pmadapter)
 {
 	mlan_status ret;
 
@@ -632,8 +870,9 @@ mlan_status wlan_enable_pcie_host_int(mlan_adapter *pmadapter)
 		LEAVE();
 		return ret;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if ((pmadapter->card_type == CARD_TYPE_PCIE9098) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEIW62X) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEAW693) ||
 	    (pmadapter->card_type == CARD_TYPE_PCIE9097)) {
 		ret = wlan_pcie_set_host_int_select_mask(pmadapter, MTRUE);
 		if (ret) {
@@ -641,7 +880,6 @@ mlan_status wlan_enable_pcie_host_int(mlan_adapter *pmadapter)
 			return ret;
 		}
 	}
-#endif
 	ret = wlan_pcie_enable_host_int_mask(pmadapter);
 	LEAVE();
 	return ret;
@@ -662,9 +900,7 @@ static mlan_status wlan_pcie_create_txbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	pmlan_pcie_data_buf ptx_bd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	padma_dual_desc_buf padma_bd_buf;
-#endif
 
 	ENTER();
 	/*
@@ -680,14 +916,14 @@ static mlan_status wlan_pcie_create_txbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	if (!pmadapter->pcard_pcie->reg->use_adma)
 		pmadapter->pcard_pcie->txbd_ring_size =
-			sizeof(mlan_pcie_data_buf) * MLAN_MAX_TXRX_BD;
+			sizeof(mlan_pcie_data_buf) *
+			pmadapter->pcard_pcie->txrx_bd_size;
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma)
 		pmadapter->pcard_pcie->txbd_ring_size =
-			sizeof(adma_dual_desc_buf) * MLAN_MAX_TXRX_BD;
-#endif
+			sizeof(adma_dual_desc_buf) *
+			pmadapter->pcard_pcie->txrx_bd_size;
 	PRINTM(MINFO, "TX ring: allocating %d bytes\n",
 	       pmadapter->pcard_pcie->txbd_ring_size);
 
@@ -711,9 +947,8 @@ static mlan_status wlan_pcie_create_txbd_ring(mlan_adapter *pmadapter)
 	       (t_u32)pmadapter->pcard_pcie->txbd_ring_pbase,
 	       pmadapter->pcard_pcie->txbd_ring_size);
 
-	for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
+	for (i = 0; i < pmadapter->pcard_pcie->txrx_bd_size; i++) {
 		pmadapter->pcard_pcie->tx_buf_list[i] = MNULL;
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf
@@ -724,13 +959,12 @@ static mlan_status wlan_pcie_create_txbd_ring(mlan_adapter *pmadapter)
 				(t_void *)padma_bd_buf;
 			padma_bd_buf->paddr = 0;
 			padma_bd_buf->len = 0;
-			padma_bd_buf->flags =
+			padma_bd_buf->flags = wlan_cpu_to_le16(
 				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_SRC_HOST |
-				ADMA_BD_FLAG_SOP | ADMA_BD_FLAG_EOP;
+				ADMA_BD_FLAG_SOP | ADMA_BD_FLAG_EOP);
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 		}
-#endif
 
 #if defined(PCIE8997) || defined(PCIE8897)
 		if (!pmadapter->pcard_pcie->reg->use_adma) {
@@ -768,13 +1002,11 @@ static mlan_status wlan_pcie_delete_txbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_data_buf *ptx_bd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
 
-	for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
+	for (i = 0; i < pmadapter->pcard_pcie->txrx_bd_size; i++) {
 		if (pmadapter->pcard_pcie->tx_buf_list[i]) {
 			pmbuf = pmadapter->pcard_pcie->tx_buf_list[i];
 			pcb->moal_unmap_memory(pmadapter->pmoal_handle,
@@ -802,7 +1034,6 @@ static mlan_status wlan_pcie_delete_txbd_ring(mlan_adapter *pmadapter)
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)
@@ -816,7 +1047,6 @@ static mlan_status wlan_pcie_delete_txbd_ring(mlan_adapter *pmadapter)
 				padma_bd_buf->reserved = 0;
 			}
 		}
-#endif
 		pmadapter->pcard_pcie->txbd_ring[i] = MNULL;
 	}
 
@@ -854,9 +1084,7 @@ static mlan_status wlan_pcie_create_rxbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_data_buf *prxbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
 
@@ -873,22 +1101,23 @@ static mlan_status wlan_pcie_create_rxbd_ring(mlan_adapter *pmadapter)
 		/* allocate shared memory for the BD ring and divide the same in
 		to several descriptors */
 		pmadapter->pcard_pcie->rxbd_ring_size =
-			sizeof(mlan_pcie_data_buf) * MLAN_MAX_TXRX_BD;
+			sizeof(mlan_pcie_data_buf) *
+			pmadapter->pcard_pcie->txrx_bd_size;
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	/*
 	 * driver maintaines the write pointer and firmware maintaines the read
 	 * pointer. The read pointer starts at 0 (zero) while the write pointer
-	 * starts at MLAN_MAX_TXRX_BD
+	 * starts at pmadapter->pcard_pcie->txrx_bd_size;
 	 */
 	if (pmadapter->pcard_pcie->reg->use_adma) {
-		pmadapter->pcard_pcie->rxbd_wrptr = MLAN_MAX_TXRX_BD;
+		pmadapter->pcard_pcie->rxbd_wrptr =
+			pmadapter->pcard_pcie->txrx_bd_size;
 		pmadapter->pcard_pcie->rxbd_ring_size =
-			sizeof(adma_dual_desc_buf) * MLAN_MAX_TXRX_BD;
+			sizeof(adma_dual_desc_buf) *
+			pmadapter->pcard_pcie->txrx_bd_size;
 	}
-#endif
 
 	PRINTM(MINFO, "RX ring: allocating %d bytes\n",
 	       pmadapter->pcard_pcie->rxbd_ring_size);
@@ -913,7 +1142,7 @@ static mlan_status wlan_pcie_create_rxbd_ring(mlan_adapter *pmadapter)
 	       (t_u32)pmadapter->pcard_pcie->rxbd_ring_pbase,
 	       pmadapter->pcard_pcie->rxbd_ring_size);
 
-	for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
+	for (i = 0; i < pmadapter->pcard_pcie->txrx_bd_size; i++) {
 		/* Allocate buffer here so that firmware can DMA data on it */
 		pmbuf = wlan_alloc_mlan_buffer(pmadapter, MLAN_RX_DATA_BUF_SIZE,
 					       MLAN_RX_HEADER_LEN,
@@ -956,15 +1185,17 @@ static mlan_status wlan_pcie_create_rxbd_ring(mlan_adapter *pmadapter)
 					    (sizeof(mlan_pcie_data_buf) * i));
 			pmadapter->pcard_pcie->rxbd_ring[i] =
 				(t_void *)prxbd_buf;
-			prxbd_buf->paddr = pmbuf->buf_pa;
-			prxbd_buf->len = (t_u16)pmbuf->data_len;
-			prxbd_buf->flags = MLAN_BD_FLAG_SOP | MLAN_BD_FLAG_EOP;
+			prxbd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			prxbd_buf->len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
+			prxbd_buf->flags = wlan_cpu_to_le16(MLAN_BD_FLAG_SOP |
+							    MLAN_BD_FLAG_EOP);
 			prxbd_buf->offset = 0;
-			prxbd_buf->frag_len = (t_u16)pmbuf->data_len;
+			prxbd_buf->frag_len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf
@@ -973,15 +1204,15 @@ static mlan_status wlan_pcie_create_rxbd_ring(mlan_adapter *pmadapter)
 					    (sizeof(adma_dual_desc_buf) * i));
 			pmadapter->pcard_pcie->rxbd_ring[i] =
 				(t_void *)padma_bd_buf;
-			padma_bd_buf->paddr = pmbuf->buf_pa;
-			padma_bd_buf->len =
-				ALIGN_SZ(pmbuf->data_len, ADMA_ALIGN_SIZE);
-			padma_bd_buf->flags =
-				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST;
+			padma_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			padma_bd_buf->len = wlan_cpu_to_le16(ALIGN_SZ(
+				pmbuf->data_len,
+				pmadapter->pcard_pcie->reg->adma_align_size));
+			padma_bd_buf->flags = wlan_cpu_to_le16(
+				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST);
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 		}
-#endif
 	}
 
 	LEAVE();
@@ -1003,12 +1234,10 @@ static mlan_status wlan_pcie_delete_rxbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_data_buf *prxbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
-	for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
+	for (i = 0; i < pmadapter->pcard_pcie->txrx_bd_size; i++) {
 		if (pmadapter->pcard_pcie->rx_buf_list[i]) {
 			pmbuf = pmadapter->pcard_pcie->rx_buf_list[i];
 			pcb->moal_unmap_memory(pmadapter->pmoal_handle,
@@ -1034,7 +1263,6 @@ static mlan_status wlan_pcie_delete_rxbd_ring(mlan_adapter *pmadapter)
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)
@@ -1048,7 +1276,6 @@ static mlan_status wlan_pcie_delete_rxbd_ring(mlan_adapter *pmadapter)
 				padma_bd_buf->len = 0;
 			}
 		}
-#endif
 		pmadapter->pcard_pcie->rxbd_ring[i] = MNULL;
 	}
 
@@ -1085,9 +1312,7 @@ static mlan_status wlan_pcie_create_evtbd_ring(mlan_adapter *pmadapter)
 	pmlan_pcie_evt_buf pevtbd_buf;
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
 	/*
@@ -1104,13 +1329,11 @@ static mlan_status wlan_pcie_create_evtbd_ring(mlan_adapter *pmadapter)
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		pmadapter->pcard_pcie->evtbd_wrptr = MLAN_MAX_EVT_BD;
 		pmadapter->pcard_pcie->evtbd_ring_size =
 			sizeof(adma_dual_desc_buf) * MLAN_MAX_EVT_BD;
 	}
-#endif
 	PRINTM(MINFO, "Evt ring: allocating %d bytes\n",
 	       pmadapter->pcard_pcie->evtbd_ring_size);
 
@@ -1169,13 +1392,13 @@ static mlan_status wlan_pcie_create_evtbd_ring(mlan_adapter *pmadapter)
 					    (sizeof(mlan_pcie_evt_buf) * i));
 			pmadapter->pcard_pcie->evtbd_ring[i] =
 				(t_void *)pevtbd_buf;
-			pevtbd_buf->paddr = pmbuf->buf_pa;
-			pevtbd_buf->len = (t_u16)pmbuf->data_len;
+			pevtbd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			pevtbd_buf->len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
 			pevtbd_buf->flags = 0;
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf
@@ -1184,15 +1407,15 @@ static mlan_status wlan_pcie_create_evtbd_ring(mlan_adapter *pmadapter)
 					    (sizeof(adma_dual_desc_buf) * i));
 			pmadapter->pcard_pcie->evtbd_ring[i] =
 				(t_void *)padma_bd_buf;
-			padma_bd_buf->paddr = pmbuf->buf_pa;
-			padma_bd_buf->len =
-				ALIGN_SZ(pmbuf->data_len, ADMA_ALIGN_SIZE);
-			padma_bd_buf->flags =
-				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST;
+			padma_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			padma_bd_buf->len = wlan_cpu_to_le16(ALIGN_SZ(
+				pmbuf->data_len,
+				pmadapter->pcard_pcie->reg->adma_align_size));
+			padma_bd_buf->flags = wlan_cpu_to_le16(
+				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST);
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 		}
-#endif
 	}
 
 	LEAVE();
@@ -1214,9 +1437,7 @@ static mlan_status wlan_pcie_delete_evtbd_ring(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_evt_buf *pevtbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
 	for (i = 0; i < MLAN_MAX_EVT_BD; i++) {
@@ -1244,7 +1465,6 @@ static mlan_status wlan_pcie_delete_evtbd_ring(mlan_adapter *pmadapter)
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)
@@ -1258,7 +1478,6 @@ static mlan_status wlan_pcie_delete_evtbd_ring(mlan_adapter *pmadapter)
 				padma_bd_buf->reserved = 0;
 			}
 		}
-#endif
 		pmadapter->pcard_pcie->evtbd_ring[i] = MNULL;
 	}
 
@@ -1441,7 +1660,6 @@ static t_u8 wlan_check_tx_pending_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 			return MFALSE;
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		if ((pmadapter->pcard_pcie->txbd_rdptr &
 		     ADMA_RW_PTR_WRAP_MASK) != (rdptr & ADMA_RW_PTR_WRAP_MASK))
@@ -1449,7 +1667,6 @@ static t_u8 wlan_check_tx_pending_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 		else
 			return MFALSE;
 	}
-#endif
 	return MFALSE;
 }
 
@@ -1462,7 +1679,7 @@ static t_u8 wlan_check_tx_pending_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
  */
 static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 {
-	const t_u32 num_tx_buffs = MLAN_MAX_TXRX_BD;
+	const t_u32 num_tx_buffs = pmadapter->pcard_pcie->txrx_bd_size;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 	mlan_buffer *pmbuf;
@@ -1475,10 +1692,8 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 		pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
 	mlan_pcie_data_buf *ptx_bd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
 	t_u32 wrptr;
-#endif
 
 	ENTER();
 
@@ -1499,7 +1714,6 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 		rdptr = rdptr >> TXBD_RW_PTR_START;
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		wrptr = rdptr & 0xffff;
 		rdptr = rdptr >> ADMA_RPTR_START;
@@ -1507,7 +1721,6 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 			PRINTM(MERROR, "wlan: Unexpected wrptr 0x%x 0x%x\n",
 			       wrptr, pmadapter->pcard_pcie->txbd_wrptr);
 	}
-#endif
 
 	/* free from previous txbd_rdptr to current txbd_rdptr */
 	while (wlan_check_tx_pending_buffer(pmadapter, rdptr)) {
@@ -1559,7 +1772,6 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 					 txrx_rw_ptr_rollover_ind);
 		}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)pmadapter->pcard_pcie
@@ -1573,7 +1785,6 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 			pmadapter->pcard_pcie->txbd_rdptr &=
 				ADMA_RW_PTR_WRAP_MASK;
 		}
-#endif
 	}
 
 	if (unmap_count)
@@ -1599,20 +1810,19 @@ static mlan_status wlan_pcie_send_data_complete(mlan_adapter *pmadapter)
 	 ((wrptr & rollover_ind) == (rdptr & rollover_ind)))
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
-#define ADMA_TXBD_IS_FULL(wrptr, rdptr)                                        \
-	(((wrptr & TXRX_RW_PTR_MASK) == (rdptr & TXRX_RW_PTR_MASK)) &&         \
-	 ((wrptr & TXRX_RW_PTR_ROLLOVER_IND) !=                                \
-	  (rdptr & TXRX_RW_PTR_ROLLOVER_IND)))
-#endif
+#define ADMA_TXBD_IS_FULL(wrptr, rdptr, mask, rollover_ind)                    \
+	(((wrptr & mask) == (rdptr & mask)) &&                                 \
+	 ((wrptr & rollover_ind) != (rdptr & rollover_ind)))
 
 static t_u8 wlan_check_txbd_not_full(mlan_adapter *pmadapter)
 {
+	t_u32 txrx_rw_ptr_mask;
+	t_u32 txrx_rw_ptr_rollover_ind;
 #if defined(PCIE8997) || defined(PCIE8897)
-	t_u32 txrx_rw_ptr_mask = pmadapter->pcard_pcie->reg->txrx_rw_ptr_mask;
-	t_u32 txrx_rw_ptr_rollover_ind =
-		pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
 	if (!pmadapter->pcard_pcie->reg->use_adma) {
+		txrx_rw_ptr_mask = pmadapter->pcard_pcie->reg->txrx_rw_ptr_mask;
+		txrx_rw_ptr_rollover_ind =
+			pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
 		if (PCIE_TXBD_NOT_FULL(pmadapter->pcard_pcie->txbd_wrptr,
 				       pmadapter->pcard_pcie->txbd_rdptr,
 				       txrx_rw_ptr_mask,
@@ -1622,15 +1832,17 @@ static t_u8 wlan_check_txbd_not_full(mlan_adapter *pmadapter)
 			return MFALSE;
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
+		txrx_rw_ptr_mask = pmadapter->pcard_pcie->txrx_bd_size - 1;
+		txrx_rw_ptr_rollover_ind = pmadapter->pcard_pcie->txrx_bd_size;
 		if (!ADMA_TXBD_IS_FULL(pmadapter->pcard_pcie->txbd_wrptr,
-				       pmadapter->pcard_pcie->txbd_rdptr))
+				       pmadapter->pcard_pcie->txbd_rdptr,
+				       txrx_rw_ptr_mask,
+				       txrx_rw_ptr_rollover_ind))
 			return MTRUE;
 		else
 			return MFALSE;
 	}
-#endif
 	return MFALSE;
 }
 
@@ -1656,10 +1868,8 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 		pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
 	mlan_pcie_data_buf *ptx_bd_buf = MNULL;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf = MNULL;
-#endif
-	const t_u32 num_tx_buffs = MLAN_MAX_TXRX_BD;
+	const t_u32 num_tx_buffs = pmadapter->pcard_pcie->txrx_bd_size;
 	mlan_status ret = MLAN_STATUS_PENDING;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 	t_u32 rxbd_val = 0;
@@ -1670,7 +1880,7 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 
 	ENTER();
 
-	if (!(pmadapter && pmbuf)) {
+	if (!pmbuf) {
 		PRINTM(MERROR, "%s() has no buffer", __FUNCTION__);
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
@@ -1716,10 +1926,13 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 			wr_ptr_start = TXBD_RW_PTR_START;
 			ptx_bd_buf = (mlan_pcie_data_buf *)pmadapter->pcard_pcie
 					     ->txbd_ring[wrindx];
-			ptx_bd_buf->paddr = pmbuf->buf_pa;
-			ptx_bd_buf->len = (t_u16)pmbuf->data_len;
-			ptx_bd_buf->flags = MLAN_BD_FLAG_SOP | MLAN_BD_FLAG_EOP;
-			ptx_bd_buf->frag_len = (t_u16)pmbuf->data_len;
+			ptx_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			ptx_bd_buf->len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
+			ptx_bd_buf->flags = wlan_cpu_to_le16(MLAN_BD_FLAG_SOP |
+							     MLAN_BD_FLAG_EOP);
+			ptx_bd_buf->frag_len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
 			ptx_bd_buf->offset = 0;
 			pmadapter->pcard_pcie->last_tx_pkt_size[wrindx] =
 				pmbuf->data_len;
@@ -1736,27 +1949,29 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			wr_ptr_start = ADMA_WPTR_START;
 			padma_bd_buf = (adma_dual_desc_buf *)pmadapter
 					       ->pcard_pcie->txbd_ring[wrindx];
-			padma_bd_buf->paddr = pmbuf->buf_pa;
-			padma_bd_buf->len =
-				ALIGN_SZ(pmbuf->data_len, ADMA_ALIGN_SIZE);
-			padma_bd_buf->flags =
+			padma_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			padma_bd_buf->len = ALIGN_SZ(
+				pmbuf->data_len,
+				pmadapter->pcard_pcie->reg->adma_align_size);
+			padma_bd_buf->flags = wlan_cpu_to_le16(
 				ADMA_BD_FLAG_SOP | ADMA_BD_FLAG_EOP |
-				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_SRC_HOST;
-			if (padma_bd_buf->len < ADMA_MIN_PKT_SIZE)
-				padma_bd_buf->len = ADMA_MIN_PKT_SIZE;
-			padma_bd_buf->pkt_size = pmbuf->data_len;
+				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_SRC_HOST);
+			if (padma_bd_buf->len <
+			    pmadapter->pcard_pcie->reg->adma_min_pkt_size)
+				padma_bd_buf->len = pmadapter->pcard_pcie->reg
+							    ->adma_min_pkt_size;
+			padma_bd_buf->len = wlan_cpu_to_le16(padma_bd_buf->len);
+			padma_bd_buf->pkt_size = padma_bd_buf->len;
 			pmadapter->pcard_pcie->last_tx_pkt_size[wrindx] =
 				pmbuf->data_len;
 			pmadapter->pcard_pcie->txbd_wrptr++;
 			pmadapter->pcard_pcie->txbd_wrptr &=
 				ADMA_RW_PTR_WRAP_MASK;
 		}
-#endif
 		pmadapter->pcard_pcie->txbd_pending++;
 		PRINTM(MINFO, "REG_TXBD_WRPT(0x%x) = 0x%x\n", reg_txbd_wrptr,
 		       ((pmadapter->pcard_pcie->txbd_wrptr << wr_ptr_start) |
@@ -1777,6 +1992,10 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 
 		if (wlan_check_txbd_not_full(pmadapter))
 			pmadapter->data_sent = MFALSE;
+		else
+			wlan_pcie_send_data_complete(pmadapter);
+		if (pmadapter->data_sent)
+			pmadapter->data_sent_cnt++;
 
 		PRINTM(MINFO, "Sent packet to firmware successfully\n");
 	} else {
@@ -1823,7 +2042,6 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 		ptx_bd_buf->offset = 0;
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma && padma_bd_buf) {
 		padma_bd_buf->paddr = 0;
 		padma_bd_buf->len = 0;
@@ -1831,7 +2049,6 @@ static mlan_status wlan_pcie_send_data(mlan_adapter *pmadapter, t_u8 type,
 		padma_bd_buf->pkt_size = 0;
 		padma_bd_buf->reserved = 0;
 	}
-#endif
 done:
 	LEAVE();
 	return ret;
@@ -1863,7 +2080,6 @@ static t_u8 wlan_check_rx_pending_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		if ((pmadapter->pcard_pcie->rxbd_rdptr &
 		     ADMA_RW_PTR_WRAP_MASK) != (rdptr & ADMA_RW_PTR_WRAP_MASK))
@@ -1871,7 +2087,54 @@ static t_u8 wlan_check_rx_pending_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 		else
 			return MFALSE;
 	}
+	return MFALSE;
+}
+
+/**
+ *  @brief This function check if the rx pending buffer is full
+ *
+ *  @param pmadapter  A pointer to mlan_adapter structure
+ *  @param rdptr           rx rdptr
+ *  @param rxbd_rdptr      rxbd_rdptr
+ *
+ *  @return           MTRUE/MFALSE;
+ */
+static t_u8 wlan_is_rx_pending_full(mlan_adapter *pmadapter, t_u32 rdptr)
+{
+#if defined(PCIE8997) || defined(PCIE8897)
+	t_u32 txrx_rw_ptr_mask = pmadapter->pcard_pcie->reg->txrx_rw_ptr_mask;
+	t_u32 txrx_rw_ptr_rollover_ind =
+		pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
+	if (!pmadapter->pcard_pcie->reg->use_adma) {
+		PRINTM(MDATA,
+		       "local wrptr: 0x%x(0x%x) -> reg rdptr: 0x%x(0x%x)\n",
+		       (pmadapter->pcard_pcie->rxbd_wrptr & txrx_rw_ptr_mask),
+		       (pmadapter->pcard_pcie->rxbd_wrptr &
+			txrx_rw_ptr_rollover_ind),
+		       (rdptr & txrx_rw_ptr_mask),
+		       (rdptr & txrx_rw_ptr_rollover_ind));
+		if (((rdptr & txrx_rw_ptr_mask) ==
+		     (pmadapter->pcard_pcie->rxbd_wrptr & txrx_rw_ptr_mask)) &&
+		    ((rdptr & txrx_rw_ptr_rollover_ind) ==
+		     (pmadapter->pcard_pcie->rxbd_wrptr &
+		      txrx_rw_ptr_rollover_ind)))
+			return MTRUE;
+		else
+			return MFALSE;
+	}
 #endif
+
+	if (pmadapter->pcard_pcie->reg->use_adma) {
+		PRINTM(MDATA, "local wrptr: 0x%x -> reg rdptr: 0x%x\n",
+		       (pmadapter->pcard_pcie->rxbd_wrptr &
+			ADMA_RW_PTR_WRAP_MASK),
+		       (rdptr & ADMA_RW_PTR_WRAP_MASK));
+		if ((rdptr & ADMA_RW_PTR_WRAP_MASK) ==
+		    (pmadapter->pcard_pcie->rxbd_wrptr & ADMA_RW_PTR_WRAP_MASK))
+			return MTRUE;
+		else
+			return MFALSE;
+	}
 	return MFALSE;
 }
 
@@ -1891,7 +2154,7 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 	mlan_buffer *pmbuf = MNULL;
 	t_u32 txbd_val = 0;
 	t_u16 rx_len, rx_type;
-	const t_u32 num_rx_buffs = MLAN_MAX_TXRX_BD;
+	const t_u32 num_rx_buffs = pmadapter->pcard_pcie->txrx_bd_size;
 	t_u32 reg_rxbd_rdptr = pmadapter->pcard_pcie->reg->reg_rxbd_rdptr;
 #if defined(PCIE8997) || defined(PCIE8897)
 	t_u32 txrx_rw_ptr_mask = pmadapter->pcard_pcie->reg->txrx_rw_ptr_mask;
@@ -1899,9 +2162,8 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 		pmadapter->pcard_pcie->reg->txrx_rw_ptr_rollover_ind;
 	mlan_pcie_data_buf *prxbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
+	t_u32 in_ts_sec, in_ts_usec;
 
 	ENTER();
 
@@ -1912,22 +2174,26 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma)
 		rdptr = rdptr >> ADMA_RPTR_START;
-#endif
 
+	if (pmadapter->tp_state_on &&
+	    wlan_is_rx_pending_full(pmadapter, rdptr)) {
+		PRINTM(MDATA, "RX FULL!\n");
+		pmadapter->callbacks.moal_tp_accounting_rx_param(
+			pmadapter->pmoal_handle, 6, 0);
+	}
 	while (wlan_check_rx_pending_buffer(pmadapter, rdptr)) {
 		/* detach pmbuf (with data) from Rx Ring */
 		rd_index =
 			pmadapter->pcard_pcie->rxbd_rdptr & (num_rx_buffs - 1);
-		if (rd_index > MLAN_MAX_TXRX_BD - 1) {
+		if (rd_index >
+		    (t_u32)(pmadapter->pcard_pcie->txrx_bd_size - 1)) {
 			PRINTM(MERROR, "RECV DATA: Invalid Rx buffer index.\n");
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
 		pmbuf = pmadapter->pcard_pcie->rx_buf_list[rd_index];
-
 		if (MLAN_STATUS_FAILURE ==
 		    pcb->moal_unmap_memory(pmadapter->pmoal_handle,
 					   pmbuf->pbuf + pmbuf->data_offset,
@@ -1959,21 +2225,45 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 			/* send buffer to host (which will free it) */
 			pmbuf->data_len = rx_len - PCIE_INTF_HEADER_LEN;
 			pmbuf->data_offset += PCIE_INTF_HEADER_LEN;
-			PRINTM(MINFO,
-			       "RECV DATA: Received packet from FW successfully\n");
-			pmadapter->callbacks.moal_spin_lock(
-				pmadapter->pmoal_handle,
-				pmadapter->rx_data_queue.plock);
-			util_enqueue_list_tail(pmadapter->pmoal_handle,
-					       &pmadapter->rx_data_queue,
-					       (pmlan_linked_list)pmbuf, MNULL,
-					       MNULL);
-			pmadapter->rx_pkts_queued++;
-			pmadapter->callbacks.moal_spin_unlock(
-				pmadapter->pmoal_handle,
-				pmadapter->rx_data_queue.plock);
+			// rx_trace 5
+			if (pmadapter->tp_state_on) {
+				pmadapter->callbacks.moal_tp_accounting(
+					pmadapter->pmoal_handle, pmbuf,
+					5 /*RX_DROP_P1*/);
+				pcb->moal_get_system_time(
+					pmadapter->pmoal_handle, &in_ts_sec,
+					&in_ts_usec);
+				pmbuf->in_ts_sec = in_ts_sec;
+				pmbuf->in_ts_usec = in_ts_usec;
+			}
+			if (pmadapter->tp_state_drop_point ==
+			    5 /*RX_DROP_P1*/) {
+				pmadapter->ops.data_complete(pmadapter, pmbuf,
+							     ret);
+			} else {
+				PRINTM(MINFO,
+				       "RECV DATA: Received packet from FW successfully\n");
+				pmadapter->callbacks.moal_spin_lock(
+					pmadapter->pmoal_handle,
+					pmadapter->rx_data_queue.plock);
+				util_enqueue_list_tail(
+					pmadapter->pmoal_handle,
+					&pmadapter->rx_data_queue,
+					(pmlan_linked_list)pmbuf, MNULL, MNULL);
+				pmadapter->rx_pkts_queued++;
+				if (pmadapter->tp_state_on)
+					pmadapter->callbacks
+						.moal_tp_accounting_rx_param(
+							pmadapter->pmoal_handle,
+							1,
+							pmadapter
+								->rx_pkts_queued);
+				pmadapter->callbacks.moal_spin_unlock(
+					pmadapter->pmoal_handle,
+					pmadapter->rx_data_queue.plock);
 
-			pmadapter->data_received = MTRUE;
+				pmadapter->data_received = MTRUE;
+			}
 			/* Create new buffer and attach it to Rx Ring */
 			pmbuf = wlan_alloc_mlan_buffer(pmadapter,
 						       MLAN_RX_DATA_BUF_SIZE,
@@ -2009,15 +2299,19 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 		if (!pmadapter->pcard_pcie->reg->use_adma) {
 			prxbd_buf = (mlan_pcie_data_buf *)pmadapter->pcard_pcie
 					    ->rxbd_ring[rd_index];
-			prxbd_buf->paddr = pmbuf->buf_pa;
-			prxbd_buf->len = (t_u16)pmbuf->data_len;
-			prxbd_buf->flags = MLAN_BD_FLAG_SOP | MLAN_BD_FLAG_EOP;
+			prxbd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			prxbd_buf->len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
+			prxbd_buf->flags = wlan_cpu_to_le16(MLAN_BD_FLAG_SOP |
+							    MLAN_BD_FLAG_EOP);
 			prxbd_buf->offset = 0;
-			prxbd_buf->frag_len = (t_u16)pmbuf->data_len;
+			prxbd_buf->frag_len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
 
 			/* update rxbd's rdptrs */
 			if ((++pmadapter->pcard_pcie->rxbd_rdptr &
-			     txrx_rw_ptr_mask) == MLAN_MAX_TXRX_BD) {
+			     txrx_rw_ptr_mask) ==
+			    pmadapter->pcard_pcie->txrx_bd_size) {
 				pmadapter->pcard_pcie->rxbd_rdptr =
 					((pmadapter->pcard_pcie->rxbd_rdptr &
 					  txrx_rw_ptr_rollover_ind) ^
@@ -2026,7 +2320,8 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 
 			/* update rxbd's wrptrs */
 			if ((++pmadapter->pcard_pcie->rxbd_wrptr &
-			     txrx_rw_ptr_mask) == MLAN_MAX_TXRX_BD) {
+			     txrx_rw_ptr_mask) ==
+			    pmadapter->pcard_pcie->txrx_bd_size) {
 				pmadapter->pcard_pcie->rxbd_wrptr =
 					((pmadapter->pcard_pcie->rxbd_wrptr &
 					  txrx_rw_ptr_rollover_ind) ^
@@ -2038,16 +2333,16 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 			txbd_val = txbd_val << TXBD_RW_PTR_START;
 		}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)pmadapter->pcard_pcie
 					->rxbd_ring[rd_index];
-			padma_bd_buf->paddr = pmbuf->buf_pa;
-			padma_bd_buf->len =
-				ALIGN_SZ(pmbuf->data_len, ADMA_ALIGN_SIZE);
-			padma_bd_buf->flags =
-				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST;
+			padma_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			padma_bd_buf->len = wlan_cpu_to_le16(ALIGN_SZ(
+				pmbuf->data_len,
+				pmadapter->pcard_pcie->reg->adma_align_size));
+			padma_bd_buf->flags = wlan_cpu_to_le16(
+				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST);
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 			pmadapter->pcard_pcie->rxbd_rdptr++;
@@ -2057,7 +2352,6 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 			pmadapter->pcard_pcie->rxbd_wrptr &=
 				ADMA_RW_PTR_WRAP_MASK;
 		}
-#endif
 		PRINTM(MINFO, "RECV DATA: Updated <Wr: %#x, Rd: %#x>\n",
 		       pmadapter->pcard_pcie->rxbd_wrptr, rdptr);
 
@@ -2080,10 +2374,8 @@ static mlan_status wlan_pcie_process_recv_data(mlan_adapter *pmadapter)
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma)
 			rdptr = rdptr >> ADMA_RPTR_START;
-#endif
 	}
 
 done:
@@ -2226,7 +2518,6 @@ static mlan_status wlan_pcie_send_cmd(mlan_adapter *pmadapter,
 		}
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		/* To send a command, the driver will:
 		   1. driver prepare the cmdrep buffer for adma
@@ -2244,7 +2535,6 @@ static mlan_status wlan_pcie_send_cmd(mlan_adapter *pmadapter,
 			       pmadapter->pcard_pcie->cmd_buf->data_len,
 			       MFALSE);
 	}
-#endif
 done:
 	if ((ret == MLAN_STATUS_FAILURE) && pmadapter)
 		pmadapter->cmd_sent = MFALSE;
@@ -2278,7 +2568,7 @@ static void mlan_delay_for_sleep_cookie(mlan_adapter *pmadapter,
 	}
 
 	if (count >= max_delay_loop_cnt)
-		PRINTM(MERROR, "sleep cookie not found!!\n");
+		PRINTM(MINFO, "sleep cookie not found!!\n");
 }
 #endif
 
@@ -2313,7 +2603,14 @@ static mlan_status wlan_pcie_process_cmd_resp(mlan_adapter *pmadapter)
 
 	pmadapter->upld_len = wlan_le16_to_cpu(resp_len);
 	pmadapter->upld_len -= PCIE_INTF_HEADER_LEN;
-
+	cmd_buf = pmadapter->pcard_pcie->cmd_buf;
+	if (cmd_buf) {
+		pcb->moal_unmap_memory(pmadapter->pmoal_handle,
+				       cmd_buf->pbuf + cmd_buf->data_offset,
+				       cmd_buf->buf_pa, WLAN_UPLD_SIZE,
+				       PCI_DMA_TODEVICE);
+		pmadapter->pcard_pcie->cmd_buf = MNULL;
+	}
 	if (!pmadapter->curr_cmd) {
 		if (pmadapter->ps_state == PS_STATE_SLEEP_CFM) {
 			wlan_process_sleep_confirm_resp(
@@ -2349,15 +2646,6 @@ static mlan_status wlan_pcie_process_cmd_resp(mlan_adapter *pmadapter)
 			mlan_delay_for_sleep_cookie(pmadapter,
 						    MAX_DELAY_LOOP_COUNT);
 #endif
-			cmd_buf = pmadapter->pcard_pcie->cmd_buf;
-			if (cmd_buf) {
-				pcb->moal_unmap_memory(
-					pmadapter->pmoal_handle,
-					cmd_buf->pbuf + cmd_buf->data_offset,
-					cmd_buf->buf_pa, WLAN_UPLD_SIZE,
-					PCI_DMA_TODEVICE);
-				pmadapter->pcard_pcie->cmd_buf = MNULL;
-			}
 		}
 		memcpy_ext(pmadapter, pmadapter->upld_buf,
 			   pmbuf->pbuf + pmbuf->data_offset +
@@ -2396,7 +2684,6 @@ static mlan_status wlan_pcie_process_cmd_resp(mlan_adapter *pmadapter)
 			}
 		}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			/* Clear the cmd-rsp buffer address in adma registers.
 			   This will prevent firmware from writing to the same
@@ -2409,7 +2696,6 @@ static mlan_status wlan_pcie_process_cmd_resp(mlan_adapter *pmadapter)
 				goto done;
 			}
 		}
-#endif
 	}
 
 done:
@@ -2425,12 +2711,10 @@ static mlan_status wlan_pcie_process_cmd_resp(mlan_adapter *pmadapter)
  *
  *  @return 	        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pcie_cmdrsp_complete(mlan_adapter *pmadapter,
-				      mlan_buffer *pmbuf, mlan_status status)
+static mlan_status wlan_pcie_cmdrsp_complete(mlan_adapter *pmadapter,
+					     mlan_buffer *pmbuf,
+					     mlan_status status)
 {
-	mlan_buffer *pcmdmbuf;
-	pmlan_callbacks pcb = &pmadapter->callbacks;
-
 	ENTER();
 
 	/*return the cmd response pmbuf*/
@@ -2440,18 +2724,6 @@ mlan_status wlan_pcie_cmdrsp_complete(mlan_adapter *pmadapter,
 		pmadapter->pcard_pcie->cmdrsp_buf = pmbuf;
 	}
 
-	/*unmap the cmd pmbuf, so the cpu can not access the memory in the
-	 * command node*/
-	pcmdmbuf = pmadapter->pcard_pcie->cmd_buf;
-
-	if (pcmdmbuf) {
-		pcb->moal_unmap_memory(pmadapter->pmoal_handle,
-				       pcmdmbuf->pbuf + pcmdmbuf->data_offset,
-				       pcmdmbuf->buf_pa, WLAN_UPLD_SIZE,
-				       PCI_DMA_TODEVICE);
-		pmadapter->pcard_pcie->cmd_buf = MNULL;
-	}
-
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
@@ -2478,7 +2750,6 @@ static t_u8 wlan_check_evt_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 			return MFALSE;
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		if ((pmadapter->pcard_pcie->evtbd_rdptr &
 		     ADMA_RW_PTR_WRAP_MASK) != (rdptr & ADMA_RW_PTR_WRAP_MASK))
@@ -2486,7 +2757,6 @@ static t_u8 wlan_check_evt_buffer(mlan_adapter *pmadapter, t_u32 rdptr)
 		else
 			return MFALSE;
 	}
-#endif
 	return MFALSE;
 }
 
@@ -2506,9 +2776,7 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_evt_buf *pevtbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 	ENTER();
 
 	if (pmadapter->event_received) {
@@ -2532,10 +2800,8 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma)
 		rdptr = rdptr >> ADMA_RPTR_START;
-#endif
 	PRINTM(MINFO, "EvtRdy: Initial <Wr: 0x%x, Rd: 0x%x>\n",
 	       pmadapter->pcard_pcie->evtbd_wrptr, rdptr);
 	if (wlan_check_evt_buffer(pmadapter, rdptr)) {
@@ -2563,7 +2829,6 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf =
 				(adma_dual_desc_buf *)pmadapter->pcard_pcie
@@ -2574,7 +2839,6 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 		}
-#endif
 		pmadapter->pcard_pcie->evt_buf_list[rd_index] = MNULL;
 
 		event = *((t_u32 *)&pmbuf_evt->pbuf[pmbuf_evt->data_offset +
@@ -2612,11 +2876,9 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma)
 			pmadapter->pcard_pcie->evtbd_rdptr &=
 				ADMA_RW_PTR_WRAP_MASK;
-#endif
 
 		/* Do not update the event write pointer here, wait till the
 		   buffer is released. This is just to make things simpler,
@@ -2645,8 +2907,9 @@ static mlan_status wlan_pcie_process_event_ready(mlan_adapter *pmadapter)
  *
  *  @return 	        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
-				     mlan_buffer *pmbuf, mlan_status status)
+static mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
+					    mlan_buffer *pmbuf,
+					    mlan_status status)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -2656,9 +2919,7 @@ mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
 #if defined(PCIE8997) || defined(PCIE8897)
 	mlan_pcie_evt_buf *pevtbd_buf;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	adma_dual_desc_buf *padma_bd_buf;
-#endif
 
 	ENTER();
 	if (!pmbuf) {
@@ -2680,10 +2941,8 @@ mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma)
 		rdptr = rdptr >> ADMA_RPTR_START;
-#endif
 
 	if (!pmadapter->pcard_pcie->evt_buf_list[wrptr]) {
 		pmbuf->data_len = MAX_EVENT_SIZE;
@@ -2704,26 +2963,26 @@ mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
 		if (!pmadapter->pcard_pcie->reg->use_adma) {
 			pevtbd_buf = (mlan_pcie_evt_buf *)pmadapter->pcard_pcie
 					     ->evtbd_ring[wrptr];
-			pevtbd_buf->paddr = pmbuf->buf_pa;
-			pevtbd_buf->len = (t_u16)pmbuf->data_len;
+			pevtbd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			pevtbd_buf->len =
+				wlan_cpu_to_le16((t_u16)pmbuf->data_len);
 			pevtbd_buf->flags = 0;
 		}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->use_adma) {
 			padma_bd_buf = (adma_dual_desc_buf *)pmadapter
 					       ->pcard_pcie->evtbd_ring[wrptr];
-			padma_bd_buf->paddr = pmbuf->buf_pa;
-			padma_bd_buf->len =
-				ALIGN_SZ(pmbuf->data_len, ADMA_ALIGN_SIZE);
+			padma_bd_buf->paddr = wlan_cpu_to_le64(pmbuf->buf_pa);
+			padma_bd_buf->len = wlan_cpu_to_le16(ALIGN_SZ(
+				pmbuf->data_len,
+				pmadapter->pcard_pcie->reg->adma_align_size));
 			padma_bd_buf->flags = 0;
-			padma_bd_buf->flags =
-				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST;
+			padma_bd_buf->flags = wlan_cpu_to_le16(
+				ADMA_BD_FLAG_INT_EN | ADMA_BD_FLAG_DST_HOST);
 			padma_bd_buf->pkt_size = 0;
 			padma_bd_buf->reserved = 0;
 		}
-#endif
 		pmbuf = MNULL;
 	} else {
 		PRINTM(MINFO,
@@ -2746,10 +3005,8 @@ mlan_status wlan_pcie_event_complete(mlan_adapter *pmadapter,
 		}
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma)
 		pmadapter->pcard_pcie->evtbd_wrptr &= ADMA_RW_PTR_WRAP_MASK;
-#endif
 	PRINTM(MINFO, "EvtCom: Updated <Wr: 0x%x, Rd: 0x%x>\n",
 	       pmadapter->pcard_pcie->evtbd_wrptr, rdptr);
 
@@ -2922,7 +3179,7 @@ static mlan_status wlan_pcie_prog_fw_w_helper(mlan_adapter *pmadapter,
 	t_u32 firmware_len = fw->fw_len;
 	t_u32 offset = 0;
 	mlan_buffer *pmbuf = MNULL;
-	t_u32 txlen, tx_blocks = 0, tries, len;
+	t_u32 txlen, tries, len;
 	t_u32 block_retry_cnt = 0;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 #if defined(PCIE9098)
@@ -2979,6 +3236,10 @@ static mlan_status wlan_pcie_prog_fw_w_helper(mlan_adapter *pmadapter,
 	if (IS_PCIE9097(pmadapter->card_type))
 		check_fw_status = MTRUE;
 #endif
+#if defined(PCIEIW62X)
+	if (IS_PCIEIW62X(pmadapter->card_type))
+		check_fw_status = MTRUE;
+#endif
 
 	/* Perform firmware data transfer */
 	do {
@@ -3081,9 +3342,6 @@ static mlan_status wlan_pcie_prog_fw_w_helper(mlan_adapter *pmadapter,
 
 			PRINTM(MINFO, ".");
 
-			tx_blocks = (txlen + MLAN_PCIE_BLOCK_SIZE_FW_DNLD - 1) /
-				    MLAN_PCIE_BLOCK_SIZE_FW_DNLD;
-
 			/* Copy payload to buffer */
 			memmove(pmadapter, pmbuf->pbuf + pmbuf->data_offset,
 				&firmware[offset], txlen);
@@ -3180,26 +3438,39 @@ mlan_status wlan_get_pcie_device(pmlan_adapter pmadapter)
 	case CARD_TYPE_PCIE8897:
 		pmadapter->pcard_pcie->reg = &mlan_reg_pcie8897;
 		pmadapter->pcard_info = &mlan_card_info_pcie8897;
+		pmadapter->pcard_pcie->txrx_bd_size = MAX_TXRX_BD;
 		break;
 #endif
 #ifdef PCIE8997
 	case CARD_TYPE_PCIE8997:
 		pmadapter->pcard_pcie->reg = &mlan_reg_pcie8997;
 		pmadapter->pcard_info = &mlan_card_info_pcie8997;
+		pmadapter->pcard_pcie->txrx_bd_size = MAX_TXRX_BD;
 		break;
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
+#if defined(PCIE9098) || defined(PCIE9097) || defined(PCIEIW62X)
 	case CARD_TYPE_PCIE9097:
 	case CARD_TYPE_PCIE9098:
+	case CARD_TYPE_PCIEIW62X:
 		pmadapter->pcard_pcie->reg = &mlan_reg_pcie9098;
 		pmadapter->pcard_info = &mlan_card_info_pcie9098;
-#ifdef PCIE9097
-		if (card_type == CARD_TYPE_PCIE9097 &&
-		    pmadapter->card_rev == CHIP_9097_REV_B0)
+		pmadapter->pcard_pcie->txrx_bd_size = ADMA_DEF_TXRX_BD;
+		pmadapter->pcard_pcie->txrx_num_desc = TXRX_DEF_NUM_DESC;
+#if defined(PCIE9097) || defined(PCIEIW62X)
+		if ((card_type == CARD_TYPE_PCIE9097 &&
+		     pmadapter->card_rev == CHIP_9097_REV_B0) ||
+		    (card_type == CARD_TYPE_PCIEIW62X))
 			pmadapter->pcard_pcie->reg = &mlan_reg_pcie9097_b0;
 #endif
+
 		break;
 #endif
+	case CARD_TYPE_PCIEAW693:
+		pmadapter->pcard_pcie->reg = &mlan_reg_pcieaw693;
+		pmadapter->pcard_info = &mlan_card_info_pcie9098;
+		pmadapter->pcard_pcie->txrx_bd_size = ADMA_DEF_TXRX_BD;
+		pmadapter->pcard_pcie->txrx_num_desc = TXRX_DEF_NUM_DESC;
+		break;
 	default:
 		PRINTM(MERROR, "can't get right pcie card type \n");
 		ret = MLAN_STATUS_FAILURE;
@@ -3247,7 +3518,7 @@ mlan_status wlan_pcie_wakeup(mlan_adapter *pmadapter)
  *  @param pmadapter  A pointer to mlan_adapter structure
  *  @return         MLAN_STATUS_FAILURE -- if the intererupt is not for us
  */
-mlan_status wlan_pcie_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
+static mlan_status wlan_pcie_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
 {
 	t_u32 pcie_ireg;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -3283,13 +3554,15 @@ mlan_status wlan_pcie_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
 			    pmoal_handle,
 			    pmadapter->pcard_pcie->reg->reg_host_int_status,
 			    &pcie_ireg)) {
-			PRINTM(MWARN, "Read register failed\n");
+			PRINTM(MERROR, "Read func%d register failed\n",
+			       pmadapter->pcard_pcie->func_num);
 			LEAVE();
 			return MLAN_STATUS_FAILURE;
 		}
 
 		if ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {
-			PRINTM(MINTR, "pcie_ireg=0x%x\n", pcie_ireg);
+			PRINTM(MINTR, "func%d: pcie_ireg=0x%x\n",
+			       pmadapter->pcard_pcie->func_num, pcie_ireg);
 			if (!pmadapter->pps_uapsd_mode &&
 			    (pmadapter->ps_state == PS_STATE_SLEEP)) {
 				/* Potentially for PCIe we could get other
@@ -3363,7 +3636,7 @@ mlan_status wlan_process_msix_int(mlan_adapter *pmadapter)
 			goto done;
 	}
 	if (pcie_ireg & pmadapter->pcard_pcie->reg->host_intr_cmd_done) {
-		if (pmadapter->cmd_sent) {
+		if (pmadapter->cmd_sent && !pmadapter->vdll_ctrl.vdll_len) {
 			PRINTM(MINFO, "<--- CMD sent Interrupt --->\n");
 			pmadapter->cmd_sent = MFALSE;
 		}
@@ -3371,7 +3644,6 @@ mlan_status wlan_process_msix_int(mlan_adapter *pmadapter)
 		if (ret)
 			goto done;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->host_intr_cmd_dnld &&
 	    (pcie_ireg & pmadapter->pcard_pcie->reg->host_intr_cmd_dnld)) {
 		if (pmadapter->cmd_sent)
@@ -3380,7 +3652,6 @@ mlan_status wlan_process_msix_int(mlan_adapter *pmadapter)
 			wlan_pcie_send_vdll_complete(pmadapter);
 		PRINTM(MINFO, "<--- CMD DNLD DONE Interrupt --->\n");
 	}
-#endif
 	PRINTM(MINFO, "cmd_sent=%d data_sent=%d\n", pmadapter->cmd_sent,
 	       pmadapter->data_sent);
 
@@ -3397,7 +3668,7 @@ mlan_status wlan_process_msix_int(mlan_adapter *pmadapter)
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
+static mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 pcie_ireg = 0;
@@ -3419,20 +3690,22 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 			    pmadapter->pmoal_handle,
 			    pmadapter->pcard_pcie->reg->reg_host_int_status,
 			    &pcie_ireg)) {
-			PRINTM(MWARN, "Read register failed\n");
+			PRINTM(MERROR, "Read func%d register failed\n",
+			       pmadapter->pcard_pcie->func_num);
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
 
 		if ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {
-			PRINTM(MINTR, "pcie_ireg=0x%x\n", pcie_ireg);
+			PRINTM(MINTR, "func%d: pcie_ireg=0x%x\n",
+			       pmadapter->pcard_pcie->func_num, pcie_ireg);
 			if (pmadapter->pcard_pcie->reg->msi_int_wr_clr) {
 				if (pcb->moal_write_reg(
 					    pmadapter->pmoal_handle,
 					    pmadapter->pcard_pcie->reg
 						    ->reg_host_int_status,
 					    ~pcie_ireg)) {
-					PRINTM(MWARN,
+					PRINTM(MERROR,
 					       "Write register failed\n");
 					ret = MLAN_STATUS_FAILURE;
 					goto done;
@@ -3454,6 +3727,9 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 			pcie_ireg &=
 				~pmadapter->pcard_pcie->reg->host_intr_dnld_done;
 			PRINTM(MINFO, "<--- DATA sent Interrupt --->\n");
+			pmadapter->callbacks.moal_tp_accounting_rx_param(
+				pmadapter->pmoal_handle, 3, 0);
+
 			ret = wlan_pcie_send_data_complete(pmadapter);
 			if (ret)
 				goto done;
@@ -3463,6 +3739,8 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 			pcie_ireg &=
 				~pmadapter->pcard_pcie->reg->host_intr_upld_rdy;
 			PRINTM(MINFO, "Rx DATA\n");
+			pmadapter->callbacks.moal_tp_accounting_rx_param(
+				pmadapter->pmoal_handle, 0, 0);
 			ret = wlan_pcie_process_recv_data(pmadapter);
 			if (ret)
 				goto done;
@@ -3480,7 +3758,8 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 		    pmadapter->pcard_pcie->reg->host_intr_cmd_done) {
 			pcie_ireg &=
 				~pmadapter->pcard_pcie->reg->host_intr_cmd_done;
-			if (pmadapter->cmd_sent) {
+			if (pmadapter->cmd_sent &&
+			    !pmadapter->vdll_ctrl.vdll_len) {
 				PRINTM(MINFO, "<--- CMD sent Interrupt --->\n");
 				pmadapter->cmd_sent = MFALSE;
 			}
@@ -3488,7 +3767,6 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 			if (ret)
 				goto done;
 		}
-#if defined(PCIE9098) || defined(PCIE9097)
 		if (pmadapter->pcard_pcie->reg->host_intr_cmd_dnld &&
 		    (pcie_ireg &
 		     pmadapter->pcard_pcie->reg->host_intr_cmd_dnld)) {
@@ -3500,7 +3778,6 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 				wlan_pcie_send_vdll_complete(pmadapter);
 			PRINTM(MINFO, "<--- CMD DNLD DONE Interrupt --->\n");
 		}
-#endif
 		if (pmadapter->pcard_pcie->pcie_int_mode == PCIE_INT_MODE_MSI) {
 			pcb->moal_spin_lock(pmadapter->pmoal_handle,
 					    pmadapter->pint_lock);
@@ -3512,13 +3789,15 @@ mlan_status wlan_process_pcie_int_status(mlan_adapter *pmadapter)
 			    pmadapter->pmoal_handle,
 			    pmadapter->pcard_pcie->reg->reg_host_int_status,
 			    &pcie_ireg)) {
-			PRINTM(MWARN, "Read register failed\n");
+			PRINTM(MERROR, "Read func%d register failed\n",
+			       pmadapter->pcard_pcie->func_num);
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
 
 		if ((pcie_ireg != 0xFFFFFFFF) && (pcie_ireg)) {
-			PRINTM(MINTR, "Poll: pcie_ireg=0x%x\n", pcie_ireg);
+			PRINTM(MINTR, "func%d: Poll pcie_ireg=0x%x\n",
+			       pmadapter->pcard_pcie->func_num, pcie_ireg);
 			if ((pmadapter->pcard_pcie->pcie_int_mode ==
 			     PCIE_INT_MODE_LEGACY) ||
 			    pmadapter->pcard_pcie->reg->msi_int_wr_clr) {
@@ -3593,7 +3872,8 @@ mlan_status wlan_set_drv_ready_reg(mlan_adapter *pmadapter, t_u32 val)
  *  @return           MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  *
  */
-mlan_status wlan_pcie_check_winner_status(mlan_adapter *pmadapter, t_u32 *val)
+static mlan_status wlan_pcie_check_winner_status(mlan_adapter *pmadapter,
+						 t_u32 *val)
 {
 	t_u32 winner = 0;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -3622,7 +3902,8 @@ mlan_status wlan_pcie_check_winner_status(mlan_adapter *pmadapter, t_u32 *val)
  *
  *  @return           MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pcie_check_fw_status(mlan_adapter *pmadapter, t_u32 pollnum)
+static mlan_status wlan_pcie_check_fw_status(mlan_adapter *pmadapter,
+					     t_u32 pollnum)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -3645,7 +3926,7 @@ mlan_status wlan_pcie_check_fw_status(mlan_adapter *pmadapter, t_u32 pollnum)
 			ret = MLAN_STATUS_SUCCESS;
 			break;
 		} else {
-			wlan_mdelay(pmadapter, 100);
+			wlan_mdelay(pmadapter, 10);
 			ret = MLAN_STATUS_FAILURE;
 		}
 	}
@@ -3683,7 +3964,8 @@ mlan_status wlan_pcie_init(mlan_adapter *pmadapter)
  *
  *  @return		MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pcie_dnld_fw(pmlan_adapter pmadapter, pmlan_fw_image pmfw)
+static mlan_status wlan_pcie_dnld_fw(pmlan_adapter pmadapter,
+				     pmlan_fw_image pmfw)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 poll_num = 1;
@@ -3779,10 +4061,8 @@ mlan_status wlan_pcie_host_to_card(pmlan_private pmpriv, t_u8 type,
 		ret = wlan_pcie_send_data(pmadapter, type, pmbuf, tx_param);
 	else if (type == MLAN_TYPE_CMD)
 		ret = wlan_pcie_send_cmd(pmadapter, pmbuf);
-#if defined(PCIE9098) || defined(PCIE9097)
 	else if (type == MLAN_TYPE_VDLL)
 		ret = wlan_pcie_send_vdll(pmadapter, pmbuf);
-#endif
 	LEAVE();
 	return ret;
 }
@@ -3907,6 +4187,12 @@ mlan_status wlan_alloc_pcie_ring_buf(pmlan_adapter pmadapter)
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
+	if ((pmadapter->card_type == CARD_TYPE_PCIE9098) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEIW62X) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIEAW693) ||
+	    (pmadapter->card_type == CARD_TYPE_PCIE9097)) {
+		wlan_pcie_init_adma_ring_size(pmadapter);
+	}
 	pmadapter->pcard_pcie->cmdrsp_buf = MNULL;
 	ret = wlan_pcie_create_txbd_ring(pmadapter);
 	if (ret)
@@ -3958,7 +4244,9 @@ mlan_status wlan_free_pcie_ring_buf(pmlan_adapter pmadapter)
 	pmadapter->pcard_pcie->cmdrsp_buf = MNULL;
 #ifdef RPTR_MEM_COP
 	if ((pmadapter->card_type == CARD_TYPE_PCIE9098) ||
-	    (pmadapter->card_type == CARD_TYPE_PCIE9097))
+	    (pmadapter->card_type == CARD_TYPE_PCIEAW693) ||
+	    (pmadapter->card_type ==
+	     CARD_TYPE_PCIEIW62X)(pmadapter->card_type == CARD_TYPE_PCIE9097))
 		wlan_pcie_free_rdptrs(pmadapter);
 #endif
 
@@ -4015,21 +4303,24 @@ mlan_status wlan_set_pcie_buf_config(mlan_private *pmpriv)
 		       sizeof(HostCmd_DS_PCIE_HOST_BUF_DETAILS));
 
 		/* Send the ring base addresses and count to firmware */
-		host_spec.txbd_addr_lo =
-			(t_u32)(pmadapter->pcard_pcie->txbd_ring_pbase);
-		host_spec.txbd_addr_hi = (t_u32)(
-			((t_u64)pmadapter->pcard_pcie->txbd_ring_pbase) >> 32);
-		host_spec.txbd_count = MLAN_MAX_TXRX_BD;
-		host_spec.rxbd_addr_lo =
-			(t_u32)(pmadapter->pcard_pcie->rxbd_ring_pbase);
-		host_spec.rxbd_addr_hi = (t_u32)(
-			((t_u64)pmadapter->pcard_pcie->rxbd_ring_pbase) >> 32);
-		host_spec.rxbd_count = MLAN_MAX_TXRX_BD;
-		host_spec.evtbd_addr_lo =
-			(t_u32)(pmadapter->pcard_pcie->evtbd_ring_pbase);
-		host_spec.evtbd_addr_hi = (t_u32)(
-			((t_u64)pmadapter->pcard_pcie->evtbd_ring_pbase) >> 32);
-		host_spec.evtbd_count = MLAN_MAX_EVT_BD;
+		host_spec.txbd_addr_lo = wlan_cpu_to_le32(
+			(t_u32)(pmadapter->pcard_pcie->txbd_ring_pbase));
+		host_spec.txbd_addr_hi = wlan_cpu_to_le32((t_u32)(
+			((t_u64)pmadapter->pcard_pcie->txbd_ring_pbase) >> 32));
+		host_spec.txbd_count =
+			wlan_cpu_to_le32(pmadapter->pcard_pcie->txrx_bd_size);
+		host_spec.rxbd_addr_lo = wlan_cpu_to_le32(
+			(t_u32)(pmadapter->pcard_pcie->rxbd_ring_pbase));
+		host_spec.rxbd_addr_hi = wlan_cpu_to_le32((t_u32)(
+			((t_u64)pmadapter->pcard_pcie->rxbd_ring_pbase) >> 32));
+		host_spec.rxbd_count =
+			wlan_cpu_to_le32(pmadapter->pcard_pcie->txrx_bd_size);
+		host_spec.evtbd_addr_lo = wlan_cpu_to_le32(
+			(t_u32)(pmadapter->pcard_pcie->evtbd_ring_pbase));
+		host_spec.evtbd_addr_hi = wlan_cpu_to_le32((t_u32)(
+			((t_u64)pmadapter->pcard_pcie->evtbd_ring_pbase) >>
+			32));
+		host_spec.evtbd_count = wlan_cpu_to_le32(MLAN_MAX_EVT_BD);
 
 		ret = wlan_prepare_cmd(pmpriv,
 				       HostCmd_CMD_PCIE_HOST_BUF_DETAILS,
@@ -4042,16 +4333,15 @@ mlan_status wlan_set_pcie_buf_config(mlan_private *pmpriv)
 		}
 	}
 #endif
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (pmadapter->pcard_pcie->reg->use_adma) {
 		/** config ADMA for Tx Data */
 		wlan_init_adma(pmadapter, ADMA_TX_DATA,
 			       pmadapter->pcard_pcie->txbd_ring_pbase,
-			       TX_RX_NUM_DESC, MTRUE);
+			       pmadapter->pcard_pcie->txrx_num_desc, MTRUE);
 		/** config ADMA for Rx Data */
 		wlan_init_adma(pmadapter, ADMA_RX_DATA,
 			       pmadapter->pcard_pcie->rxbd_ring_pbase,
-			       TX_RX_NUM_DESC, MTRUE);
+			       pmadapter->pcard_pcie->txrx_num_desc, MTRUE);
 		/** config ADMA for Rx Event */
 		wlan_init_adma(pmadapter, ADMA_EVENT,
 			       pmadapter->pcard_pcie->evtbd_ring_pbase,
@@ -4063,7 +4353,6 @@ mlan_status wlan_set_pcie_buf_config(mlan_private *pmpriv)
 			       pmadapter->pcard_pcie->cmdrsp_buf->buf_pa, 0,
 			       MTRUE);
 	}
-#endif
 	wlan_pcie_init_fw(pmadapter);
 	LEAVE();
 	return ret;
@@ -4112,13 +4401,15 @@ mlan_status wlan_cmd_pcie_host_buf_cfg(pmlan_private pmpriv,
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pm_pcie_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
+static mlan_status wlan_pm_pcie_wakeup_card(pmlan_adapter pmadapter,
+					    t_u8 timeout)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 age_ts_usec;
 
 	ENTER();
-	PRINTM(MEVENT, "Wakeup device...\n");
+	PRINTM(MEVENT, "func%d: Wakeup device...\n",
+	       pmadapter->pcard_pcie->func_num);
 	pmadapter->callbacks.moal_get_system_time(pmadapter->pmoal_handle,
 						  &pmadapter->pm_wakeup_in_secs,
 						  &age_ts_usec);
@@ -4136,7 +4427,7 @@ mlan_status wlan_pm_pcie_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
 	return ret;
 }
 
-mlan_status wlan_pcie_debug_dump(pmlan_adapter pmadapter)
+static mlan_status wlan_pcie_debug_dump(pmlan_adapter pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_buffer pmbuf = pmadapter->pcard_pcie->cmdrsp_buf;
@@ -4162,8 +4453,9 @@ mlan_status wlan_pcie_debug_dump(pmlan_adapter pmadapter)
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return          N/A
  */
-mlan_status wlan_pcie_data_complete(pmlan_adapter pmadapter, mlan_buffer *pmbuf,
-				    mlan_status status)
+static mlan_status wlan_pcie_data_complete(pmlan_adapter pmadapter,
+					   mlan_buffer *pmbuf,
+					   mlan_status status)
 {
 	ENTER();
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h
old mode 100644
new mode 100755
index af404379e..54f1c5cdb
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_pcie.h
@@ -4,7 +4,7 @@
  *  driver.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -135,6 +135,8 @@ Change log:
 
 /** DMA cfg3 register */
 #define ADMA_DMA_CFG3 0x0040
+/** ADMA Queue pointer clear */
+#define ADMA_Q_PTR_CLR MBIT(0)
 /** source rd ptr address low */
 #define ADMA_SRC_RD_PTR_LOW 0x0044
 /** source rd ptr address high */
@@ -152,9 +154,9 @@ Change log:
 /** write pointer start from bit 0 */
 #define ADMA_WPTR_START 0
 /** Tx/Rx Read/Write pointer's mask */
-#define TXRX_RW_PTR_MASK (MLAN_MAX_TXRX_BD - 1)
+#define TXRX_RW_PTR_MASK (ADMA_MAX_TXRX_BD - 1)
 /** Tx/Rx Read/Write pointer's rollover indicate bit */
-#define TXRX_RW_PTR_ROLLOVER_IND MLAN_MAX_TXRX_BD
+#define TXRX_RW_PTR_ROLLOVER_IND ADMA_MAX_TXRX_BD
 /** Start of packet flag */
 #define ADMA_BD_FLAG_SOP MBIT(0)
 /** End of packet flag */
@@ -167,8 +169,12 @@ Change log:
 #define ADMA_BD_FLAG_DST_HOST MBIT(4)
 /** ADMA MIN PKT SIZE */
 #define ADMA_MIN_PKT_SIZE 128
+/** ADMA MIN PKT SIZE 32 */
+#define ADMA_MIN_PKT_SIZE_32 32
 /** ADMA dual descriptor mode requir 8 bytes alignment in buf size */
 #define ADMA_ALIGN_SIZE 8
+/** ADMA dual descriptor mode requir 8 bytes alignment in buf size */
+#define ADMA_ALIGN_SIZE_1 1
 /** ADMA RW_PTR wrap mask */
 #define ADMA_RW_PTR_WRAP_MASK 0x00001FFF
 /** ADMA MSIX DOORBEEL DATA */
@@ -180,7 +186,6 @@ Change log:
 /** PF start bit */
 #define ADMA_MSIX_PF_BIT 24
 
-#if defined(PCIE9098) || defined(PCIE9097)
 /** PCIE9098 dev_id/vendor id reg */
 #define PCIE9098_DEV_ID_REG 0x0000
 /** PCIE revision ID register */
@@ -317,7 +322,6 @@ Change log:
 #define PCIE9098_HOST_INTR_SEL_MASK                                            \
 	(PCIE9098_HOST_INTR_DNLD_DONE | PCIE9098_HOST_INTR_UPLD_RDY |          \
 	 PCIE9098_HOST_INTR_CMD_DONE | PCIE9098_HOST_INTR_EVENT_RDY)
-#endif
 
 #if defined(PCIE8997) || defined(PCIE8897)
 /* PCIE INTERNAL REGISTERS */
@@ -456,159 +460,8 @@ Change log:
 /** Max interrupt status register read limit */
 #define MAX_READ_REG_RETRY 10000
 
-#ifdef PCIE8897
-static const struct _mlan_pcie_card_reg mlan_reg_pcie8897 = {
-	.reg_txbd_rdptr = PCIE8897_RD_DATA_PTR_Q0_Q1,
-	.reg_txbd_wrptr = PCIE8897_WR_DATA_PTR_Q0_Q1,
-	.reg_rxbd_rdptr = PCIE8897_RD_DATA_PTR_Q0_Q1,
-	.reg_rxbd_wrptr = PCIE8897_WR_DATA_PTR_Q0_Q1,
-	.reg_evtbd_rdptr = REG_EVTBD_RDPTR,
-	.reg_evtbd_wrptr = REG_EVTBD_WRPTR,
-	.reg_host_int_mask = PCIE_HOST_INT_MASK,
-	.reg_host_int_status_mask = PCIE_HOST_INT_STATUS_MASK,
-	.reg_host_int_status = PCIE_HOST_INT_STATUS,
-	.reg_cpu_int_event = PCIE_CPU_INT_EVENT,
-	.reg_ip_rev = PCIE_IP_REV_REG,
-	.reg_drv_ready = REG_DRV_READY,
-	.reg_cpu_int_status = PCIE_CPU_INT_STATUS,
-	.reg_scratch_0 = PCIE_SCRATCH_0_REG,
-	.reg_scratch_1 = PCIE_SCRATCH_1_REG,
-	.reg_scratch_2 = PCIE_SCRATCH_2_REG,
-	.reg_scratch_3 = PCIE_SCRATCH_3_REG,
-	.host_intr_mask = HOST_INTR_MASK,
-	.host_intr_dnld_done = HOST_INTR_DNLD_DONE,
-	.host_intr_upld_rdy = HOST_INTR_UPLD_RDY,
-	.host_intr_cmd_done = HOST_INTR_CMD_DONE,
-	.host_intr_event_rdy = HOST_INTR_EVENT_RDY,
-	.txrx_rw_ptr_mask = 0x000003FF,
-	.txrx_rw_ptr_wrap_mask = 0x000007FF,
-	.txrx_rw_ptr_rollover_ind = MBIT(10),
-	.use_adma = MFALSE,
-	.msi_int_wr_clr = MTRUE,
-};
-
-static const struct _mlan_card_info mlan_card_info_pcie8897 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 0,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-
-#ifdef PCIE8997
-static const struct _mlan_pcie_card_reg mlan_reg_pcie8997 = {
-	.reg_txbd_rdptr = PCIE8997_RD_DATA_PTR_Q0_Q1,
-	.reg_txbd_wrptr = PCIE8997_WR_DATA_PTR_Q0_Q1,
-	.reg_rxbd_rdptr = PCIE8997_RD_DATA_PTR_Q0_Q1,
-	.reg_rxbd_wrptr = PCIE8997_WR_DATA_PTR_Q0_Q1,
-	.reg_evtbd_rdptr = REG_EVTBD_RDPTR,
-	.reg_evtbd_wrptr = REG_EVTBD_WRPTR,
-	.reg_host_int_mask = PCIE_HOST_INT_MASK,
-	.reg_host_int_status_mask = PCIE_HOST_INT_STATUS_MASK,
-	.reg_host_int_status = PCIE_HOST_INT_STATUS,
-	.reg_cpu_int_event = PCIE_CPU_INT_EVENT,
-	.reg_ip_rev = PCIE_IP_REV_REG,
-	.reg_drv_ready = REG_DRV_READY,
-	.reg_cpu_int_status = PCIE_CPU_INT_STATUS,
-	.reg_scratch_0 = PCIE_SCRATCH_0_REG,
-	.reg_scratch_1 = PCIE_SCRATCH_1_REG,
-	.reg_scratch_2 = PCIE_SCRATCH_2_REG,
-	.reg_scratch_3 = PCIE_SCRATCH_3_REG,
-	.host_intr_mask = HOST_INTR_MASK,
-	.host_intr_dnld_done = HOST_INTR_DNLD_DONE,
-	.host_intr_upld_rdy = HOST_INTR_UPLD_RDY,
-	.host_intr_cmd_done = HOST_INTR_CMD_DONE,
-	.host_intr_event_rdy = HOST_INTR_EVENT_RDY,
-	.txrx_rw_ptr_mask = 0x00000FFF,
-	.txrx_rw_ptr_wrap_mask = 0x00001FFF,
-	.txrx_rw_ptr_rollover_ind = MBIT(12),
-	.use_adma = MFALSE,
-	.msi_int_wr_clr = MTRUE,
-};
-
-static const struct _mlan_card_info mlan_card_info_pcie8997 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
+extern mlan_adapter_operations mlan_pcie_ops;
 
-#if defined(PCIE9098) || defined(PCIE9097)
-static const struct _mlan_pcie_card_reg mlan_reg_pcie9098 = {
-	.reg_txbd_rdptr = PCIE9098_TXBD_RDPTR,
-	.reg_txbd_wrptr = PCIE9098_TXBD_WRPTR,
-	.reg_rxbd_rdptr = PCIE9098_RXBD_RDPTR,
-	.reg_rxbd_wrptr = PCIE9098_RXBD_WRPTR,
-	.reg_evtbd_rdptr = PCIE9098_EVTBD_RDPTR,
-	.reg_evtbd_wrptr = PCIE9098_EVTBD_WRPTR,
-	.reg_host_int_mask = PCIE9098_HOST_INT_MASK,
-	.reg_host_int_status_mask = PCIE9098_HOST_INT_STATUS_MASK,
-	.reg_host_int_status = PCIE9098_HOST_INT_STATUS,
-	.reg_host_int_clr_sel = PCIE9098_HOST_INT_CLR_SEL,
-	.reg_cpu_int_event = PCIE9098_CPU_INT_EVENT,
-	.reg_ip_rev = PCIE9098_DEV_ID_REG,
-	.reg_drv_ready = PCIE9098_DRV_READY,
-	.reg_cpu_int_status = PCIE9098_CPU_INT_STATUS,
-	.reg_rev_id = PCIE9098_REV_ID_REG,
-	.reg_scratch_0 = PCIE9098_SCRATCH_0_REG,
-	.reg_scratch_1 = PCIE9098_SCRATCH_1_REG,
-	.reg_scratch_2 = PCIE9098_SCRATCH_2_REG,
-	.reg_scratch_3 = PCIE9098_SCRATCH_3_REG,
-	.reg_scratch_6 = PCIE9098_SCRATCH_6_REG,
-	.reg_scratch_7 = PCIE9098_SCRATCH_7_REG,
-	.host_intr_mask = PCIE9098_HOST_INTR_MASK,
-	.host_intr_dnld_done = PCIE9098_HOST_INTR_DNLD_DONE,
-	.host_intr_upld_rdy = PCIE9098_HOST_INTR_UPLD_RDY,
-	.host_intr_cmd_done = PCIE9098_HOST_INTR_CMD_DONE,
-	.host_intr_event_rdy = PCIE9098_HOST_INTR_EVENT_RDY,
-	.host_intr_cmd_dnld = PCIE9098_HOST_INTR_CMD_DNLD,
-	.use_adma = MTRUE,
-	.msi_int_wr_clr = MTRUE,
-};
-
-static const struct _mlan_card_info mlan_card_info_pcie9098 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 1,
-	.v17_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-
-#ifdef PCIE9097
-static const struct _mlan_pcie_card_reg mlan_reg_pcie9097_b0 = {
-	.reg_txbd_rdptr = PCIE9098_TXBD_RDPTR,
-	.reg_txbd_wrptr = PCIE9098_TXBD_WRPTR,
-	.reg_rxbd_rdptr = PCIE9098_RXBD_RDPTR,
-	.reg_rxbd_wrptr = PCIE9098_RXBD_WRPTR,
-	.reg_evtbd_rdptr = PCIE9098_EVTBD_RDPTR,
-	.reg_evtbd_wrptr = PCIE9098_EVTBD_WRPTR,
-	.reg_host_int_mask = PCIE9097_B0_HOST_INT_MASK,
-	.reg_host_int_status_mask = PCIE9097_B0_HOST_INT_STATUS_MASK,
-	.reg_host_int_status = PCIE9097_B0_HOST_INT_STATUS,
-	.reg_host_int_clr_sel = PCIE9097_B0_HOST_INT_CLR_SEL,
-	.reg_cpu_int_event = PCIE9098_CPU_INT_EVENT,
-	.reg_ip_rev = PCIE9098_DEV_ID_REG,
-	.reg_drv_ready = PCIE9098_DRV_READY,
-	.reg_cpu_int_status = PCIE9098_CPU_INT_STATUS,
-	.reg_rev_id = PCIE9098_REV_ID_REG,
-	.reg_scratch_0 = PCIE9098_SCRATCH_0_REG,
-	.reg_scratch_1 = PCIE9098_SCRATCH_1_REG,
-	.reg_scratch_2 = PCIE9098_SCRATCH_2_REG,
-	.reg_scratch_3 = PCIE9098_SCRATCH_3_REG,
-	.reg_scratch_6 = PCIE9098_SCRATCH_6_REG,
-	.reg_scratch_7 = PCIE9098_SCRATCH_7_REG,
-	.host_intr_mask = PCIE9098_HOST_INTR_MASK,
-	.host_intr_dnld_done = PCIE9098_HOST_INTR_DNLD_DONE,
-	.host_intr_upld_rdy = PCIE9098_HOST_INTR_UPLD_RDY,
-	.host_intr_cmd_done = PCIE9098_HOST_INTR_CMD_DONE,
-	.host_intr_event_rdy = PCIE9098_HOST_INTR_EVENT_RDY,
-	.host_intr_cmd_dnld = PCIE9098_HOST_INTR_CMD_DNLD,
-	.use_adma = MTRUE,
-	.msi_int_wr_clr = MTRUE,
-};
-#endif
 /* Get pcie device from card type */
 mlan_status wlan_get_pcie_device(pmlan_adapter pmadapter);
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c
old mode 100644
new mode 100755
index 09484b1a7..d17b9e3a2
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_scan.c
@@ -6,7 +6,7 @@
  *  for sending scan commands to the firmware.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -46,7 +46,7 @@ Change log:
 /** minimum scan time for passive to active scan */
 #define MIN_PASSIVE_TO_ACTIVE_SCAN_TIME 150
 
-#define MRVDRV_MAX_CHANNELS_PER_SCAN 40
+#define MRVDRV_MAX_CHANNELS_PER_SCAN 38
 /** The maximum number of channels the firmware can scan per command */
 #define MRVDRV_MAX_CHANNELS_PER_SPECIFIC_SCAN 4
 
@@ -124,7 +124,7 @@ enum cipher_suite {
 	CIPHER_SUITE_MAX
 };
 
-static t_u8 wpa_oui[CIPHER_SUITE_MAX][4] = {
+static t_u8 wpa_ouis[CIPHER_SUITE_MAX][4] = {
 	{0x00, 0x50, 0xf2, 0x01}, /* WEP40 */
 	{0x00, 0x50, 0xf2, 0x02}, /* TKIP */
 	{0x00, 0x50, 0xf2, 0x04}, /* AES */
@@ -150,9 +150,9 @@ static t_u8 rsn_oui[CIPHER_SUITE_MAX][4] = {
  *  @return          Band type conversion of scanBand used in join/assoc cmds
  *
  */
-t_u8 radio_type_to_band(t_u8 radio_type)
+t_u16 radio_type_to_band(t_u8 radio_type)
 {
-	t_u8 ret_band;
+	t_u16 ret_band;
 
 	switch (radio_type) {
 	case BAND_5GHZ:
@@ -175,8 +175,9 @@ t_u8 radio_type_to_band(t_u8 radio_type)
  *
  *  @return                NA
  */
-void wlan_update_chan_statistics(mlan_private *pmpriv,
-				 MrvlIEtypes_ChannelStats_t *pchanstats_tlv)
+static void
+wlan_update_chan_statistics(mlan_private *pmpriv,
+			    MrvlIEtypes_ChannelStats_t *pchanstats_tlv)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	t_u8 i;
@@ -351,7 +352,7 @@ static t_u8 is_wpa_oui_present(mlan_adapter *pmadapter,
 	if (((pbss_desc->pwpa_ie) &&
 	     ((*(pbss_desc->pwpa_ie)).vend_hdr.element_id == WPA_IE))) {
 		ie_body = (IEBody *)pbss_desc->pwpa_ie->data;
-		oui = &wpa_oui[cipher_suite][0];
+		oui = &wpa_ouis[cipher_suite][0];
 		ret = search_oui_in_ie(pmadapter, ie_body, oui);
 		if (ret) {
 			LEAVE();
@@ -374,7 +375,7 @@ static t_u8 is_wpa_oui_present(mlan_adapter *pmadapter,
  */
 static t_u8 wlan_is_band_compatible(t_u8 cfg_band, t_u8 scan_band)
 {
-	t_u8 band;
+	t_u16 band;
 	switch (scan_band) {
 	case BAND_A:
 		band = BAND_A | BAND_AN | BAND_AAC;
@@ -451,9 +452,9 @@ static t_s32 wlan_find_best_network_in_list(mlan_private *pmpriv)
  * of channels sent in a scan command and to disable the firmware channel scan
  *                          filter.
  *
- *  @return                 N/A
+ *  @return                 num of channel
  */
-static t_void wlan_scan_create_channel_list(
+static t_u8 wlan_scan_create_channel_list(
 	mlan_private *pmpriv, const wlan_user_scan_cfg *puser_scan_in,
 	ChanScanParamSet_t *pscan_chan_list, t_u8 filtered_scan)
 {
@@ -465,7 +466,7 @@ static t_void wlan_scan_create_channel_list(
 	t_u32 next_chan;
 	t_u8 scan_type;
 	t_u8 radio_type;
-	t_u8 band;
+	t_u16 band;
 	t_u16 scan_dur = 0;
 
 	ENTER();
@@ -495,6 +496,10 @@ static t_void wlan_scan_create_channel_list(
 			if (radio_type && (pscan_region->band != BAND_A))
 				continue;
 		}
+		PRINTM(MCMD_D,
+		       "create_channel_list: region=%d band=%d num_cfp=%d\n",
+		       pscan_region->region, pscan_region->band,
+		       pscan_region->num_cfp);
 		if ((puser_scan_in &&
 		     (puser_scan_in->bss_mode == MLAN_SCAN_MODE_IBSS)) ||
 		    pmpriv->bss_mode == MLAN_BSS_MODE_IBSS)
@@ -503,6 +508,7 @@ static t_void wlan_scan_create_channel_list(
 			band = pmpriv->config_bands;
 		if (!wlan_is_band_compatible(band, pscan_region->band))
 			continue;
+
 		for (next_chan = 0; next_chan < pscan_region->num_cfp;
 		     next_chan++) {
 			/* Set the default scan type to the user specified type,
@@ -527,7 +533,7 @@ static t_void wlan_scan_create_channel_list(
 				/* Passive scan on DFS channels */
 				if (wlan_11h_radar_detect_required(
 					    pmpriv, (t_u8)cfp->channel) &&
-				    scan_type != MLAN_SCAN_TYPE_PASSIVE)
+				    scan_type == MLAN_SCAN_TYPE_PASSIVE)
 					scan_type =
 						MLAN_SCAN_TYPE_PASSIVE_TO_ACTIVE;
 				break;
@@ -568,6 +574,7 @@ static t_void wlan_scan_create_channel_list(
 					.chan_scan_mode.passive_to_active_scan =
 					MTRUE;
 			}
+
 			pscan_chan_list[chan_idx].max_scan_time =
 				wlan_cpu_to_le16(scan_dur);
 
@@ -585,7 +592,7 @@ static t_void wlan_scan_create_channel_list(
 
 			pscan_chan_list[chan_idx].chan_number =
 				(t_u8)cfp->channel;
-			PRINTM(MINFO,
+			PRINTM(MCMD_D,
 			       "chan=%d, mode=%d, passive_to_active=%d\n",
 			       pscan_chan_list[chan_idx].chan_number,
 			       pscan_chan_list[chan_idx]
@@ -597,6 +604,7 @@ static t_void wlan_scan_create_channel_list(
 	}
 
 	LEAVE();
+	return chan_idx;
 }
 
 /**
@@ -674,6 +682,15 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 	t_u32 done_early;
 	t_u32 cmd_no;
 	t_u32 first_chan = 1;
+	t_u8 *ptlv_pos;
+	MrvlIETypes_HTCap_t *pht_cap;
+
+	MrvlIETypes_VHTCap_t *pvht_cap;
+	MrvlIEtypes_Extension_t *phe_cap;
+	t_u16 len = 0;
+	t_u8 radio_type = 0;
+	t_u8 channel = 0;
+
 	mlan_callbacks *pcb = (mlan_callbacks *)&pmadapter->callbacks;
 
 	ENTER();
@@ -696,7 +713,6 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 
 	/* check expiry before preparing scan list - may affect blacklist */
 	wlan_11h_get_csa_closed_channel(pmpriv);
-
 	pchan_tlv_out->header.type = wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
 
 	/* Set the temp channel struct pointer to the start of the desired list
@@ -736,6 +752,8 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 				    radio_type_to_band(
 					    ptmp_chan_list->bandcfg.chanBand),
 				    ptmp_chan_list->chan_number)) {
+				PRINTM(MCMND, "Block scan chan = %d\n",
+				       ptmp_chan_list->chan_number);
 				ptmp_chan_list++;
 				continue;
 			}
@@ -745,13 +763,16 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 					MTRUE;
 				first_chan = 0;
 			}
-
-			PRINTM(MINFO,
-			       "Scan: Chan(%3d), bandcfg(%x), Mode(%d,%d), Dur(%d)\n",
+			radio_type = ptmp_chan_list->bandcfg.chanBand;
+			channel = ptmp_chan_list->chan_number;
+			PRINTM(MCMD_D,
+			       "Scan: Chan(%3d), bandcfg(%x), Mode(%d,%d,%d), Dur(%d)\n",
 			       ptmp_chan_list->chan_number,
 			       ptmp_chan_list->bandcfg,
 			       ptmp_chan_list->chan_scan_mode.passive_scan,
 			       ptmp_chan_list->chan_scan_mode.disable_chan_filt,
+			       ptmp_chan_list->chan_scan_mode
+				       .passive_to_active_scan,
 			       wlan_le16_to_cpu(ptmp_chan_list->max_scan_time));
 
 			if (foundJPch14 == MTRUE) {
@@ -791,7 +812,8 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 				ret = pcb->moal_malloc(
 					pmadapter->pmoal_handle,
 					MAX_SCAN_CFG_ALLOC - CHAN_TLV_MAX_SIZE,
-					MLAN_MEM_DEF, (t_u8 **)&ptlv_temp);
+					MLAN_MEM_DEF | MOAL_MEM_FLAG_ATOMIC,
+					(t_u8 **)&ptlv_temp);
 				if (ret != MLAN_STATUS_SUCCESS || !ptlv_temp) {
 					PRINTM(MERROR,
 					       "Memory allocation for pscan_cfg_out failed!\n");
@@ -958,9 +980,10 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 
 		/* The total scan time should be less than scan command timeout
 		 * value */
-		if (total_scan_time > MRVDRV_MAX_TOTAL_SCAN_TIME) {
+		if (!total_scan_time ||
+		    total_scan_time > MRVDRV_MAX_TOTAL_SCAN_TIME) {
 			PRINTM(MMSG,
-			       "Total scan time %d ms is over limit (%d ms), scan skipped\n",
+			       "Total scan time %d ms is invalid, limit (%d ms), scan skipped\n",
 			       total_scan_time, MRVDRV_MAX_TOTAL_SCAN_TIME);
 			if (pioctl_req)
 				pioctl_req->status_code =
@@ -968,15 +991,70 @@ wlan_scan_channel_list(mlan_private *pmpriv, t_void *pioctl_buf,
 			ret = MLAN_STATUS_FAILURE;
 			break;
 		}
+		ptlv_pos = (t_u8 *)pchan_tlv_out + pchan_tlv_out->header.len +
+			   sizeof(MrvlIEtypesHeader_t);
 
 		pchan_tlv_out->header.len =
 			wlan_cpu_to_le16(pchan_tlv_out->header.len);
 
+		if (ISSUPP_11NENABLED(pmpriv->adapter->fw_cap_info) &&
+		    (pmpriv->config_bands & BAND_GN ||
+		     pmpriv->config_bands & BAND_AN)) {
+			pht_cap = (MrvlIETypes_HTCap_t *)ptlv_pos;
+			memset(pmadapter, pht_cap, 0,
+			       sizeof(MrvlIETypes_HTCap_t));
+			pht_cap->header.type = wlan_cpu_to_le16(HT_CAPABILITY);
+			pht_cap->header.len = sizeof(HTCap_t);
+			wlan_fill_ht_cap_tlv(pmpriv, pht_cap,
+					     pmpriv->config_bands, MTRUE);
+			HEXDUMP("SCAN: HT_CAPABILITIES IE", (t_u8 *)pht_cap,
+				sizeof(MrvlIETypes_HTCap_t));
+			ptlv_pos += sizeof(MrvlIETypes_HTCap_t);
+			pht_cap->header.len =
+				wlan_cpu_to_le16(pht_cap->header.len);
+		}
+
+		if (ISSUPP_11ACENABLED(pmpriv->adapter->fw_cap_info) &&
+		    (pmpriv->config_bands & BAND_AAC)) {
+			pvht_cap = (MrvlIETypes_VHTCap_t *)ptlv_pos;
+			memset(pmadapter, pvht_cap, 0,
+			       sizeof(MrvlIETypes_VHTCap_t));
+			pvht_cap->header.type =
+				wlan_cpu_to_le16(VHT_CAPABILITY);
+			pvht_cap->header.len = sizeof(VHT_capa_t);
+			wlan_fill_vht_cap_tlv(pmpriv, pvht_cap,
+					      pmpriv->config_bands, MFALSE,
+					      MFALSE);
+			HEXDUMP("SCAN: VHT_CAPABILITIES IE", (t_u8 *)pvht_cap,
+				sizeof(MrvlIETypes_VHTCap_t));
+			ptlv_pos += sizeof(MrvlIETypes_VHTCap_t);
+			pvht_cap->header.len =
+				wlan_cpu_to_le16(pvht_cap->header.len);
+		}
+
+		if (IS_FW_SUPPORT_11AX(pmadapter) &&
+		    ((pmpriv->config_bands & BAND_GAX) ||
+		     (pmpriv->config_bands & BAND_AAX))) {
+			phe_cap = (MrvlIEtypes_Extension_t *)ptlv_pos;
+			len = wlan_fill_he_cap_tlv(pmpriv, pmpriv->config_bands,
+						   phe_cap, MFALSE);
+			HEXDUMP("SCAN: HE_CAPABILITIES IE", (t_u8 *)phe_cap,
+				len);
+			ptlv_pos += len;
+		}
+
+		pscan_cfg_out->tlv_buf_len =
+			(t_u32)((t_u8 *)ptlv_pos - pscan_cfg_out->tlv_buf);
+
 		pmadapter->pscan_channels = pstart_chan;
 
 		/* Send the scan command to the firmware with the specified cfg
 		 */
-		if (pmadapter->ext_scan)
+		if (pmadapter->ext_scan
+#ifdef USB8801
+		    && !IS_USB8801(pmadapter->card_type)
+#endif
+		)
 			cmd_no = HostCmd_CMD_802_11_SCAN_EXT;
 		else
 			cmd_no = HostCmd_CMD_802_11_SCAN;
@@ -1054,7 +1132,7 @@ static mlan_status wlan_scan_setup_scan_config(
 	t_u8 *ptlv_pos;
 	t_u32 num_probes;
 	t_u32 ssid_len;
-	t_u32 chan_idx;
+	t_u32 chan_idx = 0;
 	t_u32 chan_list_idx = 0;
 	t_u32 scan_type;
 	t_u16 scan_dur;
@@ -1064,13 +1142,9 @@ static mlan_status wlan_scan_setup_scan_config(
 	t_u8 ssid_filter;
 	WLAN_802_11_RATES rates;
 	t_u32 rates_size;
-	MrvlIETypes_HTCap_t *pht_cap;
-
-	MrvlIETypes_VHTCap_t *pvht_cap;
 	MrvlIEtypes_ScanChanGap_t *pscan_gap_tlv;
 	MrvlIEtypes_BssMode_t *pbss_mode;
-	MrvlIEtypes_Extension_t *phe_cap;
-	t_u16 len = 0;
+	t_u8 num_of_channel = 0;
 
 	ENTER();
 
@@ -1324,43 +1398,6 @@ static mlan_status wlan_scan_setup_scan_config(
 
 	PRINTM(MINFO, "SCAN_CMD: Rates size = %d\n", rates_size);
 
-	if (ISSUPP_11NENABLED(pmpriv->adapter->fw_cap_info) &&
-	    (pmpriv->config_bands & BAND_GN ||
-	     pmpriv->config_bands & BAND_AN)) {
-		pht_cap = (MrvlIETypes_HTCap_t *)ptlv_pos;
-		memset(pmadapter, pht_cap, 0, sizeof(MrvlIETypes_HTCap_t));
-		pht_cap->header.type = wlan_cpu_to_le16(HT_CAPABILITY);
-		pht_cap->header.len = sizeof(HTCap_t);
-		wlan_fill_ht_cap_tlv(pmpriv, pht_cap, pmpriv->config_bands,
-				     MTRUE);
-		HEXDUMP("SCAN: HT_CAPABILITIES IE", (t_u8 *)pht_cap,
-			sizeof(MrvlIETypes_HTCap_t));
-		ptlv_pos += sizeof(MrvlIETypes_HTCap_t);
-		pht_cap->header.len = wlan_cpu_to_le16(pht_cap->header.len);
-	}
-
-	if (ISSUPP_11ACENABLED(pmpriv->adapter->fw_cap_info) &&
-	    (pmpriv->config_bands & BAND_AAC)) {
-		pvht_cap = (MrvlIETypes_VHTCap_t *)ptlv_pos;
-		memset(pmadapter, pvht_cap, 0, sizeof(MrvlIETypes_VHTCap_t));
-		pvht_cap->header.type = wlan_cpu_to_le16(VHT_CAPABILITY);
-		pvht_cap->header.len = sizeof(VHT_capa_t);
-		wlan_fill_vht_cap_tlv(pmpriv, pvht_cap, pmpriv->config_bands,
-				      MFALSE, MFALSE);
-		HEXDUMP("SCAN: VHT_CAPABILITIES IE", (t_u8 *)pvht_cap,
-			sizeof(MrvlIETypes_VHTCap_t));
-		ptlv_pos += sizeof(MrvlIETypes_VHTCap_t);
-		pvht_cap->header.len = wlan_cpu_to_le16(pvht_cap->header.len);
-	}
-
-	if (IS_FW_SUPPORT_11AX(pmadapter) &&
-	    (pmpriv->config_bands & BAND_AAX)) {
-		phe_cap = (MrvlIEtypes_Extension_t *)ptlv_pos;
-		len = wlan_fill_he_cap_tlv(pmpriv, BAND_A, phe_cap, MFALSE);
-		HEXDUMP("SCAN: HE_CAPABILITIES IE", (t_u8 *)phe_cap, len);
-		ptlv_pos += len;
-	}
-
 	if (wlan_is_ext_capa_support(pmpriv))
 		wlan_add_ext_capa_info_ie(pmpriv, MNULL, &ptlv_pos);
 	if (pmpriv->adapter->ecsa_enable) {
@@ -1466,15 +1503,20 @@ static mlan_status wlan_scan_setup_scan_config(
 					return ret;
 				}
 			}
-
-			if (wlan_is_chan_passive(pmpriv, radio_type, channel)) {
-				/* do not send probe requests on this channel */
-				scan_type = MLAN_SCAN_TYPE_PASSIVE;
+			if (!puser_scan_in->scan_cfg_only) {
+				if (wlan_is_chan_passive(
+					    pmpriv,
+					    radio_type_to_band(radio_type),
+					    channel)) {
+					/* do not send probe requests on this
+					 * channel */
+					scan_type = MLAN_SCAN_TYPE_PASSIVE;
+				}
 			}
 			/* Prevent active scanning on a radar controlled channel
 			 */
 			if (radio_type == BAND_5GHZ &&
-			    scan_type != MLAN_SCAN_TYPE_PASSIVE) {
+			    scan_type == MLAN_SCAN_TYPE_PASSIVE) {
 				if (pmadapter->active_scan_triggered == MFALSE)
 					if (wlan_11h_radar_detect_required(
 						    pmpriv, channel)) {
@@ -1483,6 +1525,7 @@ static mlan_status wlan_scan_setup_scan_config(
 					}
 			}
 			if (radio_type == BAND_2GHZ &&
+			    !puser_scan_in->scan_cfg_only &&
 			    scan_type != MLAN_SCAN_TYPE_PASSIVE) {
 				if (pmadapter->active_scan_triggered == MFALSE)
 					if (wlan_bg_scan_type_is_passive(
@@ -1555,11 +1598,13 @@ static mlan_status wlan_scan_setup_scan_config(
 			*pscan_current_only = MTRUE;
 			PRINTM(MINFO, "Scan: Scanning current channel only\n");
 		}
-
 	} else {
-		PRINTM(MINFO, "Scan: Creating full region channel list\n");
-		wlan_scan_create_channel_list(pmpriv, puser_scan_in,
-					      pscan_chan_list, *pfiltered_scan);
+		num_of_channel =
+			wlan_scan_create_channel_list(pmpriv, puser_scan_in,
+						      pscan_chan_list,
+						      *pfiltered_scan);
+		PRINTM(MCMND, "Scan: Creating full region channel list %d\n",
+		       num_of_channel);
 	}
 
 	LEAVE();
@@ -1698,6 +1743,7 @@ static mlan_status wlan_interpret_bss_desc_with_ie(pmlan_adapter pmadapter,
 	IEEEtypes_VendorSpecific_t *pvendor_ie;
 	const t_u8 wpa_oui[4] = {0x00, 0x50, 0xf2, 0x01};
 	const t_u8 wmm_oui[4] = {0x00, 0x50, 0xf2, 0x02};
+	const t_u8 owe_oui[4] = {0x50, 0x6f, 0x9a, 0x1c};
 	const t_u8 osen_oui[] = {0x50, 0x6f, 0x9a, 0x12};
 
 	IEEEtypes_CountryInfoSet_t *pcountry_info;
@@ -1831,8 +1877,8 @@ static mlan_status wlan_interpret_bss_desc_with_ie(pmlan_adapter pmadapter,
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 
 		if (bytes_left_for_current_beacon < total_ie_len) {
-			PRINTM(MERROR, "InterpretIE: Error in processing IE, "
-				       "bytes left < IE length\n");
+			//PRINTM(MERROR, "InterpretIE: Error in processing IE, "
+			//	       "bytes left < IE length\n");
 			bytes_left_for_current_beacon = 0;
 			ret = MLAN_STATUS_FAILURE;
 			continue;
@@ -2037,6 +2083,54 @@ static mlan_status wlan_interpret_bss_desc_with_ie(pmlan_adapter pmadapter,
 						(t_u8 *)&pbss_entry->wmm_ie,
 						total_ie_len);
 				}
+			} else if (IS_FW_SUPPORT_EMBEDDED_OWE(pmadapter) &&
+				   !memcmp(pmadapter, pvendor_ie->vend_hdr.oui,
+					   owe_oui, sizeof(owe_oui))) {
+				/* Current Format of OWE IE is
+				 * element_id:element_len:oui:MAC Address:SSID
+				 * length:SSID */
+				t_u8 trans_ssid_len = *(
+					pcurrent_ptr +
+					sizeof(IEEEtypes_Header_t) +
+					sizeof(owe_oui) + MLAN_MAC_ADDR_LENGTH);
+
+				if (!trans_ssid_len ||
+				    trans_ssid_len > MRVDRV_MAX_SSID_LENGTH) {
+					bytes_left_for_current_beacon = 0;
+					continue;
+				}
+				if (!pcap_info->privacy)
+					pbss_entry->owe_transition_mode =
+						OWE_TRANS_MODE_OPEN;
+				else
+					pbss_entry->owe_transition_mode =
+						OWE_TRANS_MODE_OWE;
+
+				memcpy_ext(
+					pmadapter,
+					pbss_entry->trans_mac_address,
+					(pcurrent_ptr +
+					 sizeof(IEEEtypes_Header_t) +
+					 sizeof(owe_oui)),
+					MLAN_MAC_ADDR_LENGTH,
+					sizeof(pbss_entry->trans_mac_address));
+				pbss_entry->trans_ssid.ssid_len =
+					trans_ssid_len;
+				memcpy_ext(
+					pmadapter, pbss_entry->trans_ssid.ssid,
+					(pcurrent_ptr +
+					 sizeof(IEEEtypes_Header_t) +
+					 sizeof(owe_oui) +
+					 MLAN_MAC_ADDR_LENGTH + sizeof(t_u8)),
+					trans_ssid_len,
+					sizeof(pbss_entry->trans_ssid.ssid));
+
+				PRINTM(MCMND,
+				       "InterpretIE: OWE Transition AP privacy=%d MAC Addr-" MACSTR
+				       " ssid %s\n",
+				       pbss_entry->owe_transition_mode,
+				       MAC2STR(pbss_entry->trans_mac_address),
+				       pbss_entry->trans_ssid.ssid);
 			} else if (!memcmp(pmadapter, pvendor_ie->vend_hdr.oui,
 					   osen_oui, sizeof(osen_oui))) {
 				pbss_entry->posen_ie =
@@ -2059,6 +2153,16 @@ static mlan_status wlan_interpret_bss_desc_with_ie(pmlan_adapter pmadapter,
 				(*(pbss_entry->prsn_ie)).ieee_hdr.len +
 					sizeof(IEEEtypes_Header_t));
 			break;
+		case RSNX_IE:
+			pbss_entry->prsnx_ie =
+				(IEEEtypes_Generic_t *)pcurrent_ptr;
+			pbss_entry->rsnx_offset =
+				(t_u16)(pcurrent_ptr - pbss_entry->pbeacon_buf);
+			HEXDUMP("InterpretIE: Resp RSNX_IE",
+				(t_u8 *)pbss_entry->prsnx_ie,
+				(*(pbss_entry->prsnx_ie)).ieee_hdr.len +
+					sizeof(IEEEtypes_Header_t));
+			break;
 		case WAPI_IE:
 			pbss_entry->pwapi_ie =
 				(IEEEtypes_Generic_t *)pcurrent_ptr;
@@ -2069,6 +2173,13 @@ static mlan_status wlan_interpret_bss_desc_with_ie(pmlan_adapter pmadapter,
 				(*(pbss_entry->pwapi_ie)).ieee_hdr.len +
 					sizeof(IEEEtypes_Header_t));
 			break;
+		case MULTI_BSSID:
+			if (IS_FW_SUPPORT_MULTIBSSID(pmadapter)) {
+				pbss_entry->multi_bssid_ap = MULTI_BSSID_AP;
+				HEXDUMP("InterpretIE: Multi BSSID IE",
+					(t_u8 *)pcurrent_ptr, total_ie_len);
+			}
+			break;
 		case HT_CAPABILITY:
 			pbss_entry->pht_cap = (IEEEtypes_HTCap_t *)pcurrent_ptr;
 			pbss_entry->ht_cap_offset =
@@ -2362,6 +2473,11 @@ static t_void wlan_adjust_ie_in_bss_entry(mlan_private *pmpriv,
 					 *)(pbss_entry->pbeacon_buf +
 					    pbss_entry->he_oprat_offset);
 		}
+		if (pbss_entry->prsnx_ie) {
+			pbss_entry->prsnx_ie =
+				(IEEEtypes_Generic_t *)(pbss_entry->pbeacon_buf +
+							pbss_entry->rsnx_offset);
+		}
 	} else {
 		pbss_entry->pwpa_ie = MNULL;
 		pbss_entry->wpa_offset = 0;
@@ -2427,7 +2543,7 @@ static t_void wlan_ret_802_11_scan_store_beacon(mlan_private *pmpriv,
 	t_u32 adj_idx;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u8 *tmp_buf;
-	t_u16 bcn_size = 0;
+	t_u32 bcn_size = 0;
 	t_u32 bcn_offset = 0;
 
 	ENTER();
@@ -2692,6 +2808,10 @@ static t_void wlan_ret_802_11_scan_store_beacon(mlan_private *pmpriv,
 				pnew_beacon->he_oprat_offset =
 					pmadapter->pscan_table[beacon_idx]
 						.he_oprat_offset;
+			if (pnew_beacon->prsnx_ie)
+				pnew_beacon->rsnx_offset =
+					pmadapter->pscan_table[beacon_idx]
+						.rsnx_offset;
 		}
 		/* Point the new entry to its permanent storage space */
 		pnew_beacon->pbeacon_buf = pbcn_store;
@@ -2702,11 +2822,19 @@ static t_void wlan_ret_802_11_scan_store_beacon(mlan_private *pmpriv,
 		     (pmadapter->bcn_buf + pmadapter->bcn_buf_size)) &&
 		    (pmadapter->bcn_buf_size < MAX_SCAN_BEACON_BUFFER)) {
 			/* no space for this entry, realloc bcn buffer */
-			ret = pmadapter->callbacks.moal_malloc(
-				pmadapter->pmoal_handle,
-				pmadapter->bcn_buf_size +
-					DEFAULT_SCAN_BEACON_BUFFER,
-				MLAN_MEM_DEF, (t_u8 **)&tmp_buf);
+			if (pmadapter->callbacks.moal_vmalloc &&
+			    pmadapter->callbacks.moal_vfree)
+				ret = pmadapter->callbacks.moal_vmalloc(
+					pmadapter->pmoal_handle,
+					pmadapter->bcn_buf_size +
+						DEFAULT_SCAN_BEACON_BUFFER,
+					(t_u8 **)&tmp_buf);
+			else
+				ret = pmadapter->callbacks.moal_malloc(
+					pmadapter->pmoal_handle,
+					pmadapter->bcn_buf_size +
+						DEFAULT_SCAN_BEACON_BUFFER,
+					MLAN_MEM_DEF, (t_u8 **)&tmp_buf);
 
 			if ((ret == MLAN_STATUS_SUCCESS) && (tmp_buf)) {
 				PRINTM(MCMND,
@@ -2735,9 +2863,15 @@ static t_void wlan_ret_802_11_scan_store_beacon(mlan_private *pmpriv,
 						&pmadapter->pscan_table[adj_idx]);
 				}
 				pmadapter->pbcn_buf_end = tmp_buf + bcn_size;
-				pmadapter->callbacks.moal_mfree(
-					pmadapter->pmoal_handle,
-					(t_u8 *)pmadapter->bcn_buf);
+				if (pmadapter->callbacks.moal_vmalloc &&
+				    pmadapter->callbacks.moal_vfree)
+					pmadapter->callbacks.moal_vfree(
+						pmadapter->pmoal_handle,
+						(t_u8 *)pmadapter->bcn_buf);
+				else
+					pmadapter->callbacks.moal_mfree(
+						pmadapter->pmoal_handle,
+						(t_u8 *)pmadapter->bcn_buf);
 				pmadapter->bcn_buf = tmp_buf;
 				pmadapter->bcn_buf_size +=
 					DEFAULT_SCAN_BEACON_BUFFER;
@@ -2938,6 +3072,11 @@ static mlan_status wlan_update_curr_bcn(mlan_private *pmpriv)
 					 *)(pcurr_bss->pbeacon_buf +
 					    pcurr_bss->he_oprat_offset);
 		}
+		if (pcurr_bss->prsnx_ie) {
+			pcurr_bss->prsnx_ie =
+				(IEEEtypes_Generic_t *)(pcurr_bss->pbeacon_buf +
+							pcurr_bss->rsnx_offset);
+		}
 
 		PRINTM(MINFO, "current beacon restored %d\n",
 		       pmpriv->curr_bcn_size);
@@ -2962,7 +3101,7 @@ static t_u16 wlan_get_chan_load(mlan_adapter *pmadapter, t_u8 channel)
 {
 	t_u16 chan_load = 0;
 	int i;
-	for (i = 0; i < pmadapter->num_in_chan_stats; i++) {
+	for (i = 0; i < (int)pmadapter->num_in_chan_stats; i++) {
 		if ((pmadapter->pchan_stats[i].chan_num == channel) &&
 		    pmadapter->pchan_stats[i].cca_scan_duration) {
 			chan_load =
@@ -2988,7 +3127,7 @@ static t_u8 wlan_get_chan_rssi(mlan_adapter *pmadapter, t_u8 channel,
 {
 	t_u8 rssi = 0;
 	int i;
-	for (i = 0; i < pmadapter->num_in_scan_table; i++) {
+	for (i = 0; i < (int)pmadapter->num_in_scan_table; i++) {
 		if (pmadapter->pscan_table[i].channel == channel) {
 			if (rssi == 0)
 				rssi = (t_s32)pmadapter->pscan_table[i].rssi;
@@ -3019,7 +3158,7 @@ static t_void wlan_update_chan_rssi(mlan_adapter *pmadapter)
 	t_s8 min_rssi = 0;
 	t_s8 max_rssi = 0;
 	t_s8 rss = 0;
-	for (i = 0; i < pmadapter->num_in_chan_stats; i++) {
+	for (i = 0; i < (int)pmadapter->num_in_chan_stats; i++) {
 		if (pmadapter->pchan_stats[i].chan_num &&
 		    pmadapter->pchan_stats[i].cca_scan_duration) {
 			min_rssi = -wlan_get_chan_rssi(
@@ -3153,6 +3292,8 @@ static t_void wlan_scan_process_results(mlan_private *pmpriv)
 				MNULL;
 			pmpriv->curr_bss_params.bss_descriptor.he_oprat_offset =
 				0;
+			pmpriv->curr_bss_params.bss_descriptor.prsnx_ie = MNULL;
+			pmpriv->curr_bss_params.bss_descriptor.rsnx_offset = 0;
 			pmpriv->curr_bss_params.bss_descriptor.pbeacon_buf =
 				MNULL;
 			pmpriv->curr_bss_params.bss_descriptor.beacon_buf_size =
@@ -3545,6 +3686,44 @@ static t_void wlan_scan_delete_table_entry(mlan_private *pmpriv,
 	LEAVE();
 }
 
+/**
+ *  @brief Delete all entry's age out
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *
+ *  @return             N/A
+ */
+static void wlan_scan_delete_ageout_entry(mlan_private *pmpriv)
+{
+	BSSDescriptor_t *pbss_entry;
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	t_s32 table_idx = pmadapter->num_in_scan_table - 1;
+	t_u32 i = 0;
+	t_u32 age_in_secs = 0;
+	t_u32 age_ts_usec = 0;
+
+	ENTER();
+#define SCAN_RESULT_AGEOUT 10
+	pmadapter->callbacks.moal_get_system_time(pmadapter->pmoal_handle,
+						  &age_in_secs, &age_ts_usec);
+
+	for (i = 0; i < pmadapter->num_in_scan_table; i++) {
+		pbss_entry = &pmadapter->pscan_table[table_idx];
+		if (age_in_secs >
+		    (pbss_entry->age_in_secs + SCAN_RESULT_AGEOUT)) {
+			PRINTM(MCMND,
+			       "SCAN: ageout AP MAC Addr-" MACSTR
+			       " ssid: %-32s\n",
+			       MAC2STR(pbss_entry->mac_address),
+			       pbss_entry->ssid.ssid);
+			wlan_scan_delete_table_entry(pmpriv, table_idx);
+		}
+		table_idx--;
+	}
+	LEAVE();
+	return;
+}
+
 /**
  *  @brief Delete all occurrences of a given SSID from the scan table
  *
@@ -3654,6 +3833,13 @@ t_s32 wlan_is_network_compatible(mlan_private *pmpriv, t_u32 index, t_u32 mode)
 		LEAVE();
 		return index;
 	}
+	if ((pbss_desc->owe_transition_mode == OWE_TRANS_MODE_OPEN) &&
+	    (pmpriv->sec_info.authentication_mode != MLAN_AUTH_MODE_OWE)) {
+		PRINTM(MINFO,
+		       "Return success directly in OWE Transition mode\n");
+		LEAVE();
+		return index;
+	}
 
 	if (pmpriv->sec_info.osen_enabled && pbss_desc->posen_ie &&
 	    ((*(pbss_desc->posen_ie)).ieee_hdr.element_id ==
@@ -3672,7 +3858,8 @@ t_s32 wlan_is_network_compatible(mlan_private *pmpriv, t_u32 index, t_u32 mode)
 #ifdef DRV_EMBEDDED_SUPPLICANT
 	     || supplicantIsEnabled(pmpriv->psapriv)
 #endif
-		     )) {
+	     || pmpriv->sec_info.authentication_mode == MLAN_AUTH_MODE_OWE ||
+	     pbss_desc->owe_transition_mode == OWE_TRANS_MODE_OWE)) {
 		if (((pbss_desc->pwpa_ie) &&
 		     ((*(pbss_desc->pwpa_ie)).vend_hdr.element_id == WPA_IE)) ||
 		    ((pbss_desc->prsn_ie) &&
@@ -4020,7 +4207,8 @@ mlan_status wlan_scan_networks(mlan_private *pmpriv, t_void *pioctl_buf,
 	ENTER();
 
 	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
-			       sizeof(wlan_scan_cmd_config_tlv), MLAN_MEM_DEF,
+			       sizeof(wlan_scan_cmd_config_tlv),
+			       MLAN_MEM_DEF | MLAN_MEM_FLAG_ATOMIC,
 			       (t_u8 **)&pscan_cfg_out);
 	if (ret != MLAN_STATUS_SUCCESS || !pscan_cfg_out) {
 		PRINTM(MERROR, "Memory allocation for pscan_cfg_out failed!\n");
@@ -4031,7 +4219,8 @@ mlan_status wlan_scan_networks(mlan_private *pmpriv, t_void *pioctl_buf,
 	}
 
 	buf_size = sizeof(ChanScanParamSet_t) * WLAN_USER_SCAN_CHAN_MAX;
-	ret = pcb->moal_malloc(pmadapter->pmoal_handle, buf_size, MLAN_MEM_DEF,
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle, buf_size,
+			       MLAN_MEM_DEF | MLAN_MEM_FLAG_ATOMIC,
 			       (t_u8 **)&pscan_chan_list);
 	if (ret != MLAN_STATUS_SUCCESS || !pscan_chan_list) {
 		PRINTM(MERROR, "Failed to allocate scan_chan_list\n");
@@ -4044,10 +4233,6 @@ mlan_status wlan_scan_networks(mlan_private *pmpriv, t_void *pioctl_buf,
 		return MLAN_STATUS_FAILURE;
 	}
 
-	memset(pmadapter, pscan_chan_list, 0x00, buf_size);
-	memset(pmadapter, pscan_cfg_out, 0x00,
-	       sizeof(wlan_scan_cmd_config_tlv));
-
 	keep_previous_scan = MFALSE;
 
 	ret = wlan_scan_setup_scan_config(pmpriv, puser_scan_in,
@@ -4077,7 +4262,18 @@ mlan_status wlan_scan_networks(mlan_private *pmpriv, t_void *pioctl_buf,
 		       sizeof(BSSDescriptor_t) * MRVDRV_MAX_BSSID_LIST);
 		pmadapter->num_in_scan_table = 0;
 		pmadapter->pbcn_buf_end = pmadapter->bcn_buf;
+	} else {
+		wlan_scan_delete_ageout_entry(pmpriv);
 	}
+
+	// back up the pchan_stats before reset it
+	memset(pmadapter, pmadapter->pold_chan_stats, 0x00,
+	       sizeof(ChanStatistics_t) * pmadapter->num_in_chan_stats);
+	memcpy_ext(pmpriv->adapter, pmadapter->pold_chan_stats,
+		   pmadapter->pchan_stats,
+		   sizeof(ChanStatistics_t) * pmadapter->num_in_chan_stats,
+		   sizeof(ChanStatistics_t) * pmadapter->num_in_chan_stats);
+	pmadapter->old_idx_chan_stats = pmadapter->idx_chan_stats;
 	for (i = 0; i < pmadapter->num_in_chan_stats; i++)
 		pmadapter->pchan_stats[i].cca_scan_duration = 0;
 	pmadapter->idx_chan_stats = 0;
@@ -4088,28 +4284,19 @@ mlan_status wlan_scan_networks(mlan_private *pmpriv, t_void *pioctl_buf,
 
 	/* Get scan command from scan_pending_q and put to cmd_pending_q */
 	if (ret == MLAN_STATUS_SUCCESS) {
-		if (pmadapter->ext_scan && pmadapter->ext_scan_enh &&
-		    pmadapter->ext_scan_type == EXT_SCAN_ENHANCE) {
-			wlan_request_cmd_lock(pmadapter);
+		wlan_request_cmd_lock(pmadapter);
+		if (util_peek_list(pmadapter->pmoal_handle,
+				   &pmadapter->scan_pending_q, MNULL, MNULL)) {
+			pcmd_node = (cmd_ctrl_node *)util_dequeue_list(
+				pmadapter->pmoal_handle,
+				&pmadapter->scan_pending_q, MNULL, MNULL);
 			pmadapter->pscan_ioctl_req = pioctl_req;
 			pmadapter->scan_processing = MTRUE;
-			wlan_release_cmd_lock(pmadapter);
-		} else {
-			wlan_request_cmd_lock(pmadapter);
-			if (util_peek_list(pmadapter->pmoal_handle,
-					   &pmadapter->scan_pending_q, MNULL,
-					   MNULL)) {
-				pcmd_node = (cmd_ctrl_node *)util_dequeue_list(
-					pmadapter->pmoal_handle,
-					&pmadapter->scan_pending_q, MNULL,
-					MNULL);
-				pmadapter->pscan_ioctl_req = pioctl_req;
-				pmadapter->scan_processing = MTRUE;
-				wlan_insert_cmd_to_pending_q(pmadapter,
-							     pcmd_node, MTRUE);
-			}
-			wlan_release_cmd_lock(pmadapter);
+			pmadapter->scan_state = SCAN_STATE_SCAN_START;
+			wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node,
+						     MTRUE);
 		}
+		wlan_release_cmd_lock(pmadapter);
 	}
 	if (pscan_cfg_out)
 		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)pscan_cfg_out);
@@ -4178,8 +4365,8 @@ mlan_status wlan_cmd_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *pcmd,
  *  @return             MTRUE/MFALSE
  */
 
-t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
-					     mlan_ioctl_req *pioctl_buf)
+static t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
+						    mlan_ioctl_req *pioctl_buf)
 {
 	t_bool ret = MFALSE;
 	mlan_adapter *pmadapter = pmpriv->adapter;
@@ -4189,10 +4376,11 @@ t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
 	t_u32 bss_idx, i;
 	t_u8 null_ssid[MLAN_MAX_SSID_LENGTH] = {0};
 	mlan_callbacks *pcb = (mlan_callbacks *)&pmpriv->adapter->callbacks;
-	wlan_user_scan_cfg *user_scan_cfg;
+	wlan_user_scan_cfg *user_scan_cfg = MNULL;
 	mlan_ds_scan *pscan = (mlan_ds_scan *)pioctl_buf->pbuf;
 	mlan_scan_req *pscan_req = MNULL;
 	wlan_user_scan_cfg *puser_scan_in = MNULL;
+	t_u16 band;
 
 	ENTER();
 
@@ -4216,7 +4404,6 @@ t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
 		PRINTM(MERROR, "Memory allocation for user_scan_cfg failed\n");
 		goto done;
 	}
-	memset(pmadapter, user_scan_cfg, 0, sizeof(wlan_user_scan_cfg));
 	for (bss_idx = 0; bss_idx < pmadapter->num_in_scan_table; bss_idx++) {
 		scan_reqd = MFALSE;
 		if (!memcmp(pmadapter,
@@ -4263,12 +4450,15 @@ t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
 			if (scan_reqd) {
 				chan_listed = MFALSE;
 				for (i = 0; i < id; i++) {
+					band = radio_type_to_band(
+						user_scan_cfg->chan_list[i]
+							.radio_type);
+
 					if ((user_scan_cfg->chan_list[i]
 						     .chan_number ==
 					     pmadapter->pscan_table[bss_idx]
 						     .channel) &&
-					    (user_scan_cfg->chan_list[i]
-						     .radio_type &
+					    (band &
 					     pmadapter->pscan_table[bss_idx]
 						     .bss_band)) {
 						chan_listed = MTRUE;
@@ -4290,6 +4480,9 @@ t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
 				user_scan_cfg->chan_list[id].scan_type =
 					MLAN_SCAN_TYPE_ACTIVE;
 				id++;
+
+				if (id >= WLAN_USER_SCAN_CHAN_MAX)
+					break;
 			}
 		}
 	}
@@ -4309,16 +4502,20 @@ t_bool wlan_active_scan_req_for_passive_chan(mlan_private *pmpriv,
 				   MLAN_MAX_SSID_LENGTH);
 		}
 		user_scan_cfg->keep_previous_scan = MTRUE;
+		if (pmadapter->ext_scan_type == EXT_SCAN_ENHANCE)
+			user_scan_cfg->ext_scan_type = EXT_SCAN_ENHANCE;
+		PRINTM(MCMND, "active scan request for passive channel %d\n",
+		       id);
 		if (MLAN_STATUS_SUCCESS !=
 		    wlan_scan_networks(pmpriv, pioctl_buf, user_scan_cfg)) {
 			goto done;
 		}
 		ret = MTRUE;
 	}
+done:
 	if (user_scan_cfg)
 		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)user_scan_cfg);
 
-done:
 	LEAVE();
 	return ret;
 }
@@ -4366,12 +4563,12 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 	t_u32 num_in_table;
 	t_u32 bss_idx;
 	t_u32 idx;
-	t_u32 tlv_buf_size;
+	t_u32 tlv_buf_size = 0;
 	t_u64 tsf_val;
 	chan_freq_power_t *cfp;
 	MrvlIEtypes_ChanBandListParamSet_t *pchan_band_tlv = MNULL;
 	ChanBandParamSet_t *pchan_band;
-	t_u8 band;
+	t_u16 band;
 	t_u8 is_bgscan_resp;
 	t_u32 age_ts_usec;
 	t_u8 null_ssid[MLAN_MAX_SSID_LENGTH] = {0};
@@ -4404,6 +4601,10 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 	PRINTM(MINFO, "SCAN_RESP: returned %d APs before parsing\n",
 	       pscan_rsp->number_of_sets);
 
+	/* Update the age_in_second */
+	pmadapter->callbacks.moal_get_system_time(
+		pmadapter->pmoal_handle, &pmadapter->age_in_secs, &age_ts_usec);
+
 	num_in_table = pmadapter->num_in_scan_table;
 	pbss_info = pscan_rsp->bss_desc_and_tlv_buffer;
 
@@ -4413,10 +4614,21 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 	 *   BSS Descriptions (bss_descript_size as bytesLef) and the command
 	 *   response header (S_DS_GEN)
 	 */
-	tlv_buf_size = scan_resp_size -
-		       (bytes_left + sizeof(pscan_rsp->bss_descript_size) +
-			sizeof(pscan_rsp->number_of_sets) + S_DS_GEN);
-	if (is_bgscan_resp)
+	if (scan_resp_size >
+	    (bytes_left + sizeof(pscan_rsp->bss_descript_size) +
+	     sizeof(pscan_rsp->number_of_sets) + S_DS_GEN)) {
+		tlv_buf_size =
+			(scan_resp_size -
+			 (bytes_left + sizeof(pscan_rsp->bss_descript_size) +
+			  sizeof(pscan_rsp->number_of_sets) + S_DS_GEN));
+	} else {
+		PRINTM(MERROR,
+		       "scan_resp_size: Incorrect size of TLV buff size.\n");
+	}
+
+	if (is_bgscan_resp &&
+	    (tlv_buf_size >
+	     sizeof(resp->params.bg_scan_query_resp.report_condition)))
 		tlv_buf_size -= sizeof(
 			resp->params.bg_scan_query_resp.report_condition);
 
@@ -4487,9 +4699,9 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 			 * for use in join
 			 */
 			bss_new_entry->bss_band = band;
-
+			bss_new_entry->age_in_secs = pmadapter->age_in_secs;
 			cfp = wlan_find_cfp_by_band_and_channel(
-				pmadapter, (t_u8)bss_new_entry->bss_band,
+				pmadapter, bss_new_entry->bss_band,
 				(t_u16)bss_new_entry->channel);
 			if (cfp)
 				bss_new_entry->freq = cfp->freq;
@@ -4633,9 +4845,6 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 
 	/* Update the total number of BSSIDs in the scan table */
 	pmadapter->num_in_scan_table = num_in_table;
-	/* Update the age_in_second */
-	pmadapter->callbacks.moal_get_system_time(
-		pmadapter->pmoal_handle, &pmadapter->age_in_secs, &age_ts_usec);
 	if (is_bgscan_resp)
 		goto done;
 	wlan_request_cmd_lock(pmadapter);
@@ -4721,6 +4930,26 @@ mlan_status wlan_ret_802_11_scan(mlan_private *pmpriv, HostCmd_DS_COMMAND *resp,
 	return ret;
 }
 
+/**
+ *  @brief Get ext_scan state from ext_scan_type
+ *
+ *
+ *  @param pcmd       A pointer to HostCmd_DS_COMMAND structure to be sent to
+ *                    firmware with the HostCmd_DS_802_11_SCAN_EXT structure
+ *
+ *  @return
+ * SCAN_STATE_EXT_SCAN_ENH/SCAN_STATE_EXT_SCAN_CANCEL/SCAN_STATE_EXT_SCAN_ENH
+ */
+t_u8 wlan_get_ext_scan_state(HostCmd_DS_COMMAND *pcmd)
+{
+	HostCmd_DS_802_11_SCAN_EXT *pext_scan_cmd = &pcmd->params.ext_scan;
+	if (pext_scan_cmd->ext_scan_type == EXT_SCAN_ENHANCE)
+		return SCAN_STATE_EXT_SCAN_ENH;
+	if (pext_scan_cmd->ext_scan_type == EXT_SCAN_CANCEL)
+		return SCAN_STATE_EXT_SCAN_CANCEL;
+	return SCAN_STATE_EXT_SCAN;
+}
+
 /**
  *  @brief Prepare an extended scan command to be sent to the firmware
  *
@@ -4763,6 +4992,11 @@ mlan_status wlan_cmd_802_11_scan_ext(mlan_private *pmpriv,
 			return MLAN_STATUS_SUCCESS;
 		}
 	}
+	if (!pdata_buf) {
+		PRINTM(MERROR, "wlan_cmd_802_11_scan_ext: pdata_buf is null\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 	pscan_cfg = (wlan_scan_cmd_config *)pdata_buf;
 
 	memcpy_ext(pmpriv->adapter, pext_scan_cmd->tlv_buffer,
@@ -4805,11 +5039,13 @@ mlan_status wlan_ret_802_11_scan_ext(mlan_private *pmpriv,
 	ENTER();
 
 	PRINTM(MINFO, "EXT scan returns successfully\n");
+	pmadapter->scan_state |= wlan_get_ext_scan_state(resp);
 	ext_scan_type = pext_scan_cmd->ext_scan_type;
 	if (ext_scan_type == EXT_SCAN_CANCEL) {
 		PRINTM(MCMND, "Cancel scan command completed!\n");
 		wlan_request_cmd_lock(pmadapter);
 		pmadapter->scan_processing = MFALSE;
+		pmadapter->scan_state |= SCAN_STATE_SCAN_COMPLETE;
 		pmadapter->ext_scan_type = EXT_SCAN_DEFAULT;
 		wlan_release_cmd_lock(pmadapter);
 		/* Need to indicate IOCTL complete */
@@ -4866,9 +5102,9 @@ mlan_status wlan_ret_802_11_scan_ext(mlan_private *pmpriv,
  *
  *  @return             N/A
  */
-t_void wlan_add_new_entry_to_scan_table(mlan_private *pmpriv,
-					BSSDescriptor_t *bss_new_entry,
-					t_u32 *num_in_tbl)
+static t_void wlan_add_new_entry_to_scan_table(mlan_private *pmpriv,
+					       BSSDescriptor_t *bss_new_entry,
+					       t_u32 *num_in_tbl)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	t_u32 bss_idx;
@@ -4959,6 +5195,415 @@ t_void wlan_add_new_entry_to_scan_table(mlan_private *pmpriv,
 	return;
 }
 
+/** 8 bytes timestamp, 2 bytest interval, 2 bytes capability */
+#define BEACON_FIX_SIZE 12
+
+/**
+ *  @brief This function realloc the beacon buffer and update ssid for new entry
+ *
+ *  @param pmadpater        A pointer to mlan_adapter structure
+ *  @param pbss_entry       A pointer to the bss_entry which has multi-bssid IE
+ *  @param pnew_entry       A pinter to new entry
+ *  @param pssid            A pointer to ssid IE
+ *
+ *  @return                MLAN_STATUS_FAILURE/MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_update_ssid_in_beacon_buf(
+	mlan_adapter *pmadapter, BSSDescriptor_t *pbss_entry,
+	BSSDescriptor_t *pnew_entry, IEEEtypes_Ssid_t *pssid,
+	IEEEtypes_ExtCap_t *pnew_extcap, IEEEtypes_Generic_t *pnew_rsnx)
+{
+	mlan_callbacks *pcb = (pmlan_callbacks)&pmadapter->callbacks;
+	t_u8 *pbeacon_buf = MNULL;
+	t_u32 beacon_buf_size = 0;
+	t_s8 offset = pnew_entry->ssid.ssid_len - pbss_entry->ssid.ssid_len;
+	IEEEtypes_ExtCap_t *pextcap;
+	mlan_status ret = MLAN_STATUS_FAILURE;
+	t_u32 rsnx_offset = 0;
+
+	if (pnew_entry->ssid.ssid_len >= pbss_entry->ssid.ssid_len)
+		beacon_buf_size =
+			pbss_entry->beacon_buf_size +
+			(pnew_entry->ssid.ssid_len - pbss_entry->ssid.ssid_len);
+	else
+		beacon_buf_size =
+			pbss_entry->beacon_buf_size -
+			(pbss_entry->ssid.ssid_len - pnew_entry->ssid.ssid_len);
+
+	rsnx_offset = beacon_buf_size;
+	if (pnew_rsnx)
+		beacon_buf_size +=
+			pnew_rsnx->ieee_hdr.len + sizeof(IEEEtypes_Header_t);
+
+	ret = pcb->moal_malloc(pmadapter->pmoal_handle, beacon_buf_size,
+			       MLAN_MEM_DEF, (t_u8 **)&pbeacon_buf);
+	if (ret != MLAN_STATUS_SUCCESS || !pbeacon_buf) {
+		PRINTM(MERROR,
+		       "Memory allocation for beacon buf for bss_new_entry\n");
+		goto done;
+	}
+	pnew_entry->beacon_buf_size = beacon_buf_size;
+	pnew_entry->pbeacon_buf = pbeacon_buf;
+	/** copy fixed IE */
+	memcpy_ext(pmadapter, pbeacon_buf, pbss_entry->pbeacon_buf,
+		   BEACON_FIX_SIZE, BEACON_FIX_SIZE);
+	/** copy new ssid ie */
+	memcpy_ext(pmadapter, pbeacon_buf + BEACON_FIX_SIZE, (t_u8 *)pssid,
+		   pssid->len + sizeof(IEEEtypes_Header_t),
+		   pssid->len + sizeof(IEEEtypes_Header_t));
+	/** copy left IE to new beacon buffer */
+	memcpy_ext(pmadapter,
+		   pbeacon_buf + BEACON_FIX_SIZE + pssid->len +
+			   sizeof(IEEEtypes_Header_t),
+		   pbss_entry->pbeacon_buf + BEACON_FIX_SIZE +
+			   pbss_entry->ssid.ssid_len +
+			   sizeof(IEEEtypes_Header_t),
+		   pbss_entry->beacon_buf_size - BEACON_FIX_SIZE -
+			   (pbss_entry->ssid.ssid_len +
+			    sizeof(IEEEtypes_Header_t)),
+		   pbss_entry->beacon_buf_size - BEACON_FIX_SIZE -
+			   (pbss_entry->ssid.ssid_len +
+			    sizeof(IEEEtypes_Header_t)));
+
+	/* adjust the ie pointer */
+	if (pnew_entry->pwpa_ie)
+		pnew_entry->wpa_offset += offset;
+	if (pnew_entry->prsn_ie)
+		pnew_entry->rsn_offset += offset;
+	if (pnew_entry->pwapi_ie)
+		pnew_entry->wapi_offset += offset;
+
+	if (pnew_entry->posen_ie)
+		pnew_entry->osen_offset += offset;
+	if (pnew_entry->pmd_ie)
+		pnew_entry->md_offset += offset;
+	if (pnew_entry->pht_cap)
+		pnew_entry->ht_cap_offset += offset;
+	if (pnew_entry->pht_info)
+		pnew_entry->ht_info_offset += offset;
+	if (pnew_entry->pbss_co_2040)
+		pnew_entry->bss_co_2040_offset += offset;
+	if (pnew_entry->pext_cap) {
+		pnew_entry->ext_cap_offset += offset;
+		if (pnew_extcap) {
+			pextcap = (IEEEtypes_ExtCap_t
+					   *)(pnew_entry->pbeacon_buf +
+					      pnew_entry->ext_cap_offset);
+			memcpy_ext(pmadapter,
+				   pbeacon_buf + pnew_entry->ext_cap_offset,
+				   (t_u8 *)pnew_extcap,
+				   pnew_extcap->ieee_hdr.len +
+					   sizeof(IEEEtypes_Header_t),
+				   pextcap->ieee_hdr.len +
+					   sizeof(IEEEtypes_Header_t));
+		}
+	}
+	if (pnew_entry->poverlap_bss_scan_param)
+		pnew_entry->overlap_bss_offset += offset;
+	if (pnew_entry->pvht_cap)
+		pnew_entry->vht_cap_offset += offset;
+	if (pnew_entry->pvht_oprat)
+		pnew_entry->vht_oprat_offset += offset;
+	if (pnew_entry->pvht_txpower)
+		pnew_entry->vht_txpower_offset += offset;
+	if (pnew_entry->pext_pwer)
+		pnew_entry->ext_pwer_offset += offset;
+	if (pnew_entry->pext_bssload)
+		pnew_entry->ext_bssload_offset += offset;
+	if (pnew_entry->pquiet_chan)
+		pnew_entry->quiet_chan_offset += offset;
+	if (pnew_entry->poper_mode)
+		pnew_entry->oper_mode_offset += offset;
+	if (pnew_entry->phe_cap)
+		pnew_entry->he_cap_offset += offset;
+	if (pnew_entry->phe_oprat)
+		pnew_entry->he_oprat_offset += offset;
+	if (pnew_rsnx)
+		memcpy_ext(
+			pmadapter, pbeacon_buf + rsnx_offset, (t_u8 *)pnew_rsnx,
+			pnew_rsnx->ieee_hdr.len + sizeof(IEEEtypes_Header_t),
+			pnew_rsnx->ieee_hdr.len + sizeof(IEEEtypes_Header_t));
+	DBG_HEXDUMP(MCMD_D, "MBSSID beacon buf", pbeacon_buf, beacon_buf_size);
+	ret = MLAN_STATUS_SUCCESS;
+done:
+	return ret;
+}
+
+/**
+ *  @brief This function generate the bssid from bssid_idx
+ *
+ *  @param pmadpater        A pointer to mlan_adapter structure
+ *  @param pbss_entry       A pointer to the bss_entry which has multi-bssid IE
+ *  @param pnew_entry       A pinter to new entry
+ *  @param bssid_index      bssid_index from BSSID_IDX IE
+ *
+ *  @return                N/A
+ */
+static void wlan_gen_multi_bssid_by_bssid_index(pmlan_adapter pmadapter,
+						BSSDescriptor_t *pbss_entry,
+						BSSDescriptor_t *pnew_entry,
+						t_u8 bssid_index,
+						t_u8 max_bssid_indicator)
+{
+	t_u8 mask = 0xff;
+	t_u8 new_bssid[6];
+	t_u8 bssid_a;
+	t_u8 src_bssid[6];
+
+	memcpy_ext(pmadapter, (t_u8 *)src_bssid, pbss_entry->mac_address,
+		   sizeof(mlan_802_11_mac_addr), sizeof(src_bssid));
+	memcpy_ext(pmadapter, (t_u8 *)new_bssid,
+		   (t_u8 *)&pbss_entry->mac_address,
+		   sizeof(mlan_802_11_mac_addr), sizeof(new_bssid));
+
+	mask = (mask >> (8 - max_bssid_indicator));
+	bssid_a = src_bssid[5] & (~mask);
+	src_bssid[5] = (src_bssid[5] + bssid_index) & mask;
+	new_bssid[5] = bssid_a | src_bssid[5];
+
+	memcpy_ext(pmadapter, (t_u8 *)&pnew_entry->mac_address, new_bssid,
+		   sizeof(new_bssid), sizeof(mlan_802_11_mac_addr));
+	memcpy_ext(pmadapter, (t_u8 *)&pnew_entry->multi_bssid_ap_addr,
+		   (t_u8 *)&pbss_entry->mac_address,
+		   sizeof(mlan_802_11_mac_addr), sizeof(mlan_802_11_mac_addr));
+}
+
+/**
+ *  @brief This function parse the non_trans_bssid_profile
+ *
+ *  @param pmadapter        A pointer to mlan_adapter structure
+ *  @param pbss_entry       A pointer to BSSDescriptor_t which has multi-bssid
+ * IE
+ *  @param pbss_profile     A pointer to IEEEtypes_NonTransBSSIDprofile_t
+ *  @param num_in_table     A pointer to buffer to save num of entry in scan
+ * table.
+ *  @param  max_bssid_indicator max bssid indicator
+ *
+ *  @return                 N/A
+ */
+static t_void wlan_parse_non_trans_bssid_profile(
+	mlan_private *pmpriv, BSSDescriptor_t *pbss_entry,
+	IEEEtypes_NonTransBSSIDProfile_t *pbss_profile, t_u32 *num_in_table,
+	t_u8 max_bssid_indicator)
+{
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	IEEEtypes_Header_t *pheader =
+		(IEEEtypes_Header_t *)pbss_profile->profile_data;
+	IEEEtypes_MultiBSSIDIndex_t *pbssid_index = MNULL;
+	IEEEtypes_Ssid_t *pssid = MNULL;
+	IEEEtypes_NotxBssCap_t *pcap =
+		(IEEEtypes_NotxBssCap_t *)pbss_profile->profile_data;
+	t_u8 *pos = pbss_profile->profile_data;
+	t_s8 left_len = pbss_profile->ieee_hdr.len;
+	t_u8 ret = MFALSE;
+	mlan_callbacks *pcb = (pmlan_callbacks)&pmadapter->callbacks;
+	BSSDescriptor_t *bss_new_entry = MNULL;
+	t_u8 *pbeacon_buf = MNULL;
+	IEEEtypes_ExtCap_t *pextcap = MNULL;
+	IEEEtypes_Generic_t *prsnx = MNULL;
+
+	ENTER();
+
+	/* The first element within the Nontransmitted
+	 * BSSID Profile is not the Nontransmitted
+	 * BSSID Capability element.
+	 */
+	if (pcap->element_id != NONTX_BSSID_CAP || pcap->len != 2) {
+		PRINTM(MERROR,
+		       "The first element within the Nontransmitted BSSID Profile is not the NontransmittedBSSID Capability element\n");
+		LEAVE();
+		return;
+	}
+
+	while (left_len >= 2) {
+		pheader = (IEEEtypes_Header_t *)pos;
+		if ((t_s8)(pheader->len + sizeof(IEEEtypes_Header_t)) >
+		    left_len) {
+			PRINTM(MMSG, "invalid IE length = %d left len %d\n",
+			       pheader->len, left_len);
+			break;
+		}
+		switch (pheader->element_id) {
+		case MBSSID_INDEX:
+			pbssid_index = (IEEEtypes_MultiBSSIDIndex_t *)pos;
+			if (pbssid_index->bssid_index == 0 ||
+			    pbssid_index->bssid_index > 46) {
+				PRINTM(MERROR,
+				       " No valid Multiple BSSID-Index element\n");
+				goto done;
+			}
+			PRINTM(MCMND, "MBSSID: Find mbssid_index=%d\n",
+			       pbssid_index->bssid_index);
+			ret = MTRUE;
+			break;
+		case EXT_CAPABILITY:
+			pextcap = (IEEEtypes_ExtCap_t *)pos;
+			DBG_HEXDUMP(MCMD_D, "MBSSID extcap", pos,
+				    pextcap->ieee_hdr.len +
+					    sizeof(IEEEtypes_Header_t));
+			break;
+		case RSNX_IE:
+			prsnx = (IEEEtypes_Generic_t *)pos;
+			DBG_HEXDUMP(MCMD_D, "MBSSID RSNX", pos,
+				    prsnx->ieee_hdr.len +
+					    sizeof(IEEEtypes_Header_t));
+			break;
+		case SSID:
+			pssid = (IEEEtypes_Ssid_t *)pos;
+			PRINTM(MCMND, "MBSSID: Find mbssid ssid=%s\n",
+			       pssid->ssid);
+			break;
+		default:
+			break;
+		}
+		left_len -= pheader->len + sizeof(IEEEtypes_Header_t);
+		pos += pheader->len + sizeof(IEEEtypes_Header_t);
+	}
+	if (ret == MTRUE) {
+		ret = pcb->moal_malloc(pmadapter->pmoal_handle,
+				       sizeof(BSSDescriptor_t), MLAN_MEM_DEF,
+				       (t_u8 **)&bss_new_entry);
+		if (ret != MLAN_STATUS_SUCCESS || !bss_new_entry) {
+			PRINTM(MERROR,
+			       "Memory allocation for bss_new_entry failed!\n");
+			goto done;
+		}
+		memcpy_ext(pmadapter, bss_new_entry, pbss_entry,
+			   sizeof(BSSDescriptor_t), sizeof(BSSDescriptor_t));
+		wlan_gen_multi_bssid_by_bssid_index(pmadapter, pbss_entry,
+						    bss_new_entry,
+						    pbssid_index->bssid_index,
+						    max_bssid_indicator);
+		if (pssid) {
+			memset(pmadapter, (t_u8 *)&bss_new_entry->ssid, 0,
+			       sizeof(mlan_802_11_ssid));
+			bss_new_entry->ssid.ssid_len = pssid->len;
+			memcpy_ext(pmadapter, bss_new_entry->ssid.ssid,
+				   pssid->ssid, pssid->len,
+				   MLAN_MAX_SSID_LENGTH);
+			if (MLAN_STATUS_SUCCESS !=
+			    wlan_update_ssid_in_beacon_buf(
+				    pmadapter, pbss_entry, bss_new_entry, pssid,
+				    pextcap, prsnx)) {
+				PRINTM(MERROR,
+				       "Fail to update MBSSID beacon buf\n");
+				pcb->moal_mfree(pmadapter->pmoal_handle,
+						(t_u8 *)bss_new_entry);
+				goto done;
+			}
+			pbeacon_buf = bss_new_entry->pbeacon_buf;
+		}
+		memcpy_ext(pmadapter, &bss_new_entry->cap_info, &pcap->cap,
+			   sizeof(IEEEtypes_CapInfo_t),
+			   sizeof(IEEEtypes_CapInfo_t));
+		bss_new_entry->multi_bssid_ap = MULTI_BSSID_SUB_AP;
+		wlan_add_new_entry_to_scan_table(pmpriv, bss_new_entry,
+						 num_in_table);
+		if (pssid && pbeacon_buf)
+			pcb->moal_mfree(pmadapter->pmoal_handle,
+					(t_u8 *)pbeacon_buf);
+		pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)bss_new_entry);
+	}
+done:
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function parse the multi_bssid IE from pbss_entry
+ *
+ *  @param pmpriv        A pointer to mlan_private structure
+ *  @param pbss_entry       A pointer to BSSDescriptor_t which has multi-bssid
+ * IE
+ *  @param num_in_table     A pointer to buffer to save num of entry in scan
+ * table.
+ *
+ *  @return                 number entry in scan table
+ */
+static t_void wlan_parse_multi_bssid_ie(mlan_private *pmpriv,
+					BSSDescriptor_t *pbss_entry,
+					IEEEtypes_MultiBSSID_t *pmulti_bssid,
+					t_u32 *num_in_table)
+{
+	t_u32 bytes_left = 0;
+	t_u8 *pcurrent_ptr = MNULL;
+	IEEEtypes_NonTransBSSIDProfile_t *pbssid_profile = MNULL;
+
+	if (!pmulti_bssid)
+		return;
+	bytes_left = pmulti_bssid->ieee_hdr.len - 1;
+	pcurrent_ptr = pmulti_bssid->sub_elem_data;
+	while (bytes_left >= 2) {
+		pbssid_profile =
+			(IEEEtypes_NonTransBSSIDProfile_t *)pcurrent_ptr;
+		if (pbssid_profile->ieee_hdr.element_id !=
+		    NONTRANS_BSSID_PROFILE_SUBELEM_ID) {
+			PRINTM(MERROR, "Invalid multi-bssid IE\n");
+			break;
+		}
+		if (bytes_left < (t_u32)(pbssid_profile->ieee_hdr.len + 2)) {
+			PRINTM(MERROR, "Invalid multi-bssid IE\n");
+			break;
+		}
+		wlan_parse_non_trans_bssid_profile(
+			pmpriv, pbss_entry, pbssid_profile, num_in_table,
+			pmulti_bssid->max_bssid_indicator);
+		pcurrent_ptr += pbssid_profile->ieee_hdr.len + 2;
+		bytes_left -= pbssid_profile->ieee_hdr.len + 2;
+	}
+	return;
+}
+
+/**
+ *  @brief This function search all the mbssid IE in the beacon buffer
+ *
+ *  @param pmpriv           A pointer to mlan_private structure
+ *  @param pbss_entry       A pointer to BSSDescriptor_t which has multi-bssid
+ * IE
+ *  @param num_in_table     A pointer to buffer to save num of entry in scan
+ * table.
+ *
+ *  @return                 N/A
+ */
+static void wlan_parse_multi_bssid_ap(mlan_private *pmpriv,
+				      BSSDescriptor_t *pbss_entry,
+				      t_u32 *num_in_table)
+{
+	IEEEtypes_ElementId_e element_id;
+	t_u8 element_len;
+	t_u16 total_ie_len;
+	t_u32 bytes_left = pbss_entry->beacon_buf_size - BEACON_FIX_SIZE;
+	t_u8 *pcurrent_ptr = pbss_entry->pbeacon_buf + BEACON_FIX_SIZE;
+	IEEEtypes_Ssid_t *pssid = (IEEEtypes_Ssid_t *)pcurrent_ptr;
+
+	if (pssid->element_id != SSID) {
+		PRINTM(MERROR,
+		       "Invalid beacon ie, ssid should be in the first element\n");
+		return;
+	}
+	/* Process variable IE */
+	while (bytes_left >= 2) {
+		element_id = (IEEEtypes_ElementId_e)(*((t_u8 *)pcurrent_ptr));
+		element_len = *((t_u8 *)pcurrent_ptr + 1);
+		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
+
+		if (bytes_left < total_ie_len) {
+			//PRINTM(MERROR, "InterpretIE: Error in processing IE, "
+			//	       "bytes left < IE length\n");
+			bytes_left = 0;
+			continue;
+		}
+		if (element_id == MULTI_BSSID)
+			wlan_parse_multi_bssid_ie(
+				pmpriv, pbss_entry,
+				(IEEEtypes_MultiBSSID_t *)pcurrent_ptr,
+				num_in_table);
+		pcurrent_ptr += total_ie_len;
+		bytes_left -= total_ie_len;
+	}
+	return;
+}
+
 /**
  *  @brief This function parse and store the extended scan results
  *
@@ -4989,7 +5634,7 @@ static mlan_status wlan_parse_ext_scan_result(mlan_private *pmpriv,
 	MrvlIEtypes_Data_t *ptlv = MNULL;
 	MrvlIEtypes_Bss_Scan_Rsp_t *pscan_rsp_tlv = MNULL;
 	MrvlIEtypes_Bss_Scan_Info_t *pscan_info_tlv = MNULL;
-	t_u8 band;
+	t_u16 band;
 	t_u32 age_ts_usec;
 
 	ENTER();
@@ -5007,6 +5652,9 @@ static mlan_status wlan_parse_ext_scan_result(mlan_private *pmpriv,
 	PRINTM(MINFO, "EXT_SCAN: bss_descript_size %d\n", scan_resp_size);
 	PRINTM(MINFO, "EXT_SCAN: returned %d APs before parsing\n",
 	       number_of_sets);
+	/* Update the age_in_second */
+	pmadapter->callbacks.moal_get_system_time(
+		pmadapter->pmoal_handle, &pmadapter->age_in_secs, &age_ts_usec);
 
 	num_in_table = pmadapter->num_in_scan_table;
 	ptlv = (MrvlIEtypes_Data_t *)pscan_resp;
@@ -5140,9 +5788,10 @@ static mlan_status wlan_parse_ext_scan_result(mlan_private *pmpriv,
 			/* Save the band designation for this entry for use in
 			 * join */
 			bss_new_entry->bss_band = band;
+			bss_new_entry->age_in_secs = pmadapter->age_in_secs;
 
 			cfp = wlan_find_cfp_by_band_and_channel(
-				pmadapter, (t_u8)bss_new_entry->bss_band,
+				pmadapter, bss_new_entry->bss_band,
 				(t_u16)bss_new_entry->channel);
 			if (cfp)
 				bss_new_entry->freq = cfp->freq;
@@ -5155,13 +5804,20 @@ static mlan_status wlan_parse_ext_scan_result(mlan_private *pmpriv,
 				       "EXT_SCAN: dropping entry on blacklist channel.\n");
 				continue;
 			}
+			if (IS_FW_SUPPORT_MULTIBSSID(pmadapter)) {
+				if (bss_new_entry->multi_bssid_ap ==
+				    MULTI_BSSID_AP)
+					wlan_parse_multi_bssid_ap(
+						pmpriv, bss_new_entry,
+						&num_in_table);
+			}
 			wlan_add_new_entry_to_scan_table(pmpriv, bss_new_entry,
 							 &num_in_table);
 
 		} else {
 			/* Error parsing/interpreting the scan response, skipped
 			 */
-			PRINTM(MERROR,
+			PRINTM(MINFO,
 			       "EXT_SCAN: wlan_interpret_bss_desc_with_ie returned error\n");
 		}
 	}
@@ -5209,6 +5865,13 @@ mlan_status wlan_handle_event_ext_scan_report(mlan_private *pmpriv,
 
 	DBG_HEXDUMP(MCMD_D, "EVENT EXT_SCAN", pmbuf->pbuf + pmbuf->data_offset,
 		    pmbuf->data_len);
+
+	if (!pevent_scan->more_event)
+		pmadapter->scan_state |= SCAN_STATE_EXT_SCAN_RESULT |
+					 SCAN_STATE_LAST_EXT_SCAN_RESULT;
+	else
+		pmadapter->scan_state |= SCAN_STATE_EXT_SCAN_RESULT;
+
 	wlan_parse_ext_scan_result(pmpriv, pevent_scan->num_of_set, ptlv,
 				   tlv_buf_left);
 	if (!pevent_scan->more_event &&
@@ -5242,6 +5905,7 @@ mlan_status wlan_handle_event_ext_scan_report(mlan_private *pmpriv,
 			wlan_scan_process_results(pmpriv);
 			wlan_request_cmd_lock(pmadapter);
 			pmadapter->scan_processing = MFALSE;
+			pmadapter->scan_state |= SCAN_STATE_SCAN_COMPLETE;
 			pioctl_req = pmadapter->pscan_ioctl_req;
 			pmadapter->pscan_ioctl_req = MNULL;
 			/* Need to indicate IOCTL complete */
@@ -5267,6 +5931,9 @@ mlan_status wlan_handle_event_ext_scan_report(mlan_private *pmpriv,
 				wlan_flush_scan_queue(pmadapter);
 				wlan_request_cmd_lock(pmadapter);
 				pmadapter->scan_processing = MFALSE;
+				pmadapter->scan_state |=
+					SCAN_STATE_SCAN_COMPLETE;
+
 				pioctl_req = pmadapter->pscan_ioctl_req;
 				pmadapter->pscan_ioctl_req = MNULL;
 				/* Indicate IOCTL complete */
@@ -5317,7 +5984,8 @@ mlan_status wlan_handle_event_ext_scan_status(mlan_private *pmpriv,
 	t_u16 tlv_buf_left, tlv_len, tlv_type;
 	MrvlIEtypesHeader_t *tlv;
 	MrvlIEtypes_ChannelStats_t *tlv_chan_stats;
-	t_u8 status;
+	t_u8 status = 0;
+	cmd_ctrl_node *pcmd_node = MNULL;
 
 	ENTER();
 
@@ -5326,6 +5994,7 @@ mlan_status wlan_handle_event_ext_scan_status(mlan_private *pmpriv,
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
+	pmadapter->scan_state |= SCAN_STATE_EXT_SCAN_STATUS;
 
 	scan_event =
 		(pmlan_event_scan_status)(pmbuf->pbuf + pmbuf->data_offset);
@@ -5361,6 +6030,47 @@ mlan_status wlan_handle_event_ext_scan_status(mlan_private *pmpriv,
 	}
 
 done:
+	wlan_request_cmd_lock(pmadapter);
+	if (util_peek_list(pmadapter->pmoal_handle, &pmadapter->scan_pending_q,
+			   MNULL, MNULL)) {
+		/* If firmware not ready, do not issue any more scan
+		 * commands */
+		if (pmadapter->hw_status != WlanHardwareStatusReady) {
+			wlan_release_cmd_lock(pmadapter);
+			/* Flush all pending scan commands */
+			wlan_flush_scan_queue(pmadapter);
+			wlan_request_cmd_lock(pmadapter);
+			pmadapter->scan_processing = MFALSE;
+			pmadapter->scan_state |= SCAN_STATE_SCAN_COMPLETE;
+			pioctl_req = pmadapter->pscan_ioctl_req;
+			pmadapter->pscan_ioctl_req = MNULL;
+			/* Indicate IOCTL complete */
+			if (pioctl_req != MNULL) {
+				pioctl_req->status_code =
+					MLAN_ERROR_FW_NOT_READY;
+
+				/* Indicate ioctl complete */
+				pcb->moal_ioctl_complete(
+					pmadapter->pmoal_handle,
+					(pmlan_ioctl_req)pioctl_req,
+					MLAN_STATUS_FAILURE);
+			}
+			wlan_release_cmd_lock(pmadapter);
+		} else {
+			/* Get scan command from scan_pending_q and put
+			 * to cmd_pending_q */
+			pcmd_node = (cmd_ctrl_node *)util_dequeue_list(
+				pmadapter->pmoal_handle,
+				&pmadapter->scan_pending_q, MNULL, MNULL);
+			wlan_insert_cmd_to_pending_q(pmadapter, pcmd_node,
+						     MTRUE);
+			wlan_release_cmd_lock(pmadapter);
+		}
+		LEAVE();
+		return ret;
+	}
+	wlan_release_cmd_lock(pmadapter);
+
 	/* Now we got response from FW, cancel the command timer */
 	if (!pmadapter->curr_cmd && pmadapter->cmd_timer_is_set) {
 		/* Cancel command timeout timer */
@@ -5392,7 +6102,7 @@ mlan_status wlan_handle_event_ext_scan_status(mlan_private *pmpriv,
 	/** Complete scan ioctl */
 	wlan_request_cmd_lock(pmadapter);
 	pmadapter->scan_processing = MFALSE;
-	pmadapter->ext_scan_type = EXT_SCAN_DEFAULT;
+	pmadapter->scan_state |= SCAN_STATE_SCAN_COMPLETE;
 	pioctl_req = pmadapter->pscan_ioctl_req;
 	pmadapter->pscan_ioctl_req = MNULL;
 	/* Need to indicate IOCTL complete */
@@ -5403,8 +6113,10 @@ mlan_status wlan_handle_event_ext_scan_status(mlan_private *pmpriv,
 					 MLAN_STATUS_SUCCESS);
 	}
 	wlan_release_cmd_lock(pmadapter);
+	wlan_move_cmd_to_cmd_pending_q(pmadapter);
 	pmadapter->bgscan_reported = MFALSE;
-	wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_SCAN_REPORT, MNULL);
+	if (!status)
+		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_SCAN_REPORT, MNULL);
 	LEAVE();
 	return ret;
 }
@@ -5451,10 +6163,9 @@ mlan_status wlan_cmd_802_11_bg_scan_query(mlan_private *pmpriv,
  *
  *  @return                 channel number
  */
-static t_u8
-wlan_bgscan_create_channel_list(mlan_private *pmpriv,
-				const wlan_bgscan_cfg *pbg_scan_in,
-				MrvlIEtypes_ChanListParamSet_t *tlv_chan_list)
+static t_u8 wlan_bgscan_create_channel_list(
+	mlan_private *pmpriv, const wlan_bgscan_cfg *pbg_scan_in,
+	MrvlIEtypes_ChanListParamSet_t *tlv_chan_list, t_u8 max_bgscan_chan)
 {
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	region_chan_t *pscan_region;
@@ -5464,7 +6175,7 @@ wlan_bgscan_create_channel_list(mlan_private *pmpriv,
 	t_u32 next_chan;
 	t_u8 scan_type;
 	t_u8 radio_type;
-	t_u8 band;
+	t_u16 band;
 
 	ENTER();
 
@@ -5503,7 +6214,7 @@ wlan_bgscan_create_channel_list(mlan_private *pmpriv,
 			continue;
 		for (next_chan = 0; next_chan < pscan_region->num_cfp;
 		     next_chan++, chan_idx++) {
-			if (chan_idx >= WLAN_BG_SCAN_CHAN_MAX)
+			if (chan_idx >= max_bgscan_chan)
 				break;
 			/*
 			 * Set the default scan type to ACTIVE SCAN type, will
@@ -5611,6 +6322,7 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 	MrvlIETypes_HTCap_t *pht_cap = MNULL;
 	MrvlIETypes_VHTCap_t *pvht_cap = MNULL;
 	MrvlIEtypes_Extension_t *phe_cap = MNULL;
+	MrvlIEtypes_ScanChanGap_t *pscan_gap_tlv;
 	t_u16 len = 0;
 
 	t_u8 index;
@@ -5623,11 +6335,22 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 	t_u8 radio_type;
 	t_u16 scan_dur;
 	t_u8 scan_type;
-	t_u8 band;
+	t_u16 band;
+	t_u8 max_bgscan_chan = 0;
+	t_u16 scan_chan_gap = 0;
 	const t_u8 zero_mac[6] = {0, 0, 0, 0, 0, 0};
 
 	ENTER();
 
+	max_bgscan_chan = WLAN_BG_SCAN_CHAN_MAX;
+
+#if defined(SD9177)
+	if (IS_CARD9177(pmadapter->card_type))
+		max_bgscan_chan = WLAN_BG_SCAN_CHAN_MAX_UNII_4;
+#endif
+
+	PRINTM(MCMND, "max_bgscan_chan=%d\n", max_bgscan_chan);
+
 	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_802_11_BG_SCAN_CONFIG);
 	bg_scan->action = wlan_cpu_to_le16(bg_scan_in->action);
 	bg_scan->enable = bg_scan_in->enable;
@@ -5695,6 +6418,22 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 		tlv += sizeof(MrvlIEtypes_RepeatCount_t);
 		cmd_size += sizeof(MrvlIEtypes_RepeatCount_t);
 	}
+	scan_chan_gap = (bg_scan_in->scan_chan_gap ? bg_scan_in->scan_chan_gap :
+						     pmadapter->scan_chan_gap);
+	if (scan_chan_gap) {
+		pscan_gap_tlv = (MrvlIEtypes_ScanChanGap_t *)tlv;
+		PRINTM(MCMND, "bgScan: channel gap = 0x%x\n", scan_chan_gap);
+		pscan_gap_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_SCAN_CHANNEL_GAP);
+		pscan_gap_tlv->header.len = sizeof(pscan_gap_tlv->gap);
+		pscan_gap_tlv->gap =
+			wlan_cpu_to_le16((t_u16)pmadapter->scan_chan_gap);
+		/** indicate FW, gap is optional */
+		pscan_gap_tlv->gap |= GAP_FLAG_OPTIONAL;
+		tlv += sizeof(pscan_gap_tlv->header) +
+		       pscan_gap_tlv->header.len;
+		cmd_size += sizeof(MrvlIEtypes_ScanChanGap_t);
+	}
 	for (ssid_idx = 0; ((ssid_idx < NELEMENTS(bg_scan_in->ssid_list)) &&
 			    (*bg_scan_in->ssid_list[ssid_idx].ssid ||
 			     bg_scan_in->ssid_list[ssid_idx].max_len));
@@ -5725,7 +6464,7 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 		tlv_chan_list = (MrvlIEtypes_ChanListParamSet_t *)tlv;
 		PRINTM(MINFO, "Scan: Using supplied channel list\n");
 		chan_num = 0;
-		for (chan_idx = 0; chan_idx < WLAN_BG_SCAN_CHAN_MAX &&
+		for (chan_idx = 0; chan_idx < max_bgscan_chan &&
 				   bg_scan_in->chan_list[chan_idx].chan_number;
 		     chan_idx++) {
 			radio_type = bg_scan_in->chan_list[chan_idx].radio_type;
@@ -5781,6 +6520,15 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 						pmadapter->specific_scan_time;
 				}
 			}
+			PRINTM(MCMD_D,
+			       "BGScan: Chan(%3d), bandcfg(%x), Mode(%d), Dur(%d)\n",
+			       tlv_chan_list->chan_scan_param[chan_num]
+				       .chan_number,
+			       tlv_chan_list->chan_scan_param[chan_num].bandcfg,
+			       tlv_chan_list->chan_scan_param[chan_num]
+				       .chan_scan_mode.passive_scan,
+			       scan_dur);
+
 			tlv_chan_list->chan_scan_param[chan_num].min_scan_time =
 				wlan_cpu_to_le16(scan_dur);
 			tlv_chan_list->chan_scan_param[chan_num].max_scan_time =
@@ -5797,8 +6545,8 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 			    sizeof(ChanScanParamSet_t) * chan_num;
 	} else {
 		tlv_chan_list = (MrvlIEtypes_ChanListParamSet_t *)tlv;
-		chan_num = wlan_bgscan_create_channel_list(pmpriv, bg_scan_in,
-							   tlv_chan_list);
+		chan_num = wlan_bgscan_create_channel_list(
+			pmpriv, bg_scan_in, tlv_chan_list, max_bgscan_chan);
 		tlv_chan_list->header.type =
 			wlan_cpu_to_le16(TLV_TYPE_CHANLIST);
 		tlv_chan_list->header.len =
@@ -5809,7 +6557,8 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 			    sizeof(ChanScanParamSet_t) * chan_num;
 	}
 	if (bg_scan_in->chan_per_scan) {
-		bg_scan->chan_per_scan = bg_scan_in->chan_per_scan;
+		bg_scan->chan_per_scan =
+			MIN(max_bgscan_chan, bg_scan_in->chan_per_scan);
 	} else {
 		if (bg_scan_in->report_condition & BG_SCAN_WAIT_ALL_CHAN_DONE)
 			bg_scan->chan_per_scan = chan_num;
@@ -5848,9 +6597,11 @@ mlan_status wlan_cmd_bgscan_config(mlan_private *pmpriv,
 	}
 
 	if (IS_FW_SUPPORT_11AX(pmadapter) &&
-	    (pmpriv->config_bands & BAND_AAX)) {
+	    ((pmpriv->config_bands & BAND_GAX) ||
+	     (pmpriv->config_bands & BAND_AAX))) {
 		phe_cap = (MrvlIEtypes_Extension_t *)tlv;
-		len = wlan_fill_he_cap_tlv(pmpriv, BAND_A, phe_cap, MFALSE);
+		len = wlan_fill_he_cap_tlv(pmpriv, pmpriv->config_bands,
+					   phe_cap, MFALSE);
 		DBG_HEXDUMP(MCMD_D, "BGSCAN: HE_CAPABILITIES IE",
 			    (t_u8 *)phe_cap, len);
 		tlv += len;
@@ -6083,7 +6834,12 @@ mlan_status wlan_ret_802_11_bgscan_query(mlan_private *pmpriv,
 {
 	mlan_ds_scan *pscan = MNULL;
 	mlan_adapter *pmadapter = pmpriv->adapter;
+	t_u8 i;
 	ENTER();
+	for (i = 0; i < pmadapter->num_in_chan_stats; i++)
+		pmadapter->pchan_stats[i].cca_scan_duration = 0;
+	pmadapter->idx_chan_stats = 0;
+
 	wlan_ret_802_11_scan(pmpriv, resp, MNULL);
 	if (pioctl_buf) {
 		pscan = (mlan_ds_scan *)pioctl_buf->pbuf;
@@ -6359,7 +7115,8 @@ mlan_status wlan_scan_specific_ssid(mlan_private *pmpriv, t_void *pioctl_buf,
 	wlan_scan_delete_ssid_table_entry(pmpriv, preq_ssid);
 
 	ret = pcb->moal_malloc(pmpriv->adapter->pmoal_handle,
-			       sizeof(wlan_user_scan_cfg), MLAN_MEM_DEF,
+			       sizeof(wlan_user_scan_cfg),
+			       MLAN_MEM_DEF | MLAN_MEM_FLAG_ATOMIC,
 			       (t_u8 **)&pscan_cfg);
 
 	if (ret != MLAN_STATUS_SUCCESS || !pscan_cfg) {
@@ -6370,8 +7127,6 @@ mlan_status wlan_scan_specific_ssid(mlan_private *pmpriv, t_void *pioctl_buf,
 		goto done;
 	}
 
-	memset(pmpriv->adapter, pscan_cfg, 0x00, sizeof(wlan_user_scan_cfg));
-
 	memcpy_ext(pmpriv->adapter, pscan_cfg->ssid_list[0].ssid,
 		   preq_ssid->ssid, preq_ssid->ssid_len, MLAN_MAX_SSID_LENGTH);
 	pscan_cfg->keep_previous_scan = MFALSE;
@@ -6422,7 +7177,8 @@ t_void wlan_save_curr_bcn(mlan_private *pmpriv)
 		if (pmpriv->curr_bcn_size) {
 			ret = pcb->moal_malloc(pmadapter->pmoal_handle,
 					       pcurr_bss->beacon_buf_size,
-					       MLAN_MEM_DEF,
+					       MLAN_MEM_DEF |
+						       MLAN_MEM_FLAG_ATOMIC,
 					       &pmpriv->pcurr_bcn_buf);
 
 			if ((ret == MLAN_STATUS_SUCCESS) &&
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c
old mode 100644
new mode 100755
index b88c4fdb3..bfcb1cb26
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.c
@@ -3,7 +3,7 @@
  *  @brief This file contains SDIO specific code
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -40,6 +40,337 @@ Change log:
 /********************************************************
 		Local Variables
 ********************************************************/
+#ifdef SD8887
+static const struct _mlan_sdio_card_reg mlan_reg_sd8887 = {
+	.start_rd_port = 0,
+	.start_wr_port = 0,
+	.base_0_reg = 0x6C,
+	.base_1_reg = 0x6D,
+	.poll_reg = 0x5C,
+	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
+			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
+	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
+			   DN_LD_CMD_PORT_HOST_INT_STATUS |
+			   UP_LD_CMD_PORT_HOST_INT_STATUS,
+	.status_reg_0 = 0x90,
+	.status_reg_1 = 0x91,
+	.sdio_int_mask = 0xff,
+	.data_port_mask = 0xffffffff,
+	.max_mp_regs = 196,
+	.rd_bitmap_l = 0x10,
+	.rd_bitmap_u = 0x11,
+	.rd_bitmap_1l = 0x12,
+	.rd_bitmap_1u = 0x13,
+	.wr_bitmap_l = 0x14,
+	.wr_bitmap_u = 0x15,
+	.wr_bitmap_1l = 0x16,
+	.wr_bitmap_1u = 0x17,
+	.rd_len_p0_l = 0x18,
+	.rd_len_p0_u = 0x19,
+	.card_config_2_1_reg = 0xD9,
+	.cmd_config_0 = 0xC4,
+	.cmd_config_1 = 0xC5,
+	.cmd_config_2 = 0xC6,
+	.cmd_config_3 = 0xC7,
+	.cmd_rd_len_0 = 0xC0,
+	.cmd_rd_len_1 = 0xC1,
+	.cmd_rd_len_2 = 0xC2,
+	.cmd_rd_len_3 = 0xC3,
+	.io_port_0_reg = 0xE4,
+	.io_port_1_reg = 0xE5,
+	.io_port_2_reg = 0xE6,
+	.host_int_rsr_reg = 0x04,
+	.host_int_mask_reg = 0x08,
+	.host_int_status_reg = 0x0C,
+	.host_restart_reg = 0x58,
+	.card_to_host_event_reg = 0x5C,
+	.host_interrupt_mask_reg = 0x60,
+	.card_interrupt_status_reg = 0x64,
+	.card_interrupt_rsr_reg = 0x68,
+	.card_revision_reg = 0xC8,
+	.card_ocr_0_reg = 0xD4,
+	.card_ocr_1_reg = 0xD5,
+	.card_ocr_3_reg = 0xD6,
+	.card_config_reg = 0xD7,
+	.card_misc_cfg_reg = 0xD8,
+	.debug_0_reg = 0xDC,
+	.debug_1_reg = 0xDD,
+	.debug_2_reg = 0xDE,
+	.debug_3_reg = 0xDF,
+	.fw_reset_reg = 0x0B6,
+	.fw_reset_val = 1,
+	.winner_check_reg = 0x90,
+};
+
+static const struct _mlan_card_info mlan_card_info_sd8887 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
+	.v16_fw_api = 0,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 0,
+};
+#endif
+
+#ifdef SD8801
+static const struct _mlan_sdio_card_reg mlan_reg_sd8801 = {
+	.start_rd_port = 1,
+	.start_wr_port = 1,
+	.base_0_reg = 0x40,
+	.base_1_reg = 0x41,
+	.poll_reg = 0x30,
+	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK,
+	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS,
+	.status_reg_0 = 0x60,
+	.status_reg_1 = 0x61,
+	.sdio_int_mask = 0x3f,
+	.data_port_mask = 0x0000fffe,
+	.max_mp_regs = 64,
+	.rd_bitmap_l = 0x4,
+	.rd_bitmap_u = 0x5,
+	.wr_bitmap_l = 0x6,
+	.wr_bitmap_u = 0x7,
+	.rd_len_p0_l = 0x8,
+	.rd_len_p0_u = 0x9,
+	.io_port_0_reg = 0x78,
+	.io_port_1_reg = 0x79,
+	.io_port_2_reg = 0x7A,
+	.host_int_rsr_reg = 0x01,
+	.host_int_mask_reg = 0x02,
+	.host_int_status_reg = 0x03,
+	.card_misc_cfg_reg = 0x6c,
+	.fw_reset_reg = 0x64,
+	.fw_reset_val = 0,
+};
+
+static const struct _mlan_card_info mlan_card_info_sd8801 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
+	.v14_fw_api = 1,
+	.v16_fw_api = 0,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 0,
+};
+#endif
+
+#ifdef SD8897
+static const struct _mlan_sdio_card_reg mlan_reg_sd8897 = {
+	.start_rd_port = 0,
+	.start_wr_port = 0,
+	.base_0_reg = 0x60,
+	.base_1_reg = 0x61,
+	.poll_reg = 0x50,
+	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
+			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
+	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
+			   DN_LD_CMD_PORT_HOST_INT_STATUS |
+			   UP_LD_CMD_PORT_HOST_INT_STATUS,
+	.status_reg_0 = 0xC0,
+	.status_reg_1 = 0xC1,
+	.sdio_int_mask = 0xff,
+	.data_port_mask = 0xffffffff,
+	.max_mp_regs = 184,
+	.rd_bitmap_l = 0x04,
+	.rd_bitmap_u = 0x05,
+	.rd_bitmap_1l = 0x06,
+	.rd_bitmap_1u = 0x07,
+	.wr_bitmap_l = 0x08,
+	.wr_bitmap_u = 0x09,
+	.wr_bitmap_1l = 0x0A,
+	.wr_bitmap_1u = 0x0B,
+	.rd_len_p0_l = 0x0C,
+	.rd_len_p0_u = 0x0D,
+	.card_config_2_1_reg = 0xCD,
+	.cmd_config_0 = 0xB8,
+	.cmd_config_1 = 0xB9,
+	.cmd_config_2 = 0xBA,
+	.cmd_config_3 = 0xBB,
+	.cmd_rd_len_0 = 0xB4,
+	.cmd_rd_len_1 = 0xB5,
+	.cmd_rd_len_2 = 0xB6,
+	.cmd_rd_len_3 = 0xB7,
+	.io_port_0_reg = 0xD8,
+	.io_port_1_reg = 0xD9,
+	.io_port_2_reg = 0xDA,
+	.host_int_rsr_reg = 0x01,
+	.host_int_mask_reg = 0x02,
+	.host_int_status_reg = 0x03,
+	.host_restart_reg = 0x4C,
+	.card_to_host_event_reg = 0x50,
+	.host_interrupt_mask_reg = 0x54,
+	.card_interrupt_status_reg = 0x58,
+	.card_interrupt_rsr_reg = 0x5C,
+	.card_revision_reg = 0xBC,
+	.card_ocr_0_reg = 0xC8,
+	.card_ocr_1_reg = 0xC9,
+	.card_ocr_3_reg = 0xCA,
+	.card_config_reg = 0xCB,
+	.card_misc_cfg_reg = 0xCC,
+	.debug_0_reg = 0xD0,
+	.debug_1_reg = 0xD1,
+	.debug_2_reg = 0xD2,
+	.debug_3_reg = 0xD3,
+	.fw_reset_reg = 0x0E8,
+	.fw_reset_val = 1,
+	.winner_check_reg = 0xC0,
+};
+
+static const struct _mlan_card_info mlan_card_info_sd8897 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 0,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 0,
+};
+#endif
+
+static const struct _mlan_sdio_card_reg mlan_reg_sd8977_sd8997 = {
+	.start_rd_port = 0,
+	.start_wr_port = 0,
+	.base_0_reg = 0xf8,
+	.base_1_reg = 0xf9,
+	.poll_reg = 0x5C,
+	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
+			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
+	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
+			   DN_LD_CMD_PORT_HOST_INT_STATUS |
+			   UP_LD_CMD_PORT_HOST_INT_STATUS,
+	.status_reg_0 = 0xe8,
+	.status_reg_1 = 0xe9,
+	.sdio_int_mask = 0xff,
+	.data_port_mask = 0xffffffff,
+	.max_mp_regs = 196,
+	.rd_bitmap_l = 0x10,
+	.rd_bitmap_u = 0x11,
+	.rd_bitmap_1l = 0x12,
+	.rd_bitmap_1u = 0x13,
+	.wr_bitmap_l = 0x14,
+	.wr_bitmap_u = 0x15,
+	.wr_bitmap_1l = 0x16,
+	.wr_bitmap_1u = 0x17,
+	.rd_len_p0_l = 0x18,
+	.rd_len_p0_u = 0x19,
+	.card_config_2_1_reg = 0xD9,
+	.cmd_config_0 = 0xC4,
+	.cmd_config_1 = 0xC5,
+	.cmd_config_2 = 0xC6,
+	.cmd_config_3 = 0xC7,
+	.cmd_rd_len_0 = 0xC0,
+	.cmd_rd_len_1 = 0xC1,
+	.cmd_rd_len_2 = 0xC2,
+	.cmd_rd_len_3 = 0xC3,
+	.io_port_0_reg = 0xE4,
+	.io_port_1_reg = 0xE5,
+	.io_port_2_reg = 0xE6,
+	.host_int_rsr_reg = 0x04,
+	.host_int_mask_reg = 0x08,
+	.host_int_status_reg = 0x0C,
+	.host_restart_reg = 0x58,
+	.card_to_host_event_reg = 0x5C,
+	.host_interrupt_mask_reg = 0x60,
+	.card_interrupt_status_reg = 0x64,
+	.card_interrupt_rsr_reg = 0x68,
+	.card_revision_reg = 0xC8,
+	.card_ocr_0_reg = 0xD4,
+	.card_ocr_1_reg = 0xD5,
+	.card_ocr_3_reg = 0xD6,
+	.card_config_reg = 0xD7,
+	.card_misc_cfg_reg = 0xD8,
+	.debug_0_reg = 0xDC,
+	.debug_1_reg = 0xDD,
+	.debug_2_reg = 0xDE,
+	.debug_3_reg = 0xDF,
+	.fw_reset_reg = 0x0EE,
+	.fw_reset_val = 0x99,
+	.fw_dnld_offset_0_reg = 0xEC,
+	.fw_dnld_offset_1_reg = 0xED,
+	.fw_dnld_offset_2_reg = 0xEE,
+	.fw_dnld_offset_3_reg = 0xEF,
+	.fw_dnld_status_0_reg = 0xE8,
+	.fw_dnld_status_1_reg = 0xE9,
+	.winner_check_reg = 0xFC,
+};
+
+#ifdef SD8997
+static const struct _mlan_card_info mlan_card_info_sd8997 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
+
+#ifdef SD9097
+static const struct _mlan_card_info mlan_card_info_sd9097 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
+
+#ifdef SDIW62X
+static const struct _mlan_card_info mlan_card_info_sdiw62x = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
+
+static const struct _mlan_card_info mlan_card_info_sdaw693 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+
+#ifdef SD9098
+static const struct _mlan_card_info mlan_card_info_sd9098 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
+#ifdef SD9177
+static const struct _mlan_card_info mlan_card_info_sd9177 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 1,
+};
+#endif
+
+#if defined(SD8977) || defined(SD8978)
+static const struct _mlan_card_info mlan_card_info_sd8977 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
+	.v16_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 1,
+};
+#endif
+
+#ifdef SD8987
+static const struct _mlan_card_info mlan_card_info_sd8987 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
+	.v16_fw_api = 1,
+	.supp_ps_handshake = 0,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 1,
+};
+#endif
 
 /********************************************************
 		Global Variables
@@ -68,41 +399,77 @@ static mlan_status wlan_sdio_init_ioport(mlan_adapter *pmadapter)
 	t_u8 cmd_config_1 = pmadapter->pcard_sd->reg->cmd_config_1;
 
 	ENTER();
-
-	pmadapter->pcard_sd->ioport = MEM_PORT;
+	if (pmadapter->pcard_sd->supports_sdio_new_mode) {
+		pmadapter->pcard_sd->ioport = MEM_PORT;
+	} else {
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle,
+				       pmadapter->pcard_sd->reg->io_port_0_reg,
+				       &reg))
+			pmadapter->pcard_sd->ioport |= (reg & 0xff);
+		else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle,
+				       pmadapter->pcard_sd->reg->io_port_1_reg,
+				       &reg))
+			pmadapter->pcard_sd->ioport |= ((reg & 0xff) << 8);
+		else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle,
+				       pmadapter->pcard_sd->reg->io_port_2_reg,
+				       &reg))
+			pmadapter->pcard_sd->ioport |= ((reg & 0xff) << 16);
+		else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+	}
 	PRINTM(MINFO, "SDIO FUNC1 IO port: 0x%x\n",
 	       pmadapter->pcard_sd->ioport);
 
-	/* enable sdio cmd53 new mode */
-	if (MLAN_STATUS_SUCCESS == pcb->moal_read_reg(pmadapter->pmoal_handle,
-						      card_config_2_1_reg,
-						      &reg)) {
-		pcb->moal_write_reg(pmadapter->pmoal_handle,
-				    card_config_2_1_reg, reg | CMD53_NEW_MODE);
-	} else {
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
+	if (pmadapter->pcard_sd->supports_sdio_new_mode) {
+		/* enable sdio cmd53 new mode */
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle,
+				       card_config_2_1_reg, &reg)) {
+			pcb->moal_write_reg(pmadapter->pmoal_handle,
+					    card_config_2_1_reg,
+					    reg | CMD53_NEW_MODE);
+		} else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 
-	/* configure cmd port  */
-	/* enable reading rx length from the register  */
-	if (MLAN_STATUS_SUCCESS ==
-	    pcb->moal_read_reg(pmadapter->pmoal_handle, cmd_config_0, &reg)) {
-		pcb->moal_write_reg(pmadapter->pmoal_handle, cmd_config_0,
-				    reg | CMD_PORT_RD_LEN_EN);
-	} else {
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
-	/* enable Dnld/Upld ready auto reset for cmd port
-	 * after cmd53 is completed */
-	if (MLAN_STATUS_SUCCESS ==
-	    pcb->moal_read_reg(pmadapter->pmoal_handle, cmd_config_1, &reg)) {
-		pcb->moal_write_reg(pmadapter->pmoal_handle, cmd_config_1,
-				    reg | CMD_PORT_AUTO_EN);
-	} else {
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
+		/* configure cmd port  */
+		/* enable reading rx length from the register  */
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle, cmd_config_0,
+				       &reg)) {
+			pcb->moal_write_reg(pmadapter->pmoal_handle,
+					    cmd_config_0,
+					    reg | CMD_PORT_RD_LEN_EN);
+		} else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		/* enable Dnld/Upld ready auto reset for cmd port
+		 * after cmd53 is completed */
+		if (MLAN_STATUS_SUCCESS ==
+		    pcb->moal_read_reg(pmadapter->pmoal_handle, cmd_config_1,
+				       &reg)) {
+			pcb->moal_write_reg(pmadapter->pmoal_handle,
+					    cmd_config_1,
+					    reg | CMD_PORT_AUTO_EN);
+		} else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 	}
 
 #if defined(SD8977) || defined(SD8978)
@@ -196,33 +563,47 @@ static mlan_status wlan_get_rd_port(mlan_adapter *pmadapter, t_u8 *pport)
 {
 	t_u32 rd_bitmap = pmadapter->pcard_sd->mp_rd_bitmap;
 	const mlan_sdio_card_reg *reg = pmadapter->pcard_sd->reg;
-	t_u8 max_ports = MAX_PORT;
+	t_u8 max_ports = pmadapter->pcard_sd->max_ports;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
 	PRINTM(MIF_D, "wlan_get_rd_port: mp_rd_bitmap=0x%08x\n", rd_bitmap);
-
-	if (!(rd_bitmap & reg->data_port_mask)) {
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
-
-	if (pmadapter->pcard_sd->mp_rd_bitmap &
-	    (1 << pmadapter->pcard_sd->curr_rd_port)) {
-		pmadapter->pcard_sd->mp_rd_bitmap &=
-			(t_u32)(~(1 << pmadapter->pcard_sd->curr_rd_port));
-		*pport = pmadapter->pcard_sd->curr_rd_port;
-
-		/* hw rx wraps round only after port (MAX_PORT-1) */
-		if (++pmadapter->pcard_sd->curr_rd_port == max_ports)
-			pmadapter->pcard_sd->curr_rd_port = reg->start_rd_port;
+	if (new_mode) {
+		if (!(rd_bitmap & reg->data_port_mask)) {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 	} else {
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
+		if (!(rd_bitmap & (CTRL_PORT_MASK | reg->data_port_mask))) {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 	}
+	if (!new_mode && (pmadapter->pcard_sd->mp_rd_bitmap & CTRL_PORT_MASK)) {
+		pmadapter->pcard_sd->mp_rd_bitmap &= (t_u32)(~CTRL_PORT_MASK);
+		*pport = CTRL_PORT;
+		PRINTM(MIF_D, "wlan_get_rd_port: port=%d mp_rd_bitmap=0x%08x\n",
+		       *pport, pmadapter->pcard_sd->mp_rd_bitmap);
+	} else {
+		if (pmadapter->pcard_sd->mp_rd_bitmap &
+		    (1 << pmadapter->pcard_sd->curr_rd_port)) {
+			pmadapter->pcard_sd->mp_rd_bitmap &= (t_u32)(
+				~(1 << pmadapter->pcard_sd->curr_rd_port));
+			*pport = pmadapter->pcard_sd->curr_rd_port;
+
+			/* hw rx wraps round only after port (MAX_PORT-1) */
+			if (++pmadapter->pcard_sd->curr_rd_port == max_ports)
+				pmadapter->pcard_sd->curr_rd_port =
+					reg->start_rd_port;
+		} else {
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 
-	PRINTM(MIF_D, "port=%d mp_rd_bitmap=0x%08x -> 0x%08x\n", *pport,
-	       rd_bitmap, pmadapter->pcard_sd->mp_rd_bitmap);
+		PRINTM(MIF_D, "port=%d mp_rd_bitmap=0x%08x -> 0x%08x\n", *pport,
+		       rd_bitmap, pmadapter->pcard_sd->mp_rd_bitmap);
+	}
 
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -239,6 +620,7 @@ static mlan_status wlan_get_wr_port_data(mlan_adapter *pmadapter, t_u8 *pport)
 {
 	t_u32 wr_bitmap = pmadapter->pcard_sd->mp_wr_bitmap;
 	const mlan_sdio_card_reg *reg = pmadapter->pcard_sd->reg;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
@@ -264,7 +646,14 @@ static mlan_status wlan_get_wr_port_data(mlan_adapter *pmadapter, t_u8 *pport)
 		LEAVE();
 		return MLAN_STATUS_RESOURCE;
 	}
-
+	if ((!new_mode) && (*pport == CTRL_PORT)) {
+		PRINTM(MERROR,
+		       "Invalid data port=%d cur port=%d mp_wr_bitmap=0x%08x -> 0x%08x\n",
+		       *pport, pmadapter->pcard_sd->curr_wr_port, wr_bitmap,
+		       pmadapter->pcard_sd->mp_wr_bitmap);
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 	PRINTM(MIF_D, "port=%d mp_wr_bitmap=0x%08x -> 0x%08x\n", *pport,
 	       wr_bitmap, pmadapter->pcard_sd->mp_wr_bitmap);
 	LEAVE();
@@ -287,7 +676,7 @@ static mlan_status wlan_sdio_poll_card_status(mlan_adapter *pmadapter,
 
 	ENTER();
 
-	for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+	for (tries = 0; tries < 10000; tries++) {
 		if (pcb->moal_read_reg(pmadapter->pmoal_handle,
 				       pmadapter->pcard_sd->reg->poll_reg,
 				       &cs) != MLAN_STATUS_SUCCESS)
@@ -602,7 +991,7 @@ static mlan_status wlan_sdio_prog_fw_w_helper(pmlan_adapter pmadapter, t_u8 *fw,
 	t_u8 *firmware = fw;
 	t_u32 firmwarelen = fw_len;
 	t_u32 offset = 0;
-	t_u32 base0, base1;
+	t_u32 base0 = 0, base1 = 0;
 	t_void *tmpfwbuf = MNULL;
 	t_u32 tmpfwbufsz;
 	t_u8 *fwbuf;
@@ -641,7 +1030,6 @@ static mlan_status wlan_sdio_prog_fw_w_helper(pmlan_adapter pmadapter, t_u8 *fw,
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-	memset(pmadapter, tmpfwbuf, 0, tmpfwbufsz);
 	/* Ensure 8-byte aligned firmware buffer */
 	fwbuf = (t_u8 *)ALIGN_ADDR(tmpfwbuf, DMA_ALIGNMENT);
 #if defined(SD9098)
@@ -661,10 +1049,11 @@ static mlan_status wlan_sdio_prog_fw_w_helper(pmlan_adapter pmadapter, t_u8 *fw,
 			check_fw_status = MTRUE;
 	}
 #endif
-#if defined(SD9097)
-	if (IS_SD9097(pmadapter->card_type))
+	if (IS_SD9097(pmadapter->card_type) ||
+	    IS_SDIW62X(pmadapter->card_type) ||
+	    IS_SDAW693(pmadapter->card_type) || IS_SD9177(pmadapter->card_type))
 		check_fw_status = MTRUE;
-#endif
+
 	/* Perform firmware data transfer */
 	do {
 		/* The host polls for the DN_LD_CARD_RDY and CARD_IO_READY bits
@@ -787,7 +1176,7 @@ static mlan_status wlan_sdio_prog_fw_w_helper(pmlan_adapter pmadapter, t_u8 *fw,
 			 * for last block */
 			if (firmwarelen && firmwarelen - offset < txlen)
 				txlen = firmwarelen - offset;
-			PRINTM(MINFO, ".");
+			PRINTM(MINFO, ".\n");
 
 			tx_blocks = (txlen + MLAN_SDIO_BLOCK_SIZE_FW_DNLD - 1) /
 				    MLAN_SDIO_BLOCK_SIZE_FW_DNLD;
@@ -869,6 +1258,8 @@ static mlan_status wlan_decode_rx_packet(mlan_adapter *pmadapter,
 {
 	t_u8 *cmd_buf;
 	t_u32 event;
+	t_u32 in_ts_sec, in_ts_usec;
+	pmlan_callbacks pcb = &pmadapter->callbacks;
 
 	ENTER();
 
@@ -911,19 +1302,43 @@ static mlan_status wlan_decode_rx_packet(mlan_adapter *pmadapter,
 		pmbuf->data_len = (pmadapter->upld_len - SDIO_INTF_HEADER_LEN);
 		pmbuf->data_offset += SDIO_INTF_HEADER_LEN;
 		if (pmadapter->rx_work_flag) {
-			if (lock_flag)
-				pmadapter->callbacks.moal_spin_lock(
-					pmadapter->pmoal_handle,
-					pmadapter->rx_data_queue.plock);
-			util_enqueue_list_tail(pmadapter->pmoal_handle,
-					       &pmadapter->rx_data_queue,
-					       (pmlan_linked_list)pmbuf, MNULL,
-					       MNULL);
-			pmadapter->rx_pkts_queued++;
-			if (lock_flag)
-				pmadapter->callbacks.moal_spin_unlock(
+			// rx_trace 5
+			if (pmadapter->tp_state_on) {
+				pmadapter->callbacks.moal_tp_accounting(
+					pmadapter->pmoal_handle, pmbuf,
+					5 /*RX_DROP_P1*/);
+				pcb->moal_get_system_time(
+					pmadapter->pmoal_handle, &in_ts_sec,
+					&in_ts_usec);
+				pmbuf->in_ts_sec = in_ts_sec;
+				pmbuf->in_ts_usec = in_ts_usec;
+			}
+			if (pmadapter->tp_state_drop_point ==
+			    5 /*RX_DROP_P1*/) {
+				pmadapter->ops.data_complete(
+					pmadapter, pmbuf, MLAN_STATUS_SUCCESS);
+			} else {
+				if (lock_flag)
+					pmadapter->callbacks.moal_spin_lock(
+						pmadapter->pmoal_handle,
+						pmadapter->rx_data_queue.plock);
+				util_enqueue_list_tail(
 					pmadapter->pmoal_handle,
-					pmadapter->rx_data_queue.plock);
+					&pmadapter->rx_data_queue,
+					(pmlan_linked_list)pmbuf, MNULL, MNULL);
+				pmadapter->rx_pkts_queued++;
+				if (pmadapter->tp_state_on)
+					pmadapter->callbacks
+						.moal_tp_accounting_rx_param(
+							pmadapter->pmoal_handle,
+							1,
+							pmadapter
+								->rx_pkts_queued);
+				if (lock_flag)
+					pmadapter->callbacks.moal_spin_unlock(
+						pmadapter->pmoal_handle,
+						pmadapter->rx_data_queue.plock);
+			}
 		} else {
 			wlan_handle_rx_packet(pmadapter, pmbuf);
 		}
@@ -932,6 +1347,8 @@ static mlan_status wlan_decode_rx_packet(mlan_adapter *pmadapter,
 
 	case MLAN_TYPE_CMD:
 		PRINTM(MINFO, "--- Rx: Cmd Response ---\n");
+		if (pmadapter->cmd_sent && !pmadapter->vdll_ctrl.vdll_len)
+			pmadapter->cmd_sent = MFALSE;
 		/* take care of curr_cmd = NULL case */
 		if (!pmadapter->curr_cmd) {
 			cmd_buf = pmadapter->upld_buf;
@@ -1007,7 +1424,7 @@ static mlan_status wlan_decode_rx_packet(mlan_adapter *pmadapter,
  *  @param pmadapter A pointer to mlan_adapter structure
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_receive_single_packet(mlan_adapter *pmadapter)
+static mlan_status wlan_receive_single_packet(mlan_adapter *pmadapter)
 {
 	mlan_buffer *pmbuf;
 	t_u8 port;
@@ -1050,7 +1467,7 @@ mlan_status wlan_receive_single_packet(mlan_adapter *pmadapter)
  *  @param pmadapter A pointer to mlan_adapter structure
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_receive_mp_aggr_buf(mlan_adapter *pmadapter)
+static mlan_status wlan_receive_mp_aggr_buf(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -1062,6 +1479,7 @@ mlan_status wlan_receive_mp_aggr_buf(mlan_adapter *pmadapter)
 	t_u32 cmd53_port = 0;
 	t_u32 i = 0;
 	t_u32 port_count = 0;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	/* do aggr RX now */
 	PRINTM(MINFO, "do_rx_aggr: num of packets: %d\n",
@@ -1088,11 +1506,17 @@ mlan_status wlan_receive_mp_aggr_buf(mlan_adapter *pmadapter)
 		mbuf_aggr.data_len = pmadapter->pcard_sd->mpa_rx.buf_len;
 	}
 
-	port_count = bitcount(pmadapter->pcard_sd->mpa_rx.ports) - 1;
-	/* port_count = pmadapter->mpa_rx.pkt_cnt - 1; */
-	cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
-		      (port_count << 8)) +
-		     pmadapter->pcard_sd->mpa_rx.start_port;
+	if (new_mode) {
+		port_count = bitcount(pmadapter->pcard_sd->mpa_rx.ports) - 1;
+		/* port_count = pmadapter->mpa_rx.pkt_cnt - 1; */
+		cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
+			      (port_count << 8)) +
+			     pmadapter->pcard_sd->mpa_rx.start_port;
+	} else {
+		cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
+			      (pmadapter->pcard_sd->mpa_rx.ports << 4)) +
+			     pmadapter->pcard_sd->mpa_rx.start_port;
+	}
 	do {
 		ret = pcb->moal_read_data_sync(pmadapter->pmoal_handle,
 					       &mbuf_aggr, cmd53_port, 0);
@@ -1208,8 +1632,17 @@ static mlan_status wlan_sdio_card_to_host_mp_aggr(mlan_adapter *pmadapter,
 	t_u32 pind = 0;
 	t_u32 pkt_type = 0;
 	const mlan_sdio_card_reg *reg = pmadapter->pcard_sd->reg;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
+	if (!new_mode && (port == CTRL_PORT)) {
+		/* Read the command response or event without aggr */
+		PRINTM(MINFO,
+		       "card_2_host_mp_aggr: No aggr for control port\n");
+
+		f_do_rx_cur = 1;
+		goto rx_curr_single;
+	}
 
 	if (!pmadapter->pcard_sd->mpa_rx.enabled) {
 		PRINTM(MINFO,
@@ -1218,8 +1651,10 @@ static mlan_status wlan_sdio_card_to_host_mp_aggr(mlan_adapter *pmadapter,
 		f_do_rx_cur = 1;
 		goto rx_curr_single;
 	}
-
-	if (pmadapter->pcard_sd->mp_rd_bitmap & reg->data_port_mask) {
+	if ((new_mode &&
+	     (pmadapter->pcard_sd->mp_rd_bitmap & reg->data_port_mask)) ||
+	    (!new_mode && (pmadapter->pcard_sd->mp_rd_bitmap &
+			   (~((t_u32)CTRL_PORT_MASK))))) {
 		/* Some more data RX pending */
 		PRINTM(MINFO, "card_2_host_mp_aggr: Not last packet\n");
 
@@ -1256,10 +1691,15 @@ static mlan_status wlan_sdio_card_to_host_mp_aggr(mlan_adapter *pmadapter,
 	if (f_aggr_cur) {
 		PRINTM(MINFO, "Current packet aggregation.\n");
 		/* Curr pkt can be aggregated */
-		MP_RX_AGGR_SETUP(pmadapter, pmbuf, port, rx_len);
-
+		if (new_mode)
+			MP_RX_AGGR_SETUP(pmadapter, pmbuf, port, rx_len);
+		else
+			MP_RX_AGGR_SETUP_NONEWMODE(pmadapter, pmbuf, port,
+						   rx_len);
 		if (MP_RX_AGGR_PKT_LIMIT_REACHED(pmadapter) ||
-		    MP_RX_AGGR_PORT_LIMIT_REACHED(pmadapter)) {
+		    ((new_mode && MP_RX_AGGR_PORT_LIMIT_REACHED(pmadapter)) ||
+		     (!new_mode &&
+		      MP_RX_AGGR_PORT_LIMIT_REACHED_NONEWMODE(pmadapter)))) {
 			PRINTM(MINFO,
 			       "card_2_host_mp_aggr: Aggregation Packet limit reached\n");
 			/* No more pkts allowed in Aggr buf, rx it */
@@ -1288,24 +1728,41 @@ static mlan_status wlan_sdio_card_to_host_mp_aggr(mlan_adapter *pmadapter,
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
-		if (pkt_type != MLAN_TYPE_DATA &&
-		    pkt_type != MLAN_TYPE_SPA_DATA) {
+		if (!new_mode &&
+		    ((port == CTRL_PORT) && ((pkt_type != MLAN_TYPE_EVENT) &&
+					     (pkt_type != MLAN_TYPE_CMD)))) {
 			PRINTM(MERROR,
-			       "receive a wrong pkt from DATA PORT: type=%d, len=%dd\n",
+			       "Wrong pkt from CTRL PORT: type=%d, len=%dd\n",
 			       pkt_type, pmbuf->data_len);
 			pmbuf->status_code = MLAN_ERROR_DATA_RX_FAIL;
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
+		if (new_mode || (port != CTRL_PORT)) {
+			if (pkt_type != MLAN_TYPE_DATA &&
+			    pkt_type != MLAN_TYPE_SPA_DATA) {
+				PRINTM(MERROR,
+				       "receive a wrong pkt from DATA PORT: type=%d, len=%dd\n",
+				       pkt_type, pmbuf->data_len);
+				pmbuf->status_code = MLAN_ERROR_DATA_RX_FAIL;
+				ret = MLAN_STATUS_FAILURE;
+				goto done;
+			}
+		}
 
-		pmadapter->pcard_sd->mpa_rx_count[0]++;
+		if (new_mode || (port != CTRL_PORT))
+			pmadapter->pcard_sd->mpa_rx_count[0]++;
 
 		wlan_decode_rx_packet(pmadapter, pmbuf, pkt_type, MTRUE);
 	}
 	if (f_post_aggr_cur) {
 		PRINTM(MINFO, "Current packet aggregation.\n");
 		/* Curr pkt can be aggregated */
-		MP_RX_AGGR_SETUP(pmadapter, pmbuf, port, rx_len);
+		if (new_mode)
+			MP_RX_AGGR_SETUP(pmadapter, pmbuf, port, rx_len);
+		else
+			MP_RX_AGGR_SETUP_NONEWMODE(pmadapter, pmbuf, port,
+						   rx_len);
 	}
 done:
 	if (ret == MLAN_STATUS_FAILURE) {
@@ -1345,7 +1802,8 @@ mlan_status wlan_send_mp_aggr_buf(mlan_adapter *pmadapter)
 	t_u32 port_count = 0;
 	mlan_buffer mbuf_aggr;
 	t_u8 i = 0;
-	t_u8 mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+	t_u8 mp_aggr_pkt_limit = pmadapter->pcard_sd->mp_aggr_pkt_limit;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
@@ -1375,11 +1833,16 @@ mlan_status wlan_send_mp_aggr_buf(mlan_adapter *pmadapter)
 		mbuf_aggr.data_len = pmadapter->pcard_sd->mpa_tx.buf_len;
 	}
 
-	port_count = bitcount(pmadapter->pcard_sd->mpa_tx.ports) - 1;
-	cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
-		      (port_count << 8)) +
-		     pmadapter->pcard_sd->mpa_tx.start_port;
-
+	if (new_mode) {
+		port_count = bitcount(pmadapter->pcard_sd->mpa_tx.ports) - 1;
+		cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
+			      (port_count << 8)) +
+			     pmadapter->pcard_sd->mpa_tx.start_port;
+	} else {
+		cmd53_port = (pmadapter->pcard_sd->ioport | SDIO_MPA_ADDR_BASE |
+			      (pmadapter->pcard_sd->mpa_tx.ports << 4)) +
+			     pmadapter->pcard_sd->mpa_tx.start_port;
+	}
 	if (pmadapter->pcard_sd->mpa_tx.pkt_cnt == 1)
 		cmd53_port = pmadapter->pcard_sd->ioport +
 			     pmadapter->pcard_sd->mpa_tx.start_port;
@@ -1452,7 +1915,8 @@ static mlan_status wlan_host_to_card_mp_aggr(mlan_adapter *pmadapter,
 	t_s32 f_precopy_cur_buf = 0;
 	t_s32 f_postcopy_cur_buf = 0;
 	t_u8 aggr_sg = 0;
-	t_u8 mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+	t_u8 mp_aggr_pkt_limit = pmadapter->pcard_sd->mp_aggr_pkt_limit;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
@@ -1539,12 +2003,21 @@ static mlan_status wlan_host_to_card_mp_aggr(mlan_adapter *pmadapter,
 				mbuf->pbuf + mbuf->data_offset,
 				MLAN_SDIO_BLOCK_SIZE, MLAN_SDIO_BLOCK_SIZE);
 		if (!pmadapter->pcard_sd->mpa_tx.buf) {
-			MP_TX_AGGR_BUF_PUT_SG(pmadapter, mbuf, port);
+			if (new_mode)
+				MP_TX_AGGR_BUF_PUT_SG(pmadapter, mbuf, port);
+			else
+				MP_TX_AGGR_BUF_PUT_SG_NONEWMODE(pmadapter, mbuf,
+								port);
 			aggr_sg = MTRUE;
 		} else {
-			MP_TX_AGGR_BUF_PUT(pmadapter, mbuf, port);
+			if (new_mode)
+				MP_TX_AGGR_BUF_PUT(pmadapter, mbuf, port);
+			else
+				MP_TX_AGGR_BUF_PUT_NONEWMODE(pmadapter, mbuf,
+							     port);
 		}
-		if (MP_TX_AGGR_PKT_LIMIT_REACHED(pmadapter)) {
+		if (MP_TX_AGGR_PKT_LIMIT_REACHED(pmadapter) ||
+		    (!new_mode && MP_TX_AGGR_PORT_LIMIT_REACHED(pmadapter))) {
 			PRINTM(MIF_D,
 			       "host_2_card_mp_aggr: Aggregation Pkt limit reached\n");
 			/* No more pkts allowed in Aggr buf, send it */
@@ -1611,10 +2084,18 @@ static mlan_status wlan_host_to_card_mp_aggr(mlan_adapter *pmadapter,
 				mbuf->pbuf + mbuf->data_offset,
 				MLAN_SDIO_BLOCK_SIZE, MLAN_SDIO_BLOCK_SIZE);
 		if (!pmadapter->pcard_sd->mpa_tx.buf) {
-			MP_TX_AGGR_BUF_PUT_SG(pmadapter, mbuf, port);
+			if (new_mode)
+				MP_TX_AGGR_BUF_PUT_SG(pmadapter, mbuf, port);
+			else
+				MP_TX_AGGR_BUF_PUT_SG_NONEWMODE(pmadapter, mbuf,
+								port);
 			aggr_sg = MTRUE;
 		} else {
-			MP_TX_AGGR_BUF_PUT(pmadapter, mbuf, port);
+			if (new_mode)
+				MP_TX_AGGR_BUF_PUT(pmadapter, mbuf, port);
+			else
+				MP_TX_AGGR_BUF_PUT_NONEWMODE(pmadapter, mbuf,
+							     port);
 		}
 	}
 	/* Always return PENDING in SG mode */
@@ -1638,7 +2119,8 @@ static mlan_status wlan_host_to_card_mp_aggr(mlan_adapter *pmadapter,
  *  @return           MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  *
  */
-mlan_status wlan_sdio_check_winner_status(mlan_adapter *pmadapter, t_u32 *val)
+static mlan_status wlan_sdio_check_winner_status(mlan_adapter *pmadapter,
+						 t_u32 *val)
 {
 	t_u32 winner = 0;
 	pmlan_callbacks pcb;
@@ -1646,6 +2128,12 @@ mlan_status wlan_sdio_check_winner_status(mlan_adapter *pmadapter, t_u32 *val)
 
 	ENTER();
 
+#ifdef SD8801
+	if (IS_SD8801(pmadapter->card_type)) {
+		*val = 0;
+		return MLAN_STATUS_SUCCESS;
+	}
+#endif
 	pcb = &pmadapter->callbacks;
 
 	if (MLAN_STATUS_SUCCESS != pcb->moal_read_reg(pmadapter->pmoal_handle,
@@ -1668,7 +2156,8 @@ mlan_status wlan_sdio_check_winner_status(mlan_adapter *pmadapter, t_u32 *val)
  *  @param pollnum    Maximum polling number
  *  @return           MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_sdio_check_fw_status(mlan_adapter *pmadapter, t_u32 pollnum)
+static mlan_status wlan_sdio_check_fw_status(mlan_adapter *pmadapter,
+					     t_u32 pollnum)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 firmwarestat = 0;
@@ -1685,7 +2174,7 @@ mlan_status wlan_sdio_check_fw_status(mlan_adapter *pmadapter, t_u32 pollnum)
 			ret = MLAN_STATUS_SUCCESS;
 			break;
 		} else {
-			wlan_mdelay(pmadapter, 100);
+			wlan_mdelay(pmadapter, 10);
 			ret = MLAN_STATUS_FAILURE;
 		}
 	}
@@ -1709,7 +2198,7 @@ mlan_status wlan_sdio_check_fw_status(mlan_adapter *pmadapter, t_u32 pollnum)
  *  @param pmadapter A pointer to mlan_adapter structure
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_enable_sdio_host_int(pmlan_adapter pmadapter)
+static mlan_status wlan_enable_sdio_host_int(pmlan_adapter pmadapter)
 {
 	mlan_status ret;
 	t_u8 mask = pmadapter->pcard_sd->reg->host_int_enable;
@@ -1728,7 +2217,8 @@ mlan_status wlan_enable_sdio_host_int(pmlan_adapter pmadapter)
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_sdio_dnld_fw(pmlan_adapter pmadapter, pmlan_fw_image pmfw)
+static mlan_status wlan_sdio_dnld_fw(pmlan_adapter pmadapter,
+				     pmlan_fw_image pmfw)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 poll_num = 1;
@@ -1777,7 +2267,6 @@ mlan_status wlan_sdio_dnld_fw(pmlan_adapter pmadapter, pmlan_fw_image pmfw)
 #endif
 	}
 	poll_num = MAX_FIRMWARE_POLL_TRIES;
-
 	/* Check if other interface is downloading */
 	ret = wlan_sdio_check_winner_status(pmadapter, &winner);
 	if (ret == MLAN_STATUS_FAILURE) {
@@ -1810,6 +2299,10 @@ mlan_status wlan_sdio_dnld_fw(pmlan_adapter pmadapter, pmlan_fw_image pmfw)
 		LEAVE();
 		return ret;
 	}
+#ifdef SD9177
+	if (IS_SD9177(pmadapter->card_type))
+		wlan_mdelay(pmadapter, 1000);
+#endif
 done:
 
 	/* re-enable host interrupt for mlan after fw dnld is successful */
@@ -1875,8 +2368,27 @@ mlan_status wlan_get_sdio_device(pmlan_adapter pmadapter)
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
+	pmadapter->pcard_sd->max_ports = MAX_PORT;
+	pmadapter->pcard_sd->mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+	pmadapter->pcard_sd->supports_sdio_new_mode = MTRUE;
+	pmadapter->pcard_sd->mp_tx_aggr_buf_size = SDIO_MP_AGGR_BUF_SIZE_MAX;
+	pmadapter->pcard_sd->mp_rx_aggr_buf_size = SDIO_MP_AGGR_BUF_SIZE_MAX;
 
 	switch (card_type) {
+#ifdef SD8801
+	case CARD_TYPE_SD8801:
+		pmadapter->pcard_sd->reg = &mlan_reg_sd8801;
+		pmadapter->pcard_info = &mlan_card_info_sd8801;
+		pmadapter->pcard_sd->max_ports = MAX_PORT_16;
+		pmadapter->pcard_sd->mp_aggr_pkt_limit =
+			SDIO_MP_AGGR_DEF_PKT_LIMIT_8;
+		pmadapter->pcard_sd->supports_sdio_new_mode = MFALSE;
+		pmadapter->pcard_sd->mp_tx_aggr_buf_size =
+			SDIO_MP_AGGR_BUF_SIZE_32K;
+		pmadapter->pcard_sd->mp_rx_aggr_buf_size =
+			SDIO_MP_AGGR_BUF_SIZE_32K;
+		break;
+#endif
 #ifdef SD8887
 	case CARD_TYPE_SD8887:
 		pmadapter->pcard_sd->reg = &mlan_reg_sd8887;
@@ -1919,6 +2431,22 @@ mlan_status wlan_get_sdio_device(pmlan_adapter pmadapter)
 		pmadapter->pcard_sd->reg = &mlan_reg_sd8977_sd8997;
 		pmadapter->pcard_info = &mlan_card_info_sd9097;
 		break;
+#endif
+#ifdef SDIW62X
+	case CARD_TYPE_SDIW62X:
+		pmadapter->pcard_sd->reg = &mlan_reg_sd8977_sd8997;
+		pmadapter->pcard_info = &mlan_card_info_sdiw62x;
+		break;
+#endif
+	case CARD_TYPE_SDAW693:
+		pmadapter->pcard_sd->reg = &mlan_reg_sd8977_sd8997;
+		pmadapter->pcard_info = &mlan_card_info_sdaw693;
+		break;
+#ifdef SD9177
+	case CARD_TYPE_SD9177:
+		pmadapter->pcard_sd->reg = &mlan_reg_sd8977_sd8997;
+		pmadapter->pcard_info = &mlan_card_info_sd9177;
+		break;
 #endif
 	default:
 		PRINTM(MERROR, "can't get right card type \n");
@@ -1930,19 +2458,98 @@ mlan_status wlan_get_sdio_device(pmlan_adapter pmadapter)
 	return ret;
 }
 
+/**
+ *  @brief This function dump the mp registers when issue happened
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @return             N/A
+ */
+void wlan_dump_mp_registers(pmlan_adapter pmadapter)
+{
+	t_u32 mp_wr_bitmap;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
+	t_u32 mp_rd_bitmap;
+	t_u16 rx_len = 0;
+	const mlan_sdio_card_reg *reg = pmadapter->pcard_sd->reg;
+	t_u8 cmd_rd_len_0 = reg->cmd_rd_len_0;
+	t_u8 cmd_rd_len_1 = reg->cmd_rd_len_1;
+	t_u8 host_int_status_reg = reg->host_int_status_reg;
+	t_u32 sdio_ireg = 0;
+
+	mp_wr_bitmap = (t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_l];
+	mp_wr_bitmap |= ((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_u])
+			<< 8;
+	if (new_mode) {
+		mp_wr_bitmap |=
+			((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_1l])
+			<< 16;
+		mp_wr_bitmap |=
+			((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_1u])
+			<< 24;
+	}
+	PRINTM(MMSG, "wlan: mp_data_port_mask = 0x%x\n",
+	       pmadapter->pcard_sd->mp_data_port_mask);
+	PRINTM(MMSG, "wlan: HW wr_bitmap=0x%08x Host: wr_bitmap=0x%08x\n",
+	       mp_wr_bitmap, pmadapter->pcard_sd->mp_wr_bitmap);
+	mp_rd_bitmap = (t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_l];
+	mp_rd_bitmap |= ((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_u])
+			<< 8;
+	if (new_mode) {
+		mp_rd_bitmap |=
+			((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_1l])
+			<< 16;
+		mp_rd_bitmap |=
+			((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_1u])
+			<< 24;
+	}
+	PRINTM(MMSG, "wlan: HW rd_bitmap=0x%08x Host: rd_bitmap=0x%08x\n",
+	       mp_rd_bitmap, pmadapter->pcard_sd->mp_rd_bitmap);
+
+	if (new_mode) {
+		rx_len = ((t_u16)pmadapter->pcard_sd->mp_regs[cmd_rd_len_1])
+			 << 8;
+		rx_len |= (t_u16)pmadapter->pcard_sd->mp_regs[cmd_rd_len_0];
+		PRINTM(MMSG, "wlan: cmd rx buffer rx_len = %d\n", rx_len);
+	}
+	PRINTM(MMSG, "wlan: HW sdio_ireg = 0x%x\n",
+	       pmadapter->pcard_sd->mp_regs[host_int_status_reg]);
+	sdio_ireg = pmadapter->pcard_sd->mp_regs[host_int_status_reg];
+
+	if (new_mode && rx_len)
+		sdio_ireg |= UP_LD_CMD_PORT_HOST_INT_STATUS;
+
+	if (new_mode && pmadapter->cmd_sent)
+		sdio_ireg |= DN_LD_CMD_PORT_HOST_INT_STATUS;
+
+	if (!(pmadapter->pcard_sd->mp_wr_bitmap &
+	      pmadapter->pcard_sd->mp_data_port_mask)) {
+		if (mp_wr_bitmap & pmadapter->pcard_sd->mp_data_port_mask)
+			sdio_ireg |= DN_LD_HOST_INT_STATUS;
+	}
+
+	if ((!pmadapter->pcard_sd->mp_rd_bitmap) && mp_rd_bitmap)
+		sdio_ireg |= UP_LD_HOST_INT_STATUS;
+
+	pmadapter->pcard_sd->mp_regs[host_int_status_reg] = sdio_ireg;
+	PRINTM(MMSG, "wlan: recovered sdio_ireg=0x%x\n", sdio_ireg);
+	return;
+}
+
 /**
  *  @brief This function gets interrupt status.
  *
  *  @param pmadapter    A pointer to mlan_adapter structure
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_sdio_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
+static mlan_status wlan_sdio_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
 {
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 	mlan_buffer mbuf;
 	t_u32 sdio_ireg = 0;
 	t_u8 offset = 0;
-	t_u8 max_mp_regs = pmadapter->pcard_sd->reg->max_mp_regs;
+	t_u8 i = 0;
+	int max_mp_regs = pmadapter->pcard_sd->reg->max_mp_regs;
 	t_u8 host_int_status_reg =
 		pmadapter->pcard_sd->reg->host_int_status_reg;
 
@@ -1952,20 +2559,32 @@ mlan_status wlan_sdio_interrupt(t_u16 msg_id, pmlan_adapter pmadapter)
 		memset(pmadapter, &mbuf, 0, sizeof(mlan_buffer));
 		mbuf.pbuf = pmadapter->pcard_sd->mp_regs + offset;
 		mbuf.data_len = MIN(max_mp_regs, MLAN_SDIO_BLOCK_SIZE);
-
-		if (MLAN_STATUS_SUCCESS !=
-		    pcb->moal_read_data_sync(pmadapter->pmoal_handle, &mbuf,
-					     (REG_PORT + offset) |
-						     MLAN_SDIO_BYTE_MODE_MASK,
-					     0)) {
-			PRINTM(MERROR,
-			       "moal_read_data_sync: read registers failed\n");
-			pmadapter->dbg.num_int_read_failure++;
-			goto done;
-		}
+		do {
+			ret = pcb->moal_read_data_sync(
+				pmadapter->pmoal_handle, &mbuf,
+				(REG_PORT + offset) | MLAN_SDIO_BYTE_MODE_MASK,
+				0);
+			if (ret != MLAN_STATUS_SUCCESS) {
+				PRINTM(MERROR,
+				       "wlan: cmd53 read regs failed: %d port=%x retry=%d\n",
+				       ret, REG_PORT + offset, i);
+				i++;
+				pcb->moal_write_reg(pmadapter->pmoal_handle,
+						    HOST_TO_CARD_EVENT_REG,
+						    HOST_TERM_CMD53);
+				if (i > MAX_WRITE_IOMEM_RETRY) {
+					PRINTM(MERROR,
+					       "wlan: Fail to read mp_regs\n");
+					pmadapter->dbg.num_int_read_failure++;
+					goto done;
+				}
+			}
+		} while (ret == MLAN_STATUS_FAILURE);
 		offset += mbuf.data_len;
 		max_mp_regs -= mbuf.data_len;
 	}
+	if (i > 0)
+		wlan_dump_mp_registers(pmadapter);
 
 	DBG_HEXDUMP(MIF_D, "SDIO MP Registers", pmadapter->pcard_sd->mp_regs,
 		    max_mp_regs);
@@ -2014,7 +2633,8 @@ static mlan_status wlan_sdio_card_to_host_recovery(mlan_adapter *pmadapter,
 	t_u32 pkt_type = 0;
 	mlan_status ret = MLAN_STATUS_FAILURE;
 	ENTER();
-
+	if (!pmadapter->pcard_sd->supports_sdio_new_mode)
+		goto done;
 	if (MP_RX_AGGR_IN_PROGRESS(pmadapter)) {
 		PRINTM(MDATA, "Recovery:do Rx Aggr\n");
 		/* do aggr RX now */
@@ -2062,7 +2682,7 @@ static mlan_status wlan_sdio_card_to_host_recovery(mlan_adapter *pmadapter,
  *  @param pmadapter A pointer to mlan_adapter structure
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
+static mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -2082,6 +2702,7 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 	t_u8 rd_len_p0_u = reg->rd_len_p0_u;
 	t_u8 cmd_rd_len_0 = reg->cmd_rd_len_0;
 	t_u8 cmd_rd_len_1 = reg->cmd_rd_len_1;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
@@ -2093,66 +2714,74 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 	if (!sdio_ireg)
 		goto done;
 
-	/* check the command port */
-	if (sdio_ireg & DN_LD_CMD_PORT_HOST_INT_STATUS) {
-		if (pmadapter->cmd_sent)
-			pmadapter->cmd_sent = MFALSE;
-
-		PRINTM(MINFO, "cmd_sent=%d\n", pmadapter->cmd_sent);
-	}
+	if (new_mode) {
+		/* check the command port */
+		if (sdio_ireg & DN_LD_CMD_PORT_HOST_INT_STATUS) {
+			if (pmadapter->cmd_sent)
+				pmadapter->cmd_sent = MFALSE;
 
-	if (sdio_ireg & UP_LD_CMD_PORT_HOST_INT_STATUS) {
-		/* read the len of control packet */
-		rx_len = ((t_u16)pmadapter->pcard_sd->mp_regs[cmd_rd_len_1])
-			 << 8;
-		rx_len |= (t_u16)pmadapter->pcard_sd->mp_regs[cmd_rd_len_0];
-		PRINTM(MINFO, "RX: cmd port rx_len=%u\n", rx_len);
-		rx_blocks = (rx_len + MLAN_SDIO_BLOCK_SIZE - 1) /
-			    MLAN_SDIO_BLOCK_SIZE;
-		if (rx_len <= SDIO_INTF_HEADER_LEN ||
-		    (rx_blocks * MLAN_SDIO_BLOCK_SIZE) > ALLOC_BUF_SIZE) {
-			PRINTM(MERROR, "invalid rx_len=%d\n", rx_len);
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
+			PRINTM(MINFO, "cmd_sent=%d\n", pmadapter->cmd_sent);
 		}
-		rx_len = (t_u16)(rx_blocks * MLAN_SDIO_BLOCK_SIZE);
-		pmbuf = wlan_alloc_mlan_buffer(pmadapter, rx_len, 0,
-					       MOAL_MALLOC_BUFFER);
-		if (pmbuf == MNULL) {
-			PRINTM(MERROR, "Failed to allocate 'mlan_buffer'\n");
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
-		}
-		PRINTM(MINFO, "cmd rx buffer rx_len = %d\n", rx_len);
 
-		/* Transfer data from card */
-		if (MLAN_STATUS_SUCCESS !=
-		    wlan_sdio_card_to_host(
-			    pmadapter, &upld_typ, (t_u32 *)&pmadapter->upld_len,
-			    pmbuf, rx_len,
-			    pmadapter->pcard_sd->ioport | CMD_PORT_SLCT)) {
-			pmadapter->dbg.num_cmdevt_card_to_host_failure++;
-			PRINTM(MERROR,
-			       "Card-to-host cmd failed: int status=0x%x\n",
-			       sdio_ireg);
-			wlan_free_mlan_buffer(pmadapter, pmbuf);
-			ret = MLAN_STATUS_FAILURE;
-			goto term_cmd53;
-		}
+		if (sdio_ireg & UP_LD_CMD_PORT_HOST_INT_STATUS) {
+			/* read the len of control packet */
+			rx_len = ((t_u16)pmadapter->pcard_sd
+					  ->mp_regs[cmd_rd_len_1])
+				 << 8;
+			rx_len |= (t_u16)pmadapter->pcard_sd
+					  ->mp_regs[cmd_rd_len_0];
+			PRINTM(MINFO, "RX: cmd port rx_len=%u\n", rx_len);
+			rx_blocks = (rx_len + MLAN_SDIO_BLOCK_SIZE - 1) /
+				    MLAN_SDIO_BLOCK_SIZE;
+			if (rx_len <= SDIO_INTF_HEADER_LEN ||
+			    (rx_blocks * MLAN_SDIO_BLOCK_SIZE) >
+				    ALLOC_BUF_SIZE) {
+				PRINTM(MERROR, "invalid rx_len=%d\n", rx_len);
+				ret = MLAN_STATUS_FAILURE;
+				goto done;
+			}
+			rx_len = (t_u16)(rx_blocks * MLAN_SDIO_BLOCK_SIZE);
+			pmbuf = wlan_alloc_mlan_buffer(pmadapter, rx_len, 0,
+						       MOAL_MALLOC_BUFFER);
+			if (pmbuf == MNULL) {
+				PRINTM(MERROR,
+				       "Failed to allocate 'mlan_buffer'\n");
+				ret = MLAN_STATUS_FAILURE;
+				goto done;
+			}
+			PRINTM(MINFO, "cmd rx buffer rx_len = %d\n", rx_len);
 
-		if ((upld_typ != MLAN_TYPE_CMD) &&
-		    (upld_typ != MLAN_TYPE_EVENT))
-			PRINTM(MERROR,
-			       "receive a wrong packet from CMD PORT. type =0x%x\n",
-			       upld_typ);
+			/* Transfer data from card */
+			if (MLAN_STATUS_SUCCESS !=
+			    wlan_sdio_card_to_host(pmadapter, &upld_typ,
+						   (t_u32 *)&pmadapter->upld_len,
+						   pmbuf, rx_len,
+						   pmadapter->pcard_sd->ioport |
+							   CMD_PORT_SLCT)) {
+				pmadapter->dbg.num_cmdevt_card_to_host_failure++;
+				PRINTM(MERROR,
+				       "Card-to-host cmd failed: int status=0x%x\n",
+				       sdio_ireg);
+				wlan_free_mlan_buffer(pmadapter, pmbuf);
+				ret = MLAN_STATUS_FAILURE;
+				goto term_cmd53;
+			}
 
-		wlan_decode_rx_packet(pmadapter, pmbuf, upld_typ, MFALSE);
+			if ((upld_typ != MLAN_TYPE_CMD) &&
+			    (upld_typ != MLAN_TYPE_EVENT))
+				PRINTM(MERROR,
+				       "receive a wrong packet from CMD PORT. type =0x%x\n",
+				       upld_typ);
 
-		/* We might receive data/sleep_cfm at the same time */
-		/* reset data_receive flag to avoid ps_state change */
-		if ((ps_state == PS_STATE_SLEEP_CFM) &&
-		    (pmadapter->ps_state == PS_STATE_SLEEP))
-			pmadapter->data_received = MFALSE;
+			wlan_decode_rx_packet(pmadapter, pmbuf, upld_typ,
+					      MFALSE);
+
+			/* We might receive data/sleep_cfm at the same time */
+			/* reset data_receive flag to avoid ps_state change */
+			if ((ps_state == PS_STATE_SLEEP_CFM) &&
+			    (pmadapter->ps_state == PS_STATE_SLEEP))
+				pmadapter->data_received = MFALSE;
+		}
 	}
 
 	if (sdio_ireg & DN_LD_HOST_INT_STATUS) {
@@ -2164,12 +2793,16 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 		pmadapter->pcard_sd->mp_wr_bitmap |=
 			((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_u])
 			<< 8;
-		pmadapter->pcard_sd->mp_wr_bitmap |=
-			((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_1l])
-			<< 16;
-		pmadapter->pcard_sd->mp_wr_bitmap |=
-			((t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_1u])
-			<< 24;
+		if (new_mode) {
+			pmadapter->pcard_sd->mp_wr_bitmap |=
+				((t_u32)pmadapter->pcard_sd
+					 ->mp_regs[reg->wr_bitmap_1l])
+				<< 16;
+			pmadapter->pcard_sd->mp_wr_bitmap |=
+				((t_u32)pmadapter->pcard_sd
+					 ->mp_regs[reg->wr_bitmap_1u])
+				<< 24;
+		}
 		bit_count = bitcount(pmadapter->pcard_sd->mp_wr_bitmap &
 				     pmadapter->pcard_sd->mp_data_port_mask);
 		if (bit_count) {
@@ -2188,10 +2821,21 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 		if (pmadapter->data_sent &&
 		    (pmadapter->pcard_sd->mp_wr_bitmap &
 		     (1 << pmadapter->pcard_sd->curr_wr_port))) {
+			pmadapter->callbacks.moal_tp_accounting_rx_param(
+				pmadapter->pmoal_handle, 3, 0);
 			PRINTM(MINFO, " <--- Tx DONE Interrupt --->\n");
 			pmadapter->data_sent = MFALSE;
 		}
 	}
+	if ((!new_mode) && (pmadapter->cmd_sent == MTRUE)) {
+		/* Check if firmware has attach buffer at command port and
+		 * update just that in wr_bit_map. */
+		pmadapter->pcard_sd->mp_wr_bitmap |=
+			(t_u32)pmadapter->pcard_sd->mp_regs[reg->wr_bitmap_l] &
+			CTRL_PORT_MASK;
+		if (pmadapter->pcard_sd->mp_wr_bitmap & CTRL_PORT_MASK)
+			pmadapter->cmd_sent = MFALSE;
+	}
 
 	if (sdio_ireg & UP_LD_HOST_INT_STATUS) {
 		pmadapter->pcard_sd->mp_rd_bitmap =
@@ -2199,14 +2843,23 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 		pmadapter->pcard_sd->mp_rd_bitmap |=
 			((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_u])
 			<< 8;
-		pmadapter->pcard_sd->mp_rd_bitmap |=
-			((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_1l])
-			<< 16;
-		pmadapter->pcard_sd->mp_rd_bitmap |=
-			((t_u32)pmadapter->pcard_sd->mp_regs[reg->rd_bitmap_1u])
-			<< 24;
+		if (new_mode) {
+			pmadapter->pcard_sd->mp_rd_bitmap |=
+				((t_u32)pmadapter->pcard_sd
+					 ->mp_regs[reg->rd_bitmap_1l])
+				<< 16;
+			pmadapter->pcard_sd->mp_rd_bitmap |=
+				((t_u32)pmadapter->pcard_sd
+					 ->mp_regs[reg->rd_bitmap_1u])
+				<< 24;
+		}
+		pmadapter->pcard_sd->last_recv_rd_bitmap =
+			pmadapter->pcard_sd->mp_rd_bitmap;
+
 		PRINTM(MINTR, "UPLD: rd_bitmap=0x%08x\n",
 		       pmadapter->pcard_sd->mp_rd_bitmap);
+		pmadapter->callbacks.moal_tp_accounting_rx_param(
+			pmadapter->pmoal_handle, 0, 0);
 
 		while (MTRUE) {
 			ret = wlan_get_rd_port(pmadapter, &port);
@@ -2233,7 +2886,8 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 				goto done;
 			}
 			rx_len = (t_u16)(rx_blocks * MLAN_SDIO_BLOCK_SIZE);
-			if (rx_len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE)
+
+			if (!new_mode && (port == CTRL_PORT))
 				pmbuf = wlan_alloc_mlan_buffer(
 					pmadapter, rx_len, 0,
 					MOAL_MALLOC_BUFFER);
@@ -2256,7 +2910,12 @@ mlan_status wlan_process_sdio_int_status(mlan_adapter *pmadapter)
 			if (MLAN_STATUS_SUCCESS !=
 			    wlan_sdio_card_to_host_mp_aggr(pmadapter, pmbuf,
 							   port, rx_len)) {
-				pmadapter->dbg.num_rx_card_to_host_failure++;
+				if ((!new_mode) && (port == CTRL_PORT))
+					pmadapter->dbg
+						.num_cmdevt_card_to_host_failure++;
+				else
+					pmadapter->dbg
+						.num_rx_card_to_host_failure++;
 
 				PRINTM(MERROR,
 				       "Card to host failed: int status=0x%x\n",
@@ -2317,6 +2976,7 @@ mlan_status wlan_sdio_host_to_card(mlan_adapter *pmadapter, t_u8 type,
 	t_u8 port = 0;
 	t_u32 cmd53_port = 0;
 	t_u8 *payload = pmbuf->pbuf + pmbuf->data_offset;
+	t_bool new_mode = pmadapter->pcard_sd->supports_sdio_new_mode;
 
 	ENTER();
 
@@ -2353,6 +3013,9 @@ mlan_status wlan_sdio_host_to_card(mlan_adapter *pmadapter, t_u8 type,
 	} else {
 		/*Type must be MLAN_TYPE_CMD*/
 		pmadapter->cmd_sent = MTRUE;
+		if (!new_mode)
+			pmadapter->pcard_sd->mp_wr_bitmap &=
+				(t_u32)(~(1 << CTRL_PORT));
 		if (pmbuf->data_len <= SDIO_INTF_HEADER_LEN ||
 		    pmbuf->data_len > WLAN_UPLD_SIZE)
 			PRINTM(MWARN,
@@ -2360,7 +3023,11 @@ mlan_status wlan_sdio_host_to_card(mlan_adapter *pmadapter, t_u8 type,
 			       payload, pmbuf->data_len);
 		/* Transfer data to card */
 		pmbuf->data_len = buf_block_len * blksz;
-		cmd53_port = (pmadapter->pcard_sd->ioport) | CMD_PORT_SLCT;
+		if (new_mode)
+			cmd53_port =
+				(pmadapter->pcard_sd->ioport) | CMD_PORT_SLCT;
+		else
+			cmd53_port = pmadapter->pcard_sd->ioport + CTRL_PORT;
 		ret = wlan_write_data_sync(pmadapter, pmbuf, cmd53_port);
 	}
 
@@ -2387,7 +3054,6 @@ mlan_status wlan_sdio_host_to_card(mlan_adapter *pmadapter, t_u8 type,
 	return ret;
 }
 
-#if (defined(SD9098) || defined(SD9097))
 /**
  *  @brief This function sends vdll data to the card.
  *
@@ -2396,7 +3062,8 @@ mlan_status wlan_sdio_host_to_card(mlan_adapter *pmadapter, t_u8 type,
  * SDIO header)
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_sdio_send_vdll(mlan_adapter *pmadapter, mlan_buffer *pmbuf)
+static mlan_status wlan_sdio_send_vdll(mlan_adapter *pmadapter,
+				       mlan_buffer *pmbuf)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 buf_block_len;
@@ -2428,7 +3095,6 @@ mlan_status wlan_sdio_send_vdll(mlan_adapter *pmadapter, mlan_buffer *pmbuf)
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
  *  @brief This function sends data to the card.
@@ -2440,17 +3106,15 @@ mlan_status wlan_sdio_send_vdll(mlan_adapter *pmadapter, mlan_buffer *pmbuf)
  *  @param tx_param  A pointer to mlan_tx_param
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_sdio_host_to_card_ext(pmlan_private pmpriv, t_u8 type,
-				       mlan_buffer *pmbuf,
-				       mlan_tx_param *tx_param)
+static mlan_status wlan_sdio_host_to_card_ext(pmlan_private pmpriv, t_u8 type,
+					      mlan_buffer *pmbuf,
+					      mlan_tx_param *tx_param)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_adapter *pmadapter = pmpriv->adapter;
 
-#if (defined(SD9098) || defined(SD9097))
 	if (type == MLAN_TYPE_VDLL)
 		return wlan_sdio_send_vdll(pmadapter, pmbuf);
-#endif
 	ret = wlan_sdio_host_to_card(pmadapter, type, pmbuf, tx_param);
 
 	if (type == MLAN_TYPE_DATA && ret == MLAN_STATUS_FAILURE)
@@ -2475,7 +3139,7 @@ void wlan_decode_spa_buffer(mlan_adapter *pmadapter, t_u8 *buf, t_u32 len)
 	t_u8 block_num = 0;
 	t_u16 block_size = 0;
 	t_u8 *data;
-	t_u32 pkt_len, pkt_type = 0;
+	t_u32 pkt_len;
 	mlan_buffer *mbuf_deaggr = MNULL;
 
 	ENTER();
@@ -2500,8 +3164,6 @@ void wlan_decode_spa_buffer(mlan_adapter *pmadapter, t_u8 *buf, t_u32 len)
 		}
 		pkt_len = wlan_le16_to_cpu(
 			*(t_u16 *)(data + OFFSET_OF_SDIO_HEADER));
-		pkt_type = wlan_le16_to_cpu(
-			*(t_u16 *)(data + OFFSET_OF_SDIO_HEADER + 2));
 		if ((pkt_len + OFFSET_OF_SDIO_HEADER) > block_size) {
 			PRINTM(MERROR,
 			       "Error in pkt, pkt_len=%d, block_size=%d\n",
@@ -2566,7 +3228,7 @@ mlan_status wlan_alloc_sdio_mpa_buffers(mlan_adapter *pmadapter,
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
-	t_u8 mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
+	t_u8 mp_aggr_pkt_limit = pmadapter->pcard_sd->mp_aggr_pkt_limit;
 
 	ENTER();
 
@@ -2669,8 +3331,8 @@ mlan_status wlan_re_alloc_sdio_rx_mpa_buffer(mlan_adapter *pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
-	t_u8 mp_aggr_pkt_limit = SDIO_MP_AGGR_DEF_PKT_LIMIT;
-	t_u32 mpa_rx_buf_size = SDIO_MP_AGGR_BUF_SIZE_MAX;
+	t_u8 mp_aggr_pkt_limit = pmadapter->pcard_sd->mp_aggr_pkt_limit;
+	t_u32 mpa_rx_buf_size = pmadapter->pcard_sd->mp_tx_aggr_buf_size;
 
 	if (pmadapter->pcard_sd->mpa_rx.buf) {
 		pcb->moal_mfree(pmadapter->pmoal_handle,
@@ -2740,14 +3402,18 @@ mlan_status wlan_re_alloc_sdio_rx_mpa_buffer(mlan_adapter *pmadapter)
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pm_sdio_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
+static mlan_status wlan_pm_sdio_wakeup_card(pmlan_adapter pmadapter,
+					    t_u8 timeout)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 age_ts_usec;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 
 	ENTER();
-	PRINTM(MEVENT, "Wakeup device...\n");
+	if (pmadapter->second_mac)
+		PRINTM(MEVENT, "#2 Wakeup device...\n");
+	else
+		PRINTM(MEVENT, "Wakeup device...\n");
 	pmadapter->callbacks.moal_get_system_time(pmadapter->pmoal_handle,
 						  &pmadapter->pm_wakeup_in_secs,
 						  &age_ts_usec);
@@ -2755,7 +3421,7 @@ mlan_status wlan_pm_sdio_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
 	if (timeout) {
 		pmadapter->callbacks.moal_start_timer(
 			pmadapter->pmoal_handle, pmadapter->pwakeup_fw_timer,
-			MFALSE, MRVDRV_TIMER_3S);
+			MFALSE, MRVDRV_TIMER_5S);
 		pmadapter->wakeup_fw_timer_is_set = MTRUE;
 	}
 
@@ -2773,7 +3439,7 @@ mlan_status wlan_pm_sdio_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pm_sdio_reset_card(pmlan_adapter pmadapter)
+static mlan_status wlan_pm_sdio_reset_card(pmlan_adapter pmadapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -2910,8 +3576,6 @@ mlan_status wlan_reset_fw(pmlan_adapter pmadapter)
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-#if defined(SD8997) || defined(SD8977) || defined(SD8987) ||                   \
-	defined(SD9098) || defined(SD9097) || defined(SD8978)
 	if (MFALSE
 #ifdef SD8997
 	    || IS_SD8997(pmadapter->card_type)
@@ -2930,6 +3594,13 @@ mlan_status wlan_reset_fw(pmlan_adapter pmadapter)
 #endif
 #ifdef SD9097
 	    || IS_SD9097(pmadapter->card_type)
+#endif
+#ifdef SDIW62X
+	    || IS_SDIW62X(pmadapter->card_type)
+#endif
+	    || IS_SDAW693(pmadapter->card_type)
+#ifdef SD9177
+	    || IS_SD9177(pmadapter->card_type)
 #endif
 	) {
 		pcb->moal_read_reg(pmadapter->pmoal_handle,
@@ -2938,7 +3609,6 @@ mlan_status wlan_reset_fw(pmlan_adapter pmadapter)
 				    HOST_TO_CARD_EVENT_REG,
 				    value | HOST_POWER_UP);
 	}
-#endif
 	/* Poll register around 100 ms */
 	for (tries = 0; tries < MAX_POLL_TRIES; ++tries) {
 		pcb->moal_read_reg(pmadapter->pmoal_handle, reset_reg, &value);
@@ -2968,8 +3638,9 @@ mlan_status wlan_reset_fw(pmlan_adapter pmadapter)
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return          N/A
  */
-mlan_status wlan_sdio_data_evt_complete(pmlan_adapter pmadapter,
-					mlan_buffer *pmbuf, mlan_status status)
+static mlan_status wlan_sdio_data_evt_complete(pmlan_adapter pmadapter,
+					       mlan_buffer *pmbuf,
+					       mlan_status status)
 {
 	ENTER();
 
@@ -2986,8 +3657,8 @@ mlan_status wlan_sdio_data_evt_complete(pmlan_adapter pmadapter,
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return
  */
-mlan_status wlan_sdio_handle_rx_packet(mlan_adapter *pmadapter,
-				       pmlan_buffer pmbuf)
+static mlan_status wlan_sdio_handle_rx_packet(mlan_adapter *pmadapter,
+					      pmlan_buffer pmbuf)
 {
 	ENTER();
 
@@ -3008,6 +3679,8 @@ mlan_adapter_operations mlan_sdio_ops = {
 	.data_complete = wlan_sdio_data_evt_complete,
 	.cmdrsp_complete = wlan_sdio_data_evt_complete,
 	.handle_rx_packet = wlan_sdio_handle_rx_packet,
+	.disable_host_int = wlan_disable_sdio_host_int,
+	.enable_host_int = wlan_enable_sdio_host_int,
 
 	.intf_header_len = SDIO_INTF_HEADER_LEN,
 };
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h
old mode 100644
new mode 100755
index 6f653365a..4d0fa3e35
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sdio.h
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -130,7 +130,10 @@ Change log:
 #define REG_PORT 0
 /** Port for memory */
 #define MEM_PORT 0x10000
-
+/** Ctrl port */
+#define CTRL_PORT 0
+/** Ctrl port mask */
+#define CTRL_PORT_MASK 0x0001
 /** Card Control Registers : cmd53 new mode */
 #define CMD53_NEW_MODE (0x1U << 0)
 /** Card Control Registers : cmd53 tx len format 1 (0x10) */
@@ -191,6 +194,29 @@ Change log:
 		a->pcard_sd->mpa_tx.pkt_cnt++;                                 \
 	} while (0)
 
+#define MP_TX_AGGR_BUF_PUT_NONEWMODE(a, mbuf, port)                            \
+	do {                                                                   \
+		pmadapter->callbacks.moal_memmove(                             \
+			a->pmoal_handle,                                       \
+			&a->pcard_sd->mpa_tx.buf[a->pcard_sd->mpa_tx.buf_len], \
+			mbuf->pbuf + mbuf->data_offset, mbuf->data_len);       \
+		a->pcard_sd->mpa_tx.buf_len += mbuf->data_len;                 \
+		a->pcard_sd->mpa_tx.mp_wr_info[a->pcard_sd->mpa_tx.pkt_cnt] =  \
+			*(t_u16 *)(mbuf->pbuf + mbuf->data_offset);            \
+		if (!a->pcard_sd->mpa_tx.pkt_cnt) {                            \
+			a->pcard_sd->mpa_tx.start_port = port;                 \
+		}                                                              \
+		if (a->pcard_sd->mpa_tx.start_port <= port) {                  \
+			a->pcard_sd->mpa_tx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_tx.pkt_cnt));          \
+		} else {                                                       \
+			a->pcard_sd->mpa_tx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_tx.pkt_cnt + 1 +       \
+				       (a->pcard_sd->max_ports -               \
+					a->pcard_sd->mp_end_port)));           \
+		}                                                              \
+		a->pcard_sd->mpa_tx.pkt_cnt++;                                 \
+	} while (0)
 #define MP_TX_AGGR_BUF_PUT_SG(a, mbuf, port)                                   \
 	do {                                                                   \
 		a->pcard_sd->mpa_tx.buf_len += mbuf->data_len;                 \
@@ -204,10 +230,37 @@ Change log:
 		a->pcard_sd->mpa_tx.ports |= (1 << port);                      \
 		a->pcard_sd->mpa_tx.pkt_cnt++;                                 \
 	} while (0)
+#define MP_TX_AGGR_BUF_PUT_SG_NONEWMODE(a, mbuf, port)                         \
+	do {                                                                   \
+		a->pcard_sd->mpa_tx.buf_len += mbuf->data_len;                 \
+		a->pcard_sd->mpa_tx.mp_wr_info[a->pcard_sd->mpa_tx.pkt_cnt] =  \
+			*(t_u16 *)(mbuf->pbuf + mbuf->data_offset);            \
+		a->pcard_sd->mpa_tx.mbuf_arr[a->pcard_sd->mpa_tx.pkt_cnt] =    \
+			mbuf;                                                  \
+		if (!a->pcard_sd->mpa_tx.pkt_cnt) {                            \
+			a->pcard_sd->mpa_tx.start_port = port;                 \
+		}                                                              \
+		if (a->pcard_sd->mpa_tx.start_port <= port) {                  \
+			a->pcard_sd->mpa_tx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_tx.pkt_cnt));          \
+		} else {                                                       \
+			a->pcard_sd->mpa_tx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_tx.pkt_cnt + 1 +       \
+				       (a->pcard_sd->max_ports -               \
+					a->pcard_sd->mp_end_port)));           \
+		}                                                              \
+		a->pcard_sd->mpa_tx.pkt_cnt++;                                 \
+	} while (0)
+
 /** SDIO Tx aggregation limit ? */
 #define MP_TX_AGGR_PKT_LIMIT_REACHED(a)                                        \
 	((a->pcard_sd->mpa_tx.pkt_cnt) == (a->pcard_sd->mpa_tx.pkt_aggr_limit))
 
+#define MP_TX_AGGR_PORT_LIMIT_REACHED(a)                                       \
+	((a->pcard_sd->curr_wr_port < a->pcard_sd->mpa_tx.start_port) &&       \
+	 (((a->pcard_sd->max_ports - a->pcard_sd->mpa_tx.start_port) +         \
+	   a->pcard_sd->curr_wr_port) >= a->pcard_sd->mp_aggr_pkt_limit))
+
 /** Reset SDIO Tx aggregation buffer parameters */
 #define MP_TX_AGGR_BUF_RESET(a)                                                \
 	do {                                                                   \
@@ -231,11 +284,16 @@ Change log:
 /* note: hw rx wraps round only after port (MAX_PORT-1) */
 #define MP_RX_AGGR_PORT_LIMIT_REACHED(a)                                       \
 	(((a->pcard_sd->curr_rd_port < a->pcard_sd->mpa_rx.start_port) &&      \
-	  (((MAX_PORT - a->pcard_sd->mpa_rx.start_port) +                      \
+	  (((a->pcard_sd->max_ports - a->pcard_sd->mpa_rx.start_port) +        \
 	    a->pcard_sd->curr_rd_port) >= (a->pcard_sd->mp_end_port >> 1))) || \
 	 ((a->pcard_sd->curr_rd_port - a->pcard_sd->mpa_rx.start_port) >=      \
 	  (a->pcard_sd->mp_end_port >> 1)))
 
+#define MP_RX_AGGR_PORT_LIMIT_REACHED_NONEWMODE(a)                             \
+	((a->pcard_sd->curr_rd_port < a->pcard_sd->mpa_rx.start_port) &&       \
+	 (((a->pcard_sd->max_ports - a->pcard_sd->mpa_rx.start_port) +         \
+	   a->pcard_sd->curr_rd_port) >= a->pcard_sd->mp_aggr_pkt_limit))
+
 /** SDIO Rx aggregation in progress ? */
 #define MP_RX_AGGR_IN_PROGRESS(a) (a->pcard_sd->mpa_rx.pkt_cnt > 0)
 
@@ -258,6 +316,26 @@ Change log:
 		a->pcard_sd->mpa_rx.pkt_cnt++;                                 \
 	} while (0)
 
+#define MP_RX_AGGR_SETUP_NONEWMODE(a, mbuf, port, rx_len)                      \
+	do {                                                                   \
+		a->pcard_sd->mpa_rx.buf_len += rx_len;                         \
+		if (!a->pcard_sd->mpa_rx.pkt_cnt) {                            \
+			a->pcard_sd->mpa_rx.start_port = port;                 \
+		}                                                              \
+		if (a->pcard_sd->mpa_rx.start_port <= port) {                  \
+			a->pcard_sd->mpa_rx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_rx.pkt_cnt));          \
+		} else {                                                       \
+			a->pcard_sd->mpa_rx.ports |=                           \
+				(1 << (a->pcard_sd->mpa_rx.pkt_cnt + 1));      \
+		}                                                              \
+		a->pcard_sd->mpa_rx.mbuf_arr[a->pcard_sd->mpa_rx.pkt_cnt] =    \
+			mbuf;                                                  \
+		a->pcard_sd->mpa_rx.len_arr[a->pcard_sd->mpa_rx.pkt_cnt] =     \
+			rx_len;                                                \
+		a->pcard_sd->mpa_rx.pkt_cnt++;                                 \
+	} while (0);
+
 /** Reset SDIO Rx aggregation buffer parameters */
 #define MP_RX_AGGR_BUF_RESET(a)                                                \
 	do {                                                                   \
@@ -272,261 +350,7 @@ Change log:
 /** max aggr buf size 64k-256 */
 #define SDIO_MP_AGGR_BUF_SIZE_MAX (65280)
 
-#ifdef SD8887
-static const struct _mlan_sdio_card_reg mlan_reg_sd8887 = {
-	.start_rd_port = 0,
-	.start_wr_port = 0,
-	.base_0_reg = 0x6C,
-	.base_1_reg = 0x6D,
-	.poll_reg = 0x5C,
-	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
-			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
-	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
-			   DN_LD_CMD_PORT_HOST_INT_STATUS |
-			   UP_LD_CMD_PORT_HOST_INT_STATUS,
-	.status_reg_0 = 0x90,
-	.status_reg_1 = 0x91,
-	.sdio_int_mask = 0xff,
-	.data_port_mask = 0xffffffff,
-	.max_mp_regs = 196,
-	.rd_bitmap_l = 0x10,
-	.rd_bitmap_u = 0x11,
-	.rd_bitmap_1l = 0x12,
-	.rd_bitmap_1u = 0x13,
-	.wr_bitmap_l = 0x14,
-	.wr_bitmap_u = 0x15,
-	.wr_bitmap_1l = 0x16,
-	.wr_bitmap_1u = 0x17,
-	.rd_len_p0_l = 0x18,
-	.rd_len_p0_u = 0x19,
-	.card_config_2_1_reg = 0xD9,
-	.cmd_config_0 = 0xC4,
-	.cmd_config_1 = 0xC5,
-	.cmd_config_2 = 0xC6,
-	.cmd_config_3 = 0xC7,
-	.cmd_rd_len_0 = 0xC0,
-	.cmd_rd_len_1 = 0xC1,
-	.cmd_rd_len_2 = 0xC2,
-	.cmd_rd_len_3 = 0xC3,
-	.io_port_0_reg = 0xE4,
-	.io_port_1_reg = 0xE5,
-	.io_port_2_reg = 0xE6,
-	.host_int_rsr_reg = 0x04,
-	.host_int_mask_reg = 0x08,
-	.host_int_status_reg = 0x0C,
-	.host_restart_reg = 0x58,
-	.card_to_host_event_reg = 0x5C,
-	.host_interrupt_mask_reg = 0x60,
-	.card_interrupt_status_reg = 0x64,
-	.card_interrupt_rsr_reg = 0x68,
-	.card_revision_reg = 0xC8,
-	.card_ocr_0_reg = 0xD4,
-	.card_ocr_1_reg = 0xD5,
-	.card_ocr_3_reg = 0xD6,
-	.card_config_reg = 0xD7,
-	.card_misc_cfg_reg = 0xD8,
-	.debug_0_reg = 0xDC,
-	.debug_1_reg = 0xDD,
-	.debug_2_reg = 0xDE,
-	.debug_3_reg = 0xDF,
-	.fw_reset_reg = 0x0B6,
-	.fw_reset_val = 1,
-	.winner_check_reg = 0x90,
-};
-
-static const struct _mlan_card_info mlan_card_info_sd8887 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
-	.v16_fw_api = 0,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
-};
-#endif
-
-#ifdef SD8897
-static const struct _mlan_sdio_card_reg mlan_reg_sd8897 = {
-	.start_rd_port = 0,
-	.start_wr_port = 0,
-	.base_0_reg = 0x60,
-	.base_1_reg = 0x61,
-	.poll_reg = 0x50,
-	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
-			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
-	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
-			   DN_LD_CMD_PORT_HOST_INT_STATUS |
-			   UP_LD_CMD_PORT_HOST_INT_STATUS,
-	.status_reg_0 = 0xC0,
-	.status_reg_1 = 0xC1,
-	.sdio_int_mask = 0xff,
-	.data_port_mask = 0xffffffff,
-	.max_mp_regs = 184,
-	.rd_bitmap_l = 0x04,
-	.rd_bitmap_u = 0x05,
-	.rd_bitmap_1l = 0x06,
-	.rd_bitmap_1u = 0x07,
-	.wr_bitmap_l = 0x08,
-	.wr_bitmap_u = 0x09,
-	.wr_bitmap_1l = 0x0A,
-	.wr_bitmap_1u = 0x0B,
-	.rd_len_p0_l = 0x0C,
-	.rd_len_p0_u = 0x0D,
-	.card_config_2_1_reg = 0xCD,
-	.cmd_config_0 = 0xB8,
-	.cmd_config_1 = 0xB9,
-	.cmd_config_2 = 0xBA,
-	.cmd_config_3 = 0xBB,
-	.cmd_rd_len_0 = 0xB4,
-	.cmd_rd_len_1 = 0xB5,
-	.cmd_rd_len_2 = 0xB6,
-	.cmd_rd_len_3 = 0xB7,
-	.io_port_0_reg = 0xD8,
-	.io_port_1_reg = 0xD9,
-	.io_port_2_reg = 0xDA,
-	.host_int_rsr_reg = 0x01,
-	.host_int_mask_reg = 0x02,
-	.host_int_status_reg = 0x03,
-	.host_restart_reg = 0x4C,
-	.card_to_host_event_reg = 0x50,
-	.host_interrupt_mask_reg = 0x54,
-	.card_interrupt_status_reg = 0x58,
-	.card_interrupt_rsr_reg = 0x5C,
-	.card_revision_reg = 0xBC,
-	.card_ocr_0_reg = 0xC8,
-	.card_ocr_1_reg = 0xC9,
-	.card_ocr_3_reg = 0xCA,
-	.card_config_reg = 0xCB,
-	.card_misc_cfg_reg = 0xCC,
-	.debug_0_reg = 0xD0,
-	.debug_1_reg = 0xD1,
-	.debug_2_reg = 0xD2,
-	.debug_3_reg = 0xD3,
-	.fw_reset_reg = 0x0E8,
-	.fw_reset_val = 1,
-	.winner_check_reg = 0xC0,
-};
-
-static const struct _mlan_card_info mlan_card_info_sd8897 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 0,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-
-#if defined(SD8977) || defined(SD8997) || defined(SD8987) ||                   \
-	defined(SD9098) || defined(SD9097) || defined(SD8978)
-static const struct _mlan_sdio_card_reg mlan_reg_sd8977_sd8997 = {
-	.start_rd_port = 0,
-	.start_wr_port = 0,
-	.base_0_reg = 0xf8,
-	.base_1_reg = 0xf9,
-	.poll_reg = 0x5C,
-	.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |
-			   CMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,
-	.host_int_status = DN_LD_HOST_INT_STATUS | UP_LD_HOST_INT_STATUS |
-			   DN_LD_CMD_PORT_HOST_INT_STATUS |
-			   UP_LD_CMD_PORT_HOST_INT_STATUS,
-	.status_reg_0 = 0xe8,
-	.status_reg_1 = 0xe9,
-	.sdio_int_mask = 0xff,
-	.data_port_mask = 0xffffffff,
-	.max_mp_regs = 196,
-	.rd_bitmap_l = 0x10,
-	.rd_bitmap_u = 0x11,
-	.rd_bitmap_1l = 0x12,
-	.rd_bitmap_1u = 0x13,
-	.wr_bitmap_l = 0x14,
-	.wr_bitmap_u = 0x15,
-	.wr_bitmap_1l = 0x16,
-	.wr_bitmap_1u = 0x17,
-	.rd_len_p0_l = 0x18,
-	.rd_len_p0_u = 0x19,
-	.card_config_2_1_reg = 0xD9,
-	.cmd_config_0 = 0xC4,
-	.cmd_config_1 = 0xC5,
-	.cmd_config_2 = 0xC6,
-	.cmd_config_3 = 0xC7,
-	.cmd_rd_len_0 = 0xC0,
-	.cmd_rd_len_1 = 0xC1,
-	.cmd_rd_len_2 = 0xC2,
-	.cmd_rd_len_3 = 0xC3,
-	.io_port_0_reg = 0xE4,
-	.io_port_1_reg = 0xE5,
-	.io_port_2_reg = 0xE6,
-	.host_int_rsr_reg = 0x04,
-	.host_int_mask_reg = 0x08,
-	.host_int_status_reg = 0x0C,
-	.host_restart_reg = 0x58,
-	.card_to_host_event_reg = 0x5C,
-	.host_interrupt_mask_reg = 0x60,
-	.card_interrupt_status_reg = 0x64,
-	.card_interrupt_rsr_reg = 0x68,
-	.card_revision_reg = 0xC8,
-	.card_ocr_0_reg = 0xD4,
-	.card_ocr_1_reg = 0xD5,
-	.card_ocr_3_reg = 0xD6,
-	.card_config_reg = 0xD7,
-	.card_misc_cfg_reg = 0xD8,
-	.debug_0_reg = 0xDC,
-	.debug_1_reg = 0xDD,
-	.debug_2_reg = 0xDE,
-	.debug_3_reg = 0xDF,
-	.fw_reset_reg = 0x0EE,
-	.fw_reset_val = 0x99,
-	.fw_dnld_offset_0_reg = 0xEC,
-	.fw_dnld_offset_1_reg = 0xED,
-	.fw_dnld_offset_2_reg = 0xEE,
-	.fw_dnld_offset_3_reg = 0xEF,
-	.fw_dnld_status_0_reg = 0xE8,
-	.fw_dnld_status_1_reg = 0xE9,
-	.winner_check_reg = 0xFC,
-};
-
-#ifdef SD8997
-static const struct _mlan_card_info mlan_card_info_sd8997 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-
-#ifdef SD9097
-static const struct _mlan_card_info mlan_card_info_sd9097 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 1,
-	.v17_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-#ifdef SD9098
-static const struct _mlan_card_info mlan_card_info_sd9098 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
-	.v16_fw_api = 1,
-	.v17_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
-};
-#endif
-
-#if defined(SD8977) || defined(SD8978)
-static const struct _mlan_card_info mlan_card_info_sd8977 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
-	.v16_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
-};
-#endif
-
-#ifdef SD8987
-static const struct _mlan_card_info mlan_card_info_sd8987 = {
-	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
-	.v16_fw_api = 1,
-	.supp_ps_handshake = 0,
-	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
-};
-#endif
-#endif
+extern mlan_adapter_operations mlan_sdio_ops;
 
 /** Probe and initialization function */
 mlan_status wlan_sdio_probe(pmlan_adapter pmadapter);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c
old mode 100644
new mode 100755
index 2859aa9e7..45ba817bd
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_shim.c
@@ -3,7 +3,7 @@
  *  @brief This file contains APIs to MOAL module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -56,7 +56,7 @@ Change log:
 			Global Variables
 ********************************************************/
 #ifdef STA_SUPPORT
-mlan_operations mlan_sta_ops = {
+static mlan_operations mlan_sta_ops = {
 	/* init cmd handler */
 	wlan_ops_sta_init_cmd,
 	/* ioctl handler */
@@ -76,7 +76,7 @@ mlan_operations mlan_sta_ops = {
 };
 #endif
 #ifdef UAP_SUPPORT
-mlan_operations mlan_uap_ops = {
+static mlan_operations mlan_uap_ops = {
 	/* init cmd handler */
 	wlan_ops_uap_init_cmd,
 	/* ioctl handler */
@@ -140,7 +140,7 @@ extern mlan_status wlan_get_usb_device(pmlan_adapter pmadapter);
  *  @param pmadapter  A pointer to mlan_adapter structure
  *
  */
-void wlan_process_pending_ioctl(mlan_adapter *pmadapter)
+static void wlan_process_pending_ioctl(mlan_adapter *pmadapter)
 {
 	pmlan_ioctl_req pioctl_buf;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -170,7 +170,6 @@ void wlan_process_pending_ioctl(mlan_adapter *pmadapter)
 			}
 			break;
 #endif
-#ifdef STA_SUPPORT
 		case MLAN_IOCTL_MISC_CFG:
 			misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
 			if (misc->sub_command == MLAN_OID_MISC_WARM_RESET) {
@@ -179,7 +178,6 @@ void wlan_process_pending_ioctl(mlan_adapter *pmadapter)
 								    pioctl_buf);
 			}
 			break;
-#endif
 		default:
 			break;
 		}
@@ -192,15 +190,6 @@ void wlan_process_pending_ioctl(mlan_adapter *pmadapter)
 /********************************************************
 			Global Functions
 ********************************************************/
-#ifdef USB
-extern mlan_adapter_operations mlan_usb_ops;
-#endif
-#ifdef PCIE
-extern mlan_adapter_operations mlan_pcie_ops;
-#endif
-#ifdef SDIO
-extern mlan_adapter_operations mlan_sdio_ops;
-#endif
 
 /**
  *  @brief This function registers MOAL to MLAN module.
@@ -266,6 +255,8 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
+	if (pmdevice->callbacks.moal_recv_amsdu_packet)
+		PRINTM(MMSG, "Enable moal_recv_amsdu_packet\n");
 
 	/* Allocate memory for adapter structure */
 	if (pmdevice->callbacks.moal_vmalloc && pmdevice->callbacks.moal_vfree)
@@ -327,6 +318,8 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 	MASSERT(pcb->moal_spin_lock);
 	MASSERT(pcb->moal_spin_unlock);
 	MASSERT(pcb->moal_hist_data_add);
+	MASSERT(pcb->moal_updata_peer_signal);
+	MASSERT(pcb->moal_do_div);
 	/* Save pmoal_handle */
 	pmadapter->pmoal_handle = pmdevice->pmoal_handle;
 
@@ -335,6 +328,7 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 	pmadapter->card_type = pmdevice->card_type;
 	pmadapter->card_rev = pmdevice->card_rev;
 	pmadapter->init_para.uap_max_sta = pmdevice->uap_max_sta;
+	pmadapter->init_para.mcs32 = pmdevice->mcs32;
 
 #ifdef SDIO
 	if (IS_SD(pmadapter->card_type)) {
@@ -386,6 +380,7 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 		memcpy_ext(pmadapter, &pmadapter->ops, &mlan_pcie_ops,
 			   sizeof(mlan_adapter_operations),
 			   sizeof(mlan_adapter_operations));
+		pmadapter->init_para.ring_size = pmdevice->ring_size;
 		ret = wlan_get_pcie_device(pmadapter);
 		if (MLAN_STATUS_SUCCESS != ret) {
 			ret = MLAN_STATUS_FAILURE;
@@ -420,6 +415,7 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 	pmadapter->init_para.mfg_mode = pmdevice->mfg_mode;
 #endif
 	pmadapter->init_para.auto_ds = pmdevice->auto_ds;
+	pmadapter->init_para.ext_scan = pmdevice->ext_scan;
 	pmadapter->init_para.ps_mode = pmdevice->ps_mode;
 	if (pmdevice->max_tx_buf == MLAN_TX_DATA_BUF_SIZE_2K ||
 	    pmdevice->max_tx_buf == MLAN_TX_DATA_BUF_SIZE_4K ||
@@ -444,7 +440,8 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 
 	pmadapter->multiple_dtim = pmdevice->multi_dtim;
 	pmadapter->inact_tmo = pmdevice->inact_tmo;
-	pmadapter->init_para.fw_region = pmdevice->fw_region;
+	pmadapter->init_para.drcs_chantime_mode = pmdevice->drcs_chantime_mode;
+	pmadapter->second_mac = pmdevice->second_mac;
 	pmadapter->hs_wake_interval = pmdevice->hs_wake_interval;
 	if (pmdevice->indication_gpio != 0xff) {
 		pmadapter->ind_gpio = pmdevice->indication_gpio & 0x0f;
@@ -462,9 +459,12 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 		pmadapter->rx_cmd_ep = pmdevice->rx_cmd_ep;
 		pmadapter->tx_data_ep = pmdevice->tx_data_ep;
 		pmadapter->rx_data_ep = pmdevice->rx_data_ep;
+		pmadapter->usb_tx_ports[0] = pmdevice->tx_data_ep;
+		pmadapter->usb_tx_ports[1] = pmdevice->tx_data2_ep;
 	}
 #endif
 	pmadapter->init_para.dfs53cfg = pmdevice->dfs53cfg;
+	pmadapter->init_para.dfs_offload = pmdevice->dfs_offload;
 	pmadapter->priv_num = 0;
 	pmadapter->priv[0] = MNULL;
 
@@ -485,24 +485,40 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 	memset(pmadapter, pmadapter->priv[0], 0, sizeof(mlan_private));
 
 	pmadapter->priv[0]->adapter = pmadapter;
-	pmadapter->priv[0]->bss_type = (t_u8)pmdevice->bss_attr[0].bss_type;
-	pmadapter->priv[0]->frame_type = (t_u8)pmdevice->bss_attr[0].frame_type;
-	pmadapter->priv[0]->bss_priority =
-		(t_u8)pmdevice->bss_attr[0].bss_priority;
-	if (pmdevice->bss_attr[0].bss_type == MLAN_BSS_TYPE_STA)
+	if (pmdevice->drv_mode & DRV_MODE_MASK) {
+		/* Save bss_type, frame_type & bss_priority */
+		pmadapter->priv[0]->bss_type = 0xff;
+		pmadapter->priv[0]->frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
+		pmadapter->priv[0]->bss_priority = 0;
 		pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_STA;
-	else if (pmdevice->bss_attr[0].bss_type == MLAN_BSS_TYPE_UAP)
-		pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_UAP;
+
+		/* Save bss_index and bss_num */
+		pmadapter->priv[0]->bss_index = 0;
+		pmadapter->priv[0]->bss_num = 0xff;
+	} else {
+		pmadapter->priv[0]->bss_type =
+			(t_u8)pmdevice->bss_attr[0].bss_type;
+		pmadapter->priv[0]->frame_type =
+			(t_u8)pmdevice->bss_attr[0].frame_type;
+		pmadapter->priv[0]->bss_priority =
+			(t_u8)pmdevice->bss_attr[0].bss_priority;
+		if (pmdevice->bss_attr[0].bss_type == MLAN_BSS_TYPE_STA)
+			pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_STA;
+		else if (pmdevice->bss_attr[0].bss_type == MLAN_BSS_TYPE_UAP)
+			pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_UAP;
 #ifdef WIFI_DIRECT_SUPPORT
-	else if (pmdevice->bss_attr[0].bss_type == MLAN_BSS_TYPE_WIFIDIRECT) {
-		pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_STA;
-		if (pmdevice->bss_attr[0].bss_virtual)
-			pmadapter->priv[0]->bss_virtual = MTRUE;
-	}
+		else if (pmdevice->bss_attr[0].bss_type ==
+			 MLAN_BSS_TYPE_WIFIDIRECT) {
+			pmadapter->priv[0]->bss_role = MLAN_BSS_ROLE_STA;
+			if (pmdevice->bss_attr[0].bss_virtual)
+				pmadapter->priv[0]->bss_virtual = MTRUE;
+		}
 #endif
-	/* Save bss_index and bss_num */
-	pmadapter->priv[0]->bss_index = 0;
-	pmadapter->priv[0]->bss_num = (t_u8)pmdevice->bss_attr[0].bss_num;
+		/* Save bss_index and bss_num */
+		pmadapter->priv[0]->bss_index = 0;
+		pmadapter->priv[0]->bss_num =
+			(t_u8)pmdevice->bss_attr[0].bss_num;
+	}
 
 	/* init function table */
 	for (j = 0; mlan_ops[j]; j++) {
@@ -573,20 +589,20 @@ mlan_status mlan_register(pmlan_device pmdevice, t_void **ppmlan_adapter)
 /**
  *  @brief This function unregisters MOAL from MLAN module.
  *
- *  @param pmlan_adapter   A pointer to a mlan_device structure
+ *  @param padapter  A pointer to a mlan_device structure
  *                         allocated in MOAL
  *
  *  @return                MLAN_STATUS_SUCCESS
  *                             The deregistration succeeded.
  */
-mlan_status mlan_unregister(t_void *pmlan_adapter)
+mlan_status mlan_unregister(t_void *padapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	pmlan_callbacks pcb;
 	t_s32 i = 0;
 
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 
 	ENTER();
 
@@ -620,7 +636,7 @@ mlan_status mlan_unregister(t_void *pmlan_adapter)
 /**
  *  @brief This function downloads the firmware
  *
- *  @param pmlan_adapter   A pointer to a t_void pointer to store
+ *  @param padapter   A pointer to a t_void pointer to store
  *                         mlan_adapter structure pointer
  *  @param pmfw            A pointer to firmware image
  *
@@ -629,13 +645,13 @@ mlan_status mlan_unregister(t_void *pmlan_adapter)
  *                         MLAN_STATUS_FAILURE
  *                             The firmware download failed.
  */
-mlan_status mlan_dnld_fw(t_void *pmlan_adapter, pmlan_fw_image pmfw)
+mlan_status mlan_dnld_fw(t_void *padapter, pmlan_fw_image pmfw)
 {
 	mlan_status ret = MLAN_STATUS_FAILURE;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 
 	ENTER();
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 
 	/* Download helper/firmware */
 	if (pmfw) {
@@ -651,23 +667,91 @@ mlan_status mlan_dnld_fw(t_void *pmlan_adapter, pmlan_fw_image pmfw)
 	return ret;
 }
 
+/**
+ *  @brief This function mask host interrupt from firmware
+ *
+ *  @param padapter   A pointer to a t_void pointer to store
+ *                         mlan_adapter structure pointer
+ *
+ *  @return                MLAN_STATUS_SUCCESS
+ *                             The firmware download succeeded.
+ *                         MLAN_STATUS_FAILURE
+ *                             The firmware download failed.
+ */
+mlan_status mlan_disable_host_int(t_void *padapter)
+{
+	mlan_status ret = MLAN_STATUS_FAILURE;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
+
+	ENTER();
+	MASSERT(padapter);
+
+	/* mask host interrupt from firmware */
+	if (pmadapter->ops.disable_host_int) {
+		ret = pmadapter->ops.disable_host_int(pmadapter);
+		if (ret != MLAN_STATUS_SUCCESS) {
+			PRINTM(MERROR,
+			       "mlan_disable_host_int fail ret = 0x%x\n", ret);
+			LEAVE();
+			return ret;
+		}
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function unmask host interrupt from firmware
+ *
+ *  @param padapter   A pointer to a t_void pointer to store
+ *                         mlan_adapter structure pointer
+ *
+ *  @return                MLAN_STATUS_SUCCESS
+ *                             The firmware download succeeded.
+ *                         MLAN_STATUS_FAILURE
+ *                             The firmware download failed.
+ */
+mlan_status mlan_enable_host_int(t_void *padapter)
+{
+	mlan_status ret = MLAN_STATUS_FAILURE;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
+
+	ENTER();
+	MASSERT(padapter);
+
+	/* unmask host interrupt from firmware */
+	if (pmadapter->ops.enable_host_int) {
+		ret = pmadapter->ops.enable_host_int(pmadapter);
+		if (ret != MLAN_STATUS_SUCCESS) {
+			PRINTM(MERROR, "mlan_enable_host_int fail ret = 0x%x\n",
+			       ret);
+			LEAVE();
+			return ret;
+		}
+	}
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief This function pass init param to MLAN
  *
- *  @param pmlan_adapter  A pointer to a t_void pointer to store
+ *  @param padapter  A pointer to a t_void pointer to store
  *                        mlan_adapter structure pointer
  *  @param pparam         A pointer to mlan_init_param structure
  *
  *  @return               MLAN_STATUS_SUCCESS
  *
  */
-mlan_status mlan_set_init_param(t_void *pmlan_adapter, pmlan_init_param pparam)
+mlan_status mlan_set_init_param(t_void *padapter, pmlan_init_param pparam)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 
 	ENTER();
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 
 	/** Save DPD data in MLAN */
 	if ((pparam->pdpd_data_buf) || (pparam->dpd_data_len > 0)) {
@@ -691,7 +775,7 @@ mlan_status mlan_set_init_param(t_void *pmlan_adapter, pmlan_init_param pparam)
 /**
  *  @brief This function initializes the firmware
  *
- *  @param pmlan_adapter   A pointer to a t_void pointer to store
+ *  @param padapter   A pointer to a t_void pointer to store
  *                         mlan_adapter structure pointer
  *
  *  @return                MLAN_STATUS_SUCCESS
@@ -701,13 +785,13 @@ mlan_status mlan_set_init_param(t_void *pmlan_adapter, pmlan_init_param pparam)
  *                         MLAN_STATUS_FAILURE
  *                             The firmware initialization failed.
  */
-mlan_status mlan_init_fw(t_void *pmlan_adapter)
+mlan_status mlan_init_fw(t_void *padapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 
 	ENTER();
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 
 	pmadapter->hw_status = WlanHardwareStatusGetHwSpec;
 
@@ -722,7 +806,7 @@ mlan_status mlan_init_fw(t_void *pmlan_adapter)
 /**
  *  @brief Shutdown firmware
  *
- *  @param pmlan_adapter    A pointer to mlan_adapter structure
+ *  @param padapter    A pointer to mlan_adapter structure
  *
  *  @return     MLAN_STATUS_SUCCESS
  *                              The firmware shutdown call succeeded.
@@ -731,10 +815,10 @@ mlan_status mlan_init_fw(t_void *pmlan_adapter)
  *              MLAN_STATUS_FAILURE
  *                              The firmware shutdown call failed.
  */
-mlan_status mlan_shutdown_fw(t_void *pmlan_adapter)
+mlan_status mlan_shutdown_fw(t_void *padapter)
 {
 	mlan_status ret = MLAN_STATUS_PENDING;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	pmlan_buffer pmbuf;
 	pmlan_ioctl_req pioctl_buf;
 	pmlan_callbacks pcb;
@@ -742,7 +826,7 @@ mlan_status mlan_shutdown_fw(t_void *pmlan_adapter)
 
 	ENTER();
 
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 	/* MLAN already shutdown */
 	if (pmadapter->hw_status == WlanHardwareStatusNotReady) {
 		LEAVE();
@@ -934,23 +1018,24 @@ void mlan_block_rx_process(mlan_adapter *pmadapter, t_u8 block)
 /**
  *  @brief The receive process
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param rx_pkts              A pointer to save receive pkts number
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status mlan_rx_process(t_void *pmlan_adapter, t_u8 *rx_pkts)
+mlan_status mlan_rx_process(t_void *padapter, t_u8 *rx_pkts)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	pmlan_callbacks pcb;
 	pmlan_buffer pmbuf;
 	t_u8 limit = 0;
 	t_u8 rx_num = 0;
+	t_u32 in_ts_sec, in_ts_usec;
 
 	ENTER();
 
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 	pcb = &pmadapter->callbacks;
 	pcb->moal_spin_lock(pmadapter->pmoal_handle, pmadapter->prx_proc_lock);
 	if (pmadapter->mlan_rx_processing || pmadapter->rx_lock_flag) {
@@ -1002,6 +1087,22 @@ mlan_status mlan_rx_process(t_void *pmlan_adapter, t_u8 *rx_pkts)
 		pmadapter->callbacks.moal_spin_unlock(
 			pmadapter->pmoal_handle,
 			pmadapter->rx_data_queue.plock);
+
+		// rx_trace 6
+		if (pmadapter->tp_state_on) {
+			pmadapter->callbacks.moal_tp_accounting(
+				pmadapter->pmoal_handle, pmbuf,
+				6 /*RX_DROP_P2*/);
+			pcb->moal_get_system_time(pmadapter->pmoal_handle,
+						  &in_ts_sec, &in_ts_usec);
+			pmbuf->extra_ts_sec = in_ts_sec;
+			pmbuf->extra_ts_usec = in_ts_usec;
+		}
+		if (pmadapter->tp_state_drop_point == 6 /*RX_DROP_P2*/) {
+			pmadapter->ops.data_complete(pmadapter, pmbuf, ret);
+			goto rx_process_start;
+		}
+
 		if (pmadapter->delay_task_flag &&
 		    (pmadapter->rx_pkts_queued < LOW_RX_PENDING)) {
 			PRINTM(MEVENT, "Run\n");
@@ -1032,19 +1133,19 @@ mlan_status mlan_rx_process(t_void *pmlan_adapter, t_u8 *rx_pkts)
 /**
  *  @brief The main process
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status mlan_main_process(t_void *pmlan_adapter)
+mlan_status mlan_main_process(t_void *padapter)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	pmlan_callbacks pcb;
 
 	ENTER();
 
-	MASSERT(pmlan_adapter);
+	MASSERT(padapter);
 
 	pcb = &pmadapter->callbacks;
 
@@ -1082,6 +1183,8 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 #if defined(SDIO) || defined(PCIE)
 		if (!IS_USB(pmadapter->card_type)) {
 			if (pmadapter->rx_pkts_queued > HIGH_RX_PENDING) {
+				pcb->moal_tp_accounting_rx_param(
+					pmadapter->pmoal_handle, 2, 0);
 				PRINTM(MEVENT, "Pause\n");
 				pmadapter->delay_task_flag = MTRUE;
 				mlan_queue_rx_work(pmadapter);
@@ -1145,11 +1248,15 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 				break;
 
 			if (pmadapter->data_sent ||
+			    wlan_is_tdls_link_chan_switching(
+				    pmadapter->tdls_status) ||
 			    (wlan_bypass_tx_list_empty(pmadapter) &&
 			     wlan_wmm_lists_empty(pmadapter)) ||
 			    wlan_11h_radar_detected_tx_blocked(pmadapter)) {
 				if (pmadapter->cmd_sent ||
 				    pmadapter->curr_cmd ||
+				    !wlan_is_send_cmd_allowed(
+					    pmadapter->tdls_status) ||
 				    !wlan_is_cmd_pending(pmadapter)) {
 					break;
 				}
@@ -1157,8 +1264,11 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 		}
 
 		/* Check for Cmd Resp */
+		wlan_request_cmd_lock(pmadapter);
 		if (pmadapter->cmd_resp_received) {
 			pmadapter->cmd_resp_received = MFALSE;
+			wlan_release_cmd_lock(pmadapter);
+
 			wlan_process_cmdresp(pmadapter);
 
 			/* call moal back when init_fw is done */
@@ -1172,6 +1282,8 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 					WlanHardwareStatusInitializing;
 				wlan_get_hw_spec_complete(pmadapter);
 			}
+		} else {
+			wlan_release_cmd_lock(pmadapter);
 		}
 
 		/* Check for event */
@@ -1206,7 +1318,8 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 				pmadapter->vdll_ctrl.pending_block_len);
 			pmadapter->vdll_ctrl.pending_block = MNULL;
 		}
-		if (!pmadapter->cmd_sent && !pmadapter->curr_cmd) {
+		if (!pmadapter->cmd_sent && !pmadapter->curr_cmd &&
+		    wlan_is_send_cmd_allowed(pmadapter->tdls_status)) {
 			if (wlan_exec_next_cmd(pmadapter) ==
 			    MLAN_STATUS_FAILURE) {
 				ret = MLAN_STATUS_FAILURE;
@@ -1216,6 +1329,7 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 
 		if (!pmadapter->data_sent &&
 		    !wlan_11h_radar_detected_tx_blocked(pmadapter) &&
+		    !wlan_is_tdls_link_chan_switching(pmadapter->tdls_status) &&
 		    !wlan_bypass_tx_list_empty(pmadapter)) {
 			PRINTM(MINFO, "mlan_send_pkt(): deq(bybass_txq)\n");
 			wlan_process_bypass_tx(pmadapter);
@@ -1229,7 +1343,8 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 		}
 
 		if (!pmadapter->data_sent && !wlan_wmm_lists_empty(pmadapter) &&
-		    !wlan_11h_radar_detected_tx_blocked(pmadapter)) {
+		    !wlan_11h_radar_detected_tx_blocked(pmadapter) &&
+		    !wlan_is_tdls_link_chan_switching(pmadapter->tdls_status)) {
 			wlan_wmm_process_tx(pmadapter);
 			if (pmadapter->hs_activated == MTRUE) {
 				pmadapter->is_hs_configured = MFALSE;
@@ -1272,7 +1387,8 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 
 exit_main_proc:
 	if (pmadapter->hw_status == WlanHardwareStatusClosing)
-		mlan_shutdown_fw(pmadapter);
+		if (MLAN_STATUS_SUCCESS != mlan_shutdown_fw(pmadapter))
+			PRINTM(MERROR, "ERR:mlan_shutdown_fw failed\n");
 	LEAVE();
 	return ret;
 }
@@ -1280,22 +1396,24 @@ mlan_status mlan_main_process(t_void *pmlan_adapter)
 /**
  *  @brief Function to send packet
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param pmbuf		A pointer to mlan_buffer structure
  *
  *  @return			MLAN_STATUS_PENDING
  */
-mlan_status mlan_send_packet(t_void *pmlan_adapter, pmlan_buffer pmbuf)
+mlan_status mlan_send_packet(t_void *padapter, pmlan_buffer pmbuf)
 {
 	mlan_status ret = MLAN_STATUS_PENDING;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	mlan_private *pmpriv;
 	t_u16 eth_type = 0;
+	t_u8 ra[MLAN_MAC_ADDR_LENGTH];
+	tdlsStatus_e tdls_status;
 
 	ENTER();
-	MASSERT(pmlan_adapter && pmbuf);
+	MASSERT(padapter && pmbuf);
 
-	if (!pmlan_adapter || !pmbuf) {
+	if (!padapter || !pmbuf) {
 		return MLAN_STATUS_FAILURE;
 	}
 
@@ -1310,18 +1428,40 @@ mlan_status mlan_send_packet(t_void *pmlan_adapter, pmlan_buffer pmbuf)
 	     ((eth_type == MLAN_ETHER_PKT_TYPE_EAPOL) ||
 	      (eth_type == MLAN_ETHER_PKT_TYPE_ARP) ||
 	      (eth_type == MLAN_ETHER_PKT_TYPE_WAPI))) ||
+	    (eth_type == MLAN_ETHER_PKT_TYPE_TDLS_ACTION) ||
 	    (pmbuf->buf_type == MLAN_BUF_TYPE_RAW_DATA)
 
 	) {
+		if (eth_type == MLAN_ETHER_PKT_TYPE_TDLS_ACTION) {
+			memcpy_ext(pmadapter, ra,
+				   pmbuf->pbuf + pmbuf->data_offset,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+			tdls_status = wlan_get_tdls_link_status(pmpriv, ra);
+			if (MTRUE == wlan_is_tdls_link_setup(tdls_status) ||
+			    !pmpriv->media_connected)
+				pmbuf->flags |= MLAN_BUF_FLAG_TDLS;
+		}
 		if (eth_type == MLAN_ETHER_PKT_TYPE_EAPOL) {
 			PRINTM_NETINTF(MMSG, pmpriv);
 			PRINTM(MMSG, "wlan: Send EAPOL pkt to " MACSTR "\n",
 			       MAC2STR(pmbuf->pbuf + pmbuf->data_offset));
 		}
-		wlan_add_buf_bypass_txqueue(pmadapter, pmbuf);
+		if (pmadapter->tp_state_on)
+			pmadapter->callbacks.moal_tp_accounting(
+				pmadapter->pmoal_handle, pmbuf->pdesc, 2);
+		if (pmadapter->tp_state_drop_point == 2)
+			return 0;
+		else
+			wlan_add_buf_bypass_txqueue(pmadapter, pmbuf);
 	} else {
-		/* Transmit the packet*/
-		wlan_wmm_add_buf_txqueue(pmadapter, pmbuf);
+		if (pmadapter->tp_state_on)
+			pmadapter->callbacks.moal_tp_accounting(
+				pmadapter->pmoal_handle, pmbuf->pdesc, 2);
+		if (pmadapter->tp_state_drop_point == 2)
+			return 0;
+		else
+			/* Transmit the packet*/
+			wlan_wmm_add_buf_txqueue(pmadapter, pmbuf);
 	}
 
 	LEAVE();
@@ -1350,11 +1490,6 @@ mlan_status mlan_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		wlan_cancel_all_pending_cmd(pmadapter, MFALSE);
 		goto exit;
 	}
-	if (pioctl_req->action == MLAN_ACT_CANCEL) {
-		wlan_cancel_pending_ioctl(pmadapter, pioctl_req);
-		ret = MLAN_STATUS_SUCCESS;
-		goto exit;
-	}
 	pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	ret = pmpriv->ops.ioctl(adapter, pioctl_req);
 exit:
@@ -1366,19 +1501,18 @@ mlan_status mlan_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 /**
  *  @brief Packet send completion callback
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param pmbuf		A pointer to mlan_buffer structure
  *  @param port			Data port
  *  @param status		Callback status
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status mlan_write_data_async_complete(t_void *pmlan_adapter,
-					   pmlan_buffer pmbuf, t_u32 port,
-					   mlan_status status)
+mlan_status mlan_write_data_async_complete(t_void *padapter, pmlan_buffer pmbuf,
+					   t_u32 port, mlan_status status)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 
 	ENTER();
 
@@ -1389,6 +1523,9 @@ mlan_status mlan_write_data_async_complete(t_void *pmlan_adapter,
 		wlan_free_mlan_buffer(pmadapter, pmbuf);
 	} else {
 		pmadapter->data_sent = MFALSE;
+		wlan_update_port_status(pmadapter, port, MFALSE);
+		PRINTM(MDATA, "mlan_write_data_async_complete: DATA(%d)\n",
+		       port);
 		ret = wlan_write_data_complete(pmadapter, pmbuf, status);
 	}
 
@@ -1399,28 +1536,28 @@ mlan_status mlan_write_data_async_complete(t_void *pmlan_adapter,
 /**
  *  @brief Packet receive handler
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param pmbuf		A pointer to mlan_buffer structure
  *  @param port			Data port
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE or
  * MLAN_STATUS_PENDING
  */
-mlan_status mlan_recv(t_void *pmlan_adapter, pmlan_buffer pmbuf, t_u32 port)
+mlan_status mlan_recv(t_void *padapter, pmlan_buffer pmbuf, t_u32 port)
 {
 	mlan_status ret = MLAN_STATUS_PENDING;
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	t_u8 *pbuf;
 	t_u32 len, recv_type;
-	t_u32 event_cause;
+	t_u32 event_cause = 0;
 #ifdef DEBUG_LEVEL1
-	t_u32 sec, usec;
+	t_u32 sec = 0, usec = 0;
 #endif
 	t_u32 max_rx_data_size = MLAN_RX_DATA_BUF_SIZE;
 
 	ENTER();
 
-	MASSERT(pmlan_adapter && pmbuf);
+	MASSERT(padapter && pmbuf);
 
 	if (pmadapter->hs_activated == MTRUE)
 		wlan_process_hs_config(pmadapter);
@@ -1463,11 +1600,13 @@ mlan_status mlan_recv(t_void *pmlan_adapter, pmlan_buffer pmbuf, t_u32 port)
 				}
 				PRINTM(MINFO, "mlan_recv: no curr_cmd\n");
 			} else {
+				wlan_request_cmd_lock(pmadapter);
 				pmadapter->upld_len = len;
 				pmbuf->data_offset += MLAN_TYPE_LEN;
 				pmbuf->data_len -= MLAN_TYPE_LEN;
 				pmadapter->curr_cmd->respbuf = pmbuf;
 				pmadapter->cmd_resp_received = MTRUE;
+				wlan_release_cmd_lock(pmadapter);
 			}
 			break;
 		case MLAN_USB_TYPE_EVENT:
@@ -1551,16 +1690,16 @@ mlan_status mlan_recv(t_void *pmlan_adapter, pmlan_buffer pmbuf, t_u32 port)
 /**
  *  @brief Packet receive completion callback handler
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param pmbuf		A pointer to mlan_buffer structure
  *  @param status		Callback status
  *
  *  @return			MLAN_STATUS_SUCCESS
  */
-mlan_status mlan_recv_packet_complete(t_void *pmlan_adapter, pmlan_buffer pmbuf,
+mlan_status mlan_recv_packet_complete(t_void *padapter, pmlan_buffer pmbuf,
 				      mlan_status status)
 {
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 
 	ENTER();
 	wlan_recv_packet_complete(pmadapter, pmbuf, status);
@@ -1571,15 +1710,15 @@ mlan_status mlan_recv_packet_complete(t_void *pmlan_adapter, pmlan_buffer pmbuf,
 /**
  *  @brief select wmm queue
  *
- *  @param pmlan_adapter	A pointer to mlan_adapter structure
+ *  @param padapter	A pointer to mlan_adapter structure
  *  @param bss_num		BSS number
  *  @param tid			TID
  *
  *  @return			wmm queue priority (0 - 3)
  */
-t_u8 mlan_select_wmm_queue(t_void *pmlan_adapter, t_u8 bss_num, t_u8 tid)
+t_u8 mlan_select_wmm_queue(t_void *padapter, t_u8 bss_num, t_u8 tid)
 {
-	mlan_adapter *pmadapter = (mlan_adapter *)pmlan_adapter;
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
 	pmlan_private pmpriv = pmadapter->priv[bss_num];
 	t_u8 ret;
 	ENTER();
@@ -1588,6 +1727,54 @@ t_u8 mlan_select_wmm_queue(t_void *pmlan_adapter, t_u8 bss_num, t_u8 tid)
 	return ret;
 }
 
+/**
+ *  @brief this function handle the amsdu packet after deaggreate.
+ *
+ *  @param padapter	A pointer to mlan_adapter structure
+ *  @param pmbuf    A pointer to the deaggreated buf
+ *  @param drop	    A pointer to return the drop flag.
+ *
+ *  @return			N/A
+ */
+void mlan_process_deaggr_pkt(t_void *padapter, pmlan_buffer pmbuf, t_u8 *drop)
+{
+	mlan_adapter *pmadapter = (mlan_adapter *)padapter;
+	mlan_private *pmpriv;
+	t_u16 eth_type = 0;
+
+	*drop = MFALSE;
+	pmpriv = pmadapter->priv[pmbuf->bss_index];
+	eth_type =
+		mlan_ntohs(*(t_u16 *)&pmbuf->pbuf[pmbuf->data_offset +
+						  MLAN_ETHER_PKT_TYPE_OFFSET]);
+	switch (eth_type) {
+	case MLAN_ETHER_PKT_TYPE_EAPOL:
+		PRINTM(MEVENT, "Recevie AMSDU EAPOL frame\n");
+		if (pmpriv->sec_info.ewpa_enabled) {
+			*drop = MTRUE;
+			if (MLAN_STATUS_FAILURE ==
+			    wlan_prepare_cmd(pmpriv,
+					     HostCmd_CMD_802_11_EAPOL_PKT, 0, 0,
+					     MNULL, pmbuf)) {
+				PRINTM(MERROR, "Preparing the CMD failed\n");
+			}
+			wlan_recv_event(pmpriv,
+					MLAN_EVENT_ID_DRV_DEFER_HANDLING,
+					MNULL);
+		}
+		break;
+	case MLAN_ETHER_PKT_TYPE_TDLS_ACTION:
+		PRINTM(MEVENT, "Recevie AMSDU TDLS action frame\n");
+		wlan_process_tdls_action_frame(pmpriv,
+					       pmbuf->pbuf + pmbuf->data_offset,
+					       pmbuf->data_len);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
 #if defined(SDIO) || defined(PCIE)
 /**
  *  @brief This function gets interrupt status.
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c
old mode 100644
new mode 100755
index 314e8fb7f..62b6a8555
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmd.c
@@ -5,7 +5,7 @@
  *  it is ready.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -291,6 +291,16 @@ static mlan_status wlan_cmd_802_11_snmp_mib(pmlan_private pmpriv,
 			cmd->size += sizeof(t_u8);
 		}
 		break;
+	case ChanTrackParam_i:
+		psnmp_mib->oid = wlan_cpu_to_le16((t_u16)ChanTrackParam_i);
+		if (cmd_action == HostCmd_ACT_GEN_SET) {
+			psnmp_mib->query_type =
+				wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+			psnmp_mib->buf_size = wlan_cpu_to_le16(sizeof(t_u8));
+			psnmp_mib->value[0] = *(t_u8 *)pdata_buf;
+			cmd->size += sizeof(t_u8);
+		}
+		break;
 	default:
 		break;
 	}
@@ -399,6 +409,13 @@ static mlan_status wlan_cmd_mfg_tx_frame(pmlan_private pmpriv,
 		mcmd->tx_bf = wlan_cpu_to_le32(cfg->tx_bf);
 		mcmd->gf_mode = wlan_cpu_to_le32(cfg->gf_mode);
 		mcmd->stbc = wlan_cpu_to_le32(cfg->stbc);
+		mcmd->NumPkt = wlan_cpu_to_le32(cfg->NumPkt);
+		mcmd->MaxPE = wlan_cpu_to_le32(cfg->MaxPE);
+		mcmd->BeamChange = wlan_cpu_to_le32(cfg->BeamChange);
+		mcmd->Dcm = wlan_cpu_to_le32(cfg->Dcm);
+		mcmd->Doppler = wlan_cpu_to_le32(cfg->Doppler);
+		mcmd->MidP = wlan_cpu_to_le32(cfg->MidP);
+		mcmd->QNum = wlan_cpu_to_le32(cfg->QNum);
 		memcpy_ext(pmpriv->adapter, mcmd->bssid, cfg->bssid,
 			   MLAN_MAC_ADDR_LENGTH, sizeof(mcmd->bssid));
 	}
@@ -407,6 +424,91 @@ static mlan_status wlan_cmd_mfg_tx_frame(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of MFG config trigger frame.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param action       The action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_cmd_mfg_config_trigger_frame(pmlan_private pmpriv,
+						     HostCmd_DS_COMMAND *cmd,
+						     t_u16 action,
+						     t_void *pdata_buf)
+{
+	mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *mcmd =
+		(mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *)&cmd->params
+			.mfg_tx_trigger_config;
+	mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *cfg =
+		(mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *)pdata_buf;
+
+	ENTER();
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_MFG_COMMAND);
+	cmd->size = wlan_cpu_to_le16(
+		sizeof(mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t) + S_DS_GEN);
+	mcmd->mfg_cmd = wlan_cpu_to_le32(cfg->mfg_cmd);
+	mcmd->action = wlan_cpu_to_le16(action);
+	if (action == HostCmd_ACT_GEN_SET) {
+		mcmd->enable_tx = wlan_cpu_to_le32(cfg->enable_tx);
+		mcmd->standalone_hetb = wlan_cpu_to_le32(cfg->standalone_hetb);
+		mcmd->frmCtl.type = wlan_cpu_to_le16(cfg->frmCtl.type);
+		mcmd->frmCtl.sub_type = wlan_cpu_to_le16(cfg->frmCtl.sub_type);
+		mcmd->duration = wlan_cpu_to_le16(cfg->duration);
+
+		mcmd->trig_common_field =
+			wlan_cpu_to_le64(cfg->trig_common_field);
+
+		memcpy_ext(pmpriv->adapter, &mcmd->trig_user_info_field,
+			   &cfg->trig_user_info_field,
+			   sizeof(cfg->trig_user_info_field),
+			   sizeof(mcmd->trig_user_info_field));
+
+		mcmd->basic_trig_user_info =
+			wlan_cpu_to_le16(cfg->basic_trig_user_info);
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of MFG HE TB Tx.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param action       The action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+
+mlan_status wlan_cmd_mfg_he_tb_tx(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				  t_u16 action, t_void *pdata_buf)
+{
+	struct mfg_Cmd_HE_TBTx_t *mcmd =
+		(struct mfg_Cmd_HE_TBTx_t *)&cmd->params.mfg_he_power;
+	struct mfg_Cmd_HE_TBTx_t *cfg = (struct mfg_Cmd_HE_TBTx_t *)pdata_buf;
+	ENTER();
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_MFG_COMMAND);
+	cmd->size =
+		wlan_cpu_to_le16(sizeof(struct mfg_Cmd_HE_TBTx_t) + S_DS_GEN);
+
+	mcmd->mfg_cmd = wlan_cpu_to_le32(cfg->mfg_cmd);
+	mcmd->action = wlan_cpu_to_le16(action);
+	if (action == HostCmd_ACT_GEN_SET) {
+		mcmd->enable = wlan_cpu_to_le16(cfg->enable);
+		mcmd->qnum = wlan_cpu_to_le16(cfg->qnum);
+		mcmd->aid = wlan_cpu_to_le16(cfg->aid);
+		mcmd->axq_mu_timer = wlan_cpu_to_le16(cfg->axq_mu_timer);
+		mcmd->tx_power = wlan_cpu_to_le16(cfg->tx_power);
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares command of MFG cmd.
  *
@@ -439,6 +541,13 @@ mlan_status wlan_cmd_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	case MFG_CMD_TX_FRAME:
 		ret = wlan_cmd_mfg_tx_frame(pmpriv, cmd, action, pdata_buf);
 		goto cmd_mfg_done;
+	case MFG_CMD_CONFIG_MAC_HE_TB_TX:
+		ret = wlan_cmd_mfg_he_tb_tx(pmpriv, cmd, action, pdata_buf);
+		goto cmd_mfg_done;
+	case MFG_CMD_CONFIG_TRIGGER_FRAME:
+		ret = wlan_cmd_mfg_config_trigger_frame(pmpriv, cmd, action,
+							pdata_buf);
+		goto cmd_mfg_done;
 	case MFG_CMD_SET_TEST_MODE:
 	case MFG_CMD_UNSET_TEST_MODE:
 	case MFG_CMD_TX_ANT:
@@ -447,6 +556,7 @@ mlan_status wlan_cmd_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	case MFG_CMD_CLR_RX_ERR:
 	case MFG_CMD_RF_BAND_AG:
 	case MFG_CMD_RF_CHANNELBW:
+	case MFG_CMD_RADIO_MODE_CFG:
 	case MFG_CMD_RFPWR:
 		break;
 	default:
@@ -639,7 +749,22 @@ static mlan_status wlan_cmd_802_11_hs_cfg(pmlan_private pmpriv,
 	}
 	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH);
 
-	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_802_11_HS_CFG_ENH);
+	if (!hs_activate && (pdata_buf->conditions != HOST_SLEEP_CFG_CANCEL) &&
+	    ((pmadapter->arp_filter_size > 0) &&
+	     (pmadapter->arp_filter_size <= ARP_FILTER_MAX_BUF_SIZE))) {
+		PRINTM(MINFO, "Attach %d bytes ArpFilter to HSCfg cmd\n",
+		       pmadapter->arp_filter_size);
+		memcpy_ext(pmpriv->adapter,
+			   ((t_u8 *)phs_cfg) +
+				   sizeof(HostCmd_DS_802_11_HS_CFG_ENH),
+			   pmadapter->arp_filter, pmadapter->arp_filter_size,
+			   pmadapter->arp_filter_size);
+		cmd->size = pmadapter->arp_filter_size +
+			    sizeof(HostCmd_DS_802_11_HS_CFG_ENH) + S_DS_GEN;
+		tlv = (t_u8 *)phs_cfg + sizeof(HostCmd_DS_802_11_HS_CFG_ENH) +
+		      pmadapter->arp_filter_size;
+	} else
+		cmd->size = S_DS_GEN + sizeof(HostCmd_DS_802_11_HS_CFG_ENH);
 
 	if (hs_activate) {
 		cmd->size = wlan_cpu_to_le16(cmd->size);
@@ -1156,7 +1281,7 @@ static mlan_status wlan_cmd_802_11_key_material(pmlan_private pmpriv,
 					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
 					     sizeof(gcmp_param) +
 					     sizeof(pkey_material->action));
-
+		PRINTM(MCMND, "Set GCMP Key\n");
 		goto done;
 	}
 	if (pkey->key_flags & KEY_FLAG_CCMP_256) {
@@ -1180,7 +1305,7 @@ static mlan_status wlan_cmd_802_11_key_material(pmlan_private pmpriv,
 					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
 					     sizeof(ccmp_256_param) +
 					     sizeof(pkey_material->action));
-
+		PRINTM(MCMND, "Set CCMP256 Key\n");
 		goto done;
 	}
 	if (pkey->key_len == WPA_AES_KEY_LEN &&
@@ -1218,7 +1343,12 @@ static mlan_status wlan_cmd_802_11_key_material(pmlan_private pmpriv,
 			~(wlan_cpu_to_le16(KEY_INFO_MCAST_KEY));
 		pkey_material->key_param_set.key_info |=
 			wlan_cpu_to_le16(KEY_INFO_AES_MCAST_IGTK);
-		pkey_material->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC;
+		if (pkey->key_flags & KEY_FLAG_GMAC_128)
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_BIP_GMAC_128;
+		else
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_AES_CMAC;
 		pkey_material->key_param_set.key_params.cmac_aes.key_len =
 			wlan_cpu_to_le16(pkey->key_len);
 		memcpy_ext(pmpriv->adapter,
@@ -1230,7 +1360,39 @@ static mlan_status wlan_cmd_802_11_key_material(pmlan_private pmpriv,
 					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
 					     sizeof(cmac_aes_param) +
 					     sizeof(pkey_material->action));
-		PRINTM(MCMND, "Set CMAC AES Key\n");
+		if (pkey->key_flags & KEY_FLAG_GMAC_128)
+			PRINTM(MCMND, "Set AES 128 GMAC Key\n");
+		else
+			PRINTM(MCMND, "Set CMAC AES Key\n");
+		goto done;
+	}
+	if (pkey->key_len == WPA_IGTK_256_KEY_LEN &&
+	    (pkey->key_flags & KEY_FLAG_AES_MCAST_IGTK)) {
+		if (pkey->key_flags &
+		    (KEY_FLAG_RX_SEQ_VALID | KEY_FLAG_TX_SEQ_VALID))
+			memcpy_ext(pmpriv->adapter,
+				   pkey_material->key_param_set.key_params
+					   .gmac_aes.ipn,
+				   pkey->pn, SEQ_MAX_SIZE, IGTK_PN_SIZE);
+		pkey_material->key_param_set.key_info &=
+			~(wlan_cpu_to_le16(KEY_INFO_MCAST_KEY));
+		pkey_material->key_param_set.key_info |=
+			wlan_cpu_to_le16(KEY_INFO_AES_MCAST_IGTK);
+		pkey_material->key_param_set.key_type =
+			KEY_TYPE_ID_BIP_GMAC_256;
+		pkey_material->key_param_set.key_params.gmac_aes.key_len =
+			wlan_cpu_to_le16(pkey->key_len);
+		memcpy_ext(pmpriv->adapter,
+			   pkey_material->key_param_set.key_params.gmac_aes.key,
+			   pkey->key_material, pkey->key_len,
+			   WPA_IGTK_256_KEY_LEN);
+		pkey_material->key_param_set.length = wlan_cpu_to_le16(
+			KEY_PARAMS_FIXED_LEN + sizeof(gmac_aes_256_param));
+		cmd->size = wlan_cpu_to_le16(sizeof(MrvlIEtypesHeader_t) +
+					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+					     sizeof(gmac_aes_256_param) +
+					     sizeof(pkey_material->action));
+		PRINTM(MCMND, "Set AES 256 GMAC Key\n");
 		goto done;
 	}
 	if (pkey->key_len == WPA_TKIP_KEY_LEN) {
@@ -1521,6 +1683,11 @@ static mlan_status wlan_cmd_mgmt_ie_list(pmlan_private pmpriv,
 	pmgmt_ie_list->ds_mgmt_ie.len = wlan_cpu_to_le16(cust_ie->len);
 
 	req_len = cust_ie->len;
+	if (req_len > sizeof(cust_ie->ie_data_list)) {
+		PRINTM(MERROR, "Invalid cust_ie->len=%d\n", req_len);
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 	travel_len = 0;
 	/* conversion for index, mask, len */
 	if (req_len == sizeof(t_u16))
@@ -1552,6 +1719,566 @@ static mlan_status wlan_cmd_mgmt_ie_list(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of TDLS configuration.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   The action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_cmd_tdls_config(pmlan_private pmpriv,
+					HostCmd_DS_COMMAND *cmd,
+					t_u16 cmd_action, t_void *pdata_buf)
+{
+	t_u16 travel_len = 0;
+	mlan_ds_misc_tdls_config *tdls_config = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	HostCmd_DS_TDLS_CONFIG *ptdls_config_data =
+		&(cmd->params.tdls_config_data);
+	t_u8 zero_mac[] = {0, 0, 0, 0, 0, 0};
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_TDLS_CONFIG);
+	cmd->size = sizeof(HostCmd_DS_TDLS_CONFIG) + S_DS_GEN;
+	cmd->result = 0;
+
+	tdls_config = (mlan_ds_misc_tdls_config *)pdata_buf;
+	ptdls_config_data->tdls_info.tdls_action =
+		wlan_cpu_to_le16(tdls_config->tdls_action);
+
+	tdls_all_cfg = (tdls_all_config *)tdls_config->tdls_data;
+
+	switch (tdls_config->tdls_action) {
+	case WLAN_TDLS_CONFIG:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_config);
+		tdls_all_cfg->u.tdls_config.enable =
+			wlan_cpu_to_le16(tdls_all_cfg->u.tdls_config.enable);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_setup, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+
+	case WLAN_TDLS_SET_INFO:
+		travel_len = tdls_all_cfg->u.tdls_set.tlv_length;
+		if ((travel_len + sizeof(t_u16)) > MAX_TDLS_DATA_LEN) {
+			PRINTM(MERROR, "TDLS configuration overflow\n");
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   (t_u8 *)&tdls_all_cfg->u.tdls_set.cap_info,
+			   sizeof(t_u16), sizeof(t_u16));
+		memcpy_ext(pmpriv->adapter,
+			   (t_u8 *)ptdls_config_data->tdls_info.tdls_data +
+				   sizeof(t_u16),
+			   &tdls_all_cfg->u.tdls_set.tlv_buffer, travel_len,
+			   MAX_TDLS_DATA_LEN - sizeof(t_u16));
+		travel_len += sizeof(t_u16);
+		break;
+	case WLAN_TDLS_DISCOVERY_REQ:
+		travel_len = MLAN_MAC_ADDR_LENGTH;
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   tdls_all_cfg->u.tdls_discovery.peer_mac_addr,
+			   travel_len, MAX_TDLS_DATA_LEN);
+		break;
+
+	case WLAN_TDLS_SETUP_REQ:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_setup);
+		tdls_all_cfg->u.tdls_setup.setup_timeout = wlan_cpu_to_le32(
+			tdls_all_cfg->u.tdls_setup.setup_timeout);
+		tdls_all_cfg->u.tdls_setup.key_lifetime = wlan_cpu_to_le32(
+			tdls_all_cfg->u.tdls_setup.key_lifetime);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_setup, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+
+	case WLAN_TDLS_TEAR_DOWN_REQ:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_tear_down);
+		tdls_all_cfg->u.tdls_tear_down.reason_code = wlan_cpu_to_le16(
+			tdls_all_cfg->u.tdls_tear_down.reason_code);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_tear_down, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+	case WLAN_TDLS_STOP_CHAN_SWITCH:
+		travel_len = MLAN_MAC_ADDR_LENGTH;
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   tdls_all_cfg->u.tdls_stop_chan_switch.peer_mac_addr,
+			   travel_len, MAX_TDLS_DATA_LEN);
+		break;
+	case WLAN_TDLS_INIT_CHAN_SWITCH:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_chan_switch);
+		tdls_all_cfg->u.tdls_chan_switch.switch_time = wlan_cpu_to_le16(
+			tdls_all_cfg->u.tdls_chan_switch.switch_time);
+		tdls_all_cfg->u.tdls_chan_switch.switch_timeout =
+			wlan_cpu_to_le16(
+				tdls_all_cfg->u.tdls_chan_switch.switch_timeout);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_chan_switch, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+	case WLAN_TDLS_CS_PARAMS:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_cs_params);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_cs_params, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+	case WLAN_TDLS_CS_DISABLE:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_disable_cs);
+		tdls_all_cfg->u.tdls_disable_cs.data =
+			wlan_cpu_to_le16(tdls_all_cfg->u.tdls_disable_cs.data);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_disable_cs, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+	case WLAN_TDLS_POWER_MODE:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_power_mode);
+		tdls_all_cfg->u.tdls_power_mode.power_mode = wlan_cpu_to_le16(
+			tdls_all_cfg->u.tdls_power_mode.power_mode);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_power_mode, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+
+	case WLAN_TDLS_LINK_STATUS:
+		travel_len = 0;
+		if (memcmp(pmpriv->adapter,
+			   tdls_all_cfg->u.tdls_link_status_req.peer_mac_addr,
+			   zero_mac, sizeof(zero_mac))) {
+			travel_len =
+				sizeof(tdls_all_cfg->u.tdls_link_status_req);
+			memcpy_ext(pmpriv->adapter,
+				   ptdls_config_data->tdls_info.tdls_data,
+				   tdls_all_cfg->u.tdls_link_status_req
+					   .peer_mac_addr,
+				   travel_len, MAX_TDLS_DATA_LEN);
+		}
+		break;
+
+	case WLAN_TDLS_DEBUG_ALLOW_WEAK_SECURITY:
+	case WLAN_TDLS_DEBUG_SETUP_SAME_LINK:
+	case WLAN_TDLS_DEBUG_FAIL_SETUP_CONFIRM:
+	case WLAN_TDLS_DEBUG_WRONG_BSS:
+	case WLAN_TDLS_DEBUG_SETUP_PROHIBITED:
+	case WLAN_TDLS_DEBUG_HIGHER_LOWER_MAC:
+	case WLAN_TDLS_DEBUG_IGNORE_KEY_EXPIRY:
+	case WLAN_TDLS_DEBUG_STOP_RX:
+	case WLAN_TDLS_DEBUG_CS_RET_IM:
+		travel_len = sizeof(tdls_all_cfg->u.tdls_debug_data);
+		tdls_all_cfg->u.tdls_debug_data.debug_data = wlan_cpu_to_le16(
+			tdls_all_cfg->u.tdls_debug_data.debug_data);
+		memcpy_ext(pmpriv->adapter,
+			   ptdls_config_data->tdls_info.tdls_data,
+			   &tdls_all_cfg->u.tdls_debug_data, travel_len,
+			   MAX_TDLS_DATA_LEN);
+		break;
+
+	default:
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	cmd->size += travel_len;
+	cmd->size -= MAX_TDLS_DATA_LEN;
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command of TDLS create/config/delete
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   The action: GET or SET
+ *  @param pdata_buf	A pointer to data buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_cmd_tdls_oper(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
+				      t_void *pdata_buf)
+{
+	t_u16 travel_len = 0;
+	mlan_ds_misc_tdls_oper *tdls_oper = MNULL;
+	HostCmd_DS_TDLS_OPER *ptdls_oper = &(cmd->params.tdls_oper_data);
+	sta_node *sta_ptr;
+	t_u8 *pos;
+	MrvlIEtypes_RatesParamSet_t *Rate_tlv = MNULL;
+	MrvlIETypes_HTCap_t *HTcap_tlv = MNULL;
+	MrvlIETypes_HTInfo_t *HTInfo_tlv = MNULL;
+	MrvlIETypes_2040BSSCo_t *BSSCo = MNULL;
+	MrvlIETypes_ExtCap_t *ExCap = MNULL;
+	MrvlIEtypes_RsnParamSet_t *Rsn_ie = MNULL;
+	MrvlIETypes_qosinfo_t *qos_info = MNULL;
+	MrvlIETypes_LinkIDElement_t *LinkID = MNULL;
+	BSSDescriptor_t *pbss_desc = &pmpriv->curr_bss_params.bss_descriptor;
+	MrvlIETypes_VHTCap_t *VHTcap_tlv = MNULL;
+	MrvlIETypes_VHTOprat_t *VHTOper_tlv = MNULL;
+	MrvlIETypes_AID_t *AidInfo = MNULL;
+	MrvlIEtypes_Extension_t *hecap_tlv = MNULL;
+	MrvlIEtypes_He_Op_t *heop_tlv = MNULL;
+	MrvlIEtypes_TDLS_Idle_Timeout_t *TdlsIdleTimeout = MNULL;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_TDLS_OPERATION);
+	cmd->size = sizeof(HostCmd_DS_TDLS_OPER) + S_DS_GEN;
+	cmd->result = 0;
+
+	tdls_oper = (mlan_ds_misc_tdls_oper *)pdata_buf;
+	ptdls_oper->reason = 0;
+	memcpy_ext(pmpriv->adapter, ptdls_oper->peer_mac, tdls_oper->peer_mac,
+		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	sta_ptr = wlan_get_station_entry(pmpriv, tdls_oper->peer_mac);
+	pos = (t_u8 *)ptdls_oper + sizeof(HostCmd_DS_TDLS_OPER);
+	switch (tdls_oper->tdls_action) {
+	case WLAN_TDLS_CREATE_LINK:
+		if (sta_ptr)
+			sta_ptr->status = TDLS_SETUP_INPROGRESS;
+		ptdls_oper->tdls_action = wlan_cpu_to_le16(TDLS_CREATE);
+		break;
+	case WLAN_TDLS_CONFIG_LINK:
+		if (sta_ptr) {
+			ptdls_oper->tdls_action = wlan_cpu_to_le16(TDLS_CONFIG);
+			/*capability*/
+			*(t_u16 *)pos = wlan_cpu_to_le16(sta_ptr->capability);
+			travel_len += sizeof(sta_ptr->capability);
+
+			/*supported rate*/
+			Rate_tlv = (MrvlIEtypes_RatesParamSet_t *)(pos +
+								   travel_len);
+			Rate_tlv->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_RATES);
+			Rate_tlv->header.len =
+				wlan_cpu_to_le16(sta_ptr->rate_len);
+			memcpy_ext(pmpriv->adapter,
+				   pos + travel_len +
+					   sizeof(MrvlIEtypesHeader_t),
+				   sta_ptr->support_rate, sta_ptr->rate_len,
+				   sta_ptr->rate_len);
+			travel_len +=
+				sizeof(MrvlIEtypesHeader_t) + sta_ptr->rate_len;
+
+			/*Extended capability */
+			if (sta_ptr->ExtCap.ieee_hdr.element_id ==
+			    EXT_CAPABILITY) {
+				ExCap = (MrvlIETypes_ExtCap_t *)(pos +
+								 travel_len);
+				ExCap->header.type =
+					wlan_cpu_to_le16(TLV_TYPE_EXTCAP);
+				ExCap->header.len = wlan_cpu_to_le16(
+					sta_ptr->ExtCap.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter, &ExCap->ext_cap,
+					   &sta_ptr->ExtCap.ext_cap,
+					   sta_ptr->ExtCap.ieee_hdr.len,
+					   sta_ptr->ExtCap.ieee_hdr.len);
+				travel_len += sta_ptr->ExtCap.ieee_hdr.len +
+					      sizeof(MrvlIEtypesHeader_t);
+			}
+			if (ExCap) {
+				if (pmpriv->host_tdls_uapsd_support &&
+				    ISSUPP_EXTCAP_TDLS_UAPSD(ExCap->ext_cap)) {
+					/* qos_info */
+					qos_info =
+						(MrvlIETypes_qosinfo_t
+							 *)(pos + travel_len);
+					qos_info->header.type =
+						wlan_cpu_to_le16(QOS_INFO);
+					qos_info->header.len =
+						wlan_cpu_to_le16(sizeof(t_u8));
+					qos_info->qos_info = sta_ptr->qos_info;
+					travel_len +=
+						sizeof(MrvlIETypes_qosinfo_t);
+				} else {
+					RESET_EXTCAP_TDLS_UAPSD(ExCap->ext_cap);
+				}
+
+				if (!(pmpriv->host_tdls_cs_support &&
+				      ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+					      ExCap->ext_cap)))
+					RESET_EXTCAP_TDLS_CHAN_SWITCH(
+						ExCap->ext_cap);
+			}
+
+			/*RSN ie*/
+			if (sta_ptr->rsn_ie.ieee_hdr.element_id == RSN_IE) {
+				Rsn_ie = (MrvlIEtypes_RsnParamSet_t
+						  *)(pos + travel_len);
+				Rsn_ie->header.type = wlan_cpu_to_le16(
+					sta_ptr->rsn_ie.ieee_hdr.element_id);
+				Rsn_ie->header.len = wlan_cpu_to_le16(
+					sta_ptr->rsn_ie.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter, Rsn_ie->rsn_ie,
+					   sta_ptr->rsn_ie.data,
+					   sta_ptr->rsn_ie.ieee_hdr.len,
+					   sta_ptr->rsn_ie.ieee_hdr.len);
+				travel_len += sta_ptr->rsn_ie.ieee_hdr.len +
+					      sizeof(MrvlIEtypesHeader_t);
+			}
+			/*Link ID*/
+			if (sta_ptr->link_ie.element_id == LINK_ID) {
+				LinkID = (MrvlIETypes_LinkIDElement_t
+						  *)(pos + travel_len);
+				LinkID->header.type = wlan_cpu_to_le16(LINK_ID);
+				LinkID->header.len =
+					wlan_cpu_to_le16(sta_ptr->link_ie.len);
+				memcpy_ext(pmpriv->adapter, &LinkID->bssid,
+					   &sta_ptr->link_ie.bssid,
+					   sta_ptr->link_ie.len,
+					   sizeof(LinkID->bssid));
+				travel_len += sta_ptr->link_ie.len +
+					      sizeof(MrvlIEtypesHeader_t);
+			}
+			/*HT capability*/
+			if (sta_ptr->HTcap.ieee_hdr.element_id ==
+			    HT_CAPABILITY) {
+				HTcap_tlv = (MrvlIETypes_HTCap_t *)(pos +
+								    travel_len);
+				HTcap_tlv->header.type =
+					wlan_cpu_to_le16(TLV_TYPE_HT_CAP);
+				HTcap_tlv->header.len = wlan_cpu_to_le16(
+					sta_ptr->HTcap.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter, &HTcap_tlv->ht_cap,
+					   &sta_ptr->HTcap.ht_cap,
+					   sta_ptr->HTcap.ieee_hdr.len,
+					   sizeof(HTcap_tlv->ht_cap));
+				travel_len += sta_ptr->HTcap.ieee_hdr.len +
+					      sizeof(MrvlIEtypesHeader_t);
+			}
+			if (HTcap_tlv) {
+				if (pmpriv->host_tdls_cs_support &&
+				    (pmpriv->adapter->fw_bands & BAND_A))
+					wlan_fill_ht_cap_tlv(pmpriv, HTcap_tlv,
+							     BAND_A, MFALSE);
+				else
+					wlan_fill_ht_cap_tlv(
+						pmpriv, HTcap_tlv,
+						pbss_desc->bss_band, MFALSE);
+				DBG_HEXDUMP(MCMD_D, "FW htcap",
+					    (t_u8 *)HTcap_tlv,
+					    sizeof(MrvlIETypes_HTCap_t));
+			}
+
+			/*HT info*/
+			if (sta_ptr->HTInfo.ieee_hdr.element_id ==
+			    HT_OPERATION) {
+				HTInfo_tlv =
+					(MrvlIETypes_HTInfo_t *)(pos +
+								 travel_len);
+				HTInfo_tlv->header.type =
+					wlan_cpu_to_le16(TLV_TYPE_HT_INFO);
+				HTInfo_tlv->header.len = wlan_cpu_to_le16(
+					sta_ptr->HTInfo.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter,
+					   &HTInfo_tlv->ht_info,
+					   &sta_ptr->HTInfo.ht_info,
+					   sta_ptr->HTInfo.ieee_hdr.len,
+					   sizeof(HTInfo_tlv->ht_info));
+				travel_len += sta_ptr->HTInfo.ieee_hdr.len +
+					      sizeof(MrvlIEtypesHeader_t);
+				DBG_HEXDUMP(MCMD_D, "HT Info",
+					    (t_u8 *)HTInfo_tlv,
+					    sizeof(MrvlIETypes_HTInfo_t));
+			}
+			/*20/40 BSS co-exist*/
+			if (sta_ptr->BSSCO_20_40.ieee_hdr.element_id ==
+			    BSSCO_2040) {
+				BSSCo = (MrvlIETypes_2040BSSCo_t *)(pos +
+								    travel_len);
+				BSSCo->header.type = wlan_cpu_to_le16(
+					TLV_TYPE_2040BSS_COEXISTENCE);
+				BSSCo->header.len = wlan_cpu_to_le16(
+					sta_ptr->BSSCO_20_40.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter, &BSSCo->bss_co_2040,
+					   &sta_ptr->BSSCO_20_40.bss_co_2040,
+					   sta_ptr->BSSCO_20_40.ieee_hdr.len,
+					   sizeof(BSSCo->bss_co_2040));
+				travel_len +=
+					sta_ptr->BSSCO_20_40.ieee_hdr.len +
+					sizeof(MrvlIEtypesHeader_t);
+			}
+			/* Check if we need enable the 11AC */
+			if (sta_ptr && sta_ptr->vht_oprat.ieee_hdr.element_id ==
+					       VHT_OPERATION) {
+				/** AID */
+				if (sta_ptr->aid_info.ieee_hdr.element_id ==
+				    AID_INFO) {
+					AidInfo = (MrvlIETypes_AID_t
+							   *)(pos + travel_len);
+					AidInfo->header.type =
+						wlan_cpu_to_le16(AID_INFO);
+					AidInfo->header.len = wlan_cpu_to_le16(
+						sta_ptr->aid_info.ieee_hdr.len);
+					AidInfo->AID = wlan_cpu_to_le16(
+						sta_ptr->aid_info.AID);
+					travel_len += sizeof(MrvlIETypes_AID_t);
+				}
+				/* Vht capability */
+				if (sta_ptr->vht_cap.ieee_hdr.element_id ==
+				    VHT_CAPABILITY) {
+					VHTcap_tlv =
+						(MrvlIETypes_VHTCap_t
+							 *)(pos + travel_len);
+					VHTcap_tlv->header.type =
+						wlan_cpu_to_le16(
+							VHT_CAPABILITY);
+					VHTcap_tlv->header
+						.len = wlan_cpu_to_le16(
+						sta_ptr->vht_cap.ieee_hdr.len);
+					memcpy_ext(
+						pmpriv->adapter,
+						&VHTcap_tlv->vht_cap,
+						&sta_ptr->vht_cap.vht_cap,
+						sta_ptr->vht_cap.ieee_hdr.len,
+						sizeof(VHTcap_tlv->vht_cap));
+					travel_len +=
+						sta_ptr->vht_cap.ieee_hdr.len +
+						sizeof(MrvlIEtypesHeader_t);
+				}
+				if (VHTcap_tlv) {
+					wlan_fill_vht_cap_tlv(
+						pmpriv, VHTcap_tlv,
+						pbss_desc->bss_band, MTRUE,
+						MTRUE);
+					DBG_HEXDUMP(
+						MCMD_D,
+						"TDLS Config Link: VHT Capability",
+						(t_u8 *)VHTcap_tlv,
+						sizeof(MrvlIETypes_VHTCap_t));
+				}
+
+				/*Vht operation*/
+				VHTOper_tlv =
+					(MrvlIETypes_VHTOprat_t *)(pos +
+								   travel_len);
+				VHTOper_tlv->header.type =
+					wlan_cpu_to_le16(VHT_OPERATION);
+				VHTOper_tlv->header.len = wlan_cpu_to_le16(
+					sta_ptr->vht_oprat.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter,
+					   &VHTOper_tlv->chan_width,
+					   &sta_ptr->vht_oprat.chan_width,
+					   sta_ptr->vht_oprat.ieee_hdr.len,
+					   (sizeof(MrvlIETypes_VHTOprat_t) -
+					    sizeof(MrvlIEtypesHeader_t)));
+				VHTOper_tlv->basic_MCS_map = wlan_cpu_to_le16(
+					VHTOper_tlv->basic_MCS_map);
+				travel_len += sta_ptr->vht_oprat.ieee_hdr.len +
+					      sizeof(MrvlIEtypesHeader_t);
+				DBG_HEXDUMP(MCMD_D,
+					    "TDLS Config Link: VHT operation",
+					    (t_u8 *)VHTOper_tlv,
+					    sizeof(MrvlIETypes_VHTOprat_t));
+			}
+			/* Check if we need enable the 11AX */
+			if (sta_ptr &&
+			    (sta_ptr->he_op.ieee_hdr.element_id == EXTENSION) &&
+			    (sta_ptr->he_op.ext_id == HE_OPERATION)) {
+				/* HE Capability */
+				hecap_tlv =
+					(MrvlIEtypes_Extension_t *)(pos +
+								    travel_len);
+				/* fill the peer HE CAP IE */
+				memcpy_ext(pmpriv->adapter, &hecap_tlv->ext_id,
+					   &sta_ptr->tdls_he_cap.ext_id,
+					   sta_ptr->tdls_he_cap.ieee_hdr.len,
+					   sizeof(MrvlIEtypes_He_cap_t) -
+						   sizeof(MrvlIEtypesHeader_t));
+				hecap_tlv->type =
+					wlan_cpu_to_le16(TLV_TYPE_EXTENSION_ID);
+				hecap_tlv->len = MIN(
+					sta_ptr->tdls_he_cap.ieee_hdr.len,
+					sizeof(MrvlIEtypes_He_cap_t) -
+						sizeof(MrvlIEtypesHeader_t));
+				hecap_tlv->len =
+					wlan_cpu_to_le16(hecap_tlv->len);
+#if 0
+			    wlan_fill_he_cap_tlv(pmpriv,
+			            pmpriv->config_bands,
+			            hecap_tlv, MFALSE);
+#endif
+
+				travel_len += wlan_le16_to_cpu(hecap_tlv->len) +
+					      sizeof(MrvlIEtypesHeader_t);
+
+				DBG_HEXDUMP(
+					MCMD_D,
+					"TDLS Config Link: HE Capability",
+					(t_u8 *)hecap_tlv,
+					wlan_le16_to_cpu(hecap_tlv->len) +
+						sizeof(MrvlIEtypesHeader_t));
+
+				/* HE Operation */
+				heop_tlv = (MrvlIEtypes_He_Op_t *)(pos +
+								   travel_len);
+				heop_tlv->header.type =
+					wlan_cpu_to_le16(EXTENSION);
+				heop_tlv->header.len = wlan_cpu_to_le16(
+					sta_ptr->he_op.ieee_hdr.len);
+				memcpy_ext(pmpriv->adapter, &heop_tlv->ext_id,
+					   &sta_ptr->he_op.ext_id,
+					   sta_ptr->he_op.ieee_hdr.len,
+					   sizeof(MrvlIEtypes_He_Op_t) -
+						   sizeof(MrvlIEtypesHeader_t));
+				heop_tlv->he_op_param1 = wlan_cpu_to_le16(
+					heop_tlv->he_op_param1);
+				heop_tlv->basic_he_mcs_nss = wlan_cpu_to_le16(
+					heop_tlv->basic_he_mcs_nss);
+				travel_len +=
+					wlan_le16_to_cpu(heop_tlv->header.len) +
+					sizeof(MrvlIEtypesHeader_t);
+				DBG_HEXDUMP(
+					MCMD_D,
+					"TDLS Config Link: HE Operation",
+					(t_u8 *)heop_tlv,
+					wlan_le16_to_cpu(heop_tlv->header.len) +
+						sizeof(MrvlIEtypesHeader_t));
+			}
+
+			TdlsIdleTimeout =
+				(MrvlIEtypes_TDLS_Idle_Timeout_t *)(pos +
+								    travel_len);
+			TdlsIdleTimeout->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_TDLS_IDLE_TIMEOUT);
+			TdlsIdleTimeout->header.len =
+				sizeof(TdlsIdleTimeout->value);
+			TdlsIdleTimeout->header.len =
+				wlan_cpu_to_le16(TdlsIdleTimeout->header.len);
+			TdlsIdleTimeout->value =
+				wlan_cpu_to_le16(pmpriv->tdls_idle_time);
+			travel_len += sizeof(MrvlIEtypes_TDLS_Idle_Timeout_t);
+		}
+		break;
+	case WLAN_TDLS_DISABLE_LINK:
+		ptdls_oper->tdls_action = wlan_cpu_to_le16(TDLS_DELETE);
+		break;
+	default:
+		break;
+	}
+	cmd->size += travel_len;
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares system clock cfg command
  *
@@ -1815,6 +2542,46 @@ static mlan_status wlan_cmd_otp_user_data(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of fw auto re-connect.
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_cmd_fw_auto_reconnect(pmlan_private pmpriv,
+					      HostCmd_DS_COMMAND *cmd,
+					      t_u16 cmd_action,
+					      t_void *pdata_buf)
+{
+	HostCmd_DS_FW_AUTO_RECONNECT *fw_auto_reconnect =
+		&cmd->params.fw_auto_reconnect_cmd;
+	mlan_ds_fw_reconnect *fw_auto_reconn =
+		(mlan_ds_fw_reconnect *)pdata_buf;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_FW_AUTO_RECONNECT);
+	cmd->size = wlan_cpu_to_le16((sizeof(HostCmd_DS_FW_AUTO_RECONNECT)) +
+				     S_DS_GEN);
+
+	fw_auto_reconnect->action = wlan_cpu_to_le16(cmd_action);
+
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		fw_auto_reconnect->reconnect_counter =
+			fw_auto_reconn->fw_reconn_counter;
+		fw_auto_reconnect->reconnect_interval =
+			fw_auto_reconn->fw_reconn_interval;
+		fw_auto_reconnect->flags =
+			wlan_cpu_to_le16(fw_auto_reconn->fw_reconn_flags);
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 #ifdef USB
 /**
  *  @brief This function prepares command of packet aggragation
@@ -1928,6 +2695,89 @@ static mlan_status wlan_cmd_inactivity_timeout(HostCmd_DS_COMMAND *cmd,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares network monitor command
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   the action: GET or SET
+ *  @param pdata_buf    A pointer to data buffer
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_cmd_net_monitor(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				 t_u16 cmd_action, t_void *pdata_buf)
+{
+	mlan_ds_misc_net_monitor *net_mon;
+	HostCmd_DS_802_11_NET_MONITOR *cmd_net_mon = &cmd->params.net_mon;
+	ChanBandParamSet_t *pchan_band = MNULL;
+	t_u8 sec_chan_offset = 0;
+	t_u32 bw_offset = 0;
+
+	ENTER();
+
+	net_mon = (mlan_ds_misc_net_monitor *)pdata_buf;
+
+	cmd->size = wlan_cpu_to_le16(S_DS_GEN +
+				     sizeof(HostCmd_DS_802_11_NET_MONITOR));
+	cmd->command = wlan_cpu_to_le16(cmd->command);
+	cmd_net_mon->action = wlan_cpu_to_le16(cmd_action);
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		if (net_mon->enable_net_mon) {
+			cmd_net_mon->enable_net_mon =
+				wlan_cpu_to_le16((t_u16)NET_MON_MODE3);
+			cmd_net_mon->filter_flag =
+				wlan_cpu_to_le16((t_u16)net_mon->filter_flag);
+		}
+		if (net_mon->enable_net_mon && net_mon->channel) {
+			pchan_band =
+				&cmd_net_mon->monitor_chan.chan_band_param[0];
+			cmd_net_mon->monitor_chan.header.type =
+				wlan_cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);
+			cmd_net_mon->monitor_chan.header.len =
+				wlan_cpu_to_le16(sizeof(ChanBandParamSet_t));
+			pchan_band->chan_number = (t_u8)net_mon->channel;
+			pchan_band->bandcfg.chanBand =
+				wlan_band_to_radio_type((t_u16)net_mon->band);
+
+			if (net_mon->band & BAND_GN ||
+			    net_mon->band & BAND_AN ||
+			    net_mon->band & BAND_GAC ||
+			    net_mon->band & BAND_AAC) {
+				bw_offset = net_mon->chan_bandwidth;
+				if (bw_offset == CHANNEL_BW_40MHZ_ABOVE) {
+					pchan_band->bandcfg.chan2Offset =
+						SEC_CHAN_ABOVE;
+					pchan_band->bandcfg.chanWidth =
+						CHAN_BW_40MHZ;
+				} else if (bw_offset ==
+					   CHANNEL_BW_40MHZ_BELOW) {
+					pchan_band->bandcfg.chan2Offset =
+						SEC_CHAN_BELOW;
+					pchan_band->bandcfg.chanWidth =
+						CHAN_BW_40MHZ;
+				} else if (bw_offset == CHANNEL_BW_80MHZ) {
+					sec_chan_offset =
+						wlan_get_second_channel_offset(
+							pmpriv,
+							net_mon->channel);
+					if (sec_chan_offset == SEC_CHAN_ABOVE)
+						pchan_band->bandcfg.chan2Offset =
+							SEC_CHAN_ABOVE;
+					else if (sec_chan_offset ==
+						 SEC_CHAN_BELOW)
+						pchan_band->bandcfg.chan2Offset =
+							SEC_CHAN_BELOW;
+					pchan_band->bandcfg.chanWidth =
+						CHAN_BW_80MHZ;
+				}
+			}
+		}
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepares Low Power Mode
  *
@@ -2004,9 +2854,9 @@ static mlan_status wlan_cmd_dfs_repeater_cfg(pmlan_private pmpriv,
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_cmd_coalesce_config(pmlan_private pmpriv,
-				     HostCmd_DS_COMMAND *cmd, t_u16 cmd_action,
-				     t_void *pdata_buf)
+static mlan_status wlan_cmd_coalesce_config(pmlan_private pmpriv,
+					    HostCmd_DS_COMMAND *cmd,
+					    t_u16 cmd_action, t_void *pdata_buf)
 {
 	HostCmd_DS_COALESCE_CONFIG *coalesce_config =
 		&cmd->params.coalesce_config;
@@ -2017,7 +2867,9 @@ mlan_status wlan_cmd_coalesce_config(pmlan_private pmpriv,
 
 	ENTER();
 
-	cmd->size = sizeof(HostCmd_DS_COALESCE_CONFIG) + S_DS_GEN;
+	cmd->size = (sizeof(HostCmd_DS_COALESCE_CONFIG) -
+		     sizeof(struct coalesce_receive_filt_rule)) +
+		    S_DS_GEN;
 	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_COALESCE_CFG);
 	coalesce_config->action = wlan_cpu_to_le16(cmd_action);
 	coalesce_config->num_of_rules = wlan_cpu_to_le16(cfg->num_of_rules);
@@ -2080,25 +2932,6 @@ mlan_status wlan_cmd_coalesce_config(pmlan_private pmpriv,
  *		Global Functions
  ********************************************************/
 
-static mlan_status wlan_cmd_get_sensor_temp(pmlan_private pmpriv,
-					    HostCmd_DS_COMMAND *cmd,
-					    t_u16 cmd_action)
-{
-	ENTER();
-
-	if (cmd_action != HostCmd_ACT_GEN_GET) {
-		PRINTM(MERROR, "wlan_cmd_get_sensor_temp: support GET only.\n");
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
-
-	cmd->command = wlan_cpu_to_le16(HostCmd_DS_GET_SENSOR_TEMP);
-	cmd->size = wlan_cpu_to_le16(S_DS_GEN + 4);
-
-	LEAVE();
-	return MLAN_STATUS_SUCCESS;
-}
-
 /**
  *  @brief This function prepares command of arb cfg
  *
@@ -2141,6 +2974,47 @@ mlan_status wlan_cmd_arb_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function set ipv6 ra offload configuration.
+ *
+ *  @param pmpriv         A pointer to mlan_private structure
+ *  @param pcmd         A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action   Command action
+ *  @param pdata_buf    A pointer to information buffer
+ *  @return             N/A
+ */
+
+mlan_status wlan_cmd_ipv6_ra_offload(mlan_private *pmpriv,
+				     HostCmd_DS_COMMAND *pcmd, t_u16 cmd_action,
+				     void *pdata_buf)
+{
+	HostCmd_DS_IPV6_RA_OFFLOAD *ipv6_ra_cfg = &pcmd->params.ipv6_ra_offload;
+	mlan_ds_misc_ipv6_ra_offload *ipv6_ra_offload =
+		(mlan_ds_misc_ipv6_ra_offload *)pdata_buf;
+	MrvlIEtypesHeader_t *ie = &ipv6_ra_cfg->ipv6_addr_param.Header;
+
+	ENTER();
+
+	pcmd->command = wlan_cpu_to_le16(HostCmd_CMD_IPV6_RA_OFFLOAD_CFG);
+	ipv6_ra_cfg->action = wlan_cpu_to_le16(cmd_action);
+	if (cmd_action == HostCmd_ACT_GEN_SET) {
+		ipv6_ra_cfg->enable = ipv6_ra_offload->enable;
+		ie->type = wlan_cpu_to_le16(TLV_TYPE_IPV6_RA_OFFLOAD);
+		ie->len = wlan_cpu_to_le16(16);
+		memcpy_ext(pmpriv->adapter,
+			   ipv6_ra_cfg->ipv6_addr_param.ipv6_addr,
+			   ipv6_ra_offload->ipv6_addr, 16,
+			   sizeof(ipv6_ra_cfg->ipv6_addr_param.ipv6_addr));
+		pcmd->size = wlan_cpu_to_le16(
+			S_DS_GEN + sizeof(HostCmd_DS_IPV6_RA_OFFLOAD));
+	} else if (cmd_action == HostCmd_ACT_GEN_GET)
+		pcmd->size = wlan_cpu_to_le16(S_DS_GEN +
+					      sizeof(ipv6_ra_cfg->action));
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function sends get sta band channel command to firmware.
  *
@@ -2190,6 +3064,379 @@ static mlan_status wlan_cmd_sta_config(pmlan_private pmpriv,
 	return ret;
 }
 
+/**
+ *  @brief This function prepare the config tlvs of roam offload.
+ *
+ *  @param priv         A pointer to mlan_private structure
+ *  @param tlv_no       TLV type
+ *  @param value        Pointer to mlan_ds_misc_roam_offload structure
+ *  @param pointer      Value of trigger_condition
+ *  @param size         Pointer to the buffer of HostCmd_DS_ROAM_OFFLOAD
+ *  @return             N/A
+ */
+static t_u16 mlan_prepare_roam_offload_tlv(pmlan_private pmpriv, t_u32 type,
+					   mlan_ds_misc_roam_offload *roam,
+					   t_u8 trigger_condition, t_u8 *pos)
+{
+	MrvlIEtypes_fw_roam_enable_t *enable_tlv = MNULL;
+	MrvlIEtypes_fw_roam_trigger_condition_t *trigger_condition_tlv = MNULL;
+	MrvlIEtypes_Bssid_t *bssid_tlv = MNULL;
+	MrvlIEtypes_SsIdParamSet_t *ssid_tlv = MNULL;
+	MrvlIEtypes_fw_roam_retry_count_t *retry_count_tlv = MNULL;
+	MrvlIEtypes_para_rssi_t *rssi_para_tlv = MNULL;
+	MrvlIEtypes_fw_roam_bgscan_setting_t *bgscan_set_tlv = MNULL;
+	MrvlIEtypes_roam_blacklist_t *blacklist_tlv = MNULL;
+	MrvlIEtypes_ees_param_set_t *ees_param_tlv = MNULL;
+	MrvlIEtypes_band_rssi_t *band_rssi_tlv = MNULL;
+	MrvlIEtypes_beacon_miss_threshold_t *bcn_miss_threshold_tlv = MNULL;
+	MrvlIEtypes_pre_beacon_miss_threshold_t *pre_bcn_miss_threshold_tlv =
+		MNULL;
+	MrvlIEtypes_RepeatCount_t *tlv_repeat = MNULL;
+	t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0}, *begin;
+	int i = 0;
+
+	ENTER();
+
+	begin = pos;
+	if (type & FW_ROAM_ENABLE) {
+		enable_tlv = (MrvlIEtypes_fw_roam_enable_t *)pos;
+		enable_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_ROAM);
+		enable_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlIEtypes_fw_roam_enable_t) -
+					 sizeof(MrvlIEtypesHeader_t));
+		if (roam->enable <= ROAM_OFFLOAD_WITHOUT_APLIST)
+			enable_tlv->roam_enable = roam->enable;
+		else
+			enable_tlv->roam_enable = ROAM_OFFLOAD_WITHOUT_APLIST;
+		pos += sizeof(MrvlIEtypes_fw_roam_enable_t);
+	}
+	if (type & FW_ROAM_TRIGGER_COND) {
+		trigger_condition_tlv =
+			(MrvlIEtypes_fw_roam_trigger_condition_t *)pos;
+		trigger_condition_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ROM_TRIGGER);
+		trigger_condition_tlv->header.len = wlan_cpu_to_le16(
+			sizeof(trigger_condition_tlv->trigger_condition));
+		trigger_condition_tlv->trigger_condition =
+			wlan_cpu_to_le16(trigger_condition);
+		pos += sizeof(trigger_condition_tlv->header) +
+		       sizeof(trigger_condition_tlv->trigger_condition);
+	}
+	if (type & FW_ROAM_BSSID) {
+		bssid_tlv = (MrvlIEtypes_Bssid_t *)pos;
+		bssid_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_BSSID);
+		bssid_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(bssid_tlv->bssid));
+		if (memcmp(pmpriv->adapter, roam->bssid_reconnect, zero_mac,
+			   sizeof(zero_mac)) != 0)
+			memcpy_ext(pmpriv->adapter, bssid_tlv->bssid,
+				   roam->bssid_reconnect,
+				   sizeof(bssid_tlv->bssid),
+				   sizeof(bssid_tlv->bssid));
+		else {
+			if (roam->config_mode == ROAM_OFFLOAD_SUSPEND_CFG)
+				memcpy_ext(pmpriv->adapter, bssid_tlv->bssid,
+					   pmpriv->curr_bss_params
+						   .bss_descriptor.mac_address,
+					   sizeof(bssid_tlv->bssid),
+					   sizeof(bssid_tlv->bssid));
+			else if (roam->config_mode == ROAM_OFFLOAD_RESUME_CFG)
+				memcpy_ext(pmpriv->adapter, bssid_tlv->bssid,
+					   zero_mac, sizeof(bssid_tlv->bssid),
+					   sizeof(bssid_tlv->bssid));
+		}
+		pos += sizeof(bssid_tlv->header) + sizeof(bssid_tlv->bssid);
+	}
+	if (type & FW_ROAM_SSID) {
+		for (i = 0; i < roam->ssid_list.ssid_num; i++) {
+			ssid_tlv = (MrvlIEtypes_SsIdParamSet_t *)pos;
+			ssid_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+			memcpy_ext(pmpriv->adapter, ssid_tlv->ssid,
+				   roam->ssid_list.ssids[i].ssid,
+				   roam->ssid_list.ssids[i].ssid_len,
+				   roam->ssid_list.ssids[i].ssid_len);
+			pos += sizeof(ssid_tlv->header) +
+			       wlan_strlen(ssid_tlv->ssid);
+			ssid_tlv->header.len =
+				wlan_cpu_to_le16(wlan_strlen(ssid_tlv->ssid));
+		}
+		if (!roam->ssid_list.ssid_num) {
+			ssid_tlv = (MrvlIEtypes_SsIdParamSet_t *)pos;
+			ssid_tlv->header.type = wlan_cpu_to_le16(TLV_TYPE_SSID);
+			memcpy_ext(
+				pmpriv->adapter, ssid_tlv->ssid,
+				pmpriv->curr_bss_params.bss_descriptor.ssid.ssid,
+				pmpriv->curr_bss_params.bss_descriptor.ssid
+					.ssid_len,
+				pmpriv->curr_bss_params.bss_descriptor.ssid
+					.ssid_len);
+			ssid_tlv->header.len =
+				wlan_cpu_to_le16(wlan_strlen(ssid_tlv->ssid));
+			pos += sizeof(ssid_tlv->header) + ssid_tlv->header.len;
+		}
+	}
+	if (type & FW_ROAM_RETRY_COUNT) {
+		retry_count_tlv = (MrvlIEtypes_fw_roam_retry_count_t *)pos;
+		retry_count_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ROM_RETRY_COUNT);
+		retry_count_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(retry_count_tlv->retry_count));
+		if (roam->retry_count)
+			retry_count_tlv->retry_count =
+				wlan_cpu_to_le16(roam->retry_count);
+		else
+			retry_count_tlv->retry_count =
+				wlan_cpu_to_le16(RETRY_UNLIMITED_TIME);
+		pos += sizeof(retry_count_tlv->header) +
+		       sizeof(retry_count_tlv->retry_count);
+	}
+	if (type & FW_ROAM_RSSI_PARA) {
+		rssi_para_tlv = (MrvlIEtypes_para_rssi_t *)pos;
+		rssi_para_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ROM_PARA_RSSI);
+		rssi_para_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(rssi_para_tlv->max_rssi) +
+					 sizeof(rssi_para_tlv->min_rssi) +
+					 sizeof(rssi_para_tlv->step_rssi));
+		rssi_para_tlv->max_rssi = roam->para_rssi.max_rssi;
+		rssi_para_tlv->min_rssi = roam->para_rssi.min_rssi;
+		rssi_para_tlv->step_rssi = roam->para_rssi.step_rssi;
+		pos += sizeof(rssi_para_tlv->header) +
+		       sizeof(rssi_para_tlv->max_rssi) +
+		       sizeof(rssi_para_tlv->min_rssi) +
+		       sizeof(rssi_para_tlv->step_rssi);
+	}
+	if (type & FW_ROAM_BAND_RSSI) {
+		band_rssi_tlv = (MrvlIEtypes_band_rssi_t *)pos;
+		band_rssi_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_BAND_RSSI);
+		band_rssi_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlIEtypes_band_rssi_t) -
+					 sizeof(MrvlIEtypesHeader_t));
+		band_rssi_tlv->band_rssi.band_preferred =
+			roam->band_rssi.band_preferred;
+		band_rssi_tlv->band_rssi.rssi_hysteresis =
+			roam->band_rssi.rssi_hysteresis;
+		pos += sizeof(MrvlIEtypes_band_rssi_t);
+	}
+
+	if (type & FW_ROAM_BGSCAN_PARAM) {
+		bgscan_set_tlv = (MrvlIEtypes_fw_roam_bgscan_setting_t *)pos;
+		bgscan_set_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ROM_BGSCAN);
+		bgscan_set_tlv->header.len = wlan_cpu_to_le16(
+			sizeof(MrvlIEtypes_fw_roam_bgscan_setting_t) -
+			sizeof(MrvlIEtypesHeader_t));
+		bgscan_set_tlv->bss_type = roam->bgscan_cfg.bss_type;
+		bgscan_set_tlv->channels_perscan =
+			roam->bgscan_cfg.channels_per_scan;
+		bgscan_set_tlv->scan_interval =
+			wlan_cpu_to_le32(roam->bgscan_cfg.scan_interval);
+		bgscan_set_tlv->report_condition =
+			wlan_cpu_to_le32(roam->bgscan_cfg.bg_rpt_condition);
+		pos += sizeof(MrvlIEtypes_fw_roam_bgscan_setting_t);
+	}
+
+	if (type & FW_ROAM_EES_PARAM) {
+		ees_param_tlv = (MrvlIEtypes_ees_param_set_t *)pos;
+		ees_param_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_ENERGYEFFICIENTSCAN);
+		ees_param_tlv->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlIEtypes_ees_param_set_t) -
+					 sizeof(MrvlIEtypesHeader_t));
+		ees_param_tlv->ees_cfg.ees_mode =
+			wlan_cpu_to_le16(roam->ees_cfg.ees_mode);
+		ees_param_tlv->ees_cfg.ees_rpt_condition =
+			wlan_cpu_to_le16(roam->ees_cfg.ees_rpt_condition);
+		ees_param_tlv->ees_cfg.high_scan_period =
+			wlan_cpu_to_le16(roam->ees_cfg.high_scan_period);
+		ees_param_tlv->ees_cfg.high_scan_count =
+			wlan_cpu_to_le16(roam->ees_cfg.high_scan_count);
+		ees_param_tlv->ees_cfg.mid_scan_period =
+			wlan_cpu_to_le16(roam->ees_cfg.mid_scan_period);
+		ees_param_tlv->ees_cfg.mid_scan_count =
+			wlan_cpu_to_le16(roam->ees_cfg.mid_scan_count);
+		ees_param_tlv->ees_cfg.low_scan_period =
+			wlan_cpu_to_le16(roam->ees_cfg.low_scan_period);
+		ees_param_tlv->ees_cfg.low_scan_count =
+			wlan_cpu_to_le16(roam->ees_cfg.low_scan_count);
+		pos += sizeof(MrvlIEtypes_ees_param_set_t);
+	}
+
+	if (type & FW_ROAM_BCN_MISS_THRESHOLD) {
+		bcn_miss_threshold_tlv =
+			(MrvlIEtypes_beacon_miss_threshold_t *)pos;
+		bcn_miss_threshold_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_BCNMISS);
+		bcn_miss_threshold_tlv->header.len = wlan_cpu_to_le16(
+			sizeof(MrvlIEtypes_beacon_miss_threshold_t) -
+			sizeof(MrvlIEtypesHeader_t));
+		bcn_miss_threshold_tlv->bcn_miss_threshold =
+			roam->bcn_miss_threshold;
+		pos += sizeof(MrvlIEtypes_beacon_miss_threshold_t);
+	}
+
+	if (type & FW_ROAM_PRE_BCN_MISS_THRESHOLD) {
+		pre_bcn_miss_threshold_tlv =
+			(MrvlIEtypes_pre_beacon_miss_threshold_t *)pos;
+		pre_bcn_miss_threshold_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_PRE_BCNMISS);
+		pre_bcn_miss_threshold_tlv->header.len = wlan_cpu_to_le16(
+			sizeof(MrvlIEtypes_pre_beacon_miss_threshold_t) -
+			sizeof(MrvlIEtypesHeader_t));
+		pre_bcn_miss_threshold_tlv->pre_bcn_miss_threshold =
+			roam->pre_bcn_miss_threshold;
+		pos += sizeof(MrvlIEtypes_pre_beacon_miss_threshold_t);
+	}
+
+	if (type & FW_ROAM_BLACKLIST) {
+		blacklist_tlv = (MrvlIEtypes_roam_blacklist_t *)pos;
+		blacklist_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_BLACKLIST_BSSID);
+		blacklist_tlv->header.len =
+			roam->black_list.ap_num * MLAN_MAC_ADDR_LENGTH +
+			sizeof(roam->black_list.ap_num);
+		memcpy_ext(pmpriv->adapter, (t_u8 *)&blacklist_tlv->blacklist,
+			   (t_u8 *)&roam->black_list, blacklist_tlv->header.len,
+			   sizeof(blacklist_tlv->blacklist));
+		pos += sizeof(MrvlIEtypesHeader_t) + blacklist_tlv->header.len;
+		blacklist_tlv->header.len =
+			wlan_cpu_to_le16(blacklist_tlv->header.len);
+	}
+
+	if (type & FW_ROAM_REPEAT_CNT) {
+		tlv_repeat = (MrvlIEtypes_RepeatCount_t *)pos;
+		tlv_repeat->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_REPEAT_COUNT);
+		tlv_repeat->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlIEtypes_RepeatCount_t) -
+					 sizeof(MrvlIEtypesHeader_t));
+		tlv_repeat->repeat_count = wlan_cpu_to_le16(roam->repeat_count);
+		pos += sizeof(MrvlIEtypes_RepeatCount_t);
+	}
+	LEAVE();
+	return ((t_u16)(pos - begin));
+}
+/**
+ *  @brief This function sends enable/disable roam offload command to firmware.
+ *
+ *  @param pmpriv         A pointer to mlan_private structure
+ *  @param pcmd          Hostcmd ID
+ *  @param cmd_action   Command action
+ *  @return             N/A
+ */
+static mlan_status wlan_cmd_roam_offload(pmlan_private pmpriv,
+					 HostCmd_DS_COMMAND *cmd,
+					 t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_ROAM_OFFLOAD *roam_cmd = &cmd->params.roam_offload;
+	MrvlIEtypes_roam_aplist_t *aplist = MNULL;
+	t_u8 *pos = (t_u8 *)roam_cmd + sizeof(roam_cmd->action);
+	mlan_ds_misc_roam_offload *roam = MNULL;
+	t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0};
+	t_u32 type = 0;
+	t_u8 trigger_condition = 0;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_ROAM_OFFLOAD);
+	cmd->size = S_DS_GEN + sizeof(HostCmd_DS_ROAM_OFFLOAD);
+	roam_cmd->action = wlan_cpu_to_le16(cmd_action);
+
+	roam = (mlan_ds_misc_roam_offload *)pdata_buf;
+
+	if (roam->config_mode) {
+		switch (roam->config_mode) {
+		case ROAM_OFFLOAD_ENABLE:
+			type |= FW_ROAM_ENABLE;
+			if (roam->enable && roam->enable != AUTO_RECONNECT) {
+				type |= FW_ROAM_TRIGGER_COND;
+				trigger_condition |= RSSI_LOW_TRIGGER |
+						     PRE_BEACON_LOST_TRIGGER;
+			}
+			break;
+		case ROAM_OFFLOAD_SUSPEND_CFG:
+			type |= FW_ROAM_TRIGGER_COND | FW_ROAM_RETRY_COUNT;
+			if (roam->enable == AUTO_RECONNECT) {
+				type |= FW_ROAM_BSSID | FW_ROAM_SSID;
+				trigger_condition = LINK_LOST_TRIGGER |
+						    DEAUTH_WITH_EXT_AP_TRIGGER;
+			} else
+				trigger_condition = LINK_LOST_TRIGGER |
+						    DEAUTH_WITH_EXT_AP_TRIGGER |
+						    RSSI_LOW_TRIGGER |
+						    PRE_BEACON_LOST_TRIGGER;
+
+			if (roam->enable == ROAM_OFFLOAD_WITH_BSSID)
+				type |= FW_ROAM_BSSID;
+			if (roam->enable == ROAM_OFFLOAD_WITH_SSID)
+				type |= FW_ROAM_SSID;
+			break;
+		case ROAM_OFFLOAD_RESUME_CFG:
+			type |= FW_ROAM_TRIGGER_COND;
+			if (roam->enable == AUTO_RECONNECT)
+				trigger_condition = NO_TRIGGER;
+			else
+				trigger_condition = RSSI_LOW_TRIGGER |
+						    PRE_BEACON_LOST_TRIGGER;
+			if (roam->enable == ROAM_OFFLOAD_WITH_BSSID ||
+			    roam->enable == AUTO_RECONNECT)
+				type |= FW_ROAM_BSSID;
+			break;
+		case ROAM_OFFLOAD_PARAM_CFG:
+			if (roam->enable && roam->enable != AUTO_RECONNECT) {
+				if (roam->retry_count != 0)
+					type |= FW_ROAM_RETRY_COUNT;
+				if (roam->ssid_list.ssid_num)
+					type |= FW_ROAM_SSID;
+				if (roam->para_rssi.set_flag)
+					type |= FW_ROAM_RSSI_PARA;
+				if (memcmp(pmpriv->adapter,
+					   roam->bssid_reconnect, zero_mac,
+					   sizeof(zero_mac)) != 0)
+					type |= FW_ROAM_BSSID;
+				if (roam->band_rssi_flag)
+					type |= FW_ROAM_BAND_RSSI;
+				if (roam->bgscan_set_flag)
+					type |= FW_ROAM_BGSCAN_PARAM;
+				if (roam->ees_param_set_flag)
+					type |= FW_ROAM_EES_PARAM;
+				if (roam->bcn_miss_threshold)
+					type |= FW_ROAM_BCN_MISS_THRESHOLD;
+				if (roam->pre_bcn_miss_threshold)
+					type |= FW_ROAM_PRE_BCN_MISS_THRESHOLD;
+				if (roam->black_list.ap_num)
+					type |= FW_ROAM_BLACKLIST;
+				if (roam->trigger_condition != 0xff) {
+					type |= FW_ROAM_TRIGGER_COND;
+					trigger_condition =
+						roam->trigger_condition;
+				}
+				if (roam->repeat_count)
+					type |= FW_ROAM_REPEAT_CNT;
+			}
+			break;
+		}
+		cmd->size += mlan_prepare_roam_offload_tlv(
+			pmpriv, type, roam, trigger_condition, pos);
+	}
+	if (roam->aplist.ap_num) {
+		aplist = (MrvlIEtypes_roam_aplist_t *)pos;
+		aplist->header.type = wlan_cpu_to_le16(TLV_TYPE_APLIST);
+		aplist->header.len = roam->aplist.ap_num * MLAN_MAC_ADDR_LENGTH;
+		memcpy_ext(pmpriv->adapter, aplist->ap_mac, roam->aplist.ap_mac,
+			   roam->aplist.ap_num * MLAN_MAC_ADDR_LENGTH,
+			   roam->aplist.ap_num * MLAN_MAC_ADDR_LENGTH);
+		pos += sizeof(aplist->header) + aplist->header.len;
+		cmd->size += sizeof(aplist->header) + aplist->header.len;
+		aplist->header.len = wlan_cpu_to_le16(aplist->header.len);
+	}
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function sends set and get auto tx command to firmware.
  *
@@ -2211,6 +3458,8 @@ static mlan_status wlan_cmd_auto_tx(pmlan_private pmpriv,
 	MrvlIEtypes_Keep_Alive_Ctrl_t *ctrl_tlv = MNULL;
 	MrvlIEtypes_Keep_Alive_Pkt_t *pkt_tlv = MNULL;
 	mlan_ds_misc_keep_alive *misc_keep_alive = MNULL;
+	MrvlIEtypes_Cloud_Keep_Alive_Rx_t *keep_alive_Rx_tlv = MNULL;
+	mlan_ds_misc_keep_alive_rx *misc_keep_alive_rx = MNULL;
 	t_u8 eth_ip[] = {0x08, 0x00};
 
 	ENTER();
@@ -2277,6 +3526,11 @@ static mlan_status wlan_cmd_auto_tx(pmlan_private pmpriv,
 							   .h803_len,
 						   eth_ip, sizeof(t_u16),
 						   sizeof(t_u16));
+				memcpy_ext(pmpriv->adapter,
+					   (t_u8 *)&pkt_tlv->ip_packet,
+					   misc_keep_alive->packet,
+					   misc_keep_alive->pkt_len,
+					   MKEEP_ALIVE_IP_PKT_MAX);
 				pkt_tlv->header.len = wlan_cpu_to_le16(
 					sizeof(Eth803Hdr_t) +
 					misc_keep_alive->pkt_len);
@@ -2300,6 +3554,46 @@ static mlan_status wlan_cmd_auto_tx(pmlan_private pmpriv,
 		}
 		keep_alive_tlv->header.len = wlan_cpu_to_le16(len);
 
+		cmd->size = cmd->size + len + sizeof(MrvlIEtypesHeader_t);
+		cmd->size = wlan_cpu_to_le16(cmd->size);
+		break;
+	case OID_CLOUD_KEEP_ALIVE_ACK:
+		misc_keep_alive_rx = (mlan_ds_misc_keep_alive_rx *)pdata_buf;
+		keep_alive_Rx_tlv = (MrvlIEtypes_Cloud_Keep_Alive_Rx_t *)pos;
+		keep_alive_Rx_tlv->header.type =
+			wlan_cpu_to_le16(TLV_TYPE_CLOUD_KEEP_ALIVE_ACK);
+		keep_alive_Rx_tlv->keep_alive_id =
+			misc_keep_alive_rx->mkeep_alive_id;
+		keep_alive_Rx_tlv->enable = misc_keep_alive_rx->enable;
+		memcpy_ext(pmpriv->adapter,
+			   keep_alive_Rx_tlv->eth_header.dest_addr,
+			   misc_keep_alive_rx->dst_mac, MLAN_MAC_ADDR_LENGTH,
+			   MLAN_MAC_ADDR_LENGTH);
+		memcpy_ext(pmpriv->adapter,
+			   keep_alive_Rx_tlv->eth_header.src_addr,
+			   misc_keep_alive_rx->src_mac, MLAN_MAC_ADDR_LENGTH,
+			   MLAN_MAC_ADDR_LENGTH);
+		memcpy_ext(pmpriv->adapter,
+			   (t_u8 *)&keep_alive_Rx_tlv->eth_header.h803_len,
+			   eth_ip, sizeof(t_u16), sizeof(t_u16));
+		if (misc_keep_alive_rx->ether_type)
+			keep_alive_Rx_tlv->eth_header.h803_len =
+				mlan_htons(misc_keep_alive_rx->ether_type);
+		else
+			memcpy_ext(
+				pmpriv->adapter,
+				(t_u8 *)&keep_alive_Rx_tlv->eth_header.h803_len,
+				eth_ip, sizeof(t_u16), sizeof(t_u16));
+		memcpy_ext(pmpriv->adapter,
+			   (t_u8 *)&keep_alive_Rx_tlv->ip_packet,
+			   misc_keep_alive_rx->packet,
+			   misc_keep_alive_rx->pkt_len,
+			   MKEEP_ALIVE_ACK_PKT_MAX);
+
+		len = sizeof(MrvlIEtypes_Cloud_Keep_Alive_Rx_t) +
+		      misc_keep_alive_rx->pkt_len - sizeof(MrvlIEtypesHeader_t);
+		keep_alive_Rx_tlv->header.len = wlan_cpu_to_le16(len);
+
 		cmd->size = cmd->size + len + sizeof(MrvlIEtypesHeader_t);
 		cmd->size = wlan_cpu_to_le16(cmd->size);
 		break;
@@ -2319,7 +3613,7 @@ static mlan_status wlan_cmd_auto_tx(pmlan_private pmpriv,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_is_cmd_allowed(mlan_private *priv, t_u16 cmd_no)
+static mlan_status wlan_is_cmd_allowed(mlan_private *priv, t_u16 cmd_no)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
@@ -2343,6 +3637,55 @@ mlan_status wlan_is_cmd_allowed(mlan_private *priv, t_u16 cmd_no)
 	return ret;
 }
 
+/**
+ * @brief This function enable/disable CSI support.
+ *
+ * @param pmpriv       A pointer to mlan_private structure
+ * @param cmd          A pointer to HostCmd_DS_COMMAND structure
+ * @param cmd_action   The action: GET or SET
+ * @param pdata_buf    A pointer to data buffer
+ *
+ * @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_cmd_csi(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				t_u16 cmd_action, t_u16 *pdata_buf)
+{
+	HostCmd_DS_CSI_CFG *csi_cfg_cmd = &cmd->params.csi_params;
+	mlan_ds_csi_params *csi_params = MNULL;
+
+	ENTER();
+
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_CSI);
+	cmd->size = sizeof(HostCmd_DS_CSI_CFG) + S_DS_GEN;
+	csi_cfg_cmd->action = wlan_cpu_to_le16(cmd_action);
+	switch (cmd_action) {
+	case CSI_CMD_ENABLE:
+		csi_params = (mlan_ds_csi_params *)pdata_buf;
+		csi_cfg_cmd->head_id = wlan_cpu_to_le32(csi_params->head_id);
+		csi_cfg_cmd->tail_id = wlan_cpu_to_le32(csi_params->tail_id);
+		csi_cfg_cmd->chip_id = csi_params->chip_id;
+		csi_cfg_cmd->csi_filter_cnt = csi_params->csi_filter_cnt;
+		if (csi_cfg_cmd->csi_filter_cnt > CSI_FILTER_MAX)
+			csi_cfg_cmd->csi_filter_cnt = CSI_FILTER_MAX;
+		memcpy_ext(pmpriv->adapter, (t_u8 *)csi_cfg_cmd->csi_filter,
+			   (t_u8 *)csi_params->csi_filter,
+			   sizeof(mlan_csi_filter_t) *
+				   csi_cfg_cmd->csi_filter_cnt,
+			   sizeof(csi_cfg_cmd->csi_filter));
+		DBG_HEXDUMP(MCMD_D, "Enable CSI", csi_cfg_cmd,
+			    sizeof(HostCmd_DS_CSI_CFG));
+		break;
+	case CSI_CMD_DISABLE:
+		DBG_HEXDUMP(MCMD_D, "Disable CSI", csi_cfg_cmd,
+			    sizeof(HostCmd_DS_CSI_CFG));
+	default:
+		break;
+	}
+	cmd->size = wlan_cpu_to_le16(cmd->size);
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function prepare the command before sending to firmware.
  *
@@ -2437,6 +3780,17 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_ssu(pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
 #endif
+	case HostCmd_CMD_CSI:
+		ret = wlan_cmd_csi(pmpriv, cmd_ptr, cmd_action, pdata_buf);
+		break;
+	case HostCmd_CMD_HAL_PHY_CFG:
+		ret = wlan_cmd_hal_phy_cfg(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_IPS_CONFIG:
+		ret = wlan_cmd_ips_config(pmpriv, cmd_ptr, cmd_action,
+					  pdata_buf);
+		break;
 	case HOST_CMD_PMIC_CONFIGURE:
 		cmd_ptr->command = wlan_cpu_to_le16(cmd_no);
 		cmd_ptr->size = wlan_cpu_to_le16(S_DS_GEN);
@@ -2482,6 +3836,14 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_802_11_link_statistic(pmpriv, cmd_ptr,
 						     cmd_action, pioctl_buf);
 		break;
+	case HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS:
+		ret = wlan_cmd_802_11_ftm_config_session_params(
+			pmpriv, cmd_ptr, cmd_action, cmd_oid, pdata_buf);
+		break;
+	case HostCmd_CMD_FTM_CONFIG_RESPONDER:
+		ret = wlan_cmd_802_11_ftm_config_responder(
+			pmpriv, cmd_ptr, cmd_action, cmd_oid, pdata_buf);
+		break;
 	case HostCmd_CMD_RSSI_INFO:
 		ret = wlan_cmd_802_11_rssi_info(pmpriv, cmd_ptr, cmd_action);
 		break;
@@ -2640,6 +4002,14 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_mgmt_ie_list(pmpriv, cmd_ptr, cmd_action,
 					    pdata_buf);
 		break;
+	case HostCmd_CMD_TDLS_CONFIG:
+		ret = wlan_cmd_tdls_config(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_TDLS_OPERATION:
+		ret = wlan_cmd_tdls_oper(pmpriv, cmd_ptr, cmd_action,
+					 pdata_buf);
+		break;
 	case HostCmd_CMD_802_11_SCAN_EXT:
 		ret = wlan_cmd_802_11_scan_ext(pmpriv, cmd_ptr, pdata_buf);
 		break;
@@ -2654,6 +4024,7 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_TARGET_ACCESS:
 	case HostCmd_CMD_802_11_EEPROM_ACCESS:
 	case HostCmd_CMD_BCA_REG_ACCESS:
+	case HostCmd_CMD_REG_ACCESS:
 		ret = wlan_cmd_reg_access(pmpriv, cmd_ptr, cmd_action,
 					  pdata_buf);
 		break;
@@ -2690,6 +4061,10 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 			sizeof(HostCmd_DS_SET_BSS_MODE) + S_DS_GEN);
 		ret = MLAN_STATUS_SUCCESS;
 		break;
+	case HostCmd_CMD_802_11_NET_MONITOR:
+		ret = wlan_cmd_net_monitor(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
 	case HostCmd_CMD_MEASUREMENT_REQUEST:
 	case HostCmd_CMD_MEASUREMENT_REPORT:
 		ret = wlan_meas_cmd_process(pmpriv, cmd_ptr, pdata_buf);
@@ -2720,6 +4095,10 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_otp_user_data(pmpriv, cmd_ptr, cmd_action,
 					     pdata_buf);
 		break;
+	case HostCmd_CMD_FW_AUTO_RECONNECT:
+		ret = wlan_cmd_fw_auto_reconnect(pmpriv, cmd_ptr, cmd_action,
+						 pdata_buf);
+		break;
 	case HostCmd_CMD_HS_WAKEUP_REASON:
 		ret = wlan_cmd_hs_wakeup_reason(pmpriv, cmd_ptr, pdata_buf);
 		break;
@@ -2737,12 +4116,17 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 			pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
 #endif
-#ifdef RX_PACKET_COALESCE
-	case HostCmd_CMD_RX_PKT_COALESCE_CFG:
-		ret = wlan_cmd_rx_pkt_coalesce_cfg(pmpriv, cmd_ptr, cmd_action,
-						   pdata_buf);
+	case HostCmd_CMD_MULTI_CHAN_CONFIG:
+		ret = wlan_cmd_multi_chan_cfg(pmpriv, cmd_ptr, cmd_action,
+					      pdata_buf);
+		break;
+	case HostCmd_CMD_MULTI_CHAN_POLICY:
+		ret = wlan_cmd_multi_chan_policy(pmpriv, cmd_ptr, cmd_action,
+						 pdata_buf);
+		break;
+	case HostCmd_CMD_DRCS_CONFIG:
+		ret = wlan_cmd_drcs_cfg(pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
-#endif
 	case HostCMD_CONFIG_LOW_POWER_MODE:
 		ret = wlan_cmd_low_pwr_mode(pmpriv, cmd_ptr, pdata_buf);
 		break;
@@ -2760,6 +4144,10 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_802_11_MIMO_SWITCH:
 		ret = wlan_cmd_802_11_mimo_switch(pmpriv, cmd_ptr, pdata_buf);
 		break;
+	case HostCmd_CMD_IPV6_RA_OFFLOAD_CFG:
+		ret = wlan_cmd_ipv6_ra_offload(pmpriv, cmd_ptr, cmd_action,
+					       pdata_buf);
+		break;
 	case HostCmd_CMD_STA_CONFIGURE:
 		ret = wlan_cmd_sta_config(pmpriv, cmd_ptr, cmd_action,
 					  pioctl_buf, pdata_buf);
@@ -2769,6 +4157,11 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_ind_rst_cfg(cmd_ptr, cmd_action, pdata_buf);
 		break;
 
+	case HostCmd_CMD_ROAM_OFFLOAD:
+		ret = wlan_cmd_roam_offload(pmpriv, cmd_ptr, cmd_action,
+					    pdata_buf);
+		break;
+
 	case HostCmd_CMD_802_11_PS_INACTIVITY_TIMEOUT:
 		ret = wlan_cmd_ps_inactivity_timeout(pmpriv, cmd_ptr,
 						     cmd_action, pdata_buf);
@@ -2818,10 +4211,18 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_TWT_CFG:
 		ret = wlan_cmd_twt_cfg(pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
+	case HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG:
+		ret = wlan_cmd_gpio_tsf_latch(pmpriv, cmd_ptr, cmd_action,
+					      pioctl_buf, pdata_buf);
+		break;
 	case HostCmd_CMD_RX_ABORT_CFG:
 		ret = wlan_cmd_rxabortcfg(pmpriv, cmd_ptr, cmd_action,
 					  pdata_buf);
 		break;
+	case HostCmd_CMD_OFDM_DESENSE_CFG:
+		ret = wlan_cmd_ofdmdesense_cfg(pmpriv, cmd_ptr, cmd_action,
+					       pdata_buf);
+		break;
 	case HostCmd_CMD_RX_ABORT_CFG_EXT:
 		ret = wlan_cmd_rxabortcfg_ext(pmpriv, cmd_ptr, cmd_action,
 					      pdata_buf);
@@ -2856,6 +4257,18 @@ mlan_status wlan_ops_sta_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_MFG_COMMAND:
 		ret = wlan_cmd_mfg(pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
+	case HostCmd_CMD_MC_AGGR_CFG:
+		ret = wlan_cmd_mc_aggr_cfg(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_GET_CH_LOAD:
+		ret = wlan_cmd_get_ch_load(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_CROSS_CHIP_SYNCH:
+		ret = wlan_cmd_cross_chip_synch(pmpriv, cmd_ptr, cmd_action,
+						pdata_buf);
+		break;
 	default:
 		PRINTM(MERROR, "PREP_CMD: unknown command- %#x\n", cmd_no);
 		ret = MLAN_STATUS_FAILURE;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmdresp.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmdresp.c
old mode 100644
new mode 100755
index 4cd48b815..eba371de1
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmdresp.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_cmdresp.c
@@ -4,7 +4,7 @@
  *  responses generated by firmware.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -49,6 +49,87 @@
 /********************************************************
  *			Local Functions
  ********************************************************/
+/**
+ *  @brief This function handles the command response error for TDLS operation
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *
+ *  @return             N/A
+ */
+static void
+wlan_process_cmdreps_error_tdls_operation(mlan_private *pmpriv,
+					  HostCmd_DS_COMMAND *resp,
+					  mlan_ioctl_req *pioctl_buf)
+{
+	mlan_adapter *pmadapter = pmpriv->adapter;
+	HostCmd_DS_TDLS_OPER *ptdls_oper_data = &(resp->params.tdls_oper_data);
+	sta_node *sta_ptr = MNULL;
+	t_u16 reason;
+
+	ENTER();
+	ptdls_oper_data->tdls_action =
+		wlan_le16_to_cpu(ptdls_oper_data->tdls_action);
+	reason = wlan_le16_to_cpu(ptdls_oper_data->reason);
+	sta_ptr = wlan_get_station_entry(pmpriv, ptdls_oper_data->peer_mac);
+	switch (ptdls_oper_data->tdls_action) {
+	case TDLS_CREATE:
+		/* TDLS create command error */
+		if (reason != TDLS_LINK_EXISTS && sta_ptr) {
+			PRINTM(MERROR,
+			       "TDLS CREATE operation: cmd error reason %d\n",
+			       reason);
+			sta_ptr->status = TDLS_SETUP_FAILURE;
+		}
+		if (reason == TDLS_LINK_EXISTS && pioctl_buf)
+			pioctl_buf->status_code = MLAN_STATUS_SUCCESS;
+		break;
+	case TDLS_CONFIG:
+		/* TDLS config command error */
+		PRINTM(MERROR,
+		       "TDLS CONFIG operation: command error, reason %d\n",
+		       reason);
+		if (sta_ptr)
+			sta_ptr->status = TDLS_SETUP_FAILURE;
+		break;
+	case TDLS_DELETE:
+		/* TDLS delete command error */
+		wlan_restore_tdls_packets(pmpriv, ptdls_oper_data->peer_mac,
+					  TDLS_TEAR_DOWN);
+		if (sta_ptr) {
+			/**tdls cs stop*/
+			if (ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+				    sta_ptr->ExtCap.ext_cap))
+				wlan_tdls_config(pmpriv, MFALSE);
+			if (sta_ptr->is_11n_enabled ||
+			    sta_ptr->is_11ax_enabled) {
+				wlan_cleanup_reorder_tbl(
+					pmpriv, ptdls_oper_data->peer_mac);
+				wlan_11n_cleanup_txbastream_tbl(
+					pmpriv, ptdls_oper_data->peer_mac);
+			}
+			if (sta_ptr->status >= TDLS_SETUP_INPROGRESS)
+				wlan_delete_station_entry(
+					pmpriv, ptdls_oper_data->peer_mac);
+		}
+		if (wlan_is_station_list_empty(pmpriv) == MTRUE)
+			pmadapter->tdls_status = TDLS_NOT_SETUP;
+		else
+			pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+
+		if (reason == TDLS_LINK_NONEXISTENT) {
+			if (pioctl_buf)
+				pioctl_buf->status_code = MLAN_STATUS_SUCCESS;
+		} else {
+			PRINTM(MERROR,
+			       "TDLS DELETE operation: cmd error, reason %d\n",
+			       reason);
+		}
+		break;
+	}
+	LEAVE();
+	return;
+}
 
 /**
  *  @brief This function handles the command response error
@@ -66,6 +147,10 @@ static mlan_status wlan_process_cmdresp_error(mlan_private *pmpriv,
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	pmlan_ioctl_req pscan_ioctl_req = MNULL;
 	mlan_callbacks *pcb = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	HostCmd_DS_TDLS_CONFIG *ptdls_config_data =
+		&(resp->params.tdls_config_data);
+
 #if defined(USB)
 	t_s32 i = 0;
 #endif
@@ -74,7 +159,7 @@ static mlan_status wlan_process_cmdresp_error(mlan_private *pmpriv,
 	ENTER();
 	if (resp->command != HostCmd_CMD_WMM_PARAM_CONFIG &&
 	    resp->command != HostCmd_CMD_CHAN_REGION_CFG)
-		PRINTM(MERROR, "CMD_RESP: cmd %#x error, result=%#x\n",
+		PRINTM(MINFO, "CMD_RESP: cmd %#x error, result=%#x\n",
 		       resp->command, resp->result);
 	if (pioctl_buf)
 		pioctl_buf->status_code = MLAN_ERROR_FW_CMDRESP;
@@ -107,12 +192,12 @@ static mlan_status wlan_process_cmdresp_error(mlan_private *pmpriv,
 		pmadapter->pscan_ioctl_req = MNULL;
 		/* Need to indicate IOCTL complete */
 		if (pscan_ioctl_req) {
-			pscan_ioctl_req->status_code = MLAN_ERROR_CMD_SCAN_FAIL;
+			pscan_ioctl_req->status_code = MLAN_ERROR_NO_ERROR;
 			/* Indicate ioctl complete */
 			pcb->moal_ioctl_complete(
 				pmadapter->pmoal_handle,
 				(pmlan_ioctl_req)pscan_ioctl_req,
-				MLAN_STATUS_FAILURE);
+				MLAN_STATUS_SUCCESS);
 		}
 		wlan_release_cmd_lock(pmadapter);
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_SCAN_REPORT, MNULL);
@@ -121,6 +206,37 @@ static mlan_status wlan_process_cmdresp_error(mlan_private *pmpriv,
 	case HostCmd_CMD_MAC_CONTROL:
 		break;
 
+	case HostCmd_CMD_TDLS_CONFIG:
+		ptdls_config_data->tdls_info.tdls_action = wlan_le16_to_cpu(
+			ptdls_config_data->tdls_info.tdls_action);
+		switch (ptdls_config_data->tdls_info.tdls_action) {
+		case WLAN_TDLS_SETUP_REQ:
+			/* TDLS link setup error ;display error in logs */
+			tdls_all_cfg =
+				(tdls_all_config *)
+					ptdls_config_data->tdls_info.tdls_data;
+			PRINTM(MERROR, "TDLS Setup Failed, error %d\n",
+			       wlan_le16_to_cpu(tdls_all_cfg->u.tdls_cmd_resp
+							.reason_code));
+			break;
+		case WLAN_TDLS_INIT_CHAN_SWITCH:
+			tdls_all_cfg =
+				(tdls_all_config *)
+					ptdls_config_data->tdls_info.tdls_data;
+			PRINTM(MERROR,
+			       "TDLS init channel switch failed," MACSTR
+			       ": reason=%d\n",
+			       MAC2STR(tdls_all_cfg->u.tdls_cmd_resp
+					       .peer_mac_addr),
+			       wlan_le16_to_cpu(tdls_all_cfg->u.tdls_cmd_resp
+							.reason_code));
+			break;
+		}
+		break;
+	case HostCmd_CMD_TDLS_OPERATION:
+		wlan_process_cmdreps_error_tdls_operation(pmpriv, resp,
+							  pioctl_buf);
+		break;
 	case HostCmd_CMD_PACKET_AGGR_CTRL:
 #ifdef USB
 		if (IS_USB(pmadapter->card_type)) {
@@ -205,6 +321,12 @@ static mlan_status wlan_process_cmdresp_error(mlan_private *pmpriv,
 			}
 		}
 	} break;
+	case HostCmd_CMD_ROAM_OFFLOAD:
+		if (MLAN_STATUS_SUCCESS != wlan_clear_fw_roaming_pmk(pmpriv))
+			PRINTM(MERROR, "wlan_clear_fw_roaming_pmk fail\n");
+		pmpriv->adapter->fw_roaming = MFALSE;
+		PRINTM(MERROR, "FW do not support roaming!\n");
+		break;
 	case HostCmd_CMD_CHAN_REGION_CFG:
 		ret = MLAN_STATUS_SUCCESS;
 		PRINTM(MCMND, "FW don't support chan region cfg command!\n");
@@ -507,6 +629,7 @@ static mlan_status wlan_ret_802_11_snmp_mib(pmlan_private pmpriv,
 		/* Update state for 11h */
 		if (oid == Dot11H_i) {
 			ul_temp = wlan_le16_to_cpu(*((t_u16 *)(psmib->value)));
+			PRINTM(MCMND, "wlan: Dot11H_i=%d\n", ul_temp);
 			/* Set 11h state to priv */
 			pmpriv->intf_state_11h.is_11h_active =
 				(ul_temp & ENABLE_11H_MASK);
@@ -593,6 +716,58 @@ static mlan_status wlan_ret_get_log(pmlan_private pmpriv,
 		pget_info->param.stats.amsdu_tx_cnt = pmpriv->amsdu_tx_cnt;
 		pget_info->param.stats.msdu_in_tx_amsdu_cnt =
 			pmpriv->msdu_in_tx_amsdu_cnt;
+		pget_info->param.stats.rx_stuck_issue_cnt[0] =
+			wlan_le32_to_cpu(pget_log->rx_stuck_issue_cnt[0]);
+		pget_info->param.stats.rx_stuck_issue_cnt[1] =
+			wlan_le32_to_cpu(pget_log->rx_stuck_issue_cnt[1]);
+		pget_info->param.stats.rx_stuck_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->rx_stuck_recovery_cnt);
+		pget_info->param.stats.rx_stuck_tsf[0] =
+			wlan_le64_to_cpu(pget_log->rx_stuck_tsf[0]);
+		pget_info->param.stats.rx_stuck_tsf[1] =
+			wlan_le64_to_cpu(pget_log->rx_stuck_tsf[1]);
+		pget_info->param.stats.tx_watchdog_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->tx_watchdog_recovery_cnt);
+		pget_info->param.stats.tx_watchdog_tsf[0] =
+			wlan_le64_to_cpu(pget_log->tx_watchdog_tsf[0]);
+		pget_info->param.stats.tx_watchdog_tsf[1] =
+			wlan_le64_to_cpu(pget_log->tx_watchdog_tsf[1]);
+		pget_info->param.stats.channel_switch_ann_sent =
+			wlan_le32_to_cpu(pget_log->channel_switch_ann_sent);
+		pget_info->param.stats.channel_switch_state =
+			wlan_le32_to_cpu(pget_log->channel_switch_state);
+		pget_info->param.stats.reg_class =
+			wlan_le32_to_cpu(pget_log->reg_class);
+		pget_info->param.stats.channel_number =
+			wlan_le32_to_cpu(pget_log->channel_number);
+		pget_info->param.stats.channel_switch_mode =
+			wlan_le32_to_cpu(pget_log->channel_switch_mode);
+		pget_info->param.stats.rx_reset_mac_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->rx_reset_mac_recovery_cnt);
+		pget_info->param.stats.rx_Isr2_NotDone_Cnt =
+			wlan_le32_to_cpu(pget_log->rx_Isr2_NotDone_Cnt);
+		pget_info->param.stats.gdma_abort_cnt =
+			wlan_le32_to_cpu(pget_log->gdma_abort_cnt);
+		pget_info->param.stats.g_reset_rx_mac_cnt =
+			wlan_le32_to_cpu(pget_log->g_reset_rx_mac_cnt);
+		// Ownership error counters
+		pget_info->param.stats.dwCtlErrCnt =
+			wlan_le32_to_cpu(pget_log->dwCtlErrCnt);
+		pget_info->param.stats.dwBcnErrCnt =
+			wlan_le32_to_cpu(pget_log->dwBcnErrCnt);
+		pget_info->param.stats.dwMgtErrCnt =
+			wlan_le32_to_cpu(pget_log->dwMgtErrCnt);
+		pget_info->param.stats.dwDatErrCnt =
+			wlan_le32_to_cpu(pget_log->dwDatErrCnt);
+		pget_info->param.stats.bigtk_mmeGoodCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_mmeGoodCnt);
+		pget_info->param.stats.bigtk_replayErrCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_replayErrCnt);
+		pget_info->param.stats.bigtk_micErrCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_micErrCnt);
+		pget_info->param.stats.bigtk_mmeNotFoundCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_mmeNotFoundCnt);
+
 		if (pmpriv->adapter->getlog_enable) {
 			pget_info->param.stats.tx_frag_cnt =
 				wlan_le32_to_cpu(pget_log->tx_frag_cnt);
@@ -713,7 +888,7 @@ static mlan_status wlan_ret_get_log(pmlan_private pmpriv,
  */
 static mlan_status wlan_get_power_level(pmlan_private pmpriv, void *pdata_buf)
 {
-	t_u16 length = 0;
+	t_s32 length = 0;
 	t_s8 max_power = -1, min_power = -1;
 	MrvlTypes_Power_Group_t *ppg_tlv = MNULL;
 	Power_Group_t *pg = MNULL;
@@ -732,7 +907,7 @@ static mlan_status wlan_get_power_level(pmlan_private pmpriv, void *pdata_buf)
 			min_power = pg->power_min;
 			length -= sizeof(Power_Group_t);
 		}
-		while (length) {
+		while (length > 0) {
 			pg++;
 			if (max_power < pg->power_max)
 				max_power = pg->power_max;
@@ -965,6 +1140,7 @@ static mlan_status wlan_ret_802_11_sleep_period(pmlan_private pmpriv,
 			MLAN_SUB_COMMAND_SIZE;
 	}
 	pmpriv->adapter->sleep_period.period = sleep_pd;
+	pmpriv->adapter->saved_sleep_period.period = sleep_pd;
 
 	pmpriv->adapter->pps_uapsd_mode = MFALSE;
 	if ((pmpriv->adapter->sleep_period.period != 0) &&
@@ -1142,11 +1318,16 @@ static mlan_status wlan_ret_802_11_key_material(pmlan_private pmpriv,
 			}
 			if (memcmp(pmpriv->adapter, pmpriv->gtk_rekey.kek,
 				   zero_kek, sizeof(zero_kek)) != 0) {
-				wlan_prepare_cmd(
+				mlan_status ret = MLAN_STATUS_SUCCESS;
+				ret = wlan_prepare_cmd(
 					pmpriv,
 					HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG,
 					HostCmd_ACT_GEN_SET, 0, MNULL,
 					&pmpriv->gtk_rekey);
+				if (ret) {
+					PRINTM(MINFO,
+					       "Error sending message to FW\n");
+				}
 				memset(pmpriv->adapter, &pmpriv->gtk_rekey, 0,
 				       sizeof(mlan_ds_misc_gtk_rekey_data));
 			}
@@ -1215,13 +1396,16 @@ static mlan_status wlan_ret_802_11_key_material(pmlan_private pmpriv,
 					wlan_le16_to_cpu(
 						pkey->key_param_set.key_params
 							.aes.key_len);
-				memcpy_ext(
-					pmpriv->adapter,
-					sec->param.encrypt_key.key_material,
-					pkey->key_param_set.key_params.aes.key,
+				sec->param.encrypt_key
+					.key_len = MIN(
 					sec->param.encrypt_key.key_len,
-					sizeof(sec->param.encrypt_key
-						       .key_material));
+					sizeof(pkey->key_param_set.key_params
+						       .aes.key)),
+		  memcpy_ext(pmpriv->adapter,
+			     sec->param.encrypt_key.key_material,
+			     pkey->key_param_set.key_params.aes.key,
+			     sec->param.encrypt_key.key_len,
+			     sizeof(sec->param.encrypt_key.key_material));
 				memcpy_ext(
 					pmpriv->adapter,
 					sec->param.encrypt_key.pn,
@@ -1234,13 +1418,16 @@ static mlan_status wlan_ret_802_11_key_material(pmlan_private pmpriv,
 					wlan_le16_to_cpu(
 						pkey->key_param_set.key_params
 							.cmac_aes.key_len);
-				memcpy_ext(pmpriv->adapter,
-					   sec->param.encrypt_key.key_material,
-					   pkey->key_param_set.key_params
-						   .cmac_aes.key,
-					   sec->param.encrypt_key.key_len,
-					   sizeof(sec->param.encrypt_key
-							  .key_material));
+				sec->param.encrypt_key
+					.key_len = MIN(
+					sec->param.encrypt_key.key_len,
+					sizeof(pkey->key_param_set.key_params
+						       .cmac_aes.key)),
+		  memcpy_ext(pmpriv->adapter,
+			     sec->param.encrypt_key.key_material,
+			     pkey->key_param_set.key_params.cmac_aes.key,
+			     sec->param.encrypt_key.key_len,
+			     sizeof(sec->param.encrypt_key.key_material));
 				memcpy_ext(pmpriv->adapter,
 					   sec->param.encrypt_key.pn,
 					   pkey->key_param_set.key_params
@@ -1253,13 +1440,16 @@ static mlan_status wlan_ret_802_11_key_material(pmlan_private pmpriv,
 					wlan_le16_to_cpu(
 						pkey->key_param_set.key_params
 							.wep.key_len);
-				memcpy_ext(
-					pmpriv->adapter,
-					sec->param.encrypt_key.key_material,
-					pkey->key_param_set.key_params.wep.key,
+				sec->param.encrypt_key
+					.key_len = MIN(
 					sec->param.encrypt_key.key_len,
-					sizeof(sec->param.encrypt_key
-						       .key_material));
+					sizeof(pkey->key_param_set.key_params
+						       .wep.key)),
+		  memcpy_ext(pmpriv->adapter,
+			     sec->param.encrypt_key.key_material,
+			     pkey->key_param_set.key_params.wep.key,
+			     sec->param.encrypt_key.key_len,
+			     sizeof(sec->param.encrypt_key.key_material));
 				break;
 			}
 		}
@@ -1525,6 +1715,351 @@ static mlan_status wlan_ret_mgmt_ie_list(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function enable/disable tdls powermode
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param powermode    1--enable, 0--disable
+ *
+ *  @return             N/A
+ */
+static void wlan_set_tdls_powermode(pmlan_private pmpriv, t_u8 powermode)
+{
+	ENTER();
+
+	if (powermode) {
+		pmpriv->wmm_qosinfo = DEFAULT_TDLS_WMM_QOS_INFO;
+		if (!pmpriv->adapter->sleep_period.period)
+			pmpriv->adapter->sleep_period.period =
+				DEFAULT_TDLS_SLEEP_PERIOD;
+	} else {
+		pmpriv->wmm_qosinfo = pmpriv->saved_wmm_qosinfo;
+		pmpriv->adapter->sleep_period.period =
+			pmpriv->adapter->saved_sleep_period.period;
+	}
+	pmpriv->adapter->pps_uapsd_mode = MFALSE;
+	if ((pmpriv->adapter->sleep_period.period != 0) &&
+	    (pmpriv->adapter->sleep_period.period !=
+	     SLEEP_PERIOD_RESERVED_FF)) {
+		pmpriv->adapter->gen_null_pkt = MTRUE;
+	} else {
+		pmpriv->adapter->delay_null_pkt = MFALSE;
+		pmpriv->adapter->gen_null_pkt = MFALSE;
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function handles the command response of TDLS_CONFIG
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_ret_tdls_config(pmlan_private pmpriv,
+					HostCmd_DS_COMMAND *resp,
+					mlan_ioctl_req *pioctl_buf)
+{
+	t_u8 i = 0;
+	t_u16 link_length = 0, final_data_rate = 0;
+	mlan_ds_misc_cfg *misc = MNULL;
+	tdls_all_config *tdls_all_cfg = MNULL;
+	sta_node *sta_ptr = MNULL;
+	HostCmd_DS_TDLS_CONFIG *ptdls_config_data =
+		&(resp->params.tdls_config_data);
+	pmlan_adapter pmadapter = pmpriv->adapter;
+	tdls_each_link_status *link_ptr = MNULL;
+
+	ENTER();
+
+	ptdls_config_data->tdls_info.tdls_action =
+		wlan_le16_to_cpu(ptdls_config_data->tdls_info.tdls_action);
+	switch (ptdls_config_data->tdls_info.tdls_action) {
+	case WLAN_TDLS_CONFIG:
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		if (pmpriv->host_tdls_cs_support ||
+		    pmpriv->host_tdls_uapsd_support)
+			break;
+		if (wlan_le16_to_cpu(tdls_all_cfg->u.tdls_config.enable) == 0) {
+			PRINTM(MINFO, "TDLS disable successful.\n");
+			wlan_delete_station_list(pmpriv);
+			pmadapter->tdls_status = TDLS_NOT_SETUP;
+			if (pmpriv->saved_wmm_qosinfo)
+				pmpriv->wmm_qosinfo = pmpriv->saved_wmm_qosinfo;
+			if (pmadapter->saved_sleep_period.period)
+				pmadapter->sleep_period.period =
+					pmadapter->saved_sleep_period.period;
+		}
+		break;
+
+	case WLAN_TDLS_SET_INFO:
+		break;
+
+	case WLAN_TDLS_DISCOVERY_REQ:
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		tdls_all_cfg->u.tdls_discovery_resp.payload_len =
+			wlan_le16_to_cpu(
+				tdls_all_cfg->u.tdls_discovery_resp.payload_len);
+		tdls_all_cfg->u.tdls_discovery_resp.cap_info = wlan_le16_to_cpu(
+			tdls_all_cfg->u.tdls_discovery_resp.cap_info);
+		memcpy_ext(pmpriv->adapter, &misc->param.tdls_config,
+			   &ptdls_config_data->tdls_info,
+			   (resp->size - S_DS_GEN),
+			   sizeof(mlan_ds_misc_tdls_config));
+		PRINTM(MCMND, "TDLS_DISCOVERY_REQ: " MACSTR "\n",
+		       MAC2STR(tdls_all_cfg->u.tdls_discovery_resp
+				       .peer_mac_addr));
+		break;
+
+	case WLAN_TDLS_SETUP_REQ:
+		/*
+		 * TDLS link being setup, block all data for this Peer
+		 */
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		PRINTM(MCMND, "TDLS_SETUP_REQ: " MACSTR "\n",
+		       MAC2STR(tdls_all_cfg->u.tdls_setup.peer_mac_addr));
+		sta_ptr = wlan_get_station_entry(
+			pmpriv, tdls_all_cfg->u.tdls_setup.peer_mac_addr);
+		if (!sta_ptr) {
+			sta_ptr = wlan_add_station_entry(
+				pmpriv,
+				tdls_all_cfg->u.tdls_setup.peer_mac_addr);
+			if (sta_ptr) {
+				sta_ptr->status = TDLS_SETUP_INPROGRESS;
+				wlan_hold_tdls_packets(
+					pmpriv, tdls_all_cfg->u.tdls_setup
+							.peer_mac_addr);
+			}
+		}
+		break;
+
+	case WLAN_TDLS_TEAR_DOWN_REQ:
+		/*
+		 * TDLS link torn down, open data ports if blocked
+		 */
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		wlan_restore_tdls_packets(
+			pmpriv, tdls_all_cfg->u.tdls_tear_down.peer_mac_addr,
+			TDLS_TEAR_DOWN);
+		PRINTM(MCMND, "TDLS_TEARDOWN_REQ: " MACSTR "\n",
+		       MAC2STR(tdls_all_cfg->u.tdls_tear_down.peer_mac_addr));
+		sta_ptr = wlan_get_station_entry(
+			pmpriv, tdls_all_cfg->u.tdls_tear_down.peer_mac_addr);
+		if (sta_ptr) {
+			if (sta_ptr->is_11n_enabled ||
+			    sta_ptr->is_11ax_enabled) {
+				wlan_cleanup_reorder_tbl(
+					pmpriv, tdls_all_cfg->u.tdls_tear_down
+							.peer_mac_addr);
+				wlan_11n_cleanup_txbastream_tbl(
+					pmpriv, tdls_all_cfg->u.tdls_tear_down
+							.peer_mac_addr);
+			}
+			wlan_delete_station_entry(
+				pmpriv,
+				tdls_all_cfg->u.tdls_tear_down.peer_mac_addr);
+			if (MTRUE == wlan_is_station_list_empty(pmpriv))
+				pmadapter->tdls_status = TDLS_NOT_SETUP;
+			else
+				pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+		}
+		break;
+	case WLAN_TDLS_INIT_CHAN_SWITCH:
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		PRINTM(MCMND,
+		       "TDLS_INIT_CHANNEL_SWITCH: " MACSTR
+		       " chan=%d periodicity=%d\n",
+		       MAC2STR(tdls_all_cfg->u.tdls_chan_switch.peer_mac_addr),
+		       (int)tdls_all_cfg->u.tdls_chan_switch.primary_channel,
+		       (int)tdls_all_cfg->u.tdls_chan_switch.periodicity);
+		break;
+
+	case WLAN_TDLS_LINK_STATUS:
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		tdls_all_cfg->u.tdls_link_status_resp.payload_len =
+			wlan_le16_to_cpu(tdls_all_cfg->u.tdls_link_status_resp
+						 .payload_len);
+		link_ptr = tdls_all_cfg->u.tdls_link_status_resp.link_stats;
+		for (i = 0;
+		     i < tdls_all_cfg->u.tdls_link_status_resp.active_links;
+		     i++) {
+			link_ptr->active_channel =
+				wlan_le32_to_cpu(link_ptr->active_channel);
+			link_ptr->data_rssi_last =
+				wlan_le16_to_cpu(link_ptr->data_rssi_last);
+			link_ptr->data_nf_last =
+				wlan_le16_to_cpu(link_ptr->data_nf_last);
+			link_ptr->data_rssi_avg =
+				wlan_le16_to_cpu(link_ptr->data_rssi_avg);
+			link_ptr->data_nf_avg =
+				wlan_le16_to_cpu(link_ptr->data_nf_avg);
+			link_length = sizeof(tdls_each_link_status) - 1;
+			/* adjust as per open or secure network */
+			if (link_ptr->link_flags & 0x02) {
+				link_ptr->key_lifetime = wlan_le32_to_cpu(
+					link_ptr->key_lifetime);
+				link_length += link_ptr->key_length;
+			} else {
+				link_length -=
+					sizeof(link_ptr->security_method) +
+					sizeof(link_ptr->key_lifetime) +
+					sizeof(link_ptr->key_length);
+			}
+			final_data_rate = (t_u16)wlan_index_to_data_rate(
+				pmadapter, link_ptr->u.rate_info.tx_data_rate,
+				link_ptr->u.rate_info.tx_rate_htinfo, 0);
+			link_ptr->u.final_data_rate = final_data_rate / 2;
+
+			link_ptr =
+				(tdls_each_link_status *)(((t_u8 *)link_ptr) +
+							  link_length);
+		}
+		memcpy_ext(pmpriv->adapter, &misc->param.tdls_config,
+			   &ptdls_config_data->tdls_info,
+			   (resp->size - S_DS_GEN),
+			   sizeof(mlan_ds_misc_tdls_config));
+		break;
+	case WLAN_TDLS_POWER_MODE:
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		tdls_all_cfg->u.tdls_power_mode.power_mode = wlan_le16_to_cpu(
+			tdls_all_cfg->u.tdls_power_mode.power_mode);
+		wlan_set_tdls_powermode(
+			pmpriv,
+			(t_u8)tdls_all_cfg->u.tdls_power_mode.power_mode);
+		break;
+	case WLAN_TDLS_STOP_CHAN_SWITCH:
+		tdls_all_cfg = (tdls_all_config *)
+				       ptdls_config_data->tdls_info.tdls_data;
+		PRINTM(MCMND, "TDLS_STOP_CHANNEL_SWITCH: " MACSTR "\n",
+		       MAC2STR(tdls_all_cfg->u.tdls_stop_chan_switch
+				       .peer_mac_addr));
+		break;
+	case WLAN_TDLS_CS_PARAMS:
+	case WLAN_TDLS_CS_DISABLE:
+	case WLAN_TDLS_DEBUG_STOP_RX:
+	case WLAN_TDLS_DEBUG_ALLOW_WEAK_SECURITY:
+	case WLAN_TDLS_DEBUG_SETUP_SAME_LINK:
+	case WLAN_TDLS_DEBUG_FAIL_SETUP_CONFIRM:
+	case WLAN_TDLS_DEBUG_WRONG_BSS:
+	case WLAN_TDLS_DEBUG_SETUP_PROHIBITED:
+	case WLAN_TDLS_DEBUG_HIGHER_LOWER_MAC:
+	case WLAN_TDLS_DEBUG_IGNORE_KEY_EXPIRY:
+	case WLAN_TDLS_DEBUG_CS_RET_IM:
+		break;
+	default:
+		if (pioctl_buf)
+			pioctl_buf->status_code = MLAN_ERROR_CMD_RESP_FAIL;
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of TDLS_OPERATION
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_ret_tdls_oper(pmlan_private pmpriv,
+				      HostCmd_DS_COMMAND *resp,
+				      mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_TDLS_OPER *ptdls_oper = &(resp->params.tdls_oper_data);
+	sta_node *sta_ptr = MNULL;
+	t_u16 reason = 0;
+	pmlan_adapter pmadapter = pmpriv->adapter;
+
+	ENTER();
+
+	ptdls_oper->tdls_action = wlan_le16_to_cpu(ptdls_oper->tdls_action);
+
+	sta_ptr = wlan_get_station_entry(pmpriv, ptdls_oper->peer_mac);
+	reason = wlan_le16_to_cpu(ptdls_oper->reason);
+	switch (ptdls_oper->tdls_action) {
+	case TDLS_CREATE:
+		if (reason) {
+			PRINTM(MMSG,
+			       "TDLS: create link " MACSTR " fail, reason=%d\n",
+			       MAC2STR(ptdls_oper->peer_mac), reason);
+			if (reason != TDLS_LINK_EXISTS && sta_ptr)
+				sta_ptr->status = TDLS_SETUP_FAILURE;
+		} else {
+			PRINTM(MMSG, "TDLS: create link " MACSTR " success\n",
+			       MAC2STR(ptdls_oper->peer_mac), reason);
+		}
+		break;
+	case TDLS_CONFIG:
+		if (reason) {
+			PRINTM(MMSG,
+			       "TDLS: Config link " MACSTR " fail, reason=%d\n",
+			       MAC2STR(ptdls_oper->peer_mac), reason);
+			if (sta_ptr)
+				sta_ptr->status = TDLS_SETUP_FAILURE;
+		} else {
+			PRINTM(MMSG, "TDLS: Config link " MACSTR " success\n",
+			       MAC2STR(ptdls_oper->peer_mac));
+		}
+		break;
+	case TDLS_DELETE:
+		wlan_restore_tdls_packets(pmpriv, ptdls_oper->peer_mac,
+					  TDLS_TEAR_DOWN);
+		if (sta_ptr) {
+			/**tdls cs stop*/
+			if (ISSUPP_EXTCAP_TDLS_CHAN_SWITCH(
+				    sta_ptr->ExtCap.ext_cap))
+				wlan_tdls_config(pmpriv, MFALSE);
+			if (sta_ptr->is_11n_enabled ||
+			    sta_ptr->is_11ax_enabled) {
+				wlan_cleanup_reorder_tbl(pmpriv,
+							 ptdls_oper->peer_mac);
+				wlan_11n_cleanup_txbastream_tbl(
+					pmpriv, ptdls_oper->peer_mac);
+			}
+			if (sta_ptr->status >= TDLS_SETUP_INPROGRESS)
+				wlan_delete_station_entry(pmpriv,
+							  ptdls_oper->peer_mac);
+		}
+		if (MTRUE == wlan_is_station_list_empty(pmpriv))
+			pmadapter->tdls_status = TDLS_NOT_SETUP;
+		else
+			pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+
+		if (reason)
+			PRINTM(MMSG,
+			       "TDLS: Delete link " MACSTR " fail, reason=%d\n",
+			       MAC2STR(ptdls_oper->peer_mac), reason);
+		else
+			PRINTM(MMSG, "TDLS: Delete link " MACSTR " success\n",
+			       MAC2STR(ptdls_oper->peer_mac));
+		break;
+	default:
+		break;
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function handles the command response of sysclock
  *
@@ -1599,6 +2134,61 @@ static mlan_status wlan_ret_inactivity_timeout(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function handles the command response of
+ *  network monitor
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to command buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_net_monitor(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				 mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *pmisc = MNULL;
+	mlan_ds_misc_net_monitor *net_mon = MNULL;
+	HostCmd_DS_802_11_NET_MONITOR *cmd_net_mon =
+		(HostCmd_DS_802_11_NET_MONITOR *)&resp->params.net_mon;
+	ChanBandParamSet_t *pchan_band = MNULL;
+	t_u16 band_info = 0;
+
+	ENTER();
+
+	if (pioctl_buf && (pioctl_buf->action == MLAN_ACT_GET)) {
+		pmisc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		net_mon = &pmisc->param.net_mon;
+		net_mon->enable_net_mon =
+			wlan_le16_to_cpu(cmd_net_mon->enable_net_mon);
+		net_mon->filter_flag =
+			wlan_le16_to_cpu(cmd_net_mon->filter_flag);
+		pchan_band = &cmd_net_mon->monitor_chan.chan_band_param[0];
+		/* Band information in the TLV is bits[1:0] */
+		band_info = pchan_band->bandcfg.chanBand;
+		net_mon->channel = pchan_band->chan_number;
+		if (band_info == BAND_2GHZ)
+			net_mon->band |= (BAND_B | BAND_G);
+		if (band_info == BAND_5GHZ)
+			net_mon->band |= BAND_A;
+		net_mon->chan_bandwidth =
+			GET_SECONDARYCHAN(pchan_band->bandcfg.chan2Offset);
+		if (band_info == BAND_2GHZ)
+			net_mon->band |= BAND_GN;
+		if (band_info == BAND_5GHZ)
+			net_mon->band |= BAND_AN;
+		if (band_info == BAND_2GHZ)
+			net_mon->band |= BAND_GAC;
+		if (band_info == BAND_5GHZ)
+			net_mon->band |= BAND_AAC;
+	}
+	pmpriv->adapter->enable_net_mon =
+		wlan_le16_to_cpu(cmd_net_mon->enable_net_mon);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function handles the command response of
  *  subscribe event
@@ -1665,6 +2255,42 @@ static mlan_status wlan_ret_otp_user_data(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function handles the command response of
+ *  fw auto re-connect
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to command buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_ret_fw_auto_reconnect(pmlan_private pmpriv,
+					      HostCmd_DS_COMMAND *resp,
+					      mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_FW_AUTO_RECONNECT *fw_auto_reconnect =
+		(HostCmd_DS_FW_AUTO_RECONNECT *)&resp->params
+			.fw_auto_reconnect_cmd;
+	mlan_ds_misc_cfg *misc = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf && (pioctl_buf->action == MLAN_ACT_GET)) {
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		misc->param.fw_auto_reconnect.fw_reconn_counter =
+			fw_auto_reconnect->reconnect_counter;
+		misc->param.fw_auto_reconnect.fw_reconn_interval =
+			fw_auto_reconnect->reconnect_interval;
+		misc->param.fw_auto_reconnect.fw_reconn_flags =
+			wlan_le16_to_cpu(fw_auto_reconnect->flags);
+		pioctl_buf->data_read_written = sizeof(mlan_ds_misc_cfg);
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 #ifdef USB
 /**
  *  @brief This function handles the command response of
@@ -1912,32 +2538,11 @@ static mlan_status wlan_ret_dfs_repeater_cfg(pmlan_private pmpriv,
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_ret_coalesce_config(pmlan_private pmpriv,
-				     HostCmd_DS_COMMAND *resp,
-				     mlan_ioctl_req *pioctl_buf)
-{
-	ENTER();
-	LEAVE();
-	return MLAN_STATUS_SUCCESS;
-}
-
-mlan_status wlan_ret_get_sensor_temp(pmlan_private pmpriv,
-				     const HostCmd_DS_COMMAND *resp,
-				     mlan_ioctl_req *pioctl_buf)
+static mlan_status wlan_ret_coalesce_config(pmlan_private pmpriv,
+					    HostCmd_DS_COMMAND *resp,
+					    mlan_ioctl_req *pioctl_buf)
 {
-	mlan_ds_misc_cfg *pcfg = MNULL;
-	const HostCmd_DS_SENSOR_TEMP *pSensorT = &resp->params.temp_sensor;
-
 	ENTER();
-
-	if (pioctl_buf) {
-		pcfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
-		pcfg->param.sensor_temp.temperature =
-			wlan_le32_to_cpu(pSensorT->temperature);
-		PRINTM(MCMND, "get SOC temperature %u C \n",
-		       pSensorT->temperature);
-	}
-
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
@@ -1969,6 +2574,40 @@ mlan_status wlan_ret_arb_cfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function handles the command response of ipv6 ra offload feature
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_ipv6_ra_offload(pmlan_private pmpriv,
+				     HostCmd_DS_COMMAND *resp,
+				     mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_IPV6_RA_OFFLOAD *ipv6_ra_resp =
+		&resp->params.ipv6_ra_offload;
+	mlan_ds_misc_cfg *misc = MNULL;
+	mlan_ds_misc_ipv6_ra_offload *ipv6_ra = MNULL;
+
+	ENTER();
+
+	if (pioctl_buf && (pioctl_buf->action == MLAN_ACT_GET)) {
+		misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		ipv6_ra = (mlan_ds_misc_ipv6_ra_offload *)&misc->param
+				  .ipv6_ra_offload;
+		ipv6_ra->enable = ipv6_ra_resp->enable;
+		memcpy_ext(pmpriv->adapter, ipv6_ra->ipv6_addr,
+			   ipv6_ra_resp->ipv6_addr_param.ipv6_addr, 16,
+			   sizeof(ipv6_ra->ipv6_addr));
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function handles the command response of sta get band and
  * channel
@@ -1993,20 +2632,22 @@ static mlan_status wlan_ret_sta_config(pmlan_private pmpriv,
 		if (pioctl_buf->req_id == MLAN_IOCTL_BSS) {
 			bss = (mlan_ds_bss *)pioctl_buf->pbuf;
 			if (bss->sub_command == MLAN_OID_BSS_CHAN_INFO) {
+				Band_Config_t *bandcfg =
+					&bss->param.sta_channel.bandcfg;
+
 				tlv_band_channel =
 					(MrvlIEtypes_channel_band_t *)
 						cmdrsp_sta_cfg->tlv_buffer;
-				bss->param.sta_channel.bandcfg =
-					tlv_band_channel->bandcfg;
+				*bandcfg = tlv_band_channel->bandcfg;
 				bss->param.sta_channel.channel =
 					tlv_band_channel->channel;
 				bss->param.sta_channel.is_11n_enabled =
 					IS_11N_ENABLED(pmpriv);
-				if (bss->param.sta_channel.bandcfg.chanWidth ==
-				    CHAN_BW_80MHZ)
+				if (bandcfg->chanWidth == CHAN_BW_80MHZ)
 					bss->param.sta_channel.center_chan =
 						wlan_get_center_freq_idx(
-							pmpriv, BAND_AAC,
+							pmpriv,
+							bandcfg->chanBand,
 							bss->param.sta_channel
 								.channel,
 							CHANNEL_BW_80MHZ);
@@ -2026,6 +2667,70 @@ static mlan_status wlan_ret_sta_config(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function clears PMK in fw for fw roaming
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_clear_fw_roaming_pmk(pmlan_private pmpriv)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_SUPPLICANT_PMK,
+			       HostCmd_ACT_GEN_REMOVE, 0, MNULL, MNULL);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function handles the command response of enable/disable roaming
+ * offload to fw
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_ret_roam_offload(pmlan_private pmpriv,
+					 HostCmd_DS_COMMAND *resp,
+					 mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_ROAM_OFFLOAD *cmdrsp_roam_offload =
+		(HostCmd_DS_ROAM_OFFLOAD *)&resp->params.roam_offload;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	MrvlIEtypesHeader_t *header = MNULL;
+	MrvlIEtypes_fw_roam_enable_t *roam_offload_enable = MNULL;
+
+	ENTER();
+
+	if (resp->result == HostCmd_RESULT_OK) {
+		header = (MrvlIEtypesHeader_t *)cmdrsp_roam_offload->tlv;
+		header->type = wlan_le16_to_cpu(header->type);
+		if (header->type == TLV_TYPE_ROAM) {
+			roam_offload_enable = (MrvlIEtypes_fw_roam_enable_t *)
+						      cmdrsp_roam_offload->tlv;
+			if ((t_u8)roam_offload_enable->roam_enable)
+				pmpriv->adapter->fw_roaming = MTRUE;
+			else {
+				pmpriv->adapter->fw_roaming = MFALSE;
+				if (MLAN_STATUS_SUCCESS !=
+				    wlan_clear_fw_roaming_pmk(pmpriv))
+					PRINTM(MERROR,
+					       "wlan_clear_fw_roaming_pmk failed\n");
+			}
+		}
+	}
+
+	LEAVE();
+	return status;
+}
+
 /**
  *  @brief This function handles the command response of set/get auto tx
  *
@@ -2049,6 +2754,8 @@ static mlan_status wlan_ret_auto_tx(pmlan_private pmpriv,
 	MrvlIEtypes_Cloud_Keep_Alive_t *keep_alive_tlv = MNULL;
 	MrvlIEtypes_Keep_Alive_Pkt_t *pkt_tlv = MNULL;
 	mlan_ds_misc_keep_alive *misc_keep_alive = MNULL;
+	MrvlIEtypes_Cloud_Keep_Alive_Rx_t *keep_alive_Rx_tlv = MNULL;
+	mlan_ds_misc_keep_alive_rx *misc_keep_alive_rx = MNULL;
 
 	ENTER();
 
@@ -2125,6 +2832,65 @@ static mlan_status wlan_ret_auto_tx(pmlan_private pmpriv,
 				}
 			}
 		}
+		if (header->type == TLV_TYPE_CLOUD_KEEP_ALIVE_ACK) {
+			keep_alive_Rx_tlv =
+				(MrvlIEtypes_Cloud_Keep_Alive_Rx_t *)
+					cmdrsp_auto_tx->tlv_buffer;
+			misc_keep_alive_rx = (mlan_ds_misc_keep_alive_rx *)&misc
+						     ->param.keep_alive_rx;
+			misc_keep_alive_rx->mkeep_alive_id =
+				keep_alive_Rx_tlv->keep_alive_id;
+			misc_keep_alive_rx->enable = keep_alive_Rx_tlv->enable;
+			if (((action == HostCmd_ACT_GEN_SET) ||
+			     (action == HostCmd_ACT_GEN_RESET)) &&
+			    !keep_alive_Rx_tlv->enable) {
+				len = len -
+				      sizeof(keep_alive_Rx_tlv->keep_alive_id) -
+				      sizeof(keep_alive_Rx_tlv->enable);
+				if (len > sizeof(MrvlIEtypesHeader_t)) {
+					header = (MrvlIEtypesHeader_t *)
+						keep_alive_Rx_tlv;
+					header->type =
+						wlan_le16_to_cpu(header->type);
+					len = wlan_le16_to_cpu(header->len) -
+					      sizeof(Eth803Hdr_t);
+					if (header->type ==
+					    TLV_TYPE_CLOUD_KEEP_ALIVE_ACK) {
+						memcpy_ext(
+							pmpriv->adapter,
+							misc_keep_alive_rx
+								->dst_mac,
+							keep_alive_Rx_tlv
+								->eth_header
+								.dest_addr,
+							MLAN_MAC_ADDR_LENGTH,
+							sizeof(misc_keep_alive_rx
+								       ->dst_mac));
+						memcpy_ext(
+							pmpriv->adapter,
+							misc_keep_alive_rx
+								->src_mac,
+							keep_alive_Rx_tlv
+								->eth_header
+								.src_addr,
+							MLAN_MAC_ADDR_LENGTH,
+							sizeof(misc_keep_alive
+								       ->src_mac));
+						memcpy_ext(
+							pmpriv->adapter,
+							misc_keep_alive_rx
+								->packet,
+							keep_alive_Rx_tlv
+								->ip_packet,
+							len,
+							sizeof(misc_keep_alive
+								       ->packet));
+						misc_keep_alive_rx->pkt_len =
+							len;
+					}
+				}
+			}
+		}
 	}
 
 	LEAVE();
@@ -2212,12 +2978,103 @@ static mlan_status wlan_ret_mfg_tx_frame(pmlan_private pmpriv,
 	cfg->tx_bf = wlan_le32_to_cpu(mcmd->tx_bf);
 	cfg->gf_mode = wlan_le32_to_cpu(mcmd->gf_mode);
 	cfg->stbc = wlan_le32_to_cpu(mcmd->stbc);
+	cfg->NumPkt = wlan_le32_to_cpu(mcmd->NumPkt);
+	cfg->MaxPE = wlan_le32_to_cpu(mcmd->MaxPE);
+	cfg->BeamChange = wlan_le32_to_cpu(mcmd->BeamChange);
+	cfg->Dcm = wlan_le32_to_cpu(mcmd->Dcm);
+	cfg->Doppler = wlan_le32_to_cpu(mcmd->Doppler);
+	cfg->MidP = wlan_le32_to_cpu(mcmd->MidP);
+	cfg->QNum = wlan_le32_to_cpu(mcmd->QNum);
 	memcpy_ext(pmpriv->adapter, cfg->bssid, mcmd->bssid,
 		   MLAN_MAC_ADDR_LENGTH, sizeof(cfg->bssid));
 
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
+/**
+ *  @brief This function prepares command resp of MFG config Trigger frame
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_ret_mfg_config_trigger_frame(pmlan_private pmpriv,
+						     HostCmd_DS_COMMAND *resp,
+						     mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *misc = MNULL;
+	mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *mcmd =
+		(mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *)&resp->params
+			.mfg_tx_trigger_config;
+	mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *cfg = MNULL;
+
+	ENTER();
+	if (!pioctl_buf) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+	misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+	cfg = (mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *)&misc->param
+		      .mfg_tx_trigger_config;
+
+	cfg->enable_tx = wlan_le32_to_cpu(mcmd->enable_tx);
+	cfg->standalone_hetb = wlan_le32_to_cpu(mcmd->standalone_hetb);
+	cfg->frmCtl.type = wlan_le16_to_cpu(mcmd->frmCtl.type);
+	cfg->frmCtl.sub_type = wlan_le16_to_cpu(mcmd->frmCtl.sub_type);
+	cfg->duration = wlan_le16_to_cpu(mcmd->duration);
+
+	cfg->trig_common_field = wlan_le64_to_cpu(mcmd->trig_common_field);
+
+	memcpy_ext(pmpriv->adapter, &cfg->trig_user_info_field,
+		   &mcmd->trig_user_info_field,
+		   sizeof(mcmd->trig_user_info_field),
+		   sizeof(cfg->trig_user_info_field));
+
+	cfg->basic_trig_user_info =
+		wlan_le16_to_cpu(mcmd->basic_trig_user_info);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function prepares command resp of MFG HE TB Tx
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+
+static mlan_status wlan_ret_mfg_he_tb_tx(pmlan_private pmpriv,
+					 HostCmd_DS_COMMAND *resp,
+					 mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *misc = MNULL;
+	struct mfg_Cmd_HE_TBTx_t *mcmd =
+		(struct mfg_Cmd_HE_TBTx_t *)&resp->params.mfg_he_power;
+	struct mfg_Cmd_HE_TBTx_t *cfg = MNULL;
+
+	ENTER();
+	if (!pioctl_buf) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+	misc = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+	cfg = (struct mfg_Cmd_HE_TBTx_t *)&misc->param.mfg_he_power;
+
+	cfg->enable = wlan_le16_to_cpu(mcmd->enable);
+	cfg->qnum = wlan_le16_to_cpu(mcmd->qnum);
+	cfg->aid = wlan_le16_to_cpu(mcmd->aid);
+	cfg->axq_mu_timer = wlan_le16_to_cpu(mcmd->axq_mu_timer);
+	cfg->tx_power = wlan_le16_to_cpu(mcmd->tx_power);
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
 
 /**
  *  @brief This function prepares command resp of MFG Cmd
@@ -2236,6 +3093,9 @@ mlan_status wlan_ret_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 		(struct mfg_cmd_generic_cfg *)&resp->params.mfg_generic_cfg;
 	struct mfg_cmd_generic_cfg *cfg = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+#ifdef SD9177
+	mlan_adapter *pmadapter = pmpriv->adapter;
+#endif
 
 	ENTER();
 	if (!pioctl_buf) {
@@ -2249,6 +3109,13 @@ mlan_status wlan_ret_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	case MFG_CMD_TX_FRAME:
 		ret = wlan_ret_mfg_tx_frame(pmpriv, resp, pioctl_buf);
 		goto cmd_mfg_done;
+	case MFG_CMD_CONFIG_MAC_HE_TB_TX:
+		ret = wlan_ret_mfg_he_tb_tx(pmpriv, resp, pioctl_buf);
+		goto cmd_mfg_done;
+	case MFG_CMD_CONFIG_TRIGGER_FRAME:
+		ret = wlan_ret_mfg_config_trigger_frame(pmpriv, resp,
+							pioctl_buf);
+		goto cmd_mfg_done;
 	case MFG_CMD_SET_TEST_MODE:
 	case MFG_CMD_UNSET_TEST_MODE:
 	case MFG_CMD_TX_ANT:
@@ -2257,6 +3124,7 @@ mlan_status wlan_ret_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	case MFG_CMD_CLR_RX_ERR:
 	case MFG_CMD_RF_BAND_AG:
 	case MFG_CMD_RF_CHANNELBW:
+	case MFG_CMD_RADIO_MODE_CFG:
 	case MFG_CMD_RFPWR:
 		break;
 	default:
@@ -2267,7 +3135,20 @@ mlan_status wlan_ret_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	cfg = (struct mfg_cmd_generic_cfg *)&misc->param.mfg_generic_cfg;
 
 	cfg->error = wlan_le32_to_cpu(mcmd->error);
-	cfg->data1 = wlan_le32_to_cpu(mcmd->data1);
+
+#ifdef SD9177
+	if (IS_SD9177(pmadapter->card_type) &&
+	    (wlan_le32_to_cpu(mcmd->mfg_cmd) == MFG_CMD_RFPWR)) {
+		//! TX_POWER was multipied by 16 while passing to fw
+		//! So It is needed to divide by 16 for user vals understanding.
+		cfg->data1 = (wlan_le32_to_cpu(mcmd->data1) >> 4);
+	} else {
+#endif
+		cfg->data1 = wlan_le32_to_cpu(mcmd->data1);
+#ifdef SD9177
+	}
+#endif
+
 	cfg->data2 = wlan_le32_to_cpu(mcmd->data2);
 	cfg->data3 = wlan_le32_to_cpu(mcmd->data3);
 cmd_mfg_done:
@@ -2275,6 +3156,39 @@ mlan_status wlan_ret_mfg(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
 	return ret;
 }
 
+/**
+ *  @brief This function handles the command response of TWT_REPORT
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to command buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+mlan_status wlan_ret_twt_report(pmlan_private pmpriv, HostCmd_DS_COMMAND *resp,
+				mlan_ioctl_req *pioctl_buf)
+{
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+	HostCmd_DS_TWT_CFG *twt_recfg = &resp->params.twtcfg;
+
+	ENTER();
+
+	if ((wlan_le16_to_cpu(twt_recfg->action) == HostCmd_ACT_GEN_GET) &&
+	    (wlan_le16_to_cpu(twt_recfg->sub_id) ==
+	     MLAN_11AX_TWT_REPORT_SUBID)) {
+		if (pioctl_buf) {
+			misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+			memcpy_ext(pmpriv->adapter,
+				   &misc_cfg->param.twt_report_info,
+				   &resp->params.twtcfg.param.twt_report,
+				   sizeof(mlan_ds_twt_report),
+				   sizeof(mlan_ds_twt_report));
+		}
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /**
  *  @brief This function handles the station command response
  *
@@ -2383,6 +3297,15 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		       resp->params.ssu_params.rec_len);
 		break;
 #endif
+	case HostCmd_CMD_CSI:
+		if (resp->params.csi_params.action == CSI_CMD_ENABLE) {
+			pmadapter->csi_enabled = 1;
+			PRINTM(MCMND, "CSI ENABLE cmdresp\n");
+		} else {
+			pmadapter->csi_enabled = 0;
+			PRINTM(MCMND, "CSI DISABLE cmdresp\n");
+		}
+		break;
 	case HostCmd_CMD_802_11_ASSOCIATE:
 		ret = wlan_ret_802_11_associate(pmpriv, resp, pioctl_buf);
 		break;
@@ -2403,6 +3326,14 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_802_11_LINK_STATS:
 		ret = wlan_ret_get_link_statistic(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS:
+		ret = wlan_ret_802_11_ftm_config_session_params(pmpriv, resp,
+								pioctl_buf);
+		break;
+	case HostCmd_CMD_FTM_CONFIG_RESPONDER:
+		ret = wlan_ret_802_11_ftm_config_responder(pmpriv, resp,
+							   pioctl_buf);
+		break;
 	case HostCmd_CMD_RSSI_INFO_EXT:
 		ret = wlan_ret_802_11_rssi_info_ext(pmpriv, resp, pioctl_buf);
 		break;
@@ -2470,6 +3401,10 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		break;
 	case HostCmd_CMD_RECONFIGURE_TX_BUFF:
 		wlan_set_tx_pause_flag(pmpriv, MFALSE);
+#if defined(USB)
+		if (IS_USB(pmadapter->card_type))
+			wlan_resync_usb_port(pmadapter);
+#endif
 
 		pmadapter->tx_buf_size =
 			(t_u16)wlan_le16_to_cpu(resp->params.tx_buf.buff_size);
@@ -2484,15 +3419,18 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 				pmadapter->pcard_sd->reg->data_port_mask;
 
 			for (ctr = 1;
-			     ctr <= MAX_PORT - pmadapter->pcard_sd->mp_end_port;
+			     ctr <= pmadapter->pcard_sd->max_ports -
+					    pmadapter->pcard_sd->mp_end_port;
 			     ctr++) {
 				pmadapter->pcard_sd->mp_data_port_mask &=
-					~(1 << (MAX_PORT - ctr));
+					~(1 << (pmadapter->pcard_sd->max_ports -
+						ctr));
 			}
 
-			pmadapter->pcard_sd->curr_wr_port = 0;
+			pmadapter->pcard_sd->curr_wr_port =
+				pmadapter->pcard_sd->reg->start_wr_port;
 			pmadapter->pcard_sd->mpa_tx.pkt_aggr_limit =
-				MIN(SDIO_MP_AGGR_DEF_PKT_LIMIT,
+				MIN(pmadapter->pcard_sd->mp_aggr_pkt_limit,
 				    (pmadapter->pcard_sd->mp_end_port >> 1));
 			PRINTM(MCMND, "end port %d, data port mask %x\n",
 			       wlan_le16_to_cpu(
@@ -2536,6 +3474,12 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_MGMT_IE_LIST:
 		ret = wlan_ret_mgmt_ie_list(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_TDLS_CONFIG:
+		ret = wlan_ret_tdls_config(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_TDLS_OPERATION:
+		ret = wlan_ret_tdls_oper(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_11N_CFG:
 		ret = wlan_ret_11n_cfg(pmpriv, resp, pioctl_buf);
 		break;
@@ -2561,6 +3505,7 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_TARGET_ACCESS:
 	case HostCmd_CMD_802_11_EEPROM_ACCESS:
 	case HostCmd_CMD_BCA_REG_ACCESS:
+	case HostCmd_CMD_REG_ACCESS:
 		ret = wlan_ret_reg_access(pmpriv->adapter, cmdresp_no, resp,
 					  pioctl_buf);
 		break;
@@ -2580,6 +3525,9 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_MEASUREMENT_REPORT:
 		ret = wlan_meas_cmdresp_process(pmpriv, resp);
 		break;
+	case HostCmd_CMD_802_11_NET_MONITOR:
+		ret = wlan_ret_net_monitor(pmpriv, resp, pioctl_buf);
+		break;
 #if defined(PCIE)
 #if defined(PCIE8997) || defined(PCIE8897)
 	case HostCmd_CMD_PCIE_HOST_BUF_DETAILS:
@@ -2601,6 +3549,9 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_OTP_READ_USER_DATA:
 		ret = wlan_ret_otp_user_data(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_FW_AUTO_RECONNECT:
+		ret = wlan_ret_fw_auto_reconnect(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_HS_WAKEUP_REASON:
 		ret = wlan_ret_hs_wakeup_reason(pmpriv, resp, pioctl_buf);
 		break;
@@ -2616,11 +3567,15 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 							       pioctl_buf);
 		break;
 #endif
-#ifdef RX_PACKET_COALESCE
-	case HostCmd_CMD_RX_PKT_COALESCE_CFG:
-		ret = wlan_ret_rx_pkt_coalesce_cfg(pmpriv, resp, pioctl_buf);
+	case HostCmd_CMD_MULTI_CHAN_CONFIG:
+		ret = wlan_ret_multi_chan_cfg(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_MULTI_CHAN_POLICY:
+		ret = wlan_ret_multi_chan_policy(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_DRCS_CONFIG:
+		ret = wlan_ret_drcs_cfg(pmpriv, resp, pioctl_buf);
 		break;
-#endif
 	case HostCMD_CONFIG_LOW_POWER_MODE:
 		break;
 	case HostCmd_DFS_REPEATER_MODE:
@@ -2636,6 +3591,9 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		break;
 	case HostCmd_CMD_802_11_MIMO_SWITCH:
 		break;
+	case HostCmd_CMD_IPV6_RA_OFFLOAD_CFG:
+		ret = wlan_ret_ipv6_ra_offload(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_STA_CONFIGURE:
 		ret = wlan_ret_sta_config(pmpriv, resp, pioctl_buf);
 		break;
@@ -2646,6 +3604,9 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		break;
 	case HostCmd_CMD_802_11_PS_INACTIVITY_TIMEOUT:
 		break;
+	case HostCmd_CMD_ROAM_OFFLOAD:
+		ret = wlan_ret_roam_offload(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_GET_TSF:
 		ret = wlan_ret_get_tsf(pmpriv, resp, pioctl_buf);
 		break;
@@ -2679,10 +3640,17 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		ret = wlan_ret_range_ext(pmpriv, resp, pioctl_buf);
 		break;
 	case HostCmd_CMD_TWT_CFG:
+		ret = wlan_ret_twt_report(pmpriv, resp, pioctl_buf);
+		break;
+	case HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG:
+		ret = wlan_ret_gpio_tsf_latch(pmpriv, resp, pioctl_buf);
 		break;
 	case HostCmd_CMD_RX_ABORT_CFG:
 		ret = wlan_ret_rxabortcfg(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_OFDM_DESENSE_CFG:
+		ret = wlan_ret_ofdmdesense_cfg(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_RX_ABORT_CFG_EXT:
 		ret = wlan_ret_rxabortcfg_ext(pmpriv, resp, pioctl_buf);
 		break;
@@ -2696,6 +3664,12 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		ret = wlan_ret_dot11mc_unassoc_ftm_cfg(pmpriv, resp,
 						       pioctl_buf);
 		break;
+	case HostCmd_CMD_HAL_PHY_CFG:
+		ret = wlan_ret_hal_phy_cfg(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_IPS_CONFIG:
+		ret = wlan_ret_ips_cfg(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_RATE_ADAPT_CFG:
 		ret = wlan_ret_rate_adapt_cfg(pmpriv, resp, pioctl_buf);
 		break;
@@ -2712,6 +3686,15 @@ mlan_status wlan_ops_sta_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_MFG_COMMAND:
 		ret = wlan_ret_mfg(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_MC_AGGR_CFG:
+		ret = wlan_ret_mc_aggr_cfg(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_GET_CH_LOAD:
+		ret = wlan_ret_ch_load(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_CROSS_CHIP_SYNCH:
+		ret = wlan_ret_cross_chip_synch(pmpriv, resp, pioctl_buf);
+		break;
 	default:
 		PRINTM(MERROR, "CMD_RESP: Unknown command response %#x\n",
 		       resp->command);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_event.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_event.c
old mode 100644
new mode 100755
index 852f5d395..2bc5517ce
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_event.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_event.c
@@ -3,7 +3,7 @@
  *  @brief This file contains MLAN event handling.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -65,6 +65,278 @@ static t_void wlan_handle_disconnect_event(pmlan_private pmpriv)
 	LEAVE();
 }
 
+/**
+ *  @brief This function will parse the TDLS event for further wlan action
+ *
+ *  @param priv     A pointer to mlan_private
+ *  @param pevent   A pointer to event buf
+ *
+ *  @return         N/A
+ */
+static void wlan_parse_tdls_event(pmlan_private priv, pmlan_buffer pevent)
+{
+	Event_tdls_generic *tdls_event =
+		(Event_tdls_generic *)(pevent->pbuf + pevent->data_offset +
+				       sizeof(mlan_event_id));
+	sta_node *sta_ptr = MNULL;
+	pmlan_adapter pmadapter = priv->adapter;
+	t_u8 i = 0;
+	IEEEtypes_HTCap_t *pht_cap = MNULL;
+	t_u16 ie_len = 0;
+	mlan_ds_misc_tdls_oper tdls_oper;
+	t_u8 event_buf[100];
+	mlan_event *ptdls_event = (mlan_event *)event_buf;
+	tdls_tear_down_event *tdls_evt =
+		(tdls_tear_down_event *)ptdls_event->event_buf;
+	ENTER();
+
+	/* reason code is not mandatory, hence less by sizeof(t_u16) */
+	if (pevent->data_len < (sizeof(Event_tdls_generic) - sizeof(t_u16) -
+				sizeof(mlan_event_id))) {
+		PRINTM(MERROR, "Invalid length %d for TDLS event\n",
+		       pevent->data_len);
+		LEAVE();
+		return;
+	}
+	sta_ptr = wlan_get_station_entry(priv, tdls_event->peer_mac_addr);
+	PRINTM(MEVENT, "TDLS_EVENT: %d " MACSTR "\n",
+	       wlan_le16_to_cpu(tdls_event->event_type),
+	       MAC2STR(tdls_event->peer_mac_addr));
+	switch (wlan_le16_to_cpu(tdls_event->event_type)) {
+	case TDLS_EVENT_TYPE_SETUP_REQ:
+		if (sta_ptr == MNULL) {
+			sta_ptr = wlan_add_station_entry(
+				priv, tdls_event->peer_mac_addr);
+			if (sta_ptr) {
+				sta_ptr->status = TDLS_SETUP_INPROGRESS;
+				wlan_hold_tdls_packets(
+					priv, tdls_event->peer_mac_addr);
+			}
+		}
+		break;
+
+	case TDLS_EVENT_TYPE_LINK_ESTABLISHED:
+		if (sta_ptr) {
+			sta_ptr->status = TDLS_SETUP_COMPLETE;
+			/* parse the TLV for station's capability */
+			ie_len = wlan_le16_to_cpu(
+				tdls_event->u.ie_data.ie_length);
+			if (ie_len) {
+				pht_cap = (IEEEtypes_HTCap_t *)
+					wlan_get_specific_ie(
+						priv,
+						tdls_event->u.ie_data.ie_ptr,
+						ie_len, HT_CAPABILITY, 0);
+				if (pht_cap) {
+					sta_ptr->is_11n_enabled = MTRUE;
+					if (GETHT_MAXAMSDU(
+						    pht_cap->ht_cap.ht_cap_info))
+						sta_ptr->max_amsdu =
+							MLAN_TX_DATA_BUF_SIZE_8K;
+					else
+						sta_ptr->max_amsdu =
+							MLAN_TX_DATA_BUF_SIZE_4K;
+				}
+			}
+			for (i = 0; i < MAX_NUM_TID; i++) {
+				if (sta_ptr->is_11n_enabled ||
+				    sta_ptr->is_11ax_enabled)
+					sta_ptr->ampdu_sta[i] =
+						priv->aggr_prio_tbl[i]
+							.ampdu_user;
+				else
+					sta_ptr->ampdu_sta[i] =
+						BA_STREAM_NOT_ALLOWED;
+			}
+			memset(priv->adapter, sta_ptr->rx_seq, 0xff,
+			       sizeof(sta_ptr->rx_seq));
+			wlan_restore_tdls_packets(priv,
+						  tdls_event->peer_mac_addr,
+						  TDLS_SETUP_COMPLETE);
+			pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+		}
+		break;
+
+	case TDLS_EVENT_TYPE_SETUP_FAILURE:
+		wlan_restore_tdls_packets(priv, tdls_event->peer_mac_addr,
+					  TDLS_SETUP_FAILURE);
+		if (sta_ptr)
+			wlan_delete_station_entry(priv,
+						  tdls_event->peer_mac_addr);
+		if (MTRUE == wlan_is_station_list_empty(priv))
+			pmadapter->tdls_status = TDLS_NOT_SETUP;
+		else
+			pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+		break;
+	case TDLS_EVENT_TYPE_LINK_TORN_DOWN:
+		if (sta_ptr) {
+			if (sta_ptr->external_tdls) {
+				mlan_status ret = MLAN_STATUS_SUCCESS;
+				PRINTM(MMSG,
+				       "Receive TDLS TEAR DOWN event, Disable TDLS LINK\n");
+				pmadapter->tdls_status = TDLS_TEAR_DOWN;
+				memset(pmadapter, &tdls_oper, 0,
+				       sizeof(tdls_oper));
+				tdls_oper.tdls_action = WLAN_TDLS_DISABLE_LINK;
+				memcpy_ext(priv->adapter, tdls_oper.peer_mac,
+					   tdls_event->peer_mac_addr,
+					   MLAN_MAC_ADDR_LENGTH,
+					   MLAN_MAC_ADDR_LENGTH);
+				/* Send command to firmware to delete tdls
+				 * link*/
+				ret = wlan_prepare_cmd(
+					priv, HostCmd_CMD_TDLS_OPERATION,
+					HostCmd_ACT_GEN_SET, 0, (t_void *)MNULL,
+					&tdls_oper);
+				if (ret)
+					PRINTM(MERROR,
+					       "11D: failed to send cmd to FW\n");
+				ptdls_event->bss_index = priv->bss_index;
+				ptdls_event->event_id =
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ;
+				ptdls_event->event_len =
+					sizeof(tdls_tear_down_event);
+				memcpy_ext(priv->adapter,
+					   (t_u8 *)tdls_evt->peer_mac_addr,
+					   tdls_event->peer_mac_addr,
+					   MLAN_MAC_ADDR_LENGTH,
+					   MLAN_MAC_ADDR_LENGTH);
+				tdls_evt->reason_code = wlan_le16_to_cpu(
+					tdls_event->u.reason_code);
+				wlan_recv_event(
+					priv,
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ,
+					ptdls_event);
+				/* Signal MOAL to trigger mlan_main_process */
+				wlan_recv_event(
+					priv, MLAN_EVENT_ID_DRV_DEFER_HANDLING,
+					MNULL);
+				LEAVE();
+				return;
+			}
+			wlan_restore_tdls_packets(priv,
+						  tdls_event->peer_mac_addr,
+						  TDLS_TEAR_DOWN);
+			if (sta_ptr->is_11n_enabled ||
+			    sta_ptr->is_11ax_enabled) {
+				wlan_cleanup_reorder_tbl(
+					priv, tdls_event->peer_mac_addr);
+				wlan_11n_cleanup_txbastream_tbl(
+					priv, tdls_event->peer_mac_addr);
+			}
+			wlan_delete_station_entry(priv,
+						  tdls_event->peer_mac_addr);
+			if (MTRUE == wlan_is_station_list_empty(priv))
+				pmadapter->tdls_status = TDLS_NOT_SETUP;
+			else
+				pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+		}
+		break;
+	case TDLS_EVENT_TYPE_CHAN_SWITCH_RESULT:
+		PRINTM(MEVENT,
+		       "TDLS_CHAN_SWITCH_RESULT: status=0x%x, reason=0x%x current_channel=%d\n",
+		       tdls_event->u.switch_result.status,
+		       tdls_event->u.switch_result.reason,
+		       (int)tdls_event->u.switch_result.current_channel);
+		if (tdls_event->u.switch_result.status == MLAN_STATUS_SUCCESS) {
+			if (tdls_event->u.switch_result.current_channel ==
+			    TDLS_BASE_CHANNEL) {
+				/* enable traffic to AP */
+				if (pmadapter->tdls_status !=
+				    TDLS_IN_BASE_CHANNEL) {
+					wlan_update_non_tdls_ralist(
+						priv, tdls_event->peer_mac_addr,
+						MFALSE);
+					pmadapter->tdls_status =
+						TDLS_IN_BASE_CHANNEL;
+				}
+			} else if (tdls_event->u.switch_result.current_channel ==
+				   TDLS_OFF_CHANNEL) {
+				/* pause traffic to AP */
+				if (pmadapter->tdls_status !=
+				    TDLS_IN_OFF_CHANNEL) {
+					wlan_update_non_tdls_ralist(
+						priv, tdls_event->peer_mac_addr,
+						MTRUE);
+					pmadapter->tdls_status =
+						TDLS_IN_OFF_CHANNEL;
+				}
+			}
+		} else {
+			if (tdls_event->u.switch_result.current_channel ==
+			    TDLS_BASE_CHANNEL)
+				pmadapter->tdls_status = TDLS_IN_BASE_CHANNEL;
+			else if (tdls_event->u.switch_result.current_channel ==
+				 TDLS_OFF_CHANNEL)
+				pmadapter->tdls_status = TDLS_IN_OFF_CHANNEL;
+		}
+		break;
+	case TDLS_EVENT_TYPE_START_CHAN_SWITCH:
+		PRINTM(MEVENT, "TDLS start channel switch....\n");
+		pmadapter->tdls_status = TDLS_SWITCHING_CHANNEL;
+		break;
+	case TDLS_EVENT_TYPE_CHAN_SWITCH_STOPPED:
+		PRINTM(MEVENT, "TDLS channel switch stopped, reason=%d\n",
+		       tdls_event->u.cs_stop_reason);
+		break;
+	case TDLS_EVENT_TYPE_DEBUG:
+	case TDLS_EVENT_TYPE_PACKET:
+		break;
+	default:
+		PRINTM(MERROR, "unknown event type %d\n",
+		       wlan_le16_to_cpu(tdls_event->event_type));
+		break;
+	}
+	LEAVE();
+}
+
+/**
+ *  @brief This function send the tdls teardown request event.
+ *
+ *  @param priv    A pointer to mlan_private
+ *
+ *  @return        N/A
+ */
+static void wlan_send_tdls_tear_down_request(pmlan_private priv)
+{
+	t_u8 event_buf[100];
+	mlan_event *ptdls_event = (mlan_event *)event_buf;
+	tdls_tear_down_event *tdls_evt =
+		(tdls_tear_down_event *)ptdls_event->event_buf;
+	sta_node *sta_ptr = MNULL;
+
+	ENTER();
+
+	sta_ptr = (sta_node *)util_peek_list(
+		priv->adapter->pmoal_handle, &priv->sta_list,
+		priv->adapter->callbacks.moal_spin_lock,
+		priv->adapter->callbacks.moal_spin_unlock);
+	if (!sta_ptr) {
+		LEAVE();
+		return;
+	}
+	while (sta_ptr != (sta_node *)&priv->sta_list) {
+		if (sta_ptr->external_tdls) {
+			ptdls_event->bss_index = priv->bss_index;
+			ptdls_event->event_id =
+				MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ;
+			ptdls_event->event_len = sizeof(tdls_tear_down_event);
+			memcpy_ext(priv->adapter,
+				   (t_u8 *)tdls_evt->peer_mac_addr,
+				   sta_ptr->mac_addr, MLAN_MAC_ADDR_LENGTH,
+				   MLAN_MAC_ADDR_LENGTH);
+			tdls_evt->reason_code =
+				MLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;
+			wlan_recv_event(priv,
+					MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ,
+					ptdls_event);
+		}
+		sta_ptr = sta_ptr->pnext;
+	}
+	LEAVE();
+	return;
+}
+
 /********************************************************
 			Global Functions
 ********************************************************/
@@ -102,7 +374,12 @@ t_void wlan_reset_connect_state(pmlan_private priv, t_u8 drv_disconnect)
 	if (drv_disconnect) {
 		priv->media_connected = MFALSE;
 		pmadapter->state_rdh.tx_block = MFALSE;
-		wlan_11h_check_update_radar_det_state(priv);
+#ifdef UAP_SUPPORT
+		if (pmadapter->dfs_mode)
+			wlan_11h_update_dfs_master_state_on_disconect(priv);
+		else
+#endif
+			wlan_11h_check_update_radar_det_state(priv);
 	}
 
 	if (priv->port_ctrl_mode == MTRUE) {
@@ -128,6 +405,7 @@ t_void wlan_reset_connect_state(pmlan_private priv, t_u8 drv_disconnect)
 	priv->rxpd_rate_info = 0;
 	priv->max_amsdu = 0;
 	priv->amsdu_disable = MFALSE;
+	priv->multi_ap_flag = 0;
 	wlan_coex_ampdu_rxwinsize(pmadapter);
 
 	priv->sec_info.ewpa_enabled = MFALSE;
@@ -170,11 +448,14 @@ t_void wlan_reset_connect_state(pmlan_private priv, t_u8 drv_disconnect)
 		memset(pmadapter, &priv->curr_bss_params, 0x00,
 		       sizeof(priv->curr_bss_params));
 	}
+	wlan_send_tdls_tear_down_request(priv);
+	wlan_delete_station_list(priv);
+	pmadapter->tdls_status = TDLS_NOT_SETUP;
+	priv->wmm_qosinfo = priv->saved_wmm_qosinfo;
+	pmadapter->sleep_period.period = pmadapter->saved_sleep_period.period;
 	pmadapter->tx_lock_flag = MFALSE;
 	pmadapter->pps_uapsd_mode = MFALSE;
 	pmadapter->delay_null_pkt = MFALSE;
-	if (priv->bss_type == MLAN_BSS_TYPE_STA)
-		pmadapter->hs_wake_interval = 0;
 
 	if ((wlan_fw_11d_is_enabled(priv)) &&
 	    (priv->state_11d.user_enable_11d == DISABLE_11D)) {
@@ -258,6 +539,8 @@ static void wlan_process_sta_tx_pause_event(pmlan_private priv,
 		(MrvlIEtypesHeader_t *)(pevent->pbuf + pevent->data_offset +
 					sizeof(t_u32));
 	MrvlIEtypes_tx_pause_t *tx_pause_tlv;
+	sta_node *sta_ptr = MNULL;
+	tdlsStatus_e status;
 	t_u8 *bssid = MNULL;
 	ENTER();
 	if (priv->media_connected)
@@ -284,6 +567,27 @@ static void wlan_process_sta_tx_pause_event(pmlan_private priv,
 					priv->tx_pause = MTRUE;
 				else
 					priv->tx_pause = MFALSE;
+			} else {
+				status = wlan_get_tdls_link_status(
+					priv, tx_pause_tlv->peermac);
+				if (MTRUE == wlan_is_tdls_link_setup(status)) {
+					sta_ptr = wlan_get_station_entry(
+						priv, tx_pause_tlv->peermac);
+					if (sta_ptr) {
+						if (sta_ptr->tx_pause !=
+						    tx_pause_tlv->tx_pause) {
+							sta_ptr->tx_pause =
+								tx_pause_tlv
+									->tx_pause;
+							wlan_update_ralist_tx_pause(
+								priv,
+								tx_pause_tlv
+									->peermac,
+								tx_pause_tlv
+									->tx_pause);
+						}
+					}
+				}
 			}
 		}
 		tlv_buf_left -= (sizeof(MrvlIEtypesHeader_t) + tlv_len);
@@ -370,8 +674,11 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 	t_u16 reason_code;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 	mlan_event *pevent = MNULL;
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	Event_WLS_FTM_t *event_ftm = MNULL;
 	chan_band_info *pchan_band_info = MNULL;
 	t_u8 radar_chan;
+	t_u8 bandwidth;
 	t_u16 enable = 0;
 
 	ENTER();
@@ -466,8 +773,10 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 
 	case EVENT_PS_SLEEP:
 		PRINTM(MINFO, "EVENT: SLEEP\n");
-		PRINTM_NETINTF(MEVENT, pmpriv);
-		PRINTM(MEVENT, "_");
+		if (pmadapter->second_mac)
+			PRINTM(MEVENT, "__");
+		else
+			PRINTM(MEVENT, "_");
 
 		/* Handle unexpected PS SLEEP event */
 		if (pmadapter->ps_state == PS_STATE_SLEEP_CFM)
@@ -479,8 +788,10 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 
 	case EVENT_PS_AWAKE:
 		PRINTM(MINFO, "EVENT: AWAKE\n");
-		PRINTM_NETINTF(MEVENT, pmpriv);
-		PRINTM(MEVENT, "|");
+		if (pmadapter->second_mac)
+			PRINTM(MEVENT, "||");
+		else
+			PRINTM(MEVENT, "|");
 		if (!pmadapter->pps_uapsd_mode && pmpriv->media_connected &&
 		    (pmpriv->port_open || !pmpriv->port_ctrl_mode) &&
 		    pmadapter->sleep_period.period) {
@@ -494,14 +805,19 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		if (pmadapter->pps_uapsd_mode && pmadapter->gen_null_pkt) {
 			if (MTRUE ==
 			    wlan_check_last_packet_indication(pmpriv)) {
-				if (!pmadapter->data_sent) {
+				if (!pmadapter->data_sent
+#if defined(USB)
+				    && wlan_is_port_ready(pmadapter,
+							  pmpriv->port_index)
+#endif
+				) {
 					if (wlan_send_null_packet(
 						    pmpriv,
 						    MRVDRV_TxPD_POWER_MGMT_NULL_PACKET |
 							    MRVDRV_TxPD_POWER_MGMT_LAST_PACKET) ==
 					    MLAN_STATUS_SUCCESS) {
-						LEAVE();
-						return MLAN_STATUS_SUCCESS;
+						ret = MLAN_STATUS_SUCCESS;
+						goto done;
 					}
 				}
 			}
@@ -536,6 +852,14 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_FW_ADHOC_LINK_LOST,
 				MNULL);
 		break;
+	case EVENT_ASSOC_REQ_IE:
+		pmpriv->assoc_req_size = pmbuf->data_len - sizeof(eventcause);
+		evt_buf =
+			(pmbuf->pbuf + pmbuf->data_offset + sizeof(eventcause));
+		memcpy_ext(pmpriv->adapter, pmpriv->assoc_req_buf, evt_buf,
+			   pmbuf->data_len - sizeof(eventcause),
+			   MRVDRV_ASSOC_RSP_BUF_SIZE);
+		break;
 
 	case EVENT_FW_DEBUG_INFO:
 		pevent->bss_index = pmpriv->bss_index;
@@ -570,6 +894,8 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		}
 		pmadapter->scan_block = MFALSE;
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_FW_PORT_RELEASE, MNULL);
+		/* Send OBSS scan param to the application */
+		wlan_2040_coex_event(pmpriv);
 		break;
 
 	case EVENT_STOP_TX:
@@ -609,6 +935,10 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 					cfp->freq;
 			else
 				pmpriv->curr_bss_params.bss_descriptor.freq = 0;
+#ifdef UAP_SUPPORT
+			if (pmpriv->adapter->dfs_mode)
+				wlan_11h_update_dfs_master_state_by_sta(pmpriv);
+#endif
 			if (pmpriv->adapter->state_rdh.stage ==
 			    RDH_SET_CUSTOM_IE) {
 				pmadapter->state_rdh.stage =
@@ -630,11 +960,10 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 				   sizeof(pchan_band_info->bandcfg));
 			pchan_band_info->channel = pchan_info->channel;
 			if (pchan_band_info->bandcfg.chanWidth == CHAN_BW_80MHZ)
-				pchan_band_info->center_chan =
-					wlan_get_center_freq_idx(
-						priv, BAND_AAC,
-						pchan_info->channel,
-						CHANNEL_BW_80MHZ);
+				pchan_band_info
+					->center_chan = wlan_get_center_freq_idx(
+					priv, pchan_band_info->bandcfg.chanBand,
+					pchan_info->channel, CHANNEL_BW_80MHZ);
 			wlan_recv_event(pmpriv,
 					MLAN_EVENT_ID_FW_CHAN_SWITCH_COMPLETE,
 					pevent);
@@ -683,8 +1012,8 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 				   sizeof(eventcause),
 			   pevent->event_len, pevent->event_len);
 		/* Handle / pass event data */
-		ret = wlan_11h_handle_event_chanrpt_ready(pmpriv, pevent,
-							  &radar_chan);
+		ret = wlan_11h_handle_event_chanrpt_ready(
+			pmpriv, pevent, &radar_chan, &bandwidth);
 		/* Also send this event as passthru */
 		pevent->event_id = MLAN_EVENT_ID_DRV_PASSTHRU;
 		pevent->event_len = pmbuf->data_len;
@@ -711,7 +1040,7 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		PRINTM(MEVENT, "EVENT: Measurement Report Ready (%#x)\n",
 		       eventcause);
 		ret = wlan_prepare_cmd(priv, HostCmd_CMD_MEASUREMENT_REPORT,
-				       HostCmd_ACT_GEN_SET, 0, 0, MNULL);
+				       HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
 		break;
 	case EVENT_WMM_STATUS_CHANGE:
 		if (pmbuf &&
@@ -908,6 +1237,17 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_FW_REMAIN_ON_CHAN_EXPIRED,
 				MNULL);
 		break;
+	case EVENT_TDLS_GENERIC_EVENT:
+		PRINTM(MEVENT, "EVENT: TDLS event %d\n", eventcause);
+		wlan_parse_tdls_event(pmpriv, pmbuf);
+		pevent->bss_index = pmpriv->bss_index;
+		pevent->event_id = MLAN_EVENT_ID_DRV_PASSTHRU;
+		pevent->event_len = pmbuf->data_len;
+		memcpy_ext(pmadapter, (t_u8 *)pevent->event_buf,
+			   pmbuf->pbuf + pmbuf->data_offset, pevent->event_len,
+			   pevent->event_len);
+		wlan_recv_event(pmpriv, pevent->event_id, pevent);
+		break;
 
 	case EVENT_TX_DATA_PAUSE:
 		PRINTM(MEVENT, "EVENT: TX_DATA_PAUSE\n");
@@ -928,6 +1268,10 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		       eventcause, pevt_dat[0] + 1, pevt_dat[1] + 1,
 		       pevt_dat[2], pevt_dat[3]);
 	} break;
+	case EVENT_MULTI_CHAN_INFO:
+		PRINTM(MEVENT, "EVENT: MULTI_CHAN_INFO\n");
+		wlan_handle_event_multi_chan_info(pmpriv, pmbuf);
+		break;
 
 	case EVENT_FW_DUMP_INFO:
 		PRINTM(MINFO, "EVENT: Dump FW info\n");
@@ -981,12 +1325,16 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		pevent->bss_index = pmpriv->bss_index;
 		pevent->event_id = MLAN_EVENT_ID_SSU_DUMP_FILE;
 		pevent->event_len = MLAN_SSU_BUF_SIZE;
-		*(t_u64 *)pevent->event_buf = (t_u64)pmadapter->ssu_buf->pbuf +
+		*(t_ptr *)pevent->event_buf = (t_ptr)pmadapter->ssu_buf->pbuf +
 					      pmadapter->ssu_buf->data_offset;
 		wlan_recv_event(pmpriv, pevent->event_id, pevent);
 		wlan_free_ssu_pcie_buf(pmadapter);
 		break;
 #endif
+	case EVENT_CSI:
+		PRINTM(MEVENT, "EVENT: EVENT_CSI on STA\n");
+		wlan_process_csi_event(pmpriv);
+		break;
 	case EVENT_MEF_HOST_WAKEUP:
 		PRINTM(MEVENT, "EVENT: EVENT_MEF_HOST_WAKEUP len=%d\n",
 		       pmbuf->data_len);
@@ -994,8 +1342,66 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 	case EVENT_MANAGEMENT_FRAME_WAKEUP:
 		PRINTM(MEVENT, "EVENT: EVENT_MANAGEMENT_FRAME_WAKEUP HOST\n");
 		break;
+	case EVENT_ROAM_OFFLOAD:
+		memcpy_ext(pmadapter, addr,
+			   pmpriv->curr_bss_params.bss_descriptor.mac_address,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		memcpy_ext(pmadapter,
+			   pmpriv->curr_bss_params.bss_descriptor.mac_address,
+			   (t_u8 *)(pmadapter->event_body + 2),
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		/** replace ralist's mac address with new mac address */
+		if (0 ==
+		    wlan_ralist_update(
+			    pmpriv, addr,
+			    pmpriv->curr_bss_params.bss_descriptor.mac_address))
+			wlan_ralist_add(pmpriv,
+					pmpriv->curr_bss_params.bss_descriptor
+						.mac_address);
+		wlan_11n_cleanup_reorder_tbl(pmpriv);
+		wlan_11n_deleteall_txbastream_tbl(pmpriv);
+		/*Update the BSS for inform kernel, otherwise kernel will give
+		 * warning for not find BSS*/
+		memcpy_ext(pmadapter, (t_u8 *)&pmadapter->pscan_table[0],
+			   (t_u8 *)&pmpriv->curr_bss_params.bss_descriptor,
+			   sizeof(BSSDescriptor_t), sizeof(BSSDescriptor_t));
+		if (!pmadapter->num_in_scan_table)
+			pmadapter->num_in_scan_table = 1;
+		PRINTM(MEVENT, "EVENT: ROAM OFFLOAD IN FW SUCCESS\n");
+		pevent->bss_index = pmpriv->bss_index;
+		pevent->event_id = MLAN_EVENT_ID_FW_ROAM_OFFLOAD_RESULT;
+		/** Drop event id length and 2 bytes reverved length*/
+		if ((pmbuf->data_len - sizeof(eventcause)) > 2) {
+			pevent->event_len =
+				pmbuf->data_len - sizeof(eventcause) - 2;
+			memcpy_ext(pmadapter, (t_u8 *)pevent->event_buf,
+				   pmadapter->event_body + 2, pevent->event_len,
+				   pevent->event_len);
+			wlan_recv_event(pmpriv, pevent->event_id, pevent);
+		} else {
+			PRINTM(MERROR,
+			       "EVENT: ERR:: ROAM OFFLOAD IN FW has invalid length\n");
+		}
+		break;
 	case EVENT_CLOUD_KEEP_ALIVE_RETRY_FAIL:
 		break;
+	case EVENT_WLS_FTM_COMPLETE:
+		PRINTM(MEVENT, "EVENT: FTM_GENERIC_EVENT\n");
+		pevent->bss_index = pmpriv->bss_index;
+		event_ftm =
+			(Event_WLS_FTM_t *)(pmbuf->pbuf + pmbuf->data_offset);
+		if (event_ftm->sub_event_id == WLS_SUB_EVENT_RTT_RESULTS)
+			wlan_fill_hal_rtt_results(pmpriv, event_ftm,
+						  pmbuf->data_len, pevent);
+		else {
+			pevent->event_id = MLAN_EVENT_ID_DRV_PASSTHRU;
+			pevent->event_len = pmbuf->data_len;
+			memcpy_ext(pmadapter, (t_u8 *)pevent->event_buf,
+				   pmbuf->pbuf + pmbuf->data_offset,
+				   pevent->event_len, pevent->event_len);
+		}
+		wlan_recv_event(pmpriv, pevent->event_id, pevent);
+		break;
 	case EVENT_VDLL_IND:
 		wlan_process_vdll_event(pmpriv, pmbuf);
 		break;
@@ -1013,6 +1419,17 @@ mlan_status wlan_ops_sta_process_event(t_void *priv)
 		pmadapter->fw_hang_report = MTRUE;
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_DBG_DUMP, MNULL);
 		break;
+	case CHAN_LOAD_EVENT: {
+		t_u8 *ptr = MNULL;
+		HostCmd_DS_GET_CH_LOAD *cfg_cmd = MNULL;
+		ptr = (t_u8 *)(pmbuf->pbuf + pmbuf->data_offset);
+		ptr += 4; /* data start */
+		cfg_cmd = (HostCmd_DS_GET_CH_LOAD *)ptr;
+		pmpriv->ch_load_param = wlan_le16_to_cpu(cfg_cmd->ch_load);
+		pmpriv->noise = wlan_le16_to_cpu(cfg_cmd->noise);
+		pmpriv->rx_quality = wlan_le16_to_cpu(cfg_cmd->rx_quality);
+		break;
+	}
 	default:
 		PRINTM(MEVENT, "EVENT: unknown event id: %#x\n", eventcause);
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_FW_UNKNOWN, MNULL);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c
old mode 100644
new mode 100755
index 6724a17f2..b6dfd1eab
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_ioctl.c
@@ -3,7 +3,7 @@
  *  @brief This file contains the functions for station ioctl.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -295,7 +295,7 @@ static mlan_status wlan_get_info_bss_info(pmlan_adapter pmadapter,
 	info->param.bss_info.beacon_interval = pbss_desc->beacon_period;
 
 	/* Band */
-	info->param.bss_info.bss_band = (t_u8)pbss_desc->bss_band;
+	info->param.bss_info.bss_band = pbss_desc->bss_band;
 
 	/* Region code */
 	info->param.bss_info.region_code = pmadapter->region_code;
@@ -356,12 +356,8 @@ static mlan_status wlan_get_info_bss_info(pmlan_adapter pmadapter,
 	info->param.bss_info.listen_interval = pmpriv->listen_interval;
 
 	/* Association ID */
-	if (pmpriv->assoc_rsp_buf)
-		info->param.bss_info.assoc_id =
-			(t_u16)((IEEEtypes_AssocRsp_t *)pmpriv->assoc_rsp_buf)
-				->a_id;
-	else
-		info->param.bss_info.assoc_id = 0;
+	info->param.bss_info.assoc_id =
+		(t_u16)((IEEEtypes_AssocRsp_t *)pmpriv->assoc_rsp_buf)->a_id;
 
 	/* AP/Peer supported rates */
 	memset(pmadapter, info->param.bss_info.peer_supp_rates, 0,
@@ -414,6 +410,10 @@ static mlan_status wlan_get_info_ioctl(pmlan_adapter pmadapter,
 		pioctl_req->data_read_written =
 			sizeof(mlan_fw_info) + MLAN_SUB_COMMAND_SIZE;
 		pget_info->param.fw_info.fw_ver = pmadapter->fw_release_number;
+		pget_info->param.fw_info.hotfix_version =
+			pmadapter->fw_hotfix_ver;
+		pget_info->param.fw_info.tx_buf_size = pmadapter->tx_buf_size;
+
 		memcpy_ext(pmadapter, &pget_info->param.fw_info.mac_addr,
 			   pmpriv->curr_addr, MLAN_MAC_ADDR_LENGTH,
 			   MLAN_MAC_ADDR_LENGTH);
@@ -428,6 +428,8 @@ static mlan_status wlan_get_info_ioctl(pmlan_adapter pmadapter,
 			pmadapter->getlog_enable;
 		pget_info->param.fw_info.hw_dev_mcs_support =
 			pmadapter->hw_dev_mcs_support;
+		pget_info->param.fw_info.hw_mpdu_density =
+			pmadapter->hw_mpdu_density;
 		pget_info->param.fw_info.hw_dot_11n_dev_cap =
 			pmadapter->hw_dot_11n_dev_cap;
 		pget_info->param.fw_info.usr_dev_mcs_support =
@@ -446,6 +448,8 @@ static mlan_status wlan_get_info_ioctl(pmlan_adapter pmadapter,
 			pmpriv->usr_dot_11ac_mcs_support;
 		pget_info->param.fw_info.usr_dot_11ac_dev_cap_a =
 			pmpriv->usr_dot_11ac_dev_cap_a;
+		pget_info->param.fw_info.uuid_lo = pmadapter->uuid_lo;
+		pget_info->param.fw_info.uuid_hi = pmadapter->uuid_hi;
 		pget_info->param.fw_info.hw_hecap_len = pmadapter->hw_hecap_len;
 		pget_info->param.fw_info.hw_2g_hecap_len =
 			pmadapter->hw_2g_hecap_len;
@@ -460,6 +464,13 @@ static mlan_status wlan_get_info_ioctl(pmlan_adapter pmadapter,
 		pget_info->param.fw_info.antinfo = pmadapter->antinfo;
 		pget_info->param.fw_info.max_ap_assoc_sta =
 			pmadapter->max_sta_conn;
+		pget_info->param.fw_info.fw_roaming_support =
+			(pmadapter->fw_cap_info & FW_ROAMING_SUPPORT) ? 0x01 :
+									0x00;
+		pget_info->param.fw_info.fw_beacon_prot =
+			IS_FW_SUPPORT_BEACON_PROT(pmadapter) ? 0x01 : 0x00;
+		pget_info->param.fw_info.rtt_support =
+			IS_FW_SUPPORT_RTT(pmadapter) ? 0x01 : 0x00;
 		break;
 	case MLAN_OID_GET_BSS_INFO:
 		status = wlan_get_info_bss_info(pmadapter, pioctl_req);
@@ -540,6 +551,13 @@ static mlan_status wlan_snmp_mib_ioctl(pmlan_adapter pmadapter,
 		value = mib->param.signalext_enable;
 		cmd_oid = SignalextEnable_i;
 		break;
+	case MLAN_OID_SNMP_MIB_CHAN_TRACK:
+		if (!IS_FW_SUPPORT_CHAN_TRACK(pmadapter)) {
+			goto exit;
+		}
+		value = mib->param.chan_track;
+		cmd_oid = ChanTrackParam_i;
+		break;
 	}
 
 	/* Send request to firmware */
@@ -762,7 +780,7 @@ static mlan_status wlan_bss_ioctl_get_channel_list(pmlan_adapter pmadapter,
 	     (pmpriv->bss_mode == MLAN_BSS_MODE_IBSS &&
 	      pmpriv->adhoc_state != ADHOC_STARTED))) {
 		t_u8 chan_no;
-		t_u8 band;
+		t_u16 band;
 
 		parsed_region_chan_11d_t *parsed_region_chan = MNULL;
 		parsed_region_chan_11d_t region_chan;
@@ -779,7 +797,7 @@ static mlan_status wlan_bss_ioctl_get_channel_list(pmlan_adapter pmadapter,
 
 		if (wlan_11d_parse_domain_info(
 			    pmadapter, &pbss_desc->country_info,
-			    (t_u8)pbss_desc->bss_band,
+			    pbss_desc->bss_band,
 			    &region_chan) == MLAN_STATUS_SUCCESS) {
 			parsed_region_chan = &region_chan;
 		} else {
@@ -1059,6 +1077,10 @@ static mlan_status wlan_bss_ioctl_start(pmlan_adapter pmadapter,
 			       "SSID found in scan list ... associating...\n");
 			pmpriv->curr_bss_params.host_mlme =
 				bss->param.ssid_bssid.host_mlme;
+			memcpy_ext(pmpriv->adapter,
+				   &pmpriv->curr_bss_params.prev_bssid,
+				   &bss->param.ssid_bssid.prev_bssid,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 			/* Clear any past association response stored for
 			 * application retrieval */
 			pmpriv->assoc_rsp_size = 0;
@@ -1338,7 +1360,6 @@ static mlan_status wlan_query_passphrase(mlan_private *priv,
 		LEAVE();
 		return ret;
 	}
-	memset(pmadapter, sec, 0, sizeof(mlan_ds_sec_cfg));
 	sec_pp = (mlan_ds_passphrase *)&sec->param.passphrase;
 	sec_pp->psk_type = MLAN_PSK_QUERY;
 	if (ssid_bssid->ssid.ssid_len == 0) {
@@ -1377,8 +1398,8 @@ static mlan_status wlan_query_passphrase(mlan_private *priv,
  *  @return		MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success,
  * otherwise fail
  */
-mlan_status wlan_bss_ioctl_find_bss(pmlan_adapter pmadapter,
-				    pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_bss_ioctl_find_bss(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -1421,8 +1442,8 @@ mlan_status wlan_bss_ioctl_find_bss(pmlan_adapter pmadapter,
  *  @return		MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success,
  * otherwise fail
  */
-mlan_status wlan_bss_ioctl_find_bssid(pmlan_adapter pmadapter,
-				      pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_bss_ioctl_find_bssid(pmlan_adapter pmadapter,
+					     pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_bss *bss = MNULL;
@@ -1455,8 +1476,9 @@ mlan_status wlan_bss_ioctl_find_bssid(pmlan_adapter pmadapter,
  *  @return		MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success,
  * otherwise fail
  */
-mlan_status wlan_bss_ioctl_bss_11d_check_channel(pmlan_adapter pmadapter,
-						 pmlan_ioctl_req pioctl_req)
+static mlan_status
+wlan_bss_ioctl_bss_11d_check_channel(pmlan_adapter pmadapter,
+				     pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_bss *bss = MNULL;
@@ -1473,8 +1495,7 @@ mlan_status wlan_bss_ioctl_bss_11d_check_channel(pmlan_adapter pmadapter,
 	       (t_u32)ssid_bssid->channel);
 
 	/* check if this channel is supported in the region */
-	if (!wlan_find_cfp_by_band_and_channel(pmadapter,
-					       (t_u8)ssid_bssid->bss_band,
+	if (!wlan_find_cfp_by_band_and_channel(pmadapter, ssid_bssid->bss_band,
 					       (t_u32)ssid_bssid->channel)) {
 		PRINTM(MERROR, "Unsupported Channel for region 0x%x\n",
 		       pmadapter->region_code);
@@ -1754,7 +1775,6 @@ static mlan_status wlan_power_ioctl_set_power(pmlan_adapter pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto exit;
 	}
-	memset(pmadapter, buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
 	txp_cfg = (HostCmd_DS_TXPWR_CFG *)buf;
 	txp_cfg->action = HostCmd_ACT_GEN_SET;
 	if (!power->param.power_cfg.is_power_auto) {
@@ -1849,7 +1869,6 @@ static mlan_status wlan_power_ioctl_set_power_ext(pmlan_adapter pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto exit;
 	}
-	memset(pmadapter, buf, 0, MRVDRV_SIZE_OF_CMD_BUFFER);
 	txp_cfg = (HostCmd_DS_TXPWR_CFG *)buf;
 	txp_cfg->action = HostCmd_ACT_GEN_SET;
 	pwr_grp = &power->param.power_ext.power_group[0];
@@ -2716,7 +2735,7 @@ static mlan_status wlan_sec_ioctl_encrypt_mode(pmlan_adapter pmadapter,
  *
  *  @return		random charactor
  */
-t_u8 wlan_get_random_charactor(pmlan_adapter pmadapter)
+static t_u8 wlan_get_random_charactor(pmlan_adapter pmadapter)
 {
 	t_u32 sec, usec;
 	t_u8 ch = 0;
@@ -2842,7 +2861,8 @@ static mlan_status wlan_sec_ioctl_set_wep_key(pmlan_adapter pmadapter,
 				else
 					sec->param.encrypt_key.key_len =
 						WEP_104_BIT_LEN;
-				for (i = 0; i < sec->param.encrypt_key.key_len;
+				for (i = 0;
+				     i < (int)sec->param.encrypt_key.key_len;
 				     i++)
 					sec->param.encrypt_key.key_material[i] =
 						wlan_get_random_charactor(
@@ -2874,9 +2894,9 @@ static mlan_status wlan_sec_ioctl_set_wep_key(pmlan_adapter pmadapter,
 			/* Copy the required key as the current key */
 			pwep_key = &pmpriv->wep_key[index];
 			if (!pwep_key->key_length) {
-				if (&pmpriv->sec_info.wpa_enabled ||
-				    &pmpriv->sec_info.wpa2_enabled ||
-				    &pmpriv->sec_info.wapi_enabled) {
+				if (pmpriv->sec_info.wpa_enabled ||
+				    pmpriv->sec_info.wpa2_enabled ||
+				    pmpriv->sec_info.wapi_enabled) {
 					ret = MLAN_STATUS_SUCCESS;
 					goto exit;
 				}
@@ -2920,7 +2940,9 @@ static mlan_status wlan_sec_ioctl_set_wep_key(pmlan_adapter pmadapter,
 			goto exit;
 		if (!sec->param.encrypt_key.key_len) {
 			sec->param.encrypt_key.key_index = pwep_key->key_index;
-			sec->param.encrypt_key.key_len = pwep_key->key_length;
+			sec->param.encrypt_key.key_len =
+				MIN(pwep_key->key_length,
+				    sizeof(pwep_key->key_material));
 			memcpy_ext(pmadapter,
 				   sec->param.encrypt_key.key_material,
 				   pwep_key->key_material,
@@ -3347,8 +3369,8 @@ static mlan_status wlan_sec_cfg_ioctl(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-static int wlan_set_gen_ie_helper(mlan_private *priv, t_u8 *ie_data_ptr,
-				  t_u16 ie_len)
+static mlan_status wlan_set_gen_ie_helper(mlan_private *priv, t_u8 *ie_data_ptr,
+					  t_u16 ie_len)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	IEEEtypes_VendorHeader_t *pvendor_ie;
@@ -3931,9 +3953,31 @@ static mlan_status wlan_misc_ioctl_gen_ie(pmlan_adapter pmadapter,
 				   pmpriv->wpa_ie, misc->param.gen_ie.len,
 				   MAX_IE_SIZE);
 		} else {
-			wlan_set_gen_ie_helper(pmpriv,
-					       misc->param.gen_ie.ie_data,
-					       (t_u16)misc->param.gen_ie.len);
+			ret = wlan_set_gen_ie_helper(
+				pmpriv, misc->param.gen_ie.ie_data,
+				(t_u16)misc->param.gen_ie.len);
+		}
+		break;
+	case MLAN_IE_TYPE_ARP_FILTER:
+		memset(pmadapter, pmadapter->arp_filter, 0,
+		       sizeof(pmadapter->arp_filter));
+		if (misc->param.gen_ie.len > ARP_FILTER_MAX_BUF_SIZE) {
+			pmadapter->arp_filter_size = 0;
+			PRINTM(MERROR, "Invalid ARP Filter Size\n");
+			pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
+			ret = MLAN_STATUS_FAILURE;
+		} else if (misc->param.gen_ie.len <=
+			   sizeof(MrvlIEtypesHeader_t)) {
+			pmadapter->arp_filter_size = 0;
+			PRINTM(MINFO, "Clear ARP filter\n");
+		} else {
+			memcpy_ext(pmadapter, pmadapter->arp_filter,
+				   misc->param.gen_ie.ie_data,
+				   misc->param.gen_ie.len,
+				   ARP_FILTER_MAX_BUF_SIZE);
+			pmadapter->arp_filter_size = misc->param.gen_ie.len;
+			HEXDUMP("ArpFilter", pmadapter->arp_filter,
+				pmadapter->arp_filter_size);
 		}
 		break;
 	default:
@@ -3947,89 +3991,6 @@ static mlan_status wlan_misc_ioctl_gen_ie(pmlan_adapter pmadapter,
 	return ret;
 }
 
-/**
- *  @brief Perform warm reset
- *
- *  @param pmadapter	A pointer to mlan_adapter structure
- *  @param pioctl_req	A pointer to ioctl request buffer
- *
- *  @return		MLAN_STATUS_PENDING --success, MLAN_STATUS_FAILURE
- */
-mlan_status wlan_misc_ioctl_warm_reset(pmlan_adapter pmadapter,
-				       pmlan_ioctl_req pioctl_req)
-{
-	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_status ret = MLAN_STATUS_SUCCESS;
-	pmlan_callbacks pcb = &pmadapter->callbacks;
-	pmlan_buffer pmbuf;
-	t_s32 i = 0;
-	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
-
-	ENTER();
-	mlan_block_rx_process(pmadapter, MTRUE);
-
-	/* Cancel all pending commands and complete ioctls */
-	if (misc->param.fw_reload)
-		wlan_cancel_all_pending_cmd(pmadapter, MTRUE);
-
-	/** Init all the head nodes and free all the locks here */
-	for (i = 0; i < pmadapter->priv_num; i++)
-		wlan_free_priv(pmadapter->priv[i]);
-
-	while ((pmbuf = (pmlan_buffer)util_dequeue_list(
-			pmadapter->pmoal_handle, &pmadapter->rx_data_queue,
-			pcb->moal_spin_lock, pcb->moal_spin_unlock))) {
-		pmadapter->ops.data_complete(pmadapter, pmbuf,
-					     MLAN_STATUS_FAILURE);
-	}
-	pmadapter->rx_pkts_queued = 0;
-
-	/* Initialize adapter structure */
-	wlan_init_adapter(pmadapter);
-	pmadapter->hw_status = WlanHardwareStatusInitializing;
-
-	/* Initialize private structures */
-	for (i = 0; i < pmadapter->priv_num; i++) {
-		if (pmadapter->priv[i])
-			wlan_init_priv(pmadapter->priv[i]);
-	}
-	mlan_block_rx_process(pmadapter, MFALSE);
-
-	if (misc->param.fw_reload != MTRUE) {
-		/* Restart the firmware */
-		ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FUNC_SHUTDOWN,
-				       HostCmd_ACT_GEN_SET, 0, MNULL, MNULL);
-		if (ret)
-			goto done;
-	}
-
-	/* Issue firmware initialize commands for first BSS,
-	 * for other interfaces it will be called after getting
-	 * the last init command response of previous interface
-	 */
-	pmpriv = wlan_get_priv(pmadapter, MLAN_BSS_ROLE_ANY);
-	if (!pmpriv) {
-		ret = MLAN_STATUS_FAILURE;
-		LEAVE();
-		return ret;
-	}
-	ret = wlan_adapter_get_hw_spec(pmpriv->adapter);
-	if (ret == MLAN_STATUS_FAILURE) {
-		LEAVE();
-		return ret;
-	}
-	ret = pmpriv->ops.init_cmd(pmpriv, MTRUE);
-	if (ret == MLAN_STATUS_FAILURE) {
-		LEAVE();
-		return ret;
-	}
-	if (ret == MLAN_STATUS_PENDING)
-		pmadapter->pwarm_reset_ioctl_req = pioctl_req;
-done:
-	LEAVE();
-	return ret;
-}
-
 #ifdef SDIO
 /**
  *  @brief Reconfigure SDIO multiport aggregation parameters
@@ -4205,6 +4166,36 @@ static mlan_status wlan_misc_ioctl_get_assoc_rsp(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Get the associate request IEs
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_SUCCESS --success
+ */
+static mlan_status wlan_misc_ioctl_get_assoc_req(pmlan_adapter pmadapter,
+						 pmlan_ioctl_req pioctl_req)
+{
+	mlan_ds_misc_cfg *misc = MNULL;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	if ((pioctl_req->action == MLAN_ACT_GET) && pmpriv->assoc_req_size) {
+		memcpy_ext(pmadapter, misc->param.assoc_req.assoc_req_buf,
+			   pmpriv->assoc_req_buf, pmpriv->assoc_req_size,
+			   ASSOC_RSP_BUF_SIZE);
+		misc->param.assoc_req.assoc_req_len =
+			MIN(ASSOC_RSP_BUF_SIZE, pmpriv->assoc_req_size);
+	}
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Send function softreset command to firmware
  *
@@ -4239,12 +4230,11 @@ static mlan_status wlan_misc_ioctl_soft_reset(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_PENDING -- success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_thermal(pmlan_adapter pmadapter,
-				    pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_thermal(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_ds_misc_cfg *misc = MNULL;
 	t_u16 cmd_action = 0;
 
 	ENTER();
@@ -4259,7 +4249,6 @@ mlan_status wlan_misc_ioctl_thermal(pmlan_adapter pmadapter,
 		return MLAN_STATUS_RESOURCE;
 	}
 
-	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET) {
 		PRINTM(MERROR, "Thermal reading setting is not allowed!\n");
 		LEAVE();
@@ -4287,8 +4276,8 @@ mlan_status wlan_misc_ioctl_thermal(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_PENDING -- success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_subscribe_evt(pmlan_adapter pmadapter,
-					  pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_subscribe_evt(pmlan_adapter pmadapter,
+						 pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -4315,110 +4304,116 @@ mlan_status wlan_misc_ioctl_subscribe_evt(pmlan_adapter pmadapter,
 	return ret;
 }
 
-#define FLTR_BUF_IP_OFFSET 24
-#define FLTR_BUF_IP_OFFSET_2_IP_1 9
-#define FLTR_BUF_IP_OFFSET_2_IP_2 26
+/**
+ *  @brief Get/Set fw auto reconnect
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return             MLAN_STATUS_PENDING -- success, otherwise fail
+ */
+static mlan_status wlan_misc_ioctl_fw_auto_reconnect(pmlan_adapter pmadapter,
+						     pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_FW_AUTO_RECONNECT,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &misc->param.fw_auto_reconnect);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
 
 /**
- *  @brief Enable/Disable Auto ARP resonse
+ *  @brief Set ARP filter based on IP address
  *
  *  @param pmadapter    A pointer to mlan_adapter structure
  *  @param pioctl_req   A pointer to ioctl request buffer
  *  @param ipv4_addr    ipv4 Address
- *  @param num_ipv4     Number of ipv4 Addresses
  *
  *  @return             MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_ipaddr_auto_arp_resp(pmlan_adapter pmadapter,
-				      pmlan_ioctl_req pioctl_req,
-				      t_u32 *ipv4_addr, t_u8 num_ipv4)
+static mlan_status wlan_ipaddr_arp_filter(pmlan_adapter pmadapter,
+					  pmlan_ioctl_req pioctl_req,
+					  t_u32 ipv4_addr)
 {
-	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	HostCmd_DS_GEN *hostcmd_hdr;
-	HostCmd_DS_MEF_CFG *mefcmd;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
-	mlan_ds_misc_cmd *hostcmd;
-	t_u32 buf_len = 0;
-	t_u8 *buf, *filter;
-
-	t_u8 fltr_buf[] = {0x01, 0x10, 0x21, 0x00, 0x01, 0x00, 0x00, 0x00,
-			   0x01, 0x08, 0x06, 0x02, 0x02, 0x14, 0x00, 0x00,
-			   0x00, 0x01, 0x41, 0x01, 0x00, 0x00, 0x00, 0x01,
-			   0xc0, 0xa8, 0x01, 0x6d, 0x04, 0x02, 0x2e, 0x00,
-			   0x00, 0x00, 0x01, 0x41, 0x44};
-	t_u8 fltr_buf_2_ip[] = {0x01, 0x10, 0x33, 0x00, 0x01, 0x00, 0x00, 0x00,
-				0x01, 0xc0, 0xa8, 0x01, 0x6d, 0x04, 0x02, 0x2e,
-				0x00, 0x00, 0x00, 0x01, 0x41, 0x01, 0x00, 0x00,
-				0x00, 0x01, 0xc0, 0xa8, 0x02, 0x6d, 0x04, 0x02,
-				0x2e, 0x00, 0x00, 0x00, 0x01, 0x41, 0x45, 0x01,
-				0x00, 0x00, 0x00, 0x01, 0x08, 0x06, 0x02, 0x02,
-				0x14, 0x00, 0x00, 0x00, 0x01, 0x41, 0x44};
+	t_u8 *buf;
+	arpfilter_header *arpfilter = MNULL;
+	filter_entry *entry = MNULL;
+	t_u32 len;
 
 	ENTER();
 
-	ret = pcb->moal_malloc(pmadapter->pmoal_handle,
-			       sizeof(mlan_ds_misc_cmd), MLAN_MEM_DEF,
-			       (t_u8 **)&hostcmd);
-
-	if (ret != MLAN_STATUS_SUCCESS || hostcmd == MNULL) {
-		PRINTM(MERROR, "Failed to allocate hostcmd  buffer\n");
-		pioctl_req->status_code = MLAN_ERROR_NO_MEM;
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
+	pcb->moal_malloc(pmadapter->pmoal_handle, MRVDRV_SIZE_OF_CMD_BUFFER,
+			 MLAN_MEM_DEF, &buf);
+	if (!buf) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
 	}
 
-	memset(pmpriv->adapter, hostcmd, 0, sizeof(mlan_ds_misc_cmd));
-	buf = hostcmd->cmd;
+	/* Construct the ARP filter TLV */
+	arpfilter = (arpfilter_header *)buf;
+	arpfilter->type = wlan_cpu_to_le16(TLV_TYPE_ARP_FILTER);
+
+	if (ipv4_addr) {
+		arpfilter->len = wlan_cpu_to_le16(sizeof(filter_entry) * 3);
+		entry = (filter_entry *)(buf + sizeof(arpfilter_header));
+		entry->addr_type = wlan_cpu_to_le16(ADDR_TYPE_BROADCAST);
+		entry->eth_type = wlan_cpu_to_le16(ETHER_TYPE_ARP);
+		entry->ipv4_addr = wlan_cpu_to_le32(ipv4_addr);
+		entry++;
+		entry->addr_type = wlan_cpu_to_le16(ADDR_TYPE_UNICAST);
+		entry->eth_type = wlan_cpu_to_le16(ETHER_TYPE_ANY);
+		entry->ipv4_addr = wlan_cpu_to_le32(IPV4_ADDR_ANY);
+		entry++;
+		entry->addr_type = wlan_cpu_to_le16(ADDR_TYPE_MULTICAST);
+		entry->eth_type = wlan_cpu_to_le16(ETHER_TYPE_ANY);
+		entry->ipv4_addr = wlan_cpu_to_le32(IPV4_ADDR_ANY);
+	} else
+		arpfilter->len = 0;
 
-	/* Prepare hostcmd buffer */
-	hostcmd_hdr = (HostCmd_DS_GEN *)(buf);
-	hostcmd_hdr->command = wlan_cpu_to_le16(HostCmd_CMD_MEF_CFG);
-	mefcmd = (HostCmd_DS_MEF_CFG *)(buf + S_DS_GEN);
-	buf_len = S_DS_GEN;
+	/* Update the total length */
+	len = sizeof(arpfilter_header) + wlan_le16_to_cpu(arpfilter->len);
 
-	if (!ipv4_addr) {
-		PRINTM(MINFO, "Disable Auto ARP Response\n");
-		mefcmd->criteria = wlan_cpu_to_le32(0);
-		mefcmd->nentries = wlan_cpu_to_le16(0);
-		buf_len += sizeof(HostCmd_DS_MEF_CFG);
+	memset(pmadapter, pmadapter->arp_filter, 0,
+	       sizeof(pmadapter->arp_filter));
+	if (len > ARP_FILTER_MAX_BUF_SIZE) {
+		pmadapter->arp_filter_size = 0;
+		PRINTM(MERROR, "Invalid ARP Filter Size\n");
+		pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
+		ret = MLAN_STATUS_FAILURE;
+	} else if (len <= sizeof(MrvlIEtypesHeader_t)) {
+		pmadapter->arp_filter_size = 0;
+		PRINTM(MINFO, "Clear ARP filter\n");
 	} else {
-		/* Event bit (bit2) of HS conditions should be masked out */
-		mefcmd->criteria = wlan_cpu_to_le32(
-			pmpriv->adapter->hs_cfg.conditions & ~MBIT(2));
-		mefcmd->nentries = wlan_cpu_to_le16(1);
-		buf_len += sizeof(HostCmd_DS_MEF_CFG);
-		filter = buf + buf_len;
-		if (num_ipv4 == 1) {
-			memcpy_ext(pmpriv->adapter, filter, fltr_buf,
-				   sizeof(fltr_buf), sizeof(fltr_buf));
-			memcpy_ext(pmpriv->adapter, &filter[FLTR_BUF_IP_OFFSET],
-				   &ipv4_addr[0], sizeof(t_u32), sizeof(t_u32));
-			buf_len += sizeof(fltr_buf);
-		} else if (num_ipv4 >= 2) {
-			memcpy_ext(pmpriv->adapter, filter, fltr_buf_2_ip,
-				   sizeof(fltr_buf_2_ip),
-				   sizeof(fltr_buf_2_ip));
-			memcpy_ext(pmpriv->adapter,
-				   &filter[FLTR_BUF_IP_OFFSET_2_IP_1],
-				   &ipv4_addr[0], sizeof(t_u32), sizeof(t_u32));
-			memcpy_ext(pmpriv->adapter,
-				   &filter[FLTR_BUF_IP_OFFSET_2_IP_2],
-				   &ipv4_addr[1], sizeof(t_u32), sizeof(t_u32));
-			buf_len += sizeof(fltr_buf_2_ip);
-		}
+		memcpy_ext(pmadapter, pmadapter->arp_filter, buf, len,
+			   ARP_FILTER_MAX_BUF_SIZE);
+		pmadapter->arp_filter_size = len;
+		HEXDUMP("ArpFilter", pmadapter->arp_filter,
+			pmadapter->arp_filter_size);
 	}
-	hostcmd_hdr->size = wlan_cpu_to_le16(buf_len);
-	hostcmd->len = buf_len;
-
-	/* Send command to firmware */
-	ret = wlan_prepare_cmd(pmpriv, 0, 0, 0, (t_void *)pioctl_req,
-			       (t_void *)hostcmd);
-	if (ret == MLAN_STATUS_SUCCESS)
-		ret = MLAN_STATUS_PENDING;
-
-	pcb->moal_mfree(pmadapter->pmoal_handle, (t_u8 *)hostcmd);
 
+done:
+	if (buf)
+		pcb->moal_mfree(pmadapter->pmoal_handle, buf);
 	LEAVE();
 	return ret;
 }
@@ -4431,8 +4426,8 @@ mlan_status wlan_ipaddr_auto_arp_resp(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_mef_cfg(pmlan_adapter pmadapter,
-				    pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_mef_cfg(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
@@ -4540,8 +4535,8 @@ mlan_status wlan_misc_ioctl_mef_cfg(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_ipaddr_cfg(pmlan_adapter pmadapter,
-				       pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_ipaddr_cfg(pmlan_adapter pmadapter,
+					      pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_misc_cfg *misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
@@ -4559,7 +4554,7 @@ mlan_status wlan_misc_ioctl_ipaddr_cfg(pmlan_adapter pmadapter,
 		goto done;
 	}
 	/* only one IP is supported in current firmware */
-	for (i = 0; i < misc->param.ipaddr_cfg.ip_addr_num; i++) {
+	for (i = 0; i < (int)misc->param.ipaddr_cfg.ip_addr_num; i++) {
 		memcpy_ext(pmadapter, &ipv4_addr[i],
 			   misc->param.ipaddr_cfg.ip_addr[i], sizeof(t_u32),
 			   sizeof(t_u32));
@@ -4572,6 +4567,13 @@ mlan_status wlan_misc_ioctl_ipaddr_cfg(pmlan_adapter pmadapter,
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
+	if (misc->param.ipaddr_cfg.op_code & MLAN_IPADDR_OP_ARP_FILTER)
+		ret = wlan_ipaddr_arp_filter(pmadapter, pioctl_req,
+					     ipv4_addr[0]);
+	else if (pmpriv->op_code & MLAN_IPADDR_OP_ARP_FILTER)
+		ret = wlan_ipaddr_arp_filter(pmadapter, pioctl_req, 0);
+	if (ret == MLAN_STATUS_FAILURE)
+		goto done;
 
 	/* Save the values in MLAN */
 	if (pioctl_req->action == MLAN_ACT_SET) {
@@ -4594,8 +4596,8 @@ mlan_status wlan_misc_ioctl_ipaddr_cfg(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_cfp_code_cfg(pmlan_adapter pmadapter,
-					 pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_cfp_code_cfg(pmlan_adapter pmadapter,
+						pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
@@ -4674,75 +4676,6 @@ mlan_status wlan_misc_ioctl_cfp_code_cfg(pmlan_adapter pmadapter,
 	return ret;
 }
 
-/**
- *  @brief This function sets up country code and downloads CMD to FW
- *
- *  @param pmadapter    A pointer to mlan_adapter structure
- *  @param pioctl_req   Pointer to the IOCTL request buffer
- *
- *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
- */
-mlan_status wlan_misc_ioctl_country_code(pmlan_adapter pmadapter,
-					 mlan_ioctl_req *pioctl_req)
-{
-	mlan_status ret = MLAN_STATUS_SUCCESS;
-	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_misc_country_code *country_code = MNULL;
-	mlan_ds_misc_cfg *cfg_misc = MNULL;
-	t_u8 cfp_bg = 0, cfp_a = 0;
-
-	ENTER();
-
-	cfg_misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
-	country_code = &cfg_misc->param.country_code;
-
-	if (pioctl_req->action == MLAN_ACT_SET) {
-		if (pmadapter->otp_region && pmadapter->otp_region->force_reg) {
-			PRINTM(MERROR,
-			       "ForceRegionRule is set in the on-chip OTP"
-			       "memory\n");
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
-		}
-		/* Update region code and table based on country code */
-		if (wlan_misc_country_2_cfp_table_code(
-			    pmadapter, country_code->country_code, &cfp_bg,
-			    &cfp_a)) {
-			PRINTM(MERROR, "Country code not found!\n");
-			pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
-		}
-		pmadapter->cfp_code_bg = cfp_bg;
-		pmadapter->cfp_code_a = cfp_a;
-		if (cfp_a)
-			pmadapter->region_code = cfp_a;
-		else if (cfp_bg)
-			pmadapter->region_code = cfp_bg;
-		else
-			pmadapter->region_code = 0;
-		if (wlan_set_regiontable(pmpriv, pmadapter->region_code,
-					 pmadapter->config_bands |
-						 pmadapter->adhoc_start_band)) {
-			pioctl_req->status_code = MLAN_ERROR_INVALID_PARAMETER;
-			ret = MLAN_STATUS_FAILURE;
-			goto done;
-		}
-		memcpy_ext(pmadapter, pmadapter->country_code,
-			   country_code->country_code, COUNTRY_CODE_LEN,
-			   COUNTRY_CODE_LEN);
-	} else {
-		/* GET operation */
-		memcpy_ext(pmadapter, country_code->country_code,
-			   pmadapter->country_code, COUNTRY_CODE_LEN,
-			   COUNTRY_CODE_LEN);
-	}
-
-done:
-	LEAVE();
-	return ret;
-}
-
 /**
  *  @brief Configure MFPC and MFPR for management frame protection
  *
@@ -4751,8 +4684,8 @@ mlan_status wlan_misc_ioctl_country_code(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_misc_pmfcfg(pmlan_adapter pmadapter,
-			     mlan_ioctl_req *pioctl_req)
+static mlan_status wlan_misc_pmfcfg(pmlan_adapter pmadapter,
+				    mlan_ioctl_req *pioctl_req)
 {
 	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -4806,29 +4739,45 @@ mlan_status wlan_misc_ioctl_arb_cfg(pmlan_adapter pmadapter,
 	return ret;
 }
 
-mlan_status wlan_misc_ioctl_get_sensor_temp(pmlan_adapter pmadapter,
-					    pmlan_ioctl_req pioctl_req)
+/**
+ *  @brief Save tp accounting command configurations.
+ *
+ *  @param pmadapter   A pointer to mlan_adapter structure
+ *  @param pioctl_req  A pointer to ioctl request buffer
+ *
+ *  @return        MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_misc_ioctl_tp_state(pmlan_adapter pmadapter,
+				     pmlan_ioctl_req pioctl_req)
 {
+	mlan_ds_misc_cfg *pmisc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	pmadapter->tp_state_on = pmisc->param.tp_state.on;
+	pmadapter->tp_state_drop_point = pmisc->param.tp_state.drop_point;
+
+	LEAVE();
+	return ret;
+}
+
+static mlan_status wlan_misc_ioctl_ips_cfg(pmlan_adapter pmadapter,
+					   pmlan_ioctl_req pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_misc_cfg *misc = MNULL;
 	t_u16 cmd_action = 0;
-	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
 	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
-
-	if (pioctl_req->action == MLAN_ACT_GET)
-		cmd_action = HostCmd_ACT_GEN_GET;
-	else {
-		PRINTM(MERROR, " sensor temp only support get operation \n");
-		LEAVE();
-		return MLAN_STATUS_FAILURE;
-	}
+	cmd_action = HostCmd_ACT_GEN_SET;
 
 	/* Send request to firmware */
-	ret = wlan_prepare_cmd(pmpriv, HostCmd_DS_GET_SENSOR_TEMP, cmd_action,
-			       0, (t_void *)pioctl_req, MNULL);
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_IPS_CONFIG, cmd_action, 0,
+			       (t_void *)pioctl_req, &misc->param.ips_ctrl);
 
 	if (ret == MLAN_STATUS_SUCCESS)
 		ret = MLAN_STATUS_PENDING;
@@ -4837,6 +4786,40 @@ mlan_status wlan_misc_ioctl_get_sensor_temp(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief IPv6 Router Advertisement offload configuration
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+mlan_status wlan_misc_ioctl_ipv6_ra_offload(pmlan_adapter pmadapter,
+					    mlan_ioctl_req *pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else if (pioctl_req->action == MLAN_ACT_GET)
+		cmd_action = HostCmd_ACT_GEN_GET;
+
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_IPV6_RA_OFFLOAD_CFG,
+			       cmd_action, 0, (t_void *)pioctl_req,
+			       &misc->param.ipv6_ra_offload);
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Gtk Rekey Offload
  *
@@ -4845,8 +4828,8 @@ mlan_status wlan_misc_ioctl_get_sensor_temp(pmlan_adapter pmadapter,
  *
  *  @return		MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-mlan_status wlan_misc_ioctl_gtk_rekey_offload(pmlan_adapter pmadapter,
-					      pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_misc_ioctl_gtk_rekey_offload(pmlan_adapter pmadapter,
+						     pmlan_ioctl_req pioctl_req)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_misc_cfg *misc_cfg = MNULL;
@@ -4883,6 +4866,106 @@ mlan_status wlan_misc_ioctl_gtk_rekey_offload(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief enable/disable roam offload in firmware
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_misc_roam_offload(pmlan_adapter pmadapter,
+					  mlan_ioctl_req *pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (!(pmadapter->fw_cap_info & FW_ROAMING_SUPPORT)) {
+		PRINTM(MERROR, "Firmware roaming not support\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if (!IS_FW_SUPPORT_SUPPLICANT(pmadapter)) {
+		PRINTM(MERROR, "Embedded supplicant do not enable\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	if ((misc->param.roam_offload.config_mode == ROAM_OFFLOAD_ENABLE) &&
+	    misc->param.roam_offload.userset_passphrase) {
+		pmpriv->adapter->userset_passphrase =
+			misc->param.roam_offload.userset_passphrase;
+		if (!misc->param.roam_offload.enable) {
+			LEAVE();
+			return MLAN_STATUS_SUCCESS;
+		}
+	}
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else {
+		PRINTM(MERROR, "Unsupported cmd_action\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_ROAM_OFFLOAD, cmd_action, 0,
+			       (t_void *)pioctl_req, &misc->param.roam_offload);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief set roam offload aplist to firmware
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_misc_roam_offload_aplist(pmlan_adapter pmadapter,
+						 mlan_ioctl_req *pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else {
+		PRINTM(MERROR, "Unsupported cmd_action\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_ROAM_OFFLOAD, cmd_action, 0,
+			       (t_void *)pioctl_req, &misc->param.roam_offload);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief cloud keep alive
  *
@@ -4891,8 +4974,8 @@ mlan_status wlan_misc_ioctl_gtk_rekey_offload(pmlan_adapter pmadapter,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_misc_cloud_keep_alive(pmlan_adapter pmadapter,
-				       mlan_ioctl_req *pioctl_req)
+static mlan_status wlan_misc_cloud_keep_alive(pmlan_adapter pmadapter,
+					      mlan_ioctl_req *pioctl_req)
 {
 	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_misc_cfg *misc = MNULL;
@@ -4925,6 +5008,48 @@ mlan_status wlan_misc_cloud_keep_alive(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief cloud keep alive rx
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   Pointer to the IOCTL request buffer
+ *
+ *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
+ */
+static mlan_status wlan_misc_cloud_keep_alive_rx(pmlan_adapter pmadapter,
+						 mlan_ioctl_req *pioctl_req)
+{
+	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_ds_misc_cfg *misc = MNULL;
+	t_u16 cmd_action = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+
+	if (pioctl_req->action == MLAN_ACT_SET)
+		cmd_action = HostCmd_ACT_GEN_SET;
+	else if (pioctl_req->action == MLAN_ACT_GET) {
+		cmd_action = HostCmd_ACT_GEN_GET;
+	} else if (pioctl_req->action == MLAN_ACT_RESET) {
+		cmd_action = HostCmd_ACT_GEN_RESET;
+	} else {
+		cmd_action = HostCmd_ACT_GEN_REMOVE;
+	}
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_AUTO_TX, cmd_action,
+			       OID_CLOUD_KEEP_ALIVE_ACK, (t_void *)pioctl_req,
+			       &misc->param.keep_alive_rx);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Miscellaneous configuration handler
  *
@@ -4964,6 +5089,7 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 		status = wlan_misc_ioctl_region(pmadapter, pioctl_req);
 		break;
 	case MLAN_OID_MISC_WARM_RESET:
+		PRINTM(MCMND, "Request WARM RESET\n");
 		util_enqueue_list_tail(pmadapter->pmoal_handle,
 				       &pmadapter->ioctl_pending_q,
 				       (pmlan_linked_list)pioctl_req,
@@ -4989,6 +5115,9 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_ASSOC_RSP:
 		status = wlan_misc_ioctl_get_assoc_rsp(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_ASSOC_REQ:
+		status = wlan_misc_ioctl_get_assoc_req(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_INIT_SHUTDOWN:
 		status = wlan_misc_ioctl_init_shutdown(pmadapter, pioctl_req);
 		break;
@@ -4999,7 +5128,25 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 		status = wlan_misc_ioctl_custom_ie_list(pmadapter, pioctl_req,
 							MTRUE);
 		break;
+	case MLAN_OID_MISC_TDLS_CONFIG:
+		status = wlan_misc_ioctl_tdls_config(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_TDLS_OPER:
+		status = wlan_misc_ioctl_tdls_oper(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_GET_TDLS_IES:
+		status = wlan_misc_ioctl_tdls_get_ies(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_TDLS_CS_CHANNEL:
+		status = wlan_misc_ioctl_tdls_cs_channel(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_TDLS_IDLE_TIME:
+		status = wlan_misc_ioctl_tdls_idle_time(pmadapter, pioctl_req);
+		break;
 
+	case MLAN_OID_MISC_NET_MONITOR:
+		status = wlan_misc_ioctl_net_monitor(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_MAC_CONTROL:
 		status = wlan_misc_ioctl_mac_control(pmadapter, pioctl_req);
 		break;
@@ -5032,9 +5179,16 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_HOTSPOT_CFG:
 		status = wlan_misc_hotspot_cfg(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_MULTI_AP_CFG:
+		status = wlan_misc_multi_ap_cfg(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_OTP_USER_DATA:
 		status = wlan_misc_otp_user_data(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_AUTO_ASSOC:
+		status = wlan_misc_ioctl_fw_auto_reconnect(pmadapter,
+							   pioctl_req);
+		break;
 #ifdef USB
 	case MLAN_OID_MISC_USB_AGGR_CTRL:
 		status = wlan_misc_ioctl_usb_aggr_ctrl(pmadapter, pioctl_req);
@@ -5054,12 +5208,17 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_PMFCFG:
 		status = wlan_misc_pmfcfg(pmadapter, pioctl_req);
 		break;
-#ifdef RX_PACKET_COALESCE
-	case MLAN_OID_MISC_RX_PACKET_COALESCE:
-		status = wlan_misc_ioctl_rx_pkt_coalesce_config(pmadapter,
-								pioctl_req);
+	case MLAN_OID_MISC_MULTI_CHAN_CFG:
+		status = wlan_misc_ioctl_multi_chan_config(pmadapter,
+							   pioctl_req);
+		break;
+	case MLAN_OID_MISC_MULTI_CHAN_POLICY:
+		status = wlan_misc_ioctl_multi_chan_policy(pmadapter,
+							   pioctl_req);
+		break;
+	case MLAN_OID_MISC_DRCS_CFG:
+		status = wlan_misc_ioctl_drcs_config(pmadapter, pioctl_req);
 		break;
-#endif
 	case MLAN_OID_MISC_LOW_PWR_MODE:
 		status = wlan_misc_ioctl_low_pwr_mode(pmadapter, pioctl_req);
 		break;
@@ -5089,6 +5248,9 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 		status = wlan_misc_ioctl_operclass_validation(pmadapter,
 							      pioctl_req);
 		break;
+	case MLAN_OID_MISC_IPV6_RA_OFFLOAD:
+		status = wlan_misc_ioctl_ipv6_ra_offload(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_GTK_REKEY_OFFLOAD:
 		status = wlan_misc_ioctl_gtk_rekey_offload(pmadapter,
 							   pioctl_req);
@@ -5096,15 +5258,37 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_IND_RST_CFG:
 		status = wlan_misc_ioctl_ind_rst_cfg(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_MC_AGGR_CFG:
+		status = wlan_misc_ioctl_mc_aggr_cfg(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_CH_LOAD:
+		status = wlan_misc_ioctl_ch_load(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_CH_LOAD_RESULTS:
+		status = wlan_misc_ioctl_ch_load_results(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_GET_TSF:
 		status = wlan_misc_ioctl_get_tsf(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_CROSS_CHIP_SYNCH:
+		status =
+			wlan_misc_ioctl_cross_chip_synch(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_ROAM_OFFLOAD:
+		status = wlan_misc_roam_offload(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_ROAM_OFFLOAD_APLIST:
+		status = wlan_misc_roam_offload_aplist(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_GET_CHAN_REGION_CFG:
 		status = wlan_misc_chan_reg_cfg(pmadapter, pioctl_req);
 		break;
 	case MLAN_OID_MISC_CLOUD_KEEP_ALIVE:
 		status = wlan_misc_cloud_keep_alive(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX:
+		status = wlan_misc_cloud_keep_alive_rx(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_DYN_BW:
 		status = wlan_misc_ioctl_dyn_bw(pmadapter, pioctl_req);
 		break;
@@ -5120,6 +5304,15 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_DMCS_CONFIG:
 		status = wlan_misc_dmcs_config(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_CONFIG_RTT:
+		status = wlan_config_rtt(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_CANCEL_RTT:
+		status = wlan_cancel_rtt(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_RTT_RESPONDER_CFG:
+		status = wlan_rtt_responder_cfg(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_GET_TX_RX_HISTOGRAM:
 		status = wlan_get_tx_rx_histogram(pmadapter, pioctl_req);
 		break;
@@ -5137,9 +5330,24 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 			status = wlan_misc_ssu(pmadapter, pioctl_req);
 		break;
 #endif
+	case MLAN_OID_MISC_CSI:
+		status = wlan_misc_csi(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_HAL_PHY_CFG:
+		status = wlan_misc_hal_phy_cfg(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_GPIO_TSF_LATCH:
+		status = wlan_misc_gpio_tsf_latch_config(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_GET_TSF_INFO:
+		status = wlan_misc_get_tsf_info(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_RX_ABORT_CFG:
 		status = wlan_misc_ioctl_rxabortcfg(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_MISC_OFDM_DESENSE_CFG:
+		status = wlan_misc_ioctl_ofdmdesense_cfg(pmadapter, pioctl_req);
+		break;
 	case MLAN_OID_MISC_RX_ABORT_CFG_EXT:
 		status = wlan_misc_ioctl_rxabortcfg_ext(pmadapter, pioctl_req);
 		break;
@@ -5165,7 +5373,9 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 		break;
 	case MLAN_OID_MISC_RF_TEST_GENERIC:
 	case MLAN_OID_MISC_RF_TEST_TX_CONT:
+	case MLAN_OID_MISC_RF_TEST_CONFIG_TRIGGER_FRAME:
 	case MLAN_OID_MISC_RF_TEST_TX_FRAME:
+	case MLAN_OID_MISC_RF_TEST_HE_POWER:
 		status = wlan_misc_ioctl_rf_test_cfg(pmadapter, pioctl_req);
 		break;
 	case MLAN_OID_MISC_ARB_CONFIG:
@@ -5174,6 +5384,15 @@ static mlan_status wlan_misc_cfg_ioctl(pmlan_adapter pmadapter,
 	case MLAN_OID_MISC_RANGE_EXT:
 		status = wlan_misc_ioctl_range_ext(pmadapter, pioctl_req);
 		break;
+	case MLAN_OID_11AX_TWT_CFG:
+		status = wlan_misc_ioctl_twt_report(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_TP_STATE:
+		status = wlan_misc_ioctl_tp_state(pmadapter, pioctl_req);
+		break;
+	case MLAN_OID_MISC_IPS_CFG:
+		status = wlan_misc_ioctl_ips_cfg(pmadapter, pioctl_req);
+		break;
 	default:
 		if (pioctl_req)
 			pioctl_req->status_code = MLAN_ERROR_IOCTL_INVALID;
@@ -5376,10 +5595,20 @@ static mlan_status wlan_scan_ioctl(pmlan_adapter pmadapter,
 				pioctl_req->data_read_written =
 					sizeof(mlan_scan_resp) +
 					MLAN_SUB_COMMAND_SIZE;
-				pscan->param.scan_resp.pchan_stats =
-					(t_u8 *)pmadapter->pchan_stats;
-				pscan->param.scan_resp.num_in_chan_stats =
-					pmadapter->num_in_chan_stats;
+				if (pmadapter->scan_processing) {
+					pscan->param.scan_resp.pchan_stats =
+						(t_u8 *)pmadapter
+							->pold_chan_stats;
+					pscan->param.scan_resp
+						.num_in_chan_stats =
+						pmadapter->old_idx_chan_stats;
+				} else {
+					pscan->param.scan_resp.pchan_stats =
+						(t_u8 *)pmadapter->pchan_stats;
+					pscan->param.scan_resp
+						.num_in_chan_stats =
+						pmadapter->idx_chan_stats;
+				}
 			}
 		}
 	}
@@ -5484,6 +5713,18 @@ mlan_status wlan_find_bss(mlan_private *pmpriv, pmlan_ioctl_req pioctl_req)
 		memcpy_ext(pmadapter, (t_u8 *)&bss->param.ssid_bssid.bssid,
 			   (t_u8 *)&pbss_desc->mac_address,
 			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		if (pbss_desc->owe_transition_mode) {
+			bss->param.ssid_bssid.owe_transition_mode =
+				pbss_desc->owe_transition_mode;
+			memcpy_ext(pmadapter, &bss->param.ssid_bssid.trans_ssid,
+				   &pbss_desc->trans_ssid,
+				   sizeof(mlan_802_11_ssid),
+				   sizeof(mlan_802_11_ssid));
+			memcpy_ext(pmadapter,
+				   (t_u8 *)&bss->param.ssid_bssid.trans_bssid,
+				   (t_u8 *)&pbss_desc->trans_mac_address,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		}
 		bss->param.ssid_bssid.rssi = pbss_desc->rssi;
 		bss->param.ssid_bssid.channel = (t_u16)pbss_desc->channel;
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c
old mode 100644
new mode 100755
index af9a143e9..671f176b1
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_rx.c
@@ -4,7 +4,7 @@
  *  module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -33,6 +33,7 @@ Change log:
 #include "mlan_main.h"
 #include "mlan_11n_aggr.h"
 #include "mlan_11n_rxreorder.h"
+#include "mlan_11ax.h"
 #ifdef DRV_EMBEDDED_SUPPLICANT
 #include "authenticator_api.h"
 #endif
@@ -41,17 +42,6 @@ Change log:
 		Local Variables
 ********************************************************/
 
-/** Ethernet II header */
-typedef struct {
-	/** Ethernet II header destination address */
-	t_u8 dest_addr[MLAN_MAC_ADDR_LENGTH];
-	/** Ethernet II header source address */
-	t_u8 src_addr[MLAN_MAC_ADDR_LENGTH];
-	/** Ethernet II header length */
-	t_u16 ethertype;
-
-} EthII_Hdr_t;
-
 /** IPv4 ARP request header */
 typedef MLAN_PACK_START struct {
 	/** Hardware type */
@@ -157,6 +147,345 @@ static t_u8 discard_gratuitous_ARP_msg(RxPacketHdr_t *prx_pkt,
 	return ret;
 }
 
+/**
+ *  @brief This function process tdls action frame
+ *
+ *  @param priv        A pointer to mlan_private structure
+ *  @param pbuf        A pointer to tdls action frame buffer
+ *  @param len         len of tdls action frame buffer
+ *  @return            N/A
+ */
+void wlan_process_tdls_action_frame(pmlan_private priv, t_u8 *pbuf, t_u32 len)
+{
+	sta_node *sta_ptr = MNULL;
+	IEEEtypes_VendorHeader_t *pvendor_ie = MNULL;
+	const t_u8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};
+	t_u8 *peer;
+	t_u8 *pos, *end;
+	t_u8 action;
+	int ie_len = 0;
+	t_u8 i;
+	int rate_len;
+	IEEEtypes_Extension_t *ext_ie;
+
+#define TDLS_PAYLOAD_TYPE 2
+#define TDLS_CATEGORY 0x0c
+#define TDLS_REQ_FIX_LEN 6
+#define TDLS_RESP_FIX_LEN 8
+#define TDLS_CONFIRM_FIX_LEN 6
+	if (len < (sizeof(EthII_Hdr_t) + 3))
+		return;
+	if (*(t_u8 *)(pbuf + sizeof(EthII_Hdr_t)) != TDLS_PAYLOAD_TYPE)
+		/*TDLS payload type = 2*/
+		return;
+	if (*(t_u8 *)(pbuf + sizeof(EthII_Hdr_t) + 1) != TDLS_CATEGORY)
+		/*TDLS category = 0xc */
+		return;
+	peer = pbuf + MLAN_MAC_ADDR_LENGTH;
+
+	action = *(t_u8 *)(pbuf + sizeof(EthII_Hdr_t) + 2);
+	/*2= payload type + category*/
+
+	if (action > TDLS_SETUP_CONFIRM) {
+		/*just handle TDLS setup request/response/confirm */
+		PRINTM(MMSG, "Recv TDLS Action: peer=" MACSTR ", action=%d\n",
+		       MAC2STR(peer), action);
+		return;
+	}
+
+	sta_ptr = wlan_add_station_entry(priv, peer);
+	if (!sta_ptr)
+		return;
+	if (action == TDLS_SETUP_REQUEST) { /*setup request*/
+		sta_ptr->status = TDLS_NOT_SETUP;
+		PRINTM(MMSG, "Recv TDLS SETUP Request: peer=" MACSTR "\n",
+		       MAC2STR(peer));
+		wlan_hold_tdls_packets(priv, peer);
+		if (len < (sizeof(EthII_Hdr_t) + TDLS_REQ_FIX_LEN))
+			return;
+		pos = pbuf + sizeof(EthII_Hdr_t) + 4;
+		/*payload 1+ category 1 + action 1 +dialog 1*/
+		sta_ptr->capability = mlan_ntohs(*(t_u16 *)pos);
+		ie_len = len - sizeof(EthII_Hdr_t) - TDLS_REQ_FIX_LEN;
+		pos += 2;
+	} else if (action == 1) { /*setup respons*/
+		PRINTM(MMSG, "Recv TDLS SETUP Response: peer=" MACSTR "\n",
+		       MAC2STR(peer));
+		if (len < (sizeof(EthII_Hdr_t) + TDLS_RESP_FIX_LEN))
+			return;
+		pos = pbuf + sizeof(EthII_Hdr_t) + 6;
+		/*payload 1+ category 1 + action 1 +dialog 1 +status 2*/
+		sta_ptr->capability = mlan_ntohs(*(t_u16 *)pos);
+		ie_len = len - sizeof(EthII_Hdr_t) - TDLS_RESP_FIX_LEN;
+		pos += 2;
+	} else { /*setup confirm*/
+		PRINTM(MMSG, "Recv TDLS SETUP Confirm: peer=" MACSTR "\n",
+		       MAC2STR(peer));
+		if (len < (sizeof(EthII_Hdr_t) + TDLS_CONFIRM_FIX_LEN))
+			return;
+		pos = pbuf + sizeof(EthII_Hdr_t) + TDLS_CONFIRM_FIX_LEN;
+		/*payload 1+ category 1 + action 1 +dialog 1 + status 2*/
+		ie_len = len - sizeof(EthII_Hdr_t) - TDLS_CONFIRM_FIX_LEN;
+	}
+	for (end = pos + ie_len; pos + 1 < end; pos += 2 + pos[1]) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		switch (*pos) {
+		case SUPPORTED_RATES:
+			sta_ptr->rate_len =
+				MIN(pos[1], sizeof(sta_ptr->support_rate));
+			for (i = 0; i < sta_ptr->rate_len; i++)
+				sta_ptr->support_rate[i] = pos[2 + i];
+			break;
+		case EXTENDED_SUPPORTED_RATES:
+			rate_len = MIN(pos[1], sizeof(sta_ptr->support_rate) -
+						       sta_ptr->rate_len);
+			for (i = 0; i < rate_len; i++)
+				sta_ptr->support_rate[sta_ptr->rate_len + i] =
+					pos[2 + i];
+			sta_ptr->rate_len += rate_len;
+			break;
+		case HT_CAPABILITY:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->HTcap, pos,
+				   sizeof(IEEEtypes_HTCap_t),
+				   sizeof(IEEEtypes_HTCap_t));
+			sta_ptr->is_11n_enabled = 1;
+			DBG_HEXDUMP(MDAT_D, "TDLS HT capability",
+				    (t_u8 *)(&sta_ptr->HTcap),
+				    MIN(sizeof(IEEEtypes_HTCap_t),
+					MAX_DATA_DUMP_LEN));
+			break;
+		case HT_OPERATION:
+			memcpy_ext(priv->adapter, &sta_ptr->HTInfo, pos,
+				   sizeof(IEEEtypes_HTInfo_t),
+				   sizeof(IEEEtypes_HTInfo_t));
+			DBG_HEXDUMP(MDAT_D, "TDLS HT info",
+				    (t_u8 *)(&sta_ptr->HTInfo),
+				    MIN(sizeof(IEEEtypes_HTInfo_t),
+					MAX_DATA_DUMP_LEN));
+			break;
+		case BSSCO_2040:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->BSSCO_20_40,
+				   pos, sizeof(IEEEtypes_2040BSSCo_t),
+				   sizeof(IEEEtypes_2040BSSCo_t));
+			break;
+		case EXT_CAPABILITY:
+			sta_ptr->ExtCap.ieee_hdr.len =
+				MIN(pos[1], sizeof(ExtCap_t));
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->ExtCap, pos,
+				   sta_ptr->ExtCap.ieee_hdr.len +
+					   sizeof(IEEEtypes_Header_t),
+				   sizeof(IEEEtypes_ExtCap_t));
+			DBG_HEXDUMP(MDAT_D, "TDLS Extended capability",
+				    (t_u8 *)(&sta_ptr->ExtCap),
+				    sta_ptr->ExtCap.ieee_hdr.len + 2);
+			break;
+		case RSN_IE:
+			sta_ptr->rsn_ie.ieee_hdr.len =
+				MIN(pos[1], IEEE_MAX_IE_SIZE -
+						    sizeof(IEEEtypes_Header_t));
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->rsn_ie, pos,
+				   sta_ptr->rsn_ie.ieee_hdr.len +
+					   sizeof(IEEEtypes_Header_t),
+				   sizeof(IEEEtypes_Generic_t));
+			DBG_HEXDUMP(MDAT_D, "TDLS Rsn ie ",
+				    (t_u8 *)(&sta_ptr->rsn_ie),
+				    sta_ptr->rsn_ie.ieee_hdr.len +
+					    sizeof(IEEEtypes_Header_t));
+			break;
+		case QOS_INFO:
+			sta_ptr->qos_info = pos[2];
+			sta_ptr->is_wmm_enabled = MTRUE;
+			PRINTM(MDAT_D, "TDLS qos info %x\n", sta_ptr->qos_info);
+			break;
+		case VENDOR_SPECIFIC_221:
+			pvendor_ie = (IEEEtypes_VendorHeader_t *)pos;
+			if (!memcmp(priv->adapter, pvendor_ie->oui, wmm_oui,
+				    sizeof(wmm_oui))) {
+				sta_ptr->is_wmm_enabled = MTRUE;
+				sta_ptr->qos_info = pos[8]; /** qos info in wmm
+							       parameters in
+							       response and
+							       confirm */
+				PRINTM(MDAT_D, "TDLS qos info %x\n",
+				       sta_ptr->qos_info);
+			}
+			break;
+		case LINK_ID:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->link_ie,
+				   pos, sizeof(IEEEtypes_LinkIDElement_t),
+				   sizeof(IEEEtypes_LinkIDElement_t));
+			break;
+
+		case VHT_CAPABILITY:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->vht_cap,
+				   pos, sizeof(IEEEtypes_VHTCap_t),
+				   sizeof(IEEEtypes_VHTCap_t));
+			sta_ptr->is_11ac_enabled = 1;
+			DBG_HEXDUMP(MCMD_D, "Rx TDLS VHT capability",
+				    (t_u8 *)(&sta_ptr->vht_cap),
+				    MIN(sizeof(IEEEtypes_VHTCap_t),
+					MAX_DATA_DUMP_LEN));
+			break;
+		case VHT_OPERATION:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->vht_oprat,
+				   pos, sizeof(IEEEtypes_VHTOprat_t),
+				   sizeof(IEEEtypes_VHTOprat_t));
+			DBG_HEXDUMP(MCMD_D, "Rx TDLS VHT Operation",
+				    (t_u8 *)(&sta_ptr->vht_oprat),
+				    MIN(sizeof(IEEEtypes_VHTOprat_t),
+					MAX_DATA_DUMP_LEN));
+			break;
+		case AID_INFO:
+			memcpy_ext(priv->adapter, (t_u8 *)&sta_ptr->aid_info,
+				   pos, sizeof(IEEEtypes_AID_t),
+				   sizeof(IEEEtypes_AID_t));
+			DBG_HEXDUMP(MCMD_D, "Rx TDLS AID Info",
+				    (t_u8 *)(&sta_ptr->aid_info),
+				    MIN(sizeof(IEEEtypes_AID_t),
+					MAX_DATA_DUMP_LEN));
+			break;
+		case EXTENSION:
+			ext_ie = (IEEEtypes_Extension_t *)pos;
+			if (ext_ie->ext_id == HE_CAPABILITY) {
+				memcpy_ext(priv->adapter,
+					   (t_u8 *)&sta_ptr->tdls_he_cap, pos,
+					   ext_ie->ieee_hdr.len +
+						   sizeof(IEEEtypes_Header_t),
+					   sizeof(IEEEtypes_HECap_t));
+				sta_ptr->tdls_he_cap.ieee_hdr.len =
+					MIN(ext_ie->ieee_hdr.len,
+					    sizeof(IEEEtypes_HECap_t) -
+						    sizeof(IEEEtypes_Header_t));
+				sta_ptr->is_11ax_enabled = 1;
+				DBG_HEXDUMP(MCMD_D, "Rx TDLS HE Capability",
+					    (t_u8 *)(&sta_ptr->tdls_he_cap),
+					    MIN(sizeof(IEEEtypes_Header_t) +
+							sta_ptr->tdls_he_cap
+								.ieee_hdr.len,
+						sizeof(IEEEtypes_HECap_t)));
+			} else if (ext_ie->ext_id == HE_OPERATION) {
+				memcpy_ext(priv->adapter,
+					   (t_u8 *)&sta_ptr->he_op, pos,
+					   ext_ie->ieee_hdr.len +
+						   sizeof(IEEEtypes_Header_t),
+					   sizeof(IEEEtypes_HeOp_t));
+				ext_ie->ieee_hdr.len =
+					MIN(ext_ie->ieee_hdr.len,
+					    sizeof(IEEEtypes_HeOp_t) -
+						    sizeof(IEEEtypes_Header_t));
+				DBG_HEXDUMP(MCMD_D, "Rx TDLS HE Operation",
+					    (t_u8 *)(&sta_ptr->he_op),
+					    MIN(sizeof(IEEEtypes_Header_t) +
+							ext_ie->ieee_hdr.len,
+						MAX_DATA_DUMP_LEN));
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return;
+}
+
+/**
+ *  @brief This function get pxpd info for radiotap info
+ *
+ *  @param priv A pointer to pmlan_private
+ *  @param prx_pd   A pointer to RxPD
+ *  @param prt_info   A pointer to radiotap_info
+ *
+ *  @return        N/A
+ */
+void wlan_rxpdinfo_to_radiotapinfo(pmlan_private priv, RxPD *prx_pd,
+				   radiotap_info *prt_info)
+{
+	radiotap_info rt_info_tmp;
+	t_u8 rx_rate_info = 0;
+	t_u8 mcs_index = 0;
+	t_u8 format = 0;
+	t_u8 bw = 0;
+	t_u8 gi = 0;
+	t_u8 ldpc = 0;
+	t_u8 ext_rate_info = 0;
+	t_u8 nss = 0;
+	t_u8 dcm = 0;
+
+	memset(priv->adapter, &rt_info_tmp, 0x00, sizeof(rt_info_tmp));
+	rt_info_tmp.snr = prx_pd->snr;
+	rt_info_tmp.nf = prx_pd->nf;
+	rt_info_tmp.band_config = (prx_pd->rx_info & 0xf);
+	rt_info_tmp.chan_num = (prx_pd->rx_info & RXPD_CHAN_MASK) >> 5;
+	ext_rate_info = (t_u8)(prx_pd->rx_info >> 16);
+
+	rt_info_tmp.antenna = prx_pd->antenna;
+	rx_rate_info = prx_pd->rate_info;
+	if ((rx_rate_info & 0x3) == MLAN_RATE_FORMAT_HE) {
+		t_u8 gi_he = 0;
+		/* HE rate */
+		format = MLAN_RATE_FORMAT_HE;
+		mcs_index = MIN(prx_pd->rx_rate & 0xF, 0xb);
+		nss = ((prx_pd->rx_rate & 0xF0) >> 4);
+		nss = MIN(nss + 1, 2);
+		/* 20M: bw=0, 40M: bw=1, 80M: bw=2, 160M: bw=3 */
+		bw = (rx_rate_info & 0xC) >> 2;
+		gi = (rx_rate_info & 0x10) >> 4;
+		gi_he = (rx_rate_info & 0x80) >> 7;
+		gi = gi | gi_he;
+		dcm = (prx_pd->rx_info & RXPD_DCM_MASK) >> 16;
+	} else if ((rx_rate_info & 0x3) == MLAN_RATE_FORMAT_VHT) {
+		/* VHT rate */
+		format = MLAN_RATE_FORMAT_VHT;
+		mcs_index = MIN(prx_pd->rx_rate & 0xF, 9);
+		nss = ((prx_pd->rx_rate & 0xF0) >> 4);
+		nss = MIN(nss + 1, 2);
+		/* 20M: bw=0, 40M: bw=1, 80M: bw=2, 160M: bw=3 */
+		bw = (rx_rate_info & 0xC) >> 2;
+		/* LGI: gi =0, SGI: gi = 1 */
+		gi = (rx_rate_info & 0x10) >> 4;
+	} else if ((rx_rate_info & 0x3) == MLAN_RATE_FORMAT_HT) {
+		/* HT rate */
+		format = MLAN_RATE_FORMAT_HT;
+		mcs_index = prx_pd->rx_rate;
+		/* 20M: bw=0, 40M: bw=1 */
+		bw = (rx_rate_info & 0xC) >> 2;
+		/* LGI: gi =0, SGI: gi = 1 */
+		gi = (rx_rate_info & 0x10) >> 4;
+	} else {
+		/* LG rate */
+		format = MLAN_RATE_FORMAT_LG;
+		mcs_index = (prx_pd->rx_rate > MLAN_RATE_INDEX_OFDM0) ?
+				    prx_pd->rx_rate - 1 :
+				    prx_pd->rx_rate;
+	}
+	ldpc = rx_rate_info & 0x40;
+
+	rt_info_tmp.rate_info.mcs_index = mcs_index;
+	rt_info_tmp.rate_info.nss_index = nss;
+	rt_info_tmp.rate_info.dcm = dcm;
+	if (format == MLAN_RATE_FORMAT_HE) {
+		rt_info_tmp.rate_info.rate_info =
+			(ldpc << 5) | (format << 3) | (bw << 1) | (gi << 6);
+	} else
+		rt_info_tmp.rate_info.rate_info =
+			(ldpc << 5) | (format << 3) | (bw << 1) | gi;
+	rt_info_tmp.rate_info.bitrate =
+		wlan_index_to_data_rate(priv->adapter, prx_pd->rx_rate,
+					prx_pd->rate_info, ext_rate_info);
+
+	if (prx_pd->flags & RXPD_FLAG_EXTRA_HEADER)
+		memcpy_ext(priv->adapter, &rt_info_tmp.extra_info,
+			   (t_u8 *)prx_pd + sizeof(*prx_pd),
+			   sizeof(rt_info_tmp.extra_info),
+			   sizeof(rt_info_tmp.extra_info));
+
+	memset(priv->adapter, prt_info, 0x00, sizeof(radiotap_info));
+	memcpy_ext(priv->adapter, prt_info, &rt_info_tmp, sizeof(rt_info_tmp),
+		   sizeof(radiotap_info));
+
+	return;
+}
+
 /**
  *  @brief This function processes received packet and forwards it
  *          to kernel/upper layer
@@ -180,6 +509,7 @@ mlan_status wlan_process_rx_packet(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 						     0x00, 0x00, 0xf8};
 	t_u8 appletalk_aarp_type[2] = {0x80, 0xf3};
 	t_u8 ipx_snap_type[2] = {0x81, 0x37};
+	t_u8 tdls_action_type[2] = {0x89, 0x0d};
 #ifdef DRV_EMBEDDED_SUPPLICANT
 	t_u8 eapol_type[2] = {0x88, 0x8e};
 #endif
@@ -265,6 +595,12 @@ mlan_status wlan_process_rx_packet(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 			       "Bypass sending Gratuitous ARP frame to Kernel.\n");
 			goto done;
 		}
+		if (!memcmp(pmadapter, &prx_pkt->eth803_hdr.h803_len,
+			    tdls_action_type, sizeof(tdls_action_type))) {
+			wlan_process_tdls_action_frame(
+				priv, ((t_u8 *)prx_pd + prx_pd->rx_pkt_offset),
+				prx_pd->rx_pkt_length);
+		}
 		/* Chop off the RxPD */
 		hdr_chop = (t_u32)((t_ptr)&prx_pkt->eth803_hdr - (t_ptr)prx_pd);
 	}
@@ -289,6 +625,12 @@ mlan_status wlan_process_rx_packet(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 	PRINTM(MDATA, "%lu.%06lu : Data => kernel seq_num=%d tid=%d\n",
 	       pmbuf->out_ts_sec, pmbuf->out_ts_usec, prx_pd->seq_num,
 	       prx_pd->priority);
+	if (pmadapter->enable_net_mon) {
+		if (prx_pd->rx_pkt_type == PKT_TYPE_802DOT11) {
+			pmbuf->flags |= MLAN_BUF_FLAG_NET_MONITOR;
+			goto mon_process;
+		}
+	}
 
 #ifdef DRV_EMBEDDED_SUPPLICANT
 	if (supplicantIsEnabled(priv->psapriv) &&
@@ -307,6 +649,16 @@ mlan_status wlan_process_rx_packet(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 	}
 #endif
 
+mon_process:
+	if (pmbuf->flags & MLAN_BUF_FLAG_NET_MONITOR) {
+		// Use some rxpd space to save rxpd info for radiotap header
+		// We should insure radiotap_info is not bigger than RxPD
+		wlan_rxpdinfo_to_radiotapinfo(
+			priv, prx_pd,
+			(radiotap_info *)(pmbuf->pbuf + pmbuf->data_offset -
+					  sizeof(radiotap_info)));
+	}
+
 	if (MFALSE || priv->rx_pkt_info) {
 		ext_rate_info = (t_u8)(prx_pd->rx_info >> 16);
 		pmbuf->u.rx_info.data_rate =
@@ -354,6 +706,14 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	RxPD *prx_pd;
 	RxPacketHdr_t *prx_pkt;
+	RxPD *prx_pd2;
+	EthII_Hdr_t *peth_hdr2;
+	wlan_802_11_header *pwlan_hdr;
+	IEEEtypes_FrameCtl_t *frmctl;
+	pmlan_buffer pmbuf2 = MNULL;
+	mlan_802_11_mac_addr src_addr, dest_addr;
+	t_u16 hdr_len;
+	t_u8 snap_eth_hdr[5] = {0xaa, 0xaa, 0x03, 0x00, 0x00};
 	pmlan_private priv = pmadapter->priv[pmbuf->bss_index];
 	t_u8 ta[MLAN_MAC_ADDR_LENGTH];
 	t_u16 rx_pkt_type = 0;
@@ -367,7 +727,27 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	prx_pd = (RxPD *)(pmbuf->pbuf + pmbuf->data_offset);
 	/* Endian conversion */
 	endian_convert_RxPD(prx_pd);
+	if (prx_pd->flags & RXPD_FLAG_EXTRA_HEADER) {
+		endian_convert_RxPD_extra_header(
+			(rxpd_extra_info *)((t_u8 *)prx_pd + sizeof(*prx_pd)));
+	}
+	if (priv->adapter->pcard_info->v14_fw_api) {
+		t_u8 rxpd_rate_info_orig = prx_pd->rate_info;
+		prx_pd->rate_info = wlan_convert_v14_rx_rate_info(
+			priv, rxpd_rate_info_orig);
+		PRINTM(MINFO,
+		       "STA RX: v14_fw_api=%d rx_rate =%d rxpd_rate_info=0x%x->0x%x\n",
+		       priv->adapter->pcard_info->v14_fw_api, prx_pd->rx_rate,
+		       rxpd_rate_info_orig, prx_pd->rate_info);
+	}
 	rx_pkt_type = prx_pd->rx_pkt_type;
+	if (prx_pd->flags & RXPD_FLAG_PKT_EASYMESH) {
+		PRINTM_NETINTF(MDAT_D, priv);
+		PRINTM(MDAT_D, "Easymesh flags : 0x%x\n", prx_pd->flags);
+		ret = wlan_check_easymesh_pkt(priv, pmbuf, prx_pd);
+		if (ret != MLAN_STATUS_SUCCESS)
+			goto done;
+	}
 	prx_pkt = (RxPacketHdr_t *)((t_u8 *)prx_pd + prx_pd->rx_pkt_offset);
 
 	if ((prx_pd->rx_pkt_offset + prx_pd->rx_pkt_length) !=
@@ -419,11 +799,118 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 		}
 	}
 
+	if (pmadapter->enable_net_mon &&
+	    (prx_pd->flags & RXPD_FLAG_UCAST_PKT)) {
+		pwlan_hdr = (wlan_802_11_header *)((t_u8 *)prx_pd +
+						   prx_pd->rx_pkt_offset);
+		frmctl = (IEEEtypes_FrameCtl_t *)pwlan_hdr;
+		if (frmctl->type == 0x02) {
+			/* This is a valid unicast destined data packet, with
+			 * 802.11 and rtap headers attached. Duplicate this
+			 * packet and process this copy as a sniffed packet,
+			 * meant for monitor iface
+			 */
+			pmbuf2 = wlan_alloc_mlan_buffer(pmadapter,
+							pmbuf->data_len,
+							MLAN_RX_HEADER_LEN,
+							MOAL_ALLOC_MLAN_BUFFER);
+			if (!pmbuf2) {
+				PRINTM(MERROR,
+				       "Unable to allocate mlan_buffer for Rx");
+				PRINTM(MERROR, "sniffed packet\n");
+			} else {
+				pmbuf2->bss_index = pmbuf->bss_index;
+				pmbuf2->buf_type = pmbuf->buf_type;
+				pmbuf2->priority = pmbuf->priority;
+				pmbuf2->in_ts_sec = pmbuf->in_ts_sec;
+				pmbuf2->in_ts_usec = pmbuf->in_ts_usec;
+				pmbuf2->data_len = pmbuf->data_len;
+				memcpy(pmadapter,
+				       pmbuf2->pbuf + pmbuf2->data_offset,
+				       pmbuf->pbuf + pmbuf->data_offset,
+				       pmbuf->data_len);
+
+				prx_pd2 = (RxPD *)(pmbuf2->pbuf +
+						   pmbuf2->data_offset);
+				/* set pkt type of duplicated pkt to 802.11 */
+				prx_pd2->rx_pkt_type = PKT_TYPE_802DOT11;
+				wlan_process_rx_packet(pmadapter, pmbuf2);
+			}
+
+			/* Now, process this pkt as a normal data packet.
+			 * rx_pkt_offset points to the 802.11 hdr. Construct
+			 * 802.3 header from 802.11 hdr fields and attach it
+			 * just before the payload.
+			 */
+			memcpy(pmadapter, (t_u8 *)&dest_addr, pwlan_hdr->addr1,
+			       sizeof(pwlan_hdr->addr1));
+			memcpy(pmadapter, (t_u8 *)&src_addr, pwlan_hdr->addr2,
+			       sizeof(pwlan_hdr->addr2));
+
+			hdr_len = sizeof(wlan_802_11_header);
+
+			/* subtract mac addr field size for 3 address mac80211
+			 * header */
+			if (!(frmctl->from_ds && frmctl->to_ds))
+				hdr_len -= sizeof(mlan_802_11_mac_addr);
+
+			/* add 2 bytes of qos ctrl flags */
+			if (frmctl->sub_type & QOS_DATA)
+				hdr_len += 2;
+
+			if (prx_pd->rx_pkt_type == PKT_TYPE_AMSDU) {
+				/* no need to generate 802.3 hdr, update pkt
+				 * offset */
+				prx_pd->rx_pkt_offset += hdr_len;
+				prx_pd->rx_pkt_length -= hdr_len;
+			} else {
+				/* skip 6-byte snap and 2-byte type */
+				if (memcmp(pmadapter,
+					   (t_u8 *)pwlan_hdr + hdr_len,
+					   snap_eth_hdr,
+					   sizeof(snap_eth_hdr)) == 0)
+					hdr_len += 8;
+
+				peth_hdr2 =
+					(EthII_Hdr_t *)((t_u8 *)prx_pd +
+							prx_pd->rx_pkt_offset +
+							hdr_len -
+							sizeof(EthII_Hdr_t));
+				memcpy(pmadapter, peth_hdr2->dest_addr,
+				       (t_u8 *)&dest_addr,
+				       sizeof(peth_hdr2->dest_addr));
+				memcpy(pmadapter, peth_hdr2->src_addr,
+				       (t_u8 *)&src_addr,
+				       sizeof(peth_hdr2->src_addr));
+
+				/* Update the rx_pkt_offset to point the 802.3
+				 * hdr */
+				prx_pd->rx_pkt_offset +=
+					(hdr_len - sizeof(EthII_Hdr_t));
+				prx_pd->rx_pkt_length -=
+					(hdr_len - sizeof(EthII_Hdr_t));
+			}
+			/* update the prx_pkt pointer */
+			prx_pkt = (RxPacketHdr_t *)((t_u8 *)prx_pd +
+						    prx_pd->rx_pkt_offset);
+		} else {
+			pmbuf->status_code = MLAN_ERROR_PKT_SIZE_INVALID;
+			ret = MLAN_STATUS_FAILURE;
+			PRINTM(MERROR,
+			       "Drop invalid unicast sniffer pkt, subType=0x%x, flag=0x%x, pkt_type=%d\n",
+			       frmctl->sub_type, prx_pd->flags,
+			       prx_pd->rx_pkt_type);
+			wlan_free_mlan_buffer(pmadapter, pmbuf);
+			goto done;
+		}
+	}
+
 	/*
 	 * If the packet is not an unicast packet then send the packet
 	 * directly to os. Don't pass thru rx reordering
 	 */
-	if ((!IS_11N_ENABLED(priv)) ||
+	if ((!IS_11N_ENABLED(priv) &&
+	     !(prx_pd->flags & RXPD_FLAG_PKT_DIRECT_LINK)) ||
 	    memcmp(priv->adapter, priv->curr_addr,
 		   prx_pkt->eth803_hdr.dest_addr, MLAN_MAC_ADDR_LENGTH)) {
 		priv->snr = prx_pd->snr;
@@ -432,7 +919,8 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 		goto done;
 	}
 
-	if (queuing_ra_based(priv)) {
+	if (queuing_ra_based(priv) ||
+	    (prx_pd->flags & RXPD_FLAG_PKT_DIRECT_LINK)) {
 		memcpy_ext(pmadapter, ta, prx_pkt->eth803_hdr.src_addr,
 			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 		if (prx_pd->priority < MAX_NUM_TID) {
@@ -444,8 +932,17 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 					prx_pd->seq_num;
 				sta_ptr->snr = prx_pd->snr;
 				sta_ptr->nf = prx_pd->nf;
+				if (prx_pd->flags & RXPD_FLAG_PKT_DIRECT_LINK) {
+					pmadapter->callbacks
+						.moal_updata_peer_signal(
+							pmadapter->pmoal_handle,
+							pmbuf->bss_index, ta,
+							prx_pd->snr,
+							prx_pd->nf);
+				}
 			}
-			if (!sta_ptr || !sta_ptr->is_11n_enabled) {
+			if (!sta_ptr || (!sta_ptr->is_11n_enabled &&
+					 !sta_ptr->is_11ax_enabled)) {
 				wlan_process_rx_packet(pmadapter, pmbuf);
 				goto done;
 			}
@@ -462,9 +959,14 @@ mlan_status wlan_ops_sta_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	}
 	if ((priv->port_ctrl_mode == MTRUE && priv->port_open == MFALSE) &&
 	    (rx_pkt_type != PKT_TYPE_BAR)) {
-		mlan_11n_rxreorder_pkt(priv, prx_pd->seq_num, prx_pd->priority,
-				       ta, (t_u8)prx_pd->rx_pkt_type,
-				       (t_void *)RX_PKT_DROPPED_IN_FW);
+		if (MLAN_STATUS_SUCCESS !=
+		    mlan_11n_rxreorder_pkt(priv, prx_pd->seq_num,
+					   prx_pd->priority, ta,
+					   (t_u8)prx_pd->rx_pkt_type,
+					   (t_void *)RX_PKT_DROPPED_IN_FW))
+			PRINTM(MINFO, "RX pkt reordering failure seq_num:%d\n",
+			       prx_pd->seq_num);
+
 		if (rx_pkt_type == PKT_TYPE_AMSDU) {
 			pmbuf->data_len = prx_pd->rx_pkt_length;
 			pmbuf->data_offset += prx_pd->rx_pkt_offset;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c
old mode 100644
new mode 100755
index 737f2baca..7f274b00e
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_sta_tx.c
@@ -4,7 +4,7 @@
  *  transmission in MLAN module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -125,6 +125,13 @@ t_void *wlan_ops_sta_process_txpd(t_void *priv, pmlan_buffer pmbuf)
 				MRVDRV_TxPD_POWER_MGMT_LAST_PACKET;
 		}
 	}
+	if (pmbuf->flags & MLAN_BUF_FLAG_TDLS)
+		plocal_tx_pd->flags |= MRVDRV_TxPD_FLAGS_TDLS_PACKET;
+	if (pmbuf->flags & MLAN_BUF_FLAG_EASYMESH) {
+		plocal_tx_pd->flags |= MRVDRV_TxPD_FLAGS_EASYMESH;
+		memcpy_ext(pmpriv->adapter, plocal_tx_pd->ra_mac, pmbuf->mac,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	}
 	/* Offset of actual data */
 	plocal_tx_pd->tx_pkt_offset = (t_u16)(
 		(t_ptr)pmbuf->pbuf + pmbuf->data_offset - (t_ptr)plocal_tx_pd);
@@ -166,6 +173,37 @@ t_void *wlan_ops_sta_process_txpd(t_void *priv, pmlan_buffer pmbuf)
 			plocal_tx_pd->tx_control |= TXPD_RETRY_ENABLE;
 		}
 	}
+	if (pmbuf->flags & MLAN_BUF_FLAG_MC_AGGR_PKT) {
+		tx_ctrl *ctrl = (tx_ctrl *)&plocal_tx_pd->tx_control;
+		mc_tx_ctrl *mc_ctrl =
+			(mc_tx_ctrl *)&plocal_tx_pd->pkt_delay_2ms;
+		plocal_tx_pd->tx_pkt_type = PKT_TYPE_802DOT11_MC_AGGR;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_START_CYCLE)
+			ctrl->mc_cycle_start = MTRUE;
+		else
+			ctrl->mc_cycle_start = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_END_CYCLE)
+			ctrl->mc_cycle_end = MTRUE;
+		else
+			ctrl->mc_cycle_end = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_START_AMPDU)
+			ctrl->mc_ampdu_start = MTRUE;
+		else
+			ctrl->mc_ampdu_start = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_END_AMPDU)
+			ctrl->mc_ampdu_end = MTRUE;
+		else
+			ctrl->mc_ampdu_end = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_RETRY)
+			ctrl->mc_pkt_retry = MTRUE;
+		else
+			ctrl->mc_pkt_retry = MFALSE;
+		ctrl->bw = pmbuf->u.mc_tx_info.bandwidth & 0x7;
+		ctrl->tx_rate = pmbuf->u.mc_tx_info.mcs_index & 0x1f;
+		mc_ctrl->abs_tsf_expirytime =
+			wlan_cpu_to_le32(pmbuf->u.mc_tx_info.pkt_expiry);
+		mc_ctrl->mc_seq = wlan_cpu_to_le16(pmbuf->u.mc_tx_info.seq_num);
+	}
 	endian_convert_TxPD(plocal_tx_pd);
 
 	/* Adjust the data offset and length to include TxPD in pmbuf */
@@ -223,6 +261,12 @@ mlan_status wlan_send_null_packet(pmlan_private priv, t_u8 flags)
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
+#if defined(USB)
+	if (!wlan_is_port_ready(pmadapter, priv->port_index)) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+#endif
 
 	pmbuf = wlan_alloc_mlan_buffer(pmadapter, data_len, 0,
 				       MOAL_MALLOC_BUFFER);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c
old mode 100644
new mode 100755
index caf25708f..d97e36dd3
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_txrx.c
@@ -4,7 +4,7 @@
  *  @brief This file contains the handling of TX/RX in MLAN
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -124,9 +124,15 @@ mlan_status wlan_process_tx(pmlan_private priv, pmlan_buffer pmbuf,
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA)
 		plocal_tx_pd = (TxPD *)(head_ptr + priv->intf_hr_len);
 #endif
-
-	ret = pmadapter->ops.host_to_card(priv, MLAN_TYPE_DATA, pmbuf,
-					  tx_param);
+	if (pmadapter->tp_state_on)
+		pmadapter->callbacks.moal_tp_accounting(pmadapter->pmoal_handle,
+							pmbuf, 4);
+	if (pmadapter->tp_state_drop_point == 4)
+		goto done;
+	else {
+		ret = pmadapter->ops.host_to_card(priv, MLAN_TYPE_DATA, pmbuf,
+						  tx_param);
+	}
 done:
 	switch (ret) {
 #ifdef USB
@@ -253,7 +259,6 @@ mlan_status wlan_recv_packet_complete(pmlan_adapter pmadapter,
 				      pmlan_buffer pmbuf, mlan_status status)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	pmlan_callbacks pcb;
 
 	ENTER();
 
@@ -263,7 +268,6 @@ mlan_status wlan_recv_packet_complete(pmlan_adapter pmadapter,
 		return MLAN_STATUS_FAILURE;
 	}
 
-	pcb = &pmadapter->callbacks;
 	MASSERT(pmbuf->bss_index < pmadapter->priv_num);
 
 	if (pmbuf->pparent) {
@@ -311,7 +315,28 @@ t_void wlan_add_buf_bypass_txqueue(mlan_adapter *pmadapter, pmlan_buffer pmbuf)
  */
 INLINE t_u8 wlan_bypass_tx_list_empty(mlan_adapter *pmadapter)
 {
-	return (pmadapter->bypass_pkt_count) ? MFALSE : MTRUE;
+#if defined(USB)
+	if (IS_USB(pmadapter->card_type)) {
+		pmlan_callbacks pcb = &pmadapter->callbacks;
+		pmlan_private priv;
+		int j = 0;
+		for (j = 0; j < pmadapter->priv_num; ++j) {
+			priv = pmadapter->priv[j];
+			if (priv) {
+				if (!wlan_is_port_ready(pmadapter,
+							priv->port_index))
+					continue;
+				if (util_peek_list(pmadapter->pmoal_handle,
+						   &priv->bypass_txq,
+						   pcb->moal_spin_lock,
+						   pcb->moal_spin_unlock))
+					return MFALSE;
+			}
+		}
+		return MTRUE;
+	} else
+#endif
+		return (pmadapter->bypass_pkt_count) ? MFALSE : MTRUE;
 }
 
 /**
@@ -360,6 +385,11 @@ t_void wlan_process_bypass_tx(pmlan_adapter pmadapter)
 		for (j = 0; j < pmadapter->priv_num; ++j) {
 			priv = pmadapter->priv[j];
 			if (priv) {
+#if defined(USB)
+				if (!wlan_is_port_ready(pmadapter,
+							priv->port_index))
+					continue;
+#endif
 				pmbuf = (pmlan_buffer)util_dequeue_list(
 					pmadapter->pmoal_handle,
 					&priv->bypass_txq,
@@ -416,3 +446,57 @@ t_void wlan_process_bypass_tx(pmlan_adapter pmadapter)
 		 !wlan_bypass_tx_list_empty(pmadapter));
 	LEAVE();
 }
+
+/**
+ *  @brief This function will convert 802.11 header to 802.3 header
+	   and save the backhaul station aid to pmbuf
+ *
+ *  @param priv    A pointer to mlan_private
+ *  @param pmbuf   A pointer to mlan_buffer
+ *  @param prx_pd  A pointer to RxPD
+ *
+ *  @return	MLAN_STATUS_PENDING --success, otherwise fail
+ */
+mlan_status wlan_check_easymesh_pkt(mlan_private *priv, pmlan_buffer pmbuf,
+				    RxPD *prx_pd)
+{
+	Eth803Hdr_t *eth_header = MNULL;
+	sta_node *sta_ptr = MNULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u8 *pos = MNULL;
+	t_u32 tmp = 0;
+
+	ENTER();
+
+	pos = (t_u8 *)prx_pd + prx_pd->rx_pkt_offset;
+	eth_header = (Eth803Hdr_t *)pos;
+
+	PRINTM(MDAT_D,
+	       "Rx Easymesh ETH header destination address: " FULL_MACSTR
+	       "\nETH header source address: " FULL_MACSTR "\n",
+	       FULL_MAC2STR(eth_header->dest_addr),
+	       FULL_MAC2STR(eth_header->src_addr));
+
+	if (priv->bss_type == MLAN_BSS_TYPE_UAP) {
+		pmbuf->flags |= MLAN_BUF_FLAG_EASYMESH;
+		memcpy_ext(priv->adapter, pmbuf->mac, prx_pd->ta_mac,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+
+		sta_ptr = wlan_get_station_entry(priv, prx_pd->ta_mac);
+		if (!sta_ptr) {
+			PRINTM(MERROR,
+			       "Easymesh Error! Can't find station in the station list\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+
+		/* Save station aid to pmbuf and send it to moal */
+		tmp = (t_u32)sta_ptr->aid;
+		pmbuf->priority |= (tmp << 24);
+		PRINTM(MDAT_D, "Easymesh: Rx for VLAN " FULL_MACSTR "\n",
+		       FULL_MAC2STR(prx_pd->ta_mac));
+	}
+done:
+	LEAVE();
+	return ret;
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h
old mode 100644
new mode 100755
index f6f85b851..2425ebc1d
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap.h
@@ -4,7 +4,7 @@
  *  of uap functionalities
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_cmdevent.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_cmdevent.c
old mode 100644
new mode 100755
index 86a6e72d1..0aab60b14
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_cmdevent.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_cmdevent.c
@@ -3,7 +3,7 @@
  *  @brief This file contains the handling of AP mode command and event
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -59,10 +59,10 @@ Change log:
  *  @param pdata_buf    A pointer to data buffer
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_cmd_set_get_band_steering_cfg(pmlan_private pmpriv,
-					       HostCmd_DS_COMMAND *cmd,
-					       t_u16 cmd_action,
-					       t_void *pdata_buf)
+static mlan_status wlan_cmd_set_get_band_steering_cfg(pmlan_private pmpriv,
+						      HostCmd_DS_COMMAND *cmd,
+						      t_u16 cmd_action,
+						      t_void *pdata_buf)
 {
 	mlan_ds_band_steer_cfg *pband_steer_cfg =
 		(mlan_ds_band_steer_cfg *)pdata_buf;
@@ -90,9 +90,10 @@ mlan_status wlan_cmd_set_get_band_steering_cfg(pmlan_private pmpriv,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_ret_set_get_band_steering_cfg(mlan_private *pmpriv,
-					       HostCmd_DS_COMMAND *resp,
-					       mlan_ioctl_req *pioctl_buf)
+static mlan_status
+wlan_ret_set_get_band_steering_cfg(mlan_private *pmpriv,
+				   HostCmd_DS_COMMAND *resp,
+				   mlan_ioctl_req *pioctl_buf)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	HostCmd_DS_BAND_STEERING *pband_steer_info =
@@ -123,10 +124,10 @@ mlan_status wlan_ret_set_get_band_steering_cfg(mlan_private *pmpriv,
  *  @param pdata_buf    A pointer to data buffer
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_cmd_set_get_beacon_stuck_cfg(IN pmlan_private pmpriv,
-					      IN HostCmd_DS_COMMAND *cmd,
-					      IN t_u16 cmd_action,
-					      IN t_void *pdata_buf)
+static mlan_status wlan_cmd_set_get_beacon_stuck_cfg(IN pmlan_private pmpriv,
+						     IN HostCmd_DS_COMMAND *cmd,
+						     IN t_u16 cmd_action,
+						     IN t_void *pdata_buf)
 {
 	HostCmd_DS_BEACON_STUCK_CFG *pbeacon_stuck_param_cfg =
 		(HostCmd_DS_BEACON_STUCK_CFG *)(pdata_buf + sizeof(t_u32));
@@ -154,9 +155,9 @@ mlan_status wlan_cmd_set_get_beacon_stuck_cfg(IN pmlan_private pmpriv,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_ret_set_get_beacon_stuck_cfg(mlan_private *pmpriv,
-					      HostCmd_DS_COMMAND *resp,
-					      mlan_ioctl_req *pioctl_buf)
+static mlan_status wlan_ret_set_get_beacon_stuck_cfg(mlan_private *pmpriv,
+						     HostCmd_DS_COMMAND *resp,
+						     mlan_ioctl_req *pioctl_buf)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	HostCmd_DS_BEACON_STUCK_CFG *pbeacon_stuck_param_cfg =
@@ -198,9 +199,9 @@ static mlan_status uap_process_cmdresp_error(mlan_private *pmpriv,
 	mlan_status ret = MLAN_STATUS_FAILURE;
 
 	ENTER();
-	if (resp->command != HostCmd_CMD_WMM_PARAM_CONFIG ||
+	if (resp->command != HostCmd_CMD_WMM_PARAM_CONFIG &&
 	    resp->command != HostCmd_CMD_CHAN_REGION_CFG)
-		PRINTM(MERROR, "CMD_RESP: cmd %#x error, result=%#x\n",
+		PRINTM(MINFO, "CMD_RESP: cmd %#x error, result=%#x\n",
 		       resp->command, resp->result);
 	if (pioctl_buf)
 		pioctl_buf->status_code = resp->result;
@@ -324,7 +325,7 @@ static mlan_status uap_process_cmdresp_error(mlan_private *pmpriv,
  *
  *  @return	   A pointer to structure sta_node
  */
-void wlan_notify_station_deauth(mlan_private *priv)
+static void wlan_notify_station_deauth(mlan_private *priv)
 {
 	sta_node *sta_ptr;
 	t_u8 event_buf[100];
@@ -707,15 +708,13 @@ static mlan_status wlan_uap_cmd_ap_config(pmlan_private pmpriv,
 	MrvlIETypes_HTCap_t *tlv_htcap = MNULL;
 	MrvlIEtypes_wmm_parameter_t *tlv_wmm_parameter = MNULL;
 	MrvlIEtypes_preamble_t *tlv_preamble = MNULL;
+	MrvlIEtypes_MultiAp_t *tlv_multi_ap = MNULL;
 
 	t_u32 cmd_size = 0;
 	t_u8 zero_mac[] = {0, 0, 0, 0, 0, 0};
 	t_u16 i;
 	t_u16 ac;
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 	int rx_mcs_supp = 0;
-#endif
 
 	ENTER();
 	if (pioctl_buf == MNULL) {
@@ -1098,7 +1097,9 @@ static mlan_status wlan_uap_cmd_ap_config(pmlan_private pmpriv,
 		tlv_auth_type = (MrvlIEtypes_auth_type_t *)tlv;
 		tlv_auth_type->header.type =
 			wlan_cpu_to_le16(TLV_TYPE_AUTH_TYPE);
-		tlv_auth_type->header.len = wlan_cpu_to_le16(sizeof(t_u8));
+		tlv_auth_type->header.len =
+			wlan_cpu_to_le16(sizeof(MrvlIEtypes_auth_type_t) -
+					 sizeof(MrvlIEtypesHeader_t));
 		tlv_auth_type->auth_type =
 			(t_u8)bss->param.bss_config.auth_mode;
 		cmd_size += sizeof(MrvlIEtypes_auth_type_t);
@@ -1340,9 +1341,8 @@ static mlan_status wlan_uap_cmd_ap_config(pmlan_private pmpriv,
 		memcpy_ext(pmpriv->adapter, tlv_htcap->ht_cap.supported_mcs_set,
 			   bss->param.bss_config.supported_mcs_set, 16,
 			   sizeof(tlv_htcap->ht_cap.supported_mcs_set));
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(SD9097) || defined(USB9097)
 		if (IS_CARD9098(pmpriv->adapter->card_type) ||
+		    IS_CARDIW62X(pmpriv->adapter->card_type) ||
 		    IS_CARD9097(pmpriv->adapter->card_type)) {
 			if (bss->param.bss_config.supported_mcs_set[0]) {
 				if (bss->param.bss_config.bandcfg.chanBand ==
@@ -1367,7 +1367,6 @@ static mlan_status wlan_uap_cmd_ap_config(pmlan_private pmpriv,
 				}
 			}
 		}
-#endif
 		tlv_htcap->ht_cap.ht_ext_cap =
 			wlan_cpu_to_le16(bss->param.bss_config.ht_ext_cap);
 		tlv_htcap->ht_cap.tx_bf_cap =
@@ -1456,12 +1455,21 @@ static mlan_status wlan_uap_cmd_ap_config(pmlan_private pmpriv,
 			wlan_cpu_to_le16(sizeof(MrvlIEtypes_preamble_t) -
 					 sizeof(MrvlIEtypesHeader_t));
 		tlv_preamble->preamble_type =
-			wlan_cpu_to_le16(bss->param.bss_config.preamble_type);
+			bss->param.bss_config.preamble_type;
 
 		cmd_size += sizeof(MrvlIEtypes_preamble_t);
 		tlv += sizeof(MrvlIEtypes_preamble_t);
 	}
-
+	if (bss->param.bss_config.multi_ap_flag) {
+		/** Add multi AP tlv here */
+		tlv_multi_ap = (MrvlIEtypes_MultiAp_t *)tlv;
+		tlv_multi_ap->header.type = wlan_cpu_to_le16(TLV_TYPE_MULTI_AP);
+		tlv_multi_ap->header.len =
+			wlan_cpu_to_le16(sizeof(tlv_multi_ap->flag));
+		tlv_multi_ap->flag = bss->param.bss_config.multi_ap_flag;
+		cmd_size += sizeof(MrvlIEtypes_MultiAp_t);
+		tlv += sizeof(MrvlIEtypes_MultiAp_t);
+	}
 	cmd->size = (t_u16)wlan_cpu_to_le16(cmd_size);
 	PRINTM(MCMND, "AP config: cmd_size=%d\n", cmd_size);
 	LEAVE();
@@ -1511,6 +1519,10 @@ static mlan_status wlan_uap_cmd_sys_configure(pmlan_private pmpriv,
 	t_u16 req_len = 0, travel_len = 0;
 	custom_ie *cptr = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	MrvlIEtypes_wacp_mode_t *tlv_wacp_mode = MNULL;
+	MrvlIEtypes_action_chan_switch_t *tlv_chan_switch = MNULL;
+	IEEEtypes_ChanSwitchAnn_t *csa_ie = MNULL;
+	IEEEtypes_ExtChanSwitchAnn_t *ecsa_ie = MNULL;
 
 	ENTER();
 
@@ -1828,6 +1840,56 @@ static mlan_status wlan_uap_cmd_sys_configure(pmlan_private pmpriv,
 				       bss->param.ap_channel.bandcfg,
 				       bss->param.ap_channel.channel);
 			}
+		} else if (bss->sub_command == MLAN_OID_ACTION_CHAN_SWITCH) {
+			cmd->size = sizeof(HostCmd_DS_SYS_CONFIG) - 1 +
+				    S_DS_GEN +
+				    sizeof(MrvlIEtypes_action_chan_switch_t);
+			tlv_chan_switch = (MrvlIEtypes_action_chan_switch_t *)
+						  sys_config->tlv_buffer;
+			tlv_chan_switch->header.type = wlan_cpu_to_le16(
+				MRVL_ACTION_CHAN_SWITCH_ANNOUNCE);
+			tlv_chan_switch->mode = bss->param.chanswitch.mode;
+			tlv_chan_switch->num_pkt =
+				bss->param.chanswitch.chan_switch_count;
+			if (bss->param.chanswitch.new_oper_class) {
+				tlv_chan_switch->header.len = wlan_cpu_to_le16(
+					sizeof(MrvlIEtypes_action_chan_switch_t) -
+					sizeof(MrvlIEtypesHeader_t) +
+					sizeof(IEEEtypes_ExtChanSwitchAnn_t));
+				ecsa_ie = (IEEEtypes_ExtChanSwitchAnn_t *)
+						  tlv_chan_switch->ie_buf;
+				ecsa_ie->element_id = EXTEND_CHANNEL_SWITCH_ANN;
+				ecsa_ie->len =
+					sizeof(IEEEtypes_ExtChanSwitchAnn_t) -
+					sizeof(IEEEtypes_Header_t);
+				ecsa_ie->chan_switch_mode =
+					bss->param.chanswitch.chan_switch_mode;
+				ecsa_ie->chan_switch_count = 0;
+				ecsa_ie->new_channel_num =
+					bss->param.chanswitch.new_channel_num;
+				ecsa_ie->new_oper_class =
+					bss->param.chanswitch.new_oper_class;
+				cmd->size +=
+					sizeof(IEEEtypes_ExtChanSwitchAnn_t);
+			} else {
+				tlv_chan_switch->header.len = wlan_cpu_to_le16(
+					sizeof(MrvlIEtypes_action_chan_switch_t) -
+					sizeof(MrvlIEtypesHeader_t) +
+					sizeof(IEEEtypes_ChanSwitchAnn_t));
+				csa_ie = (IEEEtypes_ChanSwitchAnn_t *)
+						 tlv_chan_switch->ie_buf;
+				csa_ie->element_id = CHANNEL_SWITCH_ANN;
+				csa_ie->len =
+					sizeof(IEEEtypes_ChanSwitchAnn_t) -
+					sizeof(IEEEtypes_Header_t);
+				csa_ie->chan_switch_mode =
+					bss->param.chanswitch.chan_switch_mode;
+				csa_ie->chan_switch_count = 0;
+				csa_ie->new_channel_num =
+					bss->param.chanswitch.new_channel_num;
+				cmd->size += sizeof(IEEEtypes_ChanSwitchAnn_t);
+			}
+			cmd->size = wlan_cpu_to_le16(cmd->size);
 		} else if ((bss->sub_command == MLAN_OID_UAP_BSS_CONFIG) &&
 			   (cmd_action == HostCmd_ACT_GEN_SET)) {
 			ret = wlan_uap_cmd_ap_config(pmpriv, cmd, cmd_action,
@@ -1899,6 +1961,21 @@ static mlan_status wlan_uap_cmd_sys_configure(pmlan_private pmpriv,
 						misc->param.cust_ie.len);
 			}
 		}
+		if (misc->sub_command == MLAN_OID_MISC_WACP_MODE) {
+			tlv_wacp_mode = (MrvlIEtypes_wacp_mode_t *)
+						sys_config->tlv_buffer;
+			tlv_wacp_mode->header.type =
+				wlan_cpu_to_le16(TLV_TYPE_UAP_WACP_MODE);
+			tlv_wacp_mode->header.len =
+				wlan_cpu_to_le16(sizeof(t_u8));
+			if (cmd_action == HostCmd_ACT_GEN_SET) {
+				tlv_wacp_mode->wacp_mode =
+					misc->param.wacp_mode;
+			}
+			cmd->size = wlan_cpu_to_le16(
+				sizeof(HostCmd_DS_SYS_CONFIG) - 1 + S_DS_GEN +
+				sizeof(MrvlIEtypes_wacp_mode_t));
+		}
 	}
 done:
 	LEAVE();
@@ -2157,6 +2234,9 @@ static mlan_status wlan_uap_ret_cmd_ap_config(pmlan_private pmpriv,
 			tlv_chan_band = (MrvlIEtypes_channel_band_t *)tlv;
 			bss->param.bss_config.bandcfg = tlv_chan_band->bandcfg;
 			bss->param.bss_config.channel = tlv_chan_band->channel;
+			pmpriv->uap_channel = tlv_chan_band->channel;
+			pmpriv->uap_bandwidth =
+				tlv_chan_band->bandcfg.chanWidth;
 			pmpriv->uap_state_chan_cb.bandcfg =
 				tlv_chan_band->bandcfg;
 			pmpriv->uap_state_chan_cb.channel =
@@ -2180,6 +2260,13 @@ static mlan_status wlan_uap_ret_cmd_ap_config(pmlan_private pmpriv,
 			tlv_auth_type = (MrvlIEtypes_auth_type_t *)tlv;
 			bss->param.bss_config.auth_mode =
 				tlv_auth_type->auth_type;
+			if (tlv_len == (sizeof(MrvlIEtypes_auth_type_t) -
+					sizeof(MrvlIEtypesHeader_t))) {
+				bss->param.bss_config.pwe_derivation =
+					tlv_auth_type->PWE_derivation;
+				bss->param.bss_config.transition_disable =
+					tlv_auth_type->transition_disable;
+			}
 			break;
 		case TLV_TYPE_UAP_ENCRYPT_PROTOCOL:
 			tlv_encrypt_protocol =
@@ -2208,6 +2295,11 @@ static mlan_status wlan_uap_ret_cmd_ap_config(pmlan_private pmpriv,
 				bss->param.bss_config.wpa_cfg
 					.pairwise_cipher_wpa2 =
 					tlv_pwk_cipher->pairwise_cipher;
+			if (wlan_le16_to_cpu(tlv_pwk_cipher->protocol) &
+			    PROTOCOL_OWE)
+				bss->param.bss_config.wpa_cfg
+					.pairwise_cipher_wpa2 =
+					tlv_pwk_cipher->pairwise_cipher;
 			if (wlan_le16_to_cpu(tlv_pwk_cipher->protocol) &
 			    PROTOCOL_WPA3_SAE)
 				bss->param.bss_config.wpa_cfg
@@ -2390,7 +2482,7 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 					   mlan_ioctl_req *pioctl_buf)
 {
 	int resp_len = 0, travel_len = 0;
-	int i = 0;
+	t_u32 i = 0;
 	custom_ie *cptr;
 	HostCmd_DS_SYS_CONFIG *sys_config =
 		(HostCmd_DS_SYS_CONFIG *)&resp->params.sys_config;
@@ -2414,6 +2506,8 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 	MrvlIEtypes_uap_max_sta_cnt_t *tlv_uap_max_sta = MNULL;
 
 	ENTER();
+	sys_config->action = wlan_le16_to_cpu(sys_config->action);
+
 	if (pioctl_buf) {
 		if (pioctl_buf->req_id == MLAN_IOCTL_BSS) {
 			bss = (mlan_ds_bss *)pioctl_buf->pbuf;
@@ -2532,7 +2626,7 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 						0;
 					for (i = 0;
 					     i <
-					     wlan_le16_to_cpu(
+					     (int)wlan_le16_to_cpu(
 						     tlv_chan_list->header.len) /
 						     sizeof(ChanScanParamSet_t);
 					     i++) {
@@ -2583,8 +2677,17 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 						chan_band_tlv->bandcfg;
 					bss->param.ap_channel.channel =
 						chan_band_tlv->channel;
+					bss->param.ap_channel.center_chan = 0;
 					bss->param.ap_channel.is_11n_enabled =
 						pmpriv->is_11n_enabled;
+					pmpriv->uap_channel =
+						chan_band_tlv->channel;
+					pmpriv->uap_bandwidth =
+						chan_band_tlv->bandcfg.chanWidth;
+					pmpriv->uap_state_chan_cb.bandcfg =
+						chan_band_tlv->bandcfg;
+					pmpriv->uap_state_chan_cb.channel =
+						chan_band_tlv->channel;
 					bss->param.ap_channel.is_dfs_chan =
 						wlan_11h_radar_detect_required(
 							pmpriv,
@@ -2596,7 +2699,9 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 							.center_chan =
 							wlan_get_center_freq_idx(
 								pmpriv,
-								BAND_AAC,
+								chan_band_tlv
+									->bandcfg
+									.chanBand,
 								chan_band_tlv
 									->channel,
 								CHANNEL_BW_80MHZ);
@@ -2634,7 +2739,7 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 							cust_ie->ie_data_list[0]
 								.ie_index);
 
-				while (resp_len > sizeof(t_u16)) {
+				while (resp_len > (int)sizeof(t_u16)) {
 					cptr = (custom_ie
 							*)(((t_u8 *)cust_ie
 								    ->ie_data_list) +
@@ -2710,8 +2815,11 @@ static mlan_status wlan_uap_ret_sys_config(pmlan_private pmpriv,
 	} else { /* no ioctl: driver generated get/set */
 		switch (wlan_le16_to_cpu(tlv->header.type)) {
 		case TLV_TYPE_UAP_MAC_ADDRESS:
-			memcpy_ext(pmpriv->adapter, pmpriv->curr_addr, tlv->mac,
-				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+			if (sys_config->action == HostCmd_ACT_GEN_SET) {
+				memcpy_ext(pmpriv->adapter, pmpriv->curr_addr,
+					   tlv->mac, MLAN_MAC_ADDR_LENGTH,
+					   MLAN_MAC_ADDR_LENGTH);
+			}
 			break;
 		case TLV_TYPE_UAP_MAX_STA_CNT_PER_CHIP:
 			tlv_uap_max_sta = (MrvlIEtypes_uap_max_sta_cnt_t *)tlv;
@@ -2864,6 +2972,16 @@ static mlan_status wlan_uap_cmd_snmp_mib(pmlan_private pmpriv,
 			psnmp_mib->value[0] = *((t_u8 *)pdata_buf);
 			cmd->size += sizeof(t_u8);
 			break;
+		case Dot11H_fakeRadar:
+			psnmp_mib->oid = wlan_cpu_to_le16((t_u16)cmd_oid);
+			psnmp_mib->buf_size = 0;
+			break;
+		case ChanTrackParam_i:
+			psnmp_mib->oid = wlan_cpu_to_le16((t_u16)cmd_oid);
+			psnmp_mib->buf_size = wlan_cpu_to_le16(sizeof(t_u8));
+			psnmp_mib->value[0] = *((t_u8 *)pdata_buf);
+			cmd->size += sizeof(t_u8);
+			break;
 		default:
 			PRINTM(MERROR, "Unsupported OID.\n");
 			ret = MLAN_STATUS_FAILURE;
@@ -3062,6 +3180,7 @@ static mlan_status wlan_uap_ret_snmp_mib(pmlan_private pmpriv,
 			break;
 		case Dot11H_i:
 			data = wlan_le16_to_cpu(*((t_u16 *)(psnmp_mib->value)));
+			PRINTM(MCMND, "wlan: uap Dot11H_i=%d\n", data);
 			/* Set 11h state to priv */
 			pmpriv->intf_state_11h.is_11h_active =
 				(data & ENABLE_11H_MASK);
@@ -3142,6 +3261,58 @@ static mlan_status wlan_uap_ret_get_log(pmlan_private pmpriv,
 		pget_info->param.stats.amsdu_tx_cnt = pmpriv->amsdu_tx_cnt;
 		pget_info->param.stats.msdu_in_tx_amsdu_cnt =
 			pmpriv->msdu_in_tx_amsdu_cnt;
+		pget_info->param.stats.rx_stuck_issue_cnt[0] =
+			wlan_le32_to_cpu(pget_log->rx_stuck_issue_cnt[0]);
+		pget_info->param.stats.rx_stuck_issue_cnt[1] =
+			wlan_le32_to_cpu(pget_log->rx_stuck_issue_cnt[1]);
+		pget_info->param.stats.rx_stuck_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->rx_stuck_recovery_cnt);
+		pget_info->param.stats.rx_stuck_tsf[0] =
+			wlan_le64_to_cpu(pget_log->rx_stuck_tsf[0]);
+		pget_info->param.stats.rx_stuck_tsf[1] =
+			wlan_le64_to_cpu(pget_log->rx_stuck_tsf[1]);
+		pget_info->param.stats.tx_watchdog_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->tx_watchdog_recovery_cnt);
+		pget_info->param.stats.tx_watchdog_tsf[0] =
+			wlan_le64_to_cpu(pget_log->tx_watchdog_tsf[0]);
+		pget_info->param.stats.tx_watchdog_tsf[1] =
+			wlan_le64_to_cpu(pget_log->tx_watchdog_tsf[1]);
+		pget_info->param.stats.channel_switch_ann_sent =
+			wlan_le32_to_cpu(pget_log->channel_switch_ann_sent);
+		pget_info->param.stats.channel_switch_state =
+			wlan_le32_to_cpu(pget_log->channel_switch_state);
+		pget_info->param.stats.reg_class =
+			wlan_le32_to_cpu(pget_log->reg_class);
+		pget_info->param.stats.channel_number =
+			wlan_le32_to_cpu(pget_log->channel_number);
+		pget_info->param.stats.channel_switch_mode =
+			wlan_le32_to_cpu(pget_log->channel_switch_mode);
+		pget_info->param.stats.rx_reset_mac_recovery_cnt =
+			wlan_le32_to_cpu(pget_log->rx_reset_mac_recovery_cnt);
+		pget_info->param.stats.rx_Isr2_NotDone_Cnt =
+			wlan_le32_to_cpu(pget_log->rx_Isr2_NotDone_Cnt);
+		pget_info->param.stats.gdma_abort_cnt =
+			wlan_le32_to_cpu(pget_log->gdma_abort_cnt);
+		pget_info->param.stats.g_reset_rx_mac_cnt =
+			wlan_le32_to_cpu(pget_log->g_reset_rx_mac_cnt);
+		// Ownership error counters
+		pget_info->param.stats.dwCtlErrCnt =
+			wlan_le32_to_cpu(pget_log->dwCtlErrCnt);
+		pget_info->param.stats.dwBcnErrCnt =
+			wlan_le32_to_cpu(pget_log->dwBcnErrCnt);
+		pget_info->param.stats.dwMgtErrCnt =
+			wlan_le32_to_cpu(pget_log->dwMgtErrCnt);
+		pget_info->param.stats.dwDatErrCnt =
+			wlan_le32_to_cpu(pget_log->dwDatErrCnt);
+		pget_info->param.stats.bigtk_mmeGoodCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_mmeGoodCnt);
+		pget_info->param.stats.bigtk_replayErrCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_replayErrCnt);
+		pget_info->param.stats.bigtk_micErrCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_micErrCnt);
+		pget_info->param.stats.bigtk_mmeNotFoundCnt =
+			wlan_le32_to_cpu(pget_log->bigtk_mmeNotFoundCnt);
+
 		if (pmpriv->adapter->getlog_enable) {
 			pget_info->param.stats.tx_frag_cnt =
 				wlan_le32_to_cpu(pget_log->tx_frag_cnt);
@@ -3382,7 +3553,7 @@ static mlan_status wlan_uap_cmd_key_material(pmlan_private pmpriv,
 	else
 		pkey_material->key_param_set.key_info |= KEY_INFO_UCAST_KEY;
 	if (pkey->key_flags & KEY_FLAG_AES_MCAST_IGTK)
-		pkey_material->key_param_set.key_info = KEY_INFO_CMAC_AES_KEY;
+		pkey_material->key_param_set.key_info |= KEY_INFO_CMAC_AES_KEY;
 	if (pkey->key_flags & KEY_FLAG_SET_TX_KEY)
 		pkey_material->key_param_set.key_info |=
 			KEY_INFO_TX_KEY | KEY_INFO_RX_KEY;
@@ -3426,6 +3597,59 @@ static mlan_status wlan_uap_cmd_key_material(pmlan_private pmpriv,
 	pkey_material->key_param_set.key_info |= KEY_INFO_DEFAULT_KEY;
 	pkey_material->key_param_set.key_info =
 		wlan_cpu_to_le16(pkey_material->key_param_set.key_info);
+	if (pkey->key_flags & KEY_FLAG_GCMP ||
+	    pkey->key_flags & KEY_FLAG_GCMP_256) {
+		if (pkey->key_flags &
+		    (KEY_FLAG_RX_SEQ_VALID | KEY_FLAG_TX_SEQ_VALID)) {
+			memcpy_ext(
+				pmpriv->adapter,
+				pkey_material->key_param_set.key_params.gcmp.pn,
+				pkey->pn, SEQ_MAX_SIZE, WPA_PN_SIZE);
+		}
+		if (pkey->key_flags & KEY_FLAG_GCMP)
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_GCMP;
+		else
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_GCMP_256;
+		pkey_material->key_param_set.key_params.gcmp.key_len =
+			wlan_cpu_to_le16(pkey->key_len);
+		memcpy_ext(pmpriv->adapter,
+			   pkey_material->key_param_set.key_params.gcmp.key,
+			   pkey->key_material, pkey->key_len, WPA_GCMP_KEY_LEN);
+		pkey_material->key_param_set.length = wlan_cpu_to_le16(
+			KEY_PARAMS_FIXED_LEN + sizeof(gcmp_param));
+		cmd->size = wlan_cpu_to_le16(sizeof(MrvlIEtypesHeader_t) +
+					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+					     sizeof(gcmp_param) +
+					     sizeof(pkey_material->action));
+		PRINTM(MCMND, "Set GCMP Key\n");
+		goto done;
+	}
+	if (pkey->key_flags & KEY_FLAG_CCMP_256) {
+		if (pkey->key_flags &
+		    (KEY_FLAG_RX_SEQ_VALID | KEY_FLAG_TX_SEQ_VALID)) {
+			memcpy_ext(pmpriv->adapter,
+				   pkey_material->key_param_set.key_params
+					   .ccmp256.pn,
+				   pkey->pn, SEQ_MAX_SIZE, WPA_PN_SIZE);
+		}
+		pkey_material->key_param_set.key_type = KEY_TYPE_ID_CCMP_256;
+		pkey_material->key_param_set.key_params.ccmp256.key_len =
+			wlan_cpu_to_le16(pkey->key_len);
+		memcpy_ext(pmpriv->adapter,
+			   pkey_material->key_param_set.key_params.ccmp256.key,
+			   pkey->key_material, pkey->key_len,
+			   WPA_CCMP_256_KEY_LEN);
+		pkey_material->key_param_set.length = wlan_cpu_to_le16(
+			KEY_PARAMS_FIXED_LEN + sizeof(ccmp_256_param));
+		cmd->size = wlan_cpu_to_le16(sizeof(MrvlIEtypesHeader_t) +
+					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+					     sizeof(ccmp_256_param) +
+					     sizeof(pkey_material->action));
+		PRINTM(MCMND, "Set CCMP256 Key\n");
+		goto done;
+	}
 	if (pkey->key_len == WPA_AES_KEY_LEN &&
 	    !(pkey->key_flags & KEY_FLAG_AES_MCAST_IGTK)) {
 		if (pkey->key_flags &
@@ -3461,7 +3685,12 @@ static mlan_status wlan_uap_cmd_key_material(pmlan_private pmpriv,
 			~(wlan_cpu_to_le16(KEY_INFO_MCAST_KEY));
 		pkey_material->key_param_set.key_info |=
 			wlan_cpu_to_le16(KEY_INFO_AES_MCAST_IGTK);
-		pkey_material->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC;
+		if (pkey->key_flags & KEY_FLAG_GMAC_128)
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_BIP_GMAC_128;
+		else
+			pkey_material->key_param_set.key_type =
+				KEY_TYPE_ID_AES_CMAC;
 		pkey_material->key_param_set.key_params.cmac_aes.key_len =
 			wlan_cpu_to_le16(pkey->key_len);
 		memcpy_ext(pmpriv->adapter,
@@ -3473,7 +3702,39 @@ static mlan_status wlan_uap_cmd_key_material(pmlan_private pmpriv,
 					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
 					     sizeof(cmac_aes_param) +
 					     sizeof(pkey_material->action));
-		PRINTM(MCMND, "Set CMAC AES Key\n");
+		if (pkey->key_flags & KEY_FLAG_GMAC_128)
+			PRINTM(MCMND, "Set AES 128 GMAC Key\n");
+		else
+			PRINTM(MCMND, "Set CMAC AES Key\n");
+		goto done;
+	}
+	if (pkey->key_len == WPA_IGTK_256_KEY_LEN &&
+	    (pkey->key_flags & KEY_FLAG_AES_MCAST_IGTK)) {
+		if (pkey->key_flags &
+		    (KEY_FLAG_RX_SEQ_VALID | KEY_FLAG_TX_SEQ_VALID))
+			memcpy_ext(pmpriv->adapter,
+				   pkey_material->key_param_set.key_params
+					   .gmac_aes.ipn,
+				   pkey->pn, SEQ_MAX_SIZE, IGTK_PN_SIZE);
+		pkey_material->key_param_set.key_info &=
+			~(wlan_cpu_to_le16(KEY_INFO_MCAST_KEY));
+		pkey_material->key_param_set.key_info |=
+			wlan_cpu_to_le16(KEY_INFO_AES_MCAST_IGTK);
+		pkey_material->key_param_set.key_type =
+			KEY_TYPE_ID_BIP_GMAC_256;
+		pkey_material->key_param_set.key_params.gmac_aes.key_len =
+			wlan_cpu_to_le16(pkey->key_len);
+		memcpy_ext(pmpriv->adapter,
+			   pkey_material->key_param_set.key_params.gmac_aes.key,
+			   pkey->key_material, pkey->key_len,
+			   WPA_IGTK_256_KEY_LEN);
+		pkey_material->key_param_set.length = wlan_cpu_to_le16(
+			KEY_PARAMS_FIXED_LEN + sizeof(gmac_aes_256_param));
+		cmd->size = wlan_cpu_to_le16(sizeof(MrvlIEtypesHeader_t) +
+					     S_DS_GEN + KEY_PARAMS_FIXED_LEN +
+					     sizeof(gmac_aes_256_param) +
+					     sizeof(pkey_material->action));
+		PRINTM(MCMND, "Set AES 256 GMAC Key\n");
 		goto done;
 	}
 	if (pkey->key_len == WPA_TKIP_KEY_LEN) {
@@ -3523,6 +3784,7 @@ static mlan_status wlan_uap_ret_sta_list(pmlan_private pmpriv,
 	sta_node *sta_ptr;
 	t_u8 tlv_len = 0;
 	t_u8 *buf = MNULL;
+	t_u8 *ie_buf = MNULL;
 
 	ENTER();
 	if (pioctl_buf) {
@@ -3533,8 +3795,12 @@ static mlan_status wlan_uap_ret_sta_list(pmlan_private pmpriv,
 		tlv = (MrvlIEtypes_sta_info_t *)buf;
 		info->param.sta_list.sta_count =
 			MIN(info->param.sta_list.sta_count, MAX_NUM_CLIENTS);
+		ie_buf = (t_u8 *)&info->param.sta_list.info[0];
+		ie_buf +=
+			sizeof(sta_info_data) * info->param.sta_list.sta_count;
 		pioctl_buf->data_read_written =
-			sizeof(info->param.sta_list.sta_count);
+			sizeof(mlan_ds_sta_list) -
+			sizeof(sta_info_data) * MAX_NUM_CLIENTS;
 		for (i = 0; i < info->param.sta_list.sta_count; i++) {
 			tlv_len = wlan_le16_to_cpu(tlv->header.len);
 			memcpy_ext(pmpriv->adapter,
@@ -3544,12 +3810,12 @@ static mlan_status wlan_uap_ret_sta_list(pmlan_private pmpriv,
 			info->param.sta_list.info[i].ie_len =
 				tlv_len + sizeof(MrvlIEtypesHeader_t) -
 				sizeof(MrvlIEtypes_sta_info_t);
-			if (info->param.sta_list.info[i].ie_len)
-				memcpy_ext(pmpriv->adapter,
-					   info->param.sta_list.info[i].ie_buf,
-					   tlv->ie_buf,
+			if (info->param.sta_list.info[i].ie_len) {
+				memcpy_ext(pmpriv->adapter, ie_buf, tlv->ie_buf,
 					   info->param.sta_list.info[i].ie_len,
 					   info->param.sta_list.info[i].ie_len);
+				ie_buf += info->param.sta_list.info[i].ie_len;
+			}
 			info->param.sta_list.info[i].power_mgmt_status =
 				tlv->power_mgmt_status;
 			info->param.sta_list.info[i].rssi = tlv->rssi;
@@ -3566,7 +3832,7 @@ static mlan_status wlan_uap_ret_sta_list(pmlan_private pmpriv,
 			} else
 				info->param.sta_list.info[i].bandmode = 0xFF;
 			pioctl_buf->data_read_written +=
-				sizeof(sta_info) +
+				sizeof(sta_info_data) +
 				info->param.sta_list.info[i].ie_len;
 			buf += sizeof(MrvlIEtypes_sta_info_t) +
 			       info->param.sta_list.info[i].ie_len;
@@ -3613,6 +3879,7 @@ static void wlan_check_uap_capability(pmlan_private priv, pmlan_buffer pevent)
 	priv->is_11n_enabled = MFALSE;
 	priv->is_11ac_enabled = MFALSE;
 	priv->is_11ax_enabled = MFALSE;
+	event->event_id = 0;
 
 	while (tlv_buf_left >= (int)sizeof(MrvlIEtypesHeader_t)) {
 		tlv_type = wlan_le16_to_cpu(tlv->type);
@@ -3680,8 +3947,12 @@ static void wlan_check_uap_capability(pmlan_private priv, pmlan_buffer pevent)
 				    tlv_len + sizeof(MrvlIEtypesHeader_t));
 			pchan_info = (MrvlIEtypes_channel_band_t *)tlv;
 			priv->uap_channel = pchan_info->channel;
-			PRINTM(MCMND, "uap_channel FW: 0x%x\n",
-			       priv->uap_channel);
+			priv->uap_bandwidth = pchan_info->bandcfg.chanWidth;
+			priv->uap_state_chan_cb.channel = pchan_info->channel;
+			priv->uap_state_chan_cb.bandcfg = pchan_info->bandcfg;
+			PRINTM(MCMND, "uap_channel FW: 0x%x band=%d bw=%d\n",
+			       priv->uap_channel, pchan_info->bandcfg.chanBand,
+			       priv->uap_bandwidth);
 			event->bss_index = priv->bss_index;
 			event->event_id = MLAN_EVENT_ID_DRV_UAP_CHAN_INFO;
 			event->event_len = sizeof(chan_band_info);
@@ -3690,11 +3961,10 @@ static void wlan_check_uap_capability(pmlan_private priv, pmlan_buffer pevent)
 				   (t_u8 *)&pchan_info->bandcfg, tlv_len,
 				   tlv_len);
 			if (pchan_band_info->bandcfg.chanWidth == CHAN_BW_80MHZ)
-				pchan_band_info->center_chan =
-					wlan_get_center_freq_idx(
-						priv, BAND_AAC,
-						pchan_info->channel,
-						CHANNEL_BW_80MHZ);
+				pchan_band_info
+					->center_chan = wlan_get_center_freq_idx(
+					priv, pchan_band_info->bandcfg.chanBand,
+					pchan_info->channel, CHANNEL_BW_80MHZ);
 			if (priv->adapter->ecsa_enable) {
 				int ret;
 				t_u8 bandwidth = BW_20MHZ;
@@ -3896,9 +4166,9 @@ static t_u32 wlan_process_sta_assoc_event(pmlan_private priv,
  *
  *  @return             MLAN_STATUS_SUCCESS
  */
-mlan_status wlan_ret_cmd_uap_acs_scan(pmlan_private pmpriv,
-				      const HostCmd_DS_COMMAND *resp,
-				      mlan_ioctl_req *pioctl_buf)
+static mlan_status wlan_ret_cmd_uap_acs_scan(pmlan_private pmpriv,
+					     const HostCmd_DS_COMMAND *resp,
+					     mlan_ioctl_req *pioctl_buf)
 {
 	HostCMD_DS_APCMD_ACS_SCAN *acs_scan =
 		(HostCMD_DS_APCMD_ACS_SCAN *)&resp->params.acs_scan;
@@ -3964,6 +4234,7 @@ static mlan_status wlan_uap_cmd_oper_ctrl(pmlan_private pmpriv,
 				if (bandcfg->chanWidth)
 					bandcfg->chan2Offset =
 						wlan_get_second_channel_offset(
+							pmpriv,
 							uap_oper_ctrl->channel);
 				bandcfg->scanMode = SCAN_MODE_MANUAL;
 				poper_ctl->channel_band.channel =
@@ -4020,7 +4291,8 @@ static mlan_status wlan_uap_ret_oper_ctrl(pmlan_private pmpriv,
  *  @return MTRUE/MFALSE
  *
  */
-t_u8 wlan_check_11B_support_rates(MrvlIEtypes_RatesParamSet_t *prates_tlv)
+static t_u8
+wlan_check_11B_support_rates(MrvlIEtypes_RatesParamSet_t *prates_tlv)
 {
 	int i;
 	t_u8 rate;
@@ -4064,7 +4336,7 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 	mlan_adapter *pmadapter = pmpriv->adapter;
 	MrvlIETypes_HTCap_t *phtcap;
 	MrvlIETypes_VHTCap_t *pvhtcap;
-	MrvlIEtypes_Extension_t *pext_tlv;
+	MrvlIEtypes_Extension_t *pext_tlv = MNULL;
 	MrvlIEtypes_StaFlag_t *pstaflag;
 	int i;
 
@@ -4092,6 +4364,8 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
+	/* Save station aid for multi-ap */
+	sta_ptr->aid = bss->param.sta_info.aid;
 	memcpy_ext(pmadapter, new_sta->peer_mac, bss->param.sta_info.peer_mac,
 		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 	if (cmd_action != HostCmd_ACT_ADD_STA)
@@ -4173,6 +4447,8 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 			if (pext_tlv->ext_id == HE_CAPABILITY) {
 				sta_ptr->is_11ax_enabled = MTRUE;
 				PRINTM(MCMND, "STA supports 11ax\n");
+			} else {
+				pext_tlv = MNULL;
 			}
 			break;
 		default:
@@ -4190,6 +4466,22 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 		travel_len += sizeof(MrvlIEtypesHeader_t) + tlv_len;
 		tlv_buf_left -= sizeof(MrvlIEtypesHeader_t) + tlv_len;
 	}
+	if (sta_ptr->is_11ax_enabled) {
+		if (pext_tlv == MNULL) {
+			tlv = (MrvlIEtypesHeader_t *)pos;
+			tlv->type = wlan_cpu_to_le16(EXTENSION);
+			tlv->len = wlan_cpu_to_le16(
+				MIN(sta_ptr->he_cap.ieee_hdr.len,
+				    sizeof(IEEEtypes_HECap_t) -
+					    sizeof(IEEEtypes_Header_t)));
+
+			pos += sizeof(MrvlIEtypesHeader_t);
+			memcpy_ext(pmadapter, pos,
+				   (t_u8 *)&sta_ptr->he_cap.ext_id, tlv->len,
+				   tlv->len);
+			travel_len += sizeof(MrvlIEtypesHeader_t) + tlv->len;
+		}
+	}
 
 	if (sta_ptr->is_11n_enabled) {
 		if (pmpriv->uap_channel <= 14)
@@ -4217,7 +4509,7 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 	}
 
 	for (i = 0; i < MAX_NUM_TID; i++) {
-		if (sta_ptr->is_11n_enabled)
+		if (sta_ptr->is_11n_enabled || sta_ptr->is_11ax_enabled)
 			sta_ptr->ampdu_sta[i] =
 				pmpriv->aggr_prio_tbl[i].ampdu_user;
 		else
@@ -4231,6 +4523,81 @@ static mlan_status wlan_uap_cmd_add_station(pmlan_private pmpriv,
 	return MLAN_STATUS_SUCCESS;
 }
 
+/**
+ *  @brief This function prepares command of per peer stats
+ *
+ *  @param pmpriv        A pointer to mlan_private structure
+ *  @param cmd           A pointer to HostCmd_DS_COMMAND structure
+ *  @param cmd_action    the action: GET or SET
+ *  @param pdata_buf     A pointer to data buffer
+ *  @return              MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_cmd_stats(pmlan_private pmpriv, HostCmd_DS_COMMAND *cmd,
+				  t_u16 cmd_action, t_void *pdata_buf)
+{
+	HostCmd_DS_STATS *stats_cmd = (HostCmd_DS_STATS *)&cmd->params.stats;
+	Stats_Cfg_Params_TLV_t *cfg_param = MNULL;
+	mlan_ds_stats *stats = (mlan_ds_stats *)pdata_buf;
+	Stats_Cfg_Params_TLV_t *stats_param = MNULL;
+
+	ENTER();
+	cmd->command = wlan_cpu_to_le16(HostCmd_CMD_802_11_STATS);
+	cmd->size = wlan_cpu_to_le16(sizeof(HostCmd_DS_STATS) + S_DS_GEN);
+	if (cmd_action) {
+		cmd->size =
+			wlan_cpu_to_le16(sizeof(HostCmd_DS_STATS) + S_DS_GEN +
+					 sizeof(Stats_Cfg_Params_TLV_t) - 1);
+		stats_cmd->action = wlan_cpu_to_le16(HostCmd_ACT_GEN_SET);
+
+		stats_param = (Stats_Cfg_Params_TLV_t *)stats->tlv_buf;
+		if (stats_param->tlvHeader.type ==
+		    NXP_802_11_PER_PEER_STATS_CFG_TLV_ID) {
+			cfg_param =
+				(Stats_Cfg_Params_TLV_t *)stats_cmd->tlv_buffer;
+			*cfg_param = *stats_param;
+		}
+	} else {
+		cmd->size =
+			wlan_cpu_to_le16(sizeof(HostCmd_DS_STATS) + S_DS_GEN);
+		stats_cmd->action = wlan_cpu_to_le16(HostCmd_ACT_GEN_GET);
+	}
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
+/**
+ *  @brief This function handles the command response of stats
+ *
+ *  @param pmpriv       A pointer to mlan_private structure
+ *  @param resp         A pointer to HostCmd_DS_COMMAND
+ *  @param pioctl_buf   A pointer to mlan_ioctl_req structure
+ *
+ *  @return             MLAN_STATUS_SUCCESS
+ */
+static mlan_status wlan_ret_stats(pmlan_private pmpriv,
+				  HostCmd_DS_COMMAND *resp,
+				  mlan_ioctl_req *pioctl_buf)
+{
+	HostCmd_DS_STATS *cfg_cmd = (HostCmd_DS_STATS *)&resp->params.stats;
+	mlan_ds_misc_cfg *misc_cfg = MNULL;
+	t_u8 *pBuf = (t_u8 *)&cfg_cmd->tlv_buffer;
+	int len = resp->size;
+
+	ENTER();
+	if (pioctl_buf) {
+		misc_cfg = (mlan_ds_misc_cfg *)pioctl_buf->pbuf;
+		len -= (S_DS_GEN + sizeof(t_u16));
+		memcpy_ext(pmpriv->adapter,
+			   (t_u8 *)&misc_cfg->param.stats.tlv_buf, pBuf, len,
+			   len);
+		misc_cfg->param.stats.tlv_len = len;
+		pioctl_buf->buf_len = sizeof(mlan_ds_stats) + len - 1;
+	}
+
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+
 /********************************************************
 			Global Functions
 ********************************************************/
@@ -4401,6 +4768,14 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = MLAN_STATUS_SUCCESS;
 		break;
 #endif
+	case HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS:
+		ret = wlan_cmd_802_11_ftm_config_session_params(
+			pmpriv, cmd_ptr, cmd_action, cmd_oid, pdata_buf);
+		break;
+	case HostCmd_CMD_FTM_CONFIG_RESPONDER:
+		ret = wlan_cmd_802_11_ftm_config_responder(
+			pmpriv, cmd_ptr, cmd_action, cmd_oid, pdata_buf);
+		break;
 	case HostCmd_CMD_VERSION_EXT:
 		cmd_ptr->command = wlan_cpu_to_le16(cmd_no);
 		cmd_ptr->params.verext.version_str_sel =
@@ -4414,7 +4789,7 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		cmd_ptr->params.rx_mgmt_ind.action =
 			wlan_cpu_to_le16(cmd_action);
 		cmd_ptr->params.rx_mgmt_ind.mgmt_subtype_mask =
-			(t_u32)(*((t_u32 *)pdata_buf));
+			wlan_cpu_to_le32((t_u32)(*((t_u32 *)pdata_buf)));
 		cmd_ptr->size = wlan_cpu_to_le16(
 			sizeof(HostCmd_DS_RX_MGMT_IND) + S_DS_GEN);
 		break;
@@ -4452,6 +4827,10 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 						 pdata_buf);
 		break;
 #endif
+	case HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG:
+		ret = wlan_cmd_gpio_tsf_latch(pmpriv, cmd_ptr, cmd_action,
+					      pioctl_buf, pdata_buf);
+		break;
 	case HostCmd_CMD_802_11_RF_ANTENNA:
 		ret = wlan_cmd_802_11_rf_antenna(pmpriv, cmd_ptr, cmd_action,
 						 pdata_buf);
@@ -4473,6 +4852,7 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_TARGET_ACCESS:
 	case HostCmd_CMD_802_11_EEPROM_ACCESS:
 	case HostCmd_CMD_BCA_REG_ACCESS:
+	case HostCmd_CMD_REG_ACCESS:
 		ret = wlan_cmd_reg_access(pmpriv, cmd_ptr, cmd_action,
 					  pdata_buf);
 		break;
@@ -4482,12 +4862,17 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 	case HostCmd_CMD_WMM_QUEUE_CONFIG:
 		ret = wlan_cmd_wmm_queue_config(pmpriv, cmd_ptr, pdata_buf);
 		break;
-#ifdef RX_PACKET_COALESCE
-	case HostCmd_CMD_RX_PKT_COALESCE_CFG:
-		ret = wlan_cmd_rx_pkt_coalesce_cfg(pmpriv, cmd_ptr, cmd_action,
-						   pdata_buf);
+	case HostCmd_CMD_MULTI_CHAN_CONFIG:
+		ret = wlan_cmd_multi_chan_cfg(pmpriv, cmd_ptr, cmd_action,
+					      pdata_buf);
+		break;
+	case HostCmd_CMD_MULTI_CHAN_POLICY:
+		ret = wlan_cmd_multi_chan_policy(pmpriv, cmd_ptr, cmd_action,
+						 pdata_buf);
+		break;
+	case HostCmd_CMD_DRCS_CONFIG:
+		ret = wlan_cmd_drcs_cfg(pmpriv, cmd_ptr, cmd_action, pdata_buf);
 		break;
-#endif
 	case HOST_CMD_APCMD_OPER_CTRL:
 		ret = wlan_uap_cmd_oper_ctrl(pmpriv, cmd_ptr, cmd_action,
 					     pdata_buf);
@@ -4511,6 +4896,10 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 			sizeof(HostCmd_DS_CHAN_REGION_CFG) + S_DS_GEN);
 		cmd_ptr->params.reg_cfg.action = wlan_cpu_to_le16(cmd_action);
 		break;
+	case HostCmd_CMD_802_11_NET_MONITOR:
+		ret = wlan_cmd_net_monitor(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
 	case HostCmd_CMD_PACKET_AGGR_CTRL:
 		ret = wlan_cmd_packet_aggr_ctrl(pmpriv, cmd_ptr, cmd_action,
 						pdata_buf);
@@ -4563,6 +4952,10 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_rxabortcfg(pmpriv, cmd_ptr, cmd_action,
 					  pdata_buf);
 		break;
+	case HostCmd_CMD_OFDM_DESENSE_CFG:
+		ret = wlan_cmd_ofdmdesense_cfg(pmpriv, cmd_ptr, cmd_action,
+					       pdata_buf);
+		break;
 	case HostCmd_CMD_RX_ABORT_CFG_EXT:
 		ret = wlan_cmd_rxabortcfg_ext(pmpriv, cmd_ptr, cmd_action,
 					      pdata_buf);
@@ -4599,6 +4992,28 @@ mlan_status wlan_ops_uap_prepare_cmd(t_void *priv, t_u16 cmd_no,
 		ret = wlan_cmd_set_get_beacon_stuck_cfg(pmpriv, cmd_ptr,
 							cmd_action, pdata_buf);
 		break;
+	case HostCmd_CMD_HAL_PHY_CFG:
+		ret = wlan_cmd_hal_phy_cfg(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_MC_AGGR_CFG:
+		ret = wlan_cmd_mc_aggr_cfg(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_802_11_STATS:
+		ret = wlan_cmd_stats(pmpriv, cmd_ptr, cmd_action, pdata_buf);
+		break;
+	case HostCmd_CMD_GET_CH_LOAD:
+		ret = wlan_cmd_get_ch_load(pmpriv, cmd_ptr, cmd_action,
+					   pdata_buf);
+		break;
+	case HostCmd_CMD_CROSS_CHIP_SYNCH:
+		ret = wlan_cmd_cross_chip_synch(pmpriv, cmd_ptr, cmd_action,
+						pdata_buf);
+		break;
+	case HostCmd_DS_GET_SENSOR_TEMP:
+		wlan_cmd_get_sensor_temp(pmpriv, cmd_ptr, cmd_action);
+		break;
 	default:
 		PRINTM(MERROR, "PREP_CMD: unknown command- %#x\n", cmd_no);
 		if (pioctl_req)
@@ -4699,6 +5114,7 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		AuthenitcatorInitBssConfig(pmpriv->psapriv);
 #endif
 		ret = wlan_uap_ret_sys_reset(pmpriv, resp, pioctl_buf);
+		wlan_reset_all_chan_dfs_state(priv, BAND_A, DFS_USABLE);
 		wlan_11h_check_update_radar_det_state(pmpriv);
 		wlan_coex_ampdu_rxwinsize(pmadapter);
 		break;
@@ -4774,8 +5190,15 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		break;
 	case HostCmd_CMD_SET_BSS_MODE:
 		break;
+	case HostCmd_CMD_802_11_NET_MONITOR:
+		ret = wlan_ret_net_monitor(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_RECONFIGURE_TX_BUFF:
 		wlan_set_tx_pause_flag(pmpriv, MFALSE);
+#if defined(USB)
+		if (IS_USB(pmadapter->card_type))
+			wlan_resync_usb_port(pmadapter);
+#endif
 
 		pmadapter->tx_buf_size =
 			(t_u16)wlan_le16_to_cpu(resp->params.tx_buf.buff_size);
@@ -4790,15 +5213,18 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 				pmadapter->pcard_sd->reg->data_port_mask;
 
 			for (ctr = 1;
-			     ctr <= MAX_PORT - pmadapter->pcard_sd->mp_end_port;
+			     ctr <= pmadapter->pcard_sd->max_ports -
+					    pmadapter->pcard_sd->mp_end_port;
 			     ctr++) {
 				pmadapter->pcard_sd->mp_data_port_mask &=
-					~(1 << (MAX_PORT - ctr));
+					~(1 << (pmadapter->pcard_sd->max_ports -
+						ctr));
 			}
 
-			pmadapter->pcard_sd->curr_wr_port = 0;
+			pmadapter->pcard_sd->curr_wr_port =
+				pmadapter->pcard_sd->reg->start_wr_port;
 			pmadapter->pcard_sd->mpa_tx.pkt_aggr_limit =
-				MIN(SDIO_MP_AGGR_DEF_PKT_LIMIT,
+				MIN(pmadapter->pcard_sd->mp_aggr_pkt_limit,
 				    (pmadapter->pcard_sd->mp_end_port >> 1));
 			PRINTM(MCMND, "end port %d, data port mask %x\n",
 			       wlan_le16_to_cpu(
@@ -4822,6 +5248,14 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_TX_BF_CFG:
 		ret = wlan_ret_tx_bf_cfg(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_FTM_CONFIG_SESSION_PARAMS:
+		ret = wlan_ret_802_11_ftm_config_session_params(pmpriv, resp,
+								pioctl_buf);
+		break;
+	case HostCmd_CMD_FTM_CONFIG_RESPONDER:
+		ret = wlan_ret_802_11_ftm_config_responder(pmpriv, resp,
+							   pioctl_buf);
+		break;
 	case HostCmd_CMD_VERSION_EXT:
 		ret = wlan_ret_ver_ext(pmpriv, resp, pioctl_buf);
 		break;
@@ -4851,6 +5285,9 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		ret = wlan_ret_p2p_params_config(pmpriv, resp, pioctl_buf);
 		break;
 #endif
+	case HOST_CMD_GPIO_TSF_LATCH_PARAM_CONFIG:
+		ret = wlan_ret_gpio_tsf_latch(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_802_11_RF_ANTENNA:
 		ret = wlan_ret_802_11_rf_antenna(pmpriv, resp, pioctl_buf);
 		break;
@@ -4869,6 +5306,7 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_TARGET_ACCESS:
 	case HostCmd_CMD_802_11_EEPROM_ACCESS:
 	case HostCmd_CMD_BCA_REG_ACCESS:
+	case HostCmd_CMD_REG_ACCESS:
 		ret = wlan_ret_reg_access(pmpriv->adapter, cmdresp_no, resp,
 					  pioctl_buf);
 		break;
@@ -4878,11 +5316,15 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_WMM_QUEUE_CONFIG:
 		ret = wlan_ret_wmm_queue_config(pmpriv, resp, pioctl_buf);
 		break;
-#ifdef RX_PACKET_COALESCE
-	case HostCmd_CMD_RX_PKT_COALESCE_CFG:
-		ret = wlan_ret_rx_pkt_coalesce_cfg(pmpriv, resp, pioctl_buf);
+	case HostCmd_CMD_MULTI_CHAN_CONFIG:
+		ret = wlan_ret_multi_chan_cfg(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_MULTI_CHAN_POLICY:
+		ret = wlan_ret_multi_chan_policy(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_DRCS_CONFIG:
+		ret = wlan_ret_drcs_cfg(pmpriv, resp, pioctl_buf);
 		break;
-#endif
 	case HostCMD_APCMD_ACS_SCAN:
 		ret = wlan_ret_cmd_uap_acs_scan(pmpriv, resp, pioctl_buf);
 		break;
@@ -4939,6 +5381,9 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 	case HostCmd_CMD_RX_ABORT_CFG:
 		ret = wlan_ret_rxabortcfg(pmpriv, resp, pioctl_buf);
 		break;
+	case HostCmd_CMD_OFDM_DESENSE_CFG:
+		ret = wlan_ret_ofdmdesense_cfg(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_RX_ABORT_CFG_EXT:
 		ret = wlan_ret_rxabortcfg_ext(pmpriv, resp, pioctl_buf);
 		break;
@@ -4949,6 +5394,9 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		ret = wlan_ret_dot11mc_unassoc_ftm_cfg(pmpriv, resp,
 						       pioctl_buf);
 		break;
+	case HostCmd_CMD_HAL_PHY_CFG:
+		ret = wlan_ret_hal_phy_cfg(pmpriv, resp, pioctl_buf);
+		break;
 	case HostCmd_CMD_RATE_ADAPT_CFG:
 		ret = wlan_ret_rate_adapt_cfg(pmpriv, resp, pioctl_buf);
 		break;
@@ -4970,6 +5418,21 @@ mlan_status wlan_ops_uap_process_cmdresp(t_void *priv, t_u16 cmdresp_no,
 		ret = wlan_ret_set_get_beacon_stuck_cfg(pmpriv, resp,
 							pioctl_buf);
 		break;
+	case HostCmd_CMD_MC_AGGR_CFG:
+		ret = wlan_ret_mc_aggr_cfg(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_802_11_STATS:
+		ret = wlan_ret_stats(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_GET_CH_LOAD:
+		ret = wlan_ret_ch_load(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_CMD_CROSS_CHIP_SYNCH:
+		ret = wlan_ret_cross_chip_synch(pmpriv, resp, pioctl_buf);
+		break;
+	case HostCmd_DS_GET_SENSOR_TEMP:
+		ret = wlan_ret_get_sensor_temp(pmpriv, resp, pioctl_buf);
+		break;
 	default:
 		PRINTM(MERROR, "CMD_RESP: Unknown command response %#x\n",
 		       resp->command);
@@ -5002,9 +5465,11 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 	sta_node *sta_ptr = MNULL;
 	t_u8 i = 0;
 	t_u8 channel = 0;
+	t_u8 bandwidth = 0;
 	MrvlIEtypes_channel_band_t *pchan_info = MNULL;
 	chan_band_info *pchan_band_info = MNULL;
 	event_exceed_max_p2p_conn *event_excd_p2p = MNULL;
+	Event_WLS_FTM_t *event_ftm = MNULL;
 	t_u16 enable;
 
 	ENTER();
@@ -5056,6 +5521,8 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 					MNULL);
 		}
 #endif
+		if (wlan_11h_radar_detect_required(pmpriv, pmpriv->uap_channel))
+			wlan_11h_update_dfs_master_state_by_uap(pmpriv);
 		break;
 	case EVENT_MICRO_AP_BSS_ACTIVE:
 		PRINTM(MEVENT, "EVENT: MICRO_AP_BSS_ACTIVE\n");
@@ -5080,8 +5547,10 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		break;
 	case EVENT_PS_AWAKE:
 		PRINTM(MINFO, "EVENT: AWAKE\n");
-		PRINTM_NETINTF(MEVENT, pmpriv);
-		PRINTM(MEVENT, "||");
+		if (pmadapter->second_mac)
+			PRINTM(MEVENT, "||");
+		else
+			PRINTM(MEVENT, "|");
 		/* Handle unexpected PS AWAKE event */
 		if (pmadapter->ps_state == PS_STATE_SLEEP_CFM)
 			break;
@@ -5092,8 +5561,10 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		break;
 	case EVENT_PS_SLEEP:
 		PRINTM(MINFO, "EVENT: SLEEP\n");
-		PRINTM_NETINTF(MEVENT, pmpriv);
-		PRINTM(MEVENT, "__");
+		if (pmadapter->second_mac)
+			PRINTM(MEVENT, "__");
+		else
+			PRINTM(MEVENT, "_");
 		/* Handle unexpected PS SLEEP event */
 		if (pmadapter->ps_state == PS_STATE_SLEEP_CFM)
 			break;
@@ -5110,14 +5581,15 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		       MAC2STR(sta_addr));
 		if (!sta_ptr)
 			break;
-		if (pmpriv->is_11n_enabled
+		wlan_check_sta_capability(pmpriv, pmbuf, sta_ptr);
+		if (pmpriv->is_11n_enabled || pmpriv->is_11ax_enabled
 #ifdef DRV_EMBEDDED_AUTHENTICATOR
 		    || IsAuthenticatorEnabled(pmpriv->psapriv)
 #endif
 		) {
-			wlan_check_sta_capability(pmpriv, pmbuf, sta_ptr);
 			for (i = 0; i < MAX_NUM_TID; i++) {
-				if (sta_ptr->is_11n_enabled)
+				if (sta_ptr->is_11n_enabled ||
+				    sta_ptr->is_11ax_enabled)
 					sta_ptr->ampdu_sta[i] =
 						pmpriv->aggr_prio_tbl[i]
 							.ampdu_user;
@@ -5149,10 +5621,11 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		wlan_recv_event(pmpriv, pevent->event_id, pevent);
 		memcpy_ext(pmadapter, sta_addr, pmadapter->event_body + 2,
 			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		sta_ptr = wlan_get_station_entry(pmpriv, sta_addr);
 		PRINTM_NETINTF(MMSG, pmpriv);
 		PRINTM(MMSG, "wlan: EVENT: MICRO_AP_STA_DEAUTH " MACSTR "\n",
 		       MAC2STR(sta_addr));
-		if (pmpriv->is_11n_enabled) {
+		if (pmpriv->is_11n_enabled || pmpriv->is_11ax_enabled) {
 			wlan_cleanup_reorder_tbl(pmpriv, sta_addr);
 			wlan_11n_cleanup_txbastream_tbl(pmpriv, sta_addr);
 		}
@@ -5225,7 +5698,17 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 	case EVENT_RADAR_DETECTED:
 		PRINTM_NETINTF(MEVENT, pmpriv);
 		PRINTM(MEVENT, "EVENT: Radar Detected\n");
-
+		if (pmpriv->adapter->dfs_test_params.cac_restart &&
+		    pmpriv->adapter->state_dfs.dfs_check_pending) {
+			wlan_11h_cancel_radar_detect(pmpriv);
+			if (wlan_11h_issue_radar_detect(
+				    pmpriv, MNULL,
+				    pmpriv->adapter->dfs_test_params.chan,
+				    pmpriv->adapter->dfs_test_params.bandcfg))
+				PRINTM(MINFO, "RADAR detect returned FALSE\n");
+			pevent->event_id = 0;
+			break;
+		}
 		/* Send as passthru first, this event can cause other events */
 		memset(pmadapter, event_buf, 0x00, MAX_EVENT_SIZE);
 		pevent->bss_index = pmpriv->bss_index;
@@ -5237,7 +5720,6 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		wlan_recv_event(pmpriv, pevent->event_id, pevent);
 		pevent->event_id = 0; /* clear to avoid resending at end of fcn
 				       */
-
 		/* Print event data */
 		pevent->event_id = MLAN_EVENT_ID_FW_RADAR_DETECTED;
 		pevent->event_len = pmbuf->data_len - sizeof(eventcause);
@@ -5245,16 +5727,27 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 			   pmbuf->pbuf + pmbuf->data_offset +
 				   sizeof(eventcause),
 			   pevent->event_len, pevent->event_len);
-		wlan_11h_print_event_radar_detected(pmpriv, pevent, &channel);
+		wlan_11h_print_event_radar_detected(pmpriv, pevent, &channel,
+						    &bandwidth);
 		*((t_u8 *)pevent->event_buf) = channel;
+		*((t_u8 *)pevent->event_buf + 1) = bandwidth;
+		if (pmpriv->bss_type == MLAN_BSS_TYPE_DFS) {
+			if (!pmpriv->adapter->dfs_test_params
+				     .no_channel_change_on_radar) {
+				wlan_recv_event(priv,
+						MLAN_EVENT_ID_FW_RADAR_DETECTED,
+						pevent);
+			}
+			pevent->event_id = 0; /* clear to avoid resending at end
+						 of fcn */
+			break;
+		}
 		if (!pmpriv->intf_state_11h.is_11h_host) {
 			if (pmadapter->state_rdh.stage == RDH_OFF) {
 				pmadapter->state_rdh.stage = RDH_CHK_INTFS;
 				wlan_11h_radar_detected_handling(pmadapter,
 								 pmpriv);
-				if (pmpriv->uap_host_based)
-					wlan_recv_event(
-						priv,
+				wlan_recv_event(priv,
 						MLAN_EVENT_ID_FW_RADAR_DETECTED,
 						pevent);
 			} else {
@@ -5267,9 +5760,7 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 				    .no_channel_change_on_radar ||
 			    pmpriv->adapter->dfs_test_params
 				    .fixed_new_channel_on_radar) {
-				if (pmadapter->state_rdh.stage == RDH_OFF ||
-				    pmadapter->state_rdh.stage ==
-					    RDH_SET_CUSTOM_IE) {
+				if (pmadapter->state_rdh.stage == RDH_OFF) {
 					pmadapter->state_rdh.stage =
 						RDH_CHK_INTFS;
 					wlan_11h_radar_detected_handling(
@@ -5291,6 +5782,7 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 	case EVENT_CHANNEL_REPORT_RDY:
 		PRINTM_NETINTF(MEVENT, pmpriv);
 		PRINTM(MEVENT, "EVENT: Channel Report Ready\n");
+		pmpriv->adapter->dfs_test_params.cac_restart = MFALSE;
 		memset(pmadapter, event_buf, 0x00, MAX_EVENT_SIZE);
 		/* Setup event buffer */
 		pevent->bss_index = pmpriv->bss_index;
@@ -5303,12 +5795,25 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 			   pevent->event_len, pevent->event_len);
 		/* Handle / pass event data, and free buffer */
 		ret = wlan_11h_handle_event_chanrpt_ready(pmpriv, pevent,
-							  &channel);
-
+							  &channel, &bandwidth);
+		if (pmpriv->bss_type == MLAN_BSS_TYPE_DFS) {
+			*((t_u8 *)pevent->event_buf) =
+				pmpriv->adapter->state_dfs.dfs_radar_found;
+			*((t_u8 *)pevent->event_buf + 1) = channel;
+			*((t_u8 *)pevent->event_buf + 2) = bandwidth;
+			wlan_recv_event(pmpriv,
+					MLAN_EVENT_ID_FW_CHANNEL_REPORT_RDY,
+					pevent);
+			pevent->event_id = 0; /* clear to avoid resending at end
+						 of fcn */
+			break;
+		}
 		if (pmpriv->intf_state_11h.is_11h_host) {
 			*((t_u8 *)pevent->event_buf) =
 				pmpriv->adapter->state_dfs.dfs_radar_found;
 			*((t_u8 *)pevent->event_buf + 1) = channel;
+			*((t_u8 *)pevent->event_buf + 2) = bandwidth;
+
 			wlan_recv_event(pmpriv,
 					MLAN_EVENT_ID_FW_CHANNEL_REPORT_RDY,
 					pevent);
@@ -5327,23 +5832,11 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		PRINTM(MEVENT, "EVENT: CHANNEL_SWITCH new channel %d\n",
 		       channel);
 		pmpriv->uap_channel = channel;
+		pmpriv->uap_bandwidth = pchan_info->bandcfg.chanWidth;
 		pmpriv->uap_state_chan_cb.channel = pchan_info->channel;
 		pmpriv->uap_state_chan_cb.bandcfg = pchan_info->bandcfg;
-		if (wlan_11h_radar_detect_required(pmpriv,
-						   pchan_info->channel)) {
-			if (!wlan_11h_is_active(pmpriv)) {
-				/* active 11h extention in Fw */
-				ret = wlan_11h_activate(pmpriv, MNULL, MTRUE);
-				ret = wlan_11h_config_master_radar_det(pmpriv,
-								       MTRUE);
-				ret = wlan_11h_check_update_radar_det_state(
-					pmpriv);
-			}
-			if (pmpriv->uap_host_based)
-				pmpriv->intf_state_11h.is_11h_host = MTRUE;
-			wlan_11h_set_dfs_check_chan(pmpriv,
-						    pchan_info->channel);
-		}
+		if (wlan_11h_radar_detect_required(pmpriv, pchan_info->channel))
+			wlan_11h_update_dfs_master_state_by_uap(pmpriv);
 		if ((pmpriv->adapter->state_rdh.stage != RDH_OFF &&
 		     !pmpriv->intf_state_11h.is_11h_host) ||
 		    pmpriv->adapter->dfs_test_params.no_channel_change_on_radar ||
@@ -5360,6 +5853,8 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		} else {
 			/* Handle Host-based DFS and non-DFS(normal uap) case */
 			pmpriv->intf_state_11h.tx_disabled = MFALSE;
+		}
+		if (pmpriv->uap_host_based) {
 			memset(pmadapter, event_buf, 0x00, MAX_EVENT_SIZE);
 			/* Setup event buffer */
 			pevent->bss_index = pmpriv->bss_index;
@@ -5376,7 +5871,8 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 			if (pchan_band_info->bandcfg.chanWidth == CHAN_BW_80MHZ)
 				pchan_band_info->center_chan =
 					wlan_get_center_freq_idx(
-						priv, BAND_AAC,
+						priv,
+						pchan_info->bandcfg.chanBand,
 						pchan_info->channel,
 						CHANNEL_BW_80MHZ);
 			pchan_band_info->is_11n_enabled =
@@ -5394,6 +5890,10 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 		wlan_recv_event(pmpriv, MLAN_EVENT_ID_DRV_FLUSH_RX_WORK, MNULL);
 		pevent->event_id = MLAN_EVENT_ID_FW_REMAIN_ON_CHAN_EXPIRED;
 		break;
+	case EVENT_MULTI_CHAN_INFO:
+		PRINTM(MEVENT, "EVENT: MULTI_CHAN_INFO\n");
+		wlan_handle_event_multi_chan_info(pmpriv, pmbuf);
+		break;
 
 	case EVENT_FW_DEBUG_INFO:
 		memset(pmadapter, event_buf, 0x00, MAX_EVENT_SIZE);
@@ -5430,7 +5930,27 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 	case EVENT_VDLL_IND:
 		wlan_process_vdll_event(pmpriv, pmbuf);
 		break;
+	case EVENT_CSI:
+		PRINTM(MEVENT, "EVENT: EVENT_CSI on UAP\n");
+		wlan_process_csi_event(pmpriv);
+		break;
 
+	case EVENT_WLS_FTM_COMPLETE:
+		PRINTM(MEVENT, "EVENT: FTM_GENERIC_EVENT\n");
+		pevent = (pmlan_event)event_buf;
+		pevent->bss_index = pmpriv->bss_index;
+		event_ftm =
+			(Event_WLS_FTM_t *)(pmbuf->pbuf + pmbuf->data_offset);
+		if (event_ftm->sub_event_id == WLS_SUB_EVENT_RTT_RESULTS) {
+			wlan_fill_hal_rtt_results(pmpriv, event_ftm,
+						  pmbuf->data_len, pevent);
+			wlan_recv_event(pmpriv, pevent->event_id, pevent);
+			pevent->event_id = 0; /* clear to avoid resending at end
+						 of fcn */
+			goto done;
+		} else
+			pevent->event_id = MLAN_EVENT_ID_DRV_PASSTHRU;
+		break;
 	case EVENT_FW_HANG_REPORT:
 		if (pmbuf->data_len < (sizeof(eventcause) + sizeof(t_u16))) {
 			PRINTM(MEVENT,
@@ -5457,6 +5977,21 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
 				   sizeof(eventcause),
 			   sizeof(t_u16), sizeof(t_u16));
 		break;
+	case CHAN_LOAD_EVENT: {
+		t_u8 *ptr = MNULL;
+		HostCmd_DS_GET_CH_LOAD *cfg_cmd = MNULL;
+		ptr = (t_u8 *)(pmbuf->pbuf + pmbuf->data_offset);
+		ptr += 4; /* actual data buffer start */
+		cfg_cmd = (HostCmd_DS_GET_CH_LOAD *)ptr;
+		pmpriv->ch_load_param = wlan_le16_to_cpu(cfg_cmd->ch_load);
+		pmpriv->noise = wlan_le16_to_cpu(cfg_cmd->noise);
+		pmpriv->rx_quality = wlan_le16_to_cpu(cfg_cmd->rx_quality);
+		break;
+	}
+	case EVENT_FW_DUMP_INFO:
+		PRINTM(MINFO, "EVENT: Dump FW info\n");
+		pevent->event_id = MLAN_EVENT_ID_FW_DUMP_INFO;
+		break;
 	default:
 		pevent->event_id = MLAN_EVENT_ID_DRV_PASSTHRU;
 		break;
@@ -5485,7 +6020,8 @@ mlan_status wlan_ops_uap_process_event(t_void *priv)
  *
  *  @return   MLAN_STATUS_SUCCESS or MLAN_STATUS_PENDING or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_uap_set_uap_max_sta(pmlan_private pmpriv, t_u8 uap_max_sta)
+static mlan_status wlan_uap_set_uap_max_sta(pmlan_private pmpriv,
+					    t_u8 uap_max_sta)
 {
 	MrvlIEtypes_uap_max_sta_cnt_t tlv_uap_max_sta;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c
old mode 100644
new mode 100755
index 8de4bd3d0..acb1dc1d3
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_ioctl.c
@@ -3,7 +3,7 @@
  *  @brief This file contains the handling of AP mode ioctls
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -42,7 +42,6 @@ Change log:
 /********************************************************
 			Global Variables
 ********************************************************/
-extern t_u8 tos_to_tid_inv[];
 
 /********************************************************
 			Local Functions
@@ -84,7 +83,8 @@ static t_bool wlan_can_radar_det_skip(mlan_private *priv)
 	 * is off then 11n_radar detection is not required for subsequent BSSes
 	 * since they will follow the primary bss.
 	 */
-	if ((GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)) {
+	if (!priv->adapter->mc_policy &&
+	    (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)) {
 		memset(pmadapter, priv_list, 0x00, sizeof(priv_list));
 		pcount = wlan_get_privs_by_cond(pmadapter, wlan_is_intf_active,
 						priv_list);
@@ -113,6 +113,7 @@ static mlan_status wlan_uap_callback_bss_ioctl_start(t_void *priv)
 	wlan_uap_get_info_cb_t *puap_state_chan_cb = &pmpriv->uap_state_chan_cb;
 	t_u8 old_channel;
 	t_bool under_nop = MFALSE;
+	dfs_state_t dfs_state;
 	ENTER();
 	/* clear callback now that we're here */
 	puap_state_chan_cb->get_chan_callback = MNULL;
@@ -150,7 +151,10 @@ static mlan_status wlan_uap_callback_bss_ioctl_start(t_void *priv)
 				goto prep_bss_start;
 			}
 		}
-
+		dfs_state = wlan_get_chan_dfs_state(
+			pmpriv, BAND_A, puap_state_chan_cb->channel);
+		if (dfs_state == DFS_AVAILABLE)
+			goto prep_bss_start;
 		/* first check if channel is under NOP */
 		if (wlan_11h_is_channel_under_nop(
 			    pmpriv->adapter, puap_state_chan_cb->channel)) {
@@ -172,6 +176,7 @@ static mlan_status wlan_uap_callback_bss_ioctl_start(t_void *priv)
 
 			if (ret == MLAN_STATUS_SUCCESS) {
 				wlan_11h_update_bandcfg(
+					pmpriv,
 					&pmpriv->uap_state_chan_cb.bandcfg,
 					puap_state_chan_cb->channel);
 				PRINTM(MCMD_D,
@@ -342,16 +347,14 @@ static mlan_status wlan_uap_bss_ioctl_reset(pmlan_adapter pmadapter,
 		pmpriv->aggr_prio_tbl[i].amsdu = tos_to_tid_inv[i];
 		pmpriv->addba_reject[i] = ADDBA_RSP_STATUS_ACCEPT;
 	}
+	pmpriv->aggr_prio_tbl[6].amsdu = BA_STREAM_NOT_ALLOWED;
+	pmpriv->aggr_prio_tbl[7].amsdu = BA_STREAM_NOT_ALLOWED;
+
 	pmpriv->aggr_prio_tbl[6].ampdu_user =
 		pmpriv->aggr_prio_tbl[7].ampdu_user = BA_STREAM_NOT_ALLOWED;
 	pmpriv->addba_reject[6] = pmpriv->addba_reject[7] =
 		ADDBA_RSP_STATUS_REJECT;
 
-	/* hs_configured, hs_activated are reset by main loop */
-	pmadapter->hs_cfg.conditions = HOST_SLEEP_DEF_COND;
-	pmadapter->hs_cfg.gpio = HOST_SLEEP_DEF_GPIO;
-	pmadapter->hs_cfg.gap = HOST_SLEEP_DEF_GAP;
-
 	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_SYS_RESET,
 			       HostCmd_ACT_GEN_SET, 0, (t_void *)pioctl_req,
 			       MNULL);
@@ -371,8 +374,8 @@ static mlan_status wlan_uap_bss_ioctl_reset(pmlan_adapter pmadapter,
  *
  *  @return            	  MLAN_STATUS_SUCCESS/MLAN_STATUS_FAILURE
  */
-mlan_status wlan_uap_bss_ioctl_add_station(pmlan_adapter pmadapter,
-					   pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_uap_bss_ioctl_add_station(pmlan_adapter pmadapter,
+						  pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -437,13 +440,11 @@ static mlan_status wlan_uap_bss_ioctl_uap_wmm_param(pmlan_adapter pmadapter,
 						    pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_bss *bss = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 cmd_action = 0;
 
 	ENTER();
 
-	bss = (mlan_ds_bss *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
 	else
@@ -459,6 +460,37 @@ static mlan_status wlan_uap_bss_ioctl_uap_wmm_param(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Handle channel switch
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+static mlan_status
+wlan_uap_bss_ioctl_action_chan_switch(pmlan_adapter pmadapter,
+				      pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	cmd_action = HostCmd_ACT_GEN_SET;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_SYS_CONFIGURE, cmd_action,
+			       0, (t_void *)pioctl_req, MNULL);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Set/Get scan channels
  *
@@ -472,13 +504,11 @@ wlan_uap_bss_ioctl_uap_scan_channels(pmlan_adapter pmadapter,
 				     pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_bss *bss = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 cmd_action = 0;
 
 	ENTER();
 
-	bss = (mlan_ds_bss *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
 	else
@@ -506,13 +536,11 @@ static mlan_status wlan_uap_bss_ioctl_uap_channel(pmlan_adapter pmadapter,
 						  pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_bss *bss = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 cmd_action = 0;
 
 	ENTER();
 
-	bss = (mlan_ds_bss *)pioctl_req->pbuf;
 	if (pioctl_req->action == MLAN_ACT_SET)
 		cmd_action = HostCmd_ACT_GEN_SET;
 	else
@@ -540,7 +568,6 @@ static mlan_status wlan_uap_bss_ioctl_uap_oper_ctrl(pmlan_adapter pmadapter,
 						    pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
-	mlan_ds_bss *bss = MNULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u16 cmd_action = 0;
 
@@ -548,7 +575,6 @@ static mlan_status wlan_uap_bss_ioctl_uap_oper_ctrl(pmlan_adapter pmadapter,
 
 	if (pmadapter->fw_ver == HOST_API_VERSION_V15 &&
 	    pmadapter->fw_min_ver >= FW_MINOR_VERSION_1) {
-		bss = (mlan_ds_bss *)pioctl_req->pbuf;
 		if (pioctl_req->action == MLAN_ACT_SET)
 			cmd_action = HostCmd_ACT_GEN_SET;
 		else
@@ -688,27 +714,10 @@ static mlan_status wlan_uap_bss_ioctl_deauth_sta(pmlan_adapter pmadapter,
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_private pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_ds_bss *bss = MNULL;
-	const t_u8 bc_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	sta_node *sta_ptr = MNULL;
 
 	ENTER();
 
 	bss = (mlan_ds_bss *)pioctl_req->pbuf;
-	if (pmpriv->uap_host_based & UAP_FLAG_HOST_MLME) {
-		if (memcmp(pmpriv->adapter, bss->param.deauth_param.mac_addr,
-			   bc_mac, MLAN_MAC_ADDR_LENGTH)) {
-			sta_ptr = wlan_get_station_entry(
-				pmpriv, bss->param.deauth_param.mac_addr);
-			if (!sta_ptr) {
-				PRINTM(MCMND,
-				       "Skip deauth to station " MACSTR "\n",
-				       MAC2STR(bss->param.deauth_param
-						       .mac_addr));
-				LEAVE();
-				return ret;
-			}
-		}
-	}
 	ret = wlan_prepare_cmd(pmpriv, HOST_CMD_APCMD_STA_DEAUTH,
 			       HostCmd_ACT_GEN_SET, 0, (t_void *)pioctl_req,
 			       (t_void *)&bss->param.deauth_param);
@@ -1044,6 +1053,7 @@ wlan_uap_sec_ioctl_set_encrypt_key(pmlan_adapter pmadapter,
 		LEAVE();
 		return ret;
 	}
+
 	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_KEY_MATERIAL,
 			       HostCmd_ACT_GEN_SET, KEY_INFO_ENABLED,
 			       (t_void *)pioctl_req, &sec->param.encrypt_key);
@@ -1306,7 +1316,7 @@ static mlan_status wlan_uap_callback_domain_info(t_void *priv)
 	mlan_private *pmpriv = (mlan_private *)priv;
 	wlan_uap_get_info_cb_t *puap_state_chan_cb = &pmpriv->uap_state_chan_cb;
 	mlan_ds_11d_cfg *cfg11d;
-	t_u8 band;
+	t_u16 band;
 	pmlan_adapter pmadapter = pmpriv->adapter;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 
@@ -1406,6 +1416,7 @@ static mlan_status wlan_uap_callback_11h_channel_check_req(t_void *priv)
 	Band_Config_t *pband_cfg = &puap_state_chan_cb->bandcfg;
 	/* keep copy as local variable */
 	pmlan_ioctl_req pioctl = puap_state_chan_cb->pioctl_req_curr;
+	dfs_state_t dfs_state;
 	ENTER();
 	/* clear callback now that we're here */
 	puap_state_chan_cb->get_chan_callback = MNULL;
@@ -1430,6 +1441,19 @@ static mlan_status wlan_uap_callback_11h_channel_check_req(t_void *priv)
 		ret = wlan_11h_config_master_radar_det(pmpriv, MTRUE);
 		ret = wlan_11h_check_update_radar_det_state(pmpriv);
 
+		dfs_state = wlan_get_chan_dfs_state(
+			pmpriv, BAND_A, puap_state_chan_cb->channel);
+		if (dfs_state == DFS_AVAILABLE) {
+			wlan_11h_set_dfs_check_chan(pmpriv,
+						    puap_state_chan_cb->channel,
+						    pband_cfg->chanWidth);
+			PRINTM(MCMND, "DFS: Channel %d is Avaliable\n",
+			       puap_state_chan_cb->channel);
+			pcb->moal_ioctl_complete(pmpriv->adapter->pmoal_handle,
+						 pioctl, MLAN_STATUS_COMPLETE);
+			LEAVE();
+			return ret;
+		}
 		/* Check for radar on the channel */
 		ret = wlan_11h_issue_radar_detect(pmpriv, pioctl,
 						  puap_state_chan_cb->channel,
@@ -1476,7 +1500,8 @@ static mlan_status wlan_uap_11h_channel_check_req(pmlan_adapter pmadapter,
 	pmpriv->intf_state_11h.is_11h_host =
 		p11h_cfg->param.chan_rpt_req.host_based;
 
-	if (!pmpriv->intf_state_11h.is_11h_host) {
+	if (!pmpriv->intf_state_11h.is_11h_host &&
+	    pmpriv->bss_type != MLAN_BSS_TYPE_DFS) {
 		/* store params, issue command to get UAP channel, whose
 		 * CMD_RESP will callback remainder of 11H channel check
 		 * handling */
@@ -1494,7 +1519,8 @@ static mlan_status wlan_uap_11h_channel_check_req(pmlan_adapter pmadapter,
 			ret = wlan_11h_config_master_radar_det(pmpriv, MTRUE);
 			ret = wlan_11h_check_update_radar_det_state(pmpriv);
 		}
-		if (p11h_cfg->param.chan_rpt_req.millisec_dwell_time) {
+		if (p11h_cfg->param.chan_rpt_req.millisec_dwell_time ||
+		    pmpriv->bss_type == MLAN_BSS_TYPE_DFS) {
 			if (pmpriv->adapter->dfs_test_params
 				    .user_cac_period_msec) {
 				PRINTM(MCMD_D,
@@ -1506,6 +1532,28 @@ static mlan_status wlan_uap_11h_channel_check_req(pmlan_adapter pmadapter,
 					pmpriv->adapter->dfs_test_params
 						.user_cac_period_msec;
 			}
+			if (pmpriv->adapter->dfs_test_params.cac_restart &&
+			    p11h_cfg->param.chan_rpt_req.millisec_dwell_time) {
+				pmpriv->adapter->dfs_test_params.chan =
+					p11h_cfg->param.chan_rpt_req.chanNum;
+				pmpriv->adapter->dfs_test_params
+					.millisec_dwell_time =
+					p11h_cfg->param.chan_rpt_req
+						.millisec_dwell_time;
+				memcpy_ext(
+					pmpriv->adapter,
+					&pmpriv->adapter->dfs_test_params
+						 .bandcfg,
+					&p11h_cfg->param.chan_rpt_req.bandcfg,
+					sizeof(Band_Config_t),
+					sizeof(Band_Config_t));
+			}
+			if (p11h_cfg->param.chan_rpt_req.millisec_dwell_time)
+				PRINTM(MMSG,
+				       "11h: issuing DFS Radar check for channel=%d."
+				       "  Please wait for response...\n",
+				       p11h_cfg->param.chan_rpt_req.chanNum);
+
 			ret = wlan_prepare_cmd(
 				pmpriv, HostCmd_CMD_CHAN_REPORT_REQUEST,
 				HostCmd_ACT_GEN_SET, 0, (t_void *)pioctl_req,
@@ -1631,6 +1679,42 @@ static mlan_status wlan_uap_snmp_mib_11h(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Set SNMP MIB for 11H
+ *
+ *  @param pmadapter    A pointer to mlan_adapter structure
+ *  @param pioctl_req   A pointer to ioctl request buffer
+ *
+ *  @return     MLAN_STATUS_PENDING --success, otherwise fail
+ *  @sa         wlan_uap_callback_snmp_mib_11h
+ */
+static mlan_status wlan_uap_snmp_mib_11h_fakeradar(pmlan_adapter pmadapter,
+						   pmlan_ioctl_req pioctl_req)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+
+	ENTER();
+
+	if (pioctl_req->buf_len < sizeof(mlan_ds_snmp_mib)) {
+		PRINTM(MWARN, "MLAN snmp_mib IOCTL length is too short.\n");
+		pioctl_req->data_read_written = 0;
+		pioctl_req->buf_len_needed = sizeof(mlan_ds_snmp_mib);
+		LEAVE();
+		return MLAN_STATUS_RESOURCE;
+	}
+	/* Send cmd to FW to trigger fakeradar in firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_SNMP_MIB,
+			       HostCmd_ACT_GEN_SET, Dot11H_fakeRadar,
+			       (t_void *)pioctl_req, MNULL);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief ACS scan
  *
@@ -1755,6 +1839,39 @@ mlan_status wlan_uap_get_beacon_dtim(pmlan_private pmpriv)
 	return ret;
 }
 
+/**
+ *  @brief              Get/Start/Stop/Reset stats
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		        MLAN_STATUS_PENDING --success, otherwise fail
+ */
+static mlan_status wlan_misc_ioctl_stats(pmlan_adapter pmadapter,
+					 mlan_ioctl_req *pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u16 cmd_action = 0;
+	mlan_ds_misc_cfg *misc = MNULL;
+
+	ENTER();
+
+	misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+	cmd_action = pioctl_req->action;
+
+	/* Send request to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_STATS, cmd_action, 0,
+			       (t_void *)pioctl_req,
+			       (t_void *)&misc->param.stats);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Set/Get deauth control.
  *
@@ -1763,8 +1880,8 @@ mlan_status wlan_uap_get_beacon_dtim(pmlan_private pmpriv)
  *
  *  @return		MLAN_STATUS_PENDING --success, otherwise fail
  */
-mlan_status wlan_uap_snmp_mib_ctrl_deauth(pmlan_adapter pmadapter,
-					  pmlan_ioctl_req pioctl_req)
+static mlan_status wlan_uap_snmp_mib_ctrl_deauth(pmlan_adapter pmadapter,
+						 pmlan_ioctl_req pioctl_req)
 {
 	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -1792,6 +1909,43 @@ mlan_status wlan_uap_snmp_mib_ctrl_deauth(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief Set/Get channel tracking control.
+ *
+ *  @param pmadapter	A pointer to mlan_adapter structure
+ *  @param pioctl_req	A pointer to ioctl request buffer
+ *
+ *  @return		MLAN_STATUS_PENDING --success, otherwise fail
+ */
+static mlan_status wlan_uap_snmp_mib_chan_track(pmlan_adapter pmadapter,
+						pmlan_ioctl_req pioctl_req)
+{
+	mlan_private *pmpriv = pmadapter->priv[pioctl_req->bss_index];
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_snmp_mib *mib = (mlan_ds_snmp_mib *)pioctl_req->pbuf;
+	t_u16 cmd_action = 0;
+
+	ENTER();
+
+	mib = (mlan_ds_snmp_mib *)pioctl_req->pbuf;
+	if (pioctl_req->action == MLAN_ACT_SET) {
+		cmd_action = HostCmd_ACT_GEN_SET;
+	} else {
+		cmd_action = HostCmd_ACT_GEN_GET;
+	}
+
+	/* Send command to firmware */
+	ret = wlan_prepare_cmd(pmpriv, HostCmd_CMD_802_11_SNMP_MIB, cmd_action,
+			       ChanTrackParam_i, (t_void *)pioctl_req,
+			       &mib->param.chan_track);
+
+	if (ret == MLAN_STATUS_SUCCESS)
+		ret = MLAN_STATUS_PENDING;
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief MLAN uap ioctl handler
  *
@@ -1880,6 +2034,9 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		else if (bss->sub_command == MLAN_OID_UAP_ADD_STATION)
 			status = wlan_uap_bss_ioctl_add_station(pmadapter,
 								pioctl_req);
+		else if (bss->sub_command == MLAN_OID_ACTION_CHAN_SWITCH)
+			status = wlan_uap_bss_ioctl_action_chan_switch(
+				pmadapter, pioctl_req);
 		break;
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 	case MLAN_IOCTL_SCAN:
@@ -1926,6 +2083,11 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 				   MLAN_MAC_ADDR_LENGTH);
 			pget_info->param.fw_info.fw_ver =
 				pmadapter->fw_release_number;
+			pget_info->param.fw_info.hotfix_version =
+				pmadapter->fw_hotfix_ver;
+			pget_info->param.fw_info.tx_buf_size =
+				pmadapter->tx_buf_size;
+
 			pget_info->param.fw_info.fw_bands = pmadapter->fw_bands;
 			pget_info->param.fw_info.ecsa_enable =
 				pmadapter->ecsa_enable;
@@ -1933,6 +2095,8 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 				pmadapter->getlog_enable;
 			pget_info->param.fw_info.hw_dev_mcs_support =
 				pmadapter->hw_dev_mcs_support;
+			pget_info->param.fw_info.hw_mpdu_density =
+				pmadapter->hw_mpdu_density;
 			pget_info->param.fw_info.hw_dot_11n_dev_cap =
 				pmadapter->hw_dot_11n_dev_cap;
 			pget_info->param.fw_info.usr_dev_mcs_support =
@@ -1980,17 +2144,34 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 			pget_info->param.fw_info.antinfo = pmadapter->antinfo;
 			pget_info->param.fw_info.max_ap_assoc_sta =
 				pmadapter->max_sta_conn;
+			pget_info->param.fw_info.uuid_lo = pmadapter->uuid_lo;
+			pget_info->param.fw_info.uuid_hi = pmadapter->uuid_hi;
 		} else if (pget_info->sub_command == MLAN_OID_LINK_STATS)
 			status = wlan_ioctl_link_statistic(pmpriv, pioctl_req);
 		break;
 	case MLAN_IOCTL_MISC_CFG:
 		misc = (mlan_ds_misc_cfg *)pioctl_req->pbuf;
+		if (misc->sub_command == MLAN_OID_MISC_GET_SENSOR_TEMP) {
+			status = wlan_misc_ioctl_get_sensor_temp(pmadapter,
+								 pioctl_req);
+		}
 		if (misc->sub_command == MLAN_OID_MISC_INIT_SHUTDOWN)
 			status = wlan_misc_ioctl_init_shutdown(pmadapter,
 							       pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_SOFT_RESET)
 			status = wlan_uap_misc_ioctl_soft_reset(pmadapter,
 								pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_WARM_RESET) {
+			PRINTM(MCMND, "Request UAP WARM RESET\n");
+			util_enqueue_list_tail(
+				pmadapter->pmoal_handle,
+				&pmadapter->ioctl_pending_q,
+				(pmlan_linked_list)pioctl_req,
+				pmadapter->callbacks.moal_spin_lock,
+				pmadapter->callbacks.moal_spin_unlock);
+			pmadapter->pending_ioctl = MTRUE;
+			status = MLAN_STATUS_PENDING;
+		}
 		if (misc->sub_command == MLAN_OID_MISC_HOST_CMD)
 			status =
 				wlan_misc_ioctl_host_cmd(pmadapter, pioctl_req);
@@ -2018,15 +2199,24 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		if (misc->sub_command == MLAN_OID_MISC_MAC_CONTROL)
 			status = wlan_misc_ioctl_mac_control(pmadapter,
 							     pioctl_req);
-#ifdef RX_PACKET_COALESCE
-		if (misc->sub_command == MLAN_OID_MISC_RX_PACKET_COALESCE)
-			status = wlan_misc_ioctl_rx_pkt_coalesce_config(
-				pmadapter, pioctl_req);
-#endif
+		if (misc->sub_command == MLAN_OID_MISC_MULTI_CHAN_CFG)
+			status = wlan_misc_ioctl_multi_chan_config(pmadapter,
+								   pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_MULTI_CHAN_POLICY)
+			status = wlan_misc_ioctl_multi_chan_policy(pmadapter,
+								   pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_DRCS_CFG)
+			status = wlan_misc_ioctl_drcs_config(pmadapter,
+							     pioctl_req);
 #ifdef WIFI_DIRECT_SUPPORT
 		if (misc->sub_command == MLAN_OID_MISC_WIFI_DIRECT_CONFIG)
 			status = wlan_misc_p2p_config(pmadapter, pioctl_req);
 #endif
+		if (misc->sub_command == MLAN_OID_MISC_GPIO_TSF_LATCH)
+			status = wlan_misc_gpio_tsf_latch_config(pmadapter,
+								 pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_GET_TSF_INFO)
+			status = wlan_misc_get_tsf_info(pmadapter, pioctl_req);
 
 		if (misc->sub_command == MLAN_OID_MISC_DFS_REAPTER_MODE) {
 			mlan_ds_misc_cfg *misc_cfg = MNULL;
@@ -2042,8 +2232,22 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		if (misc->sub_command == MLAN_OID_MISC_IND_RST_CFG)
 			status = wlan_misc_ioctl_ind_rst_cfg(pmadapter,
 							     pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_MC_AGGR_CFG)
+			status = wlan_misc_ioctl_mc_aggr_cfg(pmadapter,
+							     pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_STATS)
+			status = wlan_misc_ioctl_stats(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_CH_LOAD)
+			status = wlan_misc_ioctl_ch_load(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_CH_LOAD_RESULTS)
+			status = wlan_misc_ioctl_ch_load_results(pmadapter,
+								 pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_GET_TSF)
 			status = wlan_misc_ioctl_get_tsf(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_CROSS_CHIP_SYNCH) {
+			status = wlan_misc_ioctl_cross_chip_synch(pmadapter,
+								  pioctl_req);
+		}
 		if (misc->sub_command == MLAN_OID_MISC_GET_CHAN_REGION_CFG)
 			status = wlan_misc_chan_reg_cfg(pmadapter, pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_OPER_CLASS_CHECK)
@@ -2057,12 +2261,18 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 							   pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_PER_PKT_CFG)
 			status = wlan_misc_per_pkt_cfg(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_NET_MONITOR)
+			status = wlan_misc_ioctl_net_monitor(pmadapter,
+							     pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_FW_DUMP_EVENT)
 			status = wlan_misc_ioctl_fw_dump_event(pmadapter,
 							       pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_RX_ABORT_CFG)
 			status = wlan_misc_ioctl_rxabortcfg(pmadapter,
 							    pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_OFDM_DESENSE_CFG)
+			status = wlan_misc_ioctl_ofdmdesense_cfg(pmadapter,
+								 pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_RX_ABORT_CFG_EXT)
 			status = wlan_misc_ioctl_rxabortcfg_ext(pmadapter,
 								pioctl_req);
@@ -2072,6 +2282,8 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		if (misc->sub_command == MLAN_OID_MISC_DOT11MC_UNASSOC_FTM_CFG)
 			status = wlan_misc_ioctl_dot11mc_unassoc_ftm_cfg(
 				pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_HAL_PHY_CFG)
+			status = wlan_misc_hal_phy_cfg(pmadapter, pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_RATE_ADAPT_CFG)
 			status = wlan_misc_ioctl_rate_adapt_cfg(pmadapter,
 								pioctl_req);
@@ -2082,6 +2294,12 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 			status = wlan_misc_robustcoex(pmadapter, pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_DMCS_CONFIG)
 			status = wlan_misc_dmcs_config(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_CONFIG_RTT)
+			status = wlan_config_rtt(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_CANCEL_RTT)
+			status = wlan_cancel_rtt(pmadapter, pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_RTT_RESPONDER_CFG)
+			status = wlan_rtt_responder_cfg(pmadapter, pioctl_req);
 		if (misc->sub_command == MLAN_OID_MISC_GET_TX_RX_HISTOGRAM)
 			status =
 				wlan_get_tx_rx_histogram(pmadapter, pioctl_req);
@@ -2106,6 +2324,12 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 		if (misc->sub_command == MLAN_OID_MISC_RANGE_EXT)
 			status = wlan_misc_ioctl_range_ext(pmadapter,
 							   pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_WACP_MODE)
+			status = wlan_misc_ioctl_wacp_mode(pmadapter,
+							   pioctl_req);
+		if (misc->sub_command == MLAN_OID_MISC_COUNTRY_CODE)
+			status = wlan_misc_ioctl_country_code(pmadapter,
+							      pioctl_req);
 		break;
 	case MLAN_IOCTL_POWER_CFG:
 		power = (mlan_ds_power_cfg *)pioctl_req->pbuf;
@@ -2139,6 +2363,12 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 			status = wlan_uap_snmp_mib_11d(pmadapter, pioctl_req);
 		if (snmp->sub_command == MLAN_OID_SNMP_MIB_DOT11H)
 			status = wlan_uap_snmp_mib_11h(pmadapter, pioctl_req);
+		if (snmp->sub_command == MLAN_OID_SNMP_MIB_DOT11H_FAKERADAR)
+			status = wlan_uap_snmp_mib_11h_fakeradar(pmadapter,
+								 pioctl_req);
+		if (snmp->sub_command == MLAN_OID_SNMP_MIB_CHAN_TRACK)
+			status = wlan_uap_snmp_mib_chan_track(pmadapter,
+							      pioctl_req);
 		break;
 	case MLAN_IOCTL_SEC_CFG:
 		sec = (mlan_ds_sec_cfg *)pioctl_req->pbuf;
@@ -2172,17 +2402,25 @@ mlan_status wlan_ops_uap_ioctl(t_void *adapter, pmlan_ioctl_req pioctl_req)
 			status = wlan_11h_ioctl_dfs_testing(pmadapter,
 							    pioctl_req);
 		if (cfg11h->sub_command == MLAN_OID_11H_CHAN_NOP_INFO)
-			status = wlan_11h_ioctl_get_channel_nop_info(
-				pmadapter, pioctl_req);
+			status = wlan_11h_ioctl_channel_nop_info(pmadapter,
+								 pioctl_req);
+		if (cfg11h->sub_command == MLAN_OID_11H_NOP_CHAN_LIST)
+			status = wlan_11h_ioctl_nop_channel_list(pmadapter,
+								 pioctl_req);
 		if (cfg11h->sub_command == MLAN_OID_11H_CHAN_REPORT_REQUEST)
-			status = wlan_11h_ioctl_dfs_cancel_chan_report(
-				pmpriv, pioctl_req);
+			status = wlan_11h_ioctl_dfs_chan_report(pmpriv,
+								pioctl_req);
 		if (cfg11h->sub_command == MLAN_OID_11H_CHAN_SWITCH_COUNT)
 			status = wlan_11h_ioctl_chan_switch_count(pmadapter,
 								  pioctl_req);
+		if (cfg11h->sub_command == MLAN_OID_11H_CHAN_DFS_STATE)
+			status = wlan_11h_ioctl_chan_dfs_state(pmadapter,
+							       pioctl_req);
 		if (cfg11h->sub_command == MLAN_OID_11H_DFS_W53_CFG)
 			status = wlan_11h_ioctl_dfs_w53_cfg(pmadapter,
 							    pioctl_req);
+		if (cfg11h->sub_command == MLAN_OID_11H_DFS_MODE)
+			status = wlan_11h_ioctl_dfs_mode(pmadapter, pioctl_req);
 		break;
 	case MLAN_IOCTL_RADIO_CFG:
 		radiocfg = (mlan_ds_radio_cfg *)pioctl_req->pbuf;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c
old mode 100644
new mode 100755
index 5ea637fa2..6f3201e61
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_uap_txrx.c
@@ -3,7 +3,7 @@
  *  @brief This file contains AP mode transmit and receive functions
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2009-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -65,7 +65,13 @@ static mlan_status wlan_upload_uap_rx_packet(pmlan_adapter pmadapter,
 	prx_pd = (RxPD *)(pmbuf->pbuf + pmbuf->data_offset);
 
 	/* Chop off RxPD */
-	pmbuf->data_len -= prx_pd->rx_pkt_offset;
+	if (pmbuf->data_len > prx_pd->rx_pkt_offset) {
+		pmbuf->data_len -= prx_pd->rx_pkt_offset;
+	} else {
+		PRINTM(MERROR,
+		       "pmbuf->data_len is smaller than prx_pd->rx_pkt_offset\n");
+		pmbuf->status_code = MLAN_ERROR_PKT_INVALID;
+	}
 	pmbuf->data_offset += prx_pd->rx_pkt_offset;
 	pmbuf->pparent = MNULL;
 
@@ -89,7 +95,6 @@ static mlan_status wlan_upload_uap_rx_packet(pmlan_adapter pmadapter,
 		       "uAP Rx Error: moal_recv_packet returned error\n");
 		pmbuf->status_code = MLAN_ERROR_PKT_INVALID;
 	}
-
 	if (ret != MLAN_STATUS_PENDING)
 		pmadapter->ops.data_complete(pmadapter, pmbuf, ret);
 #ifdef USB
@@ -244,6 +249,12 @@ t_void *wlan_ops_uap_process_txpd(t_void *priv, pmlan_buffer pmbuf)
 		plocal_tx_pd->tx_pkt_type = (t_u16)pkt_type;
 		plocal_tx_pd->tx_control = tx_control;
 	}
+	if (pmbuf->flags & MLAN_BUF_FLAG_EASYMESH) {
+		plocal_tx_pd->flags |= MRVDRV_TxPD_FLAGS_EASYMESH;
+		memcpy_ext(pmpriv->adapter, plocal_tx_pd->ra_mac, pmbuf->mac,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	}
+
 	if (pmbuf->flags & MLAN_BUF_FLAG_TX_CTRL) {
 		if (pmbuf->u.tx_info.data_rate) {
 			memcpy_ext(pmpriv->adapter, dst_mac,
@@ -270,6 +281,37 @@ t_void *wlan_ops_uap_process_txpd(t_void *priv, pmlan_buffer pmbuf)
 			plocal_tx_pd->tx_control |= TXPD_RETRY_ENABLE;
 		}
 	}
+	if (pmbuf->flags & MLAN_BUF_FLAG_MC_AGGR_PKT) {
+		tx_ctrl *ctrl = (tx_ctrl *)&plocal_tx_pd->tx_control;
+		mc_tx_ctrl *mc_ctrl =
+			(mc_tx_ctrl *)&plocal_tx_pd->pkt_delay_2ms;
+		plocal_tx_pd->tx_pkt_type = PKT_TYPE_802DOT11_MC_AGGR;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_START_CYCLE)
+			ctrl->mc_cycle_start = MTRUE;
+		else
+			ctrl->mc_cycle_start = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_END_CYCLE)
+			ctrl->mc_cycle_end = MTRUE;
+		else
+			ctrl->mc_cycle_end = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_START_AMPDU)
+			ctrl->mc_ampdu_start = MTRUE;
+		else
+			ctrl->mc_ampdu_start = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_END_AMPDU)
+			ctrl->mc_ampdu_end = MTRUE;
+		else
+			ctrl->mc_ampdu_end = MFALSE;
+		if (pmbuf->u.mc_tx_info.mc_pkt_flags & MC_FLAG_RETRY)
+			ctrl->mc_pkt_retry = MTRUE;
+		else
+			ctrl->mc_pkt_retry = MFALSE;
+		ctrl->bw = pmbuf->u.mc_tx_info.bandwidth & 0x7;
+		ctrl->tx_rate = pmbuf->u.mc_tx_info.mcs_index & 0x1f;
+		mc_ctrl->abs_tsf_expirytime =
+			wlan_cpu_to_le32(pmbuf->u.mc_tx_info.pkt_expiry);
+		mc_ctrl->mc_seq = wlan_cpu_to_le16(pmbuf->u.mc_tx_info.seq_num);
+	}
 
 	endian_convert_TxPD(plocal_tx_pd);
 
@@ -312,6 +354,14 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 
 	t_u32 last_rx_sec = 0;
 	t_u32 last_rx_usec = 0;
+	RxPD *prx_pd2;
+	EthII_Hdr_t *peth_hdr2;
+	wlan_802_11_header *pwlan_hdr;
+	IEEEtypes_FrameCtl_t *frmctl;
+	pmlan_buffer pmbuf2 = MNULL;
+	mlan_802_11_mac_addr src_addr, dest_addr;
+	t_u16 hdr_len;
+	t_u8 snap_eth_hdr[5] = {0xaa, 0xaa, 0x03, 0x00, 0x00};
 	t_u8 ext_rate_info = 0;
 
 	ENTER();
@@ -320,6 +370,21 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	/* Endian conversion */
 	endian_convert_RxPD(prx_pd);
 
+	if (prx_pd->flags & RXPD_FLAG_EXTRA_HEADER) {
+		endian_convert_RxPD_extra_header(
+			(rxpd_extra_info *)((t_u8 *)prx_pd + sizeof(*prx_pd)));
+	}
+
+	if (priv->adapter->pcard_info->v14_fw_api) {
+		t_u8 rxpd_rate_info_orig = prx_pd->rate_info;
+		prx_pd->rate_info = wlan_convert_v14_rx_rate_info(
+			priv, rxpd_rate_info_orig);
+		PRINTM(MINFO,
+		       "UAP RX: v14_fw_api=%d rx_rate =%d rxpd_rate_info=0x%x->0x%x\n",
+		       priv->adapter->pcard_info->v14_fw_api, prx_pd->rx_rate,
+		       rxpd_rate_info_orig, prx_pd->rate_info);
+	}
+
 	if (priv->rx_pkt_info) {
 		ext_rate_info = (t_u8)(prx_pd->rx_info >> 16);
 		pmbuf->u.rx_info.data_rate =
@@ -333,6 +398,14 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	}
 
 	rx_pkt_type = prx_pd->rx_pkt_type;
+	if (prx_pd->flags & RXPD_FLAG_PKT_EASYMESH) {
+		PRINTM_NETINTF(MDAT_D, priv);
+		PRINTM(MDAT_D, "UAP Rx Easymesh pkt flags : 0x%x\n",
+		       prx_pd->flags);
+		ret = wlan_check_easymesh_pkt(priv, pmbuf, prx_pd);
+		if (ret != MLAN_STATUS_SUCCESS)
+			goto done;
+	}
 	prx_pkt = (RxPacketHdr_t *)((t_u8 *)prx_pd + prx_pd->rx_pkt_offset);
 
 	PRINTM(MINFO,
@@ -373,6 +446,112 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 		pmadapter->ops.data_complete(pmadapter, pmbuf, ret);
 		goto done;
 	}
+	if (pmadapter->enable_net_mon &&
+	    (prx_pd->flags & RXPD_FLAG_UCAST_PKT)) {
+		pwlan_hdr = (wlan_802_11_header *)((t_u8 *)prx_pd +
+						   prx_pd->rx_pkt_offset);
+		frmctl = (IEEEtypes_FrameCtl_t *)pwlan_hdr;
+		if (frmctl->type == 0x02) {
+			/* This is a valid unicast destined data packet, with
+			 * 802.11 and rtap headers attached. Duplicate this
+			 * packet and process this copy as a sniffed packet,
+			 * meant for monitor iface
+			 */
+			pmbuf2 = wlan_alloc_mlan_buffer(pmadapter,
+							MLAN_RX_DATA_BUF_SIZE,
+							MLAN_RX_HEADER_LEN,
+							MOAL_ALLOC_MLAN_BUFFER);
+			if (!pmbuf2) {
+				PRINTM(MERROR,
+				       "Unable to allocate mlan_buffer for Rx");
+				PRINTM(MERROR, "sniffed packet\n");
+			} else {
+				pmbuf2->bss_index = pmbuf->bss_index;
+				pmbuf2->buf_type = pmbuf->buf_type;
+				pmbuf2->priority = pmbuf->priority;
+				pmbuf2->in_ts_sec = pmbuf->in_ts_sec;
+				pmbuf2->in_ts_usec = pmbuf->in_ts_usec;
+				pmbuf2->data_len = pmbuf->data_len;
+				memcpy(pmadapter,
+				       pmbuf2->pbuf + pmbuf2->data_offset,
+				       pmbuf->pbuf + pmbuf->data_offset,
+				       pmbuf->data_len);
+
+				prx_pd2 = (RxPD *)(pmbuf2->pbuf +
+						   pmbuf2->data_offset);
+				/* set pkt type of duplicated pkt to 802.11 */
+				prx_pd2->rx_pkt_type = PKT_TYPE_802DOT11;
+				wlan_process_uap_rx_packet(priv, pmbuf2);
+			}
+
+			/* Now, process this pkt as a normal data packet.
+			 * rx_pkt_offset points to the 802.11 hdr. Construct
+			 * 802.3 header from 802.11 hdr fields and attach it
+			 * just before the payload.
+			 */
+			memcpy(pmadapter, (t_u8 *)&dest_addr, pwlan_hdr->addr1,
+			       sizeof(pwlan_hdr->addr1));
+			memcpy(pmadapter, (t_u8 *)&src_addr, pwlan_hdr->addr2,
+			       sizeof(pwlan_hdr->addr2));
+
+			hdr_len = sizeof(wlan_802_11_header);
+
+			/* subtract mac addr field size for 3 address mac80211
+			 * header */
+			if (!(frmctl->from_ds && frmctl->to_ds))
+				hdr_len -= sizeof(mlan_802_11_mac_addr);
+
+			/* add 2 bytes of qos ctrl flags */
+			if (frmctl->sub_type & QOS_DATA)
+				hdr_len += 2;
+
+			if (prx_pd->rx_pkt_type == PKT_TYPE_AMSDU) {
+				/* no need to generate 802.3 hdr, update pkt
+				 * offset */
+				prx_pd->rx_pkt_offset += hdr_len;
+				prx_pd->rx_pkt_length -= hdr_len;
+			} else {
+				/* skip 6-byte snap and 2-byte type */
+				if (memcmp(pmadapter,
+					   (t_u8 *)pwlan_hdr + hdr_len,
+					   snap_eth_hdr,
+					   sizeof(snap_eth_hdr)) == 0)
+					hdr_len += 8;
+
+				peth_hdr2 =
+					(EthII_Hdr_t *)((t_u8 *)prx_pd +
+							prx_pd->rx_pkt_offset +
+							hdr_len -
+							sizeof(EthII_Hdr_t));
+				memcpy(pmadapter, peth_hdr2->dest_addr,
+				       (t_u8 *)&dest_addr,
+				       sizeof(peth_hdr2->dest_addr));
+				memcpy(pmadapter, peth_hdr2->src_addr,
+				       (t_u8 *)&src_addr,
+				       sizeof(peth_hdr2->src_addr));
+
+				/* Update the rx_pkt_offset to point the 802.3
+				 * hdr */
+				prx_pd->rx_pkt_offset +=
+					(hdr_len - sizeof(EthII_Hdr_t));
+				prx_pd->rx_pkt_length -=
+					(hdr_len - sizeof(EthII_Hdr_t));
+			}
+			/* update the prx_pkt pointer */
+			prx_pkt = (RxPacketHdr_t *)((t_u8 *)prx_pd +
+						    prx_pd->rx_pkt_offset);
+		} else {
+			pmbuf->status_code = MLAN_ERROR_PKT_SIZE_INVALID;
+			ret = MLAN_STATUS_FAILURE;
+			PRINTM(MERROR,
+			       "Drop invalid unicast sniffer pkt, subType=0x%x, flag=0x%x, pkt_type=%d\n",
+			       frmctl->sub_type, prx_pd->flags,
+			       prx_pd->rx_pkt_type);
+			wlan_free_mlan_buffer(pmadapter, pmbuf);
+			goto done;
+		}
+	}
+
 	if (rx_pkt_type != PKT_TYPE_BAR) {
 		priv->rxpd_rate = prx_pd->rx_rate;
 		priv->rxpd_rate_info = prx_pd->rate_info;
@@ -388,7 +567,11 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 		}
 	}
 
-	sta_ptr = wlan_get_station_entry(priv, prx_pkt->eth803_hdr.src_addr);
+	if (prx_pd->flags & RXPD_FLAG_PKT_EASYMESH)
+		sta_ptr = wlan_get_station_entry(priv, prx_pd->ta_mac);
+	else
+		sta_ptr = wlan_get_station_entry(priv,
+						 prx_pkt->eth803_hdr.src_addr);
 	if (sta_ptr) {
 		sta_ptr->snr = prx_pd->snr;
 		sta_ptr->nf = prx_pd->nf;
@@ -396,6 +579,10 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 			pmadapter->pmoal_handle, &last_rx_sec, &last_rx_usec);
 		sta_ptr->stats.last_rx_in_msec =
 			(t_u64)last_rx_sec * 1000 + (t_u64)last_rx_usec / 1000;
+		if (rx_pkt_type != PKT_TYPE_BAR) {
+			sta_ptr->stats.rx_packets++;
+			sta_ptr->stats.rx_bytes += prx_pd->rx_pkt_length;
+		}
 	}
 
 #ifdef DRV_EMBEDDED_AUTHENTICATOR
@@ -413,9 +600,18 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 	}
 #endif
 
-	pmbuf->priority = prx_pd->priority;
-	memcpy_ext(pmadapter, ta, prx_pkt->eth803_hdr.src_addr,
-		   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	pmbuf->priority |= prx_pd->priority;
+	if (pmadapter->enable_net_mon &&
+	    (prx_pd->rx_pkt_type == PKT_TYPE_802DOT11)) {
+		wlan_process_uap_rx_packet(priv, pmbuf);
+		goto done;
+	}
+	if (prx_pd->flags & RXPD_FLAG_PKT_EASYMESH)
+		memcpy_ext(pmadapter, ta, prx_pd->ta_mac, MLAN_MAC_ADDR_LENGTH,
+			   MLAN_MAC_ADDR_LENGTH);
+	else
+		memcpy_ext(pmadapter, ta, prx_pkt->eth803_hdr.src_addr,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 	if ((rx_pkt_type != PKT_TYPE_BAR) && (prx_pd->priority < MAX_NUM_TID)) {
 		sta_ptr = wlan_get_station_entry(priv, ta);
 		if (sta_ptr) {
@@ -425,7 +621,7 @@ mlan_status wlan_ops_uap_process_rx_packet(t_void *adapter, pmlan_buffer pmbuf)
 		}
 	}
 	/* check if UAP enable 11n */
-	if (!priv->is_11n_enabled ||
+	if ((!priv->is_11n_enabled && !priv->is_11ax_enabled) ||
 	    (!wlan_11n_get_rxreorder_tbl((mlan_private *)priv, prx_pd->priority,
 					 ta) &&
 	     (prx_pd->rx_pkt_type != PKT_TYPE_AMSDU))) {
@@ -474,8 +670,7 @@ mlan_status wlan_uap_recv_packet(mlan_private *priv, pmlan_buffer pmbuf)
 	       MAC2STR(prx_pkt->eth803_hdr.dest_addr));
 
 	/* don't do packet forwarding in disconnected state */
-	if ((priv->media_connected == MFALSE) ||
-	    (pmbuf->data_len > MV_ETH_FRAME_LEN))
+	if (priv->media_connected == MFALSE)
 		goto upload;
 
 	if (prx_pkt->eth803_hdr.dest_addr[0] & 0x01) {
@@ -624,10 +819,16 @@ mlan_status wlan_process_uap_rx_packet(mlan_private *priv, pmlan_buffer pmbuf)
 	PRINTM(MDATA, "Rx dest " MACSTR "\n",
 	       MAC2STR(prx_pkt->eth803_hdr.dest_addr));
 
+	if (pmadapter->enable_net_mon) {
+		if (prx_pd->rx_pkt_type == PKT_TYPE_802DOT11) {
+			pmbuf->flags |= MLAN_BUF_FLAG_NET_MONITOR;
+			goto upload;
+		}
+	}
+
 	/* don't do packet forwarding in disconnected state */
 	/* don't do packet forwarding when packet > 1514 */
-	if ((priv->media_connected == MFALSE) ||
-	    ((pmbuf->data_len - prx_pd->rx_pkt_offset) > MV_ETH_FRAME_LEN))
+	if (priv->media_connected == MFALSE)
 		goto upload;
 
 	if (prx_pkt->eth803_hdr.dest_addr[0] & 0x01) {
@@ -796,6 +997,14 @@ mlan_status wlan_process_uap_rx_packet(mlan_private *priv, pmlan_buffer pmbuf)
 	PRINTM(MDATA, "%lu.%06lu : Data => kernel seq_num=%d tid=%d\n",
 	       pmbuf->out_ts_sec, pmbuf->out_ts_usec, prx_pd->seq_num,
 	       prx_pd->priority);
+	if (pmbuf->flags & MLAN_BUF_FLAG_NET_MONITOR) {
+		// Use some rxpd space to save rxpd info for radiotap header
+		// We should insure radiotap_info is not bigger than RxPD
+		wlan_rxpdinfo_to_radiotapinfo(
+			priv, (RxPD *)prx_pd,
+			(radiotap_info *)(pmbuf->pbuf + pmbuf->data_offset -
+					  sizeof(radiotap_info)));
+	}
 
 	ret = pmadapter->callbacks.moal_recv_packet(pmadapter->pmoal_handle,
 						    pmbuf);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c
old mode 100644
new mode 100755
index 5a5f2d8aa..4a7264786
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_usb.c
@@ -3,7 +3,7 @@
  *  @brief This file contains USB specific code
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -37,12 +37,23 @@ Change log:
 /********************************************************
 			Local Variables
 ********************************************************/
+#ifdef USB8801
+static const struct _mlan_card_info mlan_card_info_usb8801 = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_2K,
+	.v14_fw_api = 1,
+	.v16_fw_api = 0,
+	.supp_ps_handshake = 1,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_1X1,
+	.support_11mc = 0,
+};
+#endif
 #ifdef USB8897
 static const struct _mlan_card_info mlan_card_info_usb8897 = {
 	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
 	.v16_fw_api = 0,
 	.supp_ps_handshake = 1,
 	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 0,
 };
 #endif
 
@@ -52,6 +63,7 @@ static const struct _mlan_card_info mlan_card_info_usb8997 = {
 	.v16_fw_api = 1,
 	.supp_ps_handshake = 1,
 	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
 };
 #endif
 
@@ -61,6 +73,7 @@ static const struct _mlan_card_info mlan_card_info_usb8978 = {
 	.v16_fw_api = 1,
 	.supp_ps_handshake = 1,
 	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
 };
 #endif
 
@@ -71,6 +84,7 @@ static const struct _mlan_card_info mlan_card_info_usb9098 = {
 	.v17_fw_api = 1,
 	.supp_ps_handshake = 1,
 	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
 };
 #endif
 
@@ -81,6 +95,18 @@ static const struct _mlan_card_info mlan_card_info_usb9097 = {
 	.v17_fw_api = 1,
 	.supp_ps_handshake = 1,
 	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
+};
+#endif
+
+#ifdef USBIW62X
+static const struct _mlan_card_info mlan_card_info_usbIW62X = {
+	.max_tx_buf_size = MLAN_TX_DATA_BUF_SIZE_4K,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.supp_ps_handshake = 1,
+	.default_11n_tx_bf_cap = DEFAULT_11N_TX_BF_CAP_2X2,
+	.support_11mc = 1,
 };
 #endif
 
@@ -99,7 +125,8 @@ static const struct _mlan_card_info mlan_card_info_usb9097 = {
  *  @param rev_id         A pointer to chip revision id
  *  @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_usb_check_revision(mlan_adapter *pmadapter, t_u32 *rev_id)
+static mlan_status wlan_usb_check_revision(mlan_adapter *pmadapter,
+					   t_u32 *rev_id)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
@@ -235,6 +262,11 @@ static mlan_status wlan_usb_prog_fw_w_helper(pmlan_adapter pmadapter,
 	if (IS_USB9097(pmadapter->card_type))
 		check_fw_status = MTRUE;
 #endif
+#if defined(USBIW62X)
+	if (IS_USBIW62X(pmadapter->card_type))
+		check_fw_status = MTRUE;
+#endif
+
 	do {
 		/* Send pseudo data to check winner status first */
 		if (check_winner) {
@@ -341,6 +373,16 @@ static mlan_status wlan_usb_prog_fw_w_helper(pmlan_adapter pmadapter,
 				break;
 			}
 
+			if (check_fw_status &&
+			    (SyncFWHeader.status & MBIT(9))) {
+				PRINTM(MERROR,
+				       "FW received Blk with SE_BOOT error 0x%x\n",
+				       SyncFWHeader.status);
+				retries = 0;
+				ret = MLAN_STATUS_FAILURE;
+				break;
+			}
+
 			/* Check the firmware block response for CRC errors */
 			if (SyncFWHeader.cmd) {
 				/* Check firmware block response for CRC and MIC
@@ -416,7 +458,7 @@ static int wlan_usb_deaggr_rx_num_pkts(pmlan_adapter pmadapter, t_u8 *pdata,
 	RxPD *prx_pd;
 
 	ENTER();
-	while (aggr_pkt_len >= sizeof(RxPD)) {
+	while (aggr_pkt_len >= (int)sizeof(RxPD)) {
 		prx_pd = (RxPD *)pdata;
 		pkt_len = wlan_le16_to_cpu(prx_pd->rx_pkt_length) +
 			  wlan_le16_to_cpu(prx_pd->rx_pkt_offset);
@@ -445,10 +487,11 @@ static int wlan_usb_deaggr_rx_num_pkts(pmlan_adapter pmadapter, t_u8 *pdata,
 static inline t_u32 usb_tx_aggr_pad_len(t_u32 len,
 					usb_tx_aggr_params *pusb_tx_aggr)
 {
-	return (len % pusb_tx_aggr->aggr_ctrl.aggr_align) ?
-		       (len + (pusb_tx_aggr->aggr_ctrl.aggr_align -
-			       (len % pusb_tx_aggr->aggr_ctrl.aggr_align))) :
-		       len;
+	return (t_u32)(
+		(len % pusb_tx_aggr->aggr_ctrl.aggr_align) ?
+			(len + (pusb_tx_aggr->aggr_ctrl.aggr_align -
+				(len % pusb_tx_aggr->aggr_ctrl.aggr_align))) :
+			len);
 }
 
 /**
@@ -653,7 +696,8 @@ static inline t_void wlan_usb_tx_send_aggr(pmlan_adapter pmadapter,
 	}
 
 	if (pmbuf_aggr && pmbuf_aggr->data_len) {
-		pmadapter->data_sent = MTRUE;
+		wlan_update_port_status(pmadapter, pusb_tx_aggr->port, MTRUE);
+		pmadapter->data_sent = wlan_usb_data_sent(pmadapter);
 		ret = pmadapter->callbacks.moal_write_data_async(
 			pmadapter->pmoal_handle, pmbuf_aggr,
 			pusb_tx_aggr->port);
@@ -675,6 +719,8 @@ static inline t_void wlan_usb_tx_send_aggr(pmlan_adapter pmadapter,
 			wlan_write_data_complete(pmadapter, pmbuf_aggr, ret);
 			break;
 		case MLAN_STATUS_FAILURE:
+			wlan_update_port_status(pmadapter, pusb_tx_aggr->port,
+						MFALSE);
 			pmadapter->data_sent = MFALSE;
 			PRINTM(MERROR,
 			       "Error: moal_write_data_async failed: 0x%X\n",
@@ -684,6 +730,8 @@ static inline t_void wlan_usb_tx_send_aggr(pmlan_adapter pmadapter,
 			wlan_write_data_complete(pmadapter, pmbuf_aggr, ret);
 			break;
 		case MLAN_STATUS_PENDING:
+			wlan_update_port_status(pmadapter, pusb_tx_aggr->port,
+						MFALSE);
 			pmadapter->data_sent = MFALSE;
 			break;
 		case MLAN_STATUS_SUCCESS:
@@ -728,6 +776,11 @@ mlan_status wlan_get_usb_device(pmlan_adapter pmadapter)
 	}
 
 	switch (card_type) {
+#ifdef USB8801
+	case CARD_TYPE_USB8801:
+		pmadapter->pcard_info = &mlan_card_info_usb8801;
+		break;
+#endif
 #ifdef USB8897
 	case CARD_TYPE_USB8897:
 		pmadapter->pcard_info = &mlan_card_info_usb8897;
@@ -752,6 +805,11 @@ mlan_status wlan_get_usb_device(pmlan_adapter pmadapter)
 	case CARD_TYPE_USB9097:
 		pmadapter->pcard_info = &mlan_card_info_usb9097;
 		break;
+#endif
+#ifdef USBIW62X
+	case CARD_TYPE_USBIW62X:
+		pmadapter->pcard_info = &mlan_card_info_usbIW62X;
+		break;
 #endif
 	default:
 		PRINTM(MERROR, "can't get right USB card type \n");
@@ -771,7 +829,8 @@ mlan_status wlan_get_usb_device(pmlan_adapter pmadapter)
  *
  *  @return		MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_usb_dnld_fw(pmlan_adapter pmadapter, pmlan_fw_image pmfw)
+static mlan_status wlan_usb_dnld_fw(pmlan_adapter pmadapter,
+				    pmlan_fw_image pmfw)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
@@ -813,7 +872,7 @@ mlan_status wlan_usb_deaggr_rx_pkt(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 		       wlan_le16_to_cpu(prx_pd->rx_pkt_offset);
 	/* if non-aggregate, just send through, dont process here */
 	aggr_len = pmbuf->data_len;
-	if ((aggr_len == curr_pkt_len) ||
+	if ((aggr_len == (t_s32)curr_pkt_len) ||
 	    (wlan_usb_deaggr_rx_num_pkts(pmadapter, pdata, aggr_len) == 1) ||
 	    (pmadapter->pcard_usb->usb_rx_deaggr.aggr_ctrl.enable != MTRUE)) {
 		ret = wlan_handle_rx_packet(pmadapter, pmbuf);
@@ -821,7 +880,7 @@ mlan_status wlan_usb_deaggr_rx_pkt(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 		return ret;
 	}
 
-	while (aggr_len >= sizeof(RxPD)) {
+	while (aggr_len >= (t_s32)sizeof(RxPD)) {
 		/* check for (all-zeroes) termination RxPD */
 		if (!memcmp(pmadapter, pdata, zero_rx_pd, sizeof(RxPD))) {
 			break;
@@ -855,7 +914,7 @@ mlan_status wlan_usb_deaggr_rx_pkt(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 			break;
 		}
 		/* last block has no padding bytes */
-		if (aggr_len == curr_pkt_len) {
+		if (aggr_len == (t_s32)curr_pkt_len) {
 			break;
 		}
 
@@ -890,8 +949,8 @@ mlan_status wlan_usb_deaggr_rx_pkt(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
  *
  *  @return             MTRUE/MFALSE
  */
-t_u8 wlan_is_port_tx_paused(pmlan_adapter pmadapter,
-			    usb_tx_aggr_params *pusb_tx_aggr)
+static t_u8 wlan_is_port_tx_paused(pmlan_adapter pmadapter,
+				   usb_tx_aggr_params *pusb_tx_aggr)
 {
 	mlan_private *pmpriv = MNULL;
 	t_u8 i;
@@ -918,13 +977,16 @@ t_void wlan_usb_tx_aggr_timeout_func(t_void *function_context)
 {
 	usb_tx_aggr_params *pusb_tx_aggr =
 		(usb_tx_aggr_params *)function_context;
+	t_u8 port_index = 0;
 	pmlan_adapter pmadapter = (mlan_adapter *)pusb_tx_aggr->phandle;
 	pmlan_callbacks pcb = &pmadapter->callbacks;
 
 	ENTER();
 	pcb->moal_spin_lock(pmadapter->pmoal_handle, pusb_tx_aggr->paggr_lock);
 	pusb_tx_aggr->aggr_hold_timer_is_set = MFALSE;
-	if (pusb_tx_aggr->pmbuf_aggr && !pmadapter->data_sent &&
+	port_index = wlan_get_port_index(pmadapter, pusb_tx_aggr->port);
+	if (pusb_tx_aggr->pmbuf_aggr &&
+	    wlan_is_port_ready(pmadapter, port_index) &&
 	    !wlan_is_port_tx_paused(pmadapter, pusb_tx_aggr))
 		wlan_usb_tx_send_aggr(pmadapter, pusb_tx_aggr);
 	pcb->moal_spin_unlock(pmadapter->pmoal_handle,
@@ -1089,6 +1151,98 @@ mlan_status wlan_usb_host_to_card_aggr(pmlan_adapter pmadapter,
 	return ret;
 }
 
+/**
+ *  @brief  This function used to check if any USB port still available
+ *
+ *  @param pmadapter	A pointer to mlan_adapter
+ *
+ *  @return		MTRUE--non of the port is available.
+ *              MFALSE -- still have port available.
+ */
+inline t_u8 wlan_usb_data_sent(pmlan_adapter pmadapter)
+{
+	int i;
+	for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
+		if (pmadapter->pcard_usb->usb_port_status[i] == MFALSE)
+			return MFALSE;
+	}
+	return MTRUE;
+}
+
+/**
+ *  @brief  This function resync the USB tx port
+ *
+ *  @param pmadapter	A pointer to mlan_adapter
+ *
+ *  @return		N/A
+ */
+void wlan_resync_usb_port(pmlan_adapter pmadapter)
+{
+	t_u32 active_port = pmadapter->usb_tx_ports[0];
+	int i;
+	/* MC is enabled */
+	if (pmadapter->mc_status) {
+		for (i = 0; i < MIN(pmadapter->priv_num, MLAN_MAX_BSS_NUM);
+		     i++) {
+			if (pmadapter->priv[i]) {
+				if (((GET_BSS_ROLE(pmadapter->priv[i]) ==
+				      MLAN_BSS_ROLE_UAP) &&
+				     !pmadapter->priv[i]->uap_bss_started) ||
+				    ((GET_BSS_ROLE(pmadapter->priv[i]) ==
+				      MLAN_BSS_ROLE_STA) &&
+				     !pmadapter->priv[i]->media_connected)) {
+					PRINTM(MINFO,
+					       "Set deactive interface to default EP\n");
+					pmadapter->priv[i]->port =
+						pmadapter->usb_tx_ports[0];
+					;
+					pmadapter->priv[i]->port_index = 0;
+				}
+			}
+		}
+		/** Enable all the ports */
+		for (i = 0; i < MAX_USB_TX_PORT_NUM; i++)
+			pmadapter->pcard_usb->usb_port_status[i] = MFALSE;
+	} else {
+		/* Get active port from connected interface */
+		for (i = 0; i < MIN(pmadapter->priv_num, MLAN_MAX_BSS_NUM);
+		     i++) {
+			if (pmadapter->priv[i]) {
+				if (((GET_BSS_ROLE(pmadapter->priv[i]) ==
+				      MLAN_BSS_ROLE_UAP) &&
+				     pmadapter->priv[i]->uap_bss_started) ||
+				    ((GET_BSS_ROLE(pmadapter->priv[i]) ==
+				      MLAN_BSS_ROLE_STA) &&
+				     pmadapter->priv[i]->media_connected)) {
+					active_port = pmadapter->priv[i]->port;
+					PRINTM(MEVENT, "active port=%d\n",
+					       active_port);
+					break;
+				}
+			}
+		}
+		/** set all the interface to the same port */
+		for (i = 0; i < MIN(pmadapter->priv_num, MLAN_MAX_BSS_NUM);
+		     i++) {
+			if (pmadapter->priv[i]) {
+				pmadapter->priv[i]->port = active_port;
+				pmadapter->priv[i]->port_index =
+					wlan_get_port_index(pmadapter,
+							    active_port);
+			}
+		}
+		for (i = 0; i < MAX_USB_TX_PORT_NUM; i++) {
+			if (active_port == pmadapter->usb_tx_ports[i])
+				pmadapter->pcard_usb->usb_port_status[i] =
+					MFALSE;
+			else
+				pmadapter->pcard_usb->usb_port_status[i] =
+					MTRUE;
+		}
+	}
+	return;
+}
+
 /**
  *  @brief This function wakes up the card.
  *
@@ -1097,7 +1251,8 @@ mlan_status wlan_usb_host_to_card_aggr(pmlan_adapter pmadapter,
  *
  *  @return			MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_pm_usb_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
+static mlan_status wlan_pm_usb_wakeup_card(pmlan_adapter pmadapter,
+					   t_u8 timeout)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u32 age_ts_usec;
@@ -1135,8 +1290,9 @@ mlan_status wlan_pm_usb_wakeup_card(pmlan_adapter pmadapter, t_u8 timeout)
  *
  *  @return          MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
-				  mlan_buffer *pmbuf, mlan_tx_param *tx_param)
+static mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
+					 mlan_buffer *pmbuf,
+					 mlan_tx_param *tx_param)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	usb_tx_aggr_params *pusb_tx_aggr = MNULL;
@@ -1149,7 +1305,7 @@ mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
 		return MLAN_STATUS_FAILURE;
 	}
 	if (type == MLAN_TYPE_CMD
-#if (defined(USB9098) || defined(USB9097))
+#if (defined(USB9098) || defined(USB9097) || defined(USBIW62X))
 	    || type == MLAN_TYPE_VDLL
 #endif
 	) {
@@ -1166,7 +1322,9 @@ mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
 		ret = wlan_usb_host_to_card_aggr(pmadapter, pmbuf, tx_param,
 						 pusb_tx_aggr);
 	} else {
-		pmadapter->data_sent = MTRUE;
+		pmadapter->pcard_usb->usb_port_status[pmpriv->port_index] =
+			MTRUE;
+		pmadapter->data_sent = wlan_usb_data_sent(pmadapter);
 		ret = pmadapter->callbacks.moal_write_data_async(
 			pmadapter->pmoal_handle, pmbuf, pmpriv->port);
 		switch (ret) {
@@ -1177,9 +1335,13 @@ mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
 
 			break;
 		case MLAN_STATUS_FAILURE:
+			pmadapter->pcard_usb
+				->usb_port_status[pmpriv->port_index] = MFALSE;
 			pmadapter->data_sent = MFALSE;
 			break;
 		case MLAN_STATUS_PENDING:
+			pmadapter->pcard_usb
+				->usb_port_status[pmpriv->port_index] = MFALSE;
 			pmadapter->data_sent = MFALSE;
 			break;
 		case MLAN_STATUS_SUCCESS:
@@ -1200,8 +1362,9 @@ mlan_status wlan_usb_host_to_card(pmlan_private pmpriv, t_u8 type,
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return          N/A
  */
-mlan_status wlan_usb_cmdevt_complete(pmlan_adapter pmadapter,
-				     mlan_buffer *pmbuf, mlan_status status)
+static mlan_status wlan_usb_cmdevt_complete(pmlan_adapter pmadapter,
+					    mlan_buffer *pmbuf,
+					    mlan_status status)
 {
 	ENTER();
 
@@ -1219,8 +1382,9 @@ mlan_status wlan_usb_cmdevt_complete(pmlan_adapter pmadapter,
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return          N/A
  */
-mlan_status wlan_usb_data_complete(pmlan_adapter pmadapter, mlan_buffer *pmbuf,
-				   mlan_status status)
+static mlan_status wlan_usb_data_complete(pmlan_adapter pmadapter,
+					  mlan_buffer *pmbuf,
+					  mlan_status status)
 {
 	ENTER();
 
@@ -1238,8 +1402,8 @@ mlan_status wlan_usb_data_complete(pmlan_adapter pmadapter, mlan_buffer *pmbuf,
  *  @param pmbuf     A pointer to the mlan_buffer
  *  @return
  */
-mlan_status wlan_usb_handle_rx_packet(mlan_adapter *pmadapter,
-				      pmlan_buffer pmbuf)
+static mlan_status wlan_usb_handle_rx_packet(mlan_adapter *pmadapter,
+					     pmlan_buffer pmbuf)
 {
 	ENTER();
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h
old mode 100644
new mode 100755
index c86269e2b..5f96256e4
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_util.h
@@ -4,7 +4,7 @@
  *  spinlock and timer defines.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -47,6 +47,9 @@ typedef struct _mlan_list_head {
 	t_void *plock;
 } mlan_list_head, *pmlan_list_head;
 
+/** MLAN MNULL pointer */
+#define MNULL ((void *)0)
+
 /**
  *  @brief This function initializes a list without locking
  *
@@ -78,7 +81,7 @@ static INLINE t_void util_init_list_head(
 	if (lock_required)
 		moal_init_lock(pmoal_handle, &phead->plock);
 	else
-		phead->plock = 0;
+		phead->plock = MNULL;
 }
 
 /**
@@ -93,7 +96,7 @@ static INLINE t_void util_free_list_head(
 	t_void *pmoal_handle, pmlan_list_head phead,
 	mlan_status (*moal_free_lock)(t_void *handle, t_void *plock))
 {
-	phead->pprev = phead->pnext = 0;
+	phead->pprev = phead->pnext = MNULL;
 	if (phead->plock)
 		moal_free_lock(pmoal_handle, phead->plock);
 }
@@ -112,7 +115,7 @@ util_peek_list(t_void *pmoal_handle, pmlan_list_head phead,
 	       mlan_status (*moal_spin_lock)(t_void *handle, t_void *plock),
 	       mlan_status (*moal_spin_unlock)(t_void *handle, t_void *plock))
 {
-	pmlan_linked_list pnode = 0;
+	pmlan_linked_list pnode = MNULL;
 
 	if (moal_spin_lock)
 		moal_spin_lock(pmoal_handle, phead->plock);
@@ -204,7 +207,7 @@ static INLINE t_void util_unlink_list(
 	pmy_next->pprev = pmy_prev;
 	pmy_prev->pnext = pmy_next;
 
-	pnode->pnext = pnode->pprev = 0;
+	pnode->pnext = pnode->pprev = MNULL;
 	if (moal_spin_unlock)
 		moal_spin_unlock(pmoal_handle, phead->plock);
 }
@@ -229,9 +232,9 @@ static INLINE pmlan_linked_list util_dequeue_list(
 		moal_spin_lock(pmoal_handle, phead->plock);
 	pnode = phead->pnext;
 	if (pnode && (pnode != (pmlan_linked_list)phead))
-		util_unlink_list(pmoal_handle, phead, pnode, 0, 0);
+		util_unlink_list(pmoal_handle, phead, pnode, MNULL, MNULL);
 	else
-		pnode = 0;
+		pnode = MNULL;
 	if (moal_spin_unlock)
 		moal_spin_unlock(pmoal_handle, phead->plock);
 	return pnode;
@@ -400,8 +403,10 @@ static INLINE t_void util_scalar_decrement(
  *  @param moal_spin_lock	A pointer to spin lock handler
  *  @param moal_spin_unlock	A pointer to spin unlock handler
  *
- *  @return					Value after offset
+ *  @return			Value after offset or 0 if (scalar_value + offset)
+ * overflows
  */
+#define INT_MAX 2147483647
 static INLINE t_s32 util_scalar_offset(
 	t_void *pmoal_handle, pmlan_scalar pscalar, t_s32 offset,
 	mlan_status (*moal_spin_lock)(t_void *handle, t_void *plock),
@@ -411,7 +416,10 @@ static INLINE t_s32 util_scalar_offset(
 
 	if (moal_spin_lock)
 		moal_spin_lock(pmoal_handle, pscalar->plock);
-	newval = (pscalar->value += offset);
+	if (pscalar->value < (INT_MAX - offset))
+		newval = (pscalar->value += offset);
+	else
+		newval = 0;
 	if (moal_spin_unlock)
 		moal_spin_unlock(pmoal_handle, pscalar->plock);
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c
old mode 100644
new mode 100755
index c9200b816..17e9a4612
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.c
@@ -3,7 +3,7 @@
  *  @brief This file contains functions for WMM.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -34,6 +34,7 @@ Change log:
 #include "mlan_main.h"
 #include "mlan_wmm.h"
 #include "mlan_11n.h"
+#include "mlan_11ax.h"
 #ifdef SDIO
 #include "mlan_sdio.h"
 #endif /* SDIO */
@@ -45,35 +46,6 @@ Change log:
 			Local Variables
 ********************************************************/
 
-/** Maximum value FW can accept for driver delay in packet transmission */
-#define DRV_PKT_DELAY_TO_FW_MAX 512
-
-/*
- * Upper and Lower threshold for packet queuing in the driver
-
- *    - When the number of packets queued reaches the upper limit,
- *      the driver will stop the net queue in the app/kernel space.
-
- *    - When the number of packets drops beneath the lower limit after
- *      having reached the upper limit, the driver will restart the net
- *      queue.
- */
-
-/** Lower threshold for packet queuing in the driver.
- * When the number of packets drops beneath the lower limit after having
- * reached the upper limit, the driver will restart the net queue.
- */
-#define WMM_QUEUED_PACKET_LOWER_LIMIT 180
-
-/** Upper threshold for packet queuing in the driver.
- * When the number of packets queued reaches the upper limit, the driver
- * will stop the net queue in the app/kernel space.
- */
-#define WMM_QUEUED_PACKET_UPPER_LIMIT 200
-
-/** Offset for TOS field in the IP header */
-#define IPTOS_OFFSET 5
-
 /** WMM information IE */
 static const t_u8 wmm_info_ie[] = {WMM_IE, 0x07, 0x00, 0x50, 0xf2,
 				   0x02,   0x00, 0x01, 0x00};
@@ -97,7 +69,7 @@ static const t_u8 wmm_aci_to_qidx_map[] = {WMM_AC_BE, WMM_AC_BK, WMM_AC_VI,
  * This table will be used to store the tid values based on ACs.
  * It is initialized to default values per TID.
  */
-t_u8 tos_to_tid[] = {
+static t_u8 tos_to_tid[] = {
 	/* TID        DSCP_P2   DSCP_P1  DSCP_P0   WMM_AC   */
 	0x01, /*    0         1        0       AC_BK   */
 	0x02, /*    0         0        0       AC_BK   */
@@ -124,7 +96,7 @@ t_u8 tos_to_tid_inv[] = {0x02, /* from tos_to_tid[2] = 0 */
  * change and will be used to copy back the default values to tos_to_tid in
  * case of disconnect.
  */
-const t_u8 ac_to_tid[4][2] = {{1, 2}, {0, 3}, {4, 5}, {6, 7}};
+t_u8 ac_to_tid[4][2] = {{1, 2}, {0, 3}, {4, 5}, {6, 7}};
 
 /* Map of TOS UP values to WMM AC */
 static const mlan_wmm_ac_e tos_to_ac[] = {WMM_AC_BE, WMM_AC_BK, WMM_AC_BK,
@@ -208,6 +180,53 @@ static raListTbl *wlan_wmm_allocate_ralist_node(pmlan_adapter pmadapter,
 	return ra_list;
 }
 
+/**
+ *  @brief Add packet to TDLS pending TX queue
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param pmbuf      Pointer to the mlan_buffer data struct
+ *
+ *  @return           N/A
+ */
+static t_void wlan_add_buf_tdls_txqueue(pmlan_private priv, pmlan_buffer pmbuf)
+{
+	mlan_adapter *pmadapter = priv->adapter;
+	ENTER();
+	util_enqueue_list_tail(pmadapter->pmoal_handle, &priv->tdls_pending_txq,
+			       (pmlan_linked_list)pmbuf,
+			       pmadapter->callbacks.moal_spin_lock,
+			       pmadapter->callbacks.moal_spin_unlock);
+	LEAVE();
+}
+
+/**
+ *  @brief Clean up the tdls pending TX queue
+ *
+ *  @param priv		A pointer to mlan_private
+ *
+ *  @return      N/A
+ */
+static t_void wlan_cleanup_tdls_txq(pmlan_private priv)
+{
+	pmlan_buffer pmbuf;
+	mlan_adapter *pmadapter = priv->adapter;
+	ENTER();
+
+	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
+					    priv->tdls_pending_txq.plock);
+	while ((pmbuf = (pmlan_buffer)util_peek_list(pmadapter->pmoal_handle,
+						     &priv->tdls_pending_txq,
+						     MNULL, MNULL))) {
+		util_unlink_list(pmadapter->pmoal_handle,
+				 &priv->tdls_pending_txq,
+				 (pmlan_linked_list)pmbuf, MNULL, MNULL);
+		wlan_write_data_complete(pmadapter, pmbuf, MLAN_STATUS_FAILURE);
+	}
+	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
+					      priv->tdls_pending_txq.plock);
+	LEAVE();
+}
+
 /**
  * @brief Map ACs to TID
  *
@@ -298,8 +317,7 @@ static mlan_wmm_ac_e wlan_wmm_eval_downgrade_ac(pmlan_private priv,
  *
  *  @return     WMM AC Queue mapping of the IP TOS field
  */
-static INLINE mlan_wmm_ac_e wlan_wmm_convert_tos_to_ac(pmlan_adapter pmadapter,
-						       t_u32 tos)
+mlan_wmm_ac_e wlan_wmm_convert_tos_to_ac(pmlan_adapter pmadapter, t_u32 tos)
 {
 	ENTER();
 
@@ -642,6 +660,18 @@ static raListTbl *wlan_wmm_get_highest_priolist_ptr(pmlan_adapter pmadapter,
 				/* Ignore data pkts from a BSS if tx pause */
 				goto next_intf;
 			}
+#if defined(USB)
+			if (!wlan_is_port_ready(pmadapter,
+						priv_tmp->port_index)) {
+				PRINTM(MINFO,
+				       "get_highest_prio_ptr(): "
+				       "usb port is busy,Ignore pkts from BSS%d\n",
+				       priv_tmp->bss_index);
+				/* Ignore data pkts from a BSS if usb port is
+				 * busy */
+				goto next_intf;
+			}
+#endif
 
 			pmadapter->callbacks.moal_spin_lock(
 				pmadapter->pmoal_handle,
@@ -1028,6 +1058,7 @@ static int wlan_dequeue_tx_packet(pmlan_adapter pmadapter)
 	t_u8 ra[MLAN_MAC_ADDR_LENGTH];
 	int tid_del = 0;
 	int tid = 0;
+	mlan_buffer *pmbuf = MNULL;
 
 	ENTER();
 
@@ -1064,13 +1095,40 @@ static int wlan_dequeue_tx_packet(pmlan_adapter pmadapter)
 	}
 	if (ptr->del_ba_count >= DEL_BA_THRESHOLD)
 		wlan_update_del_ba_count(priv, ptr);
-	if (!ptr->is_11n_enabled ||
+	if (pmadapter->tp_state_on) {
+		pmbuf = (pmlan_buffer)util_peek_list(
+			pmadapter->pmoal_handle, &ptr->buf_head, MNULL, MNULL);
+		if (pmbuf) {
+			pmadapter->callbacks.moal_tp_accounting(
+				pmadapter->pmoal_handle, pmbuf, 3);
+			if (pmadapter->tp_state_drop_point == 3) {
+				pmbuf = (pmlan_buffer)util_dequeue_list(
+					pmadapter->pmoal_handle, &ptr->buf_head,
+					MNULL, MNULL);
+				PRINTM(MERROR, "Dequeuing the packet %p %p\n",
+				       ptr, pmbuf);
+				priv->wmm.pkts_queued[ptrindex]--;
+				util_scalar_decrement(pmadapter->pmoal_handle,
+						      &priv->wmm.tx_pkts_queued,
+						      MNULL, MNULL);
+				ptr->total_pkts--;
+				pmadapter->callbacks.moal_spin_unlock(
+					pmadapter->pmoal_handle,
+					priv->wmm.ra_list_spinlock);
+				wlan_write_data_complete(pmadapter, pmbuf,
+							 MLAN_STATUS_SUCCESS);
+				LEAVE();
+				return MLAN_STATUS_SUCCESS;
+			}
+		}
+	}
+	if (!ptr->is_wmm_enabled ||
 	    (ptr->ba_status || ptr->del_ba_count >= DEL_BA_THRESHOLD)
 #ifdef STA_SUPPORT
 	    || priv->wps.session_enable
 #endif /* STA_SUPPORT */
 	) {
-		if (ptr->is_11n_enabled && ptr->ba_status &&
+		if (ptr->is_wmm_enabled && ptr->ba_status &&
 		    ptr->amsdu_in_ampdu &&
 		    wlan_is_amsdu_allowed(priv, ptr, tid) &&
 		    (wlan_num_pkts_in_txq(priv, ptr, pmadapter->tx_buf_size) >=
@@ -1175,6 +1233,200 @@ t_u16 wlan_update_ralist_tx_pause(pmlan_private priv, t_u8 *mac, t_u8 tx_pause)
 }
 
 #ifdef STA_SUPPORT
+/**
+ *  @brief update tx_pause flag in none tdls ra_list
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param mac        peer mac address
+ *  @param tx_pause   tx_pause flag (0/1)
+ *
+ *  @return           N/A
+ */
+t_void wlan_update_non_tdls_ralist(mlan_private *priv, t_u8 *mac, t_u8 tx_pause)
+{
+	raListTbl *ra_list;
+	int i;
+	pmlan_adapter pmadapter = priv->adapter;
+	t_u32 pkt_cnt = 0;
+	t_u32 tx_pkts_queued = 0;
+	ENTER();
+
+	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
+					    priv->wmm.ra_list_spinlock);
+	for (i = 0; i < MAX_NUM_TID; ++i) {
+		ra_list = (raListTbl *)util_peek_list(
+			priv->adapter->pmoal_handle,
+			&priv->wmm.tid_tbl_ptr[i].ra_list, MNULL, MNULL);
+		while (ra_list &&
+		       (ra_list !=
+			(raListTbl *)&priv->wmm.tid_tbl_ptr[i].ra_list)) {
+			if (memcmp(priv->adapter, ra_list->ra, mac,
+				   MLAN_MAC_ADDR_LENGTH) &&
+			    ra_list->tx_pause != tx_pause) {
+				pkt_cnt += ra_list->total_pkts;
+				ra_list->tx_pause = tx_pause;
+				if (tx_pause)
+					priv->wmm.pkts_paused[i] +=
+						ra_list->total_pkts;
+				else
+					priv->wmm.pkts_paused[i] -=
+						ra_list->total_pkts;
+			}
+			ra_list = ra_list->pnext;
+		}
+	}
+	if (pkt_cnt) {
+		tx_pkts_queued = util_scalar_read(pmadapter->pmoal_handle,
+						  &priv->wmm.tx_pkts_queued,
+						  MNULL, MNULL);
+		if (tx_pause)
+			tx_pkts_queued -= pkt_cnt;
+		else
+			tx_pkts_queued += pkt_cnt;
+		util_scalar_write(priv->adapter->pmoal_handle,
+				  &priv->wmm.tx_pkts_queued, tx_pkts_queued,
+				  MNULL, MNULL);
+		util_scalar_write(priv->adapter->pmoal_handle,
+				  &priv->wmm.highest_queued_prio, HIGH_PRIO_TID,
+				  MNULL, MNULL);
+	}
+	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
+					      priv->wmm.ra_list_spinlock);
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief find tdls buffer from ralist
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param ralist     A pointer to ralistTbl
+ *  @param mac        TDLS peer mac address
+ *
+ *  @return           pmlan_buffer or MNULL
+ */
+static pmlan_buffer wlan_find_tdls_packets(mlan_private *priv,
+					   raListTbl *ra_list, t_u8 *mac)
+{
+	pmlan_buffer pmbuf = MNULL;
+	mlan_adapter *pmadapter = priv->adapter;
+	t_u8 ra[MLAN_MAC_ADDR_LENGTH];
+	ENTER();
+	pmbuf = (pmlan_buffer)util_peek_list(priv->adapter->pmoal_handle,
+					     &ra_list->buf_head, MNULL, MNULL);
+	if (!pmbuf) {
+		LEAVE();
+		return MNULL;
+	}
+	while (pmbuf != (pmlan_buffer)&ra_list->buf_head) {
+		memcpy_ext(pmadapter, ra, pmbuf->pbuf + pmbuf->data_offset,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		if (!memcmp(priv->adapter, ra, mac, MLAN_MAC_ADDR_LENGTH)) {
+			LEAVE();
+			return pmbuf;
+		}
+		pmbuf = pmbuf->pnext;
+	}
+	LEAVE();
+	return MNULL;
+}
+
+/**
+ *  @brief find tdls buffer from tdls pending queue
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param mac        TDLS peer mac address
+ *
+ *  @return           pmlan_buffer or MNULL
+ */
+static pmlan_buffer wlan_find_packets_tdls_txq(mlan_private *priv, t_u8 *mac)
+{
+	pmlan_buffer pmbuf = MNULL;
+	mlan_adapter *pmadapter = priv->adapter;
+	t_u8 ra[MLAN_MAC_ADDR_LENGTH];
+	ENTER();
+	pmbuf = (pmlan_buffer)util_peek_list(priv->adapter->pmoal_handle,
+					     &priv->tdls_pending_txq, MNULL,
+					     MNULL);
+	if (!pmbuf) {
+		LEAVE();
+		return MNULL;
+	}
+	while (pmbuf != (pmlan_buffer)&priv->tdls_pending_txq) {
+		memcpy_ext(pmadapter, ra, pmbuf->pbuf + pmbuf->data_offset,
+			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		if (!memcmp(priv->adapter, ra, mac, MLAN_MAC_ADDR_LENGTH)) {
+			LEAVE();
+			return pmbuf;
+		}
+		pmbuf = pmbuf->pnext;
+	}
+	LEAVE();
+	return MNULL;
+}
+
+/**
+ *  @brief Remove TDLS ralist and move packets to AP's ralist
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param mac        TDLS peer mac address
+ *
+ *  @return           N/A
+ */
+static t_void wlan_wmm_delete_tdls_ralist(pmlan_private priv, t_u8 *mac)
+{
+	raListTbl *ra_list;
+	raListTbl *ra_list_ap = MNULL;
+	int i;
+	pmlan_adapter pmadapter = priv->adapter;
+	pmlan_buffer pmbuf;
+	ENTER();
+
+	for (i = 0; i < MAX_NUM_TID; ++i) {
+		ra_list = wlan_wmm_get_ralist_node(priv, i, mac);
+		if (ra_list) {
+			PRINTM(MDATA, "delete TDLS ralist %p\n", ra_list);
+			ra_list_ap = (raListTbl *)util_peek_list(
+				pmadapter->pmoal_handle,
+				&priv->wmm.tid_tbl_ptr[i].ra_list, MNULL,
+				MNULL);
+			if (!ra_list_ap) {
+				LEAVE();
+				return;
+			}
+			while ((pmbuf = (pmlan_buffer)util_peek_list(
+					pmadapter->pmoal_handle,
+					&ra_list->buf_head, MNULL, MNULL))) {
+				util_unlink_list(pmadapter->pmoal_handle,
+						 &ra_list->buf_head,
+						 (pmlan_linked_list)pmbuf,
+						 MNULL, MNULL);
+				util_enqueue_list_tail(pmadapter->pmoal_handle,
+						       &ra_list_ap->buf_head,
+						       (pmlan_linked_list)pmbuf,
+						       MNULL, MNULL);
+				ra_list_ap->total_pkts++;
+				ra_list_ap->packet_count++;
+			}
+			util_free_list_head(
+				(t_void *)pmadapter->pmoal_handle,
+				&ra_list->buf_head,
+				pmadapter->callbacks.moal_free_lock);
+
+			util_unlink_list(pmadapter->pmoal_handle,
+					 &priv->wmm.tid_tbl_ptr[i].ra_list,
+					 (pmlan_linked_list)ra_list, MNULL,
+					 MNULL);
+			pmadapter->callbacks.moal_mfree(pmadapter->pmoal_handle,
+							(t_u8 *)ra_list);
+			if (priv->wmm.tid_tbl_ptr[i].ra_list_curr == ra_list)
+				priv->wmm.tid_tbl_ptr[i].ra_list_curr =
+					ra_list_ap;
+		}
+	}
+
+	LEAVE();
+}
 #endif /* STA_SUPPORT */
 /********************************************************
 			Global Functions
@@ -1205,8 +1457,9 @@ t_u8 wlan_get_random_ba_threshold(pmlan_adapter pmadapter)
 	sec = (sec & 0xFFFF) + (sec >> 16);
 	usec = (usec & 0xFFFF) + (usec >> 16);
 
-	ba_threshold = (((sec << 16) + usec) % BA_SETUP_MAX_PACKET_THRESHOLD) +
-		       pmadapter->min_ba_threshold;
+	ba_threshold =
+		(t_u8)((((sec << 16) + usec) % BA_SETUP_MAX_PACKET_THRESHOLD) +
+		       pmadapter->min_ba_threshold);
 	PRINTM(MINFO, "pmadapter->min_ba_threshold = %d\n",
 	       pmadapter->min_ba_threshold);
 	PRINTM(MINFO, "setup BA after %d packets\n", ba_threshold);
@@ -1229,6 +1482,9 @@ t_void wlan_clean_txrx(pmlan_private priv)
 
 	ENTER();
 	wlan_cleanup_bypass_txq(priv);
+	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
+		wlan_cleanup_tdls_txq(priv);
+	}
 	wlan_11n_cleanup_reorder_tbl(priv);
 	wlan_11n_deleteall_txbastream_tbl(priv);
 #if defined(USB)
@@ -1399,6 +1655,47 @@ void wlan_wmm_setup_ac_downgrade(pmlan_private priv)
 	LEAVE();
 }
 
+/**
+ *  @brief This function checks whether a station has WMM enabled or not
+ *
+ *  @param priv     A pointer to mlan_private
+ *  @param mac      station mac address
+ *  @return         MTRUE or MFALSE
+ */
+static t_u8 is_station_wmm_enabled(mlan_private *priv, t_u8 *mac)
+{
+	sta_node *sta_ptr = MNULL;
+	sta_ptr = wlan_get_station_entry(priv, mac);
+	if (sta_ptr) {
+		if (sta_ptr->is_11n_enabled || sta_ptr->is_11ax_enabled)
+			return MTRUE;
+	}
+	return MFALSE;
+}
+
+/**
+ *  @brief This function checks whether wmm is supported
+ *
+ *  @param priv     A pointer to mlan_private
+ *  @param ra       Address of the receiver STA
+ *
+ *  @return         MTRUE or MFALSE
+ */
+static int wlan_is_wmm_enabled(mlan_private *priv, t_u8 *ra)
+{
+	int ret = MFALSE;
+	ENTER();
+#ifdef UAP_SUPPORT
+	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
+		if ((!(ra[0] & 0x01)) &&
+		    (priv->is_11n_enabled || priv->is_11ax_enabled))
+			ret = is_station_wmm_enabled(priv, ra);
+	}
+#endif /* UAP_SUPPORT */
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief  Allocate and add a RA list for all TIDs with the given RA
  *
@@ -1412,6 +1709,7 @@ void wlan_ralist_add(mlan_private *priv, t_u8 *ra)
 	int i;
 	raListTbl *ra_list;
 	pmlan_adapter pmadapter = priv->adapter;
+	tdlsStatus_e status;
 
 	ENTER();
 
@@ -1424,22 +1722,35 @@ void wlan_ralist_add(mlan_private *priv, t_u8 *ra)
 		ra_list->ba_status = BA_STREAM_NOT_SETUP;
 		ra_list->amsdu_in_ampdu = MFALSE;
 		if (queuing_ra_based(priv)) {
-			ra_list->is_11n_enabled = wlan_is_11n_enabled(priv, ra);
-			if (ra_list->is_11n_enabled)
+			ra_list->is_wmm_enabled = wlan_is_wmm_enabled(priv, ra);
+			if (ra_list->is_wmm_enabled)
 				ra_list->max_amsdu =
 					get_station_max_amsdu_size(priv, ra);
 			ra_list->tx_pause = wlan_is_tx_pause(priv, ra);
 		} else {
-			ra_list->is_11n_enabled = IS_11N_ENABLED(priv);
-			if (ra_list->is_11n_enabled)
-				ra_list->max_amsdu = priv->max_amsdu;
+			ra_list->is_tdls_link = MFALSE;
+			ra_list->tx_pause = MFALSE;
+			status = wlan_get_tdls_link_status(priv, ra);
+			if (MTRUE == wlan_is_tdls_link_setup(status)) {
+				ra_list->is_wmm_enabled =
+					is_station_wmm_enabled(priv, ra);
+				if (ra_list->is_wmm_enabled)
+					ra_list->max_amsdu =
+						get_station_max_amsdu_size(priv,
+									   ra);
+				ra_list->is_tdls_link = MTRUE;
+			} else {
+				ra_list->is_wmm_enabled = IS_11N_ENABLED(priv);
+				if (ra_list->is_wmm_enabled)
+					ra_list->max_amsdu = priv->max_amsdu;
+			}
 		}
 
 		PRINTM_NETINTF(MDATA, priv);
-		PRINTM(MDATA, "ralist %p: is_11n_enabled=%d max_amsdu=%d\n",
-		       ra_list, ra_list->is_11n_enabled, ra_list->max_amsdu);
+		PRINTM(MDATA, "ralist %p: is_wmm_enabled=%d max_amsdu=%d\n",
+		       ra_list, ra_list->is_wmm_enabled, ra_list->max_amsdu);
 
-		if (ra_list->is_11n_enabled) {
+		if (ra_list->is_wmm_enabled) {
 			ra_list->packet_count = 0;
 			ra_list->ba_packet_threshold =
 				wlan_get_random_ba_threshold(pmadapter);
@@ -1613,7 +1924,7 @@ mlan_status wlan_cmd_wmm_status_change(pmlan_private priv)
 
 	ENTER();
 
-	ret = wlan_prepare_cmd(priv, HostCmd_CMD_WMM_GET_STATUS, 0, 0, 0,
+	ret = wlan_prepare_cmd(priv, HostCmd_CMD_WMM_GET_STATUS, 0, 0, MNULL,
 			       MNULL);
 	LEAVE();
 	return ret;
@@ -1646,6 +1957,10 @@ int wlan_wmm_lists_empty(pmlan_adapter pmadapter)
 			}
 			if (priv->tx_pause)
 				continue;
+#if defined(USB)
+			if (!wlan_is_port_ready(pmadapter, priv->port_index))
+				continue;
+#endif
 
 			if (util_scalar_read(
 				    pmadapter->pmoal_handle,
@@ -1751,15 +2066,15 @@ int wlan_ralist_update(mlan_private *priv, t_u8 *old_ra, t_u8 *new_ra)
 			update_count++;
 
 			if (queuing_ra_based(priv)) {
-				ra_list->is_11n_enabled =
-					wlan_is_11n_enabled(priv, new_ra);
-				if (ra_list->is_11n_enabled)
+				ra_list->is_wmm_enabled =
+					wlan_is_wmm_enabled(priv, new_ra);
+				if (ra_list->is_wmm_enabled)
 					ra_list->max_amsdu =
 						get_station_max_amsdu_size(
 							priv, new_ra);
 			} else {
-				ra_list->is_11n_enabled = IS_11N_ENABLED(priv);
-				if (ra_list->is_11n_enabled)
+				ra_list->is_wmm_enabled = IS_11N_ENABLED(priv);
+				if (ra_list->is_wmm_enabled)
 					ra_list->max_amsdu = priv->max_amsdu;
 			}
 
@@ -1772,7 +2087,7 @@ int wlan_ralist_update(mlan_private *priv, t_u8 *old_ra, t_u8 *new_ra)
 			PRINTM(MINFO,
 			       "ralist_update: %p, %d, " MACSTR "-->" MACSTR
 			       "\n",
-			       ra_list, ra_list->is_11n_enabled,
+			       ra_list, ra_list->is_wmm_enabled,
 			       MAC2STR(ra_list->ra), MAC2STR(new_ra));
 
 			memcpy_ext(priv->adapter, ra_list->ra, new_ra,
@@ -1798,6 +2113,7 @@ t_void wlan_wmm_add_buf_txqueue(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 	t_u32 tid;
 	raListTbl *ra_list;
 	t_u8 ra[MLAN_MAC_ADDR_LENGTH], tid_down;
+	tdlsStatus_e status;
 #ifdef UAP_SUPPORT
 	psta_node sta_ptr = MNULL;
 #endif
@@ -1821,12 +2137,32 @@ t_void wlan_wmm_add_buf_txqueue(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 	   association we just don't have to call get_queue_raptr, we will have
 	   only 1 raptr for a tid in case of infra */
 	if (!queuing_ra_based(priv)) {
-		ra_list = (raListTbl *)util_peek_list(
-			pmadapter->pmoal_handle,
-			&priv->wmm.tid_tbl_ptr[tid_down].ra_list, MNULL, MNULL);
-	} else {
 		memcpy_ext(pmadapter, ra, pmbuf->pbuf + pmbuf->data_offset,
 			   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		status = wlan_get_tdls_link_status(priv, ra);
+		if (MTRUE == wlan_is_tdls_link_setup(status)) {
+			ra_list = wlan_wmm_get_queue_raptr(priv, tid_down, ra);
+			pmbuf->flags |= MLAN_BUF_FLAG_TDLS;
+		} else if (status == TDLS_SETUP_INPROGRESS) {
+			wlan_add_buf_tdls_txqueue(priv, pmbuf);
+			pmadapter->callbacks.moal_spin_unlock(
+				pmadapter->pmoal_handle,
+				priv->wmm.ra_list_spinlock);
+			LEAVE();
+			return;
+		} else
+			ra_list = (raListTbl *)util_peek_list(
+				pmadapter->pmoal_handle,
+				&priv->wmm.tid_tbl_ptr[tid_down].ra_list, MNULL,
+				MNULL);
+	} else {
+		if (pmbuf->flags & MLAN_BUF_FLAG_EASYMESH)
+			memcpy_ext(pmadapter, ra, pmbuf->mac,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		else
+			memcpy_ext(pmadapter, ra,
+				   pmbuf->pbuf + pmbuf->data_offset,
+				   MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
 		/** put multicast/broadcast packet in the same ralist */
 		if (ra[0] & 0x01)
 			memset(pmadapter, ra, 0xff, sizeof(ra));
@@ -1834,6 +2170,8 @@ t_void wlan_wmm_add_buf_txqueue(pmlan_adapter pmadapter, pmlan_buffer pmbuf)
 		else if (priv->bss_type == MLAN_BSS_TYPE_UAP) {
 			sta_ptr = wlan_get_station_entry(priv, ra);
 			if (sta_ptr) {
+				sta_ptr->stats.tx_bytes += pmbuf->data_len;
+				sta_ptr->stats.tx_packets++;
 				if (!sta_ptr->is_wmm_enabled &&
 				    !priv->is_11ac_enabled) {
 					tid_down = wlan_wmm_downgrade_tid(priv,
@@ -1930,14 +2268,20 @@ mlan_status wlan_ret_wmm_get_status(pmlan_private priv, t_u8 *ptlv,
 	ENTER();
 
 	send_wmm_event = MFALSE;
-
+	if (resp_len < (int)sizeof(ptlv_hdr->header)) {
+		PRINTM(MINFO,
+		       "WMM: WMM_GET_STATUS err: cmdresp low length received: %d\n",
+		       resp_len);
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
 	PRINTM(MINFO, "WMM: WMM_GET_STATUS cmdresp received: %d\n", resp_len);
 	HEXDUMP("CMD_RESP: WMM_GET_STATUS", pcurrent, resp_len);
 
-	while (resp_len >= sizeof(ptlv_hdr->header)) {
+	while (resp_len >= (int)sizeof(ptlv_hdr->header)) {
 		ptlv_hdr = (MrvlIEtypes_Data_t *)pcurrent;
 		tlv_len = wlan_le16_to_cpu(ptlv_hdr->header.len);
-		if ((tlv_len + sizeof(ptlv_hdr->header)) > resp_len) {
+		if ((int)(tlv_len + sizeof(ptlv_hdr->header)) > resp_len) {
 			PRINTM(MERROR,
 			       "WMM get status: Error in processing  TLV buffer\n");
 			resp_len = 0;
@@ -1957,6 +2301,11 @@ mlan_status wlan_ret_wmm_get_status(pmlan_private priv, t_u8 *ptlv,
 			       ptlv_wmm_q_status->flow_required,
 			       ptlv_wmm_q_status->disabled);
 
+			/* Pick the minimum among these to avoid array out of
+			 * bounds */
+			ptlv_wmm_q_status->queue_index = MIN(
+				ptlv_wmm_q_status->queue_index, MAX_AC_QUEUES);
+
 			pac_status =
 				&priv->wmm.ac_status[ptlv_wmm_q_status
 							     ->queue_index];
@@ -2074,13 +2423,11 @@ mlan_status wlan_ret_wmm_get_status(pmlan_private priv, t_u8 *ptlv,
  *  @param ppassoc_buf  Output parameter: Pointer to the TLV output buffer,
  *                      modified on return to point after the appended WMM TLV
  *  @param pwmm_ie      Pointer to the WMM IE for the BSS we are joining
- *  @param pht_cap      Pointer to the HT IE for the BSS we are joining
  *
  *  @return Length of data appended to the association tlv buffer
  */
 t_u32 wlan_wmm_process_association_req(pmlan_private priv, t_u8 **ppassoc_buf,
-				       IEEEtypes_WmmParameter_t *pwmm_ie,
-				       IEEEtypes_HTCap_t *pht_cap)
+				       IEEEtypes_WmmParameter_t *pwmm_ie)
 {
 	MrvlIEtypes_WmmParamSet_t *pwmm_tlv;
 	t_u32 ret_len = 0;
@@ -2105,10 +2452,7 @@ t_u32 wlan_wmm_process_association_req(pmlan_private priv, t_u8 **ppassoc_buf,
 	PRINTM(MINFO, "WMM: process assoc req: bss->wmmIe=0x%x\n",
 	       pwmm_ie->vend_hdr.element_id);
 
-	if ((priv->wmm_required ||
-	     (pht_cap && (pht_cap->ieee_hdr.element_id == HT_CAPABILITY) &&
-	      (priv->config_bands & BAND_GN || priv->config_bands & BAND_AN))) &&
-	    pwmm_ie->vend_hdr.element_id == WMM_IE) {
+	if (priv->wmm_required && pwmm_ie->vend_hdr.element_id == WMM_IE) {
 		pwmm_tlv = (MrvlIEtypes_WmmParamSet_t *)*ppassoc_buf;
 		pwmm_tlv->header.type = (t_u16)wmm_info_ie[0];
 		pwmm_tlv->header.type = wlan_cpu_to_le16(pwmm_tlv->header.type);
@@ -2160,7 +2504,13 @@ t_u8 wlan_wmm_compute_driver_packet_delay(pmlan_private priv,
 
 	priv->adapter->callbacks.moal_get_system_time(
 		priv->adapter->pmoal_handle, &out_ts_sec, &out_ts_usec);
-
+	if (priv->adapter->tp_state_on) {
+		pmbuf->out_ts_sec = out_ts_sec;
+		pmbuf->out_ts_usec = out_ts_usec;
+		if (pmbuf->in_ts_sec)
+			priv->adapter->callbacks.moal_tp_accounting(
+				priv->adapter->pmoal_handle, pmbuf, 11);
+	}
 	queue_delay = (t_s32)(out_ts_sec - pmbuf->in_ts_sec) * 1000;
 	queue_delay += (t_s32)(out_ts_usec - pmbuf->in_ts_usec) / 1000;
 
@@ -2170,7 +2520,8 @@ t_u8 wlan_wmm_compute_driver_packet_delay(pmlan_private priv,
 	 *
 	 * Pass max value if queue_delay is beyond the uint8 range
 	 */
-	ret_val = (t_u8)(MIN(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);
+	ret_val = (t_u8)(MIN(queue_delay, (t_s32)priv->wmm.drv_pkt_delay_max) >>
+			 1);
 
 	PRINTM(MINFO, "WMM: Pkt Delay: %d ms, %d ms sent to FW\n", queue_delay,
 	       ret_val);
@@ -2392,6 +2743,125 @@ t_void wlan_wmm_delete_peer_ralist(pmlan_private priv, t_u8 *mac)
 }
 
 #ifdef STA_SUPPORT
+/**
+ *  @brief Hold TDLS packets to tdls pending queue
+ *
+ *  @param priv		A pointer to mlan_private
+ *  @param mac      station mac address
+ *
+ *  @return      N/A
+ */
+t_void wlan_hold_tdls_packets(pmlan_private priv, t_u8 *mac)
+{
+	pmlan_buffer pmbuf;
+	mlan_adapter *pmadapter = priv->adapter;
+	raListTbl *ra_list = MNULL;
+	t_u8 i;
+
+	ENTER();
+	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
+					    priv->wmm.ra_list_spinlock);
+	PRINTM(MDATA, "wlan_hold_tdls_packets: " MACSTR "\n", MAC2STR(mac));
+	for (i = 0; i < MAX_NUM_TID; ++i) {
+		ra_list = (raListTbl *)util_peek_list(
+			pmadapter->pmoal_handle,
+			&priv->wmm.tid_tbl_ptr[i].ra_list, MNULL, MNULL);
+		if (ra_list) {
+			while ((pmbuf = wlan_find_tdls_packets(priv, ra_list,
+							       mac))) {
+				util_unlink_list(pmadapter->pmoal_handle,
+						 &ra_list->buf_head,
+						 (pmlan_linked_list)pmbuf,
+						 MNULL, MNULL);
+				ra_list->total_pkts--;
+				priv->wmm.pkts_queued[i]--;
+				util_scalar_decrement(pmadapter->pmoal_handle,
+						      &priv->wmm.tx_pkts_queued,
+						      MNULL, MNULL);
+				ra_list->packet_count--;
+				wlan_add_buf_tdls_txqueue(priv, pmbuf);
+				PRINTM(MDATA, "hold tdls packet=%p\n", pmbuf);
+			}
+		}
+	}
+	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
+					      priv->wmm.ra_list_spinlock);
+	LEAVE();
+}
+
+/**
+ *  @brief move TDLS packets back to ralist
+ *
+ *  @param priv		  A pointer to mlan_private
+ *  @param mac        TDLS peer mac address
+ *  @param status     tdlsStatus
+ *
+ *  @return           pmlan_buffer or MNULL
+ */
+t_void wlan_restore_tdls_packets(pmlan_private priv, t_u8 *mac,
+				 tdlsStatus_e status)
+{
+	pmlan_buffer pmbuf;
+	mlan_adapter *pmadapter = priv->adapter;
+	raListTbl *ra_list = MNULL;
+	t_u32 tid;
+	t_u32 tid_down;
+
+	ENTER();
+	PRINTM(MDATA, "wlan_restore_tdls_packets: " MACSTR " status=%d\n",
+	       MAC2STR(mac), status);
+
+	pmadapter->callbacks.moal_spin_lock(pmadapter->pmoal_handle,
+					    priv->wmm.ra_list_spinlock);
+
+	while ((pmbuf = wlan_find_packets_tdls_txq(priv, mac))) {
+		util_unlink_list(pmadapter->pmoal_handle,
+				 &priv->tdls_pending_txq,
+				 (pmlan_linked_list)pmbuf, MNULL, MNULL);
+		tid = pmbuf->priority;
+		tid_down = wlan_wmm_downgrade_tid(priv, tid);
+		if (status == TDLS_SETUP_COMPLETE) {
+			ra_list = wlan_wmm_get_queue_raptr(priv, tid_down, mac);
+			pmbuf->flags |= MLAN_BUF_FLAG_TDLS;
+		} else {
+			ra_list = (raListTbl *)util_peek_list(
+				pmadapter->pmoal_handle,
+				&priv->wmm.tid_tbl_ptr[tid_down].ra_list, MNULL,
+				MNULL);
+			pmbuf->flags &= ~MLAN_BUF_FLAG_TDLS;
+		}
+		if (!ra_list) {
+			PRINTM_NETINTF(MWARN, priv);
+			PRINTM(MWARN,
+			       "Drop packet %p, ra_list=%p media_connected=%d\n",
+			       pmbuf, ra_list, priv->media_connected);
+			wlan_write_data_complete(pmadapter, pmbuf,
+						 MLAN_STATUS_FAILURE);
+			continue;
+		}
+		PRINTM_NETINTF(MDATA, priv);
+		PRINTM(MDATA,
+		       "ADD TDLS pkt %p (priority=%d) back to ra_list %p\n",
+		       pmbuf, pmbuf->priority, ra_list);
+		util_enqueue_list_tail(pmadapter->pmoal_handle,
+				       &ra_list->buf_head,
+				       (pmlan_linked_list)pmbuf, MNULL, MNULL);
+		ra_list->total_pkts++;
+		ra_list->packet_count++;
+		priv->wmm.pkts_queued[tid_down]++;
+		util_scalar_increment(pmadapter->pmoal_handle,
+				      &priv->wmm.tx_pkts_queued, MNULL, MNULL);
+		util_scalar_conditional_write(
+			pmadapter->pmoal_handle, &priv->wmm.highest_queued_prio,
+			MLAN_SCALAR_COND_LESS_THAN, tos_to_tid_inv[tid_down],
+			tos_to_tid_inv[tid_down], MNULL, MNULL);
+	}
+	if (status != TDLS_SETUP_COMPLETE)
+		wlan_wmm_delete_tdls_ralist(priv, mac);
+	pmadapter->callbacks.moal_spin_unlock(pmadapter->pmoal_handle,
+					      priv->wmm.ra_list_spinlock);
+	LEAVE();
+}
 
 /**
  *  @brief This function prepares the command of ADDTS
@@ -2756,6 +3226,7 @@ static mlan_status wlan_wmm_ioctl_qos(pmlan_adapter pmadapter,
 		wmm->param.qos_cfg = pmpriv->wmm_qosinfo;
 	else {
 		pmpriv->wmm_qosinfo = wmm->param.qos_cfg;
+		pmpriv->saved_wmm_qosinfo = wmm->param.qos_cfg;
 	}
 
 	pioctl_req->data_read_written = sizeof(t_u8) + MLAN_SUB_COMMAND_SIZE;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h
old mode 100644
new mode 100755
index 33856f059..a458948b8
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlan/mlan_wmm.h
@@ -4,7 +4,7 @@
  *  of wmm functionalities
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -166,8 +166,7 @@ mlan_status wlan_ret_wmm_param_config(pmlan_private pmpriv,
 /** Process WMM association request */
 extern t_u32 wlan_wmm_process_association_req(pmlan_private priv,
 					      t_u8 **ppAssocBuf,
-					      IEEEtypes_WmmParameter_t *pWmmIE,
-					      IEEEtypes_HTCap_t *pHTCap);
+					      IEEEtypes_WmmParameter_t *pWmmIE);
 #endif /* STA_SUPPORT */
 
 /** setup wmm queue priorities */
@@ -181,6 +180,8 @@ void wlan_wmm_setup_ac_downgrade(pmlan_private priv);
 /** select WMM queue */
 t_u8 wlan_wmm_select_queue(mlan_private *pmpriv, t_u8 tid);
 t_void wlan_wmm_delete_peer_ralist(pmlan_private priv, t_u8 *mac);
+/** Convert the IP TOS to an WMM AC Queue assignment */
+mlan_wmm_ac_e wlan_wmm_convert_tos_to_ac(pmlan_adapter pmadapter, t_u32 tos);
 
 #ifdef STA_SUPPORT
 /*
@@ -225,6 +226,9 @@ extern mlan_status wlan_ret_wmm_queue_stats(pmlan_private pmpriv,
 extern mlan_status wlan_ret_wmm_ts_status(pmlan_private pmpriv,
 					  HostCmd_DS_COMMAND *resp,
 					  mlan_ioctl_req *pioctl_buf);
+
+extern t_u8 tos_to_tid_inv[];
+extern t_u8 ac_to_tid[4][2];
 #endif /* STA_SUPPORT */
 
 /** WMM QUEUE_CONFIG command handler */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan.h
old mode 100644
new mode 100755
index d2cd022e0..4d48ce8e3
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan.h
@@ -4,7 +4,7 @@
  *  It also defines the data structures used for APIs between MLAN and MOAL.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2021 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_decl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_decl.h
old mode 100644
new mode 100755
index 9037910c1..53eefff5c
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_decl.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_decl.h
@@ -3,7 +3,7 @@
  *  @brief This file declares the generic data structures and APIs.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2022 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -24,7 +24,7 @@
 #define _MLAN_DECL_H_
 
 /** MLAN release version */
-#define MLAN_RELEASE_VERSION "210"
+#define MLAN_RELEASE_VERSION "391.p3"
 
 /** Re-define generic data types for MLAN/MOAL */
 /** Signed char (1-byte) */
@@ -98,6 +98,8 @@ typedef t_s32 t_sval;
 /** MLAN FALSE */
 #define MFALSE (0)
 
+#define CHANNEL_SPEC_SNIFFER_MODE 1
+
 #ifndef MACSTR
 /** MAC address security format */
 #define MACSTR "%02x:XX:XX:XX:%02x:%02x"
@@ -127,17 +129,15 @@ typedef t_s32 t_sval;
 /** Return aligned offset */
 #define OFFSET_ALIGN_ADDR(p, a) (t_u32)(ALIGN_ADDR(p, a) - (t_ptr)p)
 
-#if defined(WIFI_DIRECT_SUPPORT)
 /** Maximum BSS numbers */
 #define MLAN_MAX_BSS_NUM (16)
-#else
-/** Maximum BSS numbers */
-#define MLAN_MAX_BSS_NUM (2)
-#endif
 
 /** NET IP alignment */
 #define MLAN_NET_IP_ALIGN 2
 
+/** US country code */
+#define COUNTRY_CODE_US 0x10
+
 /** DMA alignment */
 /* SDIO3.0 Inrevium Adapter require 32 bit DMA alignment */
 #define DMA_ALIGNMENT 32
@@ -233,12 +233,12 @@ typedef t_s32 t_sval;
 /** MU beamformer */
 #define DEFALUT_11AC_CAP_BEAMFORMING_RESET_MASK (MBIT(19))
 
-/** Size of rx data buffer 4096+256 */
-#define MLAN_RX_DATA_BUF_SIZE 4352
+/** Size of rx data buffer 3839+256 */
+#define MLAN_RX_DATA_BUF_SIZE 4096
 
 /** Size of command buffer */
 /** because cal_data_size 2.4 k */
-#define MRVDRV_SIZE_OF_CMD_BUFFER (4 * 1024)
+#define MRVDRV_SIZE_OF_CMD_BUFFER (3 * 1024)
 /** Size of rx command buffer */
 #define MLAN_RX_CMD_BUF_SIZE MRVDRV_SIZE_OF_CMD_BUFFER
 /** Upload size */
@@ -262,10 +262,12 @@ typedef t_s32 t_sval;
 #define FW_RELOAD_NO_EMULATION 2
 /** out band reset with interface re-emulation */
 #define FW_RELOAD_WITH_EMULATION 3
-#ifdef PCIE
 /** pcie card reset */
 #define FW_RELOAD_PCIE_RESET 4
-#endif
+/** sdio hw reset */
+#define FW_RELOAD_SDIO_HW_RESET 5
+/** pcie inband reset */
+#define FW_RELOAD_PCIE_INBAND_RESET 6
 
 #ifdef USB
 #define MLAN_USB_BLOCK_SIZE (512)
@@ -330,6 +332,8 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define ALLOC_BUF_SIZE MLAN_RX_DATA_BUF_SIZE
 /** SDIO MP aggr pkt limit */
 #define SDIO_MP_AGGR_DEF_PKT_LIMIT (16)
+/** SDIO MP aggr pkt limit 8 */
+#define SDIO_MP_AGGR_DEF_PKT_LIMIT_8 (8)
 /** max SDIO MP aggr pkt limit */
 #define SDIO_MP_AGGR_DEF_PKT_LIMIT_MAX (16)
 
@@ -365,6 +369,14 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_9097 0x07
 /** 8978 card type */
 #define CARD_TYPE_8978 0x08
+/** 9177 card type */
+#define CARD_TYPE_9177 0x09
+/** 8801 card type */
+#define CARD_TYPE_8801 0x0a
+/** OWL card type */
+#define CARD_TYPE_IW62X 0x0b
+/** Black bird card type */
+#define CARD_TYPE_AW693 0x0c
 
 /** 9098 A0 reverion num */
 #define CHIP_9098_REV_A0 1
@@ -392,6 +404,14 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_SD9097 (CARD_TYPE_9097 | (INTF_SD << 8))
 /** SD9098 card type */
 #define CARD_TYPE_SD9098 (CARD_TYPE_9098 | (INTF_SD << 8))
+/** SD9177 card type */
+#define CARD_TYPE_SD9177 (CARD_TYPE_9177 | (INTF_SD << 8))
+/** SD8801 card type */
+#define CARD_TYPE_SD8801 (CARD_TYPE_8801 | (INTF_SD << 8))
+/** SD_IW62X card type */
+#define CARD_TYPE_SDIW62X (CARD_TYPE_IW62X | (INTF_SD << 8))
+/** SD_IW62X card type */
+#define CARD_TYPE_SDAW693 (CARD_TYPE_AW693 | (INTF_SD << 8))
 
 #define IS_SD8887(ct) (CARD_TYPE_SD8887 == (ct))
 #define IS_SD8897(ct) (CARD_TYPE_SD8897 == (ct))
@@ -401,6 +421,10 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define IS_SD8987(ct) (CARD_TYPE_SD8987 == (ct))
 #define IS_SD9097(ct) (CARD_TYPE_SD9097 == (ct))
 #define IS_SD9098(ct) (CARD_TYPE_SD9098 == (ct))
+#define IS_SD9177(ct) (CARD_TYPE_SD9177 == (ct))
+#define IS_SD8801(ct) (CARD_TYPE_SD8801 == (ct))
+#define IS_SDIW62X(ct) (CARD_TYPE_SDIW62X == (ct))
+#define IS_SDAW693(ct) (CARD_TYPE_SDAW693 == (ct))
 
 /** SD8887 Card */
 #define CARD_SD8887 "SD8887"
@@ -409,15 +433,23 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 /** SD8977 Card */
 #define CARD_SD8977 "SD8977"
 /** SD8978 Card */
-#define CARD_SD8978 "SD8978"
+#define CARD_SD8978 "SDIW416"
 /** SD8997 Card */
 #define CARD_SD8997 "SD8997"
 /** SD8987 Card */
 #define CARD_SD8987 "SD8987"
 /** SD9097 Card */
-#define CARD_SD9097 "SD9097"
+#define CARD_SD9097 "SDIW620"
 /** SD9098 Card */
 #define CARD_SD9098 "SD9098"
+/** SD9177 Card */
+#define CARD_SD9177 "SDIW612"
+/** SD8801 Card */
+#define CARD_SD8801 "SD8801"
+/** SDIW62X Card */
+#define CARD_SDIW62X "SDIW62X"
+/** SDAW693 Card */
+#define CARD_SDAW693 "SDAW693"
 #endif
 
 #ifdef PCIE
@@ -429,25 +461,41 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_PCIE9097 (CARD_TYPE_9097 | (INTF_PCIE << 8))
 /** PCIE9098 card type */
 #define CARD_TYPE_PCIE9098 (CARD_TYPE_9098 | (INTF_PCIE << 8))
+/** PCIEIW62X card type */
+#define CARD_TYPE_PCIEIW62X (CARD_TYPE_IW62X | (INTF_PCIE << 8))
+/** PCIEAW693 card type */
+#define CARD_TYPE_PCIEAW693 (CARD_TYPE_AW693 | (INTF_PCIE << 8))
 
 #define IS_PCIE8897(ct) (CARD_TYPE_PCIE8897 == (ct))
 #define IS_PCIE8997(ct) (CARD_TYPE_PCIE8997 == (ct))
 #define IS_PCIE9097(ct) (CARD_TYPE_PCIE9097 == (ct))
 #define IS_PCIE9098(ct) (CARD_TYPE_PCIE9098 == (ct))
+#define IS_PCIEIW62X(ct) (CARD_TYPE_PCIEIW62X == (ct))
+#define IS_PCIEAW693(ct) (CARD_TYPE_PCIEAW693 == (ct))
 
 /** PCIE8897 Card */
 #define CARD_PCIE8897 "PCIE8897"
 /** PCIE8997 Card */
 #define CARD_PCIE8997 "PCIE8997"
 /** PCIE9097 Card */
-#define CARD_PCIE9097 "PCIE9097"
+#define CARD_PCIE9097 "PCIEIW620"
 /** PCIE9000S Card */
 #define CARD_PCIE9000S "PCIE9000S"
 /** PCIE9098 Card */
 #define CARD_PCIE9098 "PCIE9098"
+/** PCIEAW690 Card */
+#define CARD_PCIEAW690 "PCIEAW690"
+/** PCIEIW62X Card */
+#define CARD_PCIEIW62X "PCIEIW62X"
+/** PCIEAW693 Card */
+#define CARD_PCIEAW693 "PCIEAW693"
+/** PCIEIW629 Card */
+#define CARD_PCIEIW629 "PCIEIW629"
 #endif
 
 #ifdef USB
+/** USB8801 card type */
+#define CARD_TYPE_USB8801 (CARD_TYPE_8801 | (INTF_USB << 8))
 /** USB8897 card type */
 #define CARD_TYPE_USB8897 (CARD_TYPE_8897 | (INTF_USB << 8))
 /** USB8997 card type */
@@ -458,25 +506,34 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define CARD_TYPE_USB9098 (CARD_TYPE_9098 | (INTF_USB << 8))
 /** USB9097 card type */
 #define CARD_TYPE_USB9097 (CARD_TYPE_9097 | (INTF_USB << 8))
+/** USBIW62X card type */
+#define CARD_TYPE_USBIW62X (CARD_TYPE_IW62X | (INTF_USB << 8))
 
+#define IS_USB8801(ct) (CARD_TYPE_USB8801 == (ct))
 #define IS_USB8897(ct) (CARD_TYPE_USB8897 == (ct))
 #define IS_USB8997(ct) (CARD_TYPE_USB8997 == (ct))
 #define IS_USB8978(ct) (CARD_TYPE_USB8978 == (ct))
 #define IS_USB9098(ct) (CARD_TYPE_USB9098 == (ct))
 #define IS_USB9097(ct) (CARD_TYPE_USB9097 == (ct))
+#define IS_USBIW62X(ct) (CARD_TYPE_USBIW62X == (ct))
 
+/** USB8801 Card */
+#define CARD_USB8801 "USB8801"
 /** USB8897 Card */
 #define CARD_USB8897 "USB8897"
 /** USB8997 Card */
 #define CARD_USB8997 "USB8997"
 /** USB8978 Card */
-#define CARD_USB8978 "USB8978"
+#define CARD_USB8978 "USBIW416"
 /** USB9098 Card */
 #define CARD_USB9098 "USB9098"
 /** USB9097 Card */
-#define CARD_USB9097 "USB9097"
+#define CARD_USB9097 "USBIW620"
+/** USBIW62X Card */
+#define CARD_USBIW62X "USBIW62X"
 #endif
 
+#define IS_CARD8801(ct) (CARD_TYPE_8801 == ((ct)&0xf))
 #define IS_CARD8887(ct) (CARD_TYPE_8887 == ((ct)&0xf))
 #define IS_CARD8897(ct) (CARD_TYPE_8897 == ((ct)&0xf))
 #define IS_CARD8977(ct) (CARD_TYPE_8977 == ((ct)&0xf))
@@ -484,6 +541,9 @@ typedef t_u8 mlan_802_11_mac_addr[MLAN_MAC_ADDR_LENGTH];
 #define IS_CARD8987(ct) (CARD_TYPE_8987 == ((ct)&0xf))
 #define IS_CARD9098(ct) (CARD_TYPE_9098 == ((ct)&0xf))
 #define IS_CARD9097(ct) (CARD_TYPE_9097 == ((ct)&0xf))
+#define IS_CARD9177(ct) (CARD_TYPE_9177 == ((ct)&0xf))
+#define IS_CARDIW62X(ct) (CARD_TYPE_IW62X == ((ct)&0xf))
+#define IS_CARDAW693(ct) (CARD_TYPE_AW693 == ((ct)&0xf))
 
 typedef struct _card_type_entry {
 	t_u16 card_type;
@@ -534,12 +594,18 @@ typedef enum {
 #define MLAN_BUF_FLAG_USB_TX_AGGR MBIT(7)
 #endif
 
+/** Buffer flag for TDLS */
+#define MLAN_BUF_FLAG_TDLS MBIT(8)
+
 /** Buffer flag for TCP_ACK */
 #define MLAN_BUF_FLAG_TCP_ACK MBIT(9)
 
 /** Buffer flag for TX_STATUS */
 #define MLAN_BUF_FLAG_TX_STATUS MBIT(10)
 
+/** Buffer flag for NET_MONITOR */
+#define MLAN_BUF_FLAG_NET_MONITOR MBIT(11)
+
 /** Buffer flag for NULL data packet */
 #define MLAN_BUF_FLAG_NULL_PKT MBIT(12)
 /** Buffer flag for Diag pkt */
@@ -547,6 +613,10 @@ typedef enum {
 
 #define MLAN_BUF_FLAG_TX_CTRL MBIT(14)
 
+#define MLAN_BUF_FLAG_EASYMESH MBIT(16)
+
+#define MLAN_BUF_FLAG_MC_AGGR_PKT MBIT(17)
+
 #ifdef DEBUG_LEVEL1
 /** Debug level bit definition */
 #define MMSG MBIT(0)
@@ -575,6 +645,8 @@ typedef enum {
 
 /** Memory allocation type: DMA */
 #define MLAN_MEM_DMA MBIT(0)
+/** Memory allocation flag: ATOMIC */
+#define MLAN_MEM_FLAG_ATOMIC MBIT(1)
 
 /** Default memory allocation flag */
 #define MLAN_MEM_DEF 0
@@ -633,6 +705,18 @@ typedef enum _mlan_buf_type {
 #endif
 } mlan_buf_type;
 
+#define SCAN_STATE_SCAN_START MBIT(0)
+#define SCAN_STATE_EXT_SCAN MBIT(1)
+#define SCAN_STATE_EXT_SCAN_ENH MBIT(2)
+#define SCAN_STATE_EXT_SCAN_CANCEL MBIT(3)
+#define SCAN_STATE_EXT_SCAN_CMDRESP MBIT(4)
+#define SCAN_STATE_EXT_SCAN_ENH_CMDRESP MBIT(5)
+#define SCAN_STATE_EXT_SCAN_CANCEL_CMDRESP MBIT(6)
+#define SCAN_STATE_EXT_SCAN_RESULT MBIT(7)
+#define SCAN_STATE_LAST_EXT_SCAN_RESULT MBIT(8)
+#define SCAN_STATE_EXT_SCAN_STATUS MBIT(9)
+#define SCAN_STATE_SCAN_COMPLETE MBIT(10)
+
 #ifdef USB
 /** mlan_usb_ep */
 typedef enum _mlan_usb_ep {
@@ -656,6 +740,7 @@ typedef enum _mlan_bss_type {
 #ifdef WIFI_DIRECT_SUPPORT
 	MLAN_BSS_TYPE_WIFIDIRECT = 2,
 #endif
+	MLAN_BSS_TYPE_DFS = 8,
 	MLAN_BSS_TYPE_ANY = 0xff,
 } mlan_bss_type;
 
@@ -729,6 +814,7 @@ typedef enum _mlan_event_id {
 #if defined(PCIE)
 	MLAN_EVENT_ID_SSU_DUMP_FILE = 0x00000039,
 #endif /* SSU_SUPPORT */
+	MLAN_EVENT_ID_CSI = 0x00000040,
 	/* Event generated by MLAN driver (MSB=1) */
 	MLAN_EVENT_ID_DRV_CONNECTED = 0x80000001,
 	MLAN_EVENT_ID_DRV_DEFER_HANDLING = 0x80000002,
@@ -745,11 +831,14 @@ typedef enum _mlan_event_id {
 	MLAN_EVENT_ID_DRV_BGSCAN_RESULT = 0x80000013,
 	MLAN_EVENT_ID_DRV_FLUSH_RX_WORK = 0x80000015,
 	MLAN_EVENT_ID_DRV_DEFER_RX_WORK = 0x80000016,
+	MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ = 0x80000017,
 	MLAN_EVENT_ID_DRV_FT_RESPONSE = 0x80000018,
 	MLAN_EVENT_ID_DRV_FLUSH_MAIN_WORK = 0x80000019,
 #ifdef UAP_SUPPORT
 	MLAN_EVENT_ID_DRV_UAP_CHAN_INFO = 0x80000020,
 #endif
+	MLAN_EVENT_ID_FW_ROAM_OFFLOAD_RESULT = 0x80000023,
+	MLAN_EVENT_ID_DRV_RTT_RESULT = 0x80000025,
 	MLAN_EVENT_ID_DRV_ASSOC_FAILURE_LOGGER = 0x80000026,
 	MLAN_EVENT_ID_DRV_ASSOC_SUCC_LOGGER = 0x80000027,
 	MLAN_EVENT_ID_DRV_DISCONNECT_LOGGER = 0x80000028,
@@ -835,7 +924,8 @@ enum mlan_channel_type {
 /** channel band */
 enum { BAND_2GHZ = 0,
        BAND_5GHZ = 1,
-       BAND_4GHZ = 2,
+       BAND_6GHZ = 2,
+       BAND_4GHZ = 3,
 };
 
 /** channel offset */
@@ -857,6 +947,24 @@ enum { SCAN_MODE_MANUAL = 0,
        SCAN_MODE_USER,
 };
 
+/** DFS state */
+typedef enum _dfs_state_t {
+	/** Channel can be used, CAC (Channel Availability Check) must be done
+	   before using it */
+	DFS_USABLE = 0,
+	/** Channel is not available, radar was detected */
+	DFS_UNAVAILABLE = 1,
+	/** Channel is Available, CAC is done and is free of radar */
+	DFS_AVAILABLE = 2,
+} dfs_state_t;
+
+/** max cac time 10 minutes */
+#define MAX_CAC_DWELL_TIME 600000
+/** default cac time 60 seconds */
+#define DEF_CAC_DWELL_TIME 60000
+/** start freq for 5G */
+#define START_FREQ_11A_BAND 5000
+
 typedef enum _dfs_w53_cfg_t {
 	/** DFS W53 Default Fw Value */
 	DFS_W53_DEFAULT_FW = 0,
@@ -866,6 +974,14 @@ typedef enum _dfs_w53_cfg_t {
 	DFS_W53_OLD = 2
 } dfs_w53_cfg_t;
 
+typedef enum _dfs_moe_t {
+	/** driver default DFS behavior */
+	DFS_MODE_DEFAULT = 0,
+	/* disable DFS master when uap and station operate in same DFS channel
+	 */
+	DFS_MODE_ENH = 1,
+} dfs_mode_t;
+
 /** Band_Config_t */
 typedef MLAN_PACK_START struct _Band_Config_t {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -875,10 +991,10 @@ typedef MLAN_PACK_START struct _Band_Config_t {
 	t_u8 chan2Offset : 2;
 	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
 	t_u8 chanWidth : 2;
-	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	/** Band Info - (00)=2.4GHz, (01)=5GHz, (10)=6GHz */
 	t_u8 chanBand : 2;
 #else
-	/** Band Info - (00)=2.4GHz, (01)=5GHz */
+	/** Band Info - (00)=2.4GHz, (01)=5GHz, (10)=6GHz */
 	t_u8 chanBand : 2;
 	/** Channel Width - (00)=20MHz, (10)=40MHz, (11)=80MHz */
 	t_u8 chanWidth : 2;
@@ -901,7 +1017,7 @@ typedef MLAN_PACK_START struct _chan_band_info {
 	t_u8 center_chan;
 	/** dfs channel flag */
 	t_u8 is_dfs_chan;
-} MLAN_PACK_END chan_band_info, *pchan_band_info;
+} MLAN_PACK_END chan_band_info;
 
 /** Channel usability flags */
 #define NXP_CHANNEL_NO_OFDM MBIT(9)
@@ -930,6 +1046,9 @@ typedef struct _cfp_dyn_t {
 	t_u16 flags;
 	/** TRUE: Channel is blacklisted (do not use) */
 	t_bool blacklist;
+	/** DFS state of the channel
+	 * 0:DFS_USABLE  1:DFS_AVAILABLE  2:DFS_UNAVAILABLE */
+	dfs_state_t dfs_state;
 } cfp_dyn_t;
 
 /** Chan-Freq-TxPower mapping table*/
@@ -973,6 +1092,45 @@ typedef struct _mlan_cmdresp_event {
 } mlan_cmdresp_event, *pmlan_cmdresp_event;
 
 /** csi event data structure */
+typedef MLAN_PACK_START struct _csi_record_ds {
+	/** Length in DWORDS, including header */
+	t_u16 Len;
+	/** CSI signature. 0xABCD fixed */
+	t_u16 CSI_Sign;
+	/** User defined HeaderID  */
+	t_u32 CSI_HeaderID;
+	/** Packet info field */
+	t_u16 PKT_info;
+	/** Frame control field for the received packet*/
+	t_u16 FCF;
+	/** Timestamp when packet received */
+	t_u64 TSF;
+	/** Received Packet Destination MAC Address */
+	t_u8 Dst_MAC[6];
+	/** Received Packet Source MAC Address */
+	t_u8 Src_MAC[6];
+	/** RSSI for antenna A */
+	t_u8 Rx_RSSI_A;
+	/** RSSI for antenna B */
+	t_u8 Rx_RSSI_B;
+	/** Noise floor for antenna A */
+	t_u8 Rx_NF_A;
+	/** Noise floor for antenna A */
+	t_u8 Rx_NF_B;
+	/** Rx signal strength above noise floor */
+	t_u8 Rx_SINR;
+	/** Channel */
+	t_u8 channel;
+	/** user defined Chip ID */
+	t_u16 chip_id;
+	/** Reserved */
+	t_u32 rsvd;
+	/** CSI data length in DWORDs */
+	t_u32 CSI_Data_Length;
+	/** Start of CSI data */
+	t_u8 CSI_Data[0];
+	/** At the end of CSI raw data, user defined TailID of 4 bytes*/
+} MLAN_PACK_END csi_record_ds, *pcsi_record_ds;
 
 /** mlan_ioctl_req data structure */
 typedef struct _mlan_ioctl_req {
@@ -1000,6 +1158,56 @@ typedef struct _mlan_ioctl_req {
 	t_ptr reserved_1;
 } mlan_ioctl_req, *pmlan_ioctl_req;
 
+typedef MLAN_PACK_START struct _mix_rate_info {
+	/**  bit0: LGI: gi=0, SGI: gi= 1 */
+	/**  bit1-2: 20M: bw=0, 40M: bw=1, 80M: bw=2, 160M: bw=3  */
+	/**  bit3-4: LG: format=0, HT: format=1, VHT: format=2 */
+	/**  bit5: LDPC: 0-not support,  1-support */
+	/**  bit6-7:reserved */
+	t_u8 rate_info;
+	/** MCS index */
+	t_u8 mcs_index;
+	/** bitrate, in 500Kbps */
+	t_u16 bitrate;
+	/** NSS */
+	t_u8 nss_index;
+	/** DCM */
+	t_u8 dcm;
+} MLAN_PACK_END mix_rate_info, *pmix_rate_info;
+
+typedef MLAN_PACK_START struct _rxpd_extra_info {
+	/** flags */
+	t_u8 flags;
+	/** channel.flags */
+	t_u16 channel_flags;
+	/** mcs.known */
+	t_u8 mcs_known;
+	/** mcs.flags */
+	t_u8 mcs_flags;
+	/** vht/he sig1 */
+	t_u32 vht_he_sig1;
+	/** vht/he sig2 */
+	t_u32 vht_he_sig2;
+	/** HE user idx */
+	t_u32 user_idx;
+} MLAN_PACK_END rxpd_extra_info, *prxpd_extra_info;
+
+typedef MLAN_PACK_START struct _radiotap_info {
+	/** Rate Info */
+	mix_rate_info rate_info;
+	/** SNR */
+	t_s8 snr;
+	/** Noise Floor */
+	t_s8 nf;
+	/** band config */
+	t_u8 band_config;
+	/** chan number */
+	t_u8 chan_num;
+	t_u8 antenna;
+	/** extra rxpd info from FW */
+	rxpd_extra_info extra_info;
+} MLAN_PACK_END radiotap_info, *pradiotap_info;
+
 /** txpower structure */
 typedef MLAN_PACK_START struct {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -1051,6 +1259,25 @@ typedef MLAN_PACK_START struct _pkt_rxinfo {
 	t_u8 rssi;
 } MLAN_PACK_END pkt_rxinfo, *ppkt_rxinfo;
 
+#define MC_FLAG_RETRY MBIT(0)
+#define MC_FLAG_START_CYCLE MBIT(1)
+#define MC_FLAG_END_CYCLE MBIT(2)
+#define MC_FLAG_START_AMPDU MBIT(3)
+#define MC_FLAG_END_AMPDU MBIT(4)
+/* mc pkt txcontrol */
+typedef MLAN_PACK_START struct _mc_txcontrol {
+	/** Data rate in mcs index, 0-7 */
+	t_u8 mcs_index;
+	/** band width 0-20Mhz, 1-40Mhz */
+	t_u8 bandwidth;
+	/** seq_num */
+	t_u16 seq_num;
+	/** packet expiry time */
+	t_u32 pkt_expiry;
+	/** mc_pkt_flags */
+	t_u8 mc_pkt_flags;
+} MLAN_PACK_END mc_txcontrol, *pmc_txcontrol;
+
 /** mlan_buffer data structure */
 typedef struct _mlan_buffer {
 	/** Pointer to previous mlan_buffer */
@@ -1092,21 +1319,28 @@ typedef struct _mlan_buffer {
 	t_u32 out_ts_usec;
 	/** tx_seq_num */
 	t_u32 tx_seq_num;
-
+	/** Time stamp when packet is deque from rx_q(seconds) */
+	t_u32 extra_ts_sec;
+	/** Time stamp when packet is dequed from rx_q(micro seconds) */
+	t_u32 extra_ts_usec;
+	/** When TX ra mac address,  When Rx Ta mac address*/
+	t_u8 mac[MLAN_MAC_ADDR_LENGTH];
 	/** Fields below are valid for MLAN module only */
 	/** Pointer to parent mlan_buffer */
 	struct _mlan_buffer *pparent;
 	/** Use count for this buffer */
 	t_u32 use_count;
 	union {
+		mc_txcontrol mc_tx_info;
 		pkt_txctrl tx_info;
 		pkt_rxinfo rx_info;
 	} u;
 } mlan_buffer, *pmlan_buffer, **ppmlan_buffer;
 
-/** mlan_fw_info data structure */
+/** mlan_hw_info data structure */
 typedef struct _mlan_hw_info {
 	t_u32 fw_cap;
+	t_u32 fw_cap_ext;
 } mlan_hw_info, *pmlan_hw_info;
 
 /** mlan_bss_attr data structure */
@@ -1245,6 +1479,242 @@ typedef MLAN_PACK_START struct _tlvbuf_custom_ie {
 	tlvbuf_max_mgmt_ie max_mgmt_ie;
 } MLAN_PACK_END mlan_ds_misc_custom_ie;
 
+/** Max TDLS config data length */
+#define MAX_TDLS_DATA_LEN 1024
+
+/** Action commands for TDLS enable/disable */
+#define WLAN_TDLS_CONFIG 0x00
+/** Action commands for TDLS configuration :Set */
+#define WLAN_TDLS_SET_INFO 0x01
+/** Action commands for TDLS configuration :Discovery Request */
+#define WLAN_TDLS_DISCOVERY_REQ 0x02
+/** Action commands for TDLS configuration :Setup Request */
+#define WLAN_TDLS_SETUP_REQ 0x03
+/** Action commands for TDLS configuration :Tear down Request */
+#define WLAN_TDLS_TEAR_DOWN_REQ 0x04
+/** Action ID for TDLS power mode */
+#define WLAN_TDLS_POWER_MODE 0x05
+/**Action ID for init TDLS Channel Switch*/
+#define WLAN_TDLS_INIT_CHAN_SWITCH 0x06
+/** Action ID for stop TDLS Channel Switch */
+#define WLAN_TDLS_STOP_CHAN_SWITCH 0x07
+/** Action ID for configure CS related parameters */
+#define WLAN_TDLS_CS_PARAMS 0x08
+/** Action ID for Disable CS */
+#define WLAN_TDLS_CS_DISABLE 0x09
+/** Action ID for TDLS link status */
+#define WLAN_TDLS_LINK_STATUS 0x0A
+/** Action ID for Host TDLS config uapsd and CS */
+#define WLAN_HOST_TDLS_CONFIG 0x0D
+/** Action ID for TDLS CS immediate return */
+#define WLAN_TDLS_DEBUG_CS_RET_IM 0xFFF7
+/** Action ID for TDLS Stop RX */
+#define WLAN_TDLS_DEBUG_STOP_RX 0xFFF8
+/** Action ID for TDLS Allow weak security for links establish */
+#define WLAN_TDLS_DEBUG_ALLOW_WEAK_SECURITY 0xFFF9
+/** Action ID for TDLS Ignore key lifetime expiry */
+#define WLAN_TDLS_DEBUG_IGNORE_KEY_EXPIRY 0xFFFA
+/** Action ID for TDLS Higher/Lower mac Test */
+#define WLAN_TDLS_DEBUG_HIGHER_LOWER_MAC 0xFFFB
+/** Action ID for TDLS Prohibited Test */
+#define WLAN_TDLS_DEBUG_SETUP_PROHIBITED 0xFFFC
+/** Action ID for TDLS Existing link Test */
+#define WLAN_TDLS_DEBUG_SETUP_SAME_LINK 0xFFFD
+/** Action ID for TDLS Fail Setup Confirm */
+#define WLAN_TDLS_DEBUG_FAIL_SETUP_CONFIRM 0xFFFE
+/** Action commands for TDLS debug: Wrong BSS Request */
+#define WLAN_TDLS_DEBUG_WRONG_BSS 0xFFFF
+
+/** tdls each link rate information */
+typedef MLAN_PACK_START struct _tdls_link_rate_info {
+	/** Tx Data Rate */
+	t_u8 tx_data_rate;
+	/** Tx Rate HT info*/
+	t_u8 tx_rate_htinfo;
+} MLAN_PACK_END tdls_link_rate_info;
+
+/** tdls each link status */
+typedef MLAN_PACK_START struct _tdls_each_link_status {
+	/** peer mac Address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** Link Flags */
+	t_u8 link_flags;
+	/** Traffic Status */
+	t_u8 traffic_status;
+	/** Tx Failure Count */
+	t_u8 tx_fail_count;
+	/** Channel Number */
+	t_u32 active_channel;
+	/** Last Data RSSI in dBm */
+	t_s16 data_rssi_last;
+	/** Last Data NF in dBm */
+	t_s16 data_nf_last;
+	/** AVG DATA RSSI in dBm */
+	t_s16 data_rssi_avg;
+	/** AVG DATA NF in dBm */
+	t_s16 data_nf_avg;
+	union {
+		/** tdls rate info */
+		tdls_link_rate_info rate_info;
+		/** tdls link final rate*/
+		t_u16 final_data_rate;
+	} u;
+	/** Security Method */
+	t_u8 security_method;
+	/** Key Lifetime in milliseconds */
+	t_u32 key_lifetime;
+	/** Key Length */
+	t_u8 key_length;
+	/** actual key */
+	t_u8 key[1];
+} MLAN_PACK_END tdls_each_link_status;
+
+/** TDLS configuration data */
+typedef MLAN_PACK_START struct _tdls_all_config {
+	union {
+		/** TDLS state enable disable */
+		MLAN_PACK_START struct _tdls_config {
+			/** enable or disable */
+			t_u16 enable;
+		} MLAN_PACK_END tdls_config;
+		/** Host tdls config */
+		MLAN_PACK_START struct _host_tdls_cfg {
+			/** support uapsd */
+			t_u8 uapsd_support;
+			/** channel_switch */
+			t_u8 cs_support;
+			/** TLV  length */
+			t_u16 tlv_len;
+			/** tdls info */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END host_tdls_cfg;
+		/** TDLS set info */
+		MLAN_PACK_START struct _tdls_set_data {
+			/** (tlv + capInfo) length */
+			t_u16 tlv_length;
+			/** Cap Info */
+			t_u16 cap_info;
+			/** TLV buffer */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END tdls_set;
+
+		/** TDLS discovery and others having mac argument */
+		MLAN_PACK_START struct _tdls_discovery_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+		} MLAN_PACK_END tdls_discovery, tdls_stop_chan_switch,
+			tdls_link_status_req;
+
+		/** TDLS discovery Response */
+		MLAN_PACK_START struct _tdls_discovery_resp {
+			/** payload length */
+			t_u16 payload_len;
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** RSSI */
+			t_s8 rssi;
+			/** Cap Info */
+			t_u16 cap_info;
+			/** TLV buffer */
+			t_u8 tlv_buffer[];
+		} MLAN_PACK_END tdls_discovery_resp;
+
+		/** TDLS setup request */
+		MLAN_PACK_START struct _tdls_setup_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** timeout value in milliseconds */
+			t_u32 setup_timeout;
+			/** key lifetime in milliseconds */
+			t_u32 key_lifetime;
+		} MLAN_PACK_END tdls_setup;
+
+		/** TDLS tear down info */
+		MLAN_PACK_START struct _tdls_tear_down_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** reason code */
+			t_u16 reason_code;
+		} MLAN_PACK_END tdls_tear_down, tdls_cmd_resp;
+
+		/** TDLS power mode info */
+		MLAN_PACK_START struct _tdls_power_mode_data {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** Power Mode */
+			t_u16 power_mode;
+		} MLAN_PACK_END tdls_power_mode;
+
+		/** TDLS channel switch info */
+		MLAN_PACK_START struct _tdls_chan_switch {
+			/** peer mac Address */
+			t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+			/** Channel Switch primary channel no */
+			t_u8 primary_channel;
+			/** Channel Switch secondary channel offset */
+			t_u8 secondary_channel_offset;
+			/** Channel Switch Band */
+			t_u8 band;
+			/** Channel Switch time in milliseconds */
+			t_u16 switch_time;
+			/** Channel Switch timeout in milliseconds */
+			t_u16 switch_timeout;
+			/** Channel Regulatory class*/
+			t_u8 regulatory_class;
+			/** peridicity flag*/
+			t_u8 periodicity;
+		} MLAN_PACK_END tdls_chan_switch;
+
+		/** TDLS channel switch paramters */
+		MLAN_PACK_START struct _tdls_cs_params {
+			/** unit time, multiples of 10ms */
+			t_u8 unit_time;
+			/** threshold for other link */
+			t_u8 threshold_otherlink;
+			/** threshold for direct link */
+			t_u8 threshold_directlink;
+		} MLAN_PACK_END tdls_cs_params;
+
+		/** tdls disable channel switch */
+		MLAN_PACK_START struct _tdls_disable_cs {
+			/** Data*/
+			t_u16 data;
+		} MLAN_PACK_END tdls_disable_cs;
+		/** TDLS debug data */
+		MLAN_PACK_START struct _tdls_debug_data {
+			/** debug data */
+			t_u16 debug_data;
+		} MLAN_PACK_END tdls_debug_data;
+
+		/** TDLS link status Response */
+		MLAN_PACK_START struct _tdls_link_status_resp {
+			/** payload length */
+			t_u16 payload_len;
+			/** number of links */
+			t_u8 active_links;
+			/** structure for link status */
+			tdls_each_link_status link_stats[1];
+		} MLAN_PACK_END tdls_link_status_resp;
+
+	} u;
+} MLAN_PACK_END tdls_all_config;
+
+/** TDLS configuration buffer */
+typedef MLAN_PACK_START struct _buf_tdls_config {
+	/** TDLS Action */
+	t_u16 tdls_action;
+	/** TDLS data */
+	t_u8 tdls_data[MAX_TDLS_DATA_LEN];
+} MLAN_PACK_END mlan_ds_misc_tdls_config;
+
+/** Event structure for tear down */
+typedef struct _tdls_tear_down_event {
+	/** Peer mac address */
+	t_u8 peer_mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Reason code */
+	t_u16 reason_code;
+} tdls_tear_down_event;
+
 /** channel width */
 typedef enum wifi_channel_width {
 	WIFI_CHAN_WIDTH_20 = 0,
@@ -1302,6 +1772,15 @@ typedef struct {
 	t_u32 time_usec;
 } wifi_timeval;
 
+#define timeval_to_msec(timeval)                                               \
+	(t_u64)((t_u64)(timeval.time_sec) * 1000 +                             \
+		(t_u64)(timeval.time_usec) / 1000)
+#define timeval_to_usec(timeval)                                               \
+	(t_u64)((t_u64)(timeval.time_sec) * 1000 * 1000 +                      \
+		(t_u64)(timeval.time_usec))
+#define is_zero_timeval(timeval)                                               \
+	((timeval.time_sec == 0) && (timeval.time_usec == 0))
+
 #define MAX_NUM_RATE 32
 #define MAX_RADIO 2
 #define MAX_NUM_CHAN 1
@@ -1383,15 +1862,6 @@ typedef struct {
 	t_u32 cca_busy_time;
 } wifi_channel_stat;
 
-#define timeval_to_msec(timeval)                                               \
-	(t_u64)((t_u64)(timeval.time_sec) * 1000 +                             \
-		(t_u64)(timeval.time_usec) / 1000)
-#define timeval_to_usec(timeval)                                               \
-	(t_u64)((t_u64)(timeval.time_sec) * 1000 * 1000 +                      \
-		(t_u64)(timeval.time_usec))
-#define is_zero_timeval(timeval)                                               \
-	((timeval.time_sec == 0) && (timeval.time_usec == 0))
-
 /** radio statistics */
 typedef struct {
 	/** wifi radio (if multiple radio supported) */
@@ -1585,9 +2055,320 @@ typedef struct {
 	0x00000080 /** all contention (min, max, avg) statistics (within ac    \
 		      statisctics) */
 
+/** =========== Define Copied from HAL START =========== */
+/** Ranging status */
+typedef enum {
+	RTT_STATUS_SUCCESS = 0,
+	/** general failure status */
+	RTT_STATUS_FAILURE = 1,
+	/** target STA does not respond to request */
+	RTT_STATUS_FAIL_NO_RSP = 2,
+	/** request rejected. Applies to 2-sided RTT only */
+	RTT_STATUS_FAIL_REJECTED = 3,
+	RTT_STATUS_FAIL_NOT_SCHEDULED_YET = 4,
+	/** timing measurement times out */
+	RTT_STATUS_FAIL_TM_TIMEOUT = 5,
+	/** Target on different channel, cannot range */
+	RTT_STATUS_FAIL_AP_ON_DIFF_CHANNEL = 6,
+	/** ranging not supported */
+	RTT_STATUS_FAIL_NO_CAPABILITY = 7,
+	/** request aborted for unknown reason */
+	RTT_STATUS_ABORTED = 8,
+	/** Invalid T1-T4 timestamp */
+	RTT_STATUS_FAIL_INVALID_TS = 9,
+	/** 11mc protocol failed */
+	RTT_STATUS_FAIL_PROTOCOL = 10,
+	/** request could not be scheduled */
+	RTT_STATUS_FAIL_SCHEDULE = 11,
+	/** responder cannot collaborate at time of request */
+	RTT_STATUS_FAIL_BUSY_TRY_LATER = 12,
+	/** bad request args */
+	RTT_STATUS_INVALID_REQ = 13,
+	/** WiFi not enabled */
+	RTT_STATUS_NO_WIFI = 14,
+	/** Responder overrides param info, cannot range with new params */
+	RTT_STATUS_FAIL_FTM_PARAM_OVERRIDE = 15
+} wifi_rtt_status;
+
+/** RTT peer type */
+typedef enum {
+	RTT_PEER_AP = 0x1,
+	RTT_PEER_STA = 0x2,
+	RTT_PEER_P2P_GO = 0x3,
+	RTT_PEER_P2P_CLIENT = 0x4,
+	RTT_PEER_NAN = 0x5
+} rtt_peer_type;
+
+/** RTT Measurement Bandwidth */
+typedef enum {
+	WIFI_RTT_BW_5 = 0x01,
+	WIFI_RTT_BW_10 = 0x02,
+	WIFI_RTT_BW_20 = 0x04,
+	WIFI_RTT_BW_40 = 0x08,
+	WIFI_RTT_BW_80 = 0x10,
+	WIFI_RTT_BW_160 = 0x20
+} wifi_rtt_bw;
+
+/** RTT Type */
+typedef enum {
+	RTT_TYPE_1_SIDED = 0x1,
+	RTT_TYPE_2_SIDED = 0x2,
+} wifi_rtt_type;
+
+/** RTT configuration */
+typedef struct {
+	/** peer device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** 1-sided or 2-sided RTT */
+	wifi_rtt_type type;
+	/** optional - peer device hint (STA, P2P, AP) */
+	rtt_peer_type peer;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	wifi_channel_info channel;
+	/** Time interval between bursts (units: 100 ms).
+	 * Applies to 1-sided and 2-sided RTT multi-burst requests.
+	 * Range: 0-31, 0: no preference by initiator (2-sided RTT) */
+	t_u32 burst_period;
+	/** Total number of RTT bursts to be executed. It will be
+	 * specified in the same way as the parameter "Number of
+	 * Burst Exponent" found in the FTM frame format. It
+	 * applies to both: 1-sided RTT and 2-sided RTT. Valid
+	 * values are 0 to 15 as defined in 802.11mc std.
+	 * 0 means single shot
+	 * The implication of this parameter on the maximum
+	 * number of RTT results is the following:
+	 * for 1-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst)
+	 * for 2-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst - 1) */
+	t_u32 num_burst;
+	/** num of frames per burst. Minimum value = 1, Maximum value = 31
+	 * For 2-sided this equals the number of FTM frames to be attempted in a
+	 * single burst. This also equals the number of FTM frames that the
+	 * initiator will request that the responder send in a single frame. */
+	t_u32 num_frames_per_burst;
+	/** number of retries for a failed RTT frame. Applies
+	 * to 1-sided RTT only. Minimum value = 0, Maximum value = 3 */
+	t_u32 num_retries_per_rtt_frame;
+
+	/** following fields are only valid for 2-side RTT */
+	/** Maximum number of retries that the initiator can retry an FTMR
+	 * frame. Minimum value = 0, Maximum value = 3 */
+	t_u32 num_retries_per_ftmr;
+	/** 1: request LCI, 0: do not request LCI */
+	t_u8 LCI_request;
+	/** 1: request LCR, 0: do not request LCR */
+	t_u8 LCR_request;
+	/** Applies to 1-sided and 2-sided RTT. Valid values will
+	 * be 2-11 and 15 as specified by the 802.11mc std for
+	 * the FTM parameter burst duration. In a multi-burst
+	 * request, if responder overrides with larger value,
+	 * the initiator will return failure. In a single-burst
+	 * request if responder overrides with larger value,
+	 * the initiator will sent TMR_STOP to terminate RTT
+	 * at the end of the burst_duration it requested. */
+	t_u32 burst_duration;
+	/** RTT preamble to be used in the RTT frames */
+	wifi_preamble preamble;
+	/** RTT BW to be used in the RTT frames */
+	wifi_rtt_bw bw;
+} wifi_rtt_config;
+
+/** Format of information elements found in the beacon */
+typedef struct {
+	/** element identifier */
+	t_u8 id;
+	/** number of bytes to follow */
+	t_u8 len;
+	t_u8 data[];
+} wifi_information_element;
+
+/** RTT results */
+typedef struct {
+	/** device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** burst number in a multi-burst request */
+	t_u32 burst_num;
+	/** Total RTT measurement frames attempted */
+	t_u32 measurement_number;
+	/** Total successful RTT measurement frames */
+	t_u32 success_number;
+	/** Maximum number of "FTM frames per burst" supported by
+	 * the responder STA. Applies to 2-sided RTT only.
+	 * If reponder overrides with larger value:
+	 * - for single-burst request initiator will truncate the
+	 * larger value and send a TMR_STOP after receiving as
+	 * many frames as originally requested.
+	 * - for multi-burst request, initiator will return
+	 * failure right away */
+	t_u8 number_per_burst_peer;
+	/** ranging status */
+	wifi_rtt_status status;
+	/** When status == RTT_STATUS_FAIL_BUSY_TRY_LATER,
+	 * this will be the time provided by the responder as to
+	 * when the request can be tried again. Applies to 2-sided
+	 * RTT only. In sec, 1-31sec. */
+	t_u8 retry_after_duration;
+	/** RTT type */
+	wifi_rtt_type type;
+	/** average rssi in 0.5 dB steps e.g. 143 implies -71.5 dB */
+	int rssi;
+	/** rssi spread in 0.5 dB steps e.g. 5 implies 2.5 dB spread (optional)
+	 */
+	int rssi_spread;
+	/** 1-sided RTT: TX rate of RTT frame.
+	 * 2-sided RTT: TX rate of initiator's Ack in response to FTM frame. */
+	wifi_rate tx_rate;
+	/** 1-sided RTT: TX rate of Ack from other side.
+	 * 2-sided RTT: TX rate of FTM frame coming from responder. */
+	wifi_rate rx_rate;
+	/** round trip time in picoseconds */
+	t_s64 rtt;
+	/** rtt standard deviation in picoseconds */
+	t_s64 rtt_sd;
+	/** difference between max and min rtt times recorded in picoseconds */
+	t_s64 rtt_spread;
+	/** distance in mm (optional) */
+	int distance_mm;
+	/** standard deviation in mm (optional) */
+	int distance_sd_mm;
+	/** difference between max and min distance recorded in mm (optional) */
+	int distance_spread_mm;
+	/** time of the measurement (in microseconds since boot) */
+	t_s64 ts;
+	/** in ms, actual time taken by the FW to finish one burst
+	 * measurement. Applies to 1-sided and 2-sided RTT. */
+	int burst_duration;
+	/** Number of bursts allowed by the responder. Applies
+	 * to 2-sided RTT only. */
+	int negotiated_burst_num;
+	/** for 11mc only */
+	wifi_information_element *LCI;
+	/** for 11mc only */
+	wifi_information_element *LCR;
+} wifi_rtt_result;
+
+/** Preamble definition for bit mask used in wifi_rtt_capabilities */
+#define PREAMBLE_LEGACY 0x1
+#define PREAMBLE_HT 0x2
+#define PREAMBLE_VHT 0x4
+
+/** BW definition for bit mask used in wifi_rtt_capabilities */
+#define BW_5_SUPPORT 0x1
+#define BW_10_SUPPORT 0x2
+#define BW_20_SUPPORT 0x4
+#define BW_40_SUPPORT 0x8
+#define BW_80_SUPPORT 0x10
+#define BW_160_SUPPORT 0x20
+
+/** RTT Capabilities */
+typedef struct {
+	/** if 1-sided rtt data collection is supported */
+	t_u8 rtt_one_sided_supported;
+	/** if ftm rtt data collection is supported */
+	t_u8 rtt_ftm_supported;
+	/** if initiator supports LCI request. Applies to 2-sided RTT */
+	t_u8 lci_support;
+	/** if initiator supports LCR request. Applies to 2-sided RTT */
+	t_u8 lcr_support;
+	/** bit mask indicates what preamble is supported by initiator */
+	t_u8 preamble_support;
+	/** bit mask indicates what BW is supported by initiator */
+	t_u8 bw_support;
+	/** if 11mc responder mode is supported */
+	t_u8 responder_supported;
+	/** draft 11mc spec version supported by chip. For instance,
+	 * version 4.0 should be 40 and version 4.3 should be 43 etc. */
+	t_u8 mc_version;
+} wifi_rtt_capabilities;
+
+/** API for setting LCI/LCR information to be provided to a requestor */
+typedef enum {
+	/** Not expected to change location */
+	WIFI_MOTION_NOT_EXPECTED = 0,
+	/** Expected to change location */
+	WIFI_MOTION_EXPECTED = 1,
+	/** Movement pattern unknown */
+	WIFI_MOTION_UNKNOWN = 2,
+} wifi_motion_pattern;
+
+/** LCI information */
+typedef struct {
+	/** latitude in degrees * 2^25 , 2's complement */
+	long latitude;
+	/** latitude in degrees * 2^25 , 2's complement */
+	long longitude;
+	/** Altitude in units of 1/256 m */
+	int altitude;
+	/** As defined in Section 2.3.2 of IETF RFC 6225 */
+	t_u8 latitude_unc;
+	/** As defined in Section 2.3.2 of IETF RFC 6225 */
+	t_u8 longitude_unc;
+	/** As defined in Section 2.4.5 from IETF RFC 6225: */
+	t_u8 altitude_unc;
+	/** Following element for configuring the Z subelement */
+	wifi_motion_pattern motion_pattern;
+	/** floor in units of 1/16th of floor. 0x80000000 if unknown. */
+	int floor;
+	/** in units of 1/64 m */
+	int height_above_floor;
+	/** in units of 1/64 m. 0 if unknown */
+	int height_unc;
+} wifi_lci_information;
+
+/** LCR information */
+typedef struct {
+	/** country code */
+	char country_code[2];
+	/** length of the info field */
+	int length;
+	/** Civic info to be copied in FTM frame */
+	char civic_info[256];
+} wifi_lcr_information;
+
+/**
+ * RTT Responder information
+ */
+typedef struct {
+	wifi_channel_info channel;
+	wifi_preamble preamble;
+} wifi_rtt_responder;
+
+/** =========== Define Copied from HAL END =========== */
+
+#define MAX_RTT_CONFIG_NUM 10
+
+/** RTT config params */
+typedef struct wifi_rtt_config_params {
+	t_u8 rtt_config_num;
+	wifi_rtt_config rtt_config[MAX_RTT_CONFIG_NUM];
+} wifi_rtt_config_params_t;
+
+#define OID_RTT_REQUEST 0
+#define OID_RTT_CANCEL 1
+
+/** Pass RTT result element between mlan and moal */
+typedef struct {
+	/** element identifier  */
+	t_u16 id;
+	/** number of bytes to follow  */
+	t_u16 len;
+	/** data: fill with one wifi_rtt_result  */
+	t_u8 data[];
+} wifi_rtt_result_element;
+
 /** station stats */
 typedef struct _sta_stats {
+	/** last_rx_in_msec */
 	t_u64 last_rx_in_msec;
+	/** rx_packets */
+	t_u32 rx_packets;
+	/** tx packets */
+	t_u32 tx_packets;
+	/** rx bytes */
+	t_u32 rx_bytes;
+	/** tx bytes */
+	t_u32 tx_bytes;
 } sta_stats;
 
 #ifdef PRAGMA_PACK
@@ -1597,156 +2378,156 @@ typedef struct _sta_stats {
 /** mlan_callbacks data structure */
 typedef struct _mlan_callbacks {
 	/** moal_get_fw_data */
-	mlan_status (*moal_get_fw_data)(t_void *pmoal_handle, t_u32 offset,
-					t_u32 len, t_u8 *pbuf);
-	mlan_status (*moal_get_vdll_data)(t_void *pmoal_handle, t_u32 len,
-					  t_u8 *pbuf);
+	mlan_status (*moal_get_fw_data)(t_void *pmoal, t_u32 offset, t_u32 len,
+					t_u8 *pbuf);
+	mlan_status (*moal_get_vdll_data)(t_void *pmoal, t_u32 len, t_u8 *pbuf);
 	/** moal_get_hw_spec_complete */
-	mlan_status (*moal_get_hw_spec_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_get_hw_spec_complete)(t_void *pmoal,
 						 mlan_status status,
 						 pmlan_hw_info phw,
 						 pmlan_bss_tbl ptbl);
 	/** moal_init_fw_complete */
-	mlan_status (*moal_init_fw_complete)(t_void *pmoal_handle,
-					     mlan_status status);
+	mlan_status (*moal_init_fw_complete)(t_void *pmoal, mlan_status status);
 	/** moal_shutdown_fw_complete */
-	mlan_status (*moal_shutdown_fw_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_shutdown_fw_complete)(t_void *pmoal,
 						 mlan_status status);
 	/** moal_send_packet_complete */
-	mlan_status (*moal_send_packet_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_send_packet_complete)(t_void *pmoal,
 						 pmlan_buffer pmbuf,
 						 mlan_status status);
 	/** moal_recv_complete */
-	mlan_status (*moal_recv_complete)(t_void *pmoal_handle,
-					  pmlan_buffer pmbuf, t_u32 port,
-					  mlan_status status);
+	mlan_status (*moal_recv_complete)(t_void *pmoal, pmlan_buffer pmbuf,
+					  t_u32 port, mlan_status status);
 	/** moal_recv_packet */
-	mlan_status (*moal_recv_packet)(t_void *pmoal_handle,
-					pmlan_buffer pmbuf);
+	mlan_status (*moal_recv_packet)(t_void *pmoal, pmlan_buffer pmbuf);
+	/** moal_recv_amsdu_packet */
+	mlan_status (*moal_recv_amsdu_packet)(t_void *pmoal,
+					      pmlan_buffer pmbuf);
 	/** moal_recv_event */
-	mlan_status (*moal_recv_event)(t_void *pmoal_handle,
-				       pmlan_event pmevent);
+	mlan_status (*moal_recv_event)(t_void *pmoal, pmlan_event pmevent);
 	/** moal_ioctl_complete */
-	mlan_status (*moal_ioctl_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_ioctl_complete)(t_void *pmoal,
 					   pmlan_ioctl_req pioctl_req,
 					   mlan_status status);
 
 	/** moal_alloc_mlan_buffer */
-	mlan_status (*moal_alloc_mlan_buffer)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_alloc_mlan_buffer)(t_void *pmoal, t_u32 size,
 					      ppmlan_buffer pmbuf);
 	/** moal_free_mlan_buffer */
-	mlan_status (*moal_free_mlan_buffer)(t_void *pmoal_handle,
-					     pmlan_buffer pmbuf);
+	mlan_status (*moal_free_mlan_buffer)(t_void *pmoal, pmlan_buffer pmbuf);
 
 #ifdef USB
 	/** moal_write_data_async */
-	mlan_status (*moal_write_data_async)(t_void *pmoal_handle,
-					     pmlan_buffer pmbuf, t_u32 port);
+	mlan_status (*moal_write_data_async)(t_void *pmoal, pmlan_buffer pmbuf,
+					     t_u32 port);
 #endif /* USB */
 #if defined(SDIO) || defined(PCIE)
 	/** moal_write_reg */
-	mlan_status (*moal_write_reg)(t_void *pmoal_handle, t_u32 reg,
-				      t_u32 data);
+	mlan_status (*moal_write_reg)(t_void *pmoal, t_u32 reg, t_u32 data);
 	/** moal_read_reg */
-	mlan_status (*moal_read_reg)(t_void *pmoal_handle, t_u32 reg,
-				     t_u32 *data);
+	mlan_status (*moal_read_reg)(t_void *pmoal, t_u32 reg, t_u32 *data);
 #endif /* SDIO || PCIE */
 	/** moal_write_data_sync */
-	mlan_status (*moal_write_data_sync)(t_void *pmoal_handle,
-					    pmlan_buffer pmbuf, t_u32 port,
-					    t_u32 timeout);
+	mlan_status (*moal_write_data_sync)(t_void *pmoal, pmlan_buffer pmbuf,
+					    t_u32 port, t_u32 timeout);
 	/** moal_read_data_sync */
-	mlan_status (*moal_read_data_sync)(t_void *pmoal_handle,
-					   pmlan_buffer pmbuf, t_u32 port,
-					   t_u32 timeout);
+	mlan_status (*moal_read_data_sync)(t_void *pmoal, pmlan_buffer pmbuf,
+					   t_u32 port, t_u32 timeout);
 	/** moal_malloc */
-	mlan_status (*moal_malloc)(t_void *pmoal_handle, t_u32 size, t_u32 flag,
+	mlan_status (*moal_malloc)(t_void *pmoal, t_u32 size, t_u32 flag,
 				   t_u8 **ppbuf);
 	/** moal_mfree */
-	mlan_status (*moal_mfree)(t_void *pmoal_handle, t_u8 *pbuf);
+	mlan_status (*moal_mfree)(t_void *pmoal, t_u8 *pbuf);
 	/** moal_vmalloc */
-	mlan_status (*moal_vmalloc)(t_void *pmoal_handle, t_u32 size,
-				    t_u8 **ppbuf);
+	mlan_status (*moal_vmalloc)(t_void *pmoal, t_u32 size, t_u8 **ppbuf);
 	/** moal_vfree */
-	mlan_status (*moal_vfree)(t_void *pmoal_handle, t_u8 *pbuf);
+	mlan_status (*moal_vfree)(t_void *pmoal, t_u8 *pbuf);
 #ifdef PCIE
 	/** moal_malloc_consistent */
-	mlan_status (*moal_malloc_consistent)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_malloc_consistent)(t_void *pmoal, t_u32 size,
 					      t_u8 **ppbuf, t_u64 *pbuf_pa);
 	/** moal_mfree_consistent */
-	mlan_status (*moal_mfree_consistent)(t_void *pmoal_handle, t_u32 size,
+	mlan_status (*moal_mfree_consistent)(t_void *pmoal, t_u32 size,
 					     t_u8 *pbuf, t_u64 buf_pa);
 	/** moal_map_memory */
-	mlan_status (*moal_map_memory)(t_void *pmoal_handle, t_u8 *pbuf,
+	mlan_status (*moal_map_memory)(t_void *pmoal, t_u8 *pbuf,
 				       t_u64 *pbuf_pa, t_u32 size, t_u32 flag);
 	/** moal_unmap_memory */
-	mlan_status (*moal_unmap_memory)(t_void *pmoal_handle, t_u8 *pbuf,
+	mlan_status (*moal_unmap_memory)(t_void *pmoal, t_u8 *pbuf,
 					 t_u64 buf_pa, t_u32 size, t_u32 flag);
 #endif /* PCIE */
 	/** moal_memset */
-	t_void *(*moal_memset)(t_void *pmoal_handle, t_void *pmem, t_u8 byte,
+	t_void *(*moal_memset)(t_void *pmoal, t_void *pmem, t_u8 byte,
 			       t_u32 num);
 	/** moal_memcpy */
-	t_void *(*moal_memcpy)(t_void *pmoal_handle, t_void *pdest,
-			       const t_void *psrc, t_u32 num);
+	t_void *(*moal_memcpy)(t_void *pmoal, t_void *pdest, const t_void *psrc,
+			       t_u32 num);
 	/** moal_memcpy_ext */
-	t_void *(*moal_memcpy_ext)(t_void *pmoal_handle, t_void *pdest,
+	t_void *(*moal_memcpy_ext)(t_void *pmoal, t_void *pdest,
 				   const t_void *psrc, t_u32 num,
 				   t_u32 dest_size);
 	/** moal_memmove */
-	t_void *(*moal_memmove)(t_void *pmoal_handle, t_void *pdest,
+	t_void *(*moal_memmove)(t_void *pmoal, t_void *pdest,
 				const t_void *psrc, t_u32 num);
 	/** moal_memcmp */
-	t_s32 (*moal_memcmp)(t_void *pmoal_handle, const t_void *pmem1,
+	t_s32 (*moal_memcmp)(t_void *pmoal, const t_void *pmem1,
 			     const t_void *pmem2, t_u32 num);
 	/** moal_udelay */
-	t_void (*moal_udelay)(t_void *pmoal_handle, t_u32 udelay);
+	t_void (*moal_udelay)(t_void *pmoal, t_u32 udelay);
 	/** moal_usleep_range */
-	t_void (*moal_usleep_range)(t_void *pmoal_handle, t_u32 min_delay,
+	t_void (*moal_usleep_range)(t_void *pmoal, t_u32 min_delay,
 				    t_u32 max_delay);
 	/** moal_get_boot_ktime */
-	mlan_status (*moal_get_boot_ktime)(t_void *pmoal_handle, t_u64 *pnsec);
+	mlan_status (*moal_get_boot_ktime)(t_void *pmoal, t_u64 *pnsec);
 	/** moal_get_system_time */
-	mlan_status (*moal_get_system_time)(t_void *pmoal_handle, t_u32 *psec,
+	mlan_status (*moal_get_system_time)(t_void *pmoal, t_u32 *psec,
 					    t_u32 *pusec);
 	/** moal_init_timer*/
-	mlan_status (*moal_init_timer)(t_void *pmoal_handle, t_void **pptimer,
+	mlan_status (*moal_init_timer)(t_void *pmoal, t_void **pptimer,
 				       IN t_void (*callback)(t_void *pcontext),
 				       t_void *pcontext);
 	/** moal_free_timer */
-	mlan_status (*moal_free_timer)(t_void *pmoal_handle, t_void *ptimer);
+	mlan_status (*moal_free_timer)(t_void *pmoal, t_void *ptimer);
 	/** moal_start_timer*/
-	mlan_status (*moal_start_timer)(t_void *pmoal_handle, t_void *ptimer,
+	mlan_status (*moal_start_timer)(t_void *pmoal, t_void *ptimer,
 					t_u8 periodic, t_u32 msec);
 	/** moal_stop_timer*/
-	mlan_status (*moal_stop_timer)(t_void *pmoal_handle, t_void *ptimer);
+	mlan_status (*moal_stop_timer)(t_void *pmoal, t_void *ptimer);
 	/** moal_init_lock */
-	mlan_status (*moal_init_lock)(t_void *pmoal_handle, t_void **pplock);
+	mlan_status (*moal_init_lock)(t_void *pmoal, t_void **pplock);
 	/** moal_free_lock */
-	mlan_status (*moal_free_lock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_free_lock)(t_void *pmoal, t_void *plock);
 	/** moal_spin_lock */
-	mlan_status (*moal_spin_lock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_spin_lock)(t_void *pmoal, t_void *plock);
 	/** moal_spin_unlock */
-	mlan_status (*moal_spin_unlock)(t_void *pmoal_handle, t_void *plock);
+	mlan_status (*moal_spin_unlock)(t_void *pmoal, t_void *plock);
 	/** moal_print */
-	t_void (*moal_print)(t_void *pmoal_handle, t_u32 level, char *pformat,
-			     IN...);
+	t_void (*moal_print)(t_void *pmoal, t_u32 level, char *pformat, IN...);
 	/** moal_print_netintf */
-	t_void (*moal_print_netintf)(t_void *pmoal_handle, t_u32 bss_index,
+	t_void (*moal_print_netintf)(t_void *pmoal, t_u32 bss_index,
 				     t_u32 level);
 	/** moal_assert */
-	t_void (*moal_assert)(t_void *pmoal_handle, t_u32 cond);
+	t_void (*moal_assert)(t_void *pmoal, t_u32 cond);
 
 	/** moal_hist_data_add */
-	t_void (*moal_hist_data_add)(t_void *pmoal_handle, t_u32 bss_index,
+	t_void (*moal_hist_data_add)(t_void *pmoal, t_u32 bss_index,
 				     t_u16 rx_rate, t_s8 snr, t_s8 nflr,
 				     t_u8 antenna);
+	t_void (*moal_updata_peer_signal)(t_void *pmoal, t_u32 bss_index,
+					  t_u8 *peer_addr, t_s8 snr, t_s8 nflr);
+	t_u64 (*moal_do_div)(t_u64 num, t_u32 base);
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
-	mlan_status (*moal_wait_hostcmd_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_wait_hostcmd_complete)(t_void *pmoal,
 						  t_u32 bss_index);
-	mlan_status (*moal_notify_hostcmd_complete)(t_void *pmoal_handle,
+	mlan_status (*moal_notify_hostcmd_complete)(t_void *pmoal,
 						    t_u32 bss_index);
 #endif
+	void (*moal_tp_accounting)(t_void *pmoal, t_void *buf,
+				   t_u32 drop_point);
+	void (*moal_tp_accounting_rx_param)(t_void *pmoal, unsigned int type,
+					    unsigned int rsvd1);
+	void (*moal_amsdu_tp_accounting)(t_void *pmoal, t_s32 delay,
+					 t_s32 copy_delay);
 } mlan_callbacks, *pmlan_callbacks;
 
 /** Parameter unchanged, use MLAN default setting */
@@ -1809,6 +2590,9 @@ typedef struct _mlan_device {
 	/** MFG mode */
 	t_u32 mfg_mode;
 #endif
+#ifdef PCIE
+	t_u16 ring_size;
+#endif
 #if defined(SDIO)
 	/** SDIO interrupt mode (0: INT_MODE_SDIO, 1: INT_MODE_GPIO) */
 	t_u32 int_mode;
@@ -1865,6 +2649,8 @@ typedef struct _mlan_device {
 	t_u8 indication_gpio;
 	/** Dynamic MIMO-SISO switch for hscfg*/
 	t_u8 hs_mimo_switch;
+	/** channel time and mode for DRCS*/
+	t_u32 drcs_chantime_mode;
 #ifdef USB
 	/** Tx CMD endpoint address */
 	t_u8 tx_cmd_ep;
@@ -1875,9 +2661,9 @@ typedef struct _mlan_device {
 	t_u8 rx_data_ep;
 	/** Tx data endpoint address */
 	t_u8 tx_data_ep;
+	/** Tx data second endpoint address */
+	t_u8 tx_data2_ep;
 #endif
-	/** fw region */
-	t_bool fw_region;
 	/** passive to active scan */
 	t_u8 passive_to_active_scan;
 	/** uap max supported station per chip */
@@ -1886,6 +2672,14 @@ typedef struct _mlan_device {
 	t_u32 drv_mode;
 	/** dfs w53 cfg */
 	t_u8 dfs53cfg;
+	/** dfs_offload */
+	t_u8 dfs_offload;
+	/** extend enhance scan */
+	t_u8 ext_scan;
+	/* mcs32 setting */
+	t_u8 mcs32;
+	/** second mac flag */
+	t_u8 second_mac;
 } mlan_device, *pmlan_device;
 
 /** MLAN API function prototype */
@@ -1896,51 +2690,53 @@ MLAN_API mlan_status mlan_register(pmlan_device pmdevice,
 				   t_void **ppmlan_adapter);
 
 /** Un-registration */
-MLAN_API mlan_status mlan_unregister(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_unregister(t_void *padapter);
 
 /** Firmware Downloading */
-MLAN_API mlan_status mlan_dnld_fw(t_void *pmlan_adapter, pmlan_fw_image pmfw);
+MLAN_API mlan_status mlan_dnld_fw(t_void *padapter, pmlan_fw_image pmfw);
 
 /** Custom data pass API */
-MLAN_API mlan_status mlan_set_init_param(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_set_init_param(t_void *padapter,
 					 pmlan_init_param pparam);
 
 /** Firmware Initialization */
-MLAN_API mlan_status mlan_init_fw(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_init_fw(t_void *padapter);
 
 /** Firmware Shutdown */
-MLAN_API mlan_status mlan_shutdown_fw(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_shutdown_fw(t_void *padapter);
 
 /** Main Process */
-MLAN_API mlan_status mlan_main_process(t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_main_process(t_void *padapter);
 
 /** Rx process */
-mlan_status mlan_rx_process(t_void *pmlan_adapter, t_u8 *rx_pkts);
+mlan_status mlan_rx_process(t_void *padapter, t_u8 *rx_pkts);
 
 /** Packet Transmission */
-MLAN_API mlan_status mlan_send_packet(t_void *pmlan_adapter,
-				      pmlan_buffer pmbuf);
+MLAN_API mlan_status mlan_send_packet(t_void *padapter, pmlan_buffer pmbuf);
 
 #ifdef USB
 /** mlan_write_data_async_complete */
-MLAN_API mlan_status mlan_write_data_async_complete(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_write_data_async_complete(t_void *padapter,
 						    pmlan_buffer pmbuf,
 						    t_u32 port,
 						    mlan_status status);
 
 /** Packet Reception */
-MLAN_API mlan_status mlan_recv(t_void *pmlan_adapter, pmlan_buffer pmbuf,
+MLAN_API mlan_status mlan_recv(t_void *padapter, pmlan_buffer pmbuf,
 			       t_u32 port);
 #endif /* USB */
 
 /** Packet Reception complete callback */
-MLAN_API mlan_status mlan_recv_packet_complete(t_void *pmlan_adapter,
+MLAN_API mlan_status mlan_recv_packet_complete(t_void *padapter,
 					       pmlan_buffer pmbuf,
 					       mlan_status status);
 
+/** handle amsdu deaggregated packet */
+void mlan_process_deaggr_pkt(t_void *padapter, pmlan_buffer pmbuf, t_u8 *drop);
+
 #if defined(SDIO) || defined(PCIE)
 /** interrupt handler */
-MLAN_API mlan_status mlan_interrupt(t_u16 msg_id, t_void *pmlan_adapter);
+MLAN_API mlan_status mlan_interrupt(t_u16 msg_id, t_void *padapter);
 
 #if defined(SYSKT)
 /** GPIO IRQ callback function */
@@ -1948,7 +2744,7 @@ MLAN_API t_void mlan_hs_callback(t_void *pctx);
 #endif /* SYSKT_MULTI || SYSKT */
 #endif /* SDIO || PCIE */
 
-MLAN_API t_void mlan_pm_wakeup_card(t_void *pmlan_adapter, t_u8 keep_wakeup);
+MLAN_API t_void mlan_pm_wakeup_card(t_void *padapter, t_u8 keep_wakeup);
 
 MLAN_API t_u8 mlan_is_main_process_running(t_void *adapter);
 #ifdef PCIE
@@ -1956,10 +2752,15 @@ MLAN_API t_void mlan_set_int_mode(t_void *adapter, t_u32 int_mode,
 				  t_u8 func_num);
 #endif
 /** mlan ioctl */
-MLAN_API mlan_status mlan_ioctl(t_void *pmlan_adapter,
-				pmlan_ioctl_req pioctl_req);
+MLAN_API mlan_status mlan_ioctl(t_void *padapter, pmlan_ioctl_req pioctl_req);
 /** mlan select wmm queue */
-MLAN_API t_u8 mlan_select_wmm_queue(t_void *pmlan_adapter, t_u8 bss_num,
-				    t_u8 tid);
+MLAN_API t_u8 mlan_select_wmm_queue(t_void *padapter, t_u8 bss_num, t_u8 tid);
+
+/** mlan mask host interrupt */
+MLAN_API mlan_status mlan_disable_host_int(t_void *padapter);
+/** mlan unmask host interrupt */
+MLAN_API mlan_status mlan_enable_host_int(t_void *padapter);
+
+#define CSI_SIGNATURE 0xABCD
 
 #endif /* !_MLAN_DECL_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ieee.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ieee.h
old mode 100644
new mode 100755
index 03b5fd4ff..e0a73ad4a
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ieee.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ieee.h
@@ -4,7 +4,7 @@
  *  definitions used in MLAN and MOAL module.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -48,7 +48,7 @@ typedef enum _WLAN_802_11_NETWORK_TYPE {
 
 #ifdef BIG_ENDIAN_SUPPORT
 /** Frame control: Type Mgmt frame */
-#define IEEE80211_FC_MGMT_FRAME_TYPE_MASK 0x3000
+#define IEEE80211_FC_MGMT_FRAME_TYPE_MASK 0x0c00
 /** Frame control: SubType Mgmt frame */
 #define IEEE80211_GET_FC_MGMT_FRAME_SUBTYPE(fc) (((fc)&0xF000) >> 12)
 #else
@@ -67,7 +67,8 @@ typedef enum _WLAN_802_11_NETWORK_TYPE {
 
 typedef enum _IEEEtypes_Ext_ElementId_e {
 	HE_CAPABILITY = 35,
-	HE_OPERATION = 36
+	HE_OPERATION = 36,
+	HE_6G_CAPABILITY = 59
 } IEEEtypes_Ext_ElementId_e;
 
 /** IEEE Type definitions  */
@@ -89,6 +90,8 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	EXTEND_CHANNEL_SWITCH_ANN = 60,
 	QUIET = 40,
 	IBSS_DFS = 41,
+	MEASUREMENT_REQUEST = 38,
+	MEASUREMENT_REPORT = 39,
 	SUPPORTED_CHANNELS = 36,
 	REGULATORY_CLASS = 59,
 	HT_CAPABILITY = 45,
@@ -100,6 +103,7 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	NONTX_BSSID_CAP = 83,
 	MBSSID_INDEX = 85,
 	EXT_CAPABILITY = 127,
+	LINK_ID = 101,
 	/*IEEE802.11r*/
 	MOBILITY_DOMAIN = 54,
 	FAST_BSS_TRANSITION = 55,
@@ -131,6 +135,7 @@ typedef MLAN_PACK_START enum _IEEEtypes_ElementId_e {
 	VS_IE = VENDOR_SPECIFIC_221,
 	WAPI_IE = 68,
 	FRAGMENT = 242,
+	RSNX_IE = 244,
 	EXTENSION = 255
 } MLAN_PACK_END IEEEtypes_ElementId_e;
 
@@ -174,6 +179,33 @@ typedef MLAN_PACK_START struct _IEEEtypes_Generic_t {
 	t_u8 data[IEEE_MAX_IE_SIZE - sizeof(IEEEtypes_Header_t)];
 } MLAN_PACK_END IEEEtypes_Generic_t, *pIEEEtypes_Generic_t;
 
+#define MEASURE_TYPE_CLI 8
+#define MEASURE_TYPE_LOCATION_CIVIC 9
+
+/** Measurement Report IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MeasurementReport_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Measurement Token */
+	t_u8 ms_token;
+	/** Measurement Report Mode */
+	t_u8 ms_rp_mode;
+	/** Measurement Type, value in MEASURE_TYPE_XXX */
+	t_u8 ms_type;
+	/** variable */
+	t_u8 variable[];
+} MLAN_PACK_END IEEEtypes_MeasurementReport_t;
+
+/** Report */
+typedef MLAN_PACK_START struct _IEEEtypes_Report_t {
+	/** Subelement ID */
+	t_u8 subelement_id;
+	/** length */
+	t_u8 length;
+	/** variable */
+	t_u8 variable[];
+} MLAN_PACK_END IEEEtypes_Report_t;
+
 /**ft capability policy*/
 typedef MLAN_PACK_START struct _IEEEtypes_FtCapPolicy_t {
 #ifdef BIG_ENDIAN_SUPPORT
@@ -734,25 +766,27 @@ typedef MLAN_PACK_START struct {
 	t_u8 Schedule : 1;
 	IEEEtypes_WMM_TSPEC_TS_Info_AckPolicy_e AckPolicy : 2;
 	t_u8 UserPri : 3; /* ! 802.1d User Priority */
-	IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
-								    Legacy/Trigg
-								  */
+	// IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /*
+	// !Legacy/Trigg*/
+	t_u8 PowerSaveBehavior : 1;
 	t_u8 Aggregation : 1; /* ! Reserved */
 	t_u8 AccessPolicy2 : 1; /* ! */
 	t_u8 AccessPolicy1 : 1; /* ! */
 	IEEEtypes_WMM_TSPEC_TS_Info_Direction_e Direction : 2;
 	t_u8 TID : 4; /* ! Unique identifier */
-	IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	// IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	t_u8 TrafficType : 1;
 #else
-	IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	// IEEEtypes_WMM_TSPEC_TS_TRAFFIC_TYPE_e TrafficType : 1;
+	t_u8 TrafficType : 1;
 	t_u8 TID : 4; /* ! Unique identifier */
 	IEEEtypes_WMM_TSPEC_TS_Info_Direction_e Direction : 2;
 	t_u8 AccessPolicy1 : 1; /* ! */
 	t_u8 AccessPolicy2 : 1; /* ! */
 	t_u8 Aggregation : 1; /* ! Reserved */
-	IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
-								    Legacy/Trigg
-								  */
+	// IEEEtypes_WMM_TSPEC_TS_Info_PSB_e PowerSaveBehavior : 1; /* !
+	// Legacy/Trigg*/
+	t_u8 PowerSaveBehavior : 1;
 	t_u8 UserPri : 3; /* ! 802.1d User Priority */
 	IEEEtypes_WMM_TSPEC_TS_Info_AckPolicy_e AckPolicy : 2;
 	t_u8 Schedule : 1;
@@ -938,6 +972,20 @@ typedef MLAN_PACK_START struct _IEEEtypes_CountryInfoFullSet_t {
 
 #endif /* STA_SUPPORT */
 
+/** Data structure for Link ID */
+typedef MLAN_PACK_START struct _IEEEtypes_LinkIDElement_t {
+	/** Element ID */
+	t_u8 element_id;
+	/** Length */
+	t_u8 len;
+	/** bssid */
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/** initial sta address */
+	t_u8 init_sta[MLAN_MAC_ADDR_LENGTH];
+	/** respose sta address */
+	t_u8 resp_sta[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END IEEEtypes_LinkIDElement_t, *pIEEEtypes_LinkIDElement_t;
+
 /** HT Capabilities Data */
 typedef struct MLAN_PACK_START _HTCap_t {
 	/** HT Capabilities Info field */
@@ -1025,6 +1073,53 @@ typedef MLAN_PACK_START struct _IEEEtypes_HTInfo_t {
 	HTInfo_t ht_info;
 } MLAN_PACK_END IEEEtypes_HTInfo_t, *pIEEEtypes_HTInfo_t;
 
+/** the AP which send the multi_bssid IE */
+#define MULTI_BSSID_AP 1
+/** the AP which don't send beacon */
+#define MULTI_BSSID_SUB_AP 2
+/** IEEEtypes_NotxBssCap_t */
+typedef MLAN_PACK_START struct _IEEEtypes_NotxBssCap_t {
+	/** Nontransmitted BSSID Capability: Element ID */
+	t_u8 element_id;
+	/** Nontransmitted BSSID Capability : Length */
+	t_u8 len;
+	/** capability */
+	t_u16 cap;
+} MLAN_PACK_END IEEEtypes_NotxBssCap_t, *pIEEEtypes_NotxBssCap_t;
+
+/** Multi BSSID IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MultiBSSIDIndex_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** BSSID Index */
+	t_u8 bssid_index;
+	/** DTIM Period (Optional, not Present in ProbeRsp) */
+	t_u8 dtim_period;
+	/** DTIM Count (Optional, not Present in ProbeRsp) */
+	t_u8 dtim_count;
+} MLAN_PACK_END IEEEtypes_MultiBSSIDIndex_t, *pIEEEtypes_MultiBSSIDIndex_t;
+
+/** NonTransmitted BSSID Profile Subelement IE */
+/** SUBID for IEEEtypes_NonTransBSSIDCap_t */
+#define NONTRANS_BSSID_PROFILE_SUBELEM_ID 0
+
+/** NonTransmitted BSSID Capability IE */
+typedef MLAN_PACK_START struct _IEEEtypes_NonTransBSSIDProfile_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	t_u8 profile_data[];
+} MLAN_PACK_END IEEEtypes_NonTransBSSIDProfile_t,
+	*pIEEEtypes_NonTransBSSIDProfile_t;
+
+/** Multi BSSID IE */
+typedef MLAN_PACK_START struct _IEEEtypes_MultiBSSID_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Max BSSID Indicator */
+	t_u8 max_bssid_indicator;
+	/** Optional Subelement data*/
+	t_u8 sub_elem_data[];
+} MLAN_PACK_END IEEEtypes_MultiBSSID_t, *pIEEEtypes_MultiBSSID_t;
 /** 20/40 BSS Coexistence IE */
 typedef MLAN_PACK_START struct _IEEEtypes_2040BSSCo_t {
 	/** Generic IE header */
@@ -1207,6 +1302,51 @@ typedef MLAN_PACK_START struct _IEEEtypes_Extension_t {
 	t_u8 data[];
 } MLAN_PACK_END IEEEtypes_Extension_t, *pIEEEtypes_Extension_t;
 
+typedef MLAN_PACK_START struct _IEEEtypes_HeMcsMap_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Max HE-MAC for 8 SS */
+	t_u8 max_mcs_8ss : 2;
+	/** Max HE-MAC for 7 SS */
+	t_u8 max_mcs_7ss : 2;
+	/** Max HE-MAC for 6 SS */
+	t_u8 max_mcs_6ss : 2;
+	/** Max HE-MAC for 5 SS */
+	t_u8 max_mcs_5ss : 2;
+	/** Max HE-MAC for 4 SS */
+	t_u8 max_mcs_4ss : 2;
+	/** Max HE-MAC for 3 SS */
+	t_u8 max_mcs_3ss : 2;
+	/** Max HE-MAC for 2 SS */
+	t_u8 max_mcs_2ss : 2;
+	/** Max HE-MAC for 1 SS */
+	t_u8 max_mcs_1ss : 2;
+#else
+	/** Max HE-MAC for 1 SS */
+	t_u8 max_mcs_1ss : 2;
+	/** Max HE-MAC for 2 SS */
+	t_u8 max_mcs_2ss : 2;
+	/** Max HE-MAC for 3 SS */
+	t_u8 max_mcs_3ss : 2;
+	/** Max HE-MAC for 4 SS */
+	t_u8 max_mcs_4ss : 2;
+	/** Max HE-MAC for 5 SS */
+	t_u8 max_mcs_5ss : 2;
+	/** Max HE-MAC for 6 SS */
+	t_u8 max_mcs_6ss : 2;
+	/** Max HE-MAC for 7 SS */
+	t_u8 max_mcs_7ss : 2;
+	/** Max HE-MAC for 8 SS */
+	t_u8 max_mcs_8ss : 2;
+#endif
+} MLAN_PACK_END IEEEtypes_HeMcsMap_t, *pIEEEtypes_HeMcsMap_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeMcsNss_t {
+	/** HE Rx MCS and NSS Set */
+	t_u16 rx_mcs;
+	/** HE Tx MCS and NSS Set*/
+	t_u16 tx_mcs;
+} MLAN_PACK_END IEEEtypes_HeMcsNss_t, *pIEEEtypes_HeMcsNss_t;
+
 typedef MLAN_PACK_START struct _IEEEtypes_HECap_t {
 	/** Generic IE header */
 	IEEEtypes_Header_t ieee_hdr;
@@ -1216,14 +1356,121 @@ typedef MLAN_PACK_START struct _IEEEtypes_HECap_t {
 	t_u8 he_mac_cap[6];
 	/** he phy capability info */
 	t_u8 he_phy_cap[11];
-	/** he txrx mcs support , size would be 4 or 8 or 12 */
+	/** he txrx mcs support (for 80 MHz) */
 	t_u8 he_txrx_mcs_support[4];
-	/** PPE Thresholds (optional) */
+	/** Optional Field, including he_txrx_mcs_support for 160 and 80+80 MHz,
+	 * and PPE Thresholds */
+	t_u8 option[28];
 } MLAN_PACK_END IEEEtypes_HECap_t, *pIEEEtypes_HECap_t;
 
-/** Maximum number of subbands in the IEEEtypes_SupportedChannels_t structure */
-#define WLAN_11H_MAX_SUBBANDS 5
+typedef MLAN_PACK_START struct _IEEEtypes_HeOpParam_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** Reserved, including 6G Operation Info Pressent (bit17) */
+	t_u8 reserved : 6; /* bit 18-23 */
+	/* 6g operation info present */
+	t_u8 he_6g_op_info_present : 1; /* bit 17 */
+	/** ER SU Disable */
+	t_u8 er_su_disable : 1; /* bit 16 */
+	/** Co-Hosted BSS */
+	t_u16 co_located_bss : 1; /* bit 15 */
+	/** VHT Operation Info Present */
+	t_u16 vht_op_info_present : 1; /* bit 14 */
+	/** TXOP Duration RTS Threshold */
+	t_u16 txop_dur_rts_threshold : 10; /* bit 4-13 */
+	/** TWT Required */
+	t_u16 twt_req : 1; /* bit 3 */
+	/** Default PE Duration */
+	t_u16 default_pe_dur : 3; /* bit 0-2 */
+#else
+	/** Default PE Duration */
+	t_u16 default_pe_dur : 3; /* bit 0-2 */
+	/** TWT Required */
+	t_u16 twt_req : 1; /* bit 3 */
+	/** TXOP Duration RTS Threshold */
+	t_u16 txop_dur_rts_threshold : 10; /* bit 4-13 */
+	/** VHT Operation Info Present */
+	t_u16 vht_op_info_present : 1; /* bit 14 */
+	/** Co-Hosted BSS */
+	t_u16 co_located_bss : 1; /* bit 15 */
+	/** ER SU Disable */
+	t_u8 er_su_disable : 1; /* bit 16 */
+	/* 6g operation info present */
+	t_u8 he_6g_op_info_present : 1; /* bit 17 */
+	/** Reserved bit 18-23 */
+	t_u8 reserved : 6; /* bit 18-23 */
+#endif
+} MLAN_PACK_END IEEEtypes_HeOpParam_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeBssColorInfo_t {
+#ifdef BIG_ENDIAN_SUPPORT
+	/** BSS Color Disabled */
+	t_u8 bss_color_disabled : 1; /* bit 7 */
+	/** Partial BSS Color */
+	t_u8 partial_bss_color : 1; /* bit 6 */
+	/** BSS Color */
+	t_u8 bss_color : 6; /* bit 0-5 */
+#else
+	/** BSS Color */
+	t_u8 bss_color : 6; /* bit 0-5 */
+	/** Partial BSS Color */
+	t_u8 partial_bss_color : 1; /* bit 6 */
+	/** BSS Color Disabled */
+	t_u8 bss_color_disabled : 1; /* bit 7 */
+#endif
+} MLAN_PACK_END IEEEtypes_HeBssColorInfo_t;
+
+typedef MLAN_PACK_START struct _IEEEtypes_HeOp_t {
+	/** Generic IE header */
+	IEEEtypes_Header_t ieee_hdr;
+	/** Element id extension */
+	t_u8 ext_id;
+	/** HE Operation Parameters */
+	IEEEtypes_HeOpParam_t he_op_param;
+	/** BSS Color Info */
+	IEEEtypes_HeBssColorInfo_t bss_color_info;
+	/** Basic HE-MCS and NSS Set */
+	IEEEtypes_HeMcsMap_t basic_he_mcs_nss;
+	/** Optional Field, including VHT Operation Info Max Co-Hosted BSSID
+	 * Indicator, and 6Ghz Operation Info  */
+	t_u8 option[9];
+} MLAN_PACK_END IEEEtypes_HeOp_t;
+
+/** default channel switch count */
+#define DEF_CHAN_SWITCH_COUNT 5
+
+/*  IEEE Channel Switch Announcement Element (7.3.2.20) */
+/**
+ *  Provided in beacons and probe responses.  Used to advertise when
+ *    and to which channel it is changing to.  Only starting STAs in
+ *    an IBSS and APs are allowed to originate a chan switch element.
+ */
+typedef MLAN_PACK_START struct {
+	t_u8 element_id; /**< IEEE Element ID = 37 */
+	t_u8 len; /**< Element length after id and len */
+	t_u8 chan_switch_mode; /**< STA should not transmit any frames if 1 */
+	t_u8 new_channel_num; /**< Channel # that AP/IBSS is moving to */
+	t_u8 chan_switch_count; /**< # of TBTTs before channel switch */
+
+} MLAN_PACK_END IEEEtypes_ChanSwitchAnn_t;
+
+/** data structure for extended channel switch */
+typedef MLAN_PACK_START struct {
+	/** IEEE element ID = 60 */
+	t_u8 element_id;
+	/** Element length after id and len, set to 4 */
+	t_u8 len;
+	/** STA should not transmit any frames if 1 */
+	t_u8 chan_switch_mode;
+	/** Operate class # that AP/IBSS is moving to */
+	t_u8 new_oper_class;
+	/** Channel # that AP/IBSS is moving to */
+	t_u8 new_channel_num;
+	/** of TBTTs before channel switch */
+	t_u8 chan_switch_count;
+} MLAN_PACK_END IEEEtypes_ExtChanSwitchAnn_t;
 
+/** Maximum number of subbands in the IEEEtypes_SupportedChannels_t structure */
+#define WLAN_11H_MAX_SUBBANDS 6
 /** Maximum number of DFS channels configured in IEEEtypes_IBSS_DFS_t */
 #define WLAN_11H_MAX_IBSS_DFS_CHANNELS 25
 
@@ -1276,40 +1523,6 @@ typedef MLAN_PACK_START struct {
 
 } MLAN_PACK_END IEEEtypes_SupportedChannels_t;
 
-/** default channel switch count */
-#define DEF_CHAN_SWITCH_COUNT 5
-
-/*  IEEE Channel Switch Announcement Element (7.3.2.20) */
-/**
- *  Provided in beacons and probe responses.  Used to advertise when
- *    and to which channel it is changing to.  Only starting STAs in
- *    an IBSS and APs are allowed to originate a chan switch element.
- */
-typedef MLAN_PACK_START struct {
-	t_u8 element_id; /**< IEEE Element ID = 37 */
-	t_u8 len; /**< Element length after id and len */
-	t_u8 chan_switch_mode; /**< STA should not transmit any frames if 1 */
-	t_u8 new_channel_num; /**< Channel # that AP/IBSS is moving to */
-	t_u8 chan_switch_count; /**< # of TBTTs before channel switch */
-
-} MLAN_PACK_END IEEEtypes_ChanSwitchAnn_t;
-
-/** data structure for extended channel switch */
-typedef MLAN_PACK_START struct {
-	/** IEEE element ID = 60 */
-	t_u8 element_id;
-	/** Element length after id and len, set to 4 */
-	t_u8 len;
-	/** STA should not transmit any frames if 1 */
-	t_u8 chan_switch_mode;
-	/** Operate class # that AP/IBSS is moving to */
-	t_u8 new_oper_class;
-	/** Channel # that AP/IBSS is moving to */
-	t_u8 new_channel_num;
-	/** of TBTTs before channel switch */
-	t_u8 chan_switch_count;
-} MLAN_PACK_END IEEEtypes_ExtChanSwitchAnn_t;
-
 /*  IEEE Wide Bandwidth Channel Switch Element */
 /**
  *  Provided in beacons and probe responses.  Used to advertise when
@@ -1338,6 +1551,8 @@ typedef MLAN_PACK_START struct {
 	t_u8 local_max_tp_20mhz; /**< Local Maximum Transmit Power for 20 MHZ>*/
 	t_u8 local_max_tp_40mhz; /**< Local Maximum Transmit Power for 40 MHZ>*/
 	t_u8 local_max_tp_80mhz; /**< Local Maximum Transmit Power for 80 MHZ>*/
+	t_u8 local_max_tp_160mhz_80_80mhz; /**< Local Maximum Transmit Power for
+					      160/80+80 MHZ>*/
 } MLAN_PACK_END IEEEtypes_VhtTpcEnvelope_t;
 
 /*  IEEE Quiet Period Element (7.3.2.23) */
@@ -1444,6 +1659,50 @@ typedef struct {
 
 } wlan_11h_bss_info_t;
 
+/** Ethernet packet type for TDLS */
+#define MLAN_ETHER_PKT_TYPE_TDLS_ACTION (0x890D)
+
+/*802.11z  TDLS action frame type and strcuct */
+typedef MLAN_PACK_START struct {
+	/*link indentifier ie =101*/
+	t_u8 element_id;
+	/*len = 18*/
+	t_u8 len;
+	/** bssid */
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/** init sta mac address */
+	t_u8 init_sta[MLAN_MAC_ADDR_LENGTH];
+	/** resp sta mac address */
+	t_u8 resp_sta[MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END IEEEtypes_tdls_linkie;
+
+/** action code for tdls setup request */
+#define TDLS_SETUP_REQUEST 0
+/** action code for tdls setup response */
+#define TDLS_SETUP_RESPONSE 1
+/** action code for tdls setup confirm */
+#define TDLS_SETUP_CONFIRM 2
+/** action code for tdls tear down */
+#define TDLS_TEARDOWN 3
+/** action code for tdls traffic indication */
+#define TDLS_PEER_TRAFFIC_INDICATION 4
+/** action code for tdls channel switch request */
+#define TDLS_CHANNEL_SWITCH_REQUEST 5
+/** action code for tdls channel switch response */
+#define TDLS_CHANNEL_SWITCH_RESPONSE 6
+/** action code for tdls psm request */
+#define TDLS_PEER_PSM_REQUEST 7
+/** action code for tdls psm response */
+#define TDLS_PEER_PSM_RESPONSE 8
+/** action code for tdls traffic response */
+#define TDLS_PEER_TRAFFIC_RESPONSE 9
+/** action code for tdls discovery request */
+#define TDLS_DISCOVERY_REQUEST 10
+/** action code for TDLS discovery response */
+#define TDLS_DISCOVERY_RESPONSE 14
+/** category public */
+#define CATEGORY_PUBLIC 4
+
 /** action code for 20/40 BSS Coexsitence Management frame */
 #define BSS_20_40_COEX 0
 
@@ -1488,8 +1747,8 @@ typedef MLAN_PACK_START struct _wlan_user_scan_chan {
 	t_u8 radio_type;
 	/** Scan type: Active = 1, Passive = 2 */
 	t_u8 scan_type;
-	/** Reserved */
-	t_u8 reserved;
+	/** rnr_flag */
+	t_u8 rnr_flag;
 	/** Scan duration in milliseconds; if 0 default used */
 	t_u32 scan_time;
 } MLAN_PACK_END wlan_user_scan_chan;
@@ -1581,6 +1840,8 @@ typedef MLAN_PACK_START struct {
 	t_u8 bssid_num;
 	/** BSSID filter list used in the to limit the scan results */
 	mlan_802_11_mac_addr bssid_list[MAX_BSSID_FILTER_LIST];
+	/** use scan setting from scan_cfg only  */
+	t_u8 scan_cfg_only;
 } MLAN_PACK_END wlan_user_scan_cfg;
 
 /** Default scan interval in millisecond*/
@@ -1602,9 +1863,15 @@ typedef MLAN_PACK_START struct {
 #define BG_SCAN_SSID_RSSI_MATCH 0x0004
 /**wait for all channel scan to complete to report scan result*/
 #define BG_SCAN_WAIT_ALL_CHAN_DONE 0x80000000
-/** Maximum number of channels that can be sent in bg scan config */
+
+#define CHAN_MAX_6G 0
+
+/** max bgscan chan number */
 #define WLAN_BG_SCAN_CHAN_MAX 38
 
+/** max bgscan chan number, include UNII_4 channel */
+#define WLAN_BG_SCAN_CHAN_MAX_UNII_4 41
+
 /** Enumeration definition */
 /** EES MODE */
 typedef enum {
@@ -1671,7 +1938,7 @@ typedef MLAN_PACK_START struct {
 	/** SSID filter list used in the to limit the scan results */
 	wlan_user_scan_ssid ssid_list[MRVDRV_MAX_SSID_LIST_LENGTH];
 	/** Variable number (fixed maximum) of channels to scan up */
-	wlan_user_scan_chan chan_list[WLAN_BG_SCAN_CHAN_MAX];
+	wlan_user_scan_chan chan_list[WLAN_USER_SCAN_CHAN_MAX];
 	/** scan channel gap */
 	t_u16 scan_chan_gap;
 	/** Enable EES configuration */
@@ -1704,6 +1971,11 @@ typedef MLAN_PACK_START struct {
 } MLAN_PACK_END wlan_bgscan_cfg;
 #endif /* STA_SUPPORT */
 
+/** The open AP in OWE transmition Mode */
+#define OWE_TRANS_MODE_OPEN 1
+/** The security AP in OWE trsnsition Mode */
+#define OWE_TRANS_MODE_OWE 2
+
 #ifdef PRAGMA_PACK
 #pragma pack(pop)
 #endif
@@ -1718,6 +1990,15 @@ typedef struct _BSSDescriptor_t {
 	/** SSID */
 	mlan_802_11_ssid ssid;
 
+	/** Transition MAC address */
+	mlan_802_11_mac_addr trans_mac_address;
+
+	/** Transition SSID */
+	mlan_802_11_ssid trans_ssid;
+
+	/** OWE Transition mode */
+	t_u8 owe_transition_mode;
+
 	/** WEP encryption requirement */
 	t_u32 privacy;
 
@@ -1799,6 +2080,10 @@ typedef struct _BSSDescriptor_t {
 	IEEEtypes_HTInfo_t *pht_info;
 	/** HT Information Offset */
 	t_u16 ht_info_offset;
+	/** Flag to indicate this is multi_bssid_ap */
+	t_u8 multi_bssid_ap;
+	/** the mac address of multi-bssid AP */
+	mlan_802_11_mac_addr multi_bssid_ap_addr;
 	/** 20/40 BSS Coexistence IE */
 	IEEEtypes_2040BSSCo_t *pbss_co_2040;
 	/** 20/40 BSS Coexistence Offset */
@@ -1861,6 +2146,10 @@ typedef struct _BSSDescriptor_t {
 	IEEEtypes_Generic_t *prsn_ie;
 	/** RSN IE offset in the beacon buffer */
 	t_u16 rsn_offset;
+	/** RSNX IE */
+	IEEEtypes_Generic_t *prsnx_ie;
+	/** RSNX IE offset in the beacon buffer */
+	t_u16 rsnx_offset;
 #ifdef STA_SUPPORT
 	/** WAPI IE */
 	IEEEtypes_Generic_t *pwapi_ie;
@@ -1882,7 +2171,8 @@ typedef struct _BSSDescriptor_t {
 	t_u32 beacon_buf_size;
 	/** Max allocated size for updated scan response */
 	t_u32 beacon_buf_size_max;
-
+	/** scan age in secs */
+	t_u32 age_in_secs;
 } BSSDescriptor_t, *pBSSDescriptor_t;
 
 #endif /* !_MLAN_IEEE_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h
old mode 100644
new mode 100755
index caaadb03c..877cb2575
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/mlan_ioctl.h
@@ -3,7 +3,7 @@
  *  @brief This file declares the IOCTL data structures and APIs.
  *
  *
- *  Copyright 2014-2020 NXP
+ *  Copyright 2008-2023 NXP
  *
  *  This software file (the File) is distributed by NXP
  *  under the terms of the GNU General Public License Version 2, June 1991
@@ -86,6 +86,9 @@ enum _mlan_ioctl_req_id {
 #endif
 
 	MLAN_OID_BSS_FIND_BSSID = 0x0002001D,
+#ifdef UAP_SUPPORT
+	MLAN_OID_ACTION_CHAN_SWITCH = 0x0002001E,
+#endif
 
 	/* Radio Configuration Group */
 	MLAN_IOCTL_RADIO_CFG = 0x00030000,
@@ -107,6 +110,8 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_SNMP_MIB_DTIM_PERIOD = 0x00040006,
 	MLAN_OID_SNMP_MIB_SIGNALEXT_ENABLE = 0x00040007,
 	MLAN_OID_SNMP_MIB_CTRL_DEAUTH = 0x00040008,
+	MLAN_OID_SNMP_MIB_DOT11H_FAKERADAR = 0x00040009,
+	MLAN_OID_SNMP_MIB_CHAN_TRACK = 0x0004000A,
 
 	/* Status Information Group */
 	MLAN_IOCTL_GET_INFO = 0x00050000,
@@ -198,6 +203,7 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_11N_CFG_DELBA = 0x000C000C,
 	MLAN_OID_11N_CFG_REJECT_ADDBA_REQ = 0x000C000D,
 	MLAN_OID_11N_CFG_COEX_RX_WINSIZE = 0x000C000E,
+	MLAN_OID_11N_CFG_TX_AGGR_CTRL = 0x000C000F,
 	MLAN_OID_11N_CFG_IBSS_AMPDU_PARAM = 0x000C0010,
 	MLAN_OID_11N_CFG_MIN_BA_THRESHOLD = 0x000C0011,
 
@@ -228,7 +234,10 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_11H_CHAN_REPORT_REQUEST = 0x00110004,
 	MLAN_OID_11H_CHAN_SWITCH_COUNT = 0x00110005,
 	MLAN_OID_11H_CHAN_NOP_INFO = 0x00110006,
+	MLAN_OID_11H_CHAN_DFS_STATE = 0x00110007,
 	MLAN_OID_11H_DFS_W53_CFG = 0x00110008,
+	MLAN_OID_11H_DFS_MODE = 0x00110009,
+	MLAN_OID_11H_NOP_CHAN_LIST = 0x0011000A,
 
 	/* 802.11n Configuration Group RANDYTODO for value assign */
 	MLAN_IOCTL_11AC_CFG = 0x00120000,
@@ -257,6 +266,8 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_MISC_ASSOC_RSP = 0x0020000C,
 	MLAN_OID_MISC_INIT_SHUTDOWN = 0x0020000D,
 	MLAN_OID_MISC_CUSTOM_IE = 0x0020000F,
+	MLAN_OID_MISC_TDLS_CONFIG = 0x00200010,
+	MLAN_OID_MISC_NET_MONITOR = 0x00200011,
 	MLAN_OID_MISC_TX_DATAPAUSE = 0x00200012,
 	MLAN_OID_MISC_IP_ADDR = 0x00200013,
 	MLAN_OID_MISC_MAC_CONTROL = 0x00200014,
@@ -271,6 +282,7 @@ enum _mlan_ioctl_req_id {
 #endif
 	MLAN_OID_MISC_HOTSPOT_CFG = 0x0020001C,
 	MLAN_OID_MISC_OTP_USER_DATA = 0x0020001D,
+	MLAN_OID_MISC_AUTO_ASSOC = 0x0020001E,
 #ifdef USB
 	MLAN_OID_MISC_USB_AGGR_CTRL = 0x0020001F,
 #endif
@@ -281,25 +293,32 @@ enum _mlan_ioctl_req_id {
 #if defined(STA_SUPPORT)
 	MLAN_OID_MISC_PMFCFG = 0x00200022,
 #endif
+	MLAN_OID_MISC_MULTI_CHAN_CFG = 0x00200023,
+	MLAN_OID_MISC_MULTI_CHAN_POLICY = 0x00200024,
 #ifdef WIFI_DIRECT_SUPPORT
 	MLAN_OID_MISC_WIFI_DIRECT_CONFIG = 0x00200025,
 #endif
+	MLAN_OID_MISC_TDLS_OPER = 0x00200026,
+	MLAN_OID_MISC_GET_TDLS_IES = 0x00200027,
 	MLAN_OID_MISC_LOW_PWR_MODE = 0x00200029,
 	MLAN_OID_MISC_MEF_FLT_CFG = 0x0020002A,
 	MLAN_OID_MISC_DFS_REAPTER_MODE = 0x0020002B,
-#ifdef RX_PACKET_COALESCE
-	MLAN_OID_MISC_RX_PACKET_COALESCE = 0x0020002C,
-#endif
+	MLAN_OID_MISC_TDLS_CS_CHANNEL = 0x0020002D,
 	MLAN_OID_MISC_COALESCE_CFG = 0x0020002E,
+	MLAN_OID_MISC_TDLS_IDLE_TIME = 0x0020002F,
 	MLAN_OID_MISC_GET_SENSOR_TEMP = 0x00200030,
+	MLAN_OID_MISC_IPV6_RA_OFFLOAD = 0x00200036,
 	MLAN_OID_MISC_GTK_REKEY_OFFLOAD = 0x00200037,
 	MLAN_OID_MISC_OPER_CLASS = 0x00200038,
 	MLAN_OID_MISC_PMIC_CFG = 0x00200039,
 	MLAN_OID_MISC_IND_RST_CFG = 0x00200040,
+	MLAN_OID_MISC_ROAM_OFFLOAD = 0x00200042,
+	MLAN_OID_MISC_ROAM_OFFLOAD_APLIST = 0x00200043,
 	MLAN_OID_MISC_GET_TSF = 0x00200045,
 	MLAN_OID_MISC_GET_CHAN_REGION_CFG = 0x00200046,
 	MLAN_OID_MISC_CLOUD_KEEP_ALIVE = 0x00200048,
 	MLAN_OID_MISC_OPER_CLASS_CHECK = 0x00200049,
+	MLAN_OID_MISC_DRCS_CFG = 0x00200050,
 
 	MLAN_OID_MISC_CWMODE_CTRL = 0x00200051,
 	MLAN_OID_MISC_AGGR_CTRL = 0x00200052,
@@ -309,11 +328,15 @@ enum _mlan_ioctl_req_id {
 
 	MLAN_OID_MISC_ROBUSTCOEX = 0x00200056,
 	MLAN_OID_MISC_GET_TX_RX_HISTOGRAM = 0x00200057,
+	MLAN_OID_MISC_CONFIG_RTT = 0x00200059,
+	MLAN_OID_MISC_CANCEL_RTT = 0x0020005A,
+	MLAN_OID_MISC_RTT_RESPONDER_CFG = 0x0020005B,
 	MLAN_OID_MISC_CFP_INFO = 0x00200060,
 	MLAN_OID_MISC_BOOT_SLEEP = 0x00200061,
 #if defined(PCIE)
 	MLAN_OID_MISC_SSU = 0x00200062,
 #endif
+	MLAN_OID_MISC_CSI = 0x00200064,
 	MLAN_OID_MISC_DMCS_CONFIG = 0x00200065,
 	MLAN_OID_MISC_RX_ABORT_CFG = 0x00200066,
 	MLAN_OID_MISC_RX_ABORT_CFG_EXT = 0x00200067,
@@ -331,6 +354,25 @@ enum _mlan_ioctl_req_id {
 	MLAN_OID_MISC_CFP_TABLE = 0x0020007A,
 	MLAN_OID_MISC_RANGE_EXT = 0x0020007B,
 	MLAN_OID_MISC_DOT11MC_UNASSOC_FTM_CFG = 0x0020007C,
+	MLAN_OID_MISC_TP_STATE = 0x0020007D,
+	MLAN_OID_MISC_HAL_PHY_CFG = 0x0020007E,
+	MLAN_OID_MISC_RF_TEST_HE_POWER = 0X0020007F,
+	MLAN_OID_MISC_MULTI_AP_CFG = 0x00200080,
+#ifdef UAP_SUPPORT
+	MLAN_OID_MISC_WACP_MODE = 0x00200081,
+#endif
+	MLAN_OID_MISC_GPIO_TSF_LATCH = 0x00200082,
+	MLAN_OID_MISC_GET_TSF_INFO = 0x00200083,
+	MLAN_OID_MISC_ASSOC_REQ = 0x00200084,
+	MLAN_OID_MISC_IPS_CFG = 0x00200085,
+	MLAN_OID_MISC_MC_AGGR_CFG = 0x00200086,
+	MLAN_OID_MISC_CH_LOAD = 0x00200087,
+	MLAN_OID_MISC_STATS = 0x00200088,
+	MLAN_OID_MISC_CH_LOAD_RESULTS = 0x00200089,
+	MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX = 0x0020008A,
+	MLAN_OID_MISC_CROSS_CHIP_SYNCH = 0x0020008B,
+	MLAN_OID_MISC_RF_TEST_CONFIG_TRIGGER_FRAME = 0x0020008C,
+	MLAN_OID_MISC_OFDM_DESENSE_CFG = 0x0020008D,
 };
 
 /** Sub command size */
@@ -372,6 +414,14 @@ enum _mlan_pass_to_act_scan {
 	MLAN_PASS_TO_ACT_SCAN_DIS
 };
 
+/** Enumeration for passive to active scan */
+enum _mlan_ext_scan {
+	MLAN_EXTENDED_SCAN_UNCHANGED = 0,
+	MLAN_LEGACY_SCAN,
+	MLAN_EXT_SCAN,
+	MLAN_EXT_SCAN_ENH
+};
+
 /** Max number of supported rates */
 #define MLAN_SUPPORTED_RATES 32
 
@@ -580,6 +630,8 @@ enum _mlan_bss_mode {
 
 /** Maximum key length */
 #define MLAN_MAX_KEY_LENGTH 32
+/** Maximum PMK R0 NAME key length */
+#define MLAN_MAX_PMKR0_NAME_LENGTH 16
 
 /** Maximum atim window in milliseconds */
 #define MLAN_MAX_ATIM_WINDOW 50
@@ -612,7 +664,7 @@ typedef struct _mlan_multicast_list {
 } mlan_multicast_list, *pmlan_multicast_list;
 
 /** Max channel */
-#define MLAN_MAX_CHANNEL 165
+#define MLAN_MAX_CHANNEL 177
 /** Maximum number of channels in table */
 #define MLAN_MAX_CHANNEL_NUM 128
 
@@ -674,6 +726,26 @@ typedef struct _mlan_ds_misc_assoc_rsp {
 	t_u32 assoc_resp_len;
 } mlan_ds_misc_assoc_rsp, *pmlan_ds_misc_assoc_rsp;
 
+/** Type definition of mlan_ds_misc_assoc_req for MLAN_OID_MISC_ASSOC_REQ */
+typedef struct _mlan_ds_misc_assoc_req {
+	/** Associate req buffer */
+	t_u8 assoc_req_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_req_len;
+} mlan_ds_misc_assoc_req, *pmlan_ds_misc_assoc_req;
+
+/** mlan_ds_assoc_info */
+typedef struct _mlan_ds_assoc_info {
+	/** Associate req buffer */
+	t_u8 assoc_resp_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_resp_len;
+	/** Associate req buffer */
+	t_u8 assoc_req_buf[ASSOC_RSP_BUF_SIZE];
+	/** Response buffer length */
+	t_u32 assoc_req_len;
+} mlan_ds_assoc_info, *pmlan_ds_assoc_info;
+
 /** mlan_ssid_bssid  data structure for
  *  MLAN_OID_BSS_START and MLAN_OID_BSS_FIND_BSS
  */
@@ -686,6 +758,8 @@ typedef struct _mlan_ssid_bssid {
 	t_u32 idx;
 	/** Receive signal strength in dBm */
 	t_s32 rssi;
+	/* previous bssid */
+	mlan_802_11_mac_addr prev_bssid;
 	/**channel*/
 	t_u16 channel;
 	/**mobility domain value*/
@@ -700,6 +774,11 @@ typedef struct _mlan_ssid_bssid {
 	t_u8 host_mlme;
 	/** assoicate resp frame/ie from firmware */
 	mlan_ds_misc_assoc_rsp assoc_rsp;
+	t_u8 owe_transition_mode;
+	/** Transition SSID */
+	mlan_802_11_ssid trans_ssid;
+	/** Transition BSSID */
+	mlan_802_11_mac_addr trans_bssid;
 } mlan_ssid_bssid, *pmlan_ssid_bssid;
 
 /** Data structure of WMM ECW */
@@ -845,6 +924,8 @@ typedef struct _mlan_deauth_param {
 #define PROTOCOL_WAPI 0x80
 /** WPA3 SAE */
 #define PROTOCOL_WPA3_SAE 0x100
+/** OWE */
+#define PROTOCOL_OWE 0x200
 
 /** Key_mgmt_psk */
 #define KEY_MGMT_NONE 0x04
@@ -1044,6 +1125,10 @@ typedef struct _mlan_uap_bss_param {
 	t_u8 channel;
 	/** auth mode */
 	t_u16 auth_mode;
+	/** PWE derivation */
+	t_u8 pwe_derivation;
+	/** transition disable */
+	t_u8 transition_disable;
 	/** encryption protocol */
 	t_u16 protocol;
 	/** key managment type */
@@ -1088,6 +1173,8 @@ typedef struct _mlan_uap_bss_param {
 
 	/** uap host based config */
 	t_u32 uap_host_based_config;
+	/** multi ap flag */
+	t_u8 multi_ap_flag;
 } mlan_uap_bss_param, *pmlan_uap_bss_param;
 
 /** mlan_uap_scan_channels */
@@ -1102,6 +1189,27 @@ typedef struct _mlan_uap_scan_channels {
 	scan_chan_list chan_list[MLAN_MAX_CHANNEL];
 } mlan_uap_scan_channels;
 
+#define MAX_NUM_PKTS 9
+#define DEF_NUM_PKTS 3
+
+/** Default channel mode and retry packets for channel switch */
+#define DEFAULT_RETRY_PKTS 9
+#define DEFAULT_CHAN_MODE_MASK 3
+
+/** mlan_chan_switch_param */
+typedef struct _mlan_action_chan_switch {
+	/** mode*/
+	t_u8 mode;
+	/** switch mode*/
+	t_u8 chan_switch_mode;
+	/** oper class*/
+	t_u8 new_oper_class;
+	/** new channel */
+	t_u8 new_channel_num;
+	/** chan_switch_count */
+	t_u8 chan_switch_count;
+} mlan_action_chan_switch;
+
 /** mlan_uap_oper_ctrl */
 typedef struct _mlan_uap_oper_ctrl {
 	/** control value
@@ -1215,6 +1323,8 @@ typedef struct _mlan_ds_bss {
 		wmm_parameter_t ap_wmm_para;
 		/** ap scan channels for MLAN_OID_UAP_SCAN_CHANNELS*/
 		mlan_uap_scan_channels ap_scan_channels;
+		/** channel switch for MLAN_OID_UAP_CHAN_SWITCH */
+		mlan_action_chan_switch chanswitch;
 		/** ap channel for MLAN_OID_UAP_CHANNEL*/
 		chan_band_info ap_channel;
 		/** ap operation control for MLAN_OID_UAP_OPER_CTRL*/
@@ -1248,8 +1358,9 @@ typedef MLAN_PACK_START struct _otp_region_info {
 	t_u8 country_code[2];
 	t_u8 region_code;
 	t_u8 environment;
-	t_u16 force_reg : 1;
-	t_u16 reserved : 15;
+	t_u8 force_reg : 1;
+	t_u8 reserved : 7;
+	t_u8 dfs_region;
 } MLAN_PACK_END otp_region_info_t;
 
 /** Type definition of mlan_ds_custom_reg_domain */
@@ -1276,7 +1387,6 @@ enum _mlan_band_def {
 	BAND_AAC = 64,
 	BAND_GAX = 256,
 	BAND_AAX = 512,
-
 };
 
 /** Channel bandwidth */
@@ -1423,6 +1533,7 @@ typedef struct _mlan_ds_snmp_mib {
 		t_u8 signalext_enable;
 		/** Control deauth when uap switch channel */
 		t_u8 deauthctrl;
+		t_u8 chan_track;
 	} param;
 } mlan_ds_snmp_mib, *pmlan_ds_snmp_mib;
 
@@ -1594,6 +1705,54 @@ typedef struct _mlan_ds_get_stats {
 	t_u64 rx_octets_in_ampdu_cnt;
 	/** ampdu delimiter CRC error count */
 	t_u32 ampdu_delimiter_crc_error_cnt;
+	/** Rx Stuck Related Info*/
+	/** Rx Stuck Issue count */
+	t_u32 rx_stuck_issue_cnt[2];
+	/** Rx Stuck Recovery count */
+	t_u32 rx_stuck_recovery_cnt;
+	/** Rx Stuck TSF */
+	t_u64 rx_stuck_tsf[2];
+	/** Tx Watchdog Recovery Related Info */
+	/** Tx Watchdog Recovery count */
+	t_u32 tx_watchdog_recovery_cnt;
+	/** Tx Watchdog TSF */
+	t_u64 tx_watchdog_tsf[2];
+	/** Channel Switch Related Info */
+	/** Channel Switch Announcement Sent */
+	t_u32 channel_switch_ann_sent;
+	/** Channel Switch State */
+	t_u32 channel_switch_state;
+	/** Register Class */
+	t_u32 reg_class;
+	/** Channel Number */
+	t_u32 channel_number;
+	/** Channel Switch Mode */
+	t_u32 channel_switch_mode;
+	/** Reset Rx Mac Count */
+	t_u32 rx_reset_mac_recovery_cnt;
+	/** ISR2 Not Done Count*/
+	t_u32 rx_Isr2_NotDone_Cnt;
+	/** GDMA Abort Count */
+	t_u32 gdma_abort_cnt;
+	/** Rx Reset MAC Count */
+	t_u32 g_reset_rx_mac_cnt;
+	// Ownership error counters
+	/*Error Ownership error count*/
+	t_u32 dwCtlErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwBcnErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwMgtErrCnt;
+	/*Control Ownership error count*/
+	t_u32 dwDatErrCnt;
+	/*BIGTK MME good count*/
+	t_u32 bigtk_mmeGoodCnt;
+	/*BIGTK Replay error count*/
+	t_u32 bigtk_replayErrCnt;
+	/*BIGTK MIC error count*/
+	t_u32 bigtk_micErrCnt;
+	/*BIGTK MME not included count*/
+	t_u32 bigtk_mmeNotFoundCnt;
 } mlan_ds_get_stats, *pmlan_ds_get_stats;
 
 /** Type definition of mlan_ds_uap_stats for MLAN_OID_GET_STATS */
@@ -1729,12 +1888,18 @@ typedef struct _mlan_ds_get_signal {
 typedef struct _mlan_fw_info {
 	/** Firmware version */
 	t_u32 fw_ver;
+	/** Firmware Hotfix version */
+	t_u8 hotfix_version;
+	/** tx buf size */
+	t_u16 tx_buf_size;
 	/** MAC address */
 	mlan_802_11_mac_addr mac_addr;
 	/** 802.11n device capabilities */
 	t_u32 hw_dot_11n_dev_cap;
 	/** Device support for MIMO abstraction of MCSs */
 	t_u8 hw_dev_mcs_support;
+	/** mpdu density */
+	t_u8 hw_mpdu_density;
 	/** user's MCS setting */
 	t_u8 usr_dev_mcs_support;
 	/** 802.11ac device capabilities */
@@ -1771,13 +1936,28 @@ typedef struct _mlan_fw_info {
 	t_u8 antinfo;
 	/** max AP associated sta count supported by fw */
 	t_u8 max_ap_assoc_sta;
+	/** FW support roaming offload */
+	t_u8 fw_roaming_support;
 	/** Bandwidth not support 80Mhz */
 	t_u8 prohibit_80mhz;
+	/** FW support beacon protection */
+	t_u8 fw_beacon_prot;
+	/** FW RTT support */
+	t_u8 rtt_support;
+
+	/* lower 8 bytes of uuid */
+	t_u64 uuid_lo;
+
+	/* higher 8 bytes of uuid */
+	t_u64 uuid_hi;
 } mlan_fw_info, *pmlan_fw_info;
 
 /** Version string buffer length */
 #define MLAN_MAX_VER_STR_LEN 128
 
+/** Maximum length of secure boot uuid */
+#define MLAN_MAX_UUID_LEN 32
+
 /** mlan_ver_ext data structure for MLAN_OID_GET_VER_EXT */
 typedef struct _mlan_ver_ext {
 	/** Selected version string */
@@ -1790,6 +1970,14 @@ typedef struct _mlan_ver_ext {
 /** Extended Capabilities Data */
 typedef struct MLAN_PACK_START _ExtCap_t {
 	/** Extended Capabilities value */
+	t_u8 rsvdBit87 : 1; /* bit 87 */
+	t_u8 rsvdBit86 : 1; /* bit 86 */
+	t_u8 rsvdBit85 : 1; /* bit 85 */
+	t_u8 beacon_prot : 1; /* bit 84 */
+	t_u8 rsvdBit83 : 1; /* bit 83 */
+	t_u8 rsvdBit82 : 1; /* bit 82 */
+	t_u8 rsvdBit81 : 1; /* bit 81 */
+	t_u8 rsvdBit80 : 1; /* bit 80 */
 	t_u8 rsvdBit79 : 1; /* bit 79 */
 	t_u8 TWTResp : 1; /* bit 78 */
 	t_u8 TWTReq : 1; /* bit 77 */
@@ -1955,6 +2143,14 @@ typedef struct MLAN_PACK_START _ExtCap_t {
 	t_u8 TWTReq : 1; /* bit 77 */
 	t_u8 TWTResp : 1; /* bit 78 */
 	t_u8 rsvdBit79 : 1; /* bit 79 */
+	t_u8 rsvdBit80 : 1; /* bit 80 */
+	t_u8 rsvdBit81 : 1; /* bit 81 */
+	t_u8 rsvdBit82 : 1; /* bit 82 */
+	t_u8 rsvdBit83 : 1; /* bit 83 */
+	t_u8 beacon_prot : 1; /* bit 84 */
+	t_u8 rsvdBit85 : 1; /* bit 85 */
+	t_u8 rsvdBit86 : 1; /* bit 86 */
+	t_u8 rsvdBit87 : 1; /* bit 87 */
 } MLAN_PACK_END ExtCap_t, *pExtCap_t;
 #endif
 
@@ -1974,7 +2170,7 @@ typedef struct _mlan_bss_info {
 	/** Channel */
 	t_u32 bss_chan;
 	/** Band */
-	t_u8 bss_band;
+	t_u16 bss_band;
 	/** Region code */
 	t_u32 region_code;
 	/** Connection status */
@@ -2063,13 +2259,29 @@ typedef struct {
 #define SDIO_MP_DBG_NUM 10
 #endif
 
-#ifdef PCIE
-#define MLAN_MAX_TXRX_BD 0x20
-#endif
-
 /** Maximum size of IEEE Information Elements */
 #define IEEE_MAX_IE_SIZE 256
 
+/** support up to 8 TDLS peer */
+#define MLAN_MAX_TDLS_PEER_SUPPORTED 8
+/** TDLS peer info */
+typedef struct _tdls_peer_info {
+	/** station mac address */
+	t_u8 mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** SNR */
+	t_s8 snr;
+	/** Noise Floor */
+	t_s8 nf;
+	/** Extended Capabilities IE */
+	t_u8 ext_cap[IEEE_MAX_IE_SIZE];
+	/** HT Capabilities IE */
+	t_u8 ht_cap[IEEE_MAX_IE_SIZE];
+	/** VHT Capabilities IE */
+	t_u8 vht_cap[IEEE_MAX_IE_SIZE];
+	/** HE Capabilities IE */
+	t_u8 he_cap[IEEE_MAX_IE_SIZE];
+} tdls_peer_info;
+
 /** max ralist num */
 #define MLAN_MAX_RALIST_NUM 8
 /** ralist info */
@@ -2108,6 +2320,10 @@ typedef struct _mlan_debug_info {
 	t_u32 rx_tbl_num;
 	/** Rx reorder table*/
 	rx_reorder_tbl rx_tbl[MLAN_MAX_RX_BASTREAM_SUPPORTED];
+	/** TDLS peer number */
+	t_u32 tdls_peer_num;
+	/** TDLS peer list*/
+	tdls_peer_info tdls_peer_list[MLAN_MAX_TDLS_PEER_SUPPORTED];
 	/** ralist num */
 	t_u32 ralist_num;
 	/** ralist info */
@@ -2143,9 +2359,11 @@ typedef struct _mlan_debug_info {
 	/** Corresponds to port_open member of mlan_private */
 	t_u8 port_open;
 	/** bypass pkt count */
-	t_u16 bypass_pkt_count;
+	t_u32 bypass_pkt_count;
 	/** Corresponds to scan_processing member of mlan_adapter */
 	t_u32 scan_processing;
+	/** Corresponds to scan_state member of mlan_adapter */
+	t_u32 scan_state;
 	/** Corresponds to mlan_processing member of mlan_adapter */
 	t_u32 mlan_processing;
 	/** Corresponds to main_lock_flag member of mlan_adapter */
@@ -2193,6 +2411,10 @@ typedef struct _mlan_debug_info {
 	t_u32 mpa_sent_no_ports;
 	/** last recv wr_bitmap */
 	t_u32 last_recv_wr_bitmap;
+	/** last recv rd_bitmap */
+	t_u32 last_recv_rd_bitmap;
+	/** mp_data_port_mask */
+	t_u32 mp_data_port_mask;
 	/** last mp_wr_bitmap */
 	t_u32 last_mp_wr_bitmap[SDIO_MP_DBG_NUM];
 	/** last ports for cmd53 write data */
@@ -2257,6 +2479,8 @@ typedef struct _mlan_debug_info {
 	t_u32 dnld_cmd_in_secs;
 	/** Corresponds to data_sent member of mlan_adapter */
 	t_u8 data_sent;
+	/** Corresponds to data_sent_cnt member of mlan_adapter */
+	t_u32 data_sent_cnt;
 	/** Corresponds to cmd_sent member of mlan_adapter */
 	t_u8 cmd_sent;
 	/** SDIO multiple port read bitmap */
@@ -2280,8 +2504,8 @@ typedef struct _mlan_debug_info {
 	t_u32 eventbd_rdptr;
 	/** PCIE eventbd write pointer */
 	t_u32 eventbd_wrptr;
-	/** Last pkt size in transmit */
-	t_u32 last_tx_pkt_size[MLAN_MAX_TXRX_BD];
+	/** txrx_bd_size */
+	t_u16 txrx_bd_size;
 	/** txbd ring vbase */
 	t_u8 *txbd_ring_vbase;
 	/** txbd ring size */
@@ -2326,7 +2550,7 @@ typedef struct _mlan_debug_info {
 #define MAX_NUM_CLIENTS MAX_STA_COUNT
 
 /** station info */
-typedef struct _sta_info {
+typedef struct _sta_info_data {
 	/** STA MAC address */
 	t_u8 mac_address[MLAN_MAC_ADDR_LENGTH];
 	/** Power mgmt status */
@@ -2339,16 +2563,18 @@ typedef struct _sta_info {
 	sta_stats stats;
 	/** ie length */
 	t_u16 ie_len;
-	/** ie buffer */
-	t_u8 ie_buf[];
-} sta_info;
+} sta_info_data;
+
+/** Per station Maximum IE buffer SIZE */
+#define MAX_STA_LIST_IE_SIZE 13
 
 /** mlan_ds_sta_list structure for MLAN_OID_UAP_STA_LIST */
 typedef struct _mlan_ds_sta_list {
 	/** station count */
 	t_u16 sta_count;
 	/** station list */
-	sta_info info[MAX_NUM_CLIENTS];
+	sta_info_data info[MAX_NUM_CLIENTS];
+	/* ie_buf will be append at the end */
 } mlan_ds_sta_list, *pmlan_ds_sta_list;
 #endif
 
@@ -2395,6 +2621,7 @@ enum _mlan_auth_mode {
 	MLAN_AUTH_MODE_SHARED = 0x01,
 	MLAN_AUTH_MODE_FT = 0x02,
 	MLAN_AUTH_MODE_SAE = 0x03,
+	MLAN_AUTH_MODE_OWE = 0x04,
 	MLAN_AUTH_MODE_NETWORKEAP = 0x80,
 	MLAN_AUTH_MODE_AUTO = 0xFF,
 };
@@ -2406,7 +2633,8 @@ typedef enum {
 	AssocAgentAuth_FastBss,
 	AssocAgentAuth_FastBss_Skip,
 	AssocAgentAuth_Network_EAP,
-	AssocAgentAuth_Wpa3Sae,
+	AssocAgentAuth_Wpa3Sae = 6,
+	AssocAgentAuth_Owe = 7,
 	AssocAgentAuth_Auto,
 } AssocAgentAuthType_e;
 
@@ -2475,6 +2703,10 @@ enum _mlan_psk_type {
 #define KEY_FLAG_GCMP_256 0x00000040
 /** key flag for ccmp 256 */
 #define KEY_FLAG_CCMP_256 0x00000080
+/** key flag for GMAC_128 */
+#define KEY_FLAG_GMAC_128 0x00000100
+/** key flag for GMAC_256 */
+#define KEY_FLAG_GMAC_256 0x00000200
 
 /** Type definition of mlan_ds_encrypt_key for MLAN_OID_SEC_CFG_ENCRYPT_KEY */
 typedef struct _mlan_ds_encrypt_key {
@@ -2526,6 +2758,8 @@ typedef struct _mlan_sae_password_t {
 typedef struct _mlan_pmk_t {
 	/** PMK */
 	t_u8 pmk[MLAN_MAX_KEY_LENGTH];
+	t_u8 pmk_r0[MLAN_MAX_KEY_LENGTH];
+	t_u8 pmk_r0_name[MLAN_MAX_PMKR0_NAME_LENGTH];
 } mlan_pmk_t;
 
 /** Embedded supplicant RSN type: No RSN */
@@ -2576,10 +2810,20 @@ typedef struct _mlan_ds_ewpa_mode {
 	t_u32 act_groupcipher;
 } mlan_ds_esupp_mode, *pmlan_ds_esupp_mode;
 
+/* Security SSID MAX number support by firmware*/
+#define MAX_SEC_SSID_NUM 6
+
 /** Type definition of mlan_ds_sec_cfg for MLAN_IOCTL_SEC_CFG */
 typedef struct _mlan_ds_sec_cfg {
 	/** Sub-command */
 	t_u32 sub_command;
+	/** Flag to extend some structures to support multiple values.
+	 ** For example, mlan_ds_passphrase can only contain one value,
+	 ** if need use mlan_ds_passphrase[N], just set this flag and
+	 ** use mlan_ds_passphrase[] instead to avoid modify
+	 ** more already exist code.
+	 */
+	t_u8 multi_passphrase;
 	/** Security configuration parameter */
 	union {
 		/** Authentication mode for MLAN_OID_SEC_CFG_AUTH_MODE */
@@ -2605,6 +2849,7 @@ typedef struct _mlan_ds_sec_cfg {
 #ifdef UAP_SUPPORT
 		t_u8 sta_mac[MLAN_MAC_ADDR_LENGTH];
 #endif
+		mlan_ds_passphrase roam_passphrase[MAX_SEC_SSID_NUM];
 	} param;
 } mlan_ds_sec_cfg, *pmlan_ds_sec_cfg;
 
@@ -2871,7 +3116,9 @@ typedef struct _mlan_ds_beacon_stuck_param_cfg {
 #define HOST_SLEEP_COND_IPV6_PACKET MBIT(31)
 
 /** Host sleep config conditions: Default */
-#define HOST_SLEEP_DEF_COND 0
+#define HOST_SLEEP_DEF_COND                                                    \
+	(HOST_SLEEP_COND_BROADCAST_DATA | HOST_SLEEP_COND_UNICAST_DATA |       \
+	 HOST_SLEEP_COND_MAC_EVENT)
 
 /** Host sleep config GPIO : Default */
 #define HOST_SLEEP_DEF_GPIO 0xff
@@ -2917,6 +3164,8 @@ typedef struct _mlan_ds_hs_cfg {
 	t_u8 ext_gap;
 	/** GPIO wave level for extend hscfg*/
 	t_u8 gpio_wave;
+	/** Minimum delay between HsActive and HostWake (in msec) */
+	t_u16 min_wake_holdoff;
 } mlan_ds_hs_cfg, *pmlan_ds_hs_cfg;
 
 #define MAX_MGMT_FRAME_FILTER 2
@@ -3185,15 +3434,6 @@ typedef struct _mlan_ds_pm_cfg {
 	} param;
 } mlan_ds_pm_cfg, *pmlan_ds_pm_cfg;
 
-#ifdef RX_PACKET_COALESCE
-typedef struct {
-	mlan_cmd_result_e cmd_result; /**< Firmware execution result */
-
-	t_u32 pkt_threshold; /** Packet threshold */
-	t_u16 delay; /** Timeout value in milliseconds */
-} wlan_ioctl_rx_pkt_coalesce_config_t;
-#endif
-
 /*-----------------------------------------------------------------*/
 /** WMM Configuration Group */
 /*-----------------------------------------------------------------*/
@@ -3657,6 +3897,8 @@ typedef struct _mlan_ds_11n_cfg {
 		mlan_ds_reject_addba_req reject_addba_req;
 		/** Control coex RX window size configuration */
 		t_u32 coex_rx_winsize;
+		/** Control TX AMPDU configuration */
+		t_u32 txaggrctrl;
 		/** aggrprirotity table for MLAN_OID_11N_CFG_IBSS_AMPDU_PARAM */
 		mlan_ds_ibss_ampdu_param ibss_ampdu;
 		/** Minimum BA Threshold for MLAN_OID_11N_CFG_MIN_BA_THRESHOLD
@@ -3762,7 +4004,7 @@ typedef MLAN_PACK_START struct _mlan_ds_11ax_he_capa {
 
 /** Type definition of mlan_ds_11ax_he_cfg for MLAN_OID_11AX_HE_CFG */
 typedef struct _mlan_ds_11ax_he_cfg {
-	/** band, BIT0:2.4G, BIT1:5G*/
+	/** band, BIT0:2.4G, BIT1:5G BIT2:6G*/
 	t_u8 band;
 	/** mlan_ds_11ax_he_capa */
 	mlan_ds_11ax_he_capa he_cap;
@@ -3795,6 +4037,7 @@ typedef struct _mlan_ds_11ax_cfg {
 
 #define MLAN_11AX_TWT_SETUP_SUBID 0x114
 #define MLAN_11AX_TWT_TEARDOWN_SUBID 0x115
+#define MLAN_11AX_TWT_REPORT_SUBID 0x116
 
 #define MRVL_DOT11AX_ENABLE_SR_TLV_ID (PROPRIETARY_TLV_BASE_ID + 322)
 #define MRVL_DOT11AX_OBSS_PD_OFFSET_TLV_ID (PROPRIETARY_TLV_BASE_ID + 323)
@@ -3845,10 +4088,19 @@ typedef struct _mlan_ds_11ax_txop_cmd {
 } mlan_ds_11ax_txop_cmd, *pmlan_ds_11ax_txop_cmd;
 
 /** Type definition of mlan_ds_11ax_htc_cmd for MLAN_OID_11AX_CMD_CFG */
-typedef struct _mlan_ds_11ax_txomi_cmd {
+typedef struct MLAN_PACK_START_mlan_ds_11ax_txomi_cmd {
 	/* 11ax spec 9.2.4.6a.2 OM Control 12 bits. Bit 0 to bit 11 */
 	t_u16 omi;
-} mlan_ds_11ax_txomi_cmd, *pmlan_ds_11ax_txomi_cmd;
+	/* tx option
+	 * 0: send OMI in QoS NULL; 1: send OMI in QoS data; 0xFF: set OMI in
+	 * both
+	 */
+	t_u8 tx_option;
+	/* if OMI is sent in QoS data, specify the number of consecutive data
+	 * packets containing the OMI
+	 */
+	t_u8 num_data_pkts;
+} MLAN_PACK_END mlan_ds_11ax_txomi_cmd, *pmlan_ds_11ax_txomi_cmd;
 
 /** Type definition of mlan_ds_11ax_toltime_cmd for MLAN_OID_11AX_CMD_CFG */
 typedef struct _mlan_ds_11ax_toltime_cmd {
@@ -3922,6 +4174,17 @@ typedef struct MLAN_PACK_START _mlan_ds_twt_teardown {
 	t_u8 teardown_all_twt;
 } MLAN_PACK_END mlan_ds_twt_teardown, *pmlan_ds_twt_teardown;
 
+/** Type definition of mlan_ds_twt_report for MLAN_OID_11AX_TWT_CFG */
+typedef MLAN_PACK_START struct _mlan_ds_twt_report {
+	/** TWT report type, 0: BTWT id */
+	t_u8 type;
+	/** TWT report length of value in data */
+	t_u8 length;
+	t_u8 reserve[2];
+	/** TWT report payload for FW response to fill */
+	t_u8 data[36];
+} MLAN_PACK_END mlan_ds_twt_report, *pmlan_ds_twt_report;
+
 /** Type definition of mlan_ds_twtcfg for MLAN_OID_11AX_TWT_CFG */
 typedef struct MLAN_PACK_START _mlan_ds_twtcfg {
 	/** Sub-command */
@@ -3935,6 +4198,8 @@ typedef struct MLAN_PACK_START _mlan_ds_twtcfg {
 		/** TWT Teardown config for Sub ID: MLAN_11AX_TWT_TEARDOWN_SUBID
 		 */
 		mlan_ds_twt_teardown twt_teardown;
+		/** TWT report for Sub ID: MLAN_11AX_TWT_REPORT_SUBID */
+		mlan_ds_twt_report twt_report;
 	} param;
 } MLAN_PACK_END mlan_ds_twtcfg, *pmlan_ds_twtcfg;
 
@@ -3957,12 +4222,19 @@ typedef struct _mlan_ds_subband_set_t {
 	t_u8 max_tx_pwr;
 } mlan_ds_subband_set_t;
 
+#define NXP_DFS_UNSET 0
+#define NXP_DFS_FCC 1
+#define NXP_DFS_ETSI 2
+#define NXP_DFS_JP 3
+#define NXP_DFS_UNKNOWN 0xFF
 /** Domain regulatory information */
 typedef struct _mlan_ds_11d_domain_info {
+	/** DFS region code */
+	t_u8 dfs_region;
 	/** Country Code */
 	t_u8 country_code[COUNTRY_CODE_LEN];
 	/** Band that channels in sub_band belong to */
-	t_u8 band;
+	t_u16 band;
 	/** No. of subband in below */
 	t_u8 no_of_sub_band;
 	/** Subband data to send/last sent */
@@ -4005,13 +4277,11 @@ enum _mlan_reg_type {
 	MLAN_REG_CAU = 5,
 	MLAN_REG_PSU = 6,
 	MLAN_REG_BCA = 7,
-#if defined(PCIE9098) || defined(SD9098) || defined(USB9098) ||                \
-	defined(PCIE9097) || defined(USB9097) || defined(SD9097)
+	MLAN_REG_CIU = 8,
 	MLAN_REG_MAC2 = 0x81,
 	MLAN_REG_BBP2 = 0x82,
 	MLAN_REG_RF2 = 0x83,
 	MLAN_REG_BCA2 = 0x87
-#endif
 };
 
 /** Type definition of mlan_ds_reg_rw for MLAN_OID_REG_RW */
@@ -4077,6 +4347,8 @@ typedef struct _mlan_ds_11h_dfs_testing {
 	/** User-configured fixed channel to change to, 0 to use random channel
 	 */
 	t_u8 usr_fixed_new_chan;
+	/** User-configured cac restart */
+	t_u8 usr_cac_restart;
 } mlan_ds_11h_dfs_testing, *pmlan_ds_11h_dfs_testing;
 
 /** Type definition of mlan_ds_11h_dfs_testing for MLAN_OID_11H_CHAN_NOP_INFO */
@@ -4085,12 +4357,23 @@ typedef struct _mlan_ds_11h_chan_nop_info {
 	t_u8 curr_chan;
 	/** channel_width */
 	t_u8 chan_width;
+	/** check new channel flag */
+	t_u8 check_new_chan;
 	/** flag for chan under nop */
 	t_bool chan_under_nop;
 	/** chan_ban_info for new channel */
 	chan_band_info new_chan;
 } mlan_ds_11h_chan_nop_info, *pmlan_ds_11h_chan_nop_info;
 
+/** Type definition of mlan_ds_11h_nop_chan_list for MLAN_OID_11H_NOP_CHAN_LIST
+ */
+typedef struct _mlan_ds_11h_nop_chan_list {
+	/** number of nop channel */
+	t_u8 num_chan;
+	/** chan list array */
+	t_u8 chan_list[20];
+} mlan_ds_11h_nop_chan_list, *pmlan_ds_11h_nop_chan_list;
+
 typedef struct _mlan_ds_11h_chan_rep_req {
 	t_u16 startFreq;
 	Band_Config_t bandcfg;
@@ -4099,6 +4382,16 @@ typedef struct _mlan_ds_11h_chan_rep_req {
 	t_u8 host_based;
 } mlan_ds_11h_chan_rep_req;
 
+/** channel dfs state for MLAN_OID_11H_CHAN_DFS_STATE */
+typedef struct _mlan_ds_11h_chan_dfs_state {
+	/** channel */
+	t_u8 channel;
+	/** is dfs channel */
+	t_u8 dfs_required;
+	/** dfs state */
+	dfs_state_t dfs_state;
+} mlan_ds_11h_chan_dfs_state;
+
 typedef struct _mlan_ds_11h_dfs_w53_cfg {
 	/** dfs w53 cfg */
 	t_u8 dfs53cfg;
@@ -4116,11 +4409,17 @@ typedef struct _mlan_ds_11h_cfg {
 		mlan_ds_11h_dfs_testing dfs_testing;
 		/** channel NOP information for MLAN_OID_11H_CHAN_NOP_INFO */
 		mlan_ds_11h_chan_nop_info ch_nop_info;
+		/** NOP channel list for MLAN_OID_11H_NOP_CHAN_LIST */
+		mlan_ds_11h_nop_chan_list nop_chan_list;
 		/** channel report req for MLAN_OID_11H_CHAN_REPORT_REQUEST */
 		mlan_ds_11h_chan_rep_req chan_rpt_req;
 		/** channel switch count for MLAN_OID_11H_CHAN_SWITCH_COUNT*/
 		t_s8 cs_count;
+		/** channel dfs state for MLAN_OID_11H_CHAN_DFS_STATE */
+		mlan_ds_11h_chan_dfs_state ch_dfs_state;
 		mlan_ds_11h_dfs_w53_cfg dfs_w53_cfg;
+		/** dfs_mode for MLAN_OID_11H_DFS_MODE */
+		t_u8 dfs_mode;
 	} param;
 } mlan_ds_11h_cfg, *pmlan_ds_11h_cfg;
 
@@ -4139,6 +4438,9 @@ typedef struct _mlan_ds_11h_cfg {
 /** Enumeration for IE type */
 enum _mlan_ie_type {
 	MLAN_IE_TYPE_GEN_IE = 0,
+#ifdef STA_SUPPORT
+	MLAN_IE_TYPE_ARP_FILTER,
+#endif /* STA_SUPPORT */
 };
 
 /** Type definition of mlan_ds_misc_gen_ie for MLAN_OID_MISC_GEN_IE */
@@ -4205,6 +4507,33 @@ enum _mlan_func_cmd {
 	MLAN_FUNC_SHUTDOWN,
 };
 
+/* Net monitor filters: */
+/* management frame */
+#define MLAN_NETMON_MANAGEMENT MBIT(0)
+/* control frame */
+#define MLAN_NETMON_CONTROL MBIT(1)
+/* data frame */
+#define MLAN_NETMON_DATA MBIT(2)
+/* only unicast destined frame (no promiscuous) */
+#define MLAN_NETMON_NOPROM MBIT(3)
+/* capture non-bss Rx beacons */
+#define MLAN_NETMON_NON_BSS_BCN MBIT(5)
+/* capture Tx frames */
+#define MLAN_NETMON_TX MBIT(6)
+
+typedef struct _mlan_ds_misc_net_monitor {
+	/** Enable/disable network monitor */
+	t_u32 enable_net_mon;
+	/** Set net monitor filer flag */
+	t_u32 filter_flag;
+	/** Radio type */
+	t_u32 band;
+	/** Channel */
+	t_u32 channel;
+	/** Secondary channel bandwidth */
+	t_u32 chan_bandwidth;
+} mlan_ds_misc_net_monitor;
+
 /** Type definition of mlan_ds_misc_tx_datapause
  * for MLAN_OID_MISC_TX_DATAPAUSE
  */
@@ -4224,6 +4553,15 @@ typedef struct _mlan_ds_misc_rx_abort_cfg {
 	/** Rx weak RSSI pkt threshold */
 	t_s8 rssi_threshold;
 } mlan_ds_misc_rx_abort_cfg;
+/** Type definition of mlan_ds_misc_ofdm_desense_cfg
+ * for MLAN_OID_MISC_OFDM_DESENSE_CFG
+ */
+typedef struct _mlan_ds_misc_ofdm_desense_cfg {
+	/** enable/disable ofdm desense cfg */
+	t_u8 enable;
+	/** OFDM  CCA pkt threshold */
+	t_s8 cca_threshold;
+} mlan_ds_misc_ofdm_desense_cfg;
 
 /** Type definition of mlan_ds_misc_rx_abort_cfg_ext
  * for MLAN_OID_MISC_RX_ABORT_CFG_EXT
@@ -4235,6 +4573,14 @@ typedef struct _mlan_ds_misc_rx_abort_cfg_ext {
 	t_s8 rssi_margin;
 	/** specify ceil rssi threshold */
 	t_s8 ceil_rssi_threshold;
+	/** specify floor rssi threshold */
+	t_s8 floor_rssi_threshold;
+	/** current dynamic rssi threshold */
+	t_s8 current_dynamic_rssi_threshold;
+	/** rssi config: default or user configured */
+	t_u8 rssi_default_config;
+	/** EDMAC status */
+	t_u8 edmac_enable;
 } mlan_ds_misc_rx_abort_cfg_ext;
 
 /** Type definition of mlan_ds_misc_rx_abort_cfg_ext
@@ -4296,8 +4642,13 @@ typedef struct _mlan_ds_misc_cck_desense_cfg {
 #define IPADDR_TYPE_IPV4 (1)
 /** IP operation remove */
 #define MLAN_IPADDR_OP_IP_REMOVE (0)
+/** IP operation ARP filter */
+#define MLAN_IPADDR_OP_ARP_FILTER MBIT(0)
 /** IP operation ARP response */
 #define MLAN_IPADDR_OP_AUTO_ARP_RESP MBIT(1)
+/** Enable opcode bit for MDNS & NS when device enter into suspend **/
+#define MLAN_OP_ADD_MDNS MBIT(2)
+#define MLAN_OP_ADD_IPV6_NS MBIT(3)
 
 /** Type definition of mlan_ds_misc_ipaddr_cfg for MLAN_OID_MISC_IP_ADDR */
 typedef struct _mlan_ds_misc_ipaddr_cfg {
@@ -4311,6 +4662,14 @@ typedef struct _mlan_ds_misc_ipaddr_cfg {
 	t_u8 ip_addr[MAX_IPADDR][IPADDR_LEN];
 } mlan_ds_misc_ipaddr_cfg;
 
+/** Type definnition of mlan_ds_misc_ipv6_ra_offload for
+ * MLAN_OID_MISC_IPV6_RA_OFFLOAD*/
+typedef struct _mlan_ds_misc_ipv6_ra_offload {
+	/** 0: disable; 1: enable*/
+	t_u8 enable;
+	t_u8 ipv6_addr[16];
+} mlan_ds_misc_ipv6_ra_offload;
+
 /* MEF configuration disable */
 #define MEF_CFG_DISABLE 0
 /* MEF configuration Rx filter enable */
@@ -4347,6 +4706,16 @@ typedef struct _mlan_ds_misc_arb_cfg {
 	t_u32 arb_mode;
 } mlan_ds_misc_arb_cfg;
 
+/** Type definition of mlan_ds_misc_tp_state
+ *  for MLAN_OID_MISC_TP_STATE
+ */
+typedef struct _mlan_ds_misc_tp_state {
+	/** TP account mode 0-disable 1-enable */
+	t_u32 on;
+	/** Packet drop point */
+	t_u32 drop_point;
+} mlan_ds_misc_tp_state;
+
 /** Type definition of mlan_ds_misc_country_code
  *  for MLAN_OID_MISC_COUNTRY_CODE
  */
@@ -4483,7 +4852,17 @@ typedef struct _mlan_ds_misc_otp_user_data {
 	t_u8 user_data[MAX_OTP_USER_DATA_LEN];
 } mlan_ds_misc_otp_user_data;
 
-typedef struct _aggr_ctrl {
+/** Type definition of mlan_ds_fw_reconnect for MLAN_OID_MISC_AUTO_ASSOC */
+typedef struct _mlan_ds_fw_reconnect {
+	/* fw auto re-connect counter */
+	t_u8 fw_reconn_counter;
+	/* fw auto re-connect interval */
+	t_u8 fw_reconn_interval;
+	/* fw auto re-connect flags */
+	t_u16 fw_reconn_flags;
+} mlan_ds_fw_reconnect;
+
+typedef struct _aggr_ctrl_cfg {
 	/** Enable */
 	t_u16 enable;
 	/** Aggregation alignment */
@@ -4494,18 +4873,18 @@ typedef struct _aggr_ctrl {
 	t_u16 aggr_max_num;
 	/** Aggrgation timeout, in microseconds */
 	t_u16 aggr_tmo;
-} aggr_ctrl;
+} aggr_ctrl_cfg;
 
 /** Type definition of mlan_ds_misc_aggr_ctrl
  *  for MLAN_OID_MISC_AGGR_CTRL
  */
 typedef struct _mlan_ds_misc_aggr_ctrl {
 	/** Tx aggregation control */
-	aggr_ctrl tx;
+	aggr_ctrl_cfg tx;
 } mlan_ds_misc_aggr_ctrl;
 
 #ifdef USB
-typedef struct _usb_aggr_ctrl {
+typedef struct _usb_aggr_ctrl_cfg {
 	/** Enable */
 	t_u16 enable;
 	/** Aggregation mode */
@@ -4516,16 +4895,16 @@ typedef struct _usb_aggr_ctrl {
 	t_u16 aggr_max;
 	/** Aggrgation timeout, in microseconds */
 	t_u16 aggr_tmo;
-} usb_aggr_ctrl;
+} usb_aggr_ctrl_cfg;
 
 /** Type definition of mlan_ds_misc_usb_aggr_ctrl
  *  for MLAN_OID_MISC_USB_AGGR_CTRL
  */
 typedef struct _mlan_ds_misc_usb_aggr_ctrl {
 	/** Tx aggregation control */
-	usb_aggr_ctrl tx_aggr_ctrl;
+	usb_aggr_ctrl_cfg tx_aggr_ctrl;
 	/** Rx deaggregation control */
-	usb_aggr_ctrl rx_deaggr_ctrl;
+	usb_aggr_ctrl_cfg rx_deaggr_ctrl;
 } mlan_ds_misc_usb_aggr_ctrl;
 #endif
 
@@ -4557,6 +4936,33 @@ typedef struct _mlan_ds_wifi_direct_config {
 } mlan_ds_wifi_direct_config;
 #endif
 
+/** Type definition of mlan_ds_gpio_tsf_latch */
+typedef struct _mlan_ds_gpio_tsf_latch {
+	/**clock sync Mode */
+	t_u8 clock_sync_mode;
+	/**clock sync Role */
+	t_u8 clock_sync_Role;
+	/**clock sync GPIO Pin Number */
+	t_u8 clock_sync_gpio_pin_number;
+	/**clock sync GPIO Level or Toggle */
+	t_u8 clock_sync_gpio_level_toggle;
+	/**clock sync GPIO Pulse Width */
+	t_u16 clock_sync_gpio_pulse_width;
+} mlan_ds_gpio_tsf_latch;
+
+/** Type definition of mlan_ds_tsf_info */
+typedef struct _mlan_ds_tsf_info {
+	/**get tsf info format */
+	t_u16 tsf_format;
+	/**tsf info */
+	t_u16 tsf_info;
+	/**tsf */
+	t_u64 tsf;
+	/**Positive or negative offset in microsecond from Beacon TSF to GPIO
+	 * toggle TSF  */
+	t_s32 tsf_offset;
+} mlan_ds_tsf_info;
+
 #if defined(STA_SUPPORT)
 typedef struct _mlan_ds_misc_pmfcfg {
 	/** Management Frame Protection Capable */
@@ -4566,17 +4972,278 @@ typedef struct _mlan_ds_misc_pmfcfg {
 } mlan_ds_misc_pmfcfg;
 #endif
 
+typedef MLAN_PACK_START struct _mlan_ds_multi_chan_cfg {
+	/** Channel Time */
+	t_u32 channel_time;
+	/** Buffer Weight */
+	t_u8 buffer_weight;
+	/** tlv len */
+	t_u16 tlv_len;
+	/** TLV buffer */
+	t_u8 tlv_buf[];
+} MLAN_PACK_END mlan_ds_multi_chan_cfg;
+
+typedef MLAN_PACK_START struct _mlan_ds_drcs_cfg {
+	/** Channel Index*/
+	t_u16 chan_idx;
+	/** Channel time (in TU) for chan_idx */
+	t_u8 chantime;
+	/** Channel swith time (in TU) for chan_idx */
+	t_u8 switchtime;
+	/** Undoze time (in TU) for chan_idx */
+	t_u8 undozetime;
+	/** Rx traffic control scheme when channel switch*/
+	/** only valid for GC/STA interface*/
+	t_u8 mode;
+} MLAN_PACK_END mlan_ds_drcs_cfg;
+
 #define MAX_SSID_NUM 16
 #define MAX_AP_LIST 8
-
-#ifdef RX_PACKET_COALESCE
-typedef struct _mlan_ds_misc_rx_packet_coalesce {
-	/** packet threshold */
-	t_u32 packet_threshold;
-	/** timeout value */
-	t_u16 delay;
-} mlan_ds_misc_rx_packet_coalesce;
-#endif
+#define RETRY_UNLIMITED_TIME 0xFF
+
+#define FW_ROAM_ENABLE MBIT(0)
+#define FW_ROAM_TRIGGER_COND MBIT(1)
+#define FW_ROAM_BSSID MBIT(2)
+#define FW_ROAM_SSID MBIT(3)
+#define FW_ROAM_RETRY_COUNT MBIT(4)
+#define FW_ROAM_RSSI_PARA MBIT(5)
+#define FW_ROAM_BAND_RSSI MBIT(6)
+#define FW_ROAM_BGSCAN_PARAM MBIT(7)
+#define FW_ROAM_EES_PARAM MBIT(8)
+#define FW_ROAM_BCN_MISS_THRESHOLD MBIT(9)
+#define FW_ROAM_PRE_BCN_MISS_THRESHOLD MBIT(10)
+#define FW_ROAM_BLACKLIST MBIT(11)
+#define FW_ROAM_REPEAT_CNT MBIT(12)
+
+/*Roam offload configuration for auto reconnection when suspend and resume*/
+typedef enum _roam_offload_config_mode {
+	ROAM_OFFLOAD_ENABLE = 1,
+	ROAM_OFFLOAD_SUSPEND_CFG,
+	ROAM_OFFLOAD_RESUME_CFG,
+	ROAM_OFFLOAD_PARAM_CFG,
+} roam_offload_config_mode;
+
+typedef enum _roam_offload_set_mode {
+	ROAM_OFFLOAD_DISABLE = 0,
+	ROAM_OFFLOAD_WITH_APLIST,
+	ROAM_OFFLOAD_WITHOUT_APLIST,
+	ROAM_OFFLOAD_WITH_BSSID,
+	ROAM_OFFLOAD_WITH_SSID,
+	AUTO_RECONNECT,
+} roam_offload_set_mode;
+
+typedef enum _roam_offload_trigger_mode {
+	NO_TRIGGER = 0x00,
+	RSSI_LOW_TRIGGER = 0x01,
+	PRE_BEACON_LOST_TRIGGER = 0x02,
+	LINK_LOST_TRIGGER = 0x04,
+	DEAUTH_WITH_EXT_AP_TRIGGER = 0x08,
+} roam_offload_trigger_mode;
+
+/** mlan_ds_misc_ees_cfg structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_ees_cfg {
+	/* EES mode*/
+	t_u16 ees_mode;
+	/* EES report condition*/
+	t_u16 ees_rpt_condition;
+	/* High scan period(milliseconds)*/
+	t_u16 high_scan_period;
+	/* High scan count*/
+	t_u16 high_scan_count;
+	/* Middle scan period(milliseconds)*/
+	t_u16 mid_scan_period;
+	/* Middle scan count*/
+	t_u16 mid_scan_count;
+	/* Low scan period(milliseconds)*/
+	t_u16 low_scan_period;
+	/* Low scan count*/
+	t_u16 low_scan_count;
+} MLAN_PACK_END mlan_ds_misc_ees_cfg;
+
+/** mlan_ds_misc_bgscan_cfg structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_bgscan_cfg {
+	/* BSS Type  0x1-bss independent, 0x2-bss infrastructure, 0x3-bss any*/
+	t_u8 bss_type;
+	/* Number of channels scanned for each scan*/
+	t_u8 channels_per_scan;
+	/* Interval between consective scans*/
+	t_u32 scan_interval;
+	/* Conditons to trigger report to host*/
+	t_u32 bg_rpt_condition;
+} MLAN_PACK_END mlan_ds_misc_bgscan_cfg;
+
+/** mlan_ds_misc_band_rssi structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_band_rssi {
+	/* RSSI hysteresis*/
+	t_u8 rssi_hysteresis;
+	/*  Preferred channel band for fw roaming
+	 *  0:2.4G band; 1: 5G band; 2:4G band; 0xFF:band not set(invalid)
+	 */
+	t_u8 band_preferred;
+} MLAN_PACK_END mlan_ds_misc_band_rssi;
+
+/** mlan_ds_misc_ssid_list structure */
+typedef MLAN_PACK_START struct _mlan_ds_misc_ssid_list {
+	/* SSID number*/
+	t_u8 ssid_num;
+	/* SSID for fw roaming/auto_reconnect*/
+	mlan_802_11_ssid ssids[MAX_SSID_NUM];
+} MLAN_PACK_END mlan_ds_misc_ssid_list;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload_aplist {
+	/** Number of AP**/
+	t_u8 ap_num;
+	/** AP mac addrs**/
+	t_u8 ap_mac[MAX_AP_LIST][MLAN_MAC_ADDR_LENGTH];
+} MLAN_PACK_END mlan_ds_misc_roam_offload_aplist;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload_para_rssi {
+	/** Setting flag**/
+	t_u8 set_flag;
+	/** Max value of RSSI threshold**/
+	t_u8 max_rssi;
+	/** Min value of RSSI threshold**/
+	t_u8 min_rssi;
+	/** Adjusting step value of RSSI threshold**/
+	t_u8 step_rssi;
+} MLAN_PACK_END mlan_ds_misc_roam_offload_para_rssi;
+
+typedef MLAN_PACK_START struct _mlan_ds_misc_roam_offload {
+	/** Enable roam offload**/
+	t_u8 enable;
+	/** User set passphrase**/
+	t_u8 userset_passphrase;
+	/* Condition to trigger roaming
+	 * Bit0 : RSSI low trigger
+	 * Bit1 : Pre-beacon lost trigger
+	 * Bit2 : Link Lost trigger
+	 * Bit3 : Deauth by ext-AP trigger
+	 * Bit4 ~ Bit15 : Reserved
+	 * value 0 : no trigger
+	 * value 0xff : invalid
+	 */
+	t_u16 trigger_condition;
+	/** AP list**/
+	mlan_ds_misc_roam_offload_aplist aplist;
+	/*Roam offload configuration mode for auto connection when suspend and
+	 * resume*/
+	roam_offload_config_mode config_mode;
+	/** Retry count**/
+	t_u8 retry_count;
+	/** RSSI para**/
+	mlan_ds_misc_roam_offload_para_rssi para_rssi;
+	/** BSSID of reconnection**/
+	mlan_802_11_mac_addr bssid_reconnect;
+	/* SSID List(White list)*/
+	mlan_ds_misc_ssid_list ssid_list;
+	/* Black list(BSSID list)*/
+	mlan_ds_misc_roam_offload_aplist black_list;
+	/* BAND and RSSI_HYSTERESIS set flag*/
+	t_u8 band_rssi_flag;
+	mlan_ds_misc_band_rssi band_rssi;
+
+	/* BGSCAN params set flag*/
+	t_u8 bgscan_set_flag;
+	mlan_ds_misc_bgscan_cfg bgscan_cfg;
+
+	/* EES mode params set flag*/
+	t_u8 ees_param_set_flag;
+	mlan_ds_misc_ees_cfg ees_cfg;
+
+	/* Beacon miss threshold*/
+	t_u8 bcn_miss_threshold;
+
+	/* Beacon miss threshold*/
+	t_u8 pre_bcn_miss_threshold;
+
+	/* Scan repeat count*/
+	t_u16 repeat_count;
+} MLAN_PACK_END mlan_ds_misc_roam_offload;
+
+/**Action ID for TDLS disable link*/
+#define WLAN_TDLS_DISABLE_LINK 0x00
+/**Action ID for TDLS enable link*/
+#define WLAN_TDLS_ENABLE_LINK 0x01
+/**Action ID for TDLS create link*/
+#define WLAN_TDLS_CREATE_LINK 0x02
+/**Action ID for TDLS config link*/
+#define WLAN_TDLS_CONFIG_LINK 0x03
+/*reason code*/
+#define MLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED 26
+/** TDLS operation buffer */
+typedef struct _mlan_ds_misc_tdls_oper {
+	/** TDLS Action */
+	t_u16 tdls_action;
+	/** TDLS peer address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** peer capability */
+	t_u16 capability;
+	/** peer qos info */
+	t_u8 qos_info;
+	/** peer extend capability */
+	t_u8 *ext_capab;
+	/** extend capability len */
+	t_u8 ext_capab_len;
+	/** support rates */
+	t_u8 *supported_rates;
+	/** supported rates len */
+	t_u8 supported_rates_len;
+	/** peer ht_cap */
+	t_u8 *ht_capa;
+	/** peer vht capability */
+	t_u8 *vht_cap;
+} mlan_ds_misc_tdls_oper;
+
+/** flag for TDLS extcap */
+#define TDLS_IE_FLAGS_EXTCAP 0x0001
+/** flag for TDLS HTCAP */
+#define TDLS_IE_FLAGS_HTCAP 0x0002
+/** flag for TDLS HTINFO */
+#define TDLS_IE_FLAGS_HTINFO 0x0004
+/** flag for TDLS VHTCAP */
+#define TDLS_IE_FLAGS_VHTCAP 0x0008
+/** flag for TDLS VHTOPRAT */
+#define TDLS_IE_FLAGS_VHTOPRAT 0x0010
+/** flag for TDLS AID inof */
+#define TDLS_IE_FLAGS_AID 0x0020
+/** flag for TDLS Supported channels and regulatory class IE*/
+#define TDLS_IE_FLAGS_SUPP_CS_IE 0x0040
+/** flag for TDLS Qos info */
+#define TDLS_IE_FLAGS_QOS_INFO 0x0080
+/** flag for TDLS SETUP */
+#define TDLS_IE_FLAGS_SETUP 0x0100
+#define TDLS_IE_FLAGS_HECAP 0x0200
+#define TDLS_IE_FLAGS_HEOP 0x0400
+
+/** TDLS ie buffer */
+typedef struct _mlan_ds_misc_tdls_ies {
+	/** TDLS peer address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** flags for request IEs */
+	t_u16 flags;
+	/** Qos info */
+	t_u8 QosInfo;
+	/** Extended Capabilities IE */
+	t_u8 ext_cap[IEEE_MAX_IE_SIZE];
+	/** HT Capabilities IE */
+	t_u8 ht_cap[IEEE_MAX_IE_SIZE];
+	/** HT Information IE */
+	t_u8 ht_info[IEEE_MAX_IE_SIZE];
+	/** VHT Capabilities IE */
+	t_u8 vht_cap[IEEE_MAX_IE_SIZE];
+	/** VHT Operations IE */
+	t_u8 vht_oprat[IEEE_MAX_IE_SIZE];
+	/** aid Info */
+	t_u8 aid_info[IEEE_MAX_IE_SIZE];
+	/** HE Capabilities IE */
+	t_u8 he_cap[IEEE_MAX_IE_SIZE];
+	/** HE Operation IE */
+	t_u8 he_op[IEEE_MAX_IE_SIZE];
+	/** supported channels */
+	t_u8 supp_chan[IEEE_MAX_IE_SIZE];
+	/** supported regulatory class */
+	t_u8 regulatory_class[IEEE_MAX_IE_SIZE];
+} mlan_ds_misc_tdls_ies;
 
 typedef struct _mlan_ds_misc_dfs_repeater {
 	/** Set or Get */
@@ -4682,6 +5349,8 @@ typedef struct _mef_entry_t {
 typedef struct _mlan_ds_misc_mef_flt_cfg {
 	/** Type of action*/
 	int mef_act_type;
+	/** Operation code*/
+	t_u32 op_code;
 	/** NV Filter Criteria*/
 	t_u32 criteria;
 	/** NV MEF entry*/
@@ -4752,6 +5421,21 @@ typedef struct _mlan_ds_misc_keep_alive {
 	t_u16 ether_type;
 } mlan_ds_misc_keep_alive, *pmlan_ds_misc_keep_alive;
 
+#define MKEEP_ALIVE_ACK_PKT_MAX 100
+typedef struct _mlan_ds_misc_keep_alive_rx {
+	t_u8 mkeep_alive_id;
+	t_u8 enable;
+	/** enable/disable tcp reset*/
+	t_u8 reset;
+	/**True means saved in driver, false means not saved or download*/
+	t_u8 cached;
+	t_u8 dst_mac[MLAN_MAC_ADDR_LENGTH];
+	t_u8 src_mac[MLAN_MAC_ADDR_LENGTH];
+	t_u16 pkt_len;
+	t_u8 packet[MKEEP_ALIVE_ACK_PKT_MAX];
+	/** Ethernet type */
+	t_u16 ether_type;
+} mlan_ds_misc_keep_alive_rx, *pmlan_ds_misc_keep_alive_rx;
 /** TX and RX histogram statistic parameters*/
 typedef MLAN_PACK_START struct _mlan_ds_misc_tx_rx_histogram {
 	/** Enable or disable get tx/rx histogram statistic */
@@ -4806,6 +5490,115 @@ typedef struct _mlan_ds_misc_robustcoex_params {
 	t_u8 gpio_polarity;
 } mlan_ds_misc_robustcoex_params;
 
+/** RTT configuration */
+typedef struct _mlan_rtt_config {
+	/** peer device mac address */
+	t_u8 addr[MLAN_MAC_ADDR_LENGTH];
+	/** 1-sided or 2-sided RTT */
+	t_u8 type;
+	/** optional - peer device hint (STA, P2P, AP) */
+	t_u8 peer;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	t_u8 channel;
+	/** Required for STA-AP mode, optional for P2P, NBD etc. */
+	Band_Config_t bandcfg;
+	/** Time interval between bursts (units: 100 ms).
+	 * Applies to 1-sided and 2-sided RTT multi-burst requests.
+	 * Range: 0-31, 0: no preference by initiator (2-sided RTT) */
+	t_u8 burst_period;
+	/** Total number of RTT bursts to be executed. It will be
+	 * specified in the same way as the parameter "Number of
+	 * Burst Exponent" found in the FTM frame format. It
+	 * applies to both: 1-sided RTT and 2-sided RTT. Valid
+	 * values are 0 to 15 as defined in 802.11mc std.
+	 * 0 means single shot
+	 * The implication of this parameter on the maximum
+	 * number of RTT results is the following:
+	 * for 1-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst)
+	 * for 2-sided RTT: max num of RTT results =
+	 * (2^num_burst)*(num_frames_per_burst - 1) */
+	t_u8 num_burst;
+	/** num of frames per burst.
+	 * Minimum value = 1, Maximum value = 31
+	 * For 2-sided this equals the number of FTM frames
+	 * to be attempted in a single burst. This also
+	 * equals the number of FTM frames that the
+	 * initiator will request that the responder send
+	 * in a single frame. */
+	t_u8 num_frames_per_burst;
+	/** number of retries for a failed RTT frame. Applies
+	 * to 1-sided RTT only. Minimum value = 0, Maximum value = 3 */
+	t_u8 num_retries_per_rtt_frame;
+
+	/** following fields are only valid for 2-side RTT */
+	/** Maximum number of retries that the initiator can
+	 * retry an FTMR frame.
+	 * Minimum value = 0, Maximum value = 3 */
+	t_u8 num_retries_per_ftmr;
+	/** 1: request LCI, 0: do not request LCI */
+	t_u8 LCI_request;
+	/** 1: request LCR, 0: do not request LCR */
+	t_u8 LCR_request;
+	/** Applies to 1-sided and 2-sided RTT. Valid values will
+	 * be 2-11 and 15 as specified by the 802.11mc std for
+	 * the FTM parameter burst duration. In a multi-burst
+	 * request, if responder overrides with larger value,
+	 * the initiator will return failure. In a single-burst
+	 * request if responder overrides with larger value,
+	 * the initiator will sent TMR_STOP to terminate RTT
+	 * at the end of the burst_duration it requested. */
+	t_u8 burst_duration;
+	/** RTT preamble to be used in the RTT frames */
+	t_u8 preamble;
+	/** RTT BW to be used in the RTT frames */
+	t_u8 bw;
+} mlan_rtt_config, *pmlan_rtt_config;
+
+/** RTT config params */
+typedef struct _mlan_rtt_config_params {
+	t_u8 rtt_config_num;
+	mlan_rtt_config rtt_config[MAX_RTT_CONFIG_NUM];
+} mlan_rtt_config_params;
+
+/** RTT cancel params */
+typedef struct _mlan_rtt_cancel_params {
+	t_u8 rtt_cancel_num;
+	t_u8 rtt_cancel[MAX_RTT_CONFIG_NUM][MLAN_MAC_ADDR_LENGTH];
+} mlan_rtt_cancel_params;
+
+/** RTT responder info */
+typedef struct _rtt_responder_info {
+	t_u8 channel;
+	Band_Config_t bandcfg;
+	t_u8 preamble;
+} rtt_responder_info;
+
+/** RTT responder enable configure */
+typedef struct _rtt_responder_encfg {
+	t_u8 channel;
+	Band_Config_t bandcfg;
+	t_u32 max_dur_sec;
+} rtt_responder_encfg;
+
+/** Define for mlan_rtt_responder.action */
+#define RTT_GET_RESPONDER_INFO 0
+#define RTT_SET_RESPONDER_ENABLE 1
+#define RTT_SET_RESPONDER_DISABLE 2
+#define RTT_SET_RESPONDER_LCI 3
+#define RTT_SET_RESPONDER_LCR 4
+
+/** RTT responder configure for MLAN_OID_MISC_RTT_RESPONDER_CFG */
+typedef struct _mlan_rtt_responder {
+	t_u8 action;
+	union {
+		rtt_responder_info info;
+		rtt_responder_encfg encfg;
+		wifi_lci_information lci;
+		wifi_lcr_information lcr;
+	} u;
+} mlan_rtt_responder;
+
 #if defined(PCIE)
 typedef struct _mlan_ds_ssu_params {
 	t_u32 nskip;
@@ -4819,6 +5612,41 @@ typedef struct _mlan_ds_ssu_params {
 } mlan_ds_ssu_params;
 #endif
 
+#define CSI_FILTER_MAX 16
+/** Structure of CSI filters */
+typedef MLAN_PACK_START struct _mlan_csi_filter_t {
+	/** Source address of the packet to receive */
+	t_u8 mac_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Pakcet type of the interested CSI */
+	t_u8 pkt_type;
+	/* Packet subtype of the interested CSI */
+	t_u8 subtype;
+	/* Other filter flags */
+	t_u8 flags;
+} MLAN_PACK_END mlan_csi_filter_t;
+/** Structure of CSI parameters */
+typedef MLAN_PACK_START struct _mlan_ds_csi_params {
+	/** CSI enable flag. 1: enable, 0: disable */
+	t_u16 csi_enable;
+	/** Header ID*/
+	t_u32 head_id;
+	/** Tail ID */
+	t_u32 tail_id;
+	/** Number of CSI filters */
+	t_u8 csi_filter_cnt;
+	/** Chip ID */
+	t_u8 chip_id;
+	/** CSI filters */
+	mlan_csi_filter_t csi_filter[CSI_FILTER_MAX];
+} MLAN_PACK_END mlan_ds_csi_params;
+
+typedef MLAN_PACK_START struct _mlan_ds_hal_phy_cfg_params {
+	/** 11b pwr spectral density mask enable/disable */
+	t_u8 dot11b_psd_mask_cfg;
+	/** reserved fields for future hal/phy cfg use */
+	t_u8 reserved[7];
+} MLAN_PACK_END mlan_ds_hal_phy_cfg_params;
+
 #define MAX_NUM_MAC 2
 /** Type definition of mlan_ds_misc_mapping_policy */
 typedef struct _mlan_ds_misc_mapping_policy {
@@ -4878,6 +5706,9 @@ typedef struct _mlan_ds_misc_chan_trpc_cfg {
 #define MFG_CMD_RFPWR 0x1033
 #define MFG_CMD_RF_BAND_AG 0x1034
 #define MFG_CMD_RF_CHANNELBW 0x1044
+#define MFG_CMD_RADIO_MODE_CFG 0x1211
+#define MFG_CMD_CONFIG_MAC_HE_TB_TX 0x110A
+#define MFG_CMD_CONFIG_TRIGGER_FRAME 0x110C
 /** MFG CMD generic cfg */
 struct MLAN_PACK_START mfg_cmd_generic_cfg {
 	/** MFG command code */
@@ -4936,6 +5767,21 @@ struct MLAN_PACK_START mfg_cmd_tx_frame2 {
 	t_u32 stbc;
 	/** power id */
 	t_u32 rsvd[2];
+	/** NumPkt */
+	t_u32 NumPkt;
+	/** MaxPE */
+	t_u32 MaxPE;
+	/** BeamChange */
+	t_u32 BeamChange;
+	/** Dcm */
+	t_u32 Dcm;
+	/** Doppler */
+	t_u32 Doppler;
+	/** MidP */
+	t_u32 MidP;
+	/** QNum */
+	t_u32 QNum;
+
 } MLAN_PACK_END;
 
 /* MFG CMD Tx Continuous */
@@ -4964,6 +5810,199 @@ struct MLAN_PACK_START mfg_cmd_tx_cont {
 	t_u32 rsvd;
 } MLAN_PACK_END;
 
+struct MLAN_PACK_START mfg_Cmd_HE_TBTx_t {
+	/** MFG command code */
+	t_u32 mfg_cmd;
+	/** Action */
+	t_u16 action;
+	/** Device ID */
+	t_u16 device_id;
+	/** MFG Error code */
+	t_u32 error;
+	/** Enable Tx */
+	t_u16 enable;
+	/** Q num */
+	t_u16 qnum;
+	/** AID */
+	t_u16 aid;
+	/** AXQ Mu Timer */
+	t_u16 axq_mu_timer;
+	/** Tx Power */
+	t_s16 tx_power;
+} MLAN_PACK_END;
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigComInfo_t {
+	t_u64 reserved : 1;
+	t_u64 he_sig2 : 9;
+	t_u64 doppler : 1;
+	t_u64 spatial_reuse : 16;
+	t_u64 pe_disambig : 1;
+	t_u64 pre_fec_pad_fct : 2;
+	t_u64 ap_tx_pwr : 6;
+
+	t_u64 ldpc_ess : 1;
+	t_u64 ul_stbc : 1;
+	t_u64 ltf_symbol : 3;
+	t_u64 ltf_mode : 1;
+	t_u64 ltf_type : 2;
+
+	t_u64 ul_bw : 2;
+	t_u64 cs_required : 1;
+	t_u64 more_tf : 1;
+	t_u64 ul_len : 12;
+	t_u64 trigger_type : 4;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigComInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigComInfo_t {
+	t_u64 trigger_type : 4;
+	t_u64 ul_len : 12;
+	t_u64 more_tf : 1;
+	t_u64 cs_required : 1;
+	t_u64 ul_bw : 2;
+
+	t_u64 ltf_type : 2;
+	t_u64 ltf_mode : 1;
+	t_u64 ltf_symbol : 3;
+	t_u64 ul_stbc : 1;
+	t_u64 ldpc_ess : 1;
+
+	t_u64 ap_tx_pwr : 6;
+	t_u64 pre_fec_pad_fct : 2;
+	t_u64 pe_disambig : 1;
+	t_u64 spatial_reuse : 16;
+	t_u64 doppler : 1;
+	t_u64 he_sig2 : 9;
+	t_u64 reserved : 1;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigComInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigUserInfo_t {
+	t_u8 reserved : 1;
+	t_u8 ul_target_rssi : 7;
+	t_u32 ss_alloc : 6;
+	t_u32 ul_dcm : 1;
+	t_u32 ul_mcs : 4;
+	t_u32 ul_coding_type : 1;
+	t_u32 ru_alloc : 7;
+	t_u32 ru_alloc_reg : 1;
+	t_u32 aid12 : 12;
+
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigUserInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_HETrigUserInfo_t {
+	t_u32 aid12 : 12;
+	t_u32 ru_alloc_reg : 1;
+	t_u32 ru_alloc : 7;
+	t_u32 ul_coding_type : 1;
+	t_u32 ul_mcs : 4;
+	t_u32 ul_dcm : 1;
+	t_u32 ss_alloc : 6;
+	t_u8 ul_target_rssi : 7;
+	t_u8 reserved : 1;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_HETrigUserInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEETypes_BasicHETrigUserInfo_t {
+	t_u8 pref_ac : 2;
+	t_u8 ac_pl : 1;
+	t_u8 tid_al : 3;
+	t_u8 mpdu_mu_sf : 2;
+} MLAN_PACK_END mfg_cmd_IEEETypes_BasicHETrigUserInfo_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEETypes_BasicHETrigUserInfo_t {
+	t_u8 mpdu_mu_sf : 2;
+	t_u8 tid_al : 3;
+	t_u8 ac_pl : 1;
+	t_u8 pref_ac : 2;
+} MLAN_PACK_END mfg_cmd_IEEETypes_BasicHETrigUserInfo_t;
+#endif
+
+#ifdef BIG_ENDIAN_SUPPORT
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_FrameCtrl_t {
+	/** Order */
+	t_u8 order : 1;
+	/** Wep */
+	t_u8 wep : 1;
+	/** More Data */
+	t_u8 more_data : 1;
+	/** Power Mgmt */
+	t_u8 pwr_mgmt : 1;
+	/** Retry */
+	t_u8 retry : 1;
+	/** More Frag */
+	t_u8 more_frag : 1;
+	/** From DS */
+	t_u8 from_ds : 1;
+	/** To DS */
+	t_u8 to_ds : 1;
+	/** Sub Type */
+	t_u8 sub_type : 4;
+	/** Type */
+	t_u8 type : 2;
+	/** Protocol Version */
+	t_u8 protocol_version : 2;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_FrameCtrl_t;
+#else
+typedef MLAN_PACK_START struct _mfg_cmd_IEEEtypes_FrameCtrl_t {
+	/** Protocol Version */
+	t_u8 protocol_version : 2;
+	/** Type */
+	t_u8 type : 2;
+	/** Sub Type */
+	t_u8 sub_type : 4;
+	/** To DS */
+	t_u8 to_ds : 1;
+	/** From DS */
+	t_u8 from_ds : 1;
+	/** More Frag */
+	t_u8 more_frag : 1;
+	/** Retry */
+	t_u8 retry : 1;
+	/** Power Mgmt */
+	t_u8 pwr_mgmt : 1;
+	/** More Data */
+	t_u8 more_data : 1;
+	/** Wep */
+	t_u8 wep : 1;
+	/** Order */
+	t_u8 order : 1;
+} MLAN_PACK_END mfg_cmd_IEEEtypes_FrameCtrl_t;
+#endif
+
+typedef MLAN_PACK_START struct _mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t {
+	/** MFG command code */
+	t_u32 mfg_cmd;
+	/** Action */
+	t_u16 action;
+	/** Device ID */
+	t_u16 device_id;
+	/** MFG Error code */
+	t_u32 error;
+	/** enable Tx*/
+	t_u32 enable_tx;
+	/** enable Stand Alone HE TB */
+	t_u32 standalone_hetb;
+	/** Frame Control */
+	mfg_cmd_IEEEtypes_FrameCtrl_t frmCtl;
+	/** Duration */
+	t_u16 duration;
+	/** Destination MAC Address */
+	t_u8 dest_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Source MAC Address */
+	t_u8 src_addr[MLAN_MAC_ADDR_LENGTH];
+	/** Common Info Field **/
+	mfg_cmd_IEEEtypes_HETrigComInfo_t trig_common_field;
+	/** User Info Field **/
+	mfg_cmd_IEEEtypes_HETrigUserInfo_t trig_user_info_field;
+	/** Trigger Dependent User Info Field **/
+	mfg_cmd_IEEETypes_BasicHETrigUserInfo_t basic_trig_user_info;
+} MLAN_PACK_END mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t;
+
 typedef struct _mlan_ds_misc_chnrgpwr_cfg {
 	/** length */
 	t_u16 length;
@@ -4981,6 +6020,61 @@ typedef struct _mlan_ds_misc_cfp_tbl {
 	chan_freq_power_t cfp_tbl[];
 } mlan_ds_misc_cfp_tbl;
 
+/** mlan_ds_mc_aggr_cfg for MLAN_OID_MISC_MC_AGGR_CFG */
+typedef struct _mlan_ds_mc_aggr_cfg {
+	/** action */
+	t_u8 action;
+	/* 1 enable, 0 disable
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 enable_bitmap;
+	/* 1 valid, 0 invalid
+	 * bit 0 MC aggregation
+	 * bit 1 packet expiry
+	 * bit 2 CTS2Self
+	 * bit 3 CTS2Self duration offset*/
+	t_u8 mask_bitmap;
+	/** CTS2Self duration offset */
+	t_u16 cts2self_offset;
+} mlan_ds_mc_aggr_cfg;
+
+/** mlan_ds_stats */
+typedef struct _mlan_ds_stats {
+	/** action */
+	t_u16 action;
+	/** tlv len */
+	t_u16 tlv_len;
+	/** TLV buffer */
+	t_u8 tlv_buf[1];
+} mlan_ds_stats;
+
+typedef struct _mlan_ds_ch_load {
+	/** action */
+	t_u8 action;
+	t_u16 ch_load_param;
+	t_s16 noise;
+	t_u16 rx_quality;
+	t_u16 duration;
+} mlan_ds_ch_load;
+
+/** Type definition of mlan_ds_cross_chip_synch */
+typedef struct _mlan_ds_cross_chip_synch {
+	/**cross chip sync action 0-GET, 1-SET */
+	t_u16 action;
+	/**cross chip sync start or stop */
+	t_u8 start_stop;
+	/**cross chip sync role, master or slave */
+	t_u8 role;
+	/**cross chip sync periodicty of toggle in us */
+	t_u32 period;
+	/**cross chip sync initial TSF low */
+	t_u32 init_tsf_low;
+	/**cross chip sync intial TSF high */
+	t_u32 init_tsf_high;
+} mlan_ds_cross_chip_synch;
+
 /** Type definition of mlan_ds_misc_cfg for MLAN_IOCTL_MISC_CFG */
 typedef struct _mlan_ds_misc_cfg {
 	/** Sub-command */
@@ -5003,16 +6097,31 @@ typedef struct _mlan_ds_misc_cfg {
 		t_u32 wws_cfg;
 		/** Get associate response for MLAN_OID_MISC_ASSOC_RSP */
 		mlan_ds_misc_assoc_rsp assoc_resp;
+		/** Get associate request for MLAN_OID_MISC_ASSOC_REQ */
+		mlan_ds_misc_assoc_req assoc_req;
 		/** Function init/shutdown for MLAN_OID_MISC_INIT_SHUTDOWN */
 		t_u32 func_init_shutdown;
 		/** Custom IE for MLAN_OID_MISC_CUSTOM_IE */
 		mlan_ds_misc_custom_ie cust_ie;
+		t_u16 tdls_idle_time;
 		/** Config dynamic bandwidth*/
 		t_u16 dyn_bw;
+		/** TDLS configuration for MLAN_OID_MISC_TDLS_CONFIG */
+		mlan_ds_misc_tdls_config tdls_config;
+		/** TDLS operation for MLAN_OID_MISC_TDLS_OPER */
+		mlan_ds_misc_tdls_oper tdls_oper;
+		/** TDLS ies for  MLAN_OID_MISC_GET_TDLS_IES */
+		mlan_ds_misc_tdls_ies tdls_ies;
+		/**tdls cs off channel*/
+		t_u8 tdls_cs_channel;
+		/** Net monitor for MLAN_OID_MISC_NET_MONITOR */
+		mlan_ds_misc_net_monitor net_mon;
 		/** Tx data pause for MLAN_OID_MISC_TX_DATAPAUSE */
 		mlan_ds_misc_tx_datapause tx_datapause;
 		/** IP address configuration */
 		mlan_ds_misc_ipaddr_cfg ipaddr_cfg;
+		/** IPv6 Router Advertisement offload configuration */
+		mlan_ds_misc_ipv6_ra_offload ipv6_ra_offload;
 		/** MAC control for MLAN_OID_MISC_MAC_CONTROL */
 		t_u32 mac_ctrl;
 		/** MEF configuration for MLAN_OID_MISC_MEF_CFG */
@@ -5033,10 +6142,14 @@ typedef struct _mlan_ds_misc_cfg {
 #endif
 		/** Hotspot config param set */
 		t_u32 hotspot_cfg;
+		/** Multi AP flag */
+		t_u8 multi_ap_flag;
 #ifdef STA_SUPPORT
 		ExtCap_t ext_cap;
 #endif
 		mlan_ds_misc_otp_user_data otp_user_data;
+		/** fw re-connect cfg param set */
+		mlan_ds_fw_reconnect fw_auto_reconnect;
 #ifdef USB
 		/** USB aggregation parameters for MLAN_OID_MISC_USB_AGGR_CTRL
 		 */
@@ -5048,17 +6161,23 @@ typedef struct _mlan_ds_misc_cfg {
 #if defined(STA_SUPPORT)
 		mlan_ds_misc_pmfcfg pmfcfg;
 #endif
+		/** Multi-channel config for MLAN_OID_MISC_MULTI_CHAN_CFG */
+		mlan_ds_multi_chan_cfg multi_chan_cfg;
+		/** Multi-channel policy for MLAN_OID_MISC_MULTI_CHAN_POLICY */
+		t_u16 multi_chan_policy;
+		/** channel drcs time slicing config for MLAN_OID_MISC_DRCS_CFG
+		 */
+		mlan_ds_drcs_cfg drcs_cfg[2];
 #ifdef WIFI_DIRECT_SUPPORT
 		mlan_ds_wifi_direct_config p2p_config;
 #endif
+		mlan_ds_gpio_tsf_latch gpio_tsf_latch_config;
+		mlan_ds_tsf_info tsf_info;
 		mlan_ds_coalesce_cfg coalesce_cfg;
 		t_u8 low_pwr_mode;
 		/** MEF-FLT-CONFIG for MLAN_OID_MISC_NV_FLT_CFG */
 		mlan_ds_misc_mef_flt_cfg mef_flt_cfg;
 		mlan_ds_misc_dfs_repeater dfs_repeater;
-#ifdef RX_PACKET_COALESCE
-		mlan_ds_misc_rx_packet_coalesce rx_coalesce;
-#endif
 		/** FW reload flag */
 		t_u8 fw_reload;
 		mlan_ds_sensor_temp sensor_temp;
@@ -5066,23 +6185,34 @@ typedef struct _mlan_ds_misc_cfg {
 		mlan_ds_misc_gtk_rekey_data gtk_rekey;
 		mlan_ds_bw_chan_oper bw_chan_oper;
 		mlan_ds_ind_rst_cfg ind_rst_cfg;
+		/** Roam offload */
+		mlan_ds_misc_roam_offload roam_offload;
 		t_u64 misc_tsf;
 		mlan_ds_custom_reg_domain custom_reg_domain;
 		mlan_ds_misc_keep_alive keep_alive;
+		mlan_ds_misc_keep_alive_rx keep_alive_rx;
 		mlan_ds_misc_tx_rx_histogram tx_rx_histogram;
 		mlan_ds_cw_mode_ctrl cwmode;
 		/**  Tx/Rx per-packet control */
 		t_u8 txrx_pkt_ctrl;
 		mlan_ds_misc_robustcoex_params robustcoexparams;
+		/** config RTT for MLAN_OID_MISC_CONFIG_RTT */
+		mlan_rtt_config_params rtt_params;
+		/** cancel RTT for MLAN_OID_MISC_CANCEL_RTT */
+		mlan_rtt_cancel_params rtt_cancel;
+		/** config RTT responder for MLAN_OID_MISC_RTT_RESPONDER_CFG */
+		mlan_rtt_responder rtt_rsp_cfg;
 #if defined(PCIE)
 		mlan_ds_ssu_params ssu_params;
 #endif
+		mlan_ds_csi_params csi_params;
 		/** boot sleep enable or disable */
 		t_u16 boot_sleep;
 		/** Mapping Policy */
 		mlan_ds_misc_mapping_policy dmcs_policy;
 		mlan_ds_misc_dmcs_status dmcs_status;
 		mlan_ds_misc_rx_abort_cfg rx_abort_cfg;
+		mlan_ds_misc_ofdm_desense_cfg ofdm_desense_cfg;
 		mlan_ds_misc_rx_abort_cfg_ext rx_abort_cfg_ext;
 		mlan_ds_misc_tx_ampdu_prot_mode tx_ampdu_prot_mode;
 		mlan_ds_misc_rate_adapt_cfg rate_adapt_cfg;
@@ -5095,10 +6225,23 @@ typedef struct _mlan_ds_misc_cfg {
 		struct mfg_cmd_generic_cfg mfg_generic_cfg;
 		struct mfg_cmd_tx_cont mfg_tx_cont;
 		struct mfg_cmd_tx_frame2 mfg_tx_frame2;
+		struct mfg_Cmd_HE_TBTx_t mfg_he_power;
+		mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t mfg_tx_trigger_config;
 		mlan_ds_misc_arb_cfg arb_cfg;
 		mlan_ds_misc_cfp_tbl cfp;
 		t_u8 range_ext_mode;
+		mlan_ds_twt_report twt_report_info;
 		mlan_ds_misc_dot11mc_unassoc_ftm_cfg dot11mc_unassoc_ftm_cfg;
+		mlan_ds_misc_tp_state tp_state;
+		mlan_ds_hal_phy_cfg_params hal_phy_cfg_params;
+		mlan_ds_mc_aggr_cfg mc_aggr_cfg;
+		mlan_ds_stats stats;
+#ifdef UAP_SUPPORT
+		t_u8 wacp_mode;
+#endif
+		t_u32 ips_ctrl;
+		mlan_ds_ch_load ch_load;
+		mlan_ds_cross_chip_synch cross_chip_synch;
 	} param;
 } mlan_ds_misc_cfg, *pmlan_ds_misc_cfg;
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.c
old mode 100644
new mode 100755
index abcf6149b..e6b119847
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.c
@@ -3,7 +3,7 @@
  * @brief This file contains the functions for CFG80211.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2023 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -127,6 +127,9 @@ static struct ieee80211_channel cfg80211_channels_5ghz[] = {
 	{.center_freq = 5785, .hw_value = 157, .max_power = 20},
 	{.center_freq = 5805, .hw_value = 161, .max_power = 20},
 	{.center_freq = 5825, .hw_value = 165, .max_power = 20},
+	{.center_freq = 5845, .hw_value = 169, .max_power = 20},
+	{.center_freq = 5865, .hw_value = 173, .max_power = 20},
+	{.center_freq = 5885, .hw_value = 177, .max_power = 20},
 };
 
 struct ieee80211_supported_band cfg80211_band_2ghz = {
@@ -145,50 +148,7 @@ struct ieee80211_supported_band cfg80211_band_5ghz = {
 	.n_bitrates = ARRAY_SIZE(cfg80211_rates) - 4,
 };
 
-/** Channel definitions for 5 GHz to be advertised to cfg80211 */
-static struct ieee80211_channel mac1_cfg80211_channels_5ghz[] = {
-	{.center_freq = 5180, .hw_value = 36, .max_power = 20},
-	{.center_freq = 5200, .hw_value = 40, .max_power = 20},
-	{.center_freq = 5220, .hw_value = 44, .max_power = 20},
-	{.center_freq = 5240, .hw_value = 48, .max_power = 20},
-	{.center_freq = 5260, .hw_value = 52, .max_power = 20},
-	{.center_freq = 5280, .hw_value = 56, .max_power = 20},
-	{.center_freq = 5300, .hw_value = 60, .max_power = 20},
-	{.center_freq = 5320, .hw_value = 64, .max_power = 20},
-	{.center_freq = 5500, .hw_value = 100, .max_power = 20},
-	{.center_freq = 5520, .hw_value = 104, .max_power = 20},
-	{.center_freq = 5540, .hw_value = 108, .max_power = 20},
-	{.center_freq = 5560, .hw_value = 112, .max_power = 20},
-	{.center_freq = 5580, .hw_value = 116, .max_power = 20},
-	{.center_freq = 5600, .hw_value = 120, .max_power = 20},
-	{.center_freq = 5620, .hw_value = 124, .max_power = 20},
-	{.center_freq = 5640, .hw_value = 128, .max_power = 20},
-	{.center_freq = 5660, .hw_value = 132, .max_power = 20},
-	{.center_freq = 5680, .hw_value = 136, .max_power = 20},
-	{.center_freq = 5700, .hw_value = 140, .max_power = 20},
-	{.center_freq = 5720, .hw_value = 144, .max_power = 20},
-	{.center_freq = 5745, .hw_value = 149, .max_power = 20},
-	{.center_freq = 5765, .hw_value = 153, .max_power = 20},
-	{.center_freq = 5785, .hw_value = 157, .max_power = 20},
-	{.center_freq = 5805, .hw_value = 161, .max_power = 20},
-	{.center_freq = 5825, .hw_value = 165, .max_power = 20},
-};
-
-struct ieee80211_supported_band mac1_cfg80211_band_2ghz = {
-	.channels = cfg80211_channels_2ghz,
-	.band = IEEE80211_BAND_2GHZ,
-	.n_channels = ARRAY_SIZE(cfg80211_channels_2ghz),
-	.bitrates = cfg80211_rates,
-	.n_bitrates = ARRAY_SIZE(cfg80211_rates),
-};
-
-struct ieee80211_supported_band mac1_cfg80211_band_5ghz = {
-	.channels = mac1_cfg80211_channels_5ghz,
-	.band = IEEE80211_BAND_5GHZ,
-	.n_channels = ARRAY_SIZE(mac1_cfg80211_channels_5ghz),
-	.bitrates = cfg80211_rates + 4,
-	.n_bitrates = ARRAY_SIZE(cfg80211_rates) - 4,
-};
+extern pmoal_handle m_handle[];
 
 #if KERNEL_VERSION(2, 6, 29) < LINUX_VERSION_CODE
 #ifdef UAP_SUPPORT
@@ -207,6 +167,12 @@ extern const struct net_device_ops woal_netdev_ops;
 /********************************************************
  *				Global Functions
  ********************************************************/
+#ifdef UAP_SUPPORT
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg,
+		  t_u8 wait_option);
+#endif
+#endif
 
 /**
  * @brief Get the private structure from wiphy
@@ -232,6 +198,27 @@ void *woal_get_netdev_priv(struct net_device *dev)
 	return (void *)netdev_priv(dev);
 }
 
+/**
+ *  @brief get ieee80211_channel
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param pchan_info   A pointer to chan_band_info structure
+ *
+ *  @return           radio_type
+ */
+struct ieee80211_channel *woal_get_ieee80211_channel(moal_private *priv,
+						     chan_band_info *pchan_info)
+{
+	enum ieee80211_band band = IEEE80211_BAND_2GHZ;
+	int freq = 0;
+	if (pchan_info->bandcfg.chanBand == BAND_2GHZ)
+		band = IEEE80211_BAND_2GHZ;
+	else if (pchan_info->bandcfg.chanBand == BAND_5GHZ)
+		band = IEEE80211_BAND_5GHZ;
+	freq = ieee80211_channel_to_frequency(pchan_info->channel, band);
+	return ieee80211_get_channel(priv->wdev->wiphy, freq);
+}
+
 /**
  *  @brief Get current frequency of active interface
  *
@@ -241,53 +228,55 @@ void *woal_get_netdev_priv(struct net_device *dev)
  */
 int woal_get_active_intf_freq(moal_private *priv)
 {
+#ifdef WIFI_DIRECT_SUPPORT
+#if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
+	moal_private *pmpriv = NULL;
 	moal_handle *handle = priv->phandle;
 	int i;
+#endif
+#endif
 
-	if (priv->media_connected == MTRUE
 #ifdef UAP_SUPPORT
-	    || priv->bss_started == MTRUE
+	if (priv->bss_role == MLAN_BSS_ROLE_UAP && priv->bss_started &&
+	    priv->uap_host_based) {
+#if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
+		return priv->chan.chan->center_freq;
 #endif
-	)
-		return ieee80211_channel_to_frequency(
-			priv->channel
-#if KERNEL_VERSION(2, 6, 39) <= CFG80211_VERSION_CODE
-			,
-			(priv->channel <= 14 ? IEEE80211_BAND_2GHZ :
-					       IEEE80211_BAND_5GHZ)
+	}
 #endif
-		);
-
-	for (i = 0; i < handle->priv_num; i++) {
 #ifdef STA_SUPPORT
-		if (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_STA) {
-			if (handle->priv[i]->media_connected == MTRUE)
-				return ieee80211_channel_to_frequency(
-					handle->priv[i]->channel
-#if KERNEL_VERSION(2, 6, 39) <= CFG80211_VERSION_CODE
-					,
-					(handle->priv[i]->channel <= 14 ?
-						 IEEE80211_BAND_2GHZ :
-						 IEEE80211_BAND_5GHZ)
-#endif
-				);
-		}
+	if (priv->bss_role == MLAN_BSS_ROLE_STA &&
+	    priv->media_connected == MTRUE && priv->sme_current.ssid_len) {
+		return priv->conn_chan.center_freq;
+	}
 #endif
-#ifdef UAP_SUPPORT
-		if (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_UAP) {
-			if (handle->priv[i]->bss_started == MTRUE)
-				return ieee80211_channel_to_frequency(
-					handle->priv[i]->channel
-#if KERNEL_VERSION(2, 6, 39) <= CFG80211_VERSION_CODE
-					,
-					(handle->priv[i]->channel <= 14 ?
-						 IEEE80211_BAND_2GHZ :
-						 IEEE80211_BAND_5GHZ)
+
+#ifdef WIFI_DIRECT_SUPPORT
+#if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
+	if (priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT) {
+		for (i = 0; i < handle->priv_num; i++) {
+			if (handle->priv[i] &&
+			    handle->priv[i]->bss_type ==
+				    MLAN_BSS_TYPE_WIFIDIRECT) {
+				pmpriv = handle->priv[i];
+				if (pmpriv->bss_role == MLAN_BSS_ROLE_STA &&
+				    pmpriv->media_connected == MTRUE &&
+				    pmpriv->sme_current.ssid_len) {
+					return pmpriv->conn_chan.center_freq;
+				}
+				if (pmpriv->bss_role == MLAN_BSS_ROLE_UAP &&
+				    pmpriv->bss_started &&
+				    pmpriv->uap_host_based) {
+#if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
+					return pmpriv->chan.chan->center_freq;
 #endif
-				);
+				}
+			}
 		}
-#endif
 	}
+#endif
+#endif
+
 	return 0;
 }
 
@@ -325,6 +314,32 @@ t_u8 woal_band_cfg_to_ieee_band(t_u32 band)
 	return ret_radio_type;
 }
 
+/**
+ *  @brief Convert IEEE band type to radio_type
+ *
+ *  @param ieeeband     IEEE band
+ *
+ *  @return           radio_type
+ */
+t_u8 woal_ieee_band_to_radio_type(t_u8 ieee_band)
+{
+	t_u8 radio_type = 0;
+
+	ENTER();
+
+	switch (ieee_band) {
+	case IEEE80211_BAND_5GHZ:
+		radio_type = BAND_5GHZ;
+		break;
+	case IEEE80211_BAND_2GHZ:
+	default:
+		radio_type = BAND_2GHZ;
+		break;
+	}
+	LEAVE();
+	return radio_type;
+}
+
 /**
  *  @brief Set/Enable encryption key
  *
@@ -412,6 +427,7 @@ mlan_status woal_cfg80211_set_key(moal_private *priv, t_u8 is_enable_wep,
 		    cipher != WLAN_CIPHER_SUITE_GCMP &&
 #endif
 #if KERNEL_VERSION(4, 0, 0) <= CFG80211_VERSION_CODE
+		    cipher != WLAN_CIPHER_SUITE_BIP_GMAC_128 &&
 		    cipher != WLAN_CIPHER_SUITE_BIP_GMAC_256 &&
 		    cipher != WLAN_CIPHER_SUITE_GCMP_256 &&
 #endif
@@ -480,11 +496,21 @@ mlan_status woal_cfg80211_set_key(moal_private *priv, t_u8 is_enable_wep,
 
 		if (cipher == WLAN_CIPHER_SUITE_AES_CMAC
 #if KERNEL_VERSION(4, 0, 0) <= CFG80211_VERSION_CODE
-		    || cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256
+		    || cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||
+		    cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256
 #endif
 		) {
 			sec->param.encrypt_key.key_flags |=
 				KEY_FLAG_AES_MCAST_IGTK;
+
+#if KERNEL_VERSION(4, 0, 0) <= CFG80211_VERSION_CODE
+			if (cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128)
+				sec->param.encrypt_key.key_flags |=
+					KEY_FLAG_GMAC_128;
+			else if (cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256)
+				sec->param.encrypt_key.key_flags |=
+					KEY_FLAG_GMAC_256;
+#endif
 		}
 	} else {
 		if (key_index == KEY_INDEX_CLEAR_ALL)
@@ -541,9 +567,11 @@ mlan_status woal_cfg80211_set_wep_keys(moal_private *priv, const t_u8 *key,
 		/* No key provided so it is enable key. We
 		 * want to just set the transmit key index
 		 */
-		woal_cfg80211_set_key(priv, 1, cipher, key, key_len, NULL, 0,
-				      index, NULL, 0, wait_option);
+		ret = woal_cfg80211_set_key(priv, 1, cipher, key, key_len, NULL,
+					    0, index, NULL, 0, wait_option);
 	}
+	if (ret != MLAN_STATUS_SUCCESS)
+		PRINTM(MERROR, "woal_cfg80211_set_wep_keys Fail\n");
 
 	LEAVE();
 	return ret;
@@ -562,17 +590,21 @@ void woal_clear_all_mgmt_ies(moal_private *priv, t_u8 wait_option)
 	/* clear BEACON WPS/P2P IE */
 	if (priv->beacon_wps_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK) {
 		PRINTM(MCMND, "Clear BEACON WPS ie\n");
-		woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0, NULL, 0,
-					    NULL, 0, MGMT_MASK_BEACON_WPS_P2P,
-					    wait_option);
+		if (woal_cfg80211_mgmt_frame_ie(
+			    priv, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+			    MGMT_MASK_BEACON_WPS_P2P, wait_option))
+			PRINTM(MERROR, "%s: clear beacon wps ie failed \n",
+			       __func__);
 		priv->beacon_wps_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
 	}
 	if (priv->assocresp_qos_map_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK) {
 		PRINTM(MCMND, "Clear associate response QOS map ie\n");
-		woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0, NULL, 0,
-					    NULL, 0,
-					    MGMT_MASK_ASSOC_RESP_QOS_MAP,
-					    wait_option);
+		if (woal_cfg80211_mgmt_frame_ie(
+			    priv, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+			    MGMT_MASK_ASSOC_RESP_QOS_MAP, wait_option))
+			PRINTM(MERROR,
+			       "%s: Clear associate response QOS map ie failed \n",
+			       __func__);
 		priv->assocresp_qos_map_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
 	}
 	/* clear mgmt frame ies */
@@ -593,8 +625,10 @@ void woal_clear_all_mgmt_ies(moal_private *priv, t_u8 wait_option)
 		       priv->beacon_index, priv->probereq_index,
 		       priv->proberesp_index, priv->assocresp_index,
 		       priv->proberesp_p2p_index, priv->beacon_vendor_index);
-		woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0, NULL, 0,
-					    NULL, 0, mask, wait_option);
+		if (woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0, NULL, 0,
+						NULL, 0, mask, wait_option))
+			PRINTM(MERROR, "%s: Clear ies failed, mask=0x%x\n",
+			       __func__, mask);
 	}
 	priv->probereq_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
 	priv->beacon_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
@@ -622,18 +656,29 @@ int woal_cfg80211_bss_role_cfg(moal_private *priv, t_u16 action, t_u8 *bss_role)
 
 	if (action == MLAN_ACT_SET) {
 		/* Reset interface */
-		woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE)) {
+			PRINTM(MERROR, "woal_reset_intf fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 	}
 
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_bss_role_cfg(priv, action, MOAL_IOCTL_WAIT, bss_role)) {
+		PRINTM(MERROR, "woal_bss_role_cfg fail\n");
 		ret = -EFAULT;
 		goto done;
 	}
 
 	if (action == MLAN_ACT_SET) {
 		/* set back the mac address */
-		woal_request_set_mac_address(priv, MOAL_IOCTL_WAIT);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_request_set_mac_address(priv, MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "woal_request_set_mac_address fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		/* clear the mgmt ies */
 		woal_clear_all_mgmt_ies(priv, MOAL_IOCTL_WAIT);
 		/* Initialize private structures */
@@ -884,11 +929,22 @@ int woal_cfg80211_init_p2p_go(moal_private *priv)
 		p2p_config.noa_duration = priv->phandle->noa_duration;
 		p2p_config.noa_interval = priv->phandle->noa_interval;
 		p2p_config.flags = WIFI_DIRECT_NOA;
-		woal_p2p_config(priv, MLAN_ACT_SET, &p2p_config);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_p2p_config(priv, MLAN_ACT_SET, &p2p_config)) {
+			PRINTM(MERROR, "woal_p2p_config fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
+
 		memset(&ps_mgmt, 0, sizeof(ps_mgmt));
 		ps_mgmt.flags = PS_FLAG_PS_MODE;
 		ps_mgmt.ps_mode = PS_MODE_INACTIVITY;
-		woal_set_get_uap_power_mode(priv, MLAN_ACT_SET, &ps_mgmt);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_uap_power_mode(priv, MLAN_ACT_SET, &ps_mgmt)) {
+			PRINTM(MERROR, "woal_set_get_uap_power_mode fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		PRINTM(MMSG, "Enable NOA: duration=%d, interval=%d\n",
 		       priv->phandle->noa_duration,
 		       priv->phandle->noa_interval);
@@ -983,7 +1039,12 @@ int woal_cfg80211_deinit_p2p(moal_private *priv)
 		memset(&ps_mgmt, 0, sizeof(ps_mgmt));
 		ps_mgmt.flags = PS_FLAG_PS_MODE;
 		ps_mgmt.ps_mode = PS_MODE_DISABLE;
-		woal_set_get_uap_power_mode(priv, MLAN_ACT_SET, &ps_mgmt);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_uap_power_mode(priv, MLAN_ACT_SET, &ps_mgmt)) {
+			PRINTM(MERROR, "woal_set_get_uap_power_mode fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		bss_role = MLAN_BSS_ROLE_STA;
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_cfg80211_bss_role_cfg(priv, MLAN_ACT_SET, &bss_role)) {
@@ -1005,6 +1066,44 @@ int woal_cfg80211_deinit_p2p(moal_private *priv)
 #endif /* KERNEL_VERSION */
 #endif /* WIFI_DIRECT_SUPPORT */
 
+#ifdef UAP_SUPPORT
+/**
+ * @brief Request to cancel CAC
+ *
+ * @param priv         A pointer to moal_private structure
+ *
+ * @return              N/A */
+void woal_cancel_cac(moal_private *priv)
+{
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+	if (priv->phandle->is_cac_timer_set &&
+	    priv->bss_index == priv->phandle->cac_bss_index) {
+		woal_cancel_timer(&priv->phandle->cac_timer);
+		priv->phandle->is_cac_timer_set = MFALSE;
+		/* Make sure Chan Report is cancelled */
+		if (woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR, "%s: cancel chan report failed \n",
+			       __func__);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		cfg80211_cac_event(priv->netdev, &priv->phandle->dfs_channel,
+				   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
+#else
+		cfg80211_cac_event(priv->netdev, NL80211_RADAR_CAC_ABORTED,
+				   GFP_KERNEL);
+#endif
+		memset(&priv->phandle->dfs_channel, 0,
+		       sizeof(struct cfg80211_chan_def));
+		priv->phandle->cac_bss_index = 0xff;
+	}
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD))
+		woal_cancel_cac_block(priv);
+#endif
+	return;
+}
+#endif
+
 /**
  * @brief Request the driver to change the interface type
  *
@@ -1035,15 +1134,56 @@ int woal_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 
 	ENTER();
 
+	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_MONITOR) {
+		ret = -EFAULT;
+		goto done;
+	}
+
 	if (priv->wdev->iftype == type) {
 		PRINTM(MINFO, "Already set to required type\n");
 		goto done;
 	}
 #ifdef UAP_SUPPORT
+	/* when AP mode switch to station mode, we use it to cancel pending CAC
+	 */
+	if (priv->wdev->iftype == NL80211_IFTYPE_AP &&
+	    type == NL80211_IFTYPE_STATION) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+		if (priv->phandle->is_cac_timer_set &&
+		    priv->bss_index == priv->phandle->cac_bss_index) {
+			woal_cancel_timer(&priv->phandle->cac_timer);
+			priv->phandle->is_cac_timer_set = MFALSE;
+			/* Make sure Chan Report is cancelled */
+			if (woal_11h_cancel_chan_report_ioctl(priv,
+							      MOAL_IOCTL_WAIT))
+				PRINTM(MERROR,
+				       "%s: cancel chan report failed \n",
+				       __func__);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			cfg80211_cac_event(priv->netdev,
+					   &priv->phandle->dfs_channel,
+					   NL80211_RADAR_CAC_ABORTED,
+					   GFP_KERNEL);
+#else
+			cfg80211_cac_event(priv->netdev,
+					   NL80211_RADAR_CAC_ABORTED,
+					   GFP_KERNEL);
+#endif
+			memset(&priv->phandle->dfs_channel, 0,
+			       sizeof(struct cfg80211_chan_def));
+			priv->phandle->cac_bss_index = 0xff;
+		}
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD))
+			woal_cancel_cac_block(priv);
+#endif
+	}
 	if ((priv->bss_type == MLAN_BSS_TYPE_UAP) && (priv->bss_index > 0)) {
+		PRINTM(MMSG,
+		       "%s: Skip change virtual intf type on uap: from %d to %d\n",
+		       dev->name, priv->wdev->iftype, type);
 		priv->wdev->iftype = type;
-		PRINTM(MMSG, "%s: Skip change virtual intf on uap: type=%d\n",
-		       dev->name, type);
 		goto done;
 	}
 #endif
@@ -1133,10 +1273,20 @@ int woal_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 #endif /* WIFI_DIRECT_SUPPORT */
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 		if (priv->bss_type == MLAN_BSS_TYPE_UAP) {
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			woal_cfg80211_del_beacon(wiphy, dev, 0);
+#else
 			woal_cfg80211_del_beacon(wiphy, dev);
+#endif
 			bss_role = MLAN_BSS_ROLE_STA;
-			woal_cfg80211_bss_role_cfg(priv, MLAN_ACT_SET,
-						   &bss_role);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_cfg80211_bss_role_cfg(priv, MLAN_ACT_SET,
+						       &bss_role)) {
+				PRINTM(MERROR,
+				       "%s: WLAN set bss role config failed. \n",
+				       __func__);
+			}
 			PRINTM(MIOCTL, "set bss role for STA\n");
 		}
 #endif
@@ -1192,10 +1342,13 @@ int woal_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 #endif
 			if (priv->probereq_index !=
 			    MLAN_CUSTOM_IE_AUTO_IDX_MASK)
-				woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL,
-							    0, NULL, 0, NULL, 0,
-							    MGMT_MASK_PROBE_REQ,
-							    MOAL_IOCTL_WAIT);
+				if (woal_cfg80211_mgmt_frame_ie(
+					    priv, NULL, 0, NULL, 0, NULL, 0,
+					    NULL, 0, MGMT_MASK_PROBE_REQ,
+					    MOAL_IOCTL_WAIT))
+					PRINTM(MERROR,
+					       "%s: Clear probe req ie failed\n",
+					       __func__);
 			bss_role = MLAN_BSS_ROLE_UAP;
 			woal_cfg80211_bss_role_cfg(priv, MLAN_ACT_SET,
 						   &bss_role);
@@ -1265,9 +1418,9 @@ int woal_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
 		LEAVE();
 		return -EFAULT;
 	}
-	if (rts_thr == MLAN_FRAG_RTS_DISABLED)
+	if (rts_thr == (int)MLAN_FRAG_RTS_DISABLED)
 		rts_thr = MLAN_RTS_MAX_VALUE;
-	if (frag_thr == MLAN_FRAG_RTS_DISABLED)
+	if (frag_thr == (int)MLAN_FRAG_RTS_DISABLED)
 		frag_thr = MLAN_FRAG_MAX_VALUE;
 
 #ifdef UAP_CFG80211
@@ -1360,6 +1513,9 @@ int woal_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
  */
 #endif
 int woal_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+			  int link_id,
+#endif
 			  t_u8 key_index,
 #if KERNEL_VERSION(2, 6, 36) < CFG80211_VERSION_CODE
 			  bool pairwise,
@@ -1373,6 +1529,10 @@ int woal_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
 		PRINTM(MINFO, "Skip set keys during ft connecting\n");
 		return -EFAULT;
 	}
+
+	/** cancel pending scan */
+	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
+
 	if (woal_cfg80211_set_key(priv, 0, params->cipher, params->key,
 				  params->key_len, params->seq, params->seq_len,
 				  key_index, mac_addr, 0, MOAL_IOCTL_WAIT)) {
@@ -1412,6 +1572,9 @@ int woal_cfg80211_add_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 #endif
 int woal_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+			  int link_id,
+#endif
 			  t_u8 key_index,
 #if KERNEL_VERSION(2, 6, 36) < CFG80211_VERSION_CODE
 			  bool pairwise,
@@ -1467,7 +1630,11 @@ int woal_cfg80211_del_key(struct wiphy *wiphy, struct net_device *netdev,
  */
 #endif
 int woal_cfg80211_set_default_key(struct wiphy *wiphy,
-				  struct net_device *netdev, t_u8 key_index
+				  struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+				  int link_id,
+#endif
+				  t_u8 key_index
 #if KERNEL_VERSION(2, 6, 37) < CFG80211_VERSION_CODE
 				  ,
 				  bool ucast, bool mcast
@@ -1481,7 +1648,11 @@ int woal_cfg80211_set_default_key(struct wiphy *wiphy,
 	ENTER();
 	memset(&bss_info, 0, sizeof(mlan_bss_info));
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+			PRINTM(MERROR, "%s: WLAN get bss info failed. \n",
+			       __func__);
+		}
 		if (!bss_info.wep_status) {
 			LEAVE();
 			return ret;
@@ -1499,6 +1670,9 @@ int woal_cfg80211_set_default_key(struct wiphy *wiphy,
 #if KERNEL_VERSION(2, 6, 30) <= CFG80211_VERSION_CODE
 int woal_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
 				       struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+				       int link_id,
+#endif
 				       t_u8 key_index)
 {
 	PRINTM(MINFO, "set default mgmt key, key index=%d\n", key_index);
@@ -1507,6 +1681,20 @@ int woal_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
 }
 #endif
 
+#if KERNEL_VERSION(5, 10, 0) <= CFG80211_VERSION_CODE
+int woal_cfg80211_set_default_beacon_key(struct wiphy *wiphy,
+					 struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+					 int link_id,
+#endif
+					 t_u8 key_index)
+{
+	PRINTM(MINFO, "set default beacon key, key index=%d\n", key_index);
+
+	return 0;
+}
+#endif
+
 #if KERNEL_VERSION(3, 1, 0) <= CFG80211_VERSION_CODE
 /**
  *  @brief  Set GTK rekey data to driver
@@ -1523,7 +1711,6 @@ mlan_status woal_set_rekey_data(moal_private *priv,
 {
 	mlan_ioctl_req *req;
 	mlan_ds_misc_cfg *misc_cfg;
-	int ret = 0;
 	mlan_status status;
 
 	ENTER();
@@ -1531,7 +1718,8 @@ mlan_status woal_set_rekey_data(moal_private *priv,
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 
 	if (req == NULL) {
-		ret = -ENOMEM;
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
 	} else {
 		misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
 		misc_cfg->sub_command = MLAN_OID_MISC_GTK_REKEY_OFFLOAD;
@@ -1545,14 +1733,12 @@ mlan_status woal_set_rekey_data(moal_private *priv,
 					sizeof(mlan_ds_misc_gtk_rekey_data));
 
 		status = woal_request_ioctl(priv, req, wait_option);
-		if (status != MLAN_STATUS_SUCCESS)
-			ret = -EFAULT;
 		if (status != MLAN_STATUS_PENDING)
 			kfree(req);
 	}
 
 	LEAVE();
-	return ret;
+	return status;
 }
 
 /**
@@ -1658,7 +1844,7 @@ int woal_flush_pmksa_list(moal_private *priv)
 
 	if (!priv || priv->bss_type != MLAN_BSS_TYPE_STA) {
 		PRINTM(MERROR, "Invalid interface structure\n");
-		return -1;
+		return -EFAULT;
 	}
 
 	spin_lock_irqsave(&priv->pmksa_list_lock, flags);
@@ -1980,8 +2166,8 @@ static int woal_fill_coalesce_rule_info(struct cfg80211_coalesce_rules *crule,
  *
  *  @return                 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_set_coalesce(moal_private *priv, t_u16 action,
-			      mlan_ds_coalesce_cfg *coalesce_cfg)
+static mlan_status woal_set_coalesce(moal_private *priv, t_u16 action,
+				     mlan_ds_coalesce_cfg *coalesce_cfg)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_misc_cfg *misc_cfg = NULL;
@@ -2085,6 +2271,10 @@ int woal_cfg80211_set_coalesce(struct wiphy *wiphy,
  * @return                0 -- success, otherwise fail
  */
 int woal_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *dev,
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+				   unsigned int link_id,
+#endif
 				   const u8 *peer,
 				   const struct cfg80211_bitrate_mask *mask)
 {
@@ -2301,7 +2491,6 @@ int woal_cfg80211_set_antenna(struct wiphy *wiphy, u32 tx_ant, u32 rx_ant)
  */
 void woal_mgmt_frame_register(moal_private *priv, u16 frame_type, bool reg)
 {
-	mlan_status status = MLAN_STATUS_SUCCESS;
 	t_u32 mgmt_subtype_mask = 0x0;
 	t_u32 last_mgmt_subtype_mask = priv->mgmt_subtype_mask;
 
@@ -2333,8 +2522,8 @@ void woal_mgmt_frame_register(moal_private *priv, u16 frame_type, bool reg)
 		 * Note that this callback may not sleep, and cannot run
 		 * concurrently with itself.
 		 */
-		status = woal_reg_rx_mgmt_ind(priv, MLAN_ACT_SET,
-					      &mgmt_subtype_mask, MOAL_NO_WAIT);
+		woal_reg_rx_mgmt_ind(priv, MLAN_ACT_SET, &mgmt_subtype_mask,
+				     MOAL_NO_WAIT);
 		priv->mgmt_subtype_mask = last_mgmt_subtype_mask;
 	}
 
@@ -2390,8 +2579,12 @@ void woal_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
 	     */
 	    && !moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
 		upd->interface_stypes &= ~BIT(IEEE80211_STYPE_AUTH >> 4);
-	woal_reg_rx_mgmt_ind(priv, MLAN_ACT_SET, &upd->interface_stypes,
-			     MOAL_NO_WAIT);
+
+	if (priv->mgmt_subtype_mask != upd->interface_stypes) {
+		priv->mgmt_subtype_mask = upd->interface_stypes;
+		woal_reg_rx_mgmt_ind(priv, MLAN_ACT_SET, &upd->interface_stypes,
+				     MOAL_NO_WAIT);
+	}
 #else
 	if (frame_type == IEEE80211_STYPE_AUTH
 #if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
@@ -2409,6 +2602,63 @@ void woal_cfg80211_mgmt_frame_register(struct wiphy *wiphy,
 	LEAVE();
 }
 
+#ifdef UAP_CFG80211
+#if KERNEL_VERSION(3, 12, 0) <= CFG80211_VERSION_CODE
+/*
+ * @brief  prepare and send WOAL_EVENT_CANCEL_CHANRPT
+ *
+ * @param priv           A pointer moal_private structure
+ *
+ * @return          N/A
+ */
+void woal_cancel_chanrpt_event(moal_private *priv)
+{
+	struct woal_event *evt;
+	unsigned long flags;
+	moal_handle *handle = priv->phandle;
+
+	evt = kzalloc(sizeof(struct woal_event), GFP_ATOMIC);
+	if (!evt) {
+		PRINTM(MERROR, "Fail to alloc memory for deauth event\n");
+		LEAVE();
+		return;
+	}
+	evt->priv = priv;
+	evt->type = WOAL_EVENT_CANCEL_CHANRPT;
+	INIT_LIST_HEAD(&evt->link);
+	spin_lock_irqsave(&handle->evt_lock, flags);
+	list_add_tail(&evt->link, &handle->evt_queue);
+	spin_unlock_irqrestore(&handle->evt_lock, flags);
+	queue_work(handle->evt_workqueue, &handle->evt_work);
+}
+#endif
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
+/*
+ * @brief  check if we need set remain_on_channel
+ *
+ * @param priv           A pointer moal_private structure
+ * @param wait           Duration to wait
+ *
+ * @return          MFALSE-no need set remain_on_channel
+ */
+t_u8 woal_check_mgmt_tx_channel(moal_private *priv,
+				struct ieee80211_channel *chan,
+				unsigned int wait)
+{
+	int freq;
+	if (priv->bss_type == MLAN_BSS_TYPE_UAP)
+		return MFALSE;
+	if (wait)
+		return MTRUE;
+	freq = woal_get_active_intf_freq(priv);
+	if (chan->center_freq == freq)
+		return MFALSE;
+	return MTRUE;
+}
+#endif
+
 #if KERNEL_VERSION(3, 2, 0) <= CFG80211_VERSION_CODE
 #if KERNEL_VERSION(3, 3, 0) <= CFG80211_VERSION_CODE
 #if KERNEL_VERSION(3, 6, 0) <= CFG80211_VERSION_CODE
@@ -2557,6 +2807,7 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 	pmlan_buffer pmbuf = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	t_u16 packet_len = 0;
+	t_u16 pkt_len = 0;
 	t_u8 addr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 	t_u32 pkt_type;
 	t_u32 tx_control;
@@ -2604,9 +2855,22 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 				break;
 			case IEEE80211_STYPE_DEAUTH:
 			case IEEE80211_STYPE_DISASSOC:
+#ifdef UAP_SUPPORT
+				if (!priv->bss_started) {
+					PRINTM(MCMND,
+					       "Drop deauth packet before AP started\n");
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+					if (!moal_extflg_isset(priv->phandle,
+							       EXT_DFS_OFFLOAD))
+#endif
+						woal_cancel_cac(priv);
+					goto done;
+				}
+#endif
 				PRINTM(MMSG,
 				       "wlan: HostMlme %s send deauth/disassoc\n",
 				       priv->netdev->name);
+
 				break;
 			case IEEE80211_STYPE_ASSOC_RESP:
 			case IEEE80211_STYPE_REASSOC_RESP:
@@ -2619,6 +2883,7 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 			}
 		}
 	}
+
 #if KERNEL_VERSION(2, 6, 39) <= CFG80211_VERSION_CODE
 	if ((ieee80211_is_action(((struct ieee80211_mgmt *)buf)->frame_control))
 #if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
@@ -2675,7 +2940,7 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 		woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
 #endif
 
-		if (chan) {
+		if (chan && woal_check_mgmt_tx_channel(priv, chan, wait)) {
 			duration = (wait > MGMT_TX_DEFAULT_WAIT_TIME) ?
 					   wait :
 					   MGMT_TX_DEFAULT_WAIT_TIME;
@@ -2746,7 +3011,11 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 #if KERNEL_VERSION(3, 8, 0) > LINUX_VERSION_CODE
 	*cookie = random32() | 1;
 #else
+#if KERNEL_VERSION(6, 1, 0) > LINUX_VERSION_CODE
 	*cookie = prandom_u32() | 1;
+#else
+	*cookie = get_random_u32() | 1;
+#endif
 #endif
 	pmbuf->data_offset = MLAN_MIN_DATA_HEADER_LEN;
 	pkt_type = MRVL_PKT_TYPE_MGMT_FRAME;
@@ -2762,9 +3031,10 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 	remain_len -= sizeof(tx_control);
 	/* frmctl + durationid + addr1 + addr2 + addr3 + seqctl */
 #define PACKET_ADDR4_POS (2 + 2 + 6 + 6 + 6 + 2)
+	pkt_len = woal_cpu_to_le16(packet_len);
 	moal_memcpy_ext(priv->phandle,
 			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE,
-			&packet_len, sizeof(packet_len), remain_len);
+			&pkt_len, sizeof(pkt_len), remain_len);
 	remain_len -= sizeof(packet_len);
 	moal_memcpy_ext(priv->phandle,
 			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE +
@@ -2903,7 +3173,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
-	mlan_ds_misc_custom_ie *custom_ie = NULL;
+	mlan_ds_misc_custom_ie *pcustom_ie = NULL;
 	t_u8 *pos = NULL;
 	t_u16 len = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -2911,17 +3181,17 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 
 	ENTER();
 
-	custom_ie = kzalloc(sizeof(mlan_ds_misc_custom_ie), GFP_KERNEL);
-	if (!custom_ie) {
+	pcustom_ie = kzalloc(sizeof(mlan_ds_misc_custom_ie), GFP_KERNEL);
+	if (!pcustom_ie) {
 		PRINTM(MERROR, "Fail to allocate custome_ie\n");
 		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
-	custom_ie->type = TLV_TYPE_MGMT_IE;
+	pcustom_ie->type = TLV_TYPE_MGMT_IE;
 
-	pos = (t_u8 *)custom_ie->ie_data_list;
-	remain_len = sizeof(custom_ie->ie_data_list);
+	pos = (t_u8 *)pcustom_ie->ie_data_list;
+	remain_len = sizeof(pcustom_ie->ie_data_list);
 	if (beacon_ies_data) {
 		len = sizeof(*beacon_ies_data) - MAX_IE_SIZE +
 		      beacon_ies_data->ie_length;
@@ -2929,7 +3199,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 				remain_len);
 		pos += len;
 		remain_len -= len;
-		custom_ie->len += len;
+		pcustom_ie->len += len;
 	}
 
 	if (proberesp_ies_data) {
@@ -2939,7 +3209,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 				remain_len);
 		pos += len;
 		remain_len -= len;
-		custom_ie->len += len;
+		pcustom_ie->len += len;
 	}
 
 	if (assocresp_ies_data) {
@@ -2949,7 +3219,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 				remain_len);
 		pos += len;
 		remain_len -= len;
-		custom_ie->len += len;
+		pcustom_ie->len += len;
 	}
 
 	if (probereq_ies_data) {
@@ -2959,7 +3229,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 				remain_len);
 		pos += len;
 		remain_len -= len;
-		custom_ie->len += len;
+		pcustom_ie->len += len;
 	}
 	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
@@ -2973,7 +3243,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 	ioctl_req->action = MLAN_ACT_SET;
 
-	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, custom_ie,
+	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, pcustom_ie,
 			sizeof(mlan_ds_misc_custom_ie),
 			sizeof(mlan_ds_misc_custom_ie));
 
@@ -3024,7 +3294,7 @@ woal_cfg80211_custom_ie(moal_private *priv, custom_ie *beacon_ies_data,
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(ioctl_req);
-	kfree(custom_ie);
+	kfree(pcustom_ie);
 	LEAVE();
 	return status;
 }
@@ -3173,7 +3443,7 @@ static t_u16 woal_get_specific_ie(const t_u8 *ie, int len, t_u8 *ie_out,
 					   wps_oui[3]) {
 				if (mask & IE_MASK_WPS) {
 					if ((out_len + length + 2) <
-					    ie_out_len) {
+					    (int)ie_out_len) {
 						moal_memcpy_ext(
 							NULL, ie_out + out_len,
 							pos, length + 2,
@@ -3191,7 +3461,7 @@ static t_u16 woal_get_specific_ie(const t_u8 *ie, int len, t_u8 *ie_out,
 					   wfd_oui[3]) {
 				if (mask & IE_MASK_WFD) {
 					if ((out_len + length + 2) <
-					    ie_out_len) {
+					    (int)ie_out_len) {
 						moal_memcpy_ext(
 							NULL, ie_out + out_len,
 							pos, length + 2,
@@ -3204,7 +3474,7 @@ static t_u16 woal_get_specific_ie(const t_u8 *ie, int len, t_u8 *ie_out,
 					}
 				}
 			} else if (mask & IE_MASK_VENDOR) {
-				if ((out_len + length + 2) < ie_out_len) {
+				if ((out_len + length + 2) < (int)ie_out_len) {
 					moal_memcpy_ext(NULL, ie_out + out_len,
 							pos, length + 2,
 							ie_out_len - out_len);
@@ -3239,11 +3509,9 @@ static t_u8 woal_find_ie(const t_u8 *ie, int len, const t_u8 *spec_ie,
 	int left_len = len;
 	const t_u8 *pos = ie;
 	int length;
-	t_u8 id = 0;
 
 	while (left_len >= 2) {
 		length = *(pos + 1);
-		id = *pos;
 		if ((length + 2) > left_len)
 			break;
 		if ((length + 2) == spec_len) {
@@ -3270,8 +3538,8 @@ static t_u8 woal_find_ie(const t_u8 *ie, int len, const t_u8 *spec_ie,
  *
  * @return                out IE length
  */
-static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
-				    t_u8 *ie_out, t_u32 ie_out_len,
+static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie,
+				    size_t len, t_u8 *ie_out, t_u32 ie_out_len,
 				    t_u16 wps_flag, const t_u8 *dup_ie,
 				    int dup_ie_len)
 {
@@ -3308,7 +3576,7 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 		switch (id) {
 		case COUNTRY_INFO:
 			enable_11d = MTRUE;
-			if ((out_len + length + 2) < ie_out_len) {
+			if ((out_len + length + 2) < (int)ie_out_len) {
 				moal_memcpy_ext(priv->phandle, ie_out + out_len,
 						pos, length + 2,
 						ie_out_len - out_len);
@@ -3322,8 +3590,9 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 		case HT_OPERATION:
 		case VHT_CAPABILITY:
 		case VHT_OPERATION:
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 			if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
-				if ((out_len + length + 2) < ie_out_len) {
+				if ((out_len + length + 2) < (int)ie_out_len) {
 					moal_memcpy_ext(priv->phandle,
 							ie_out + out_len, pos,
 							length + 2,
@@ -3334,32 +3603,83 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 					       "IE too big, fail copy COUNTRY INFO IE\n");
 				}
 			}
+#endif
 			break;
 		case EXTENDED_SUPPORTED_RATES:
 		case WLAN_EID_ERP_INFO:
 		/* Fall Through */
-		case REGULATORY_CLASS:
-		/* Fall Through */
 		case OVERLAPBSSSCANPARAM:
 		/* Fall Through */
 		case WAPI_IE:
 			break;
 		case EXTENSION:
 			ext_id = *(pos + 2);
-			if ((ext_id == HE_CAPABILITY ||
-			     ext_id == HE_OPERATION) &&
-			    !moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
+			if ((ext_id == HE_CAPABILITY || ext_id == HE_OPERATION)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+			    && !moal_extflg_isset(priv->phandle, EXT_HOST_MLME)
+#endif
+			)
 				break;
 			else {
-				if ((out_len + length + 2) < ie_out_len) {
-					moal_memcpy_ext(priv->phandle,
+#ifdef UAP_SUPPORT
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+				if (ext_id == HE_CAPABILITY) {
+					mlan_ds_11ax_he_cfg he_cfg;
+					IEEEtypes_HECap_t *hecap_ie;
+
+					if (priv->channel <= 14)
+						he_cfg.band = MBIT(0);
+					else
+						he_cfg.band = MBIT(1);
+
+					PRINTM(MCMND,
+					       "Retrieve 11ax cfg by channel=%d band=%d\n",
+					       priv->channel, he_cfg.band);
+
+					if (0 ==
+					    woal_11ax_cfg(priv, MLAN_ACT_GET,
+							  &he_cfg,
+							  MOAL_IOCTL_WAIT)) {
+						hecap_ie = (IEEEtypes_HECap_t
+								    *)&he_cfg
+								   .he_cap.len;
+
+						hecap_ie->ieee_hdr.len =
+							he_cfg.he_cap.len;
+						hecap_ie->ieee_hdr.element_id =
+							he_cfg.he_cap.id;
+
+						moal_memcpy_ext(
+							priv->phandle,
+							ie_out + out_len,
+							hecap_ie,
+							hecap_ie->ieee_hdr.len +
+								2,
+							ie_out_len - out_len);
+
+						out_len +=
+							hecap_ie->ieee_hdr.len +
+							2;
+					} else {
+						PRINTM(MERROR,
+						       "Fail to get 11ax he_cap parameters\n");
+					}
+				} else
+#endif
+#endif
+				{
+					if ((out_len + length + 2) <
+					    (int)ie_out_len) {
+						moal_memcpy_ext(
+							priv->phandle,
 							ie_out + out_len, pos,
 							length + 2,
 							ie_out_len - out_len);
-					out_len += length + 2;
-				} else {
-					PRINTM(MERROR,
-					       "IE too big, fail copy EXTENSION IE\n");
+						out_len += length + 2;
+					} else {
+						PRINTM(MERROR,
+						       "IE too big, fail copy EXTENSION IE\n");
+					}
 				}
 				break;
 			}
@@ -3375,7 +3695,7 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 					       "Fail to set EXTCAP IE\n");
 				break;
 			}
-			if ((out_len + length + 2) < ie_out_len) {
+			if ((out_len + length + 2) < (int)ie_out_len) {
 				moal_memcpy_ext(priv->phandle, ie_out + out_len,
 						pos, length + 2,
 						ie_out_len - out_len);
@@ -3419,7 +3739,7 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 				// filter out vendor IE
 				break;
 			}
-			if ((out_len + length + 2) < ie_out_len) {
+			if ((out_len + length + 2) < (int)ie_out_len) {
 				moal_memcpy_ext(priv->phandle, ie_out + out_len,
 						pos, length + 2,
 						ie_out_len - out_len);
@@ -3429,8 +3749,11 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 				       "IE too big, fail copy VENDOR_SPECIFIC_221 IE\n");
 			}
 			break;
+		case REGULATORY_CLASS:
+			break;
+			// fall thru to default to add IE
 		default:
-			if ((out_len + length + 2) < ie_out_len) {
+			if ((out_len + length + 2) < (int)ie_out_len) {
 				moal_memcpy_ext(priv->phandle, ie_out + out_len,
 						pos, length + 2,
 						ie_out_len - out_len);
@@ -3445,8 +3768,14 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
 		left_len -= (length + 2);
 	}
 
-	if (enable_11d)
-		woal_set_11d(priv, MOAL_IOCTL_WAIT, MTRUE);
+#ifdef UAP_SUPPORT
+	if (enable_11d && !priv->bss_started) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_11d(priv, MOAL_IOCTL_WAIT, MTRUE)) {
+			PRINTM(MERROR, "woal_set_11d fail\n");
+		}
+	}
+#endif
 	return out_len;
 }
 
@@ -3459,7 +3788,7 @@ static t_u16 woal_filter_beacon_ies(moal_private *priv, const t_u8 *ie, int len,
  *
  * @return                MTRUE/MFALSE
  */
-t_u8 is_selected_registrar_on(const t_u8 *ie, int len)
+static t_u8 is_selected_registrar_on(const t_u8 *ie, int len)
 {
 #define WPS_IE_FIX_LEN 6
 #define TLV_ID_SELECTED_REGISTRAR 0x1041
@@ -3469,9 +3798,9 @@ t_u8 is_selected_registrar_on(const t_u8 *ie, int len)
 	u16 tlv_type, tlv_len;
 	u8 *pos = NULL;
 
-	while (left_len > sizeof(TLV_Generic_t)) {
-		tlv_type = ntohs(tlv->type);
-		tlv_len = ntohs(tlv->len);
+	while (left_len > (int)sizeof(TLV_Generic_t)) {
+		tlv_type = ntohs((__force __be16)tlv->type);
+		tlv_len = ntohs((__force __be16)tlv->len);
 		if (tlv_type == TLV_ID_SELECTED_REGISTRAR) {
 			PRINTM(MIOCTL, "Selected Registrar found !");
 			pos = (u8 *)tlv + sizeof(TLV_Generic_t);
@@ -3608,6 +3937,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (beacon_wps_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid beacon wps index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 
@@ -3660,6 +3990,7 @@ int woal_cfg80211_mgmt_frame_ie(
 				PRINTM(MERROR,
 				       "IE too big: assocresp_ies_len=%d\n",
 				       (int)assocresp_ies_len);
+				ret = -EFAULT;
 				goto done;
 			}
 			assocresp_ies_data->ie_length = assocresp_ies_len;
@@ -3674,6 +4005,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (assocrep_qos_map_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid Qos map index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 
@@ -3765,6 +4097,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (beacon_vendor_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid beacon_vendor_index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 			beacon_ies_data->ie_index = beacon_vendor_index;
@@ -3776,7 +4109,9 @@ int woal_cfg80211_mgmt_frame_ie(
 		if ((beacon_ies && beacon_ies_len &&
 		     beacon_ies_data->ie_length) ||
 		    (beacon_ies_data->mgmt_subtype_mask ==
-		     MLAN_CUSTOM_IE_DELETE_MASK)) {
+			     MLAN_CUSTOM_IE_DELETE_MASK &&
+		     priv->beacon_vendor_index !=
+			     MLAN_CUSTOM_IE_AUTO_IDX_MASK)) {
 			if (MLAN_STATUS_FAILURE ==
 			    woal_cfg80211_custom_ie(
 				    priv, beacon_ies_data, &beacon_vendor_index,
@@ -3821,6 +4156,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (beacon_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MINFO,
 				       "Invalid beacon index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 
@@ -3833,6 +4169,7 @@ int woal_cfg80211_mgmt_frame_ie(
 	}
 
 	if (proberesp_ies_data) {
+		proberesp_ies_data->mgmt_subtype_mask = 0xff;
 		if (proberesp_ies && proberesp_ies_len) {
 			/* set the probe response p2p ies */
 			proberesp_ies_data->ie_index = proberesp_p2p_index;
@@ -3851,6 +4188,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (proberesp_p2p_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid proberesp_p2p_index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 			proberesp_ies_data->ie_index = proberesp_p2p_index;
@@ -3905,6 +4243,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (proberesp_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid probe resp index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 			proberesp_ies_data->ie_index = proberesp_index;
@@ -3927,6 +4266,7 @@ int woal_cfg80211_mgmt_frame_ie(
 				PRINTM(MERROR,
 				       "IE too big, assocresp_ies_len=%d\n",
 				       (int)assocresp_ies_len);
+				ret = -EFAULT;
 				goto done;
 			}
 			assocresp_ies_data->ie_length = assocresp_ies_len;
@@ -3941,6 +4281,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (assocresp_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid assoc resp index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 
@@ -3978,6 +4319,7 @@ int woal_cfg80211_mgmt_frame_ie(
 					PRINTM(MERROR,
 					       "IE too big, probereq_ies_len=%d\n",
 					       (int)probereq_ies_len);
+					ret = -EFAULT;
 					goto done;
 				}
 				probereq_ies_data->ie_length = probereq_ies_len;
@@ -4003,6 +4345,7 @@ int woal_cfg80211_mgmt_frame_ie(
 			if (probereq_index > MAX_MGMT_IE_INDEX) {
 				PRINTM(MERROR,
 				       "Invalid probe req index for mgmt frame ie.\n");
+				ret = -EFAULT;
 				goto done;
 			}
 			probereq_ies_data->ie_index = probereq_index;
@@ -4060,6 +4403,62 @@ int woal_cfg80211_mgmt_frame_ie(
 	return ret;
 }
 
+/**
+ *  @brief Sets up the ieee80211_supported band
+ *  *
+ *  @param ht_info      A pointer to ieee80211_sta_ht_cap structure
+ *  @param dev_cap      Device capability information
+ *  @param mcs_set      Device MCS sets
+ *
+ *  @return             N/A
+ */
+struct ieee80211_supported_band *woal_setup_wiphy_bands(t_u8 ieee_band)
+{
+	struct ieee80211_supported_band *band = NULL;
+	switch (ieee_band) {
+	case IEEE80211_BAND_5GHZ:
+		band = kmemdup(&cfg80211_band_5ghz,
+			       sizeof(struct ieee80211_supported_band),
+			       GFP_KERNEL);
+		if (!band) {
+			PRINTM(MERROR, "No memory for 5g band\n");
+			break;
+		}
+		band->channels =
+			kmemdup(&cfg80211_channels_5ghz,
+				sizeof(cfg80211_channels_5ghz), GFP_KERNEL);
+		if (!band->channels) {
+			PRINTM(MERROR, "No memory for 5g band->channel\n");
+			kfree(band);
+			band = NULL;
+			break;
+		}
+		band->n_channels = ARRAY_SIZE(cfg80211_channels_5ghz);
+		break;
+	case IEEE80211_BAND_2GHZ:
+	default:
+		band = kmemdup(&cfg80211_band_2ghz,
+			       sizeof(struct ieee80211_supported_band),
+			       GFP_KERNEL);
+		if (!band) {
+			PRINTM(MERROR, "No memory for 2g band\n");
+			break;
+		}
+		band->channels =
+			kmemdup(&cfg80211_channels_2ghz,
+				sizeof(cfg80211_channels_2ghz), GFP_KERNEL);
+		if (!band->channels) {
+			PRINTM(MERROR, "No memory for 2g band->channel\n");
+			kfree(band);
+			band = NULL;
+			break;
+		}
+		band->n_channels = ARRAY_SIZE(cfg80211_channels_2ghz);
+		break;
+	}
+	return band;
+}
+
 /**
  *  @brief Sets up the CFG802.11 specific HT capability fields
  *  with default values
@@ -4071,13 +4470,13 @@ int woal_cfg80211_mgmt_frame_ie(
  *  @return             N/A
  */
 void woal_cfg80211_setup_ht_cap(struct ieee80211_sta_ht_cap *ht_info,
-				t_u32 dev_cap, t_u8 *mcs_set)
+				t_u32 dev_cap, t_u8 *mcs_set, t_u8 mpdu_density)
 {
 	ENTER();
 
 	ht_info->ht_supported = true;
 	ht_info->ampdu_factor = 0x3;
-	ht_info->ampdu_density = 0;
+	ht_info->ampdu_density = mpdu_density;
 
 	memset(&ht_info->mcs, 0, sizeof(ht_info->mcs));
 	ht_info->cap = 0;
@@ -4152,12 +4551,14 @@ void woal_cfg80211_setup_vht_cap(moal_private *priv,
 	}
 	vht_cap->vht_supported = true;
 	vht_cap->cap = cfg_11ac->param.vht_cfg.vht_cap_info;
-	vht_cap->vht_mcs.rx_mcs_map = (t_u16)cfg_11ac->param.vht_cfg.vht_rx_mcs;
-	vht_cap->vht_mcs.rx_highest =
-		(t_u16)cfg_11ac->param.vht_cfg.vht_rx_max_rate;
-	vht_cap->vht_mcs.tx_mcs_map = (t_u16)cfg_11ac->param.vht_cfg.vht_tx_mcs;
-	vht_cap->vht_mcs.tx_highest =
-		(t_u16)cfg_11ac->param.vht_cfg.vht_tx_max_rate;
+	vht_cap->vht_mcs.rx_mcs_map = (__force __le16)woal_cpu_to_le16(
+		cfg_11ac->param.vht_cfg.vht_rx_mcs);
+	vht_cap->vht_mcs.rx_highest = (__force __le16)woal_cpu_to_le16(
+		cfg_11ac->param.vht_cfg.vht_rx_max_rate);
+	vht_cap->vht_mcs.tx_mcs_map = (__force __le16)woal_cpu_to_le16(
+		cfg_11ac->param.vht_cfg.vht_tx_mcs);
+	vht_cap->vht_mcs.tx_highest = (__force __le16)woal_cpu_to_le16(
+		cfg_11ac->param.vht_cfg.vht_tx_max_rate);
 	PRINTM(MCMND,
 	       "vht_cap=0x%x rx_mcs_map=0x%x rx_max=0x%x tx_mcs_map=0x%x tx_max=0x%x\n",
 	       vht_cap->cap, vht_cap->vht_mcs.rx_mcs_map,
@@ -4170,7 +4571,6 @@ void woal_cfg80211_setup_vht_cap(moal_private *priv,
 }
 #endif
 
-#if KERNEL_VERSION(4, 20, 0) <= CFG80211_VERSION_CODE
 /*
 ===============
 11AX CAP for uAP
@@ -4212,8 +4612,8 @@ Bit75: 0x1 (Rx 1024-QAM Support < 242-tone RU)
 #define UAP_HE_MAC_CAP0_MASK 0x00
 #define UAP_HE_MAC_CAP1_MASK 0x00
 #define UAP_HE_MAC_CAP2_MASK 0x00
-#define UAP_HE_MAC_CAP3_MASK 0x00
-#define UAP_HE_MAC_CAP4_MASK 0x02
+#define UAP_HE_MAC_CAP3_MASK 0x02
+#define UAP_HE_MAC_CAP4_MASK 0x00
 #define UAP_HE_MAC_CAP5_MASK 0x00
 #define UAP_HE_PHY_CAP0_MASK 0x04
 #define UAP_HE_PHY_CAP1_MASK 0x23
@@ -4260,10 +4660,10 @@ Bit75: 0x1 (Rx 1024-QAM Support < 242-tone RU)
 #define UAP_HE_2G_MAC_CAP0_MASK 0x00
 #define UAP_HE_2G_MAC_CAP1_MASK 0x00
 #define UAP_HE_2G_MAC_CAP2_MASK 0x00
-#define UAP_HE_2G_MAC_CAP3_MASK 0x00
-#define UAP_HE_2G_MAC_CAP4_MASK 0x02
+#define UAP_HE_2G_MAC_CAP3_MASK 0x02
+#define UAP_HE_2G_MAC_CAP4_MASK 0x00
 #define UAP_HE_2G_MAC_CAP5_MASK 0x00
-#define UAP_HE_2G_PHY_CAP0_MASK 0x04
+#define UAP_HE_2G_PHY_CAP0_MASK 0x02
 #define UAP_HE_2G_PHY_CAP1_MASK 0x20
 #define UAP_HE_2G_PHY_CAP2_MASK 0x3E
 #define UAP_HE_2G_PHY_CAP3_MASK 0x88
@@ -4277,12 +4677,12 @@ Bit75: 0x1 (Rx 1024-QAM Support < 242-tone RU)
 
 /**
  *  @brief update 11ax ie for AP mode *
- *  @param band     band config
- *  @hecap_ie      a pointer to mlan_ds_11ax_he_capa
+ *  @param band     channel band
+ *  @hecap_ie       a pointer to mlan_ds_11ax_he_capa
  *
  *  @return         0--success, otherwise failure
  */
-void woal_uap_update_11ax_ie(t_u8 band, mlan_ds_11ax_he_capa *hecap_ie)
+static void woal_uap_update_11ax_ie(t_u8 band, mlan_ds_11ax_he_capa *hecap_ie)
 {
 	if (band == BAND_5GHZ) {
 		hecap_ie->he_mac_cap[0] &= UAP_HE_MAC_CAP0_MASK;
@@ -4324,6 +4724,7 @@ void woal_uap_update_11ax_ie(t_u8 band, mlan_ds_11ax_he_capa *hecap_ie)
 	return;
 }
 
+#if KERNEL_VERSION(4, 20, 0) <= CFG80211_VERSION_CODE
 /**
  *  @brief Sets up the CFG802.11 specific HE capability fields *  with default
  * values
@@ -4343,6 +4744,8 @@ void woal_cfg80211_setup_he_cap(moal_private *priv,
 	mlan_ds_11ax_he_capa *phe_cap = NULL;
 	t_u8 hw_hecap_len;
 
+	memset(&fw_info, 0, sizeof(mlan_fw_info));
+
 	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
 	if (band->band == NL80211_BAND_5GHZ) {
 		phe_cap = (mlan_ds_11ax_he_capa *)fw_info.hw_he_cap;
@@ -4363,6 +4766,7 @@ void woal_cfg80211_setup_he_cap(moal_private *priv,
 		PRINTM(MERROR, "Fail to allocate iftype data\n");
 		goto done;
 	}
+	memset(iftype_data, 0, sizeof(struct ieee80211_sband_iftype_data));
 	iftype_data->types_mask =
 		MBIT(NL80211_IFTYPE_STATION) | MBIT(NL80211_IFTYPE_AP) |
 		MBIT(NL80211_IFTYPE_P2P_CLIENT) | MBIT(NL80211_IFTYPE_P2P_GO);
@@ -4413,6 +4817,72 @@ void woal_cfg80211_setup_he_cap(moal_private *priv,
 done:
 	LEAVE();
 }
+#else
+/**
+ *  @brief setup uap he_cap based on FW he_cap
+ *
+ *  @param priv         A pointer to moal private structure
+ *  @param wait_option  wait_option
+ *
+ *  @return             N/A
+ */
+void woal_cfg80211_setup_uap_he_cap(moal_private *priv, t_u8 wait_option)
+{
+	mlan_ds_11ax_he_capa *phe_cap = NULL;
+	mlan_ds_11ax_he_cfg he_cfg;
+	t_u8 hw_hecap_len;
+	mlan_fw_info fw_info;
+#ifdef UAP_SUPPORT
+	int ret = 0;
+#endif
+
+	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
+
+	// Enable 2G 11AX on UAP
+	if (fw_info.fw_bands & BAND_GAX) {
+		memset(&he_cfg, 0, sizeof(he_cfg));
+		phe_cap = (mlan_ds_11ax_he_capa *)fw_info.hw_2g_he_cap;
+		hw_hecap_len = fw_info.hw_2g_hecap_len;
+		if (hw_hecap_len) {
+			woal_uap_update_11ax_ie(BAND_2GHZ, phe_cap);
+			he_cfg.band = MBIT(0);
+			moal_memcpy_ext(priv->phandle, &he_cfg.he_cap, phe_cap,
+					hw_hecap_len,
+					sizeof(mlan_ds_11ax_he_capa));
+			DBG_HEXDUMP(MCMD_D, "2G HE_CFG ", (t_u8 *)&he_cfg,
+				    sizeof(he_cfg));
+#ifdef UAP_SUPPORT
+			ret = woal_11ax_cfg(priv, MLAN_ACT_SET, &he_cfg,
+					    wait_option);
+			if (ret)
+				PRINTM(MERROR, "Fail to set 2G HE CAP\n");
+#endif
+		}
+	}
+	// Enable 5G 11AX on UAP
+	if (fw_info.fw_bands & BAND_AAX) {
+		memset(&he_cfg, 0, sizeof(he_cfg));
+		phe_cap = (mlan_ds_11ax_he_capa *)fw_info.hw_he_cap;
+		hw_hecap_len = fw_info.hw_hecap_len;
+		if (hw_hecap_len) {
+			woal_uap_update_11ax_ie(BAND_5GHZ, phe_cap);
+			he_cfg.band = MBIT(1);
+			moal_memcpy_ext(priv->phandle, &he_cfg.he_cap, phe_cap,
+					hw_hecap_len,
+					sizeof(mlan_ds_11ax_he_capa));
+			DBG_HEXDUMP(MCMD_D, "5G HE_CFG ", (t_u8 *)&he_cfg,
+				    sizeof(he_cfg));
+#ifdef UAP_SUPPORT
+			ret = woal_11ax_cfg(priv, MLAN_ACT_SET, &he_cfg,
+					    wait_option);
+			if (ret)
+				PRINTM(MERROR, "Fail to set 5G HE CAP\n");
+#endif
+		}
+	}
+	return;
+}
+#endif
 
 /**
  *  @brief free iftype_data
@@ -4422,21 +4892,26 @@ void woal_cfg80211_setup_he_cap(moal_private *priv,
  *
  *  @return             N/A
  */
-void woal_cfg80211_free_iftype_data(struct wiphy *wiphy)
+void woal_cfg80211_free_bands(struct wiphy *wiphy)
 {
-	enum nl80211_band band;
+	t_u8 band;
 
-	for (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; ++band) {
+	for (band = NL80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; ++band) {
 		if (!wiphy->bands[band])
 			continue;
-		if (!wiphy->bands[band]->iftype_data)
-			continue;
-		kfree(wiphy->bands[band]->iftype_data);
-		wiphy->bands[band]->n_iftype_data = 0;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+		if (wiphy->bands[band]->iftype_data) {
+			kfree(wiphy->bands[band]->iftype_data);
+			wiphy->bands[band]->n_iftype_data = 0;
+		}
+#endif
+		kfree(wiphy->bands[band]->channels);
+		kfree(wiphy->bands[band]);
+		wiphy->bands[band] = NULL;
 	}
 }
-#endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 /*
  * @brief  prepare and send fake deauth packet to cfg80211 to
  *         notify wpa_supplicant about disconnection
@@ -4468,6 +4943,7 @@ void woal_deauth_event(moal_private *priv, int reason_code)
 	spin_unlock_irqrestore(&handle->evt_lock, flags);
 	queue_work(handle->evt_workqueue, &handle->evt_work);
 }
+#endif
 
 #ifdef STA_CFG80211
 #if KERNEL_VERSION(3, 2, 0) <= CFG80211_VERSION_CODE
@@ -4513,7 +4989,24 @@ void woal_cfg80211_notify_sched_scan_stop(moal_private *priv)
 #endif
 	);
 	priv->sched_scanning = MFALSE;
-	PRINTM(MEVENT, "Sched_Scan stopped\n");
+	PRINTM(MEVENT, "Notify sched scan stopped\n");
+}
+
+/**
+ * @brief report sched_scan result to kernel
+ *
+ * @param priv          A pointer moal_private structure
+ *
+ * @return          N/A
+ */
+void woal_report_sched_scan_result(moal_private *priv)
+{
+	cfg80211_sched_scan_results(priv->wdev->wiphy
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+				    ,
+				    priv->bg_scan_reqid
+#endif
+	);
 }
 #endif
 #endif
@@ -4567,12 +5060,36 @@ void woal_cfg80211_notify_channel(moal_private *priv,
 	int freq = 0;
 #endif
 #endif
+	struct ieee80211_channel *chan;
 	ENTER();
 
+	/* save the new channel for station interface */
+	if (priv->sme_current.ssid_len) {
+		chan = woal_get_ieee80211_channel(priv, pchan_info);
+		if (chan) {
+			moal_memcpy_ext(priv->phandle, &priv->conn_chan, chan,
+					sizeof(struct ieee80211_channel),
+					sizeof(struct ieee80211_channel));
+		}
+	}
+
 #if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
 	if (MLAN_STATUS_SUCCESS ==
 	    woal_chandef_create(priv, &chandef, pchan_info)) {
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+		mutex_lock(&priv->wdev->mtx);
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+		cfg80211_ch_switch_notify(priv->netdev, &chandef, 0, 0);
+#elif ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) ||                  \
+       IMX_ANDROID_13 || IMX_ANDROID_12_BACKPORT)
+		cfg80211_ch_switch_notify(priv->netdev, &chandef, 0);
+#else
 		cfg80211_ch_switch_notify(priv->netdev, &chandef);
+#endif
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+		mutex_unlock(&priv->wdev->mtx);
+#endif
 		priv->channel = pchan_info->channel;
 #ifdef UAP_CFG80211
 		moal_memcpy_ext(priv->phandle, &priv->chan, &chandef,
@@ -4615,6 +5132,174 @@ void woal_cfg80211_notify_channel(moal_private *priv,
 }
 #endif
 
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+/**
+ * @brief Notify cfg80211 supplicant ant cfg changed
+ *
+ * @param priv          A pointer moal_private structure
+ * @param wiphy         A pointer structure wiphy
+ * @param radio         A pointer to radio cfg structure
+ *
+ * @return              N/A
+ */
+void woal_cfg80211_notify_antcfg(moal_private *priv, struct wiphy *wiphy,
+				 mlan_ds_radio_cfg *radio)
+{
+	if (IS_STA_OR_UAP_CFG80211(priv->phandle->params.cfg80211_wext) &&
+	    wiphy) {
+		if (wiphy->bands[IEEE80211_BAND_2GHZ]) {
+			struct ieee80211_supported_band *bands =
+				wiphy->bands[IEEE80211_BAND_2GHZ];
+
+			if (((radio->param.ant_cfg.tx_antenna & 0xFF) != 3 &&
+			     (radio->param.ant_cfg.tx_antenna & 0xFF) != 0) ||
+			    ((radio->param.ant_cfg.rx_antenna & 0xFF) != 3 &&
+			     (radio->param.ant_cfg.rx_antenna & 0xFF) != 0)) {
+				bands->ht_cap.mcs.rx_mask[1] = 0;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+				if (bands->n_iftype_data &&
+				    bands->iftype_data &&
+				    bands->iftype_data->he_cap.has_he) {
+					t_u16 mcs_nss[2];
+
+					mcs_nss[0] = bands->iftype_data->he_cap
+							     .he_mcs_nss_supp
+							     .rx_mcs_80;
+					mcs_nss[1] = mcs_nss[0] |= 0x0c;
+					moal_memcpy_ext(
+						priv->phandle,
+						(t_void *)&bands->iftype_data
+							->he_cap.he_mcs_nss_supp
+							.rx_mcs_80,
+						(t_void *)&mcs_nss,
+						sizeof(mcs_nss),
+						sizeof(bands->iftype_data->he_cap
+							       .he_mcs_nss_supp));
+				}
+#endif
+			} else if ((radio->param.ant_cfg.tx_antenna & 0xFF) ==
+					   3 ||
+				   (radio->param.ant_cfg.rx_antenna & 0xFF) ==
+					   3) {
+				bands->ht_cap.mcs.rx_mask[1] = 0xff;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+				if (bands->n_iftype_data &&
+				    bands->iftype_data &&
+				    bands->iftype_data->he_cap.has_he) {
+					t_u16 mcs_nss[2];
+
+					mcs_nss[0] = bands->iftype_data->he_cap
+							     .he_mcs_nss_supp
+							     .rx_mcs_80;
+					mcs_nss[1] = mcs_nss[0] =
+						(mcs_nss[0] & ~0x0c) |
+						((mcs_nss[0] & 0x3) << 2);
+
+					moal_memcpy_ext(
+						priv->phandle,
+						(t_void *)&bands->iftype_data
+							->he_cap.he_mcs_nss_supp
+							.rx_mcs_80,
+						(t_void *)&mcs_nss,
+						sizeof(mcs_nss),
+						sizeof(bands->iftype_data->he_cap
+							       .he_mcs_nss_supp));
+				}
+#endif
+			}
+		}
+
+		if (wiphy->bands[IEEE80211_BAND_5GHZ]) {
+			struct ieee80211_supported_band *bands =
+				wiphy->bands[IEEE80211_BAND_5GHZ];
+
+			if (((radio->param.ant_cfg.tx_antenna & 0xFF00) !=
+				     0x300 &&
+			     (radio->param.ant_cfg.tx_antenna & 0xFF00) != 0) ||
+			    ((radio->param.ant_cfg.rx_antenna & 0xFF00) !=
+				     0x300 &&
+			     (radio->param.ant_cfg.rx_antenna & 0xFF00) != 0)) {
+				bands->ht_cap.mcs.rx_mask[1] = 0;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				bands->vht_cap.vht_mcs.rx_mcs_map =
+					(__force __le16)woal_cpu_to_le16(
+						0xfffe);
+				bands->vht_cap.vht_mcs.tx_mcs_map =
+					(__force __le16)woal_cpu_to_le16(
+						0xfffe);
+				bands->vht_cap.vht_mcs.rx_highest =
+					(__force __le16)woal_cpu_to_le16(0x186);
+				bands->vht_cap.vht_mcs.tx_highest =
+					(__force __le16)woal_cpu_to_le16(0x186);
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+				if (bands->n_iftype_data &&
+				    bands->iftype_data &&
+				    bands->iftype_data->he_cap.has_he) {
+					t_u16 mcs_nss[2];
+
+					mcs_nss[0] = bands->iftype_data->he_cap
+							     .he_mcs_nss_supp
+							     .rx_mcs_80;
+					mcs_nss[1] = mcs_nss[0] |= 0x0c;
+					moal_memcpy_ext(
+						priv->phandle,
+						(t_void *)&bands->iftype_data
+							->he_cap.he_mcs_nss_supp
+							.rx_mcs_80,
+						(t_void *)&mcs_nss,
+						sizeof(mcs_nss),
+						sizeof(bands->iftype_data->he_cap
+							       .he_mcs_nss_supp));
+				}
+#endif
+			} else if ((radio->param.ant_cfg.tx_antenna & 0xFF00) ==
+					   0x300 ||
+				   (radio->param.ant_cfg.rx_antenna & 0xFF00) ==
+					   0x300) {
+				bands->ht_cap.mcs.rx_mask[1] = 0xff;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+				bands->vht_cap.vht_mcs.rx_mcs_map =
+					(__force __le16)woal_cpu_to_le16(
+						0xfffa);
+				bands->vht_cap.vht_mcs.tx_mcs_map =
+					(__force __le16)woal_cpu_to_le16(
+						0xfffa);
+				bands->vht_cap.vht_mcs.rx_highest =
+					(__force __le16)woal_cpu_to_le16(0x30c);
+				bands->vht_cap.vht_mcs.tx_highest =
+					(__force __le16)woal_cpu_to_le16(0x30c);
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+				if (bands->n_iftype_data &&
+				    bands->iftype_data &&
+				    bands->iftype_data->he_cap.has_he) {
+					t_u16 mcs_nss[2];
+
+					mcs_nss[0] = bands->iftype_data->he_cap
+							     .he_mcs_nss_supp
+							     .rx_mcs_80;
+					mcs_nss[1] = mcs_nss[0] =
+						(mcs_nss[0] & ~0x0c) |
+						((mcs_nss[0] & 0x3) << 2);
+
+					moal_memcpy_ext(
+						priv->phandle,
+						(t_void *)&bands->iftype_data
+							->he_cap.he_mcs_nss_supp
+							.rx_mcs_80,
+						(t_void *)&mcs_nss,
+						sizeof(mcs_nss),
+						sizeof(bands->iftype_data->he_cap
+							       .he_mcs_nss_supp));
+				}
+#endif
+			}
+		}
+	}
+}
+#endif
+
 #if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
 /**
  * @brief create cfg80211_chan_def structure based on chan_band info
@@ -4661,7 +5346,8 @@ mlan_status woal_chandef_create(moal_private *priv,
 		chandef->width = NL80211_CHAN_WIDTH_40;
 		if (pchan_info->bandcfg.chan2Offset == SEC_CHAN_ABOVE)
 			chandef->center_freq1 = chandef->chan->center_freq + 10;
-		else if (pchan_info->bandcfg.chan2Offset == SEC_CHAN_BELOW)
+		//else if (pchan_info->bandcfg.chan2Offset == SEC_CHAN_BELOW)
+                else
 			chandef->center_freq1 = chandef->chan->center_freq - 10;
 		break;
 	case CHAN_BW_80MHZ:
@@ -4677,3 +5363,170 @@ mlan_status woal_chandef_create(moal_private *priv,
 	return status;
 }
 #endif
+
+/**
+ * @brief Set given radar channel dfs_state to AVAILABLE
+ *
+ * @param wiphy           A pointer to struct wiphy
+ *
+ * @return                N/A
+ */
+void woal_clear_wiphy_dfs_state(struct wiphy *wiphy)
+{
+	struct ieee80211_supported_band *sband;
+	int i;
+
+	ENTER();
+	if (!wiphy) {
+		LEAVE();
+		return;
+	}
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+	if (!sband) {
+		LEAVE();
+		return;
+	}
+
+	for (i = 0; i < sband->n_channels; i++) {
+		if (sband->channels[i].flags & IEEE80211_CHAN_RADAR) {
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
+			if (sband->channels[i].dfs_state ==
+			    NL80211_DFS_UNAVAILABLE) {
+				sband->channels[i].dfs_state =
+					NL80211_DFS_USABLE;
+				sband->channels[i].dfs_state_entered = jiffies;
+			}
+#endif
+		}
+	}
+	LEAVE();
+}
+
+/**
+ * @brief Set given radar channel dfs_state to AVAILABLE
+ *
+ * @param wiphy           A pointer to struct wiphy
+ * @param ch_dfs_state    A pointer to struct mlan_ds_11h_chan_dfs_state
+ *
+ * @return                N/A
+ */
+int woal_get_wiphy_chan_dfs_state(struct wiphy *wiphy,
+				  mlan_ds_11h_chan_dfs_state *ch_dfs_state)
+{
+	struct ieee80211_supported_band *sband;
+	int i;
+	int ret = -1;
+	t_u8 channel = ch_dfs_state->channel;
+
+	ENTER();
+	if (!wiphy) {
+		LEAVE();
+		return ret;
+	}
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+	if (!sband) {
+		LEAVE();
+		return ret;
+	}
+	ch_dfs_state->dfs_required = MFALSE;
+	for (i = 0; i < sband->n_channels; i++) {
+		if (sband->channels[i].hw_value == channel) {
+			if (sband->channels[i].flags & IEEE80211_CHAN_RADAR) {
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
+				ch_dfs_state->dfs_state =
+					(dfs_state_t)sband->channels[i]
+						.dfs_state;
+				ch_dfs_state->dfs_required = MTRUE;
+#endif
+			}
+			ret = 0;
+			break;
+		}
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief Set given radar channel dfs_state to AVAILABLE
+ *
+ * @param wiphy           A pointer to struct wiphy
+ * @param channel         given radar channel
+ * @param dfs_state       dfs_state
+ *
+ * @return                N/A
+ */
+static void woal_update_wiphy_chan_dfs_state(struct wiphy *wiphy, t_u8 channel,
+					     t_u8 dfs_state)
+{
+	struct ieee80211_supported_band *sband;
+	int i;
+
+	ENTER();
+	if (!wiphy) {
+		LEAVE();
+		return;
+	}
+	sband = wiphy->bands[NL80211_BAND_5GHZ];
+
+	if (!sband) {
+		LEAVE();
+		return;
+	}
+
+	for (i = 0; i < sband->n_channels; i++) {
+		if (sband->channels[i].flags & IEEE80211_CHAN_RADAR) {
+			if (sband->channels[i].hw_value == channel) {
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
+				sband->channels[i].dfs_state = dfs_state;
+				sband->channels[i].dfs_state_entered = jiffies;
+#endif
+				break;
+			}
+		}
+	}
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
+	if (i < sband->n_channels)
+		PRINTM(MCMD_D, "DFS: Set channel %d dfs_state: %d\n", channel,
+		       sband->channels[i].dfs_state);
+#endif
+	LEAVE();
+}
+/**
+ * @brief Set given radar channel dfs_state
+ *
+ * @param wiphy           A pointer to wiphy structure
+ * @param channel         given radar channel
+ * @param dfs_state       dfs_state
+ *
+ * @return                N/A
+ */
+static void woal_update_wiphy_channel_dfs_state(struct wiphy *wiphy,
+						t_u8 channel, t_u8 dfs_state)
+{
+	if (!wiphy) {
+		LEAVE();
+		return;
+	}
+	woal_update_wiphy_chan_dfs_state(wiphy, channel, dfs_state);
+}
+
+/**
+ * @brief update channel dfs state to all wiphy
+ *
+ * @param channel         given radar channel
+ * @param dfs_state       dfs_state
+ *
+ * @return                N/A
+ */
+void woal_update_channel_dfs_state(t_u8 channel, t_u8 dfs_state)
+{
+	int index;
+	for (index = 0; index < MAX_MLAN_ADAPTER; index++) {
+		if (m_handle[index] && m_handle[index]->wiphy)
+			woal_update_wiphy_channel_dfs_state(
+				m_handle[index]->wiphy, channel, dfs_state);
+	}
+}
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.h
old mode 100644
new mode 100755
index f68e50c95..402c1aa3a
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211.h
@@ -3,7 +3,7 @@
  * @brief This file contains the CFG80211 specific defines.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -48,6 +48,9 @@
 #define WLAN_CIPHER_SUITE_AES_CMAC 0x000FAC06
 #endif
 #if KERNEL_VERSION(4, 0, 0) <= CFG80211_VERSION_CODE
+#ifndef WLAN_CIPHER_SUITE_BIP_GMAC_128
+#define WLAN_CIPHER_SUITE_BIP_GMAC_128 0x000FAC0B
+#endif
 #ifndef WLAN_CIPHER_SUITE_BIP_GMAC_256
 #define WLAN_CIPHER_SUITE_BIP_GMAC_256 0x000FAC0C
 #endif
@@ -55,7 +58,6 @@
 
 /* define for custom ie operation */
 #define MLAN_CUSTOM_IE_AUTO_IDX_MASK 0xffff
-#define MLAN_CUSTOM_IE_NEW_MASK 0x8000
 #define IE_MASK_WPS 0x0001
 #define IE_MASK_P2P 0x0002
 #define IE_MASK_WFD 0x0004
@@ -64,6 +66,22 @@
 
 #define MRVL_PKT_TYPE_MGMT_FRAME 0xE5
 
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+#define MRVL_PKT_TYPE_MGMT_EASYMESH 0xCF
+#endif
+
+mlan_status woal_cfg80211_set_key(moal_private *priv, t_u8 is_enable_wep,
+				  t_u32 cipher, const t_u8 *key, int key_len,
+				  const t_u8 *seq, int seq_len, t_u8 key_index,
+				  const t_u8 *addr, int disable,
+				  t_u8 wait_option);
+
+mlan_status woal_cfg80211_set_wep_keys(moal_private *priv, const t_u8 *key,
+				       int key_len, t_u8 index,
+				       t_u8 wait_option);
+
+t_u8 is_cfg80211_special_region_code(t_u8 *region_string);
+
 /**
  * If multiple wiphys are registered e.g. a regular netdev with
  * assigned ieee80211_ptr and you won't know whether it points
@@ -91,11 +109,16 @@ pmoal_private woal_get_scan_interface(pmoal_handle handle);
 void woal_host_mlme_disconnect(pmoal_private priv, u16 reason_code, u8 *sa);
 void woal_host_mlme_work_queue(struct work_struct *work);
 void woal_host_mlme_process_assoc_resp(moal_private *priv,
-				       mlan_ds_misc_assoc_rsp *assoc_rsp);
+				       mlan_ds_assoc_info *assoc_info);
+#endif
 #endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+void woal_regulatory_work_queue(struct work_struct *work);
 #endif
 
 t_u8 woal_band_cfg_to_ieee_band(t_u32 band);
+t_u8 woal_ieee_band_to_radio_type(t_u8 ieee_band);
 
 int woal_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 				      struct net_device *dev,
@@ -108,6 +131,9 @@ int woal_cfg80211_change_virtual_intf(struct wiphy *wiphy,
 int woal_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed);
 
 int woal_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+			  int link_id,
+#endif
 			  t_u8 key_index,
 #if KERNEL_VERSION(2, 6, 36) < CFG80211_VERSION_CODE
 			  bool pairwise,
@@ -115,6 +141,9 @@ int woal_cfg80211_add_key(struct wiphy *wiphy, struct net_device *dev,
 			  const t_u8 *mac_addr, struct key_params *params);
 
 int woal_cfg80211_del_key(struct wiphy *wiphy, struct net_device *dev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+			  int link_id,
+#endif
 			  t_u8 key_index,
 #if KERNEL_VERSION(2, 6, 36) < CFG80211_VERSION_CODE
 			  bool pairwise,
@@ -136,6 +165,10 @@ int woal_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *dev);
 #endif
 
 int woal_cfg80211_set_bitrate_mask(struct wiphy *wiphy, struct net_device *dev,
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+				   unsigned int link_id,
+#endif
 				   const u8 *peer,
 				   const struct cfg80211_bitrate_mask *mask);
 #if KERNEL_VERSION(2, 6, 38) <= CFG80211_VERSION_CODE
@@ -184,6 +217,9 @@ int woal_cfg80211_set_channel(struct wiphy *wiphy,
 
 #if KERNEL_VERSION(2, 6, 37) < CFG80211_VERSION_CODE
 int woal_cfg80211_set_default_key(struct wiphy *wiphy, struct net_device *dev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+				  int link_id,
+#endif
 				  t_u8 key_index, bool ucast, bool mcast);
 #else
 int woal_cfg80211_set_default_key(struct wiphy *wiphy, struct net_device *dev,
@@ -193,9 +229,21 @@ int woal_cfg80211_set_default_key(struct wiphy *wiphy, struct net_device *dev,
 #if KERNEL_VERSION(2, 6, 30) <= CFG80211_VERSION_CODE
 int woal_cfg80211_set_default_mgmt_key(struct wiphy *wiphy,
 				       struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+				       int link_id,
+#endif
 				       t_u8 key_index);
 #endif
 
+#if KERNEL_VERSION(5, 10, 0) <= CFG80211_VERSION_CODE
+int woal_cfg80211_set_default_beacon_key(struct wiphy *wiphy,
+					 struct net_device *netdev,
+#if ((KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE) || IMX_ANDROID_13)
+					 int link_id,
+#endif
+					 t_u8 key_index);
+#endif
+
 #if KERNEL_VERSION(3, 1, 0) <= CFG80211_VERSION_CODE
 int woal_cfg80211_set_rekey_data(struct wiphy *wiphy, struct net_device *dev,
 				 struct cfg80211_gtk_rekey_data *data);
@@ -238,10 +286,6 @@ int woal_cfg80211_mgmt_tx(struct wiphy *wiphy,
 #endif
 			  u64 *cookie);
 
-#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
-void woal_update_radar_chans_dfs_state(struct wiphy *wiphy);
-#endif
-
 mlan_status woal_register_cfg80211(moal_private *priv);
 
 extern struct ieee80211_supported_band cfg80211_band_2ghz;
@@ -253,6 +297,11 @@ extern struct ieee80211_supported_band mac1_cfg80211_band_5ghz;
 int woal_cfg80211_bss_role_cfg(moal_private *priv, t_u16 action,
 			       t_u8 *bss_role);
 #endif
+
+#ifdef UAP_SUPPORT
+void woal_cancel_cac(moal_private *priv);
+#endif
+
 #if KERNEL_VERSION(4, 1, 0) <= CFG80211_VERSION_CODE
 struct wireless_dev *
 woal_cfg80211_add_virtual_intf(struct wiphy *wiphy, const char *name,
@@ -299,6 +348,8 @@ int woal_cfg80211_del_virtual_intf(struct wiphy *wiphy,
 int woal_cfg80211_del_virtual_intf(struct wiphy *wiphy, struct net_device *dev);
 #endif
 
+void woal_remove_virtual_interface(moal_handle *handle);
+
 #ifdef WIFI_DIRECT_SUPPORT
 /* Group Owner Negotiation Req */
 #define P2P_GO_NEG_REQ 0
@@ -338,14 +389,11 @@ int woal_cfg80211_init_p2p_client(moal_private *priv);
 int woal_cfg80211_init_p2p_go(moal_private *priv);
 
 int woal_cfg80211_deinit_p2p(moal_private *priv);
-
-void woal_remove_virtual_interface(moal_handle *handle);
-
 #endif /* KERNEL_VERSION */
 #endif /* WIFI_DIRECT_SUPPORT */
 
 /** Define for remain on channel duration timer */
-#define MAX_REMAIN_ON_CHANNEL_DURATION (1000)
+#define MAX_REMAIN_ON_CHANNEL_DURATION (5000)
 
 int woal_cfg80211_remain_on_channel_cfg(moal_private *priv, t_u8 wait_option,
 					t_u8 remove, t_u8 *status,
@@ -397,7 +445,13 @@ int woal_cfg80211_set_beacon(struct wiphy *wiphy, struct net_device *dev,
 			     struct beacon_parameters *params);
 #endif
 
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev,
+			     unsigned int link_id);
+#else
 int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev);
+#endif
 int woal_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,
 #if KERNEL_VERSION(3, 19, 0) <= CFG80211_VERSION_CODE
 			      struct station_del_parameters *param);
@@ -408,6 +462,7 @@ int woal_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,
 			      u8 *mac_addr);
 #endif
 #endif
+
 #if KERNEL_VERSION(3, 12, 0) <= CFG80211_VERSION_CODE
 #if KERNEL_VERSION(3, 15, 0) <= CFG80211_VERSION_CODE
 int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
@@ -423,6 +478,8 @@ int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 int woal_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 				 struct cfg80211_csa_settings *params);
 
+void woal_process_cancel_chanrpt_event(moal_private *priv);
+
 void woal_cac_timer_func(void *context);
 void woal_csa_work_queue(struct work_struct *work);
 #endif
@@ -430,7 +487,7 @@ void woal_csa_work_queue(struct work_struct *work);
 #if defined(UAP_CFG80211) || defined(STA_CFG80211)
 #if KERNEL_VERSION(3, 5, 0) <= CFG80211_VERSION_CODE
 void woal_cfg80211_notify_channel(moal_private *priv,
-				  pchan_band_info pchan_info);
+				  chan_band_info *pchan_info);
 void woal_channel_switch_event(moal_private *priv, chan_band_info *pchan_info);
 #endif
 #endif
@@ -439,10 +496,19 @@ void woal_channel_switch_event(moal_private *priv, chan_band_info *pchan_info);
 #if KERNEL_VERSION(3, 2, 0) <= CFG80211_VERSION_CODE
 void woal_bgscan_stop_event(moal_private *priv);
 void woal_cfg80211_notify_sched_scan_stop(moal_private *priv);
+void woal_report_sched_scan_result(moal_private *priv);
+#endif
 #endif
+
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+
+void woal_cfg80211_notify_antcfg(moal_private *priv, struct wiphy *wiphy,
+				 mlan_ds_radio_cfg *radio);
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 void woal_deauth_event(moal_private *priv, int reason_code);
+#endif
 
 #if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
 mlan_status woal_chandef_create(moal_private *priv,
@@ -453,9 +519,13 @@ mlan_status woal_chandef_create(moal_private *priv,
 #if KERNEL_VERSION(4, 20, 0) <= CFG80211_VERSION_CODE
 void woal_cfg80211_setup_he_cap(moal_private *priv,
 				struct ieee80211_supported_band *band);
-void woal_cfg80211_free_iftype_data(struct wiphy *wiphy);
+#else
+void woal_cfg80211_setup_uap_he_cap(moal_private *priv, t_u8 wait_option);
 #endif
 
+void woal_cfg80211_free_bands(struct wiphy *wiphy);
+struct ieee80211_supported_band *woal_setup_wiphy_bands(t_u8 ieee_band);
+
 void woal_clear_all_mgmt_ies(moal_private *priv, t_u8 wait_option);
 int woal_cfg80211_mgmt_frame_ie(
 	moal_private *priv, const t_u8 *beacon_ies, size_t beacon_ies_len,
@@ -467,7 +537,8 @@ int woal_cfg80211_mgmt_frame_ie(
 int woal_get_active_intf_freq(moal_private *priv);
 
 void woal_cfg80211_setup_ht_cap(struct ieee80211_sta_ht_cap *ht_info,
-				t_u32 dev_cap, t_u8 *mcs_set);
+				t_u32 dev_cap, t_u8 *mcs_set,
+				t_u8 mpdu_density);
 #if KERNEL_VERSION(3, 6, 0) <= CFG80211_VERSION_CODE
 void woal_cfg80211_setup_vht_cap(moal_private *priv,
 				 struct ieee80211_sta_vht_cap *vht_cap);
@@ -475,4 +546,11 @@ void woal_cfg80211_setup_vht_cap(moal_private *priv,
 int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 			pmlan_ds_misc_assoc_rsp assoc_rsp);
 
+void woal_clear_wiphy_dfs_state(struct wiphy *wiphy);
+void woal_update_channel_dfs_state(t_u8 channel, t_u8 dfs_state);
+int woal_get_wiphy_chan_dfs_state(struct wiphy *wiphy,
+				  mlan_ds_11h_chan_dfs_state *ch_dfs_state);
+
+mlan_status woal_reset_wifi(moal_handle *handle, t_u8 cnt, char *reason);
+
 #endif /* _MOAL_CFG80211_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.c
old mode 100644
new mode 100755
index 0e124c595..aa3134679
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.c
@@ -3,7 +3,7 @@
  * @brief This file contains the functions for CFG80211 vendor.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2015-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -43,15 +43,39 @@
 /**nxp vendor command and event*/
 #define MRVL_VENDOR_ID 0x005043
 /** vendor events */
-const struct nl80211_vendor_cmd_info vendor_events[] = {
+static const struct nl80211_vendor_cmd_info vendor_events[] = {
 	{
 		.vendor_id = MRVL_VENDOR_ID,
 		.subcmd = event_hang,
 	}, /*event_id 0*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_fw_dump_done,
+	}, /*event_id 1*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_fw_reset_success,
+	}, /*event_id 2*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_fw_reset_failure,
+	}, /*event_id 3*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_fw_reset_start,
+	}, /*event_id 4*/
 	{
 		.vendor_id = MRVL_VENDOR_ID,
 		.subcmd = event_rssi_monitor,
 	}, /*event_id 0x1501*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_set_key_mgmt_offload,
+	}, /*event_id 0x10001*/
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_fw_roam_success,
+	}, /*event_id 0x10002*/
 	{
 		.vendor_id = MRVL_VENDOR_ID,
 		.subcmd = event_cloud_keep_alive,
@@ -92,6 +116,10 @@ const struct nl80211_vendor_cmd_info vendor_events[] = {
 		.vendor_id = MRVL_VENDOR_ID,
 		.subcmd = event_wake_reason_report,
 	},
+	{
+		.vendor_id = MRVL_VENDOR_ID,
+		.subcmd = event_rtt_result,
+	}, /*event_id ???*/
 	/**add vendor event here*/
 };
 
@@ -125,6 +153,17 @@ static const struct nla_policy
 };
 // clang-format on
 
+static const struct nla_policy woal_rtt_policy[ATTR_RTT_MAX + 1] = {
+	[ATTR_RTT_TARGET_NUM] = {.type = NLA_U8},
+	[ATTR_RTT_TARGET_CONFIG] = {.type = NLA_BINARY},
+	[ATTR_RTT_TARGET_ADDR] = {.type = NLA_STRING, .len = ETH_ALEN},
+	[ATTR_RTT_CHANNEL_INFO] = {.type = NLA_BINARY},
+	[ATTR_RTT_MAX_DUR_SEC] = {.type = NLA_U32},
+	[ATTR_RTT_LCI_INFO] = {.type = NLA_BINARY},
+	[ATTR_RTT_LCR_INFO] = {.type = NLA_BINARY},
+
+};
+
 static const struct nla_policy
 	woal_rssi_monitor_policy[ATTR_RSSI_MONITOR_MAX + 1] = {
 		[ATTR_RSSI_MONITOR_CONTROL] = {.type = NLA_U32},
@@ -143,11 +182,9 @@ static const struct nla_policy
 	woal_fw_roaming_policy[MRVL_WLAN_VENDOR_ATTR_FW_ROAMING_MAX + 1] = {
 		[MRVL_WLAN_VENDOR_ATTR_FW_ROAMING_CONTROL] = {.type = NLA_U32},
 		[MRVL_WLAN_VENDOR_ATTR_FW_ROAMING_CONFIG_BSSID] = {
-			.type = NLA_BINARY,
-			.len = sizeof(int)},
+			.type = NLA_BINARY},
 		[MRVL_WLAN_VENDOR_ATTR_FW_ROAMING_CONFIG_SSID] = {
-			.type = NLA_BINARY,
-			.len = sizeof(int)},
+			.type = NLA_BINARY},
 };
 // clang-format on
 
@@ -155,7 +192,7 @@ static const struct nla_policy
 	woal_keep_alive_policy[MKEEP_ALIVE_ATTRIBUTE_MAX + 1] = {
 		[MKEEP_ALIVE_ATTRIBUTE_ID] = {.type = NLA_U8},
 		[MKEEP_ALIVE_ATTRIBUTE_ETHER_TYPE] = {.type = NLA_U16},
-		[MKEEP_ALIVE_ATTRIBUTE_IP_PKT] = {.type = NLA_BINARY, .len = 1},
+		[MKEEP_ALIVE_ATTRIBUTE_IP_PKT] = {.type = NLA_BINARY},
 		[MKEEP_ALIVE_ATTRIBUTE_IP_PKT_LEN] = {.type = NLA_U16},
 		[MKEEP_ALIVE_ATTRIBUTE_SRC_MAC_ADDR] = {.type = NLA_STRING,
 							.len = ETH_ALEN},
@@ -174,12 +211,12 @@ static const struct nla_policy
  *
  * @return    index of events array
  */
-int woal_get_event_id(int event)
+static int woal_get_event_id(int event)
 {
 	int i = 0;
 
-	for (i = 0; i < ARRAY_SIZE(vendor_events); i++) {
-		if (vendor_events[i].subcmd == event)
+	for (i = 0; i < (int)ARRAY_SIZE(vendor_events); i++) {
+		if ((int)vendor_events[i].subcmd == event)
 			return i;
 	}
 
@@ -244,6 +281,22 @@ int woal_cfg80211_vendor_event(moal_private *priv, int event, t_u8 *data,
 	return ret;
 }
 
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+/**
+ * @brief send fw dump complete event to vendorhal
+ *
+ * @param priv       A pointer to moal_private
+ *
+ * @return      N/A
+ */
+void woal_cfg80211_vendor_event_fw_dump(moal_private *priv)
+{
+	PRINTM(MEVENT, "wlan: Notify FW dump complete event\n");
+	woal_cfg80211_vendor_event(priv, event_fw_dump_done, CUS_EVT_FW_DUMP,
+				   strlen(CUS_EVT_FW_DUMP));
+}
+#endif
+
 /**
  * @brief send vendor event to kernel
  *
@@ -253,8 +306,8 @@ int woal_cfg80211_vendor_event(moal_private *priv, int event, t_u8 *data,
  *
  * @return      0: success  1: fail
  */
-struct sk_buff *woal_cfg80211_alloc_vendor_event(moal_private *priv, int event,
-						 int len)
+static struct sk_buff *woal_cfg80211_alloc_vendor_event(moal_private *priv,
+							int event, int len)
 {
 	struct wiphy *wiphy = NULL;
 	struct sk_buff *skb = NULL;
@@ -626,6 +679,7 @@ static int woal_cfg80211_subcmd_get_fw_version(struct wiphy *wiphy,
 	char end_c = '\0';
 	int ret = 0;
 	char fw_ver[32] = {0};
+	t_u8 hotfix_ver = 0;
 	union {
 		t_u32 l;
 		t_u8 c[4];
@@ -633,9 +687,15 @@ static int woal_cfg80211_subcmd_get_fw_version(struct wiphy *wiphy,
 
 	ENTER();
 
+	hotfix_ver = priv->phandle->fw_hotfix_version;
 	ver.l = priv->phandle->fw_release_number;
-	snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u%c", ver.c[2], ver.c[1],
-		 ver.c[0], ver.c[3], end_c);
+	if (hotfix_ver) {
+		snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u.%u%c", ver.c[2],
+			 ver.c[1], ver.c[0], ver.c[3], hotfix_ver, end_c);
+	} else {
+		snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u%c", ver.c[2],
+			 ver.c[1], ver.c[0], ver.c[3], end_c);
+	}
 	reply_len = strlen(fw_ver) + 1;
 
 	/** Allocate skb for cmd reply*/
@@ -725,7 +785,6 @@ static int woal_cfg80211_subcmd_get_drv_dump(struct wiphy *wiphy,
 	int ret = MLAN_STATUS_SUCCESS;
 	int length = 0;
 	char driver_dump_file[128];
-	char path_name[64];
 	struct sk_buff *skb = NULL;
 
 	ENTER();
@@ -737,12 +796,14 @@ static int woal_cfg80211_subcmd_get_drv_dump(struct wiphy *wiphy,
 	dev = wdev->netdev;
 	priv = (moal_private *)woal_get_netdev_priv(dev);
 	handle = priv->phandle;
-	memset(path_name, 0, sizeof(path_name));
-	woal_create_dump_dir(handle, path_name, sizeof(path_name));
-	PRINTM(MMSG, "driver dump path name is %s\n", path_name);
-	woal_dump_drv_info(handle, path_name);
 	memset(driver_dump_file, 0, sizeof(driver_dump_file));
-	sprintf(driver_dump_file, "%s/%s", path_name, "file_drv_info");
+	snprintf(driver_dump_file, sizeof(driver_dump_file), "/proc/mwlan/");
+	if (handle->handle_idx)
+		snprintf(driver_dump_file, sizeof(driver_dump_file),
+			 "drv_dump%d", handle->handle_idx);
+	else
+		snprintf(driver_dump_file, sizeof(driver_dump_file),
+			 "drv_dump");
 	PRINTM(MMSG, "driver dump file is %s\n", driver_dump_file);
 	length = sizeof(driver_dump_file);
 	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, length);
@@ -781,29 +842,41 @@ static int woal_cfg80211_subcmd_get_supp_feature_set(struct wiphy *wiphy,
 						     int data_len)
 {
 	struct sk_buff *skb = NULL;
+
 	struct net_device *dev = wdev->netdev;
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	mlan_fw_info fw_info;
+
 	t_u32 reply_len = 0;
 	int ret = 0;
 	t_u32 supp_feature_set = 0;
 
 	ENTER();
-
 	supp_feature_set = WLAN_FEATURE_INFRA
 #if defined(UAP_SUPPORT) && defined(STA_SUPPORT)
 			   | WLAN_FEATURE_AP_STA
 #endif
 			   | WLAN_FEATURE_LINK_LAYER_STATS |
 			   WLAN_FEATURE_LOGGER | WLAN_FEATURE_RSSI_MONITOR |
-			   WLAN_FEATURE_CONFIG_NDO |
-			   WLAN_FEATURE_CONTROL_ROAMING |
-			   WLAN_FEATURE_SCAN_RAND | WLAN_FEATURE_MKEEP_ALIVE;
+			   WLAN_FEATURE_CONFIG_NDO | WLAN_FEATURE_SCAN_RAND |
+			   WLAN_FEATURE_MKEEP_ALIVE | WLAN_FEATURE_PNO |
+			   WLAN_FEATURE_TDLS;
 
 	memset(&fw_info, 0, sizeof(mlan_fw_info));
-	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info)) {
+		PRINTM(MERROR, "Fail to get fw info\n");
+		ret = -EFAULT;
+		goto done;
+	}
 	if (fw_info.fw_bands & BAND_A)
 		supp_feature_set |= WLAN_FEATURE_INFRA_5G;
+	if (fw_info.rtt_support)
+		supp_feature_set |= WLAN_FEATURE_D2AP_RTT;
+	if (fw_info.fw_roaming_support)
+		supp_feature_set |= WLAN_FEATURE_CONTROL_ROAMING;
+
+	priv->phandle->wifi_hal_flag = MTRUE;
 
 	reply_len = sizeof(supp_feature_set);
 	/** Allocate skb for cmd reply*/
@@ -854,7 +927,7 @@ static int woal_cfg80211_subcmd_set_country_code(struct wiphy *wiphy,
 		switch (type) {
 		case ATTR_COUNTRY_CODE:
 			strncpy(country, nla_data(iter),
-				MIN(sizeof(country) - 1, nla_len(iter)));
+				MIN((int)sizeof(country) - 1, nla_len(iter)));
 			break;
 		default:
 			PRINTM(MERROR, "Unknown type: %d\n", type);
@@ -946,8 +1019,8 @@ static void woal_get_ring_status(moal_private *priv, int ring_id,
 		ring = (wifi_ring_buffer *)priv->rings[id];
 		if (ring && VALID_RING(ring->ring_id) &&
 		    ring_id == ring->ring_id) {
-			strncpy(status->name, ring->name,
-				sizeof(status->name) - 1);
+			moal_memcpy(priv->phandle, status->name, ring->name,
+				    sizeof(status->name) - 1);
 			status->ring_id = ring->ring_id;
 			status->ring_buffer_byte_size = ring->ring_size;
 			status->written_bytes = ring->ctrl.written_bytes;
@@ -1647,6 +1720,7 @@ int woal_ring_push_data(moal_private *priv, int ring_id,
 
 	if ((ring->wp + w_len) > ring->ring_size ||
 	    (ring->ctrl.written_bytes + w_len) > ring->ring_size) {
+		spin_unlock_irqrestore(&ring->lock, flags);
 		PRINTM(MERROR,
 		       "Ring push buffer overflow: rp=%d  wp=%d, write_bytes=%d\n",
 		       ring->rp, ring->wp, ring->ctrl.written_bytes);
@@ -1775,14 +1849,16 @@ static int woal_deinit_ring_buffer(moal_private *priv)
 
 	ENTER();
 
-	for (i = 0; i < RING_ID_MAX - 1; i++) {
+	for (i = 0; i < RING_ID_MAX; i++) {
 		ring_buff = (wifi_ring_buffer *)priv->rings[i];
 		if (!ring_buff)
 			continue;
 		spin_lock_irqsave(&ring_buff->lock, lock_flags);
 		ring_state = ring_buff->state;
-		if (ring_state == RING_ACTIVE)
+		if (ring_state == RING_ACTIVE) {
 			ring_buff->state = RING_STOP;
+			ring_buff->interval = 0;
+		}
 		spin_unlock_irqrestore(&ring_buff->lock, lock_flags);
 		if (ring_state == RING_ACTIVE)
 			cancel_delayed_work_sync(&ring_buff->work);
@@ -2331,10 +2407,10 @@ static int woal_cfg80211_subcmd_set_packet_filter(struct wiphy *wiphy,
 				nla_data(iter),
 				MIN(packet_filter_len, nla_len(iter)));
 			pkt_filter->packet_filter_len =
-				MIN(packet_filter_len, nla_len(iter));
+				(t_u8)MIN(packet_filter_len, nla_len(iter));
 			pkt_filter->state = PACKET_FILTER_STATE_START;
 			spin_unlock_irqrestore(&pkt_filter->lock, flags);
-			DBG_HEXDUMP(MCMD_D, "packet_filter_program",
+			DBG_HEXDUMP(MDAT_D, "packet_filter_program",
 				    pkt_filter->packet_filter_program,
 				    pkt_filter->packet_filter_len);
 			break;
@@ -2728,10 +2804,10 @@ int woal_filter_packet(moal_private *priv, t_u8 *data, t_u32 len,
 	if (pkt_filter->state != PACKET_FILTER_STATE_START)
 		goto done;
 
-	DBG_HEXDUMP(MCMD_D, "packet_filter_program",
+	DBG_HEXDUMP(MDAT_D, "packet_filter_program",
 		    pkt_filter->packet_filter_program,
 		    pkt_filter->packet_filter_len);
-	DBG_HEXDUMP(MCMD_D, "packet_filter_data", data, len);
+	DBG_HEXDUMP(MDAT_D, "packet_filter_data", data, len);
 	spin_lock_irqsave(&pkt_filter->lock, flags);
 	ret = process_packet(pkt_filter->packet_filter_program,
 			     pkt_filter->packet_filter_len, data, len,
@@ -2806,7 +2882,6 @@ static int woal_cfg80211_subcmd_link_statistic_get(struct wiphy *wiphy,
 	t_u32 num_radio = 0, iface_stat_len = 0, radio_stat_len = 0;
 	int err = -1, length = 0, i;
 	char *ioctl_link_stats_buf = NULL;
-	mlan_ds_get_stats stats;
 	t_u64 cur_time = 0;
 	t_u64 inter_msec = 0;
 	t_u64 max_msec = (t_u64)24 * (t_u64)24 * (t_u64)3600 * (t_u64)1000;
@@ -2832,14 +2907,6 @@ static int woal_cfg80211_subcmd_link_statistic_get(struct wiphy *wiphy,
 		goto done;
 	}
 
-	/* Get Log from the firmware */
-	memset(&stats, 0, sizeof(mlan_ds_get_stats));
-	if (MLAN_STATUS_SUCCESS !=
-	    woal_get_stats_info(priv, MOAL_IOCTL_WAIT, &stats)) {
-		PRINTM(MERROR, "Error getting stats information\n");
-		goto done;
-	}
-
 	ioctl_link_stats_buf = info->param.link_statistic;
 	num_radio = *((t_u32 *)info->param.link_statistic);
 
@@ -2859,7 +2926,7 @@ static int woal_cfg80211_subcmd_link_statistic_get(struct wiphy *wiphy,
 		 * 24days.
 		 */
 		if (inter_msec > max_msec) {
-			PRINTM(MMSG,
+			PRINTM(MINFO,
 			       "Out of range, set inter_msec=%llu to max_msec=%llu\n",
 			       inter_msec, max_msec);
 			inter_msec = max_msec;
@@ -2883,8 +2950,6 @@ static int woal_cfg80211_subcmd_link_statistic_get(struct wiphy *wiphy,
 	iface_stat = (wifi_iface_stat *)(info->param.link_statistic +
 					 sizeof(num_radio) + radio_stat_len);
 	iface_stat_len = sizeof(wifi_iface_stat);
-	/* Fill some fileds */
-	iface_stat->beacon_rx = stats.bcn_rcv_cnt;
 
 	/* could get peer info with separate cmd */
 	for (i = 0; i < iface_stat->num_peers; i++) {
@@ -2913,38 +2978,38 @@ static int woal_cfg80211_subcmd_link_statistic_get(struct wiphy *wiphy,
 		goto done;
 	}
 
-	PRINTM(MCMD_D, "%s: <<< Start DUMP\n", __func__);
-	PRINTM(MCMD_D, "sizeof(wifi_radio_stat)=%zu\n",
+	PRINTM(MDAT_D, "%s: <<< Start DUMP\n", __func__);
+	PRINTM(MDAT_D, "sizeof(wifi_radio_stat)=%zu\n",
 	       sizeof(wifi_radio_stat));
-	DBG_HEXDUMP(MCMD_D, "radio_stat", (t_u8 *)radio_stat, radio_stat_len);
-	PRINTM(MCMD_D, "sizeof(wifi_channel_stat)=%zu\n",
+	DBG_HEXDUMP(MDAT_D, "radio_stat", (t_u8 *)radio_stat, radio_stat_len);
+	PRINTM(MDAT_D, "sizeof(wifi_channel_stat)=%zu\n",
 	       sizeof(wifi_channel_stat));
-	DBG_HEXDUMP(MCMD_D, "iface_stat", (t_u8 *)iface_stat, iface_stat_len);
-	PRINTM(MCMD_D, "num_radio=%d\n", num_radio);
+	DBG_HEXDUMP(MDAT_D, "iface_stat", (t_u8 *)iface_stat, iface_stat_len);
+	PRINTM(MDAT_D, "num_radio=%d\n", num_radio);
 	radio_stat_tmp = radio_stat;
 	for (i = 0; i < num_radio; i++) {
-		PRINTM(MCMD_D, "--radio_stat[%d]--\n", i);
-		PRINTM(MCMD_D, "radio=%d\n", radio_stat_tmp->radio);
-		PRINTM(MCMD_D, "on_time=%d\n", radio_stat_tmp->on_time);
-		PRINTM(MCMD_D, "tx_time=%d\n", radio_stat_tmp->tx_time);
-		PRINTM(MCMD_D, "reserved0=%d\n", radio_stat_tmp->reserved0);
-		PRINTM(MCMD_D, "rx_time=%d\n", radio_stat_tmp->rx_time);
-		PRINTM(MCMD_D, "on_time_scan=%d\n",
+		PRINTM(MDAT_D, "--radio_stat[%d]--\n", i);
+		PRINTM(MDAT_D, "radio=%d\n", radio_stat_tmp->radio);
+		PRINTM(MDAT_D, "on_time=%d\n", radio_stat_tmp->on_time);
+		PRINTM(MDAT_D, "tx_time=%d\n", radio_stat_tmp->tx_time);
+		PRINTM(MDAT_D, "reserved0=%d\n", radio_stat_tmp->reserved0);
+		PRINTM(MDAT_D, "rx_time=%d\n", radio_stat_tmp->rx_time);
+		PRINTM(MDAT_D, "on_time_scan=%d\n",
 		       radio_stat_tmp->on_time_scan);
-		PRINTM(MCMD_D, "on_time_nbd=%d\n", radio_stat_tmp->on_time_nbd);
-		PRINTM(MCMD_D, "on_time_gscan=%d\n",
+		PRINTM(MDAT_D, "on_time_nbd=%d\n", radio_stat_tmp->on_time_nbd);
+		PRINTM(MDAT_D, "on_time_gscan=%d\n",
 		       radio_stat_tmp->on_time_gscan);
-		PRINTM(MCMD_D, "on_time_roam_scan=%d\n",
+		PRINTM(MDAT_D, "on_time_roam_scan=%d\n",
 		       radio_stat_tmp->on_time_roam_scan);
-		PRINTM(MCMD_D, "on_time_pno_scan=%d\n",
+		PRINTM(MDAT_D, "on_time_pno_scan=%d\n",
 		       radio_stat_tmp->on_time_pno_scan);
-		PRINTM(MCMD_D, "on_time_hs20=%d\n",
+		PRINTM(MDAT_D, "on_time_hs20=%d\n",
 		       radio_stat_tmp->on_time_hs20);
-		PRINTM(MCMD_D, "num_channels=%d\n",
+		PRINTM(MDAT_D, "num_channels=%d\n",
 		       radio_stat_tmp->num_channels);
 		radio_stat_tmp++;
 	}
-	PRINTM(MCMD_D, "%s: >>> End DUMP\n", __func__);
+	PRINTM(MDAT_D, "%s: >>> End DUMP\n", __func__);
 
 	err = cfg80211_vendor_cmd_reply(skb);
 	if (unlikely(err))
@@ -3100,7 +3165,7 @@ static int woal_cfg80211_subcmd_link_statistic_clr(struct wiphy *wiphy,
 	/* Send IOCTL request to MLAN */
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status == MLAN_STATUS_SUCCESS)
-		PRINTM(MMSG, "enable link layer statistic successfully\n");
+		PRINTM(MMSG, "disable link layer statistic successfully\n");
 
 	length = NLA_HDRLEN + sizeof(stats_clear_rsp_mask) + sizeof(stop_rsp);
 	/* Alloc the SKB for vendor_event */
@@ -3207,7 +3272,12 @@ static int woal_cfg80211_subcmd_rssi_monitor(struct wiphy *wiphy,
 		priv->cqm_rssi_high_thold = rssi_max;
 		priv->cqm_rssi_thold = rssi_min;
 		priv->cqm_rssi_hyst = 4;
-		woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "set rssi threhold fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 	} else if (rssi_monitor_control == RSSI_MONOTOR_STOP) {
 		/* stop rssi monitor */
 		PRINTM(MEVENT, "stop rssi monitor\n");
@@ -3217,7 +3287,12 @@ static int woal_cfg80211_subcmd_rssi_monitor(struct wiphy *wiphy,
 		priv->cqm_rssi_high_thold = 0;
 		priv->cqm_rssi_thold = 0;
 		priv->cqm_rssi_hyst = 0;
-		woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "set rssi threhold fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 	} else {
 		PRINTM(MERROR, "invalid rssi_monitor control request\n");
 		ret = -EINVAL;
@@ -3276,7 +3351,211 @@ void woal_cfg80211_rssi_monitor_event(moal_private *priv, t_s16 rssi)
 done:
 	LEAVE();
 }
+
+/**
+ * @brief send driver hang vendor event to kernel
+ *
+ * @param priv          A pointer to moal_private
+ * @param reload_mode   reload mode
+ *
+ * @return      N/A
+ */
+void woal_cfg80211_driver_hang_event(moal_private *priv, t_u8 reload_mode)
+{
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+
+	skb = dev_alloc_skb(NLA_HDRLEN + sizeof(t_u8));
+	if (!skb) {
+		PRINTM(MERROR,
+		       "woal_cfg80211_driver_hang_event: Failed to allocate skb");
+		goto done;
+	}
+
+	if (nla_put_u8(skb, ATTR_FW_RELOAD_MODE, reload_mode)) {
+		PRINTM(MERROR,
+		       "woal_cfg80211_driver_hang_event: nla_put failed!\n");
+		kfree(skb);
+		goto done;
+	}
+
+	PRINTM(MMSG,
+	       "woal_cfg80211_driver_hang_event: Send event_hang with reload mode: %d",
+	       reload_mode);
+	woal_cfg80211_vendor_event(priv, event_hang, (t_u8 *)skb->data,
+				   skb->len);
+
+	kfree(skb);
+done:
+	LEAVE();
+}
+
+#endif // STA_CFG80211
+
+/**
+ * @brief vendor command to key_mgmt_set_key
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  fail otherwise
+ */
+static int
+woal_cfg80211_subcmd_set_roaming_offload_key(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     const void *data, int data_len)
+{
+	moal_private *priv;
+	struct net_device *dev;
+	struct sk_buff *skb = NULL;
+	t_u8 *pos = (t_u8 *)data;
+	int ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (data)
+		DBG_HEXDUMP(MCMD_D, "Vendor pmk", (t_u8 *)data, data_len);
+
+	if (!wdev || !wdev->netdev) {
+		LEAVE();
+		return -EFAULT;
+	}
+
+	dev = wdev->netdev;
+	priv = (moal_private *)woal_get_netdev_priv(dev);
+	if (!priv || !pos) {
+		LEAVE();
+		return -EFAULT;
+	}
+
+	if (data_len > MLAN_MAX_KEY_LENGTH) {
+		moal_memcpy_ext(priv->phandle, &priv->pmk.pmk_r0, pos,
+				MLAN_MAX_KEY_LENGTH, MLAN_MAX_KEY_LENGTH);
+		pos += MLAN_MAX_KEY_LENGTH;
+		moal_memcpy_ext(priv->phandle, &priv->pmk.pmk_r0_name, pos,
+				data_len - MLAN_MAX_KEY_LENGTH,
+				MLAN_MAX_PMKR0_NAME_LENGTH);
+	} else {
+		moal_memcpy_ext(priv->phandle, &priv->pmk.pmk, data, data_len,
+				MLAN_MAX_KEY_LENGTH);
+	}
+	priv->pmk_saved = MTRUE;
+
+	/** Allocate skb for cmd reply*/
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, data_len);
+	if (!skb) {
+		PRINTM(MERROR, "allocate memory fail for vendor cmd\n");
+		LEAVE();
+		return -EFAULT;
+	}
+	pos = skb_put(skb, data_len);
+	moal_memcpy_ext(priv->phandle, pos, data, data_len, data_len);
+	ret = cfg80211_vendor_cmd_reply(skb);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to supplicant to update AP info
+ *
+ * @param priv     A pointer to moal_private
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  1: fail
+ */
+int woal_roam_ap_info(moal_private *priv, t_u8 *data, int len)
+{
+	struct wiphy *wiphy = priv->wdev->wiphy;
+	struct sk_buff *skb = NULL;
+	int ret = MLAN_STATUS_SUCCESS;
+	key_info *pkey = NULL;
+	apinfo *pinfo = NULL;
+	apinfo *req_tlv = NULL;
+	MrvlIEtypesHeader_t *tlv = NULL;
+	t_u16 tlv_type = 0, tlv_len = 0, tlv_buf_left = 0;
+	int event_id = 0;
+	t_u8 authorized = 1;
+
+	ENTER();
+
+	event_id = woal_get_event_id(event_fw_roam_success);
+	if (event_max == event_id) {
+		PRINTM(MERROR, "Not find this event %d\n", event_id);
+		ret = 1;
+		LEAVE();
+		return ret;
+	}
+	/**allocate skb*/
+#if KERNEL_VERSION(4, 1, 0) <= CFG80211_VERSION_CODE
+	skb = cfg80211_vendor_event_alloc(wiphy, priv->wdev, len + 50,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, len + 50,
 #endif
+					  event_id, GFP_ATOMIC);
+
+	if (!skb) {
+		PRINTM(MERROR, "allocate memory fail for vendor event\n");
+		ret = 1;
+		LEAVE();
+		return ret;
+	}
+
+	nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_BSSID,
+		MLAN_MAC_ADDR_LENGTH, (t_u8 *)data);
+	nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_AUTHORIZED,
+		sizeof(authorized), &authorized);
+	tlv = (MrvlIEtypesHeader_t *)(data + MLAN_MAC_ADDR_LENGTH);
+	tlv_buf_left = len - MLAN_MAC_ADDR_LENGTH;
+	while (tlv_buf_left >= sizeof(MrvlIEtypesHeader_t)) {
+		tlv_type = woal_le16_to_cpu(tlv->type);
+		tlv_len = woal_le16_to_cpu(tlv->len);
+
+		if (tlv_buf_left < (tlv_len + sizeof(MrvlIEtypesHeader_t))) {
+			PRINTM(MERROR,
+			       "Error processing firmware roam success TLVs, bytes left < TLV length\n");
+			break;
+		}
+
+		switch (tlv_type) {
+		case TLV_TYPE_APINFO:
+			pinfo = (apinfo *)tlv;
+			nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_RESP_IE,
+				pinfo->header.len, pinfo->rsp_ie);
+			break;
+		case TLV_TYPE_ASSOC_REQ_IE:
+			req_tlv = (apinfo *)tlv;
+			nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_REQ_IE,
+				req_tlv->header.len, req_tlv->rsp_ie);
+			break;
+		case TLV_TYPE_KEYINFO:
+			pkey = (key_info *)tlv;
+			nla_put(skb,
+				MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_KEY_REPLAY_CTR,
+				MLAN_REPLAY_CTR_LEN, pkey->key.replay_ctr);
+			nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KCK,
+				MLAN_KCK_LEN, pkey->key.kck);
+			nla_put(skb, MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KEK,
+				MLAN_KEK_LEN, pkey->key.kek);
+			break;
+		default:
+			break;
+		}
+		tlv_buf_left -= tlv_len + sizeof(MrvlIEtypesHeader_t);
+		tlv = (MrvlIEtypesHeader_t *)((t_u8 *)tlv + tlv_len +
+					      sizeof(MrvlIEtypesHeader_t));
+	}
+
+	/**send event*/
+	cfg80211_vendor_event(skb, GFP_ATOMIC);
+
+	LEAVE();
+	return ret;
+}
 
 /**
  * @brief vendor command to get fw roaming capability
@@ -3350,6 +3629,11 @@ static int woal_cfg80211_subcmd_fw_roaming_enable(struct wiphy *wiphy,
 	const struct nlattr *iter;
 	int type, rem, err;
 	t_u32 fw_roaming_enable = 0;
+#ifdef STA_CFG80211
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+	t_u8 enable = 0;
+#endif
+#endif
 
 	ENTER();
 
@@ -3380,12 +3664,7 @@ static int woal_cfg80211_subcmd_fw_roaming_enable(struct wiphy *wiphy,
 
 	PRINTM(MMSG, "FW roaming set enable=%d from wifi hal.\n",
 	       fw_roaming_enable);
-#if defined(STA_CFG80211)
-	if (fw_roaming_enable)
-		priv->roaming_enabled = MTRUE;
-	else
-		priv->roaming_enabled = MFALSE;
-#endif
+	ret = woal_enable_fw_roaming(priv, fw_roaming_enable);
 	/* Alloc the SKB for vendor_event */
 	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(t_u32) + 50);
 	if (unlikely(!skb)) {
@@ -3399,6 +3678,14 @@ static int woal_cfg80211_subcmd_fw_roaming_enable(struct wiphy *wiphy,
 	if (unlikely(err))
 		PRINTM(MERROR, "Vendor Command reply failed ret:%d\n", err);
 
+#ifdef STA_CFG80211
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+	if (!fw_roaming_enable)
+		woal_cfg80211_vendor_event(priv, event_set_key_mgmt_offload,
+					   &enable, sizeof(enable));
+#endif
+#endif
+
 done:
 	LEAVE();
 	return ret;
@@ -3423,6 +3710,7 @@ static int woal_cfg80211_subcmd_fw_roaming_config(struct wiphy *wiphy,
 	int ret = MLAN_STATUS_SUCCESS;
 	const struct nlattr *iter;
 	int type, rem;
+	woal_roam_offload_cfg *roam_offload_cfg = NULL;
 	wifi_bssid_params blacklist;
 	wifi_ssid_params whitelist;
 
@@ -3462,7 +3750,64 @@ static int woal_cfg80211_subcmd_fw_roaming_config(struct wiphy *wiphy,
 		}
 	}
 
+	if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS)) {
+		/*save blacklist and whitelist in driver*/
+		priv->phandle->fw_roam_params.black_list.ap_num =
+			blacklist.num_bssid;
+		moal_memcpy_ext(
+			priv->phandle,
+			(t_u8 *)priv->phandle->fw_roam_params.black_list.ap_mac,
+			(t_u8 *)blacklist.mac_addr,
+			sizeof(wifi_bssid_params) - sizeof(blacklist.num_bssid),
+			sizeof(mlan_ds_misc_roam_offload_aplist) -
+				sizeof(priv->phandle->fw_roam_params.black_list
+					       .ap_num));
+		priv->phandle->fw_roam_params.ssid_list.ssid_num =
+			whitelist.num_ssid;
+		moal_memcpy_ext(
+			priv->phandle,
+			(t_u8 *)priv->phandle->fw_roam_params.ssid_list.ssids,
+			(t_u8 *)whitelist.whitelist_ssid,
+			sizeof(wifi_ssid_params) - sizeof(whitelist.num_ssid),
+			MAX_SSID_NUM * sizeof(mlan_802_11_ssid));
+	} else {
+		roam_offload_cfg = (woal_roam_offload_cfg *)kmalloc(
+			sizeof(woal_roam_offload_cfg), GFP_KERNEL);
+		if (!roam_offload_cfg) {
+			PRINTM(MERROR, "kmalloc failed!\n");
+			ret = -ENOMEM;
+			goto done;
+		}
+		/*download parameters directly to fw*/
+		memset((char *)roam_offload_cfg, 0,
+		       sizeof(woal_roam_offload_cfg));
+		roam_offload_cfg->black_list.ap_num = blacklist.num_bssid;
+		moal_memcpy_ext(priv->phandle,
+				(t_u8 *)&roam_offload_cfg->black_list.ap_mac,
+				(t_u8 *)blacklist.mac_addr,
+				sizeof(wifi_bssid_params) -
+					sizeof(blacklist.num_bssid),
+				sizeof(mlan_ds_misc_roam_offload_aplist) -
+					sizeof(priv->phandle->fw_roam_params
+						       .black_list.ap_num));
+		roam_offload_cfg->ssid_list.ssid_num = whitelist.num_ssid;
+		moal_memcpy_ext(priv->phandle,
+				(t_u8 *)&roam_offload_cfg->ssid_list.ssids,
+				(t_u8 *)whitelist.whitelist_ssid,
+				sizeof(wifi_ssid_params) -
+					sizeof(whitelist.num_ssid),
+				MAX_SSID_NUM * sizeof(mlan_802_11_ssid));
+		if (woal_config_fw_roaming(priv, ROAM_OFFLOAD_PARAM_CFG,
+					   roam_offload_cfg)) {
+			PRINTM(MERROR, "%s: config fw roaming failed \n",
+			       __func__);
+			ret = -EFAULT;
+		}
+	}
+
 done:
+	if (roam_offload_cfg)
+		kfree(roam_offload_cfg);
 	LEAVE();
 	return ret;
 }
@@ -3534,7 +3879,7 @@ static int woal_cfg80211_subcmd_set_scan_mac_oui(struct wiphy *wiphy,
 	struct net_device *dev = NULL;
 	moal_private *priv = NULL;
 	struct nlattr *tb_vendor[ATTR_WIFI_MAX + 1];
-	t_u8 mac_oui[3];
+	t_u8 mac_oui[3] = {0};
 	int ret = MLAN_STATUS_SUCCESS;
 
 	ENTER();
@@ -3633,6 +3978,10 @@ static int woal_cfg80211_subcmd_start_keep_alive(struct wiphy *wiphy,
 			break;
 		case MKEEP_ALIVE_ATTRIBUTE_IP_PKT:
 			if (ip_pkt_len) {
+				if (ip_pkt) {
+					kfree(ip_pkt);
+					ip_pkt = NULL;
+				}
 				ip_pkt = (u8 *)kzalloc(ip_pkt_len, GFP_ATOMIC);
 				if (ip_pkt == NULL) {
 					ret = -ENOMEM;
@@ -3834,66 +4183,1195 @@ static int woal_cfg80211_subcmd_set_dfs_offload(struct wiphy *wiphy,
 	return ret;
 }
 
-// clang-format off
-const struct wiphy_vendor_command vendor_commands[] = {
-	{
-		.info = {
-				.vendor_id = MRVL_VENDOR_ID,
-				.subcmd = sub_cmd_set_drvdbg,
-			},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-			 WIPHY_VENDOR_CMD_NEED_NETDEV,
-		.doit = woal_cfg80211_subcmd_set_drvdbg,
-#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
-		.policy = VENDOR_CMD_RAW_DATA,
-#endif
-	},
-	{
-		.info = {
-				.vendor_id = MRVL_VENDOR_ID,
-				.subcmd = sub_cmd_get_valid_channels,
-			},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-			 WIPHY_VENDOR_CMD_NEED_NETDEV,
-		.doit = woal_cfg80211_subcmd_get_valid_channels,
-#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
-		.policy = woal_attr_policy,
-		.maxattr = ATTR_WIFI_MAX,
-#endif
-	},
-	{
-		.info = {
-				.vendor_id = MRVL_VENDOR_ID,
-				.subcmd = sub_cmd_set_scan_mac_oui,
-			},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-			 WIPHY_VENDOR_CMD_NEED_NETDEV,
-		.doit = woal_cfg80211_subcmd_set_scan_mac_oui,
-#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
-		.policy = woal_attr_policy,
-		.maxattr = ATTR_WIFI_MAX,
-#endif
-	},
-	{
-		.info = {
-				.vendor_id = MRVL_VENDOR_ID,
-				.subcmd = sub_cmd_link_statistic_set,
-			},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-			 WIPHY_VENDOR_CMD_NEED_NETDEV,
-		.doit = woal_cfg80211_subcmd_link_statistic_set,
-#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
-		.policy = woal_ll_stat_policy,
-		.maxattr = ATTR_LL_STATS_MAX,
-#endif
-	},
-	{
-		.info = {
-				.vendor_id = MRVL_VENDOR_ID,
-				.subcmd = sub_cmd_link_statistic_get,
-			},
-		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
-			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+/**
+ * @brief vendor command to get rtt capability
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_get_capa(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	moal_handle *handle = priv->phandle;
+	struct sk_buff *skb = NULL;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "CfgVendor: cfg80211_subcmd_rtt_get_capa\n");
+
+	DBG_HEXDUMP(MCMD_D, "input data", (t_u8 *)data, len);
+
+	/* Alloc the SKB for vendor_event */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(
+		wiphy, nla_total_size(sizeof(handle->rtt_capa)) +
+			       VENDOR_REPLY_OVERHEAD);
+	if (unlikely(!skb)) {
+		PRINTM(MERROR, "skb alloc failed in %s\n", __func__);
+		goto done;
+	}
+
+	/* Put the attribute to the skb */
+	nla_put(skb, ATTR_RTT_CAPA, sizeof(handle->rtt_capa),
+		&(handle->rtt_capa));
+
+	PRINTM(MCMND, "NL80211_CMD_VENDOR=0x%x\n", NL80211_CMD_VENDOR);
+	PRINTM(MCMND, "NL80211_ATTR_WIPHY=0x%x\n", NL80211_ATTR_WIPHY);
+	PRINTM(MCMND, "NL80211_ATTR_VENDOR_ID=0x%x\n", NL80211_ATTR_VENDOR_ID);
+	PRINTM(MCMND, "NL80211_ATTR_VENDOR_SUBCMD=0x%x\n",
+	       NL80211_ATTR_VENDOR_SUBCMD);
+	PRINTM(MCMND, "NL80211_ATTR_VENDOR_DATA=0x%x\n",
+	       NL80211_ATTR_VENDOR_DATA);
+	PRINTM(MCMND, "NL80211_ATTR_VENDOR_EVENTS=0x%x\n",
+	       NL80211_ATTR_VENDOR_EVENTS);
+
+	DBG_HEXDUMP(MCMD_D, "output data skb->head", (t_u8 *)skb->head, 50);
+	DBG_HEXDUMP(MCMD_D, "output data skb->data", (t_u8 *)skb->data, 50);
+	err = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(err))
+		PRINTM(MERROR, "Vendor Command reply failed err:%d\n", err);
+
+done:
+	LEAVE();
+	return err;
+}
+
+static void woal_dump_rtt_params(wifi_rtt_config_params_t *rtt_params)
+{
+	int i = 0;
+
+	PRINTM(MMSG, "===== Start DUMP RTT Params =====\n");
+	PRINTM(MMSG, "rtt_config_num=%d\n\n", rtt_params->rtt_config_num);
+
+	for (i = 0; i < rtt_params->rtt_config_num; i++) {
+		PRINTM(MMSG, "----------[%d]----------\n", i);
+		PRINTM(MMSG, "rtt_config[%d].addr=" MACSTR "\n", i,
+		       MAC2STR(rtt_params->rtt_config[i].addr));
+		PRINTM(MMSG, "rtt_config[%d].type=%d\n", i,
+		       rtt_params->rtt_config[i].type);
+		PRINTM(MMSG, "rtt_config[%d].peer=%d\n", i,
+		       rtt_params->rtt_config[i].peer);
+		PRINTM(MMSG, "rtt_config[%d].channel=[%d %d %d %d]\n", i,
+		       rtt_params->rtt_config[i].channel.width,
+		       rtt_params->rtt_config[i].channel.center_freq,
+		       rtt_params->rtt_config[i].channel.center_freq0,
+		       rtt_params->rtt_config[i].channel.center_freq1);
+		PRINTM(MMSG, "rtt_config[%d].burst_period=%d\n", i,
+		       rtt_params->rtt_config[i].burst_period);
+		PRINTM(MMSG, "rtt_config[%d].num_burst=%d\n", i,
+		       rtt_params->rtt_config[i].num_burst);
+		PRINTM(MMSG, "rtt_config[%d].num_frames_per_burst=%d\n", i,
+		       rtt_params->rtt_config[i].num_frames_per_burst);
+		PRINTM(MMSG, "rtt_config[%d].num_retries_per_rtt_frame=%d\n", i,
+		       rtt_params->rtt_config[i].num_retries_per_rtt_frame);
+		PRINTM(MMSG, "rtt_config[%d].num_retries_per_ftmr=%d\n", i,
+		       rtt_params->rtt_config[i].num_retries_per_ftmr);
+		PRINTM(MMSG, "rtt_config[%d].LCI_request=%d\n", i,
+		       rtt_params->rtt_config[i].LCI_request);
+		PRINTM(MMSG, "rtt_config[%d].LCR_request=%d\n", i,
+		       rtt_params->rtt_config[i].LCR_request);
+		PRINTM(MMSG, "rtt_config[%d].burst_duration=%d\n", i,
+		       rtt_params->rtt_config[i].burst_duration);
+		PRINTM(MMSG, "rtt_config[%d].preamble=%d\n", i,
+		       rtt_params->rtt_config[i].preamble);
+		PRINTM(MMSG, "rtt_config[%d].bw=%d\n", i,
+		       rtt_params->rtt_config[i].bw);
+		PRINTM(MMSG, "\n");
+	}
+}
+
+/**
+ * @brief vendor command to request rtt range
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_range_request(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+						  const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	moal_handle *handle = priv->phandle;
+	struct nlattr *tb[ATTR_RTT_MAX + 1];
+	t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0};
+	t_u8 rtt_config_num = 0;
+	wifi_rtt_config *rtt_config = NULL;
+	t_u8 i = 0, j = 0;
+	wifi_rtt_config_params_t rtt_params;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	err = nla_parse(tb, ATTR_RTT_MAX, data, len, NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			,
+			NULL
+#endif
+	);
+	if (err) {
+		err = -EFAULT;
+		PRINTM(MERROR, "%s: nla_parse fail\n", __func__);
+		goto done;
+	}
+
+	if (!tb[ATTR_RTT_TARGET_NUM] || !tb[ATTR_RTT_TARGET_CONFIG]) {
+		PRINTM(MERROR,
+		       "%s: null attr: tb[ATTR_RTT_TARGET_NUM]=%p tb[ATTR_RTT_TARGET_CONFIG]=%p\n",
+		       __func__, tb[ATTR_RTT_TARGET_NUM],
+		       tb[ATTR_RTT_TARGET_CONFIG]);
+		err = -EINVAL;
+		goto done;
+	}
+
+	rtt_config_num = nla_get_u8(tb[ATTR_RTT_TARGET_NUM]);
+
+	if ((rtt_config_num == 0) || ((handle->rtt_params.rtt_config_num +
+				       rtt_config_num) > MAX_RTT_CONFIG_NUM)) {
+		PRINTM(MERROR, "%s: invalid num=%d  num in handle=%d  MAX=%d\n",
+		       __func__, rtt_config_num,
+		       handle->rtt_params.rtt_config_num, MAX_RTT_CONFIG_NUM);
+		err = -EINVAL;
+		goto done;
+	}
+	if (nla_len(tb[ATTR_RTT_TARGET_CONFIG]) !=
+	    sizeof(rtt_params.rtt_config[0]) * rtt_config_num) {
+		PRINTM(MERROR, "%s: invalid %d(total) != %d(num) * %u(each)\n",
+		       __func__, nla_len(tb[ATTR_RTT_TARGET_CONFIG]),
+		       rtt_config_num, (t_u32)sizeof(rtt_params.rtt_config[0]));
+		err = -EINVAL;
+		goto done;
+	}
+
+	rtt_config = (wifi_rtt_config *)nla_data(tb[ATTR_RTT_TARGET_CONFIG]);
+	memset(&rtt_params, 0, sizeof(rtt_params));
+	/** Strip the zero mac config */
+	for (i = 0; i < rtt_config_num; i++) {
+		if (!memcmp(rtt_config[i].addr, zero_mac,
+			    sizeof(rtt_config[i].addr)))
+			continue;
+		else {
+			moal_memcpy_ext(
+				handle,
+				&rtt_params
+					 .rtt_config[rtt_params.rtt_config_num],
+				&rtt_config[i],
+				sizeof(rtt_params.rtt_config
+					       [rtt_params.rtt_config_num]),
+				sizeof(wifi_rtt_config));
+			rtt_params.rtt_config_num++;
+		}
+	}
+	if (!rtt_params.rtt_config_num) {
+		PRINTM(MERROR, "%s: no valid mac addr\n", __func__);
+		goto done;
+	}
+	woal_dump_rtt_params(&rtt_params);
+
+	ret = woal_config_rtt(priv, MOAL_IOCTL_WAIT, &rtt_params);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_config_rtt() failed\n", __func__);
+		err = -EFAULT;
+		goto done;
+	}
+
+	for (i = 0; i < rtt_params.rtt_config_num; i++) {
+		for (j = 0; j < handle->rtt_params.rtt_config_num; j++) {
+			if (!memcmp(handle->rtt_params.rtt_config[j].addr,
+				    rtt_params.rtt_config[i].addr,
+				    sizeof(handle->rtt_params.rtt_config[j]
+						   .addr)))
+				break;
+		}
+		moal_memcpy_ext(handle, &(handle->rtt_params.rtt_config[j]),
+				&(rtt_params.rtt_config[i]),
+				sizeof(handle->rtt_params.rtt_config[j]),
+				sizeof(wifi_rtt_config));
+		if (j == handle->rtt_params.rtt_config_num)
+			handle->rtt_params.rtt_config_num++;
+	}
+
+	woal_dump_rtt_params(&(handle->rtt_params));
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor command to cancel rtt range
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_range_cancel(struct wiphy *wiphy,
+						 struct wireless_dev *wdev,
+						 const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	moal_handle *handle = priv->phandle;
+	t_u8 rtt_config_num = handle->rtt_params.rtt_config_num;
+	struct nlattr *tb[ATTR_RTT_MAX + 1];
+	t_u32 target_num = 0;
+	t_u8 addr[MAX_RTT_CONFIG_NUM][MLAN_MAC_ADDR_LENGTH];
+	int i = 0, j = 0;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	err = nla_parse(tb, ATTR_RTT_MAX, data, len, NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			,
+			NULL
+#endif
+	);
+	if (err) {
+		PRINTM(MERROR, "%s: nla_parse fail\n", __func__);
+		goto done;
+	}
+
+	if (!tb[ATTR_RTT_TARGET_NUM] || !tb[ATTR_RTT_TARGET_ADDR]) {
+		PRINTM(MERROR,
+		       "%s: null attr: tb[ATTR_RTT_TARGET_NUM]=%p tb[ATTR_RTT_TARGET_ADDR]=%p\n",
+		       __func__, tb[ATTR_RTT_TARGET_NUM],
+		       tb[ATTR_RTT_TARGET_ADDR]);
+		err = -EINVAL;
+		goto done;
+	}
+
+	target_num = nla_get_u8(tb[ATTR_RTT_TARGET_NUM]);
+
+	if ((target_num <= 0 || target_num > MAX_RTT_CONFIG_NUM) ||
+	    (nla_len(tb[ATTR_RTT_TARGET_ADDR]) !=
+	     sizeof(t_u8) * MLAN_MAC_ADDR_LENGTH * target_num)) {
+		PRINTM(MERROR, "%s: Check if %din[1-%d] or %d*%u=%d\n",
+		       __func__, target_num, MAX_RTT_CONFIG_NUM, target_num,
+		       (t_u32)(sizeof(t_u8) * MLAN_MAC_ADDR_LENGTH),
+		       nla_len(tb[ATTR_RTT_TARGET_ADDR]));
+		err = -EINVAL;
+		goto done;
+	}
+	woal_dump_rtt_params(&(handle->rtt_params));
+
+	moal_memcpy_ext(handle, addr, nla_data(tb[ATTR_RTT_TARGET_ADDR]),
+			nla_len(tb[ATTR_RTT_TARGET_ADDR]), sizeof(addr));
+
+	for (i = 0; i < target_num; i++)
+		PRINTM(MMSG, "cancel[%d].addr=" MACSTR "\n", i,
+		       MAC2STR(addr[i]));
+
+	for (i = 0; i < target_num; i++) {
+		for (j = 0; j < handle->rtt_params.rtt_config_num; j++) {
+			if (!memcmp(addr[i],
+				    handle->rtt_params.rtt_config[j].addr,
+				    sizeof(addr[0]))) {
+				memset(&(handle->rtt_params.rtt_config[j]),
+				       0x00,
+				       sizeof(handle->rtt_params.rtt_config[0]));
+				if ((j + 1) <
+				    handle->rtt_params.rtt_config_num) {
+					memmove(&(handle->rtt_params
+							  .rtt_config[j]),
+						&(handle->rtt_params
+							  .rtt_config[j + 1]),
+						sizeof(handle->rtt_params
+							       .rtt_config[0]) *
+							(handle->rtt_params
+								 .rtt_config_num -
+							 (j + 1)));
+					memset(&(handle->rtt_params.rtt_config
+							 [handle->rtt_params
+								  .rtt_config_num -
+							  1]),
+					       0x00,
+					       sizeof(handle->rtt_params
+							      .rtt_config[0]));
+				}
+				handle->rtt_params.rtt_config_num--;
+				continue;
+			}
+		}
+	}
+
+	if (handle->rtt_params.rtt_config_num >= rtt_config_num) {
+		PRINTM(MERROR, "%s: No matched mac addr in rtt_config\n",
+		       __func__);
+		goto done;
+	}
+
+	ret = woal_cancel_rtt(priv, MOAL_IOCTL_WAIT, target_num, addr);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_cancel_rtt() failed\n", __func__);
+		err = -EFAULT;
+		goto done;
+	}
+	woal_dump_rtt_params(&(handle->rtt_params));
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor event to report RTT Results
+ *
+ * @param priv     A pointer to moal_private
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      mlan_status
+ */
+mlan_status woal_cfg80211_event_rtt_result(moal_private *priv, t_u8 *data,
+					   int len)
+{
+	// moal_handle *handle = priv->phandle;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	t_u8 *pos = data;
+	t_u32 event_left_len = len;
+	struct sk_buff *skb = NULL;
+	t_u32 vdr_event_len = 0;
+	t_u32 complete = 0;
+	wifi_rtt_result_element *rtt_result_elem = NULL;
+	t_u32 num_results = 0;
+
+	ENTER();
+
+	PRINTM(MEVENT, "Enter %s()\n", __func__);
+
+	vdr_event_len = nla_total_size(sizeof(complete)) +
+			nla_total_size(sizeof(num_results)) +
+			nla_total_size(len) + NLA_ALIGNTO * num_results +
+			VENDOR_REPLY_OVERHEAD;
+	PRINTM(MEVENT, "vdr_event_len = %d\n", vdr_event_len);
+	skb = woal_cfg80211_alloc_vendor_event(priv, event_rtt_result,
+					       vdr_event_len);
+	if (!skb)
+		goto done;
+
+	complete = *pos;
+	nla_put(skb, ATTR_RTT_RESULT_COMPLETE, sizeof(complete), &complete);
+	pos++;
+	event_left_len--;
+
+	while (event_left_len > sizeof(wifi_rtt_result_element)) {
+		rtt_result_elem = (wifi_rtt_result_element *)pos;
+
+		nla_put(skb, ATTR_RTT_RESULT_FULL, rtt_result_elem->len,
+			rtt_result_elem->data);
+		num_results++;
+
+		pos += sizeof(*rtt_result_elem) + rtt_result_elem->len;
+		event_left_len -=
+			sizeof(*rtt_result_elem) + rtt_result_elem->len;
+	}
+
+	nla_put(skb, ATTR_RTT_RESULT_NUM, sizeof(num_results), &num_results);
+
+	DBG_HEXDUMP(MEVT_D, "output data skb->data", (t_u8 *)skb->data,
+		    skb->len);
+	/**send event*/
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to get rtt responder info
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int
+woal_cfg80211_subcmd_rtt_get_responder_info(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	mlan_rtt_responder rtt_rsp_cfg;
+	struct sk_buff *skb = NULL;
+	wifi_rtt_responder rtt_rsp;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	memset(&rtt_rsp_cfg, 0x00, sizeof(rtt_rsp_cfg));
+	rtt_rsp_cfg.action = RTT_GET_RESPONDER_INFO;
+	ret = woal_rtt_responder_cfg(priv, MOAL_IOCTL_WAIT, &rtt_rsp_cfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_rtt_responder_cfg() failed\n",
+		       __func__);
+		err = -EFAULT;
+		goto done;
+	}
+	PRINTM(MCMD_D,
+	       "mlan_rtt_responder from FW: channel=%d bandcfg=%d %d %d %d preamble=%d\n",
+	       rtt_rsp_cfg.u.info.channel, rtt_rsp_cfg.u.info.bandcfg.chanBand,
+	       rtt_rsp_cfg.u.info.bandcfg.chanWidth,
+	       rtt_rsp_cfg.u.info.bandcfg.chan2Offset,
+	       rtt_rsp_cfg.u.info.bandcfg.scanMode,
+	       rtt_rsp_cfg.u.info.preamble);
+
+	memset(&rtt_rsp, 0x00, sizeof(rtt_rsp));
+	woal_bandcfg_to_channel_info(priv, &(rtt_rsp_cfg.u.info.bandcfg),
+				     rtt_rsp_cfg.u.info.channel,
+				     &(rtt_rsp.channel));
+	rtt_rsp.preamble = rtt_rsp_cfg.u.info.preamble;
+	PRINTM(MCMD_D, "wifi_rtt_responder report to HAL:\n");
+	PRINTM(MCMD_D,
+	       "channel: width=%d center_freq=%d center_freq0=%d center_freq1=%d\n",
+	       rtt_rsp.channel.width, rtt_rsp.channel.center_freq,
+	       rtt_rsp.channel.center_freq0, rtt_rsp.channel.center_freq1);
+	PRINTM(MCMD_D, "preamble=%d\n", rtt_rsp.preamble);
+
+	/* Alloc the SKB for vendor_event */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(
+		wiphy, nla_total_size(sizeof(rtt_rsp)) + VENDOR_REPLY_OVERHEAD);
+	if (unlikely(!skb)) {
+		PRINTM(MERROR, "skb alloc failed in %s\n", __func__);
+		goto done;
+	}
+
+	/* Put the attribute to the skb */
+	nla_put(skb, ATTR_RTT_CHANNEL_INFO, sizeof(rtt_rsp.channel),
+		&(rtt_rsp.channel));
+	nla_put(skb, ATTR_RTT_PREAMBLE, sizeof(rtt_rsp.preamble),
+		&(rtt_rsp.preamble));
+	DBG_HEXDUMP(MCMD_D, "output data skb->data", (t_u8 *)skb->data,
+		    skb->len);
+
+	err = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(err))
+		PRINTM(MERROR, "Vendor Command reply failed err:%d\n", err);
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor command to enable rtt responder
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_enable_responder(struct wiphy *wiphy,
+						     struct wireless_dev *wdev,
+						     const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	struct nlattr *tb[ATTR_RTT_MAX + 1];
+	wifi_channel_info *ch_info = NULL;
+	t_u32 max_dur_sec = 0;
+	mlan_rtt_responder rtt_rsp_cfg;
+	wifi_rtt_responder rtt_rsp;
+	struct sk_buff *skb = NULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	err = nla_parse(tb, ATTR_RTT_MAX, data, len, NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			,
+			NULL
+#endif
+	);
+	if (err) {
+		err = -EFAULT;
+		PRINTM(MERROR, "%s: nla_parse fail\n", __func__);
+		goto done;
+	}
+
+	if (!tb[ATTR_RTT_CHANNEL_INFO] || !tb[ATTR_RTT_MAX_DUR_SEC]) {
+		PRINTM(MERROR,
+		       "%s: null attr: tb[ATTR_RTT_TARGET_NUM]=%p tb[ATTR_RTT_TARGET_CONFIG]=%p\n",
+		       __func__, tb[ATTR_RTT_CHANNEL_INFO],
+		       tb[ATTR_RTT_MAX_DUR_SEC]);
+		err = -EINVAL;
+		goto done;
+	}
+	ch_info = (wifi_channel_info *)nla_data(tb[ATTR_RTT_CHANNEL_INFO]);
+	max_dur_sec = nla_get_u32(tb[ATTR_RTT_MAX_DUR_SEC]);
+	PRINTM(MCMD_D, "HAL input:\n");
+	PRINTM(MCMD_D,
+	       "wifi_channel_info: width=%d center_freq=%d center_freq0=%d center_freq1=%d\n",
+	       ch_info->width, ch_info->center_freq, ch_info->center_freq0,
+	       ch_info->center_freq1);
+	PRINTM(MCMD_D, "max_dur_sec=%d\n", max_dur_sec);
+
+	memset(&rtt_rsp_cfg, 0x00, sizeof(rtt_rsp_cfg));
+	rtt_rsp_cfg.action = RTT_SET_RESPONDER_ENABLE;
+	rtt_rsp_cfg.u.encfg.channel =
+		ieee80211_frequency_to_channel(ch_info->center_freq);
+	woal_channel_info_to_bandcfg(priv, ch_info,
+				     &(rtt_rsp_cfg.u.encfg.bandcfg));
+	rtt_rsp_cfg.u.encfg.max_dur_sec = max_dur_sec;
+	PRINTM(MCMD_D, "HAL input to rtt_responder_encfg:\n");
+	PRINTM(MCMD_D,
+	       "channel=%d bandcfg=[chanBand=%d chanWidth=%d chan2Offset=%d scanMode=%d]\n",
+	       rtt_rsp_cfg.u.encfg.channel,
+	       rtt_rsp_cfg.u.encfg.bandcfg.chanBand,
+	       rtt_rsp_cfg.u.encfg.bandcfg.chanWidth,
+	       rtt_rsp_cfg.u.encfg.bandcfg.chan2Offset,
+	       rtt_rsp_cfg.u.encfg.bandcfg.scanMode);
+	PRINTM(MCMD_D, "max_dur_sec=%d\n", rtt_rsp_cfg.u.encfg.max_dur_sec);
+	ret = woal_rtt_responder_cfg(priv, MOAL_IOCTL_WAIT, &rtt_rsp_cfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_rtt_responder_cfg() failed\n",
+		       __func__);
+		err = -EFAULT;
+		goto done;
+	}
+
+	memset(&rtt_rsp, 0x00, sizeof(rtt_rsp));
+	woal_bandcfg_to_channel_info(priv, &(rtt_rsp_cfg.u.info.bandcfg),
+				     rtt_rsp_cfg.u.info.channel,
+				     &(rtt_rsp.channel));
+	rtt_rsp.preamble = rtt_rsp_cfg.u.info.preamble;
+	PRINTM(MCMD_D, "wifi_rtt_responder report to HAL:\n");
+	PRINTM(MCMD_D,
+	       "channel: width=%d center_freq=%d center_freq0=%d center_freq1=%d\n",
+	       rtt_rsp.channel.width, rtt_rsp.channel.center_freq,
+	       rtt_rsp.channel.center_freq0, rtt_rsp.channel.center_freq1);
+	PRINTM(MCMD_D, "preamble=%d\n", rtt_rsp.preamble);
+
+	/* Alloc the SKB for vendor_event */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(
+		wiphy, nla_total_size(sizeof(rtt_rsp)) + VENDOR_REPLY_OVERHEAD);
+	if (unlikely(!skb)) {
+		PRINTM(MERROR, "skb alloc failed in %s\n", __func__);
+		goto done;
+	}
+
+	/* Put the attribute to the skb */
+	nla_put(skb, ATTR_RTT_CHANNEL_INFO, sizeof(rtt_rsp.channel),
+		&(rtt_rsp.channel));
+	nla_put(skb, ATTR_RTT_PREAMBLE, sizeof(rtt_rsp.preamble),
+		&(rtt_rsp.preamble));
+	DBG_HEXDUMP(MCMD_D, "output data skb->data", (t_u8 *)skb->data,
+		    skb->len);
+
+	err = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(err))
+		PRINTM(MERROR, "Vendor Command reply failed err:%d\n", err);
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor command to disable rtt responder
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_disable_responder(struct wiphy *wiphy,
+						      struct wireless_dev *wdev,
+						      const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	mlan_rtt_responder rtt_rsp_cfg;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	memset(&rtt_rsp_cfg, 0x00, sizeof(rtt_rsp_cfg));
+	rtt_rsp_cfg.action = RTT_SET_RESPONDER_DISABLE;
+	ret = woal_rtt_responder_cfg(priv, MOAL_IOCTL_WAIT, &rtt_rsp_cfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_rtt_responder_cfg() failed\n",
+		       __func__);
+		err = -EFAULT;
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor command to set rtt lci
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_set_lci(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	struct nlattr *tb[ATTR_RTT_MAX + 1];
+	mlan_rtt_responder rtt_rsp_cfg;
+	wifi_lci_information *lci_info;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	err = nla_parse(tb, ATTR_RTT_MAX, data, len, NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			,
+			NULL
+#endif
+	);
+	if (err) {
+		err = -EFAULT;
+		PRINTM(MERROR, "%s: nla_parse fail\n", __func__);
+		goto done;
+	}
+
+	if (!tb[ATTR_RTT_LCI_INFO]) {
+		PRINTM(MERROR, "%s: null attr: tb[ATTR_RTT_LCI_INFO]=%p\n",
+		       __func__, tb[ATTR_RTT_LCI_INFO]);
+		err = -EINVAL;
+		goto done;
+	}
+	lci_info = (wifi_lci_information *)nla_data(tb[ATTR_RTT_LCI_INFO]);
+	PRINTM(MCMD_D, "HAL input:\n");
+	PRINTM(MCMD_D,
+	       "wifi_lci_information: latitude=%lu longitude=%lu altitude=%d latitude_unc=%d longitude_unc=%d altitude_unc=%d\n",
+	       lci_info->latitude, lci_info->longitude, lci_info->altitude,
+	       lci_info->latitude_unc, lci_info->longitude_unc,
+	       lci_info->altitude_unc);
+	PRINTM(MCMD_D,
+	       "wifi_lci_information: motion_pattern=%d floor=%d height_above_floor=%d height_unc=%d\n",
+	       lci_info->motion_pattern, lci_info->floor,
+	       lci_info->height_above_floor, lci_info->height_unc);
+
+	memset(&rtt_rsp_cfg, 0x00, sizeof(rtt_rsp_cfg));
+	rtt_rsp_cfg.action = RTT_SET_RESPONDER_LCI;
+	moal_memcpy_ext(priv->phandle, &(rtt_rsp_cfg.u.lci), lci_info,
+			sizeof(rtt_rsp_cfg.u.lci), sizeof(rtt_rsp_cfg.u.lci));
+	ret = woal_rtt_responder_cfg(priv, MOAL_IOCTL_WAIT, &rtt_rsp_cfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_rtt_responder_cfg() failed\n",
+		       __func__);
+		err = -EFAULT;
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return err;
+}
+
+/**
+ * @brief vendor command to set rtt lcr
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_rtt_set_lcr(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	struct net_device *dev = wdev->netdev;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	struct nlattr *tb[ATTR_RTT_MAX + 1];
+	mlan_rtt_responder rtt_rsp_cfg;
+	wifi_lcr_information *lcr_info;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int err = 0;
+
+	ENTER();
+	PRINTM(MCMND, "Enter %s()\n", __func__);
+
+	err = nla_parse(tb, ATTR_RTT_MAX, data, len, NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			,
+			NULL
+#endif
+	);
+	if (err) {
+		err = -EFAULT;
+		PRINTM(MERROR, "%s: nla_parse fail\n", __func__);
+		goto done;
+	}
+
+	if (!tb[ATTR_RTT_LCR_INFO]) {
+		PRINTM(MERROR, "%s: null attr: tb[ATTR_RTT_LCR_INFO]=%p\n",
+		       __func__, tb[ATTR_RTT_LCR_INFO]);
+		err = -EINVAL;
+		goto done;
+	}
+	lcr_info = (wifi_lcr_information *)nla_data(tb[ATTR_RTT_LCR_INFO]);
+	PRINTM(MCMD_D, "HAL input:\n");
+	PRINTM(MCMD_D, "wifi_lcr_information: country_code='%c' '%c'\n",
+	       lcr_info->country_code[0], lcr_info->country_code[1]);
+	PRINTM(MCMD_D, "wifi_lci_information: length=%d civic_info=%s\n",
+	       lcr_info->length, lcr_info->civic_info);
+
+	memset(&rtt_rsp_cfg, 0x00, sizeof(rtt_rsp_cfg));
+	rtt_rsp_cfg.action = RTT_SET_RESPONDER_LCR;
+	moal_memcpy_ext(priv->phandle, &(rtt_rsp_cfg.u.lcr), lcr_info,
+			sizeof(rtt_rsp_cfg.u.lcr), sizeof(rtt_rsp_cfg.u.lcr));
+	ret = woal_rtt_responder_cfg(priv, MOAL_IOCTL_WAIT, &rtt_rsp_cfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_rtt_responder_cfg() failed\n",
+		       __func__);
+		err = -EFAULT;
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return err;
+}
+
+#define CSI_DUMP_FILE_MAX 1200000
+
+/**
+ * @brief vendor command to set CSI params
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ * @param csi_enable    enable/disable CSI
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_set_csi(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len,
+					int csi_enable)
+{
+	struct net_device *dev = NULL;
+	moal_private *priv = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	struct nlattr *tb_vendor[ATTR_CSI_MAX + 1];
+	int ret = 0;
+	int status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!wdev || !wdev->netdev) {
+		LEAVE();
+		return -EFAULT;
+	}
+	dev = wdev->netdev;
+	priv = (moal_private *)woal_get_netdev_priv(dev);
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MERROR, "Could not allocate mlan ioctl request!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_CSI;
+
+	priv->csi_enable = csi_enable;
+	if (csi_enable == 1) {
+		nla_parse(tb_vendor, ATTR_CSI_MAX, (struct nlattr *)data, len,
+			  NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			  ,
+			  NULL
+#endif
+		);
+		if (!tb_vendor[ATTR_CSI_CONFIG]) {
+			ret = -EFAULT;
+			goto done;
+		}
+		moal_memcpy_ext(priv->phandle, &cfg->param.csi_params,
+				(mlan_ds_csi_params *)nla_data(
+					tb_vendor[ATTR_CSI_CONFIG]),
+				sizeof(mlan_ds_csi_params),
+				sizeof(mlan_ds_csi_params));
+		moal_memcpy_ext(priv->phandle, &priv->csi_config,
+				&cfg->param.csi_params,
+				sizeof(mlan_ds_csi_params),
+				sizeof(mlan_ds_csi_params));
+		if (tb_vendor[ATTR_CSI_DUMP_FORMAT])
+			priv->csi_dump_format =
+				nla_get_u8(tb_vendor[ATTR_CSI_DUMP_FORMAT]);
+	} else if (csi_enable == 0) {
+		nla_parse(tb_vendor, ATTR_CSI_MAX, (struct nlattr *)data, len,
+			  NULL
+#if KERNEL_VERSION(4, 12, 0) <= CFG80211_VERSION_CODE
+			  ,
+			  NULL
+#endif
+		);
+		if (!tb_vendor[ATTR_PEER_MAC_ADDR]) {
+			ret = -EFAULT;
+			goto done;
+		}
+		memset(&cfg->param.csi_params, 0, sizeof(mlan_ds_csi_params));
+		moal_memcpy_ext(priv->phandle,
+				cfg->param.csi_params.csi_filter[0].mac_addr,
+				(t_u8 *)nla_data(tb_vendor[ATTR_PEER_MAC_ADDR]),
+				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to enable CSI
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_csi_enable(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	int ret = 0;
+
+	ENTER();
+
+	ret = woal_cfg80211_subcmd_set_csi(wiphy, wdev, data, len, 1);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to disable CSI
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_csi_disable(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	int ret = 0;
+
+	ENTER();
+
+	ret = woal_cfg80211_subcmd_set_csi(wiphy, wdev, data, len, 0);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to get CSI dump path
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_get_csi_dump_path(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+						  const void *data, int len)
+{
+	int ret = 0;
+	struct net_device *dev = NULL;
+	moal_private *priv = NULL;
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+
+	if (!wdev || !wdev->netdev) {
+		LEAVE();
+		return -EFAULT;
+	}
+	dev = wdev->netdev;
+	priv = (moal_private *)woal_get_netdev_priv(dev);
+
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+						  sizeof(priv->csi_dump_path));
+	if (unlikely(!skb)) {
+		PRINTM(MERROR, "skb alloc failed\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Push the data to the skb */
+	nla_put(skb, ATTR_CSI_DUMP_PATH, sizeof(priv->csi_dump_path),
+		(t_u8 *)priv->csi_dump_path);
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(ret)) {
+		PRINTM(MERROR, "Vendor Command reply failed ret:%d\n", ret);
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to get CSI config
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_get_csi_config(struct wiphy *wiphy,
+					       struct wireless_dev *wdev,
+					       const void *data, int len)
+{
+	int ret = 0;
+	struct net_device *dev = NULL;
+	moal_private *priv = NULL;
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+
+	if (!wdev || !wdev->netdev) {
+		LEAVE();
+		return -EFAULT;
+	}
+	dev = wdev->netdev;
+	priv = (moal_private *)woal_get_netdev_priv(dev);
+
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+						  sizeof(priv->csi_config));
+	if (unlikely(!skb)) {
+		PRINTM(MERROR, "skb alloc failed\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	/* Push the data to the skb */
+	nla_put(skb, ATTR_CSI_CONFIG, sizeof(mlan_ds_csi_params),
+		(t_u8 *)&priv->csi_config);
+
+	ret = cfg80211_vendor_cmd_reply(skb);
+	if (unlikely(ret)) {
+		PRINTM(MERROR, "Vendor Command reply failed ret:%d\n", ret);
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor command to get CSI capability
+ *
+ * @param wiphy    A pointer to wiphy struct
+ * @param wdev     A pointer to wireless_dev struct
+ * @param data     a pointer to data
+ * @param len     data length
+ *
+ * @return      0: success  -1: fail
+ */
+static int woal_cfg80211_subcmd_get_csi_capa(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     const void *data, int len)
+{
+	ENTER();
+	LEAVE();
+	return 0;
+}
+
+/**
+ * @brief Save CSI dump to file
+ *
+ * @param dir_name    Directory name
+ * @param file_name    File name
+ * @param buf    Pointer to dump buffer
+ * @param buf_len    Length of buf
+ * @param name    Full path name of CSI dump
+ *
+ * @return      0: success  -1: fail
+ */
+static mlan_status woal_save_csi_dump_to_file(char *dir_name, char *file_name,
+					      t_u8 *buf, int buf_len,
+					      t_u8 format, char *name)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	ENTER();
+
+	if (!dir_name || !file_name || !buf) {
+		PRINTM(MERROR, "Can't save dump info to file\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief vendor event to upload csi dump
+ *
+ * @param priv     A pointer to moal_private
+ * @param data     a pointer to data
+ * @param  len     data length
+ *
+ * @return      mlan_status
+ */
+mlan_status woal_cfg80211_event_csi_dump(moal_private *priv, t_u8 *data,
+					 int len)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	char path_name[20];
+	char file_name[20];
+
+	ENTER();
+
+	DBG_HEXDUMP(MCMD_D, "CSI dump data", data, len);
+	snprintf(path_name, sizeof(path_name), "/data");
+	if (priv->csi_dump_format == 1)
+		snprintf(file_name, sizeof(file_name), "csi_dump.bin");
+	else
+		snprintf(file_name, sizeof(file_name), "csi_dump.txt");
+	priv->csi_dump_len += len;
+	if (priv->csi_dump_len > CSI_DUMP_FILE_MAX) {
+		PRINTM(MERROR,
+		       "Reached file maximum size. Not saving CSI records.\n");
+		goto done;
+	}
+	/* Save CSI dump to file */
+	ret = woal_save_csi_dump_to_file(path_name, file_name, data, len,
+					 priv->csi_dump_format,
+					 priv->csi_dump_path);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "Failed to save CSI dump to file\n");
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+// clang-format off
+static const struct wiphy_vendor_command vendor_commands[] = {
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_set_drvdbg,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_set_drvdbg,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_get_valid_channels,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_get_valid_channels,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = woal_attr_policy,
+		.maxattr = ATTR_WIFI_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_set_scan_mac_oui,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_set_scan_mac_oui,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = woal_attr_policy,
+		.maxattr = ATTR_WIFI_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_link_statistic_set,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_link_statistic_set,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = woal_ll_stat_policy,
+		.maxattr = ATTR_LL_STATS_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_link_statistic_get,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
 		.doit = woal_cfg80211_subcmd_link_statistic_get,
 #if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
 		.policy = VENDOR_CMD_RAW_DATA,
@@ -3927,6 +5405,18 @@ const struct wiphy_vendor_command vendor_commands[] = {
 #endif
 	},
 #endif
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = sub_cmd_set_roaming_offload_key,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_set_roaming_offload_key,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
 	{
 		.info = {
 				.vendor_id = MRVL_VENDOR_ID,
@@ -4004,6 +5494,112 @@ const struct wiphy_vendor_command vendor_commands[] = {
 	},
 
 
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_GET_CAPA,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_get_capa,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_RANGE_REQUEST,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_range_request,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_RANGE_CANCEL,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_range_cancel,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_GET_RESPONDER_INFO,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_get_responder_info,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_ENABLE_RESPONDER,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_enable_responder,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_DISABLE_RESPONDER,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_disable_responder,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_SET_LCI,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_set_lci,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = SUBCMD_RTT_SET_LCR,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_rtt_set_lcr,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+                .policy = woal_rtt_policy,
+                .maxattr = ATTR_RTT_MAX,
+#endif
+	},
+
 	{
 		.info = {
 				.vendor_id = MRVL_VENDOR_ID,
@@ -4185,6 +5781,66 @@ const struct wiphy_vendor_command vendor_commands[] = {
 		.doit = woal_cfg80211_subcmd_get_packet_filter_capability,
 #if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
 		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = subcmd_cfr_request,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_csi_enable,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = subcmd_cfr_cancel,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_csi_disable,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = subcmd_get_csi_dump_path,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_get_csi_dump_path,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = subcmd_get_csi_config,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_get_csi_config,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
+#endif
+	},
+	{
+		.info = {
+				.vendor_id = MRVL_VENDOR_ID,
+				.subcmd = subcmd_get_csi_capa,
+			},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = woal_cfg80211_subcmd_get_csi_capa,
+#if KERNEL_VERSION(5, 3, 0) <= CFG80211_VERSION_CODE
+		.policy = VENDOR_CMD_RAW_DATA,
 #endif
 	},
 };
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.h
old mode 100644
new mode 100755
index d98eca392..bf29b69e6
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_cfg80211_util.h
@@ -3,7 +3,7 @@
  * @brief This file contains the CFG80211 vendor specific defines.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2015-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -25,6 +25,26 @@
 
 #include "moal_main.h"
 
+#define TLV_TYPE_APINFO (PROPRIETARY_TLV_BASE_ID + 249)
+#define TLV_TYPE_KEYINFO (PROPRIETARY_TLV_BASE_ID + 250)
+#define TLV_TYPE_ASSOC_REQ_IE (PROPRIETARY_TLV_BASE_ID + 292)
+
+/** Key Info structure */
+typedef struct _key_info_tlv {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** kck, kek, key_replay*/
+	mlan_ds_misc_gtk_rekey_data key;
+} key_info;
+
+/** APinfo TLV structure */
+typedef struct _apinfo_tlv {
+	/** Header */
+	MrvlIEtypesHeader_t header;
+	/** Assoc response buffer */
+	t_u8 rsp_ie[1];
+} apinfo;
+
 #if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
 #define RING_NAME_MAX 32
 typedef int wifi_ring_buffer_id;
@@ -600,10 +620,26 @@ enum mrvl_wlan_vendor_attr_wifi_logger {
 	MRVL_WLAN_VENDOR_ATTR_NAME = 10,
 };
 
+enum ATTR_FW_RELOAD {
+	ATTR_FW_RELOAD_INVALID = 0,
+	ATTR_FW_RELOAD_MODE = 1,
+	ATTR_FW_RELOAD_AFTER_LAST,
+	ATTR_FW_RELOAD_MAX = ATTR_FW_RELOAD_AFTER_LAST - 1,
+};
+
+void woal_cfg80211_driver_hang_event(moal_private *priv, t_u8 reload_mode);
+
 /**vendor event*/
 enum vendor_event {
 	event_hang = 0,
+	event_fw_dump_done = 1,
+	event_fw_reset_success = 2,
+	event_fw_reset_failure = 3,
+	event_fw_reset_start = 4,
 	event_rssi_monitor = 0x1501,
+	event_rtt_result = 0x07,
+	event_set_key_mgmt_offload = 0x10001,
+	event_fw_roam_success = 0x10002,
 	event_cloud_keep_alive = 0x10003,
 	event_dfs_radar_detected = 0x10004,
 	event_dfs_cac_started = 0x10005,
@@ -666,6 +702,7 @@ void woal_cfg80211_rssi_monitor_event(moal_private *priv, t_s16 rssi);
 /**vendor sub command*/
 enum vendor_sub_command {
 	sub_cmd_set_drvdbg = 0,
+	sub_cmd_set_roaming_offload_key = 0x0002,
 	sub_cmd_start_keep_alive = 0x0003,
 	sub_cmd_stop_keep_alive = 0x0004,
 	sub_cmd_dfs_capability = 0x0005,
@@ -673,6 +710,14 @@ enum vendor_sub_command {
 	sub_cmd_set_packet_filter = 0x0011,
 	sub_cmd_get_packet_filter_capability,
 	sub_cmd_nd_offload = 0x0100,
+	SUBCMD_RTT_GET_CAPA = 0x1100,
+	SUBCMD_RTT_RANGE_REQUEST,
+	SUBCMD_RTT_RANGE_CANCEL,
+	SUBCMD_RTT_GET_RESPONDER_INFO,
+	SUBCMD_RTT_ENABLE_RESPONDER,
+	SUBCMD_RTT_DISABLE_RESPONDER,
+	SUBCMD_RTT_SET_LCI,
+	SUBCMD_RTT_SET_LCR,
 	sub_cmd_link_statistic_set = 0x1200,
 	sub_cmd_link_statistic_get = 0x1201,
 	sub_cmd_link_statistic_clr = 0x1202,
@@ -693,6 +738,11 @@ enum vendor_sub_command {
 	sub_cmd_get_roaming_capability = 0x1700,
 	sub_cmd_fw_roaming_enable = 0x1701,
 	sub_cmd_fw_roaming_config = 0x1702,
+	subcmd_cfr_request = 0x1900,
+	subcmd_cfr_cancel,
+	subcmd_get_csi_dump_path,
+	subcmd_get_csi_config,
+	subcmd_get_csi_capa,
 	sub_cmd_max,
 };
 
@@ -732,6 +782,25 @@ enum mkeep_alive_attributes {
 	MKEEP_ALIVE_ATTRIBUTE_MAX = MKEEP_ALIVE_ATTRIBUTE_AFTER_LAST - 1
 };
 
+int woal_roam_ap_info(moal_private *priv, t_u8 *data, int len);
+
+/*Attribute for wpa_supplicant*/
+enum mrvl_wlan_vendor_attr_roam_auth {
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_INVALID = 0,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_BSSID,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_REQ_IE,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_RESP_IE,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_AUTHORIZED,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_KEY_REPLAY_CTR,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KCK,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_PTK_KEK,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_SUBNET_STATUS,
+	/* keep last */
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_AFTER_LAST,
+	MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_MAX =
+		MRVL_WLAN_VENDOR_ATTR_ROAM_AUTH_AFTER_LAST - 1
+};
+
 /** WiFi roaming capabilities structure */
 typedef struct {
 	/** max blacklist size */
@@ -777,5 +846,51 @@ enum mrvl_wlan_vendor_attr_fw_roaming {
 		MRVL_WLAN_VENDOR_ATTR_FW_ROAMING_AFTER_LAST - 1
 };
 
+enum attr_rtt {
+	ATTR_RTT_INVALID = 0,
+	ATTR_RTT_CAPA,
+	ATTR_RTT_TARGET_NUM,
+	ATTR_RTT_TARGET_CONFIG,
+	ATTR_RTT_TARGET_ADDR,
+	ATTR_RTT_RESULT_COMPLETE,
+	ATTR_RTT_RESULT_NUM,
+	ATTR_RTT_RESULT_FULL,
+	ATTR_RTT_CHANNEL_INFO,
+	ATTR_RTT_MAX_DUR_SEC,
+	ATTR_RTT_PREAMBLE,
+	ATTR_RTT_LCI_INFO,
+	ATTR_RTT_LCR_INFO,
+
+	/* keep last */
+	ATTR_RTT_AFTER_LAST,
+	ATTR_RTT_MAX = ATTR_RTT_AFTER_LAST - 1
+};
+
+mlan_status woal_cfg80211_event_rtt_result(moal_private *priv, t_u8 *data,
+					   int len);
+
+enum attr_csi {
+	ATTR_CSI_INVALID = 0,
+	ATTR_CSI_CONFIG,
+	ATTR_PEER_MAC_ADDR,
+	ATTR_CSI_DUMP_PATH,
+	ATTR_CSI_CAPA,
+	ATTR_CSI_DUMP_FORMAT,
+	ATTR_CSI_AFTER_LAST,
+	ATTR_CSI_MAX = ATTR_CSI_AFTER_LAST - 1,
+};
+
+/** CSI capability structure */
+typedef struct {
+	/**Bit mask indicates what BW is supported */
+	t_u8 bw_support;
+	/** Bit mask indicates what capturing method is supported */
+	t_u8 method_support;
+	/** Max number of capture peers supported */
+	t_u8 max_peer;
+} wifi_csi_capabilities;
+
+mlan_status woal_cfg80211_event_csi_dump(moal_private *priv, t_u8 *data,
+					 int len);
 #endif
 #endif /* _MOAL_CFGVENDOR_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_debug.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_debug.c
old mode 100644
new mode 100755
index 10da4dc27..1252ab566
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_debug.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_debug.c
@@ -3,7 +3,7 @@
  * @brief This file contains functions for debug proc file.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -117,6 +117,7 @@ static struct debug_data items[] = {
 	 item_addr(bypass_pkt_count), INFO_ADDR},
 	{"scan_processing", item_size(scan_processing),
 	 item_addr(scan_processing), INFO_ADDR},
+	{"scan_state", item_size(scan_state), item_addr(scan_state), INFO_ADDR},
 	{"num_cmd_timeout", item_size(num_cmd_timeout),
 	 item_addr(num_cmd_timeout), INFO_ADDR},
 	{"timeout_cmd_id", item_size(timeout_cmd_id), item_addr(timeout_cmd_id),
@@ -184,6 +185,8 @@ static struct debug_data items[] = {
 	 item_addr(num_cons_assoc_failure), INFO_ADDR},
 	{"cmd_sent", item_size(cmd_sent), item_addr(cmd_sent), INFO_ADDR},
 	{"data_sent", item_size(data_sent), item_addr(data_sent), INFO_ADDR},
+	{"data_sent_cnt", item_size(data_sent_cnt), item_addr(data_sent_cnt),
+	 INFO_ADDR},
 	{"mp_rd_bitmap", item_size(mp_rd_bitmap), item_addr(mp_rd_bitmap),
 	 INFO_ADDR},
 	{"curr_rd_port", item_size(curr_rd_port), item_addr(curr_rd_port),
@@ -257,6 +260,10 @@ static struct debug_data items[] = {
 	 item_handle_addr(hs_skip_count), HANDLE_ADDR},
 	{"hs_force_count", item_handle_size(hs_force_count),
 	 item_handle_addr(hs_force_count), HANDLE_ADDR},
+#ifdef STA_CFG80211
+	{"scan_timeout", item_handle_size(scan_timeout),
+	 item_handle_addr(scan_timeout), HANDLE_ADDR},
+#endif
 };
 
 #endif
@@ -363,6 +370,8 @@ static struct debug_data uap_items[] = {
 #endif
 	{"cmd_sent", item_size(cmd_sent), item_addr(cmd_sent), INFO_ADDR},
 	{"data_sent", item_size(data_sent), item_addr(data_sent), INFO_ADDR},
+	{"data_sent_cnt", item_size(data_sent_cnt), item_addr(data_sent_cnt),
+	 INFO_ADDR},
 	{"mp_rd_bitmap", item_size(mp_rd_bitmap), item_addr(mp_rd_bitmap),
 	 INFO_ADDR},
 	{"curr_rd_port", item_size(curr_rd_port), item_addr(curr_rd_port),
@@ -549,7 +558,6 @@ void woal_hist_data_add(moal_private *priv, t_u16 rx_rate, t_s8 snr, t_s8 nflr,
 #define MAX_MCS_NUM_SUPP 16
 #define MAX_MCS_NUM_AC 10
 #define MAX_MCS_NUM_AX 12
-#define RATE_INDEX_MCS0 12
 /**
  *  @brief histogram info in proc
  *
@@ -740,7 +748,9 @@ static int woal_histogram_read(struct seq_file *sfp, void *data)
 
 static int woal_histogram_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_histogram_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_histogram_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_histogram_read, PDE(inode)->data);
@@ -939,7 +949,9 @@ static int woal_log_read(struct seq_file *sfp, void *data)
  */
 static int woal_log_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_log_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_log_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_log_read, PDE(inode)->data);
@@ -968,8 +980,8 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 	moal_private *priv = items_priv->priv;
 	mlan_debug_info *info = NULL;
 	t_u32 intf_mask = INTF_MASK << 8;
-#ifdef SDIO
 	unsigned int j;
+#ifdef SDIO
 	t_u8 mp_aggr_pkt_limit = 0;
 #endif
 
@@ -1007,7 +1019,6 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 		else if (d[i].size == 4)
 			val = *((t_u32 *)d[i].addr);
 		else {
-			unsigned int j;
 			seq_printf(sfp, "%s=", d[i].name);
 			for (j = 0; j < d[i].size; j += 2) {
 				val = *(t_u16 *)(d[i].addr + j);
@@ -1030,6 +1041,9 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 		mp_aggr_pkt_limit = info->mp_aggr_pkt_limit;
 		seq_printf(sfp, "last_recv_wr_bitmap=0x%x last_mp_index=%d\n",
 			   info->last_recv_wr_bitmap, info->last_mp_index);
+		seq_printf(sfp,
+			   "last_recv_rd_bitmap=0x%x mp_data_port_mask=0x%x\n",
+			   info->last_recv_rd_bitmap, info->mp_data_port_mask);
 		for (i = 0; i < SDIO_MP_DBG_NUM; i++) {
 			seq_printf(
 				sfp,
@@ -1061,18 +1075,20 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 #endif
 #ifdef PCIE
 	if (IS_PCIE(priv->phandle->card_type)) {
+		seq_printf(sfp, "txbd_rdptr=0x%x txbd_wrptr=0x%x\n",
+			   info->txbd_rdptr, info->txbd_wrptr);
+		seq_printf(sfp, "rxbd_rdptr=0x%x rxbd_wrptr=0x%x\n",
+			   info->rxbd_rdptr, info->rxbd_wrptr);
+		seq_printf(sfp, "eventbd_rdptr=0x%x event_wrptr=0x%x\n",
+			   info->eventbd_rdptr, info->eventbd_wrptr);
 		seq_printf(sfp, "last_wr_index:%d\n",
-			   info->txbd_wrptr & (MLAN_MAX_TXRX_BD - 1));
-		seq_printf(sfp, "Tx pkt size:\n");
-		for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
-			seq_printf(sfp, "%04d ", info->last_tx_pkt_size[i]);
-			if ((i + 1) % 16 == 0)
-				seq_printf(sfp, "\n");
-		}
+			   info->txbd_wrptr & (info->txrx_bd_size - 1));
+		seq_printf(sfp, "txrx bd size:%d\n", info->txrx_bd_size);
 	}
 #endif
 	seq_printf(sfp, "tcp_ack_drop_cnt=%d\n", priv->tcp_ack_drop_cnt);
 	seq_printf(sfp, "tcp_ack_cnt=%d\n", priv->tcp_ack_cnt);
+	seq_printf(sfp, "tcp_ack_payload=%d\n", priv->tcp_ack_payload);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 	for (i = 0; i < 4; i++)
 		seq_printf(sfp, "wmm_tx_pending[%d]:%d\n", i,
@@ -1094,12 +1110,10 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 	if (info->rx_tbl_num) {
 		seq_printf(sfp, "Rx reorder table:\n");
 		for (i = 0; i < info->rx_tbl_num; i++) {
-			unsigned int j;
-
 			seq_printf(
 				sfp,
 				"tid = %d, ta =  %02x:%02x:%02x:%02x:%02x:%02x, start_win = %d, "
-				"win_size = %d, amsdu=%d\n",
+				"win_size = %d, amsdu=%d",
 				(int)info->rx_tbl[i].tid, info->rx_tbl[i].ta[0],
 				info->rx_tbl[i].ta[1], info->rx_tbl[i].ta[2],
 				info->rx_tbl[i].ta[3], info->rx_tbl[i].ta[4],
@@ -1107,6 +1121,8 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 				(int)info->rx_tbl[i].start_win,
 				(int)info->rx_tbl[i].win_size,
 				(int)info->rx_tbl[i].amsdu);
+			seq_printf(sfp, "\n");
+
 			seq_printf(sfp, "buffer: ");
 			for (j = 0; j < info->rx_tbl[i].win_size; j++) {
 				if (info->rx_tbl[i].buffer[j] == MTRUE)
@@ -1128,6 +1144,33 @@ static int woal_debug_read(struct seq_file *sfp, void *data)
 			info->ralist[i].tx_pause);
 	}
 
+	for (i = 0; i < info->tdls_peer_num; i++) {
+		seq_printf(
+			sfp,
+			"tdls peer: %02x:%02x:%02x:%02x:%02x:%02x snr=%d nf=%d\n",
+			info->tdls_peer_list[i].mac_addr[0],
+			info->tdls_peer_list[i].mac_addr[1],
+			info->tdls_peer_list[i].mac_addr[2],
+			info->tdls_peer_list[i].mac_addr[3],
+			info->tdls_peer_list[i].mac_addr[4],
+			info->tdls_peer_list[i].mac_addr[5],
+			info->tdls_peer_list[i].snr,
+			-info->tdls_peer_list[i].nf);
+		seq_printf(sfp, "htcap: ");
+		for (j = 0; j < sizeof(IEEEtypes_HTCap_t); j++)
+			seq_printf(sfp, "%02x ",
+				   info->tdls_peer_list[i].ht_cap[j]);
+		seq_printf(sfp, "\nExtcap: ");
+		for (j = 0; j < sizeof(IEEEtypes_ExtCap_t); j++)
+			seq_printf(sfp, "%02x ",
+				   info->tdls_peer_list[i].ext_cap[j]);
+		seq_printf(sfp, "\n");
+		seq_printf(sfp, "vhtcap: ");
+		for (j = 0; j < sizeof(IEEEtypes_VHTCap_t); j++)
+			seq_printf(sfp, "%02x ",
+				   info->tdls_peer_list[i].vht_cap[j]);
+		seq_printf(sfp, "\n");
+	}
 exit:
 	MODULE_PUT;
 	LEAVE();
@@ -1232,7 +1275,9 @@ static ssize_t woal_debug_write(struct file *f, const char __user *buf,
 
 static int woal_debug_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_debug_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_debug_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_debug_read, PDE(inode)->data);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.c
old mode 100644
new mode 100755
index d262fcd0a..1a379a42d
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.c
@@ -1,9 +1,10 @@
+
 /** @file  moal_eth_ioctl.c
   *
   * @brief This file contains private ioctl functions
 
   *
-  * Copyright 2014-2020 NXP
+  * Copyright 2014-2023 NXP
   *
   * This software file (the File) is distributed by NXP
   * under the terms of the GNU General Public License Version 2, June 1991
@@ -55,6 +56,11 @@ Change log:
 #include "moal_cfg80211_util.h"
 #endif
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#include <linux/compat.h>
+#endif
+
+#define CMD_BUF_LEN 4096
 
 /********************************************************
 			Local Variables
@@ -93,7 +99,7 @@ static t_u16 SupportedInfraBand[] = {
 };
 
 /** Bands supported in Ad-Hoc mode */
-static t_u8 SupportedAdhocBand[] = {
+static t_u16 SupportedAdhocBand[] = {
 	BAND_B,
 	BAND_B | BAND_G,
 	BAND_G,
@@ -115,7 +121,7 @@ extern const struct net_device_ops woal_netdev_ops;
 #endif
 
 /********************************************************
-			Local Functions
+			Global Functions
 ********************************************************/
 /**
  * @brief Parse a string to extract numerical arguments
@@ -130,7 +136,7 @@ extern const struct net_device_ops woal_netdev_ops;
 mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
 			    int *user_data_len)
 {
-	unsigned int i, j, k;
+	int i, j, k;
 	char cdata[10];
 	int is_hex = 0;
 
@@ -140,8 +146,8 @@ mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
 	}
 
 	memset(cdata, 0, sizeof(cdata));
-	for (i = 0, j = 0, k = 0; i <= strlen(pos); i++) {
-		if ((k == 0) && (i <= (strlen(pos) - 2))) {
+	for (i = 0, j = 0, k = 0; i <= (int)strlen(pos); i++) {
+		if ((k == 0) && (i <= (int)(strlen(pos) - 2))) {
 			if ((pos[i] == '0') && (pos[i + 1] == 'x')) {
 				is_hex = 1;
 				i = i + 2;
@@ -156,7 +162,9 @@ mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
 				data[j] = woal_atox(cdata);
 				is_hex = 0;
 			} else {
-				woal_atoi(&data[j], cdata);
+				if (woal_atoi(&data[j], cdata) !=
+				    MLAN_STATUS_SUCCESS)
+					;
 			}
 			j++;
 			k = 0;
@@ -164,7 +172,7 @@ mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
 			if (pos[i] == '\0')
 				break;
 		} else {
-			if (k >= sizeof(cdata)) {
+			if (k >= (int)sizeof(cdata)) {
 				PRINTM(MERROR, "Invalid numerical arguments\n");
 				break;
 			}
@@ -177,36 +185,9 @@ mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
 	return MLAN_STATUS_SUCCESS;
 }
 
-/** Convert character to integer */
-#define CHAR2INT(x) (((x) >= 'A') ? ((x) - 'A' + 10) : ((x) - '0'))
-/**
- * @brief Converts a string to hex value
- *
- * @param str      A pointer to the string
- * @param raw      A pointer to the raw data buffer
- * @param raw_size      raw data buffer size
- * @return         Number of bytes read
- **/
-int string2raw(unsigned char *str, unsigned char *raw, int raw_size)
-{
-	int len = (strlen(str) + 1) / 2;
-	int i = 0;
-
-	do {
-		if (strlen(str) < 2)
-			return -1;
-		if (!isxdigit(*str) || !isxdigit(*(str + 1)))
-			return -1;
-		*str = toupper(*str);
-		*raw = CHAR2INT(*str) << 4;
-		++str;
-		*str = toupper(*str);
-		*raw |= CHAR2INT(*str);
-		++raw;
-		i++;
-	} while (*++str != '\0' && i < raw_size);
-	return len;
-}
+/********************************************************
+			Local Functions
+********************************************************/
 
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 /**
@@ -290,7 +271,8 @@ mlan_status woal_set_ap_wps_p2p_ie(moal_private *priv, t_u8 *ie, size_t len)
  *
  *  @return             MLAN_STATUS_SUCCESS -- success, otherwise fail
  */
-mlan_status woal_set_miracast_mode(moal_private *priv, t_u8 *pdata, size_t len)
+static mlan_status woal_set_miracast_mode(moal_private *priv, t_u8 *pdata,
+					  size_t len)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u8 *pos = pdata;
@@ -338,8 +320,8 @@ mlan_status woal_set_miracast_mode(moal_private *priv, t_u8 *pdata, size_t len)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_get_priv_driver_version(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_get_priv_driver_version(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
 	int len = 0, ret = -1;
 	char buf[MLAN_MAX_VER_STR_LEN];
@@ -360,7 +342,7 @@ int woal_get_priv_driver_version(moal_private *priv, t_u8 *respbuf,
 	if (len) {
 		/* Copy back the retrieved version string */
 		PRINTM(MINFO, "MOAL VERSION: %s\n", buf);
-		ret = MIN(len, (respbuflen - 1));
+		ret = MIN(len, (int)(respbuflen - 1));
 		moal_memcpy_ext(priv->phandle, respbuf, buf, ret,
 				respbuflen - 1);
 	} else {
@@ -428,7 +410,7 @@ int woal_priv_hostcmd(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 	}
 	ret = misc_cfg->param.hostcmd.len + sizeof(buf_len) + strlen(CMD_NXP) +
 	      strlen(PRIV_CMD_HOSTCMD);
-	if (ret > respbuflen) {
+	if (ret > (int)respbuflen) {
 		ret = -EFAULT;
 		goto error;
 	}
@@ -468,7 +450,7 @@ static int woal_setget_priv_11axcmdcfg(moal_private *priv, t_u8 *respbuf,
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	int header_len = 0, user_data_len = 0;
-	int data[3] = {0};
+	int data[4] = {0};
 	ENTER();
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11ax_cmd_cfg));
@@ -488,7 +470,7 @@ static int woal_setget_priv_11axcmdcfg(moal_private *priv, t_u8 *respbuf,
 	PRINTM(MINFO, "data_len=%d,data=%d,%d,%d\n", user_data_len, data[0],
 	       data[1], data[2]);
 
-	if (user_data_len > 3 || user_data_len == 0) {
+	if (user_data_len > 4 || user_data_len == 0) {
 		PRINTM(MERROR, "Invalid parameters\n");
 		ret = -EFAULT;
 		goto done;
@@ -525,6 +507,8 @@ static int woal_setget_priv_11axcmdcfg(moal_private *priv, t_u8 *respbuf,
 	case MLAN_11AXCMD_CFG_ID_TX_OMI:
 		cfg->sub_id = MLAN_11AXCMD_TXOMI_SUBID;
 		cfg->param.txomi_cfg.omi = data[1];
+		cfg->param.txomi_cfg.tx_option = data[2];
+		cfg->param.txomi_cfg.num_data_pkts = data[3];
 		break;
 	case MLAN_11AXCMD_CFG_ID_OBSSNBRU_TOLTIME:
 		cfg->sub_id = MLAN_11AXCMD_OBSS_TOLTIME_SUBID;
@@ -599,7 +583,7 @@ static int woal_setget_priv_range_ext(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_RANGE_EXT;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -649,19 +633,20 @@ static int woal_setget_priv_range_ext(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_customie(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_customie(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
 {
 	int ret = 0;
 	t_u8 *data_ptr;
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
-	mlan_ds_misc_custom_ie *custom_ie = NULL;
+	mlan_ds_misc_custom_ie *pcustom_ie = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 	data_ptr = respbuf + (strlen(CMD_NXP) + strlen(PRIV_CMD_CUSTOMIE));
 
-	custom_ie = (mlan_ds_misc_custom_ie *)data_ptr;
+	pcustom_ie = (mlan_ds_misc_custom_ie *)data_ptr;
 	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
@@ -671,13 +656,13 @@ int woal_priv_customie(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_CUSTOM_IE;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
-	if ((custom_ie->len == 0) ||
-	    (custom_ie->len == sizeof(custom_ie->ie_data_list[0].ie_index)))
+	if ((pcustom_ie->len == 0) ||
+	    (pcustom_ie->len == sizeof(pcustom_ie->ie_data_list[0].ie_index)))
 		ioctl_req->action = MLAN_ACT_GET;
 	else
 		ioctl_req->action = MLAN_ACT_SET;
 
-	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, custom_ie,
+	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, pcustom_ie,
 			sizeof(mlan_ds_misc_custom_ie),
 			sizeof(mlan_ds_misc_custom_ie));
 
@@ -686,8 +671,8 @@ int woal_priv_customie(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		ret = -EFAULT;
 		goto done;
 	}
-	custom_ie = (mlan_ds_misc_custom_ie *)data_ptr;
-	moal_memcpy_ext(priv->phandle, custom_ie, &misc->param.cust_ie,
+	pcustom_ie = (mlan_ds_misc_custom_ie *)data_ptr;
+	moal_memcpy_ext(priv->phandle, pcustom_ie, &misc->param.cust_ie,
 			sizeof(mlan_ds_misc_custom_ie),
 			respbuflen -
 				(strlen(CMD_NXP) + strlen(PRIV_CMD_CUSTOMIE)));
@@ -712,8 +697,8 @@ int woal_priv_customie(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_bandcfg(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_setget_priv_bandcfg(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	int ret = 0;
 	unsigned int i;
@@ -770,6 +755,7 @@ int woal_setget_priv_bandcfg(moal_private *priv, t_u8 *respbuf,
 	} else {
 		/* To support only <b/bg/bgn/n/aac/gac> */
 		infra_band = data[0];
+
 		for (i = 0; i < (sizeof(SupportedInfraBand) /
 				 sizeof(SupportedInfraBand[0]));
 		     i++)
@@ -783,7 +769,9 @@ int woal_setget_priv_bandcfg(moal_private *priv, t_u8 *respbuf,
 		/* Set Adhoc band */
 		if (user_data_len >= 2) {
 			adhoc_band = data[1];
-			for (i = 0; i < sizeof(SupportedAdhocBand); i++)
+			for (i = 0; i < (sizeof(SupportedAdhocBand) /
+					 sizeof(SupportedAdhocBand[0]));
+			     i++)
 				if (adhoc_band == SupportedAdhocBand[i])
 					break;
 			if (i == sizeof(SupportedAdhocBand)) {
@@ -839,8 +827,8 @@ int woal_setget_priv_bandcfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_httxcfg(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_setget_priv_httxcfg(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	t_u32 data[2];
 	mlan_ioctl_req *req = NULL;
@@ -938,8 +926,8 @@ int woal_setget_priv_httxcfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_htcapinfo(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_setget_priv_htcapinfo(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	int data[2];
 	mlan_ioctl_req *req = NULL;
@@ -1040,8 +1028,8 @@ int woal_setget_priv_htcapinfo(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_addbapara(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_setget_priv_addbapara(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	int data[5];
 	mlan_ioctl_req *req = NULL;
@@ -1146,7 +1134,7 @@ int woal_setget_priv_addbapara(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_delba(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_delba(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 {
 	t_u32 data[2] = {0xFF, 0xFF};
 	mlan_ioctl_req *req = NULL;
@@ -1163,7 +1151,7 @@ int woal_priv_delba(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DELBA);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* Incorrect number of arguments */
 		PRINTM(MERROR, "%d: Invalid arguments\n", __LINE__);
 		ret = -EINVAL;
@@ -1224,7 +1212,8 @@ int woal_priv_delba(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		goto done;
 	}
 
-	ret = sprintf(respbuf, "OK. BA deleted successfully.\n") + 1;
+	ret = snprintf(respbuf, CMD_BUF_LEN, "OK. BA deleted successfully.\n") +
+	      1;
 
 done:
 	if (status != MLAN_STATUS_PENDING)
@@ -1242,8 +1231,8 @@ int woal_priv_delba(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_rejectaddbareq(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_rejectaddbareq(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	t_u32 data[1];
 	mlan_ioctl_req *req = NULL;
@@ -1298,11 +1287,11 @@ int woal_priv_rejectaddbareq(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 	if (req->action == MLAN_ACT_GET) {
-		sprintf(respbuf, "0x%x",
-			cfg_11n->param.reject_addba_req.conditions);
+		snprintf(respbuf, CMD_BUF_LEN, "0x%x",
+			 cfg_11n->param.reject_addba_req.conditions);
 		ret = strlen(respbuf) + 1;
 	} else {
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 
 done:
@@ -1322,8 +1311,8 @@ int woal_priv_rejectaddbareq(moal_private *priv, t_u8 *respbuf,
  *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
  * otherwise fail
  */
-mlan_status woal_ioctl_addba_reject(moal_private *priv, t_u32 action,
-				    t_u8 *addba_reject)
+static mlan_status woal_ioctl_addba_reject(moal_private *priv, t_u32 action,
+					   t_u8 *addba_reject)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
@@ -1423,8 +1412,8 @@ mlan_status woal_ioctl_aggr_prio_tbl(moal_private *priv, t_u32 action,
  *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
  * otherwise fail
  */
-mlan_status woal_ioctl_addba_param(moal_private *priv, t_u32 action,
-				   mlan_ds_11n_addba_param *addba_param)
+static mlan_status woal_ioctl_addba_param(moal_private *priv, t_u32 action,
+					  mlan_ds_11n_addba_param *addba_param)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
@@ -1472,7 +1461,8 @@ mlan_status woal_ioctl_addba_param(moal_private *priv, t_u32 action,
  *
  *  @return             0 --success, otherwise failure
  */
-int woal_set_rx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
+static int woal_set_rx_ba_winsize(moal_private *priv, t_u8 *respbuf,
+				  int respbuflen)
 {
 	int data[2];
 	t_u8 addba_reject[MAX_NUM_TID];
@@ -1530,7 +1520,7 @@ int woal_set_rx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
 			ret = -EFAULT;
 			goto done;
 		}
-		if (data[1] != addba_param.rxwinsize) {
+		if (data[1] != (int)addba_param.rxwinsize) {
 			addba_param.rxwinsize = data[1];
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_ioctl_addba_param(priv, MLAN_ACT_SET,
@@ -1551,7 +1541,8 @@ int woal_set_rx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
  *
  *  @return             0 --success, otherwise failure
  */
-int woal_set_tx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
+static int woal_set_tx_ba_winsize(moal_private *priv, t_u8 *respbuf,
+				  int respbuflen)
 {
 	int data[2];
 	mlan_ds_11n_aggr_prio_tbl aggr_prio_tbl;
@@ -1614,7 +1605,7 @@ int woal_set_tx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
 			ret = -EFAULT;
 			goto done;
 		}
-		if (data[1] != addba_param.txwinsize) {
+		if (data[1] != (int)addba_param.txwinsize) {
 			addba_param.txwinsize = data[1];
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_ioctl_addba_param(priv, MLAN_ACT_SET,
@@ -1636,8 +1627,8 @@ int woal_set_tx_ba_winsize(moal_private *priv, t_u8 *respbuf, int respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_aggrpriotbl(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_setget_priv_aggrpriotbl(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
 	int data[MAX_NUM_TID * 2], i, j;
 	mlan_ioctl_req *req = NULL;
@@ -1724,8 +1715,8 @@ int woal_setget_priv_aggrpriotbl(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_addbareject(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_setget_priv_addbareject(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
 	int data[MAX_NUM_TID], i;
 	mlan_ioctl_req *req = NULL;
@@ -1807,7 +1798,8 @@ int woal_setget_priv_addbareject(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_vhtcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_setget_priv_vhtcfg(moal_private *priv, t_u8 *respbuf,
+				   t_u32 respbuflen)
 {
 	int data[6];
 	mlan_ioctl_req *req = NULL;
@@ -1962,8 +1954,8 @@ int woal_setget_priv_vhtcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_opermodecfg(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_setget_priv_opermodecfg(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
 	int data[2];
 	mlan_ioctl_req *req = NULL;
@@ -2045,7 +2037,8 @@ int woal_setget_priv_opermodecfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_get_priv_datarate(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_get_priv_datarate(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_rate *rate = NULL;
@@ -2095,8 +2088,8 @@ int woal_get_priv_datarate(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	t_u32 data[4];
 	mlan_ioctl_req *req = NULL;
@@ -2206,7 +2199,7 @@ int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
 				       data[3]);
 
 /* HE Preamble type */
-#define HE_SU_PREAMBLE 0
+//#define HE_SU_PREAMBLE 0
 #define HE_ER_PREAMBLE 1
 
 /* HE ER SU Type */
@@ -2221,7 +2214,7 @@ int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
 						if (rate_setting->bandwidth ==
 						    HE_ER_SU_BANDWIDTH_TONE242) {
 							if ((data[1] >
-							     MLAN_RATE_INDEX_MCS4) ||
+							     MLAN_RATE_INDEX_MCS2) ||
 							    data[2] >
 								    MLAN_RATE_NSS1) {
 								PRINTM(MERROR,
@@ -2248,7 +2241,8 @@ int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
 							goto done;
 						}
 					}
-					if (rate_setting->dcm) {
+					if ((rate_setting->dcm) &&
+					    (rate_setting->stbc == 0)) {
 						if ((data[1] ==
 						     MLAN_RATE_INDEX_MCS2) ||
 						    (data[1] >
@@ -2308,7 +2302,6 @@ int woal_setget_priv_txratecfg(moal_private *priv, t_u8 *respbuf,
 mlan_status woal_get_stats_info(moal_private *priv, t_u8 wait_option,
 				mlan_ds_get_stats *stats)
 {
-	int ret = 0;
 	mlan_ds_get_info *info = NULL;
 	mlan_ioctl_req *req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -2317,7 +2310,7 @@ mlan_status woal_get_stats_info(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_get_info));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -2360,7 +2353,8 @@ mlan_status woal_get_stats_info(moal_private *priv, t_u8 wait_option,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_get_priv_getlog(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_get_priv_getlog(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
 {
 	int ret = 0;
 	mlan_ds_get_stats *stats;
@@ -2400,8 +2394,8 @@ int woal_get_priv_getlog(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_esuppmode(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_setget_priv_esuppmode(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	t_u32 data[3];
 	mlan_ioctl_req *req = NULL;
@@ -2490,8 +2484,8 @@ int woal_setget_priv_esuppmode(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_setget_priv_passphrase(moal_private *priv, t_u8 *respbuf,
-				t_u32 respbuflen)
+static int woal_setget_priv_passphrase(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
@@ -2648,34 +2642,36 @@ int woal_setget_priv_passphrase(moal_private *priv, t_u8 *respbuf,
 
 	memset(respbuf, 0, respbuflen);
 	if (sec->param.passphrase.ssid.ssid_len) {
-		len += sprintf(respbuf + len, "ssid:");
+		len += snprintf(respbuf + len, CMD_BUF_LEN, "ssid:");
 		moal_memcpy_ext(priv->phandle, respbuf + len,
 				sec->param.passphrase.ssid.ssid,
 				sec->param.passphrase.ssid.ssid_len,
 				respbuflen - len);
 		len += sec->param.passphrase.ssid.ssid_len;
-		len += sprintf(respbuf + len, " ");
+		len += snprintf(respbuf + len, CMD_BUF_LEN, " ");
 	}
 	if (memcmp(&sec->param.passphrase.bssid, zero_mac, sizeof(zero_mac))) {
 		mac = (t_u8 *)&sec->param.passphrase.bssid;
-		len += sprintf(respbuf + len, "bssid:");
+		len += snprintf(respbuf + len, CMD_BUF_LEN, "bssid:");
 		for (i = 0; i < ETH_ALEN - 1; ++i)
-			len += sprintf(respbuf + len, "%02x:", mac[i]);
-		len += sprintf(respbuf + len, "%02x ", mac[i]);
+			len += snprintf(respbuf + len, CMD_BUF_LEN,
+					"%02x:", mac[i]);
+		len += snprintf(respbuf + len, CMD_BUF_LEN, "%02x ", mac[i]);
 	}
 	if (sec->param.passphrase.psk_type == MLAN_PSK_PMK) {
-		len += sprintf(respbuf + len, "psk:");
+		len += snprintf(respbuf + len, CMD_BUF_LEN, "psk:");
 		for (i = 0; i < MLAN_MAX_KEY_LENGTH; ++i)
-			len += sprintf(respbuf + len, "%02x",
-				       sec->param.passphrase.psk.pmk.pmk[i]);
-		len += sprintf(respbuf + len, "\n");
+			len += snprintf(respbuf + len, CMD_BUF_LEN, "%02x",
+					sec->param.passphrase.psk.pmk.pmk[i]);
+		len += snprintf(respbuf + len, CMD_BUF_LEN, "\n");
 	}
 	if (sec->param.passphrase.psk_type == MLAN_PSK_PASSPHRASE)
-		len += sprintf(respbuf + len, "passphrase:%s\n",
-			       sec->param.passphrase.psk.passphrase.passphrase);
+		len += snprintf(
+			respbuf + len, CMD_BUF_LEN, "passphrase:%s\n",
+			sec->param.passphrase.psk.passphrase.passphrase);
 	if (sec->param.passphrase.psk_type == MLAN_PSK_SAE_PASSWORD)
-		len += sprintf(
-			respbuf + len, "sae_password:%s\n",
+		len += snprintf(
+			respbuf + len, CMD_BUF_LEN, "sae_password:%s\n",
 			sec->param.passphrase.psk.sae_password.sae_password);
 
 	ret = len;
@@ -2695,7 +2691,7 @@ int woal_setget_priv_passphrase(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_deauth(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_deauth(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 {
 	int ret = 0;
 	t_u8 mac[ETH_ALEN];
@@ -2804,7 +2800,8 @@ static int woal_priv_get_sta_list(moal_private *priv, t_u8 *respbuf,
 
 	/* Allocate an IOCTL request buffer */
 	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_get_info));
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
@@ -2825,9 +2822,10 @@ static int woal_priv_get_sta_list(moal_private *priv, t_u8 *respbuf,
 					strlen(PRIV_CMD_GET_STA_LIST));
 	moal_memcpy_ext(
 		priv->phandle, sta_list, &info->param.sta_list,
-		sizeof(mlan_ds_sta_list),
+		ioctl_req->data_read_written,
 		respbuflen - (strlen(CMD_NXP) + strlen(PRIV_CMD_GET_STA_LIST)));
-	ret = sizeof(mlan_ds_sta_list);
+	ret = ioctl_req->data_read_written + strlen(CMD_NXP) +
+	      strlen(PRIV_CMD_GET_STA_LIST);
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(ioctl_req);
@@ -2901,6 +2899,116 @@ static int woal_priv_bss_config(moal_private *priv, t_u8 *respbuf,
 }
 #endif
 
+#if defined(UAP_SUPPORT)
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+/**
+ *  @brief easymesh uap Set/Get multi AP mode handler
+ *
+ *  @param priv     A pointer to moal_private structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         0 --success, otherwise fail
+ */
+static int woal_uap_set_multiap_mode(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int mode[1] = {0};
+	int ret = 0;
+	int header_len = 0;
+	int user_data_len = 0;
+
+	ENTER();
+
+	if (!respbuf) {
+		PRINTM(MERROR, "response buffer is not available!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SETMODE);
+	user_data_len = strlen(respbuf) - header_len;
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_MULTI_AP_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, mode, ARRAY_SIZE(mode),
+				&user_data_len);
+		if (user_data_len > 1) {
+			PRINTM(MERROR, "Invalid number of args!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if ((mode[0] != EASY_MESH_MULTI_AP_BSS_MODE_3) &&
+		    (mode[0] != EASY_MESH_MULTI_AP_BSS_MODE_2) &&
+		    (mode[0] != EASY_MESH_MULTI_AP_BSS_MODE_1)) {
+			PRINTM(MERROR, "Invalid setmode value\n");
+			ret = -EINVAL;
+			goto done;
+		}
+
+		if (mode[0] == EASY_MESH_MULTI_AP_BSS_MODE_3)
+			/* Supports backhaul and fronthaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_BH_AND_FH_BSS;
+		else if (mode[0] == EASY_MESH_MULTI_AP_BSS_MODE_2)
+			/* Supports backhaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_BH_BSS;
+		else if (mode[0] == EASY_MESH_MULTI_AP_BSS_MODE_1)
+			/* Supports fronthaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_FH_BSS;
+		PRINTM(MINFO, "[EM:%s:%d] priv->multi_ap_flag 0x%x\n", __func__,
+		       __LINE__, priv->multi_ap_flag);
+
+		req->action = MLAN_ACT_SET;
+	}
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (req->action == MLAN_ACT_GET) {
+		if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_BH_AND_FH_BSS)
+			mode[0] = EASY_MESH_MULTI_AP_BSS_MODE_3;
+		else if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_BH_BSS)
+			mode[0] = EASY_MESH_MULTI_AP_BSS_MODE_2;
+		else if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_FH_BSS)
+			mode[0] = EASY_MESH_MULTI_AP_BSS_MODE_1;
+
+		PRINTM(MINFO, "[EM:%s:%d] setmode to 0x%x\n", __func__,
+		       __LINE__, mode[0]);
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)mode,
+				sizeof(mode), respbuflen);
+		ret = sizeof(mode);
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+#endif
+#endif
+
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 /**
@@ -2912,7 +3020,8 @@ static int woal_priv_bss_config(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_bssrole(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_bssrole(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
 {
 	t_u32 data[1];
 	int ret = 0;
@@ -2954,7 +3063,13 @@ int woal_priv_bssrole(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		}
 		action = MLAN_ACT_SET;
 		/* Reset interface */
-		woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE)) {
+			PRINTM(MERROR, "%s: woal_reset_intf failed \n",
+			       __func__);
+			ret = -EFAULT;
+			goto error;
+		}
 	}
 
 	if (MLAN_STATUS_SUCCESS !=
@@ -2993,27 +3108,36 @@ int woal_priv_bssrole(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_setuserscan(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_setuserscan(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
-	wlan_user_scan_cfg scan_cfg;
+	wlan_user_scan_cfg *scan_cfg;
 	int ret = 0;
 
 	ENTER();
 
+	scan_cfg = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_cfg) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
 	/* Create the scan_cfg structure */
-	memset(&scan_cfg, 0, sizeof(scan_cfg));
+	memset(scan_cfg, 0, sizeof(wlan_user_scan_cfg));
 
 	/* We expect the scan_cfg structure to be passed in respbuf */
-	moal_memcpy_ext(priv->phandle, (char *)&scan_cfg,
+	moal_memcpy_ext(priv->phandle, (char *)scan_cfg,
 			respbuf + strlen(CMD_NXP) +
 				strlen(PRIV_CMD_SETUSERSCAN),
 			sizeof(wlan_user_scan_cfg), sizeof(wlan_user_scan_cfg));
-	moal_memcpy_ext(priv->phandle, scan_cfg.random_mac, priv->random_mac,
+	moal_memcpy_ext(priv->phandle, scan_cfg->random_mac, priv->random_mac,
 			ETH_ALEN, MLAN_MAC_ADDR_LENGTH);
 	/* Call for scan */
-	if (MLAN_STATUS_FAILURE == woal_do_scan(priv, &scan_cfg))
+	if (MLAN_STATUS_FAILURE == woal_do_scan(priv, scan_cfg))
 		ret = -EFAULT;
-
+	kfree(scan_cfg);
 	LEAVE();
 	return ret;
 }
@@ -3027,7 +3151,8 @@ int woal_priv_setuserscan(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_get_chanstats(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_get_chanstats(moal_private *priv, t_u8 *respbuf,
+				   t_u32 respbuflen)
 {
 	mlan_scan_resp scan_resp;
 	chan_stats *stats = NULL;
@@ -3039,6 +3164,7 @@ int woal_priv_get_chanstats(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		ret = -EINVAL;
 		goto done;
 	}
+	mdelay(10);
 	memset(&scan_resp, 0, sizeof(scan_resp));
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_get_scan_table(priv, MOAL_IOCTL_WAIT, &scan_resp)) {
@@ -3067,8 +3193,9 @@ int woal_priv_get_chanstats(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-int moal_ret_get_scan_table_ioctl(t_u8 *respbuf, t_u32 respbuflen,
-				  mlan_scan_resp *scan_resp, t_u32 scan_start)
+static int moal_ret_get_scan_table_ioctl(t_u8 *respbuf, t_u32 respbuflen,
+					 mlan_scan_resp *scan_resp,
+					 t_u32 scan_start)
 {
 	pBSSDescriptor_t pbss_desc, scan_table;
 	wlan_ioctl_get_scan_table_info *prsp_info;
@@ -3129,7 +3256,7 @@ int moal_ret_get_scan_table_ioctl(t_u8 *respbuf, t_u32 respbuflen,
 	}
 
 	prsp_info->scan_number = num_scans_done;
-	ret_len = pcurrent - respbuf;
+	ret_len = (int)(pcurrent - respbuf);
 
 	LEAVE();
 	return ret_len;
@@ -3144,7 +3271,8 @@ int moal_ret_get_scan_table_ioctl(t_u8 *respbuf, t_u32 respbuflen,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_getscantable(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_getscantable(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
 	int ret = 0;
 	mlan_ioctl_req *req = NULL;
@@ -3205,7 +3333,8 @@ int woal_priv_getscantable(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_extcapcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_extcapcfg(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
 {
 	int ret, header;
 	mlan_ioctl_req *req = NULL;
@@ -3230,7 +3359,7 @@ int woal_priv_extcapcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	cfg->sub_command = MLAN_OID_MISC_EXT_CAP_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
 	header = strlen(CMD_NXP) + strlen(PRIV_CMD_EXTCAPCFG);
-	if (strlen(respbuf) == header)
+	if ((int)strlen(respbuf) == header)
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 	else {
@@ -3281,8 +3410,8 @@ int woal_priv_extcapcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_setgetdeepsleep(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static int woal_priv_setgetdeepsleep(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
 	t_u32 data[2];
 	int ret = 0;
@@ -3312,7 +3441,7 @@ int woal_priv_setgetdeepsleep(moal_private *priv, t_u8 *respbuf,
 			ret = -EFAULT;
 			goto done;
 		}
-		sprintf(respbuf, "%d %d", data[0], data[1]);
+		snprintf(respbuf, CMD_BUF_LEN, "%d %d", data[0], data[1]);
 		ret = strlen(respbuf) + 1;
 	} else {
 		if (data[0] == DEEP_SLEEP_OFF) {
@@ -3338,7 +3467,7 @@ int woal_priv_setgetdeepsleep(moal_private *priv, t_u8 *respbuf,
 			ret = -EINVAL;
 			goto done;
 		}
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 
 done:
@@ -3355,7 +3484,8 @@ int woal_priv_setgetdeepsleep(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_setgetipaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_setgetipaddr(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -3367,7 +3497,7 @@ int woal_priv_setgetipaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	if (priv->bss_type != MLAN_BSS_TYPE_STA) {
 		PRINTM(MIOCTL, "Bss type[%d]: Not STA, ignore it\n",
 		       priv->bss_type);
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 		goto done;
 	}
 
@@ -3430,7 +3560,7 @@ int woal_priv_setgetipaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 			 misc->param.ipaddr_cfg.ip_addr[0][3]);
 		ret = IPADDR_MAX_BUF + 1;
 	} else {
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 
 done:
@@ -3449,7 +3579,8 @@ int woal_priv_setgetipaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_setwpssession(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_setwpssession(moal_private *priv, t_u8 *respbuf,
+				   t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_wps_cfg *pwps = NULL;
@@ -3500,7 +3631,7 @@ int woal_priv_setwpssession(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		goto done;
 	}
 
-	ret = sprintf(respbuf, "OK\n") + 1;
+	ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
@@ -3517,7 +3648,8 @@ int woal_priv_setwpssession(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_otpuserdata(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_otpuserdata(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
 	int data[1];
 	int user_data_len = 0;
@@ -3587,8 +3719,8 @@ int woal_priv_otpuserdata(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_set_get_countrycode(moal_private *priv, t_u8 *respbuf,
-				  t_u32 respbuflen)
+static int woal_priv_set_get_countrycode(moal_private *priv, t_u8 *respbuf,
+					 t_u32 respbuflen)
 {
 	int ret = 0;
 	/* char data[COUNTRY_CODE_LEN] = {0, 0, 0}; */
@@ -3655,6 +3787,53 @@ int woal_priv_set_get_countrycode(moal_private *priv, t_u8 *respbuf,
 	return ret;
 }
 
+/**
+ *  @brief Get country code
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param country      A pointer to country string
+ *
+ *  @return             0--success, otherwise failure
+ */
+static int woal_get_countrycode(moal_private *priv, t_u8 *country)
+{
+	int ret = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *pcfg_misc = NULL;
+	mlan_ds_misc_country_code *country_code = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	pcfg_misc = (mlan_ds_misc_cfg *)req->pbuf;
+	country_code = &pcfg_misc->param.country_code;
+	pcfg_misc->sub_command = MLAN_OID_MISC_COUNTRY_CODE;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_GET;
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, country, country_code->country_code,
+			COUNTRY_CODE_LEN, COUNTRY_CODE_LEN);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Get cfp information
  *
@@ -3664,13 +3843,13 @@ int woal_priv_set_get_countrycode(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_get_cfpinfo(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_get_cfpinfo(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
 	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *cfp_misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
-	int header = 0, data_length = 0;
 
 	ENTER();
 
@@ -3679,8 +3858,6 @@ int woal_priv_get_cfpinfo(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		ret = -EINVAL;
 		goto done;
 	}
-	header = strlen(CMD_NXP) + strlen(PRIV_CMD_CFPINFO);
-	data_length = strlen(respbuf) - header;
 
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
@@ -3726,14 +3903,19 @@ int woal_priv_get_cfpinfo(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_setgettcpackenh(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static int woal_priv_setgettcpackenh(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
-	t_u32 data[1];
+	t_u32 data[2] = {0, 0};
 	int ret = 0;
 	int user_data_len = 0;
 
 	ENTER();
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
 
 	if (strlen(respbuf) == (strlen(CMD_NXP) + strlen(PRIV_CMD_TCPACKENH))) {
 		/* GET operation */
@@ -3746,17 +3928,25 @@ int woal_priv_setgettcpackenh(moal_private *priv, t_u8 *respbuf,
 				data, ARRAY_SIZE(data), &user_data_len);
 	}
 
-	if (user_data_len >= 2) {
-		PRINTM(MERROR, "Too many arguments\n");
-		ret = -EINVAL;
-		goto done;
-	}
-
 	if (user_data_len == 0) {
 		/* get operation */
-		respbuf[0] = priv->enable_tcp_ack_enh;
+		data[0] = priv->enable_tcp_ack_enh;
+		data[1] = priv->tcp_ack_max_hold;
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+				sizeof(data), respbuflen);
+		ret = sizeof(data);
 	} else {
 		/* set operation */
+		if (user_data_len >= 3) {
+			PRINTM(MERROR, "Too many arguments\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data[0] > 1 || data[1] > TCP_ACK_MAX_HOLD) {
+			PRINTM(MERROR, "Invalid argument\n");
+			ret = -EINVAL;
+			goto done;
+		}
 		if (data[0] == MTRUE) {
 			PRINTM(MINFO, "Enabling TCP Ack enhancement\n");
 			priv->enable_tcp_ack_enh = MTRUE;
@@ -3765,14 +3955,17 @@ int woal_priv_setgettcpackenh(moal_private *priv, t_u8 *respbuf,
 			priv->enable_tcp_ack_enh = MFALSE;
 			/* release the tcp sessions if any */
 			woal_flush_tcp_sess_queue(priv);
-		} else {
-			PRINTM(MERROR, "Unknown option = %u\n", data[0]);
-			ret = -EINVAL;
-			goto done;
 		}
-		respbuf[0] = priv->enable_tcp_ack_enh;
+		if (user_data_len >= 2) {
+			PRINTM(MINFO, "TCP drop Ack configure: %d\n", data[1]);
+			priv->tcp_ack_max_hold = data[1];
+		}
+		data[0] = priv->enable_tcp_ack_enh;
+		data[1] = priv->tcp_ack_max_hold;
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+				sizeof(data), respbuflen);
+		ret = sizeof(data);
 	}
-	ret = 1;
 
 done:
 	LEAVE();
@@ -3790,8 +3983,8 @@ int woal_priv_setgettcpackenh(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
-			 t_u8 bBSSID)
+static int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen, t_u8 bBSSID)
 {
 	mlan_ssid_bssid ssid_bssid;
 	moal_handle *handle = priv->phandle;
@@ -3810,14 +4003,14 @@ int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 	else
 		header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ASSOCESSID);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		PRINTM(MERROR, "No argument, invalid operation!\n");
 		ret = -EINVAL;
 		LEAVE();
 		return ret;
 	}
 	copy_len = strlen(respbuf) - header_len;
-	buflen = MIN(copy_len, (sizeof(buf) - 1));
+	buflen = MIN(copy_len, (int)(sizeof(buf) - 1));
 	memset(buf, 0, sizeof(buf));
 	memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
 	moal_memcpy_ext(handle, buf, respbuf + header_len, buflen, sizeof(buf));
@@ -3893,20 +4086,27 @@ int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 
 	if (MTRUE == woal_is_connected(priv, &ssid_bssid)) {
 		PRINTM(MIOCTL, "Already connect to the network\n");
-		ret = sprintf(respbuf,
-			      "Has already connected to this ESSID!\n") +
+		ret = snprintf(respbuf, CMD_BUF_LEN,
+			       "Has already connected to this ESSID!\n") +
 		      1;
 		goto setessid_ret;
 	}
 	moal_memcpy_ext(handle, &priv->prev_ssid_bssid, &ssid_bssid,
 			sizeof(mlan_ssid_bssid), sizeof(mlan_ssid_bssid));
-	/* disconnect before driver assoc */
-	woal_disconnect(priv, MOAL_IOCTL_WAIT, NULL, DEF_DEAUTH_REASON_CODE);
-	priv->set_asynced_essid_flag = MTRUE;
+	priv->auto_assoc_priv.drv_reconnect.status = MFALSE;
+	priv->auto_assoc_priv.auto_assoc_trigger_flag =
+		AUTO_ASSOC_TYPE_DRV_ASSOC;
+	priv->auto_assoc_priv.drv_assoc.status = MTRUE;
+	if (priv->auto_assoc_priv.auto_assoc_type_on &
+	    (0x1 << (AUTO_ASSOC_TYPE_DRV_ASSOC - 1))) {
+		PRINTM(MINFO, " auto assoc: trigger driver auto re-assoc\n");
+	} else {
+		PRINTM(MINFO, " Set Asynced ESSID: trigger auto re-assoc\n");
+	}
 	priv->reassoc_required = MTRUE;
 	priv->phandle->is_reassoc_timer_set = MTRUE;
 	woal_mod_timer(&priv->phandle->reassoc_timer, 0);
-	ret = sprintf(respbuf, "%s\n", buf) + 1;
+	ret = snprintf(respbuf, CMD_BUF_LEN, "%s\n", buf) + 1;
 
 setessid_ret:
 	if (priv->scan_type == MLAN_SCAN_TYPE_PASSIVE)
@@ -3918,7 +4118,7 @@ int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 #endif
 
 /**
- *  @brief Get wakeup reason
+ *  @brief Set/Get deep auto assoc configurations
  *
  *  @param priv         A pointer to moal_private structure
  *  @param respbuf      A pointer to response buffer
@@ -3926,25 +4126,350 @@ int woal_priv_assocessid(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_getwakeupreason(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static int woal_priv_setgetautoassoc(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
+#ifdef REASSOCIATION
+	moal_handle *handle = priv->phandle;
+#endif
 	mlan_ioctl_req *req = NULL;
-	mlan_ds_pm_cfg *pm_cfg = NULL;
-	t_u32 data;
+	mlan_ds_misc_cfg *misc = NULL;
+	t_u32 data[5];
 	int ret = 0;
+	int user_data_len = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	if (strlen(respbuf) ==
-	    (strlen(CMD_NXP) + strlen(PRIV_CMD_WAKEUPREASON))) {
-		/* GET operation */
-		req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_pm_cfg));
-		if (req == NULL) {
-			LEAVE();
-			return -ENOMEM;
-		}
+	if (strlen(respbuf) == (strlen(CMD_NXP) + strlen(PRIV_CMD_AUTOASSOC))) {
+		PRINTM(MERROR, "No argument, invalid operation!\n");
+		ret = -EINVAL;
+		goto done;
+	} else {
+		/* GET/SET operation */
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(respbuf + strlen(CMD_NXP) +
+					strlen(PRIV_CMD_AUTOASSOC),
+				data, ARRAY_SIZE(data), &user_data_len);
+	}
+
+	if (sizeof(t_u32) * user_data_len > sizeof(data)) {
+		PRINTM(MERROR, "Too many arguments\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (data[0] != AUTO_ASSOC_TYPE_DRV_ASSOC &&
+	    data[0] != AUTO_ASSOC_TYPE_DRV_RECONN &&
+	    data[0] != AUTO_ASSOC_TYPE_FW_RECONN) {
+		PRINTM(MERROR, "Invalid auto assoc type option = %u\n",
+		       data[0]);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (user_data_len == 1) {
+		/* Get operation */
+		if (data[0] == AUTO_ASSOC_TYPE_FW_RECONN) {
+			/* Get fw auto re-connect parameters */
+			req = woal_alloc_mlan_ioctl_req(
+				sizeof(mlan_ds_misc_cfg));
+			if (req == NULL) {
+				LEAVE();
+				return -ENOMEM;
+			}
+
+			misc = (mlan_ds_misc_cfg *)req->pbuf;
+			misc->sub_command = MLAN_OID_MISC_AUTO_ASSOC;
+			req->req_id = MLAN_IOCTL_MISC_CFG;
+			req->action = MLAN_ACT_GET;
+
+			status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+			if (status != MLAN_STATUS_SUCCESS) {
+				ret = -EFAULT;
+				if (status != MLAN_STATUS_PENDING)
+					kfree(req);
+				goto done;
+			} else {
+				data[2] = misc->param.fw_auto_reconnect
+						  .fw_reconn_counter;
+				if (data[2] == 0) {
+					data[1] = 0;
+					snprintf(respbuf, CMD_BUF_LEN, "%d %d",
+						 data[0], data[1]);
+					ret = strlen(respbuf) + 1;
+				} else {
+					data[1] = 1;
+					data[3] = misc->param.fw_auto_reconnect
+							  .fw_reconn_interval;
+					data[4] = misc->param.fw_auto_reconnect
+							  .fw_reconn_flags;
+					snprintf(respbuf, CMD_BUF_LEN,
+						 "%d %d 0x%x 0x%x 0x%x",
+						 data[0], data[1], data[2],
+						 data[3], data[4]);
+					ret = strlen(respbuf) + 1;
+				}
+				kfree(req);
+			}
+		} else {
+			if (priv->auto_assoc_priv.auto_assoc_type_on &
+			    (0x1 << (data[0] - 1))) {
+				data[1] = 1;
+				if (data[0] == AUTO_ASSOC_TYPE_DRV_RECONN) {
+					/* Get driver auto re-connect parameters
+					 */
+					data[2] = priv->auto_assoc_priv
+							  .drv_reconnect
+							  .retry_count;
+					data[3] = priv->auto_assoc_priv
+							  .drv_reconnect
+							  .retry_interval;
+				} else {
+					/* Get driver auto assoc parameters */
+					data[2] =
+						priv->auto_assoc_priv.drv_assoc
+							.retry_count;
+					data[3] =
+						priv->auto_assoc_priv.drv_assoc
+							.retry_interval;
+				}
+				snprintf(respbuf, CMD_BUF_LEN,
+					 "%d %d 0x%x 0x%x", data[0], data[1],
+					 data[2], data[3]);
+				ret = strlen(respbuf) + 1;
+			} else {
+				data[1] = 0;
+				snprintf(respbuf, CMD_BUF_LEN, "%d %d", data[0],
+					 data[1]);
+				ret = strlen(respbuf) + 1;
+			}
+		}
+	} else {
+		/* Set operation */
+		if (data[1] == MFALSE) {
+			/* Set Disable */
+			if (user_data_len > 2) {
+				PRINTM(MERROR,
+				       "Invalid number of arguments for setting Disable\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			priv->auto_assoc_priv.auto_assoc_type_on &=
+				~(0x1 << (data[0] - 1));
+		} else if (data[1] == MTRUE) {
+			/* Set Enable */
+			if (user_data_len > 2) {
+				if (data[2] == 0 || data[2] > 0xFF) {
+					PRINTM(MERROR,
+					       "Invalid auto assoc retry count option = %u\n",
+					       data[2]);
+					ret = -EINVAL;
+					goto done;
+				}
+				if (user_data_len > 3) {
+					if (data[3] > 0xFF) {
+						PRINTM(MERROR,
+						       "Invalid auto assoc interval option = %u\n",
+						       data[3]);
+						ret = -EINVAL;
+						goto done;
+					}
+				} else {
+					data[3] = 0xa; /* Default retry
+							  interval: 10 seconds
+							*/
+				}
+			} else {
+				data[2] = 0xff; /* Default retry count: retry
+						   forever */
+				data[3] = 0xa; /* Default retry interval: 10
+						  seconds */
+			}
+			priv->auto_assoc_priv.auto_assoc_type_on |=
+				0x1 << (data[0] - 1);
+		} else {
+			PRINTM(MERROR,
+			       "Invalid auto assoc on/off option = %u\n",
+			       data[1]);
+			ret = -EINVAL;
+			goto done;
+		}
+
+		if (data[0] == AUTO_ASSOC_TYPE_FW_RECONN) {
+			/* Set fw auto re-connect operation */
+			if (user_data_len == 5) {
+				if (data[4] > 0x1) {
+					PRINTM(MERROR,
+					       "Invalid fw auto re-connect flag option = %u\n",
+					       data[4]);
+					ret = -EINVAL;
+					goto done;
+				}
+			} else {
+				data[4] = 0; /* Default fw auto re-connect flags
+					      */
+			}
+			req = woal_alloc_mlan_ioctl_req(
+				sizeof(mlan_ds_misc_cfg));
+			if (req == NULL) {
+				LEAVE();
+				return -ENOMEM;
+			}
+
+			misc = (mlan_ds_misc_cfg *)req->pbuf;
+			misc->sub_command = MLAN_OID_MISC_AUTO_ASSOC;
+			req->req_id = MLAN_IOCTL_MISC_CFG;
+			req->action = MLAN_ACT_SET;
+
+			if (data[1] == MFALSE) {
+				/* Set fw auto re-connect Disable */
+				misc->param.fw_auto_reconnect.fw_reconn_counter =
+					0;
+				misc->param.fw_auto_reconnect
+					.fw_reconn_interval = 0;
+				misc->param.fw_auto_reconnect.fw_reconn_flags =
+					0;
+			} else {
+				/* Set fw auto re-connect Enable */
+				misc->param.fw_auto_reconnect.fw_reconn_counter =
+					data[2];
+				misc->param.fw_auto_reconnect
+					.fw_reconn_interval = data[3];
+				misc->param.fw_auto_reconnect.fw_reconn_flags =
+					data[4];
+			}
+
+			status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+			if (status != MLAN_STATUS_SUCCESS) {
+				ret = -EFAULT;
+				if (status != MLAN_STATUS_PENDING)
+					kfree(req);
+				goto done;
+			} else {
+				kfree(req);
+			}
+		} else {
+			if (user_data_len == 5) {
+				PRINTM(MERROR,
+				       "The fifth parameter is only used for FW auto re-connect!\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			if (data[0] == AUTO_ASSOC_TYPE_DRV_RECONN) {
+				/* Set driver auto re-connect operation */
+				if (data[1] == MFALSE) {
+					if (!(priv->auto_assoc_priv
+						      .auto_assoc_type_on &
+					      (0x1
+					       << (AUTO_ASSOC_TYPE_DRV_ASSOC -
+						   1)))) {
+						priv->auto_assoc_priv
+							.drv_reconnect.status =
+							MFALSE;
+#ifdef REASSOCIATION
+						handle->reassoc_on &=
+							~MBIT(priv->bss_index);
+						priv->reassoc_on = MFALSE;
+						priv->reassoc_required = MFALSE;
+						if (!handle->reassoc_on &&
+						    handle->is_reassoc_timer_set ==
+							    MTRUE) {
+							woal_cancel_timer(
+								&handle->reassoc_timer);
+							handle->is_reassoc_timer_set =
+								MFALSE;
+						}
+#endif
+					}
+				}
+#ifdef REASSOCIATION
+				else {
+					handle->reassoc_on |=
+						MBIT(priv->bss_index);
+					priv->reassoc_on = MTRUE;
+				}
+#endif
+				priv->auto_assoc_priv.drv_reconnect.retry_count =
+					data[2];
+				priv->auto_assoc_priv.drv_reconnect
+					.retry_interval = data[3];
+			}
+			if (data[0] == AUTO_ASSOC_TYPE_DRV_ASSOC) {
+				/* Set driver auto assoc operation */
+				if (data[1] == MFALSE) {
+					if (!(priv->auto_assoc_priv
+						      .auto_assoc_type_on &
+					      (0x1
+					       << (AUTO_ASSOC_TYPE_DRV_RECONN -
+						   1)))) {
+						priv->auto_assoc_priv.drv_assoc
+							.status = MFALSE;
+#ifdef REASSOCIATION
+						handle->reassoc_on &=
+							~MBIT(priv->bss_index);
+						priv->reassoc_on = MFALSE;
+						priv->reassoc_required = MFALSE;
+						if (!handle->reassoc_on &&
+						    handle->is_reassoc_timer_set ==
+							    MTRUE) {
+							woal_cancel_timer(
+								&handle->reassoc_timer);
+							handle->is_reassoc_timer_set =
+								MFALSE;
+						}
+#endif
+					}
+				}
+#ifdef REASSOCIATION
+				else {
+					handle->reassoc_on |=
+						MBIT(priv->bss_index);
+					priv->reassoc_on = MTRUE;
+				}
+#endif
+				priv->auto_assoc_priv.drv_assoc.retry_count =
+					data[2];
+				priv->auto_assoc_priv.drv_assoc.retry_interval =
+					data[3];
+			}
+		}
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get wakeup reason
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_getwakeupreason(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_pm_cfg *pm_cfg = NULL;
+	t_u32 data;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (strlen(respbuf) ==
+	    (strlen(CMD_NXP) + strlen(PRIV_CMD_WAKEUPREASON))) {
+		/* GET operation */
+		req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_pm_cfg));
+		if (req == NULL) {
+			LEAVE();
+			return -ENOMEM;
+		}
 
 		pm_cfg = (mlan_ds_pm_cfg *)req->pbuf;
 		pm_cfg->sub_command = MLAN_OID_PM_HS_WAKEUP_REASON;
@@ -3959,7 +4484,7 @@ int woal_priv_getwakeupreason(moal_private *priv, t_u8 *respbuf,
 			goto done;
 		} else {
 			data = pm_cfg->param.wakeup_reason.hs_wakeup_reason;
-			sprintf(respbuf, " %d", data);
+			snprintf(respbuf, CMD_BUF_LEN, " %d", data);
 			ret = strlen(respbuf) + 1;
 			kfree(req);
 		}
@@ -3984,8 +4509,8 @@ int woal_priv_getwakeupreason(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_set_get_listeninterval(moal_private *priv, t_u8 *respbuf,
-				     t_u32 respbuflen)
+static int woal_priv_set_get_listeninterval(moal_private *priv, t_u8 *respbuf,
+					    t_u32 respbuflen)
 {
 	int data[1];
 	int user_data_len = 0;
@@ -4040,10 +4565,11 @@ int woal_priv_set_get_listeninterval(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 	if (req->action == MLAN_ACT_GET) {
-		sprintf(respbuf, "%d", pcfg_bss->param.listen_interval);
+		snprintf(respbuf, CMD_BUF_LEN, "%d",
+			 pcfg_bss->param.listen_interval);
 		ret = strlen(respbuf) + 1;
 	} else {
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 
 done:
@@ -4065,8 +4591,8 @@ int woal_priv_set_get_listeninterval(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_set_get_drvdbg(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_set_get_drvdbg(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	int data[4];
 	int user_data_len = 0;
@@ -4163,7 +4689,8 @@ int woal_priv_set_get_drvdbg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_mgmt_filter(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_mgmt_filter(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_pm_cfg *pm_cfg = NULL;
@@ -4193,15 +4720,15 @@ int woal_priv_mgmt_filter(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 
 	header_len = strlen(PRIV_CMD_MGMT_FILTER) + strlen(CMD_NXP);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		action = MLAN_ACT_GET;
 	} else {
 		/* SET operation */
 		argument = (t_u8 *)(respbuf + header_len);
 		data_len = respbuflen - header_len;
-		if (data_len >
-		    MAX_MGMT_FRAME_FILTER * sizeof(mlan_mgmt_frame_wakeup)) {
+		if (data_len > (int)(MAX_MGMT_FRAME_FILTER *
+				     sizeof(mlan_mgmt_frame_wakeup))) {
 			PRINTM(MERROR, "%d: Invalid arguments\n", __LINE__);
 			ret = -EINVAL;
 			goto done;
@@ -4230,6 +4757,7 @@ int woal_priv_mgmt_filter(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 #define PARAMETER_GPIO_INDICATION 1
 #define PARAMETER_EXTEND_HSCFG 2
 #define PARAMETER_HS_WAKEUP_INTERVAL 3
+#define PARAMETER_MIN_WAKE_HOLDOFF 4
 /**
  *  @brief Set/Get Host Sleep configuration
  *
@@ -4240,10 +4768,10 @@ int woal_priv_mgmt_filter(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
-		    BOOLEAN invoke_hostcmd)
+static int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
+			   BOOLEAN invoke_hostcmd)
 {
-	int data[13] = {0};
+	int data[15] = {0};
 	int *temp_data, type;
 	int user_data_len = 0;
 	int ret = 0;
@@ -4293,7 +4821,7 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 	if (user_data_len == 0) {
 		action = MLAN_ACT_GET;
 	} else {
-		if (user_data_len >= 1 && user_data_len <= 13) {
+		if (user_data_len >= 1 && user_data_len <= 15) {
 			action = MLAN_ACT_SET;
 		} else {
 			PRINTM(MERROR, "Invalid arguments\n");
@@ -4303,10 +4831,14 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 	}
 
 	/* HS config is blocked if HS is already activated */
-	if (user_data_len &&
-	    (data[0] != HOST_SLEEP_CFG_CANCEL || invoke_hostcmd == MFALSE)) {
+	if (user_data_len && (data[0] != (int)HOST_SLEEP_CFG_CANCEL ||
+			      invoke_hostcmd == MFALSE)) {
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		ret = woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (ret != MLAN_STATUS_SUCCESS) {
+			ret = -EFAULT;
+			goto done;
+		}
 		if (bss_info.is_hs_configured) {
 			PRINTM(MERROR, "HS already configured\n");
 			ret = -EFAULT;
@@ -4316,8 +4848,11 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 
 	/* Do a GET first if some arguments are not provided */
 	if (user_data_len >= 1 && user_data_len < 11) {
-		woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
-				       &hscfg_temp);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
+					   &hscfg_temp)) {
+			PRINTM(MERROR, "Unable to get HS params\n");
+		}
 	}
 	hscfg.conditions = hscfg_temp.conditions;
 	hscfg.gpio = hscfg_temp.gpio;
@@ -4399,6 +4934,18 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 				user_data_len = user_data_len - 2;
 				temp_data++;
 				break;
+			case PARAMETER_MIN_WAKE_HOLDOFF:
+				if (user_data_len >= 2)
+					hscfg.min_wake_holdoff = *(++temp_data);
+				else {
+					PRINTM(MERROR,
+					       "Invaild number of parameters\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				user_data_len = user_data_len - 2;
+				temp_data++;
+				break;
 			default:
 				PRINTM(MERROR, "Unsupported type\n");
 				ret = -EINVAL;
@@ -4435,6 +4982,43 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
 	return ret;
 }
 
+/**
+ *  @brief Process Set Host Sleep parameters from proc buffer
+ *
+ *  @param handle       A pointer to moal_handle structure
+ *  @param pbuf         A pointer to buffer for host sleep parameters
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             0 --success, otherwise fail
+ */
+int woal_process_proc_hssetpara(moal_handle *handle, t_u8 *buf)
+{
+	int data[15] = {0};
+	int user_data_len = 0;
+	int ret = 0;
+	t_u8 respbuf[500];
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+
+	ENTER();
+	if (!priv) {
+		LEAVE();
+		return ret;
+	}
+	memset((char *)data, 0, sizeof(data));
+	parse_arguments(buf, data, ARRAY_SIZE(data), &user_data_len);
+	if (sizeof(int) * user_data_len > sizeof(data)) {
+		PRINTM(MERROR, "Too many arguments\n");
+		LEAVE();
+		return -EINVAL;
+	}
+	if (user_data_len >= 1 && user_data_len <= 15) {
+		snprintf(respbuf, 500, "%s%s%s", CMD_NXP, PRIV_CMD_HSCFG, buf);
+		ret = woal_priv_hscfg(priv, respbuf, sizeof(respbuf), MFALSE);
+	}
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Set Host Sleep parameters
  *
@@ -4444,9 +5028,10 @@ int woal_priv_hscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen,
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_hssetpara(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_hssetpara(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
 {
-	int data[13] = {0};
+	int data[15] = {0};
 	int user_data_len = 0;
 	int ret = 0;
 
@@ -4470,10 +5055,11 @@ int woal_priv_hssetpara(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		return -EINVAL;
 	}
 
-	if (user_data_len >= 1 && user_data_len <= 13) {
-		sprintf(respbuf, "%s%s%s", CMD_NXP, PRIV_CMD_HSCFG,
-			respbuf +
-				(strlen(CMD_NXP) + strlen(PRIV_CMD_HSSETPARA)));
+	if (user_data_len >= 1 && user_data_len <= 15) {
+		snprintf(respbuf, CMD_BUF_LEN, "%s%s%s", CMD_NXP,
+			 PRIV_CMD_HSCFG,
+			 respbuf + (strlen(CMD_NXP) +
+				    strlen(PRIV_CMD_HSSETPARA)));
 		respbuflen = strlen(respbuf);
 		ret = woal_priv_hscfg(priv, respbuf, respbuflen, MFALSE);
 		goto done;
@@ -4492,8 +5078,8 @@ int woal_priv_hssetpara(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  * @return         0 --success, otherwise fail
  */
-int woal_priv_set_get_scancfg(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static int woal_priv_set_get_scancfg(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
 	int ret = 0;
 	int user_data_len = 0;
@@ -4532,55 +5118,62 @@ int woal_priv_set_get_scancfg(moal_private *priv, t_u8 *respbuf,
 	req->req_id = MLAN_IOCTL_SCAN;
 
 	if (user_data_len) {
-		if ((data[0] < 0) || (data[0] > MLAN_SCAN_TYPE_PASSIVE)) {
+		moal_memcpy_ext(priv->phandle, &scan->param.scan_cfg, data,
+				sizeof(data), sizeof(scan->param.scan_cfg));
+		if (scan->param.scan_cfg.scan_type > MLAN_SCAN_TYPE_PASSIVE) {
 			PRINTM(MERROR, "Invalid argument for scan type\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[1] < 0) || (data[1] > MLAN_SCAN_MODE_ANY)) {
+		if (scan->param.scan_cfg.scan_mode > MLAN_SCAN_MODE_ANY) {
 			PRINTM(MERROR, "Invalid argument for scan mode\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[2] < 0) || (data[2] > MAX_PROBES)) {
+		if (scan->param.scan_cfg.scan_probe > MAX_PROBES) {
 			PRINTM(MERROR, "Invalid argument for scan probes\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if (((data[3] < 0) ||
-		     (data[3] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME)) ||
-		    ((data[4] < 0) ||
-		     (data[4] > MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME)) ||
-		    ((data[5] < 0) ||
-		     (data[5] > MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME))) {
+		if ((scan->param.scan_cfg.scan_time.specific_scan_time >
+		     MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) ||
+		    (scan->param.scan_cfg.scan_time.active_scan_time >
+		     MRVDRV_MAX_ACTIVE_SCAN_CHAN_TIME) ||
+		    (scan->param.scan_cfg.scan_time.passive_scan_time >
+		     MRVDRV_MAX_PASSIVE_SCAN_CHAN_TIME)) {
 			PRINTM(MERROR, "Invalid argument for scan time\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[6] < 0) || (data[6] > MLAN_PASS_TO_ACT_SCAN_DIS)) {
+		if (scan->param.scan_cfg.passive_to_active_scan >
+		    MLAN_PASS_TO_ACT_SCAN_DIS) {
 			PRINTM(MERROR,
 			       "Invalid argument for Passive to Active Scan\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[7] < 0) || (data[7] > 3)) {
+		if (scan->param.scan_cfg.ext_scan > MLAN_EXT_SCAN_ENH) {
 			PRINTM(MERROR, "Invalid argument for extended scan\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[8] < 0) ||
-		    (data[8] > MRVDRV_MAX_SCAN_CHAN_GAP_TIME)) {
+		if (scan->param.scan_cfg.scan_chan_gap >
+		    MRVDRV_MAX_SCAN_CHAN_GAP_TIME) {
 			PRINTM(MERROR,
 			       "Invalid argument for scan channel gap\n");
 			ret = -EINVAL;
 			goto done;
 		}
+
 		req->action = MLAN_ACT_SET;
 		moal_memcpy_ext(priv->phandle, &scan->param.scan_cfg, data,
 				sizeof(data), sizeof(scan->param.scan_cfg));
 	} else
 		req->action = MLAN_ACT_GET;
-
+	if (scan->param.scan_cfg.scan_time.specific_scan_time &&
+	    req->action == MLAN_ACT_SET) {
+		priv->phandle->user_scan_cfg = MTRUE;
+	}
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
@@ -4605,7 +5198,8 @@ int woal_priv_set_get_scancfg(moal_private *priv, t_u8 *respbuf,
  *
  * @return         Number of bytes written, negative for failure.
  */
-int woal_priv_getnlnum(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_getnlnum(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
 {
 	int ret = 0;
 	int data = 0;
@@ -4637,8 +5231,8 @@ int woal_priv_getnlnum(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_set_get_aggrctrl(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_set_get_aggrctrl(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	int data[1];
 	int user_data_len = 0;
@@ -4733,8 +5327,8 @@ int woal_priv_set_get_aggrctrl(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_set_get_usbaggrctrl(moal_private *priv, t_u8 *respbuf,
-				  t_u32 respbuflen)
+static int woal_priv_set_get_usbaggrctrl(moal_private *priv, t_u8 *respbuf,
+					 t_u32 respbuflen)
 {
 	int data[8];
 	int user_data_len = 0;
@@ -4938,7 +5532,7 @@ int woal_priv_set_get_usbaggrctrl(moal_private *priv, t_u8 *respbuf,
 	/* Keep a copy of the latest Tx aggregation parameters in MOAL */
 	moal_memcpy_ext(handle, &cardp->tx_aggr_ctrl,
 			&pcfg_misc->param.usb_aggr_params.tx_aggr_ctrl,
-			sizeof(usb_aggr_ctrl), sizeof(usb_aggr_ctrl));
+			sizeof(usb_aggr_ctrl_cfg), sizeof(usb_aggr_ctrl_cfg));
 
 	if (usb_resubmit_urbs) {
 		/* Indicate resubmition from here */
@@ -4961,7 +5555,7 @@ int woal_priv_set_get_usbaggrctrl(moal_private *priv, t_u8 *respbuf,
 	/* Keep a copy of the latest Rx deaggregation parameters in MOAL */
 	moal_memcpy_ext(handle, &cardp->rx_deaggr_ctrl,
 			&pcfg_misc->param.usb_aggr_params.rx_deaggr_ctrl,
-			sizeof(usb_aggr_ctrl), sizeof(usb_aggr_ctrl));
+			sizeof(usb_aggr_ctrl_cfg), sizeof(usb_aggr_ctrl_cfg));
 
 	if (usb_resubmit_urbs) {
 		/* Ensure the next data URBs will use the modified parameters */
@@ -5201,8 +5795,8 @@ static int woal_priv_set_essid(moal_private *priv, t_u8 *respbuf,
 {
 	mlan_802_11_ssid req_ssid;
 	mlan_ssid_bssid ssid_bssid;
-#ifdef REASSOCIATION
 	moal_handle *handle = priv->phandle;
+#ifdef REASSOCIATION
 	mlan_bss_info bss_info;
 #endif
 	int ret = 0;
@@ -5277,6 +5871,38 @@ static int woal_priv_set_essid(moal_private *priv, t_u8 *respbuf,
 			goto setessid_ret;
 		}
 
+		priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+		priv->auto_assoc_priv.drv_reconnect.status = MFALSE;
+#ifdef REASSOCIATION
+		if (priv->reassoc_on == MTRUE) {
+			if (priv->auto_assoc_priv.auto_assoc_type_on &
+			    (0x1 << (AUTO_ASSOC_TYPE_DRV_ASSOC - 1))) {
+				if (priv->scan_type == MLAN_SCAN_TYPE_PASSIVE)
+					woal_set_scan_type(
+						priv, MLAN_SCAN_TYPE_PASSIVE);
+				MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
+				moal_memcpy_ext(handle,
+						&priv->prev_ssid_bssid.ssid,
+						&req_ssid,
+						sizeof(mlan_802_11_ssid),
+						sizeof(mlan_802_11_ssid));
+				priv->auto_assoc_priv.auto_assoc_trigger_flag =
+					AUTO_ASSOC_TYPE_DRV_ASSOC;
+				priv->auto_assoc_priv.drv_assoc.status = MTRUE;
+				priv->reassoc_required = MTRUE;
+				priv->phandle->is_reassoc_timer_set = MTRUE;
+				PRINTM(MINFO,
+				       " auto assoc: trigger driver auto re-assoc\n");
+				woal_mod_timer(&priv->phandle->reassoc_timer,
+					       0);
+				ret = MLAN_STATUS_SUCCESS;
+
+				LEAVE();
+				return ret;
+			}
+		}
+#endif
+
 		if (mwr->u.essid.flags != 0xFFFF) {
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_find_essid(priv, &ssid_bssid,
@@ -5472,7 +6098,11 @@ static int woal_priv_get_ap(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	if (bss_info.media_connected == MTRUE) {
 		moal_memcpy_ext(priv->phandle, mwr->u.ap_addr.sa_data,
 				&bss_info.bssid, MLAN_MAC_ADDR_LENGTH,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+				sizeof(mwr->u.ap_addr.sa_data_min));
+#else
 				sizeof(mwr->u.ap_addr.sa_data));
+#endif
 	} else {
 		memset(mwr->u.ap_addr.sa_data, 0, MLAN_MAC_ADDR_LENGTH);
 	}
@@ -5544,7 +6174,7 @@ static int woal_priv_set_get_psmode(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PSMODE);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		action = MLAN_ACT_GET;
@@ -5561,6 +6191,12 @@ static int woal_priv_set_get_psmode(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 
+	if (data != 0 && data != 1) {
+		PRINTM(MERROR, "Invalid psmode=%d\n", data);
+		ret = -EINVAL;
+		goto done;
+	}
+
 	/* Flip the value */
 	data = !data;
 
@@ -5645,7 +6281,9 @@ static int woal_priv_txpowercfg(moal_private *priv, t_u8 *respbuf,
 
 	memset(data, 0, sizeof(data));
 	memset(&bss_info, 0, sizeof(bss_info));
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	ret = woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	if (ret != MLAN_STATUS_SUCCESS)
+		return -EFAULT;
 
 	if (strlen(respbuf) ==
 	    (strlen(CMD_NXP) + strlen(PRIV_CMD_TXPOWERCFG))) {
@@ -5844,7 +6482,7 @@ static int woal_priv_pscfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PSCFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -6046,7 +6684,7 @@ static int woal_priv_sleeppd(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SLEEPPD);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -6124,7 +6762,7 @@ static int woal_priv_txcontrol(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TXCONTROL);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -6201,7 +6839,7 @@ static int woal_priv_regrdwr(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_REGRDWR);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -6213,7 +6851,8 @@ static int woal_priv_regrdwr(moal_private *priv, t_u8 *respbuf,
 		ret = -ENOMEM;
 		goto done;
 	}
-	strcpy(arguments, respbuf + header_len);
+	strncpy(arguments, respbuf + header_len,
+		strlen(respbuf) * sizeof(char));
 	space_ind = strstr((char *)arguments, " ");
 	if (space_ind)
 		space_ind = strstr(space_ind + 1, " ");
@@ -6221,7 +6860,8 @@ static int woal_priv_regrdwr(moal_private *priv, t_u8 *respbuf,
 		if (*(char *)(space_ind + 1) == '-') {
 			is_negative_val = MTRUE;
 			arguments[space_ind + 1 - arguments] = '\0';
-			strcat(arguments, space_ind + 2);
+			strncat(arguments, space_ind + 2,
+				(strlen(respbuf) * sizeof(char)) - 1);
 		}
 	}
 	parse_arguments(arguments, data, ARRAY_SIZE(data), &user_data_len);
@@ -6295,7 +6935,7 @@ static int woal_priv_rdeeprom(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_RDEEPROM);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -6367,7 +7007,7 @@ static int woal_priv_memrdwr(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MEMRDWR);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		ret = -EINVAL;
 		goto done;
 	}
@@ -6432,7 +7072,7 @@ static int woal_priv_sdcmd52rw(moal_private *priv, t_u8 *respbuf,
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SDCMD52RW);
 	memset((t_u8 *)buf, 0, sizeof(buf));
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		PRINTM(MERROR, "Invalid number of arguments\n");
 		ret = -EINVAL;
 		goto done;
@@ -6542,48 +7182,100 @@ static int woal_priv_sdcmd52rw(moal_private *priv, t_u8 *respbuf,
 }
 #endif /* SDIO */
 
+#ifdef STA_SUPPORT
 /**
- *  @brief Set / Get Auto ARP Response configuration
+ *  @brief arpfilter ioctl function
  *
  *  @param priv         A pointer to moal_private structure
  *  @param respbuf      A pointer to response buffer
  *  @param respbuflen   Available length of response buffer
  *
- *  @return             Number of bytes written, negative for failure.
+ *  @return		0 --success, otherwise fail
  */
-int woal_priv_set_get_auto_arp(moal_private *priv, t_u8 *respbuf,
+static int woal_priv_arpfilter(moal_private *priv, t_u8 *respbuf,
 			       t_u32 respbuflen)
 {
-	int data[4];
-	int user_data_len = 0;
 	int ret = 0;
-	moal_handle *handle = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	t_u8 *data_ptr = NULL;
+	t_u32 buf_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	if (priv == NULL) {
-		PRINTM(MERROR, "Invalid priv\n");
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
-	handle = priv->phandle;
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_GEN_IE;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	misc->param.gen_ie.type = MLAN_IE_TYPE_ARP_FILTER;
 
-	if (strlen(respbuf) == (strlen(CMD_NXP) + strlen(PRIV_CMD_AUTO_ARP))) {
-		/* GET operation */
-		user_data_len = 0;
-	} else {
-		/* SET operation */
-		memset((char *)data, 0, sizeof(data));
-		parse_arguments(respbuf + strlen(CMD_NXP) +
-					strlen(PRIV_CMD_AUTO_ARP),
-				data, ARRAY_SIZE(data), &user_data_len);
-	}
+	data_ptr = respbuf + (strlen(CMD_NXP) + strlen(PRIV_CMD_ARPFILTER));
+	buf_len = *((t_u16 *)data_ptr);
+	misc->param.gen_ie.len = buf_len;
+	moal_memcpy_ext(priv->phandle, (void *)(misc->param.gen_ie.ie_data),
+			data_ptr + sizeof(buf_len), buf_len, MAX_IE_SIZE);
 
-	if (user_data_len > 1) {
-		PRINTM(MERROR, "Too many arguments\n");
-		ret = -EINVAL;
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
 		goto done;
 	}
-
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+#endif /* STA_SUPPORT */
+
+/**
+ *  @brief Set / Get Auto ARP Response configuration
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_set_get_auto_arp(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
+{
+	int data[4];
+	int user_data_len = 0;
+	int ret = 0;
+	moal_handle *handle = NULL;
+
+	ENTER();
+
+	if (priv == NULL) {
+		PRINTM(MERROR, "Invalid priv\n");
+		goto done;
+	}
+	handle = priv->phandle;
+
+	if (strlen(respbuf) == (strlen(CMD_NXP) + strlen(PRIV_CMD_AUTO_ARP))) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(respbuf + strlen(CMD_NXP) +
+					strlen(PRIV_CMD_AUTO_ARP),
+				data, ARRAY_SIZE(data), &user_data_len);
+	}
+
+	if (user_data_len > 1) {
+		PRINTM(MERROR, "Too many arguments\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
 	if (user_data_len) {
 		/* Get the enable/disable value from user */
 		handle->hs_auto_arp = data[0];
@@ -6621,7 +7313,7 @@ static int woal_priv_deauth_ctrl(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_snmp_mib));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -6631,7 +7323,7 @@ static int woal_priv_deauth_ctrl(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DEAUTH_CTRL);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 	} else {
@@ -6701,7 +7393,7 @@ static int woal_priv_per_pkt_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -6875,7 +7567,12 @@ static int woal_priv_get_txpwrlimit(moal_private *priv, t_u8 *respbuf,
 	header_len = strlen(PRIV_CMD_GET_TXPWR_LIMIT);
 	trpc_cfg = (mlan_ds_misc_chan_trpc_cfg *)(respbuf + header_len);
 	if ((trpc_cfg->sub_band != 0) && (trpc_cfg->sub_band != 0x10) &&
-	    (trpc_cfg->sub_band != 0x11) && (trpc_cfg->sub_band != 0x12)) {
+	    (trpc_cfg->sub_band != 0x11) && (trpc_cfg->sub_band != 0x12) &&
+	    (trpc_cfg->sub_band != 0x13) && (trpc_cfg->sub_band != 0x20) &&
+	    (trpc_cfg->sub_band != 0x21) && (trpc_cfg->sub_band != 0x22) &&
+	    (trpc_cfg->sub_band != 0x23) && (trpc_cfg->sub_band != 0x24) &&
+	    (trpc_cfg->sub_band != 0x25) && (trpc_cfg->sub_band != 0x26) &&
+	    (trpc_cfg->sub_band != 0x27)) {
 		PRINTM(MERROR, "Invalid subband=0x%x\n", trpc_cfg->sub_band);
 		ret = -EINVAL;
 		goto done;
@@ -6927,6 +7624,7 @@ static int woal_priv_getcfgchanlist(moal_private *priv, t_u8 *respbuf,
 	wlan_ieee80211_chan_list *plist = NULL;
 	struct ieee80211_supported_band *sband;
 	struct wiphy *wiphy = NULL;
+	t_u8 band;
 	int i;
 
 	ENTER();
@@ -6938,36 +7636,25 @@ static int woal_priv_getcfgchanlist(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 	plist = (wlan_ieee80211_chan_list *)respbuf;
-	sband = wiphy->bands[NL80211_BAND_2GHZ];
-	if (sband) {
-		num_chan += sband->n_channels;
-		for (i = 0; i < sband->n_channels; i++) {
-			plist->chan_list[i].center_freq =
-				sband->channels[i].center_freq;
-			plist->chan_list[i].hw_value =
-				sband->channels[i].hw_value;
-			plist->chan_list[i].flags = sband->channels[i].flags;
-			plist->chan_list[i].max_power =
-				sband->channels[i].max_power;
-		}
-	}
-	sband = wiphy->bands[NL80211_BAND_5GHZ];
-	if (sband) {
-		for (i = 0; i < sband->n_channels; i++) {
-			plist->chan_list[i + num_chan].center_freq =
-				sband->channels[i].center_freq;
-			plist->chan_list[i + num_chan].hw_value =
-				sband->channels[i].hw_value;
-			plist->chan_list[i + num_chan].flags =
-				sband->channels[i].flags;
-			plist->chan_list[i + num_chan].max_power =
-				sband->channels[i].max_power;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
-			plist->chan_list[i + num_chan].dfs_state =
-				sband->channels[i].dfs_state;
+	for (band = NL80211_BAND_2GHZ; band < IEEE80211_NUM_BANDS; ++band) {
+		sband = wiphy->bands[band];
+		if (sband) {
+			for (i = 0; i < sband->n_channels; i++) {
+				plist->chan_list[i + num_chan].center_freq =
+					sband->channels[i].center_freq;
+				plist->chan_list[i + num_chan].hw_value =
+					sband->channels[i].hw_value;
+				plist->chan_list[i + num_chan].flags =
+					sband->channels[i].flags;
+				plist->chan_list[i + num_chan].max_power =
+					sband->channels[i].max_power;
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 8, 13)
+				plist->chan_list[i + num_chan].dfs_state =
+					sband->channels[i].dfs_state;
 #endif
+			}
+			num_chan += sband->n_channels;
 		}
-		num_chan += sband->n_channels;
 	}
 	plist->num_chan = num_chan;
 	ret = sizeof(wlan_ieee80211_chan_list) +
@@ -7065,7 +7752,8 @@ static int woal_priv_get_rx_tx_histogram(moal_private *priv, t_u8 *respbuf,
  *
  *  @return         0 --success, otherwise fail
  */
-int woal_priv_hotspotcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_hotspotcfg(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
 {
 	int ret = 0;
 	mlan_ioctl_req *req = NULL;
@@ -7077,7 +7765,7 @@ int woal_priv_hotspotcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	ENTER();
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_HOTSPOTCFG);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -7132,8 +7820,8 @@ int woal_priv_hotspotcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return         0 --success, otherwise fail
  */
-int woal_priv_mgmt_frame_passthru_ctrl(moal_private *priv, t_u8 *respbuf,
-				       t_u32 respbuflen)
+static int woal_priv_mgmt_frame_passthru_ctrl(moal_private *priv, t_u8 *respbuf,
+					      t_u32 respbuflen)
 {
 	int ret = 0;
 	int data = 0;
@@ -7144,7 +7832,7 @@ int woal_priv_mgmt_frame_passthru_ctrl(moal_private *priv, t_u8 *respbuf,
 
 	ENTER();
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MGMT_FRAME_CTRL);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -7337,7 +8025,7 @@ static int woal_priv_wmm_delts_req_ioctl(moal_private *priv, t_u8 *respbuf,
 
 	memset(&delts_ioctl, 0x00, sizeof(delts_ioctl));
 
-	if (strlen(respbuf) > header_len) {
+	if ((int)strlen(respbuf) > header_len) {
 		copy_len = MIN(strlen(data_ptr), sizeof(delts_ioctl));
 		moal_memcpy_ext(priv->phandle, (t_u8 *)&delts_ioctl, data_ptr,
 				copy_len, sizeof(delts_ioctl));
@@ -7478,7 +8166,7 @@ static int woal_priv_wmm_queue_status_ioctl(moal_private *priv, t_u8 *respbuf,
 	pwmm = (mlan_ds_wmm_cfg *)req->pbuf;
 	pwmm->sub_command = MLAN_OID_WMM_CFG_QUEUE_STATUS;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 		if (status != MLAN_STATUS_SUCCESS) {
 			ret = -EFAULT;
@@ -7572,7 +8260,8 @@ static int woal_priv_wmm_ts_status_ioctl(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_macctrl(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_macctrl(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
 {
 	int data = 0;
 	mlan_ioctl_req *req = NULL;
@@ -7584,7 +8273,7 @@ int woal_priv_macctrl(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	ENTER();
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MAC_CTRL);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -7640,7 +8329,7 @@ int woal_priv_macctrl(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_getwap(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_getwap(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 {
 	int ret = 0;
 #ifdef STA_SUPPORT
@@ -7653,7 +8342,9 @@ int woal_priv_getwap(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
 		memset(&bss_info, 0, sizeof(bss_info));
 
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		ret = woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (ret != MLAN_STATUS_SUCCESS)
+			return -EFAULT;
 
 		if (bss_info.media_connected == MTRUE) {
 			moal_memcpy_ext(priv->phandle, respbuf,
@@ -7689,7 +8380,8 @@ int woal_priv_getwap(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_region_code(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_region_code(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
 	int data = 0;
 	mlan_ioctl_req *req = NULL;
@@ -7701,7 +8393,7 @@ int woal_priv_region_code(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	ENTER();
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_REGION_CODE);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -7748,9 +8440,8 @@ int woal_priv_region_code(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	return ret;
 }
 
-#ifdef RX_PACKET_COALESCE
 /**
- *  @brief Set/Get RX packet coalesceing setting
+ *  @brief Set/Get channel time and buffer weight
  *
  *  @param priv         A pointer to moal_private structure
  *  @param respbuf      A pointer to response buffer
@@ -7758,42 +8449,156 @@ int woal_priv_region_code(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_rx_pkt_coalesce_cfg(moal_private *priv, t_u8 *respbuf,
-				  t_u32 respbuflen)
+static int woal_priv_multi_chan_config(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
 {
-	int ret = 0;
-	t_u32 data[2];
-	int user_data_len = 0, header_len = 0;
+	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *cfg = NULL;
 	t_u8 *data_ptr;
-	mlan_ioctl_req *req = NULL;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	data_ptr = respbuf + strlen(CMD_NXP) + strlen(PRIV_CMD_RX_COAL_CFG);
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_RX_COAL_CFG);
-	if (strlen(respbuf) == header_len) {
+	data_ptr = respbuf + strlen(CMD_NXP) + strlen(PRIV_CMD_MULTI_CHAN_CFG);
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MULTI_CHAN_CFG);
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
 		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
+		user_data_len = sizeof(mlan_ds_multi_chan_cfg);
 	}
 
-	if (sizeof(int) * user_data_len > sizeof(data)) {
-		PRINTM(MERROR, "Too many arguments\n");
-		ret = -EINVAL;
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
-	if ((user_data_len != 0) && (user_data_len != 2)) {
-		PRINTM(MERROR, "Invalid arguments\n");
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_MULTI_CHAN_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	if (user_data_len == 0) {
+		req->action = MLAN_ACT_GET;
+	} else {
+		req->action = MLAN_ACT_SET;
+		moal_memcpy_ext(priv->phandle, &cfg->param.multi_chan_cfg,
+				data_ptr, sizeof(mlan_ds_multi_chan_cfg),
+				sizeof(mlan_ds_multi_chan_cfg));
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	moal_memcpy_ext(priv->phandle, respbuf,
+			(mlan_ds_multi_chan_cfg *)&cfg->param.multi_chan_cfg,
+			req->buf_len, respbuflen);
+	ret = req->buf_len;
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get multi_channel policy setting
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_multi_chan_policy(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
+{
+	int ret = 0;
+	int user_data_len = 0, header_len = 0;
+	int data = 0;
+	t_u16 enable;
+	t_u8 action;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MULTI_CHAN_POLICY);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data, 1, &user_data_len);
+	}
+
+	if (user_data_len > 1) {
+		PRINTM(MERROR, "Invalid number of arguments\n");
 		ret = -EINVAL;
 		goto done;
 	}
 
+	if (user_data_len == 0) {
+		action = MLAN_ACT_GET;
+	} else {
+		action = MLAN_ACT_SET;
+		enable = (t_u16)data;
+	}
+
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_mc_policy_cfg(priv, &enable, MOAL_IOCTL_WAIT, action)) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, respbuf, &enable, sizeof(t_u16),
+			respbuflen);
+	ret = sizeof(t_u16);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get drcs time slicing parameters
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_drcs_time_slicing_cfg(moal_private *priv, t_u8 *respbuf,
+					   t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	mlan_ds_drcs_cfg *drcs_cfg = NULL;
+	t_u8 *data_ptr;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0;
+	int data[8];
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	data_ptr = respbuf + strlen(CMD_NXP) + strlen(PRIV_CMD_DRCS_CFG);
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DRCS_CFG);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(data_ptr, data, ARRAY_SIZE(data),
+				&user_data_len);
+	}
+
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
 		ret = -ENOMEM;
@@ -7801,15 +8606,31 @@ int woal_priv_rx_pkt_coalesce_cfg(moal_private *priv, t_u8 *respbuf,
 	}
 
 	cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	cfg->sub_command = MLAN_OID_MISC_RX_PACKET_COALESCE;
+	cfg->sub_command = MLAN_OID_MISC_DRCS_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
 
 	if (user_data_len == 0) {
 		req->action = MLAN_ACT_GET;
 	} else {
 		req->action = MLAN_ACT_SET;
-		cfg->param.rx_coalesce.packet_threshold = data[0];
-		cfg->param.rx_coalesce.delay = data[1];
+		drcs_cfg = (mlan_ds_drcs_cfg *)&cfg->param.drcs_cfg[0];
+		drcs_cfg->chantime = (t_u8)data[0];
+		drcs_cfg->switchtime = (t_u8)data[1];
+		drcs_cfg->undozetime = (t_u8)data[2];
+		drcs_cfg->mode = (t_u8)data[3];
+		/* Set the same parameters for two channels*/
+		if (user_data_len < (int)ARRAY_SIZE(data))
+			drcs_cfg->chan_idx = 0x03;
+		else {
+			/* Set the different parameters for two channels*/
+			drcs_cfg->chan_idx = 0x1;
+			drcs_cfg = (mlan_ds_drcs_cfg *)&cfg->param.drcs_cfg[1];
+			drcs_cfg->chan_idx = 0x2;
+			drcs_cfg->chantime = (t_u8)data[4];
+			drcs_cfg->switchtime = (t_u8)data[5];
+			drcs_cfg->undozetime = (t_u8)data[6];
+			drcs_cfg->mode = (t_u8)data[7];
+		}
 	}
 
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
@@ -7818,17 +8639,17 @@ int woal_priv_rx_pkt_coalesce_cfg(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 
-	moal_memcpy_ext(
-		priv->phandle, respbuf,
-		(mlan_ds_misc_rx_packet_coalesce *)&cfg->param.rx_coalesce,
-		req->buf_len, respbuflen);
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&cfg->param.drcs_cfg,
+			req->buf_len, respbuflen);
 	ret = req->buf_len;
 
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
 	LEAVE();
 	return ret;
 }
-#endif
+
 /**
  *  @brief Set/Get FW side mac address
  *
@@ -7838,7 +8659,8 @@ int woal_priv_rx_pkt_coalesce_cfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_fwmacaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_fwmacaddr(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
 {
 	t_u8 data[ETH_ALEN];
 	int ret = 0;
@@ -7862,7 +8684,7 @@ int woal_priv_fwmacaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	bss->sub_command = MLAN_OID_BSS_MAC_ADDR;
 	req->req_id = MLAN_IOCTL_BSS;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 	} else {
@@ -7904,7 +8726,8 @@ int woal_priv_fwmacaddr(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
 {
 	int data[4];
 	int ret = 0;
@@ -7918,15 +8741,17 @@ int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_OFFCHANNEL);
 
-	if (header_len == strlen(respbuf)) {
+	if (header_len == (int)strlen(respbuf)) {
 		/* Query current remain on channel status */
 		if (priv->phandle->remain_on_channel)
-			ret = sprintf(respbuf,
+			ret = snprintf(
+				      respbuf, CMD_BUF_LEN,
 				      "There is pending remain on channel from bss %d\n",
 				      priv->phandle->remain_bss_index) +
 			      1;
 		else
-			ret = sprintf(respbuf,
+			ret = snprintf(
+				      respbuf, CMD_BUF_LEN,
 				      "There is no pending remain on channel\n") +
 			      1;
 		goto done;
@@ -7999,7 +8824,8 @@ int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 
 	if (data[0] == 0) {
 		if (!priv->phandle->remain_on_channel) {
-			ret = sprintf(respbuf,
+			ret = snprintf(
+				      respbuf, CMD_BUF_LEN,
 				      "There is no pending remain on channel to be canceled\n") +
 			      1;
 			goto done;
@@ -8041,7 +8867,7 @@ int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	if (status != MLAN_STATUS_SUCCESS)
 		ret = -EFAULT;
 	else
-		ret = sprintf(respbuf, "OK\n") + 1;
+		ret = snprintf(respbuf, CMD_BUF_LEN, "OK\n") + 1;
 
 done:
 	LEAVE();
@@ -8059,8 +8885,8 @@ int woal_priv_offchannel(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_priv_set_get_dscp_map(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_set_get_dscp_map(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	int ret = MLAN_STATUS_SUCCESS;
 	t_u8 *pos = NULL;
@@ -8069,7 +8895,7 @@ int woal_priv_set_get_dscp_map(moal_private *priv, t_u8 *respbuf,
 	ENTER();
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DSCP_MAP);
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		/* SET operation */
 		pos = respbuf + header_len;
 		moal_memcpy_ext(priv->phandle, priv->dscp_map, pos,
@@ -8094,8 +8920,8 @@ int woal_priv_set_get_dscp_map(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_get_driver_verext(moal_private *priv, t_u8 *respbuf,
-				t_u32 respbuflen)
+static int woal_priv_get_driver_verext(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
 {
 	int data = 0;
 	mlan_ds_get_info *info = NULL;
@@ -8109,7 +8935,7 @@ int woal_priv_get_driver_verext(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_get_info));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8120,7 +8946,7 @@ int woal_priv_get_driver_verext(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_VEREXT);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -8237,7 +9063,7 @@ static int woal_priv_radio_ctrl(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_RADIO_CTRL);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -8263,7 +9089,9 @@ static int woal_priv_radio_ctrl(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	} else {
 		/* Get radio status */
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		ret = woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (ret != MLAN_STATUS_SUCCESS)
+			return -EFAULT;
 		moal_memcpy_ext(priv->phandle, respbuf, &bss_info.radio_on,
 				sizeof(bss_info.radio_on), respbuflen);
 		ret = sizeof(bss_info.radio_on);
@@ -8297,7 +9125,7 @@ static int woal_priv_wmm_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_wmm_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8307,7 +9135,7 @@ static int woal_priv_wmm_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_WMM_CFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8372,7 +9200,7 @@ static int woal_priv_min_ba_threshold_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 	cfg_11n = (mlan_ds_11n_cfg *)req->pbuf;
@@ -8381,7 +9209,7 @@ static int woal_priv_min_ba_threshold_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MIN_BA_THRESH_CFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8446,7 +9274,7 @@ static int woal_priv_11d_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11d_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8456,7 +9284,7 @@ static int woal_priv_11d_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_11D_CFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8519,13 +9347,13 @@ static int woal_priv_11d_clr_chan_tbl(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11d_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_11D_CLR_TBL);
 
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		PRINTM(MERROR, "Too many arguments\n");
 		ret = -EINVAL;
 		goto done;
@@ -8573,7 +9401,7 @@ static int woal_priv_wws_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8583,7 +9411,7 @@ static int woal_priv_wws_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_WWS_CFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8645,7 +9473,7 @@ static int woal_priv_set_get_reassoc(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_REASSOCTRL);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		data = (int)(priv->reassoc_on);
@@ -8653,6 +9481,19 @@ static int woal_priv_set_get_reassoc(moal_private *priv, t_u8 *respbuf,
 				respbuflen);
 		ret = sizeof(data);
 	} else {
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+		if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
+			if (priv->host_mlme) {
+				PRINTM(MERROR,
+				       "Don't support reassoctrl in host_mlme mode\n");
+				ret = -EFAULT;
+				LEAVE();
+				return ret;
+			}
+		}
+#endif
+#endif
 		/* SET operation */
 		parse_arguments(respbuf + header_len, &data, 1, &user_data_len);
 		if (user_data_len == 1) {
@@ -8706,7 +9547,7 @@ static int woal_priv_txbuf_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8716,7 +9557,7 @@ static int woal_priv_txbuf_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TXBUF_CFG);
 
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		PRINTM(MERROR,
 		       "Don't support set Tx buffer size after driver loaded!\n");
 		ret = -EINVAL;
@@ -8765,7 +9606,7 @@ static int woal_priv_auth_type(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_AUTH_TYPE);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_get_auth_mode(priv, MOAL_IOCTL_WAIT, &auth_mode)) {
@@ -8785,7 +9626,7 @@ static int woal_priv_auth_type(moal_private *priv, t_u8 *respbuf,
 		if (user_data_len == 1) {
 			PRINTM(MINFO, "SET: auth_type %d\n", auth_type);
 			if (((auth_type < MLAN_AUTH_MODE_OPEN) ||
-			     (auth_type > MLAN_AUTH_MODE_SAE)) &&
+			     (auth_type > MLAN_AUTH_MODE_OWE)) &&
 			    (auth_type != MLAN_AUTH_MODE_AUTO)) {
 				ret = -EINVAL;
 				goto done;
@@ -8832,7 +9673,7 @@ static int woal_priv_11h_local_pwr_constraint(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8842,7 +9683,7 @@ static int woal_priv_11h_local_pwr_constraint(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_POWER_CONS);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8902,7 +9743,7 @@ static int woal_priv_ht_stream_cfg(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8912,7 +9753,7 @@ static int woal_priv_ht_stream_cfg(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_HT_STREAM_CFG);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -8975,7 +9816,7 @@ static int woal_priv_mimo_switch(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_radio_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -8985,7 +9826,7 @@ static int woal_priv_mimo_switch(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MIMO_SWITCH);
 
-	if (strlen(respbuf) > header_len) {
+	if ((int)strlen(respbuf) > header_len) {
 		/* SET operation */
 		req->action = MLAN_ACT_SET;
 		parse_arguments(respbuf + header_len, data, 2, &user_data_len);
@@ -9036,7 +9877,7 @@ static int woal_priv_thermal(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -9046,7 +9887,7 @@ static int woal_priv_thermal(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_THERMAL);
 
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		PRINTM(MERROR, "Set is not supported for this command\n");
 		ret = -EINVAL;
 		goto done;
@@ -9094,7 +9935,7 @@ static int woal_priv_beacon_interval(moal_private *priv, t_u8 *respbuf,
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
 	if (req == NULL) {
-		ret = ENOMEM;
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -9104,7 +9945,7 @@ static int woal_priv_beacon_interval(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_BCN_INTERVAL);
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		req->action = MLAN_ACT_GET;
 		user_data_len = 0;
@@ -9166,7 +10007,6 @@ static int woal_priv_get_signal(moal_private *priv, t_u8 *respbuf,
 	int out_data[OUT_DATA_SIZE];
 	mlan_ds_get_signal signal;
 	int data_length = 0;
-	int buflen = 0;
 	int user_data_len = 0, header_len = 0;
 
 	ENTER();
@@ -9176,10 +10016,9 @@ static int woal_priv_get_signal(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_GET_SIGNAL);
 
-	if (strlen(respbuf) != header_len)
+	if ((int)strlen(respbuf) != header_len)
 		parse_arguments(respbuf + header_len, in_data, IN_DATA_SIZE,
 				&user_data_len);
-	buflen = MIN(user_data_len, IN_DATA_SIZE);
 
 	if (priv->media_connected == MFALSE) {
 		PRINTM(MERROR, "Can not get RSSI in disconnected state\n");
@@ -9413,7 +10252,7 @@ static int woal_priv_get_signal_ext(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_GET_SIGNAL_EXT);
 
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		parse_arguments(respbuf + header_len, &data,
 				sizeof(data) / sizeof(int), &user_data_len);
 	}
@@ -9562,7 +10401,7 @@ static int woal_priv_get_signal_ext_v2(moal_private *priv, t_u8 *respbuf,
 	}
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_GET_SIGNAL_EXT_V2);
-	if (strlen(respbuf) != header_len) {
+	if ((int)strlen(respbuf) != header_len) {
 		parse_arguments(respbuf + header_len, &data,
 				sizeof(data) / sizeof(int), &user_data_len);
 	}
@@ -9682,7 +10521,7 @@ static int woal_priv_signalext_cfg(moal_private *priv, t_u8 *respbuf,
 	int user_data_len = 0, header_len = 0;
 	ENTER();
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SIGNALEXT_CFG);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		PRINTM(MERROR, "Invalid arguments!\n");
 		ret = -EINVAL;
 		goto done;
@@ -9718,8 +10557,8 @@ static int woal_priv_signalext_cfg(moal_private *priv, t_u8 *respbuf,
  *
  * @return              0 -- success, otherwise fail
  */
-int woal_priv_set_get_pmfcfg(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_set_get_pmfcfg(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	int data[2] = {0, 0};
 	mlan_ioctl_req *req = NULL;
@@ -9738,7 +10577,7 @@ int woal_priv_set_get_pmfcfg(moal_private *priv, t_u8 *respbuf,
 	}
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PMFCFG);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -9812,7 +10651,7 @@ static int woal_priv_inactivity_timeout_ext(moal_private *priv, t_u8 *respbuf,
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_INACTIVITYTO);
 	memset(data, 0, sizeof(data));
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -9906,7 +10745,7 @@ static int woal_priv_11n_amsdu_aggr_ctrl(moal_private *priv, t_u8 *respbuf,
 	cfg_11n->sub_command = MLAN_OID_11N_CFG_AMSDU_AGGR_CTRL;
 	req->req_id = MLAN_IOCTL_11N_CFG;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -9974,7 +10813,7 @@ static int woal_priv_tx_bf_cap_ioctl(moal_private *priv, t_u8 *respbuf,
 	bf_cfg->sub_command = MLAN_OID_11N_CFG_TX_BF_CAP;
 	req->req_id = MLAN_IOCTL_11N_CFG;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -10033,7 +10872,7 @@ static int woal_priv_sdio_clock_ioctl(moal_private *priv, t_u8 *respbuf,
 	ENTER();
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SDIO_CLOCK);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&clock_state,
 				sizeof(clock_state), respbuflen);
@@ -10094,7 +10933,7 @@ static int woal_priv_sdio_mpa_ctrl(moal_private *priv, t_u8 *respbuf,
 
 	memset(data, 0, sizeof(data));
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MPA_CTRL);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 	} else {
@@ -10232,7 +11071,7 @@ static int woal_priv_sleep_params_ioctl(moal_private *priv, t_u8 *respbuf,
 	psleep_params = (pmlan_ds_sleep_params)&pm->param.sleep_params;
 
 	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SLEEP_PARAMS);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -10305,8 +11144,9 @@ static int woal_priv_sleep_params_ioctl(moal_private *priv, t_u8 *respbuf,
 	return ret;
 }
 
+#ifdef UAP_SUPPORT
 /**
- * @brief               Set/Get DFS Testing settings
+ * @brief               Set/Get network monitor configurations
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
@@ -10314,23 +11154,395 @@ static int woal_priv_sleep_params_ioctl(moal_private *priv, t_u8 *respbuf,
  *
  * @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_priv_net_monitor_ioctl(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_11h_cfg *ds_11hcfg = NULL;
-	int ret = 0;
-	int data[4] = {0};
 	int user_data_len = 0, header_len = 0;
+	int data_length = 0;
+	int data[5] = {0};
+	int ret = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_net_monitor *net_mon = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	moal_handle *handle = priv->phandle;
+	monitor_iface *mon_if = NULL;
+	struct net_device *ndev = NULL;
+#endif
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_TESTING);
-	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_NET_MON);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		LEAVE();
+		return -ENOMEM;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	net_mon = (mlan_ds_misc_net_monitor *)&misc->param.net_mon;
+	misc->sub_command = MLAN_OID_MISC_NET_MONITOR;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len == 1 || user_data_len == 2 ||
+		    user_data_len == 4 || user_data_len == 5) {
+			if (data[0] != MTRUE && data[0] != MFALSE) {
+				PRINTM(MERROR,
+				       "NET_MON: Activity should be enable(=1)/"
+				       "disable(=0)\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			net_mon->enable_net_mon = data[0];
+			if (data[0] == MTRUE) {
+				int i;
+				if (user_data_len != 2 && user_data_len != 4 &&
+				    user_data_len != 5) {
+					PRINTM(MERROR,
+					       "NET_MON: Invalid number of args!\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				/* Supported filter flags */
+				if (!data[1] ||
+				    data[1] & ~(MLAN_NETMON_DATA |
+						MLAN_NETMON_MANAGEMENT |
+						MLAN_NETMON_CONTROL |
+						MLAN_NETMON_NOPROM |
+						MLAN_NETMON_NON_BSS_BCN |
+						MLAN_NETMON_TX)) {
+					PRINTM(MERROR,
+					       "NET_MON: Invalid filter flag\n");
+					ret = -EINVAL;
+					goto done;
+				}
+
+				if (user_data_len > 2) {
+					/* Supported bands */
+
+					for (i = 0;
+					     i <
+					     (int)(sizeof(SupportedInfraBand) /
+						   sizeof(SupportedInfraBand[0]));
+					     i++)
+						if (data[2] ==
+						    SupportedInfraBand[i])
+							break;
+					if (i == sizeof(SupportedInfraBand)) {
+						PRINTM(MERROR,
+						       "NET_MON: Invalid band\n");
+						ret = -EINVAL;
+						goto done;
+					}
+				}
+				/* Supported channel */
+				if (user_data_len > 3 &&
+				    (data[3] < 1 ||
+				     data[3] > MLAN_MAX_CHANNEL)) {
+					PRINTM(MERROR,
+					       "NET_MON: Invalid channel number\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				if (user_data_len == 5) {
+					/* Secondary channel offset */
+					if (!(data[2] & (BAND_GN | BAND_AN))) {
+						PRINTM(MERROR,
+						       "No 11n in band, can not set "
+						       "secondary channel offset\n");
+						ret = -EINVAL;
+						goto done;
+					}
+					if ((data[4] != CHANNEL_BW_20MHZ) &&
+					    (data[4] !=
+					     CHANNEL_BW_40MHZ_ABOVE) &&
+					    (data[4] !=
+					     CHANNEL_BW_40MHZ_BELOW) &&
+					    (data[4] != CHANNEL_BW_80MHZ)) {
+						PRINTM(MERROR,
+						       "Invalid secondary channel bandwidth, "
+						       "only allowed 0, 1, 3 or 4\n");
+						ret = -EINVAL;
+						goto done;
+					}
+					net_mon->chan_bandwidth = data[4];
+				}
+
+				net_mon->filter_flag = data[1];
+				net_mon->band = data[2];
+				net_mon->channel = data[3];
+			}
+			req->action = MLAN_ACT_SET;
+		} else {
+			PRINTM(MERROR, "NET_MON: Invalid number of args!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "NET_MON: woal_request_ioctl fail\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	if (req->action == MLAN_ACT_SET) {
+		if (data[0]) { /** Enable sniffer mode: 1/2 */
+			if (!handle->mon_if) {
+				mon_if = woal_prepare_mon_if(priv, "rtap", 0);
+				if (!mon_if) {
+					PRINTM(MFATAL,
+					       "Prepare mon_if fail.\n");
+					ret = -EFAULT;
+					goto done;
+				}
+				ndev = mon_if->mon_ndev;
+				ret = register_netdevice(ndev);
+				if (ret) {
+					PRINTM(MFATAL,
+					       "register net_device failed, ret=%d\n",
+					       ret);
+					free_netdev(ndev);
+					ret = -EFAULT;
+					goto done;
+				}
+				handle->mon_if = mon_if;
+			}
+			/* Save band channel config */
+			handle->mon_if->band_chan_cfg.band = net_mon->band;
+			handle->mon_if->band_chan_cfg.channel =
+				net_mon->channel;
+			handle->mon_if->band_chan_cfg.chan_bandwidth =
+				net_mon->chan_bandwidth;
+			handle->mon_if->flag = net_mon->filter_flag;
+		} else { /** Disable sniffer mode: 0 */
+			if (handle->mon_if) {
+				ndev = handle->mon_if->mon_ndev;
+				handle->mon_if = NULL;
+				unregister_netdevice(ndev);
+			}
+		}
+	}
+#endif
+
+	data[0] = net_mon->enable_net_mon;
+	data[1] = net_mon->filter_flag;
+	data[2] = net_mon->band;
+	data[3] = net_mon->channel;
+	data[4] = net_mon->chan_bandwidth;
+	data_length = 5;
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+			sizeof(int) * data_length, respbuflen);
+	ret = sizeof(int) * data_length;
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+#endif
+
+/**
+ *  @brief This function get nop list.
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_nop_list(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_cfg *ds_11hcfg = NULL;
+
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11H_CFG;
+	req->action = MLAN_ACT_GET;
+
+	ds_11hcfg = (mlan_ds_11h_cfg *)req->pbuf;
+	ds_11hcfg->sub_command = MLAN_OID_11H_NOP_CHAN_LIST;
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status == MLAN_STATUS_FAILURE) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, respbuf,
+			(t_u8 *)&ds_11hcfg->param.nop_chan_list,
+			sizeof(mlan_ds_11h_nop_chan_list), respbuflen);
+	ret = sizeof(mlan_ds_11h_nop_chan_list);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief clear NOP list
+ *
+ *  @param priv             A pointer to moal_private structure
+ *  @return                 0 --success, otherwise fail
+ */
+static int woal_uap_clear_nop(moal_private *priv)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_cfg *ds_11hcfg = NULL;
+
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11H_CFG;
+	req->action = MLAN_ACT_CLEAR;
+
+	ds_11hcfg = (mlan_ds_11h_cfg *)req->pbuf;
+	ds_11hcfg->sub_command = MLAN_OID_11H_CHAN_NOP_INFO;
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status == MLAN_STATUS_FAILURE) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function clear nop flags.
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_clear_nop(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
+{
+	int ret = 0;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	struct wiphy *wiphy = priv->phandle->wiphy;
+#endif
+
+	ENTER();
+	PRINTM(MCMND, "clear nop\n");
+	ret = woal_uap_clear_nop(priv);
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	if (IS_STA_OR_UAP_CFG80211(priv->phandle->params.cfg80211_wext)) {
+		if (wiphy)
+			woal_clear_wiphy_dfs_state(wiphy);
+	}
+#endif
+	ret = sizeof(int);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function detects fake RADAR.
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             positive for success, negative for failure.
+ */
+static int woal_priv_fake_radar(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_snmp_mib *snmp = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	ENTER();
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (priv && priv->chan.chan &&
+	    !(priv->chan.chan->flags & IEEE80211_CHAN_RADAR)) {
+		PRINTM(MERROR, "Current op channel NOT DFS\n");
+		LEAVE();
+		return -EINVAL;
+	}
+#endif
+#endif
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_snmp_mib));
+	if (ioctl_req == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+	snmp = (mlan_ds_snmp_mib *)ioctl_req->pbuf;
+	ioctl_req->req_id = MLAN_IOCTL_SNMP_MIB;
+	snmp->sub_command = MLAN_OID_SNMP_MIB_DOT11H_FAKERADAR;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get DFS Testing settings
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_cfg *ds_11hcfg = NULL;
+	int ret = 0;
+	int data[5] = {0};
+	int user_data_len = 0, header_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_TESTING);
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
@@ -10339,7 +11551,7 @@ static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
 	ds_11hcfg->sub_command = MLAN_OID_11H_DFS_TESTING;
 	req->req_id = MLAN_IOCTL_11H_CFG;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -10347,14 +11559,14 @@ static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
 		/* SET operation */
 		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
 				&user_data_len);
-		if (user_data_len != 4) {
+		if (user_data_len != 5) {
 			PRINTM(MERROR, "Invalid number of args!\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((unsigned)data[0] > 0xFFFFF) {
+		if ((unsigned)data[0] > 1800) {
 			PRINTM(MERROR,
-			       "The maximum user CAC is 1048575 msec (17 mins approx).\n");
+			       "The maximum user CAC is 1800 seconds (30 mins).\n");
 			ret = -EINVAL;
 			goto done;
 		}
@@ -10369,6 +11581,12 @@ static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
 			ret = -EINVAL;
 			goto done;
 		}
+		if ((unsigned)data[4] != 0 && ((unsigned)data[4] != 1)) {
+			PRINTM(MERROR, "CAC restart should be 0/1\n");
+			ret = -EINVAL;
+			goto done;
+		}
+
 		ds_11hcfg->param.dfs_testing.usr_cac_period_msec =
 			(t_u32)data[0] * 1000;
 		ds_11hcfg->param.dfs_testing.usr_nop_period_sec =
@@ -10376,7 +11594,9 @@ static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
 		ds_11hcfg->param.dfs_testing.usr_no_chan_change =
 			data[2] ? 1 : 0;
 		ds_11hcfg->param.dfs_testing.usr_fixed_new_chan = (t_u8)data[3];
-		priv->phandle->cac_period_jiffies = (t_u32)data[0] * HZ / 1000;
+		ds_11hcfg->param.dfs_testing.usr_cac_restart = (t_u8)data[4];
+		priv->phandle->cac_restart = (t_u8)data[4];
+		priv->phandle->cac_period_jiffies = (t_u32)data[0] * HZ;
 		priv->phandle->usr_nop_period_sec = (t_u16)data[1];
 		req->action = MLAN_ACT_SET;
 #ifdef UAP_SUPPORT
@@ -10398,6 +11618,7 @@ static int woal_priv_dfs_testing(moal_private *priv, t_u8 *respbuf,
 		data[1] = ds_11hcfg->param.dfs_testing.usr_nop_period_sec;
 		data[2] = ds_11hcfg->param.dfs_testing.usr_no_chan_change;
 		data[3] = ds_11hcfg->param.dfs_testing.usr_fixed_new_chan;
+		data[4] = ds_11hcfg->param.dfs_testing.usr_cac_restart;
 		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
 				sizeof(data), respbuflen);
 		ret = sizeof(data);
@@ -10445,7 +11666,7 @@ static int woal_priv_dfs53cfg(moal_private *priv, t_u8 *respbuf,
 	ds_11hcfg->sub_command = MLAN_OID_11H_DFS_W53_CFG;
 	req->req_id = MLAN_IOCTL_11H_CFG;
 
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -10495,240 +11716,199 @@ static int woal_priv_dfs53cfg(moal_private *priv, t_u8 *respbuf,
 }
 
 /**
- *  @brief determine the center frquency center index for bandwidth
- *         of 80 MHz and 160 MHz
+ * @brief               Set/Get DFS mode settings
  *
- ** @param priv          Pointer to moal_private structure
- *  @param band         band
- *  @param pri_chan     primary channel
- *  @param chan_bw      channel bandwidth
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
  *
- *  @return             channel center frequency center, if found; O, otherwise
+ * @return             Number of bytes written, negative for failure.
  */
-
-t_u8 woal_get_center_freq_idx(moal_private *priv, t_u8 band, t_u32 pri_chan,
-			      t_u8 chan_bw)
+static int woal_priv_dfs_mode(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
 {
-	t_u8 center_freq_idx = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_cfg *ds_11hcfg = NULL;
+	int ret = 0;
+	int data = 0;
+	int user_data_len = 0, header_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
 
-	if (band & BAND_AAC) {
-		switch (pri_chan) {
-		case 36:
-		case 40:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 38;
-				break;
-			}
-			/* fall through */
-		case 44:
-		case 48:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 46;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 42;
-				break;
-			}
-			/* fall through */
-		case 52:
-		case 56:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 54;
-				break;
-			}
-			/* fall through */
-		case 60:
-		case 64:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 62;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 58;
-				break;
-			} else if (chan_bw == CHANNEL_BW_160MHZ) {
-				center_freq_idx = 50;
-				break;
-			}
-			/* fall through */
-		case 68:
-		case 72:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 70;
-				break;
-			}
-			/* fall through */
-		case 76:
-		case 80:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 78;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 74;
-				break;
-			}
-			/* fall through */
-		case 84:
-		case 88:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 86;
-				break;
-			}
-			/* fall through */
-		case 92:
-		case 96:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 94;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 90;
-				break;
-			}
-			/* fall through */
-		case 100:
-		case 104:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 102;
-				break;
-			}
-			/* fall through */
-		case 108:
-		case 112:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 110;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 106;
-				break;
-			}
-			/* fall through */
-		case 116:
-		case 120:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 118;
-				break;
-			}
-			/* fall through */
-		case 124:
-		case 128:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 126;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 122;
-			} else if (chan_bw == CHANNEL_BW_160MHZ) {
-				center_freq_idx = 114;
-			}
-			break;
-		case 132:
-		case 136:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 134;
-				break;
-			}
-			/* fall through */
-		case 140:
-		case 144:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 126;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 138;
-			}
-			break;
-		case 149:
-		case 153:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 151;
-				break;
-			}
-			/* fall through */
-		case 157:
-		case 161:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 159;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 155;
-				break;
-			}
-			/* fall through */
-		case 165:
-		case 169:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 167;
-				break;
-			}
-			/* fall through */
-		case 173:
-		case 177:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 175;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 171;
-				break;
-			}
-			/* fall through */
-		case 184:
-		case 188:
-			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 186;
-				break;
-			}
-			/* fall through */
-		case 192:
-		case 196:
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_MODE);
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	ds_11hcfg = (mlan_ds_11h_cfg *)req->pbuf;
+	ds_11hcfg->sub_command = MLAN_OID_11H_DFS_MODE;
+	req->req_id = MLAN_IOCTL_11H_CFG;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args !\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data > DFS_MODE_ENH) {
+			PRINTM(MERROR, "Invalid config for dfs_mode!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+
+		ds_11hcfg->param.dfs_mode = (t_u8)data;
+		req->action = MLAN_ACT_SET;
+	}
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (!user_data_len) {
+		moal_memcpy_ext(priv->phandle, respbuf,
+				(t_u8 *)&ds_11hcfg->param.dfs_mode,
+				sizeof(ds_11hcfg->param.dfs_mode), respbuflen);
+		ret = sizeof(t_u8);
+	}
+
+	PRINTM(MIOCTL, "dfs_mode %d\n", ds_11hcfg->param.dfs_mode);
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
+#ifdef UAP_SUPPORT
+
+/**
+ *  @brief determine the center frequency center index for bandwidth
+ *         of 40/80/160 MHz
+ *
+ ** @param priv         Pointer to moal_private structure
+ *  @param band         band
+ *  @param pri_chan     primary channel
+ *  @param chan_bw      channel bandwidth
+ *
+ *  @return             channel center frequency center, if found; O, otherwise
+ */
+static t_u8 woal_get_center_freq_idx(moal_private *priv, t_u16 band,
+				     t_u32 pri_chan, t_u8 chan_bw)
+{
+	struct center_freq_desc {
+		t_u8 pri_chan;
+		t_u8 ch_40;
+		t_u8 ch_80;
+		t_u8 ch_160;
+	};
+
+	static const struct center_freq_desc center_freq_idx_map_5g[] = {
+		{.pri_chan = 36, .ch_40 = 38, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 40, .ch_40 = 38, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 44, .ch_40 = 46, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 48, .ch_40 = 46, .ch_80 = 42, .ch_160 = 50},
+		{.pri_chan = 52, .ch_40 = 54, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 56, .ch_40 = 54, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 60, .ch_40 = 62, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 64, .ch_40 = 62, .ch_80 = 58, .ch_160 = 50},
+		{.pri_chan = 68, .ch_40 = 70, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 72, .ch_40 = 70, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 76, .ch_40 = 78, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 80, .ch_40 = 78, .ch_80 = 74, .ch_160 = 0},
+		{.pri_chan = 84, .ch_40 = 86, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 88, .ch_40 = 86, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 92, .ch_40 = 94, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 96, .ch_40 = 94, .ch_80 = 90, .ch_160 = 0},
+		{.pri_chan = 100, .ch_40 = 102, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 104, .ch_40 = 102, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 108, .ch_40 = 110, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 112, .ch_40 = 110, .ch_80 = 106, .ch_160 = 114},
+		{.pri_chan = 116, .ch_40 = 118, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 120, .ch_40 = 118, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 124, .ch_40 = 126, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 128, .ch_40 = 126, .ch_80 = 122, .ch_160 = 114},
+		{.pri_chan = 132, .ch_40 = 134, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 136, .ch_40 = 134, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 140, .ch_40 = 142, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 144, .ch_40 = 142, .ch_80 = 138, .ch_160 = 0},
+		{.pri_chan = 149, .ch_40 = 151, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 153, .ch_40 = 151, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 157, .ch_40 = 159, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 161, .ch_40 = 159, .ch_80 = 155, .ch_160 = 163},
+		{.pri_chan = 165, .ch_40 = 167, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 169, .ch_40 = 167, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 173, .ch_40 = 175, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 177, .ch_40 = 175, .ch_80 = 171, .ch_160 = 163},
+		{.pri_chan = 184, .ch_40 = 186, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 188, .ch_40 = 186, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 192, .ch_40 = 194, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 196, .ch_40 = 194, .ch_80 = 190, .ch_160 = 0},
+		{.pri_chan = 0,
+		 .ch_40 = 42 /* terminator with default cfreq */}};
+
+	const struct center_freq_desc *map = NULL;
+
+	if (band == BAND_5GHZ)
+		map = center_freq_idx_map_5g;
+
+	for (; map != NULL; map++) {
+		/* reached end of map, return default value for that map */
+		if (map->pri_chan == 0)
+			return map->ch_40;
+
+		if (map->pri_chan == pri_chan) {
 			if (chan_bw == CHANNEL_BW_40MHZ_ABOVE ||
-			    chan_bw == CHANNEL_BW_40MHZ_BELOW) {
-				center_freq_idx = 194;
-				break;
-			} else if (chan_bw == CHANNEL_BW_80MHZ) {
-				center_freq_idx = 190;
-				break;
-			}
-			/* fall through */
-		default: /* error. go to the default */
-			center_freq_idx = 42;
+			    chan_bw == CHANNEL_BW_40MHZ_BELOW)
+				return map->ch_40;
+
+			if (chan_bw == CHANNEL_BW_80MHZ)
+				return map->ch_80;
+
+			if (chan_bw == CHANNEL_BW_160MHZ)
+				return map->ch_160;
 		}
 	}
-	return center_freq_idx;
+
+	return 0;
 }
 
+#endif
+
+#if defined(UAP_SUPPORT)
 /**
- *  @brief determine the center frquency center index for bandwidth
- *         of 80 MHz and 160 MHz
+ *  @brief This function handles channel switch with CSA/ECSA IE.
  *
  ** @param priv          Pointer to moal_private structure
  *  @param block_tx      0-no need block traffic 1- need block traffic
  *  @param oper_class    oper_class
  *  @param channel       channel
  *  @param switch count  how many csa/ecsa beacon will send out
+ *  @param band          see BAND_5GHZ/BAND_6GHZ enum
  *  @param band_width    1-40Mhz above, 3-40Mhz below, 4-80Mhz, 5-160Mhz
  *  @param ecsa          MTRUE/MFALSE;
  *
  *  @return             channel center frequency center, if found; O, otherwise
  */
-
 static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 			       t_u8 oper_class, t_u8 channel, t_u8 switch_count,
-			       t_u8 band_width, t_u8 ecsa)
+			       t_u8 band, t_u8 band_width, t_u8 ecsa)
 {
 	IEEEtypes_ExtChanSwitchAnn_t *ext_chan_switch = NULL;
 	IEEEtypes_ChanSwitchAnn_t *chan_switch = NULL;
@@ -10760,18 +11940,25 @@ static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 
 	pcust_chansw_ie = (custom_ie *)&misc->param.cust_ie.ie_data_list[0];
 	pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
-	pcust_chansw_ie->ie_length = sizeof(IEEEtypes_ChanSwitchAnn_t);
+	pcust_chansw_ie->ie_length = 0;
 	pcust_chansw_ie->mgmt_subtype_mask =
 		MGMT_MASK_BEACON | MGMT_MASK_PROBE_RESP; /*Add IE for
 							    BEACON/probe resp*/
-	chan_switch = (IEEEtypes_ChanSwitchAnn_t *)pcust_chansw_ie->ie_buffer;
-	chan_switch->element_id = CHANNEL_SWITCH_ANN;
-	chan_switch->len = 3;
-	chan_switch->chan_switch_mode = block_tx;
-	chan_switch->new_channel_num = channel;
-	chan_switch->chan_switch_count = switch_count;
-	DBG_HEXDUMP(MCMD_D, "CSA IE", (t_u8 *)pcust_chansw_ie->ie_buffer,
-		    pcust_chansw_ie->ie_length);
+	pcust_chansw_ie->mgmt_subtype_mask |= MLAN_CUSTOM_IE_NEW_MASK;
+
+	if (band == BAND_2GHZ || band == BAND_5GHZ) {
+		pcust_chansw_ie->ie_length = sizeof(IEEEtypes_ChanSwitchAnn_t);
+		chan_switch =
+			(IEEEtypes_ChanSwitchAnn_t *)pcust_chansw_ie->ie_buffer;
+		chan_switch->element_id = CHANNEL_SWITCH_ANN;
+		chan_switch->len = 3;
+		chan_switch->chan_switch_mode = block_tx;
+		chan_switch->new_channel_num = channel;
+		chan_switch->chan_switch_count = switch_count;
+		DBG_HEXDUMP(MCMD_D, "CSA IE",
+			    (t_u8 *)pcust_chansw_ie->ie_buffer,
+			    pcust_chansw_ie->ie_length);
+	}
 	switch (band_width) {
 	case CHANNEL_BW_40MHZ_ABOVE:
 	case CHANNEL_BW_40MHZ_BELOW:
@@ -10791,27 +11978,23 @@ static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 		woal_priv_get_nonglobal_operclass_by_bw_channel(
 			priv, bw, channel, &new_oper_class);
 	if (new_oper_class) {
-		pcust_chansw_ie->ie_length +=
-			sizeof(IEEEtypes_ExtChanSwitchAnn_t);
-		ext_chan_switch =
-			(IEEEtypes_ExtChanSwitchAnn_t
-				 *)(pcust_chansw_ie->ie_buffer +
-				    sizeof(IEEEtypes_ChanSwitchAnn_t));
+		ext_chan_switch = (IEEEtypes_ExtChanSwitchAnn_t
+					   *)(pcust_chansw_ie->ie_buffer +
+					      pcust_chansw_ie->ie_length);
 		ext_chan_switch->element_id = EXTEND_CHANNEL_SWITCH_ANN;
 		ext_chan_switch->len = 4;
 		ext_chan_switch->chan_switch_mode = block_tx;
 		ext_chan_switch->new_oper_class = new_oper_class;
 		ext_chan_switch->new_channel_num = channel;
 		ext_chan_switch->chan_switch_count = switch_count;
-		DBG_HEXDUMP(MCMD_D, "ECSA IE",
-			    (t_u8 *)(pcust_chansw_ie->ie_buffer +
-				     sizeof(IEEEtypes_ChanSwitchAnn_t)),
-			    pcust_chansw_ie->ie_length -
-				    sizeof(IEEEtypes_ChanSwitchAnn_t));
+		pcust_chansw_ie->ie_length +=
+			sizeof(IEEEtypes_ExtChanSwitchAnn_t);
+		DBG_HEXDUMP(MCMD_D, "ECSA IE", (t_u8 *)ext_chan_switch,
+			    sizeof(IEEEtypes_ExtChanSwitchAnn_t));
 	}
 	/* bandwidth 40/80/160 should set channel switch wrapper ie for 11ac 5G
 	 * channel*/
-	if (band_width && channel > 14) {
+	if (band_width && (band == BAND_5GHZ)) {
 		pChanSwWrap_ie =
 			(IEEEtypes_Header_t *)(pcust_chansw_ie->ie_buffer +
 					       pcust_chansw_ie->ie_length);
@@ -10826,8 +12009,8 @@ static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 			sizeof(IEEEtypes_WideBWChanSwitch_t) -
 			sizeof(IEEEtypes_Header_t);
 
-		center_freq_idx = woal_get_center_freq_idx(priv, BAND_AAC,
-							   channel, band_width);
+		center_freq_idx = woal_get_center_freq_idx(priv, band, channel,
+							   band_width);
 		if (band_width == CHANNEL_BW_40MHZ_ABOVE ||
 		    band_width == CHANNEL_BW_40MHZ_BELOW) {
 			pbwchansw_ie->new_channel_width = 0;
@@ -10865,6 +12048,7 @@ static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 		pvhttpcEnv_ie->local_max_tp_20mhz = 0xff;
 		pvhttpcEnv_ie->local_max_tp_40mhz = 0xff;
 		pvhttpcEnv_ie->local_max_tp_80mhz = 0xff;
+		pvhttpcEnv_ie->local_max_tp_160mhz_80_80mhz = 0xff;
 		pChanSwWrap_ie->len += sizeof(IEEEtypes_VhtTpcEnvelope_t);
 		pcust_chansw_ie->ie_length +=
 			pChanSwWrap_ie->len + sizeof(IEEEtypes_Header_t);
@@ -10905,1204 +12089,3650 @@ static int woal_channel_switch(moal_private *priv, t_u8 block_tx,
 	LEAVE();
 	return ret;
 }
+#endif
 
+#ifdef UAP_SUPPORT
 /**
- * @brief               Set/Get CFP table codes
+ * @brief Given bandwidth and channel, create Band_Config
  *
- * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param priv         A pointer to moal_private
+ * @param bandcfg         A pointer to Band_Config_t structure
+ * @param channel         A pointer to cfg80211_chan_def structure
+ * @param bandwidth       0/1/3/4
  *
- * @return             Number of bytes written, negative for failure.
+ * @return                N/A
  */
-static int woal_priv_cfp_code(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static void woal_convert_chanbw_to_bandconfig(moal_private *priv,
+					      Band_Config_t *bandcfg,
+					      t_u8 channel, t_u8 bandwidth)
 {
-	int ret = 0;
-	int user_data_len = 0, header_len = 0;
-	int data[2] = {0};
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *misc_cfg = NULL;
-	mlan_ds_misc_cfp_code *cfp_code = NULL;
-	mlan_status status = MLAN_STATUS_SUCCESS;
-
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFP_CODE);
+	if (channel <= MAX_BG_CHANNEL)
+		bandcfg->chanBand = BAND_2GHZ;
+	else
+		bandcfg->chanBand = BAND_5GHZ;
+	switch (bandwidth) {
+	case CHANNEL_BW_40MHZ_ABOVE:
+		bandcfg->chanWidth = CHAN_BW_40MHZ;
+		bandcfg->chan2Offset = SEC_CHAN_ABOVE;
+		break;
+	case CHANNEL_BW_40MHZ_BELOW:
+		bandcfg->chanWidth = CHAN_BW_40MHZ;
+		bandcfg->chan2Offset = SEC_CHAN_BELOW;
+		break;
+	case CHANNEL_BW_80MHZ:
+		bandcfg->chanWidth = CHAN_BW_80MHZ;
+		bandcfg->chan2Offset =
+			woal_get_second_channel_offset(priv, channel);
+		break;
+	case CHANNEL_BW_20MHZ:
+	default:
+		bandcfg->chanWidth = CHAN_BW_20MHZ;
+		break;
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ * @brief Get DFS channel list
+ *
+ * @param priv         A pointer to moal_private
+ *
+ * @return                N/A
+ */
+static void woal_get_dfs_chan_list(moal_private *priv)
+{
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	struct wiphy *wiphy = priv->phandle->wiphy;
+	struct ieee80211_supported_band *sband;
+#endif
+	int i;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfp_misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
 
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	if (IS_STA_OR_UAP_CFG80211(priv->phandle->params.cfg80211_wext) &&
+	    wiphy) {
+		sband = wiphy->bands[NL80211_BAND_5GHZ];
+		if (sband) {
+			for (i = 0; i < sband->n_channels; i++) {
+				if (sband->channels[i].flags &
+				    IEEE80211_CHAN_RADAR) {
+					priv->auto_dfs_cfg.dfs_chan_list
+						[priv->auto_dfs_cfg.num_of_chan] =
+						sband->channels[i].hw_value;
+					priv->auto_dfs_cfg.num_of_chan++;
+				}
+			}
+			return;
+		}
+	}
+#endif
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	if (req == NULL)
 		goto done;
-	}
 
 	/* Fill request buffer */
-	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	cfp_code = &misc_cfg->param.cfp_code;
-	misc_cfg->sub_command = MLAN_OID_MISC_CFP_CODE;
+	cfp_misc = (mlan_ds_misc_cfg *)req->pbuf;
+	cfp_misc->sub_command = MLAN_OID_MISC_CFP_TABLE;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
-	} else {
-		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
-		if (user_data_len > 2) {
-			PRINTM(MERROR, "Invalid number of args!\n");
-			ret = -EINVAL;
-			goto done;
-		}
-		cfp_code->cfp_code_bg = data[0];
-		if (user_data_len == 2)
-			cfp_code->cfp_code_a = data[1];
-		req->action = MLAN_ACT_SET;
-	}
+	req->action = MLAN_ACT_GET;
+	cfp_misc->param.cfp.band = BAND_A;
 
 	/* Send IOCTL request to MLAN */
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
+	if (status != MLAN_STATUS_SUCCESS)
 		goto done;
-	}
 
-	if (!user_data_len) {
-		data[0] = cfp_code->cfp_code_bg;
-		data[1] = cfp_code->cfp_code_a;
-		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
-				sizeof(data), respbuflen);
-		ret = sizeof(data);
+	for (i = 0; i < cfp_misc->param.cfp.num_chan; i++) {
+		if (cfp_misc->param.cfp.cfp_tbl[i].dynamic.flags &
+		    NXP_CHANNEL_DISABLED)
+			continue;
+		if (cfp_misc->param.cfp.cfp_tbl[i].passive_scan_or_radar_detect) {
+			priv->auto_dfs_cfg
+				.dfs_chan_list[priv->auto_dfs_cfg.num_of_chan] =
+				cfp_misc->param.cfp.cfp_tbl[i].channel;
+			priv->auto_dfs_cfg.num_of_chan++;
+		}
 	}
-
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
 
 	LEAVE();
-	return ret;
+	return;
 }
 
 /**
- * @brief               Set/Get Tx/Rx antenna
+ * @brief               Process dfs cac command
  *
- * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param priv          a pointer to moal_private structure
+ * @param ch_rpt_req    a pointer to mlan_ds_11h_chan_rep_req structure
  *
- * @return             Number of bytes written, negative for failure.
+ * @return              MLAN_STATUS_FAILRUE or MLAN_STATUS_SUCCESS
  */
-static int woal_priv_set_get_tx_rx_ant(moal_private *priv, t_u8 *respbuf,
-				       t_u32 respbuflen)
+mlan_status woal_do_dfs_cac(moal_private *priv,
+			    mlan_ds_11h_chan_rep_req *ch_rpt_req)
 {
-	int ret = 0;
-	int user_data_len = 0, header_len = 0;
-	mlan_ds_radio_cfg *radio = NULL;
 	mlan_ioctl_req *req = NULL;
-	int data[3] = {0};
+	mlan_ds_11h_cfg *p11h_cfg = NULL;
+	mlan_ds_11h_chan_rep_req *pchan_rpt_req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-	struct wiphy *wiphy = priv->phandle->wiphy;
-#endif
 
 	ENTER();
-
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ANT_CFG);
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_radio_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
-		goto done;
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (NULL == req) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
 	}
-	radio = (mlan_ds_radio_cfg *)req->pbuf;
-	radio->sub_command = MLAN_OID_ANT_CFG;
-	req->req_id = MLAN_IOCTL_RADIO_CFG;
+	p11h_cfg = (mlan_ds_11h_cfg *)req->pbuf;
+	pchan_rpt_req = &p11h_cfg->param.chan_rpt_req;
 
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
-	} else {
-		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
-		if (user_data_len > 2) {
-			PRINTM(MERROR, "Invalid number of args!\n");
-			ret = -EINVAL;
-			goto done;
-		}
-		if (priv->phandle->feature_control & FEATURE_CTRL_STREAM_2X2) {
-			radio->param.ant_cfg.tx_antenna = data[0];
-			radio->param.ant_cfg.rx_antenna = data[0];
-			if (user_data_len == 2)
-				radio->param.ant_cfg.rx_antenna = data[1];
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-			if (IS_CARD9098(priv->phandle->card_type) ||
-			    IS_CARD9097(priv->phandle->card_type)) {
-				if (IS_STA_OR_UAP_CFG80211(
-					    priv->phandle->params
-						    .cfg80211_wext) &&
-				    wiphy) {
-					if (wiphy->bands[IEEE80211_BAND_2GHZ]) {
-						if (((radio->param.ant_cfg
-							      .tx_antenna &
-						      0xFF) != 3 &&
-						     (radio->param.ant_cfg
-							      .tx_antenna &
-						      0xFF) != 0) ||
-						    ((radio->param.ant_cfg
-							      .rx_antenna &
-						      0xFF) != 3 &&
-						     (radio->param.ant_cfg
-							      .rx_antenna &
-						      0xFF) != 0))
-							wiphy->bands[IEEE80211_BAND_2GHZ]
-								->ht_cap.mcs
-								.rx_mask[1] = 0;
-						else if ((radio->param.ant_cfg
-								  .tx_antenna &
-							  0xFF) == 3 ||
-							 (radio->param.ant_cfg
-								  .rx_antenna &
-							  0xFF) == 3)
-							wiphy->bands[IEEE80211_BAND_2GHZ]
-								->ht_cap.mcs
-								.rx_mask[1] =
-								0xff;
-						wiphy->bands[IEEE80211_BAND_2GHZ]
-							->ht_cap.mcs.rx_mask[4] =
-							0;
-					}
-					if (wiphy->bands[IEEE80211_BAND_5GHZ]) {
-						if (((radio->param.ant_cfg
-							      .tx_antenna &
-						      0xFF00) != 0x300 &&
-						     (radio->param.ant_cfg
-							      .tx_antenna &
-						      0xFF00) != 0) ||
-						    ((radio->param.ant_cfg
-							      .rx_antenna &
-						      0xFF00) != 0x300 &&
-						     (radio->param.ant_cfg
-							      .rx_antenna &
-						      0xFF00) != 0)) {
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->ht_cap.mcs
-								.rx_mask[1] = 0;
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->vht_cap
-								.vht_mcs
-								.rx_mcs_map =
-								0xfffe;
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->vht_cap
-								.vht_mcs
-								.tx_mcs_map =
-								0xfffe;
-						} else if ((radio->param.ant_cfg
-								    .tx_antenna &
-							    0xFF00) == 0x300 ||
-							   (radio->param.ant_cfg
-								    .rx_antenna &
-							    0xFF00) == 0x300) {
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->ht_cap.mcs
-								.rx_mask[1] =
-								0xff;
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->vht_cap
-								.vht_mcs
-								.rx_mcs_map =
-								0xfffa;
-							wiphy->bands[IEEE80211_BAND_5GHZ]
-								->vht_cap
-								.vht_mcs
-								.tx_mcs_map =
-								0xfffa;
-						}
-					}
-				}
+	moal_memcpy_ext(priv->phandle, pchan_rpt_req, ch_rpt_req,
+			sizeof(mlan_ds_11h_chan_rep_req),
+			sizeof(mlan_ds_11h_chan_rep_req));
+
+	if (priv->bss_type == MLAN_BSS_TYPE_DFS)
+		p11h_cfg->sub_command = MLAN_OID_11H_CHAN_REPORT_REQUEST;
+	else
+		p11h_cfg->sub_command = MLAN_OID_11H_CHANNEL_CHECK;
+
+	req->req_id = MLAN_IOCTL_11H_CFG;
+
+	req->action = MLAN_ACT_SET;
+	/* Send Channel Check command and wait until the report is ready */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return status;
+}
+
+/**
+ * @brief               Get Next DFS channel from dfs_chan_list
+ *
+ * @param priv          a pointer to moal_private structure
+ *
+ * @return              N/A
+ *
+ */
+static t_u8 woal_get_next_dfs_chan(moal_private *priv)
+{
+	int i;
+	int idx = priv->curr_cac_idx;
+	mlan_ds_11h_chan_dfs_state ch_dfs_state;
+	t_u8 chan = 0;
+	ENTER();
+	idx++;
+	if (idx >= priv->auto_dfs_cfg.num_of_chan)
+		idx = 0;
+	for (i = 0; i < priv->auto_dfs_cfg.num_of_chan; i++) {
+		if (priv->chan_rpt_req.chanNum !=
+		    priv->auto_dfs_cfg.dfs_chan_list[idx]) {
+			memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+			ch_dfs_state.channel =
+				priv->auto_dfs_cfg.dfs_chan_list[idx];
+			if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+						    &ch_dfs_state)) {
+				PRINTM(MERROR,
+				       "%s: woal_11h_chan_dfs_state failed \n",
+				       __func__);
+				continue;
+			}
+			if (ch_dfs_state.dfs_state != DFS_UNAVAILABLE) {
+				chan = priv->auto_dfs_cfg.dfs_chan_list[idx];
+				priv->curr_cac_idx = idx;
+				break;
 			}
-#endif
-		} else {
-			radio->param.ant_cfg_1x1.antenna = data[0];
-			if (user_data_len == 2)
-				radio->param.ant_cfg_1x1.evaluate_time =
-					data[1];
 		}
-		req->action = MLAN_ACT_SET;
-	}
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
+		idx++;
+		if (idx >= priv->auto_dfs_cfg.num_of_chan)
+			idx = 0;
 	}
-	if (!user_data_len) {
-		if (priv->phandle->feature_control & FEATURE_CTRL_STREAM_2X2) {
-			data[0] = radio->param.ant_cfg.tx_antenna;
-			data[1] = radio->param.ant_cfg.rx_antenna;
-			if (data[0] && data[1])
-				ret = sizeof(int) * 2;
-			else
-				ret = sizeof(int) * 1;
-			moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
-					sizeof(data), respbuflen);
-		} else {
-			data[0] = (int)radio->param.ant_cfg_1x1.antenna;
-			data[1] = (int)radio->param.ant_cfg_1x1.evaluate_time;
-			data[2] = (int)radio->param.ant_cfg_1x1.current_antenna;
-			moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
-					sizeof(data), respbuflen);
-			ret = sizeof(data);
+	LEAVE();
+	return chan;
+}
+
+/**
+ * @brief               Process auto dfs cac
+ *
+ * @param priv          a pointer to moal_private structure
+ *
+ * @return              N/A
+ *
+ */
+static void woal_do_auto_dfs(moal_private *priv)
+{
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
+	ENTER();
+	if (priv->auto_dfs_cfg.multi_chan_dfs &&
+	    priv->auto_dfs_cfg.num_of_chan) {
+		memset(&chan_rpt_req, 0, sizeof(chan_rpt_req));
+		chan_rpt_req.startFreq = START_FREQ_11A_BAND;
+		chan_rpt_req.chanNum = woal_get_next_dfs_chan(priv);
+		if (priv->chan_rpt_req.chanNum) {
+			if (woal_11h_cancel_chan_report_ioctl(priv,
+							      MOAL_IOCTL_WAIT))
+				PRINTM(MERROR,
+				       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+				       __func__);
+			memset(&priv->chan_rpt_req, 0,
+			       sizeof(mlan_ds_11h_chan_rep_req));
+		}
+		if (chan_rpt_req.chanNum) {
+			chan_rpt_req.bandcfg.chanBand = BAND_5GHZ;
+			chan_rpt_req.bandcfg.chanWidth = priv->auto_dfs_cfg.bw;
+			chan_rpt_req.millisec_dwell_time =
+				priv->auto_dfs_cfg.cac_timer;
+			moal_memcpy_ext(priv->phandle, &priv->chan_rpt_req,
+					&chan_rpt_req,
+					sizeof(mlan_ds_11h_chan_rep_req),
+					sizeof(mlan_ds_11h_chan_rep_req));
+			PRINTM(MCMND,
+			       "ZeroDFS: AUTO DFS Start Radar detect on channel=%d, bandwidth=%d, cac time=%d\n",
+			       chan_rpt_req.chanNum,
+			       (int)(chan_rpt_req.bandcfg.chanWidth),
+			       chan_rpt_req.millisec_dwell_time);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_do_dfs_cac(priv, &chan_rpt_req))
+				PRINTM(MERROR, "%s: woal_do_dfs_cac failed \n",
+				       __func__);
 		}
 	}
-done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
-	return ret;
+	return;
 }
 
 /*
- * @brief               Set/Get CWMode
+ * @brief  prepare and send WOAL_EVENT_CHAN_RPT/WOAL_EVENT_RADAR
  *
- * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param priv           A pointer moal_private structure
+ * @param type 			 WOAL_EVENT_CHAN_RPT/WOAL_EVENT_RADAR
+ * @param channel 		 channel
+ * @param radar          MTRUE/MFALSE
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return          N/A
  */
-static int woal_priv_set_get_cwmode(moal_private *priv, t_u8 *respbuf,
-				    t_u32 respbuflen)
+void woal_chan_event(moal_private *priv, t_u8 type, t_u8 channel, t_u8 radar)
 {
-	mlan_ioctl_req *ioctl_req = NULL;
-	mlan_ds_misc_cfg *misc = NULL;
-	mlan_status status = MLAN_STATUS_SUCCESS;
-	mlan_ds_cw_mode_ctrl *cwmode;
-	int ret = 0;
-	int header_len = 0;
-
-	ENTER();
+	struct woal_event *evt;
+	unsigned long flags;
+	moal_handle *handle = priv->phandle;
 
-	if (!priv || !priv->phandle) {
-		PRINTM(MERROR, "priv or handle is null\n");
-		ret = -EFAULT;
-		goto done;
-	}
+	evt = kzalloc(sizeof(struct woal_event), GFP_ATOMIC);
+	if (!evt) {
+		PRINTM(MERROR, "Fail to alloc memory for deauth event\n");
+		LEAVE();
+		return;
+	}
+	evt->priv = priv;
+	evt->type = type;
+	evt->radar_info.channel = channel;
+	evt->radar_info.radar = radar;
+	INIT_LIST_HEAD(&evt->link);
+	spin_lock_irqsave(&handle->evt_lock, flags);
+	list_add_tail(&evt->link, &handle->evt_queue);
+	spin_unlock_irqrestore(&handle->evt_lock, flags);
+	queue_work(handle->evt_workqueue, &handle->evt_work);
+}
 
-	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (ioctl_req == NULL) {
-		ret = -ENOMEM;
-		goto done;
+/**
+ * @brief               Get active UAP handler
+ *
+ * @param handle        a pointer to moal_handle structure
+ *
+ * @return              N/A
+ *
+ */
+static moal_private *woal_get_active_uap_interface(moal_handle *handle)
+{
+	int i;
+	moal_private *priv = NULL;
+	for (i = 0; i < handle->priv_num; i++) {
+		if (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_UAP) {
+			if (handle->priv[i]->bss_started == MTRUE) {
+				priv = handle->priv[i];
+				break;
+			}
+		}
 	}
+	return priv;
+}
 
-	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_CWMODE_CTRL;
-	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+/**
+ * @brief               handle auto uap channel switch
+ *
+ * @param priv          a pointer to moal_private structure
+ * @param channel       channel
+ *
+ * @return              N/A
+ *
+ */
+static void woal_auto_uap_channel_switch(moal_private *priv, t_u8 channel)
+{
+	moal_private *pmpriv = NULL;
+	chan_band_info chaninfo;
+	t_u8 band = BAND_2GHZ;
+	moal_handle *ref_handle;
+	t_u8 band_width = CHANNEL_BW_20MHZ;
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CWMODE);
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		ioctl_req->action = MLAN_ACT_GET;
-	} else {
-		/* SET operation */
-		ioctl_req->action = MLAN_ACT_SET;
+	memset(&chaninfo, 0, sizeof(chaninfo));
 
-		cwmode = (mlan_ds_cw_mode_ctrl *)(respbuf + header_len +
-						  sizeof(t_u8));
-		misc->param.cwmode.mode = cwmode->mode;
-		misc->param.cwmode.txPower = cwmode->txPower;
-		misc->param.cwmode.rateInfo = cwmode->rateInfo;
-		misc->param.cwmode.channel = cwmode->channel;
-		misc->param.cwmode.chanInfo = cwmode->chanInfo;
-		misc->param.cwmode.pktLength = cwmode->pktLength;
+	pmpriv = woal_get_active_uap_interface(priv->phandle);
+	if (!pmpriv) {
+		ref_handle = (moal_handle *)priv->phandle->pref_mac;
+		pmpriv = woal_get_active_uap_interface(ref_handle);
 	}
-
-	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
+	if (pmpriv) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_ap_channel(pmpriv, MLAN_ACT_GET,
+					    MOAL_IOCTL_WAIT, &chaninfo)) {
+			PRINTM(MERROR, "Fail to get ap channel \n");
+			return;
+		}
+		if (chaninfo.channel != channel) {
+			switch (chaninfo.bandcfg.chanWidth) {
+			case CHAN_BW_40MHZ:
+				if (chaninfo.bandcfg.chan2Offset ==
+				    SEC_CHAN_BELOW)
+					band_width = CHANNEL_BW_40MHZ_BELOW;
+				else if (chaninfo.bandcfg.chan2Offset ==
+					 SEC_CHAN_ABOVE)
+					band_width = CHANNEL_BW_40MHZ_ABOVE;
+				break;
+			case CHAN_BW_80MHZ:
+				band_width = CHANNEL_BW_80MHZ;
+				break;
+			default:
+				band_width = CHANNEL_BW_20MHZ;
+				break;
+			}
+			if (channel > MAX_BG_CHANNEL)
+				band = BAND_5GHZ;
+#define DEF_SWITCH_COUNT 10
+			woal_channel_switch(pmpriv, MTRUE, 0, channel,
+					    DEF_SWITCH_COUNT, band, band_width,
+					    MTRUE);
+		}
 	}
+}
 
-	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&misc->param.cwmode,
-			sizeof(misc->param.cwmode), respbuflen);
-	ret = sizeof(misc->param.cwmode);
-
-done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(ioctl_req);
+/**
+ * @brief               Process channel event
+ *
+ * @param priv          a pointer to moal_private structure
+ * @param type 			WOAL_EVENT_CHAN_RPT/WOAL_EVENT_RADAR
+ * @param channel       channel
+ * @param radar         radar
+ *
+ * @return              N/A
+ *
+ */
+void woal_process_chan_event(moal_private *priv, t_u8 type, t_u8 channel,
+			     t_u8 radar)
+{
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
+
+	if (!priv->auto_dfs_cfg.start_auto_zero_dfs)
+		return;
+	if (type == WOAL_EVENT_CHAN_RPT) {
+		if (priv->auto_dfs_cfg.uap_chan_switch && !radar) {
+			priv->auto_dfs_cfg.uap_chan_switch = MFALSE;
+			PRINTM(MCMND, "Trying uap_chan_switch to %d\n",
+			       channel);
+			woal_auto_uap_channel_switch(priv, channel);
+		}
+		woal_do_auto_dfs(priv);
+	} else if (type == WOAL_EVENT_RADAR) {
+		memset(&chan_rpt_req, 0, sizeof(chan_rpt_req));
+		chan_rpt_req.startFreq = START_FREQ_11A_BAND;
+		chan_rpt_req.chanNum = woal_get_next_dfs_chan(priv);
+		if (priv->chan_rpt_req.chanNum) {
+			if (woal_11h_cancel_chan_report_ioctl(priv,
+							      MOAL_IOCTL_WAIT))
+				PRINTM(MERROR,
+				       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+				       __func__);
+			memset(&priv->chan_rpt_req, 0,
+			       sizeof(mlan_ds_11h_chan_rep_req));
+		}
+		if (chan_rpt_req.chanNum) {
+			chan_rpt_req.bandcfg.chanBand = BAND_5GHZ;
+			chan_rpt_req.bandcfg.chanWidth = priv->auto_dfs_cfg.bw;
+			chan_rpt_req.millisec_dwell_time =
+				priv->auto_dfs_cfg.cac_timer;
+			moal_memcpy_ext(priv->phandle, &priv->chan_rpt_req,
+					&chan_rpt_req,
+					sizeof(mlan_ds_11h_chan_rep_req),
+					sizeof(mlan_ds_11h_chan_rep_req));
+			PRINTM(MCMND,
+			       "ZeroDFS: AUTO DFS Start Radar detect on channel=%d, bandwidth=%d, cac time=%d\n",
+			       chan_rpt_req.chanNum,
+			       (int)(chan_rpt_req.bandcfg.chanWidth),
+			       chan_rpt_req.millisec_dwell_time);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_do_dfs_cac(priv, &chan_rpt_req))
+				PRINTM(MERROR, "%s: woal_do_dfs_cac failed \n",
+				       __func__);
+		}
+	}
+}
 
+/**
+ * @brief               check if channel under nop
+ *
+ * @param priv          a pointer to moal_private structure
+ * @param channel       WIFI channel
+ *
+ * @return              length
+ */
+static t_u8 woal_is_channel_under_nop(moal_private *priv, t_u8 channel)
+{
+	mlan_ds_11h_chan_nop_info chan_nop_info;
+	t_u8 ret = MFALSE;
+	ENTER();
+	memset(&chan_nop_info, 0, sizeof(chan_nop_info));
+	chan_nop_info.curr_chan = channel;
+	woal_uap_get_channel_nop_info(priv, MOAL_IOCTL_WAIT, &chan_nop_info);
+	if (chan_nop_info.chan_under_nop)
+		ret = MTRUE;
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Set/Get out band independent reset
+ * @brief               Process dfs cac command
  *
- * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param priv          a pointer to moal_private structure
+ * @param respbuf       respbuf buffer
+ * @param respbuflen    respbuf length
  *
- * @return             Number of bytes written, negative for failure.
+ * @return              length
  */
-static int woal_priv_ind_rst_cfg(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_priv_do_dfs_cac(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
 {
 	int ret = 0;
+	int data[3] = {0};
 	int user_data_len = 0, header_len = 0;
-	mlan_ds_misc_cfg *misc = NULL;
-	mlan_ioctl_req *req = NULL;
-	int data[2] = {0};
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_11h_chan_dfs_state ch_dfs_state;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_IND_RST_CFG);
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
-		goto done;
-	}
-	misc = (mlan_ds_misc_cfg *)req->pbuf;
-	memset(misc, 0, sizeof(mlan_ds_misc_cfg));
-	misc->sub_command = MLAN_OID_MISC_IND_RST_CFG;
-	req->req_id = MLAN_IOCTL_MISC_CFG;
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_CAC);
 
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
-	} else {
+	if ((int)strlen(respbuf) >= header_len) {
+		memset(&chan_rpt_req, 0, sizeof(chan_rpt_req));
 		/* SET operation */
 		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
 				&user_data_len);
-		if (user_data_len > 2) {
-			PRINTM(MERROR, "Invalid number of args!\n");
-			ret = -EINVAL;
-			goto done;
+		if (user_data_len >= 1) {
+			if (!data[0] ||
+			    (priv->chan_rpt_req.chanNum &&
+			     (priv->chan_rpt_req.chanNum != data[0]))) {
+				if (priv->chan_rpt_pending ||
+				    (priv->bss_type == MLAN_BSS_TYPE_DFS)) {
+					if (woal_11h_cancel_chan_report_ioctl(
+						    priv, MOAL_IOCTL_WAIT)) {
+						PRINTM(MERROR,
+						       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+						       __func__);
+						LEAVE();
+						return -EFAULT;
+					}
+					priv->chan_rpt_pending = MFALSE;
+				}
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+				if (!data[0] && priv->chan_rpt_req.chanNum) {
+					memset(&ch_dfs_state, 0,
+					       sizeof(ch_dfs_state));
+					ch_dfs_state.channel =
+						priv->chan_rpt_req.chanNum;
+					if (!woal_11h_chan_dfs_state(
+						    priv, MLAN_ACT_GET,
+						    &ch_dfs_state)) {
+						if (ch_dfs_state.dfs_state ==
+						    DFS_AVAILABLE)
+							woal_update_channels_dfs_state(
+								priv,
+								priv->chan_rpt_req
+									.chanNum,
+								priv->chan_rpt_req
+									.bandcfg
+									.chanWidth,
+								DFS_USABLE);
+					}
+				}
+#endif
+#endif
+				memset(&priv->chan_rpt_req, 0,
+				       sizeof(mlan_ds_11h_chan_rep_req));
+				PRINTM(MCMND, "DFS: Stop Radar detect\n");
+				if (!data[0]) {
+					if (priv->bss_type == MLAN_BSS_TYPE_UAP)
+						woal_uap_11h_ctrl(priv, MFALSE);
+					LEAVE();
+					return ret;
+				}
+			}
+			if (data[0] == priv->chan_rpt_req.chanNum &&
+			    priv->bss_type == MLAN_BSS_TYPE_UAP)
+				woal_uap_11h_ctrl(priv, MFALSE);
+			memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+			ch_dfs_state.channel = data[0];
+			if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+						    &ch_dfs_state)) {
+				PRINTM(MERROR,
+				       "%s: woal_11h_chan_dfs_state failed \n",
+				       __func__);
+				LEAVE();
+				return -EFAULT;
+			}
+			if (!ch_dfs_state.dfs_required ||
+			    ch_dfs_state.dfs_state == DFS_UNAVAILABLE) {
+				PRINTM(MCMND,
+				       "DFS: This channel=%d under NOP or not DFS channel\n",
+				       data[0]);
+				LEAVE();
+				return -EINVAL;
+			}
+			if (woal_is_channel_under_nop(priv, data[0])) {
+				PRINTM(MCMND,
+				       "DFS: This channel=%d under NOP\n",
+				       data[0]);
+				LEAVE();
+				return -EINVAL;
+			}
+			chan_rpt_req.startFreq = START_FREQ_11A_BAND;
+			chan_rpt_req.chanNum = data[0];
+			chan_rpt_req.bandcfg.chanBand = BAND_5GHZ;
+			chan_rpt_req.bandcfg.chanWidth = CHAN_BW_20MHZ;
+			chan_rpt_req.millisec_dwell_time = DEF_CAC_DWELL_TIME;
+			chan_rpt_req.host_based = MTRUE;
+		}
+		if (user_data_len >= 2) {
+			if (data[1] < 0 || data[1] > CHANNEL_BW_80MHZ) {
+				PRINTM(MERROR, "Inavalid bandwidth %d\n",
+				       data[1]);
+				LEAVE();
+				return -EINVAL;
+			}
+			woal_convert_chanbw_to_bandconfig(priv,
+							  &chan_rpt_req.bandcfg,
+							  chan_rpt_req.chanNum,
+							  data[1]);
+		}
+		if (user_data_len >= 3)
+			chan_rpt_req.millisec_dwell_time =
+				MIN(MAX_CAC_DWELL_TIME, data[2] * 1000);
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+		else {
+			if ((woal_is_etsi_country(
+				     priv->phandle->country_code) == MTRUE)) {
+				if (chan_rpt_req.chanNum == 120 ||
+				    chan_rpt_req.chanNum == 124 ||
+				    chan_rpt_req.chanNum == 128) {
+					chan_rpt_req.millisec_dwell_time =
+						DEF_CAC_DWELL_TIME * 10;
+				}
+				if (chan_rpt_req.chanNum == 116 &&
+				    user_data_len >= 2 && data[1] > 0)
+					chan_rpt_req.millisec_dwell_time =
+						DEF_CAC_DWELL_TIME * 10;
+			}
 		}
+#endif
+		moal_memcpy_ext(priv->phandle, &priv->chan_rpt_req,
+				&chan_rpt_req, sizeof(mlan_ds_11h_chan_rep_req),
+				sizeof(mlan_ds_11h_chan_rep_req));
+		PRINTM(MCMND,
+		       "DFS: Start Radar detect on channel=%d, bandwidth=%d, cac time=%d\n",
+		       chan_rpt_req.chanNum,
+		       (int)(chan_rpt_req.bandcfg.chanWidth),
+		       chan_rpt_req.millisec_dwell_time);
+		status = woal_do_dfs_cac(priv, &chan_rpt_req);
+		if (status != MLAN_STATUS_SUCCESS)
+			ret = -EFAULT;
+		else
+			priv->chan_rpt_pending = MTRUE;
+	}
+	LEAVE();
+	return ret;
+}
 
-		if ((user_data_len == 1) || (user_data_len == 2)) {
-			req->action = MLAN_ACT_SET;
+/**
+ * @brief               Set Auto Zero DFS configure
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return              0 --success, otherwise fail
+ */
+static int woal_priv_auto_dfs_cfg(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
+{
+	int ret = 0;
+	int header_len = 0;
+	auto_zero_dfs_cfg *auto_dfs_cfg = NULL;
+	int i;
+	int idx = 0;
+	mlan_ds_11h_chan_dfs_state ch_dfs_state;
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
 
-			/* ir_mode */
-			if (data[0] < 0 || data[0] > 2) {
-				PRINTM(MERROR, "Invalid ir mode parameter!\n");
-				ret = -EINVAL;
+	ENTER();
+	if (priv->bss_type != MLAN_BSS_TYPE_DFS) {
+		PRINTM(MWARN, "Invalid BSS type\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_AUTODFS);
+	auto_dfs_cfg = (auto_zero_dfs_cfg *)(respbuf + header_len);
+	/** Auto DFS is enabled and save config to moal_private structure */
+	if (auto_dfs_cfg->start_auto_zero_dfs) {
+		if (priv->auto_dfs_cfg.start_auto_zero_dfs ||
+		    priv->chan_rpt_req.chanNum) {
+			if (woal_11h_cancel_chan_report_ioctl(
+				    priv, MOAL_IOCTL_WAIT)) {
+				PRINTM(MERROR,
+				       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+				       __func__);
+				ret = -EFAULT;
 				goto done;
 			}
-			misc->param.ind_rst_cfg.ir_mode = data[0];
-
-			/* gpio_pin */
-			if (user_data_len == 2) {
-				if ((data[1] != 0xFF) && (data[1] < 0)) {
+			memset(&priv->chan_rpt_req, 0,
+			       sizeof(mlan_ds_11h_chan_rep_req));
+		}
+		memset(&priv->auto_dfs_cfg, 0, sizeof(auto_zero_dfs_cfg));
+		if (auto_dfs_cfg->cac_start_chan) {
+			memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+			ch_dfs_state.channel = auto_dfs_cfg->cac_start_chan;
+			if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+						    &ch_dfs_state)) {
+				PRINTM(MERROR,
+				       "%s: woal_11h_chan_dfs_state failed \n",
+				       __func__);
+				ret = -EFAULT;
+				goto done;
+			}
+			if (!ch_dfs_state.dfs_required ||
+			    ch_dfs_state.dfs_state == DFS_UNAVAILABLE) {
+				PRINTM(MCMND,
+				       "ZeroDFS: This channel=%d under NOP or not DFS channel\n",
+				       auto_dfs_cfg->cac_start_chan);
+				LEAVE();
+				return -EINVAL;
+			}
+		}
+		priv->auto_dfs_cfg.cac_start_chan =
+			auto_dfs_cfg->cac_start_chan;
+		if (auto_dfs_cfg->cac_timer)
+			priv->auto_dfs_cfg.cac_timer =
+				MIN(MAX_CAC_DWELL_TIME,
+				    auto_dfs_cfg->cac_timer * 1000);
+		else
+			priv->auto_dfs_cfg.cac_timer = DEF_CAC_DWELL_TIME;
+		if ((auto_dfs_cfg->bw != CHANNEL_BW_20MHZ) &&
+		    (auto_dfs_cfg->bw != CHANNEL_BW_40MHZ_ABOVE) &&
+		    (auto_dfs_cfg->bw != CHANNEL_BW_40MHZ_BELOW) &&
+		    (auto_dfs_cfg->bw != CHANNEL_BW_80MHZ)) {
+			PRINTM(MERROR, "ZeroDFS: Invalid bw = %d\n",
+			       auto_dfs_cfg->bw);
+			LEAVE();
+			return -EINVAL;
+		}
+		priv->auto_dfs_cfg.bw = auto_dfs_cfg->bw;
+		priv->auto_dfs_cfg.uap_chan_switch =
+			auto_dfs_cfg->uap_chan_switch;
+		priv->auto_dfs_cfg.multi_chan_dfs =
+			auto_dfs_cfg->multi_chan_dfs;
+		if (auto_dfs_cfg->num_of_chan) {
+			for (i = 0; i < auto_dfs_cfg->num_of_chan; i++) {
+				memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+				ch_dfs_state.channel =
+					auto_dfs_cfg->dfs_chan_list[i];
+				if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+							    &ch_dfs_state)) {
 					PRINTM(MERROR,
-					       "Invalid gpio pin no!\n");
-					ret = -EINVAL;
+					       "%s: woal_11h_chan_dfs_state failed \n",
+					       __func__);
+					ret = -EFAULT;
 					goto done;
 				}
-				misc->param.ind_rst_cfg.gpio_pin = data[1];
+				if (!ch_dfs_state.dfs_required)
+					continue;
+				priv->auto_dfs_cfg.dfs_chan_list[idx] =
+					auto_dfs_cfg->dfs_chan_list[i];
+				idx++;
+			}
+			priv->auto_dfs_cfg.num_of_chan = idx;
+		}
+		if (!priv->auto_dfs_cfg.num_of_chan)
+			woal_get_dfs_chan_list(priv);
+		priv->curr_cac_idx = -1;
+		if (!priv->auto_dfs_cfg.cac_start_chan)
+			priv->auto_dfs_cfg.cac_start_chan =
+				woal_get_next_dfs_chan(priv);
+		PRINTM(MCMND, "Start Auto ZeroDFS\n");
+		PRINTM(MCMND, "cac_start_chan=%d\n",
+		       priv->auto_dfs_cfg.cac_start_chan);
+		PRINTM(MCMND, "cac_timer=%d\n", priv->auto_dfs_cfg.cac_timer);
+		PRINTM(MCMND, "bw=%d\n", priv->auto_dfs_cfg.bw);
+		PRINTM(MCMND, "uap_chan_switch=%d\n",
+		       priv->auto_dfs_cfg.uap_chan_switch);
+		PRINTM(MCMND, "multi_chan_dfs=%d\n",
+		       priv->auto_dfs_cfg.multi_chan_dfs);
+		PRINTM(MCMND, "num of chan=%d\n",
+		       priv->auto_dfs_cfg.num_of_chan);
+		DBG_HEXDUMP(MCMD_D, "dfs chan list",
+			    priv->auto_dfs_cfg.dfs_chan_list,
+			    priv->auto_dfs_cfg.num_of_chan);
+		if (priv->auto_dfs_cfg.cac_start_chan) {
+			priv->auto_dfs_cfg.start_auto_zero_dfs = MTRUE;
+			memset(&chan_rpt_req, 0, sizeof(chan_rpt_req));
+			chan_rpt_req.startFreq = START_FREQ_11A_BAND;
+			chan_rpt_req.chanNum =
+				priv->auto_dfs_cfg.cac_start_chan;
+			chan_rpt_req.bandcfg.chanBand = BAND_5GHZ;
+			chan_rpt_req.bandcfg.chanWidth = priv->auto_dfs_cfg.bw;
+			chan_rpt_req.millisec_dwell_time =
+				priv->auto_dfs_cfg.cac_timer;
+			moal_memcpy_ext(priv->phandle, &priv->chan_rpt_req,
+					&chan_rpt_req,
+					sizeof(mlan_ds_11h_chan_rep_req),
+					sizeof(mlan_ds_11h_chan_rep_req));
+			PRINTM(MCMND,
+			       "ZeroDFS: AUTO DFS Start Radar detect on channel=%d, bandwidth=%d, cac time=%d\n",
+			       chan_rpt_req.chanNum,
+			       (int)(chan_rpt_req.bandcfg.chanWidth),
+			       chan_rpt_req.millisec_dwell_time);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_do_dfs_cac(priv, &chan_rpt_req)) {
+				PRINTM(MERROR, "%s: woal_do_dfs_cac failed \n",
+				       __func__);
+				ret = -EFAULT;
 			}
 		}
+	} else {
+		PRINTM(MCMND, "Stop Auto ZeroDFS\n");
+		if (woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR,
+			       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+			       __func__);
+		memset(&priv->chan_rpt_req, 0,
+		       sizeof(mlan_ds_11h_chan_rep_req));
+		memset(&priv->auto_dfs_cfg, 0, sizeof(auto_zero_dfs_cfg));
 	}
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
-	}
-
-	data[0] = (int)misc->param.ind_rst_cfg.ir_mode;
-	data[1] = (int)misc->param.ind_rst_cfg.gpio_pin;
-	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data, sizeof(data),
-			respbuflen);
-	ret = sizeof(data);
-
 done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
 	return ret;
 }
+#endif
 
 /**
- * @brief               Get/Set system clock
+ * @brief               Set/Get CFP table codes
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_sysclock(moal_private *priv, t_u8 *respbuf,
+static int woal_priv_cfp_code(moal_private *priv, t_u8 *respbuf,
 			      t_u32 respbuflen)
 {
-	int data[65];
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *cfg = NULL;
-	int ret = 0, i = 0;
+	int ret = 0;
 	int user_data_len = 0, header_len = 0;
-	int data_length = 0, length_index = 0;
+	int data[2] = {0};
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc_cfg = NULL;
+	mlan_ds_misc_cfp_code *cfp_code = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SYSCLOCK);
-	memset(data, 0, sizeof(data));
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		user_data_len = 0;
-	} else {
-		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
-	}
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFP_CODE);
 
-	if (user_data_len > MLAN_MAX_CLK_NUM) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
-		goto done;
-	}
+	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	cfg->sub_command = MLAN_OID_MISC_SYS_CLOCK;
+	/* Fill request buffer */
+	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfp_code = &misc_cfg->param.cfp_code;
+	misc_cfg->sub_command = MLAN_OID_MISC_CFP_CODE;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	if (user_data_len) {
-		/* SET operation */
-		req->action = MLAN_ACT_SET;
-
-		/* Set configurable clocks */
-		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_CONFIGURABLE;
-		cfg->param.sys_clock.sys_clk_num =
-			MIN(MLAN_MAX_CLK_NUM, user_data_len);
-		for (i = 0; i < cfg->param.sys_clock.sys_clk_num; i++)
-			cfg->param.sys_clock.sys_clk[i] = (t_u16)data[i];
-
-		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-		if (status != MLAN_STATUS_SUCCESS) {
-			ret = -EFAULT;
-			goto done;
-		}
-	} else {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
+		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
-
-		/* Get configurable clocks */
-		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_CONFIGURABLE;
-		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-		if (status != MLAN_STATUS_SUCCESS) {
-			ret = -EFAULT;
-			goto done;
-		}
-
-		/* Current system clock */
-		data[1] = (int)cfg->param.sys_clock.cur_sys_clk;
-		data_length = 1;
-
-		length_index =
-			MIN(cfg->param.sys_clock.sys_clk_num, MLAN_MAX_CLK_NUM);
-
-		/* Configurable clocks */
-		for (i = 1; i <= length_index; i++)
-			data[i + data_length] =
-				(int)cfg->param.sys_clock.sys_clk[i - 1];
-
-		data_length += length_index;
-
-		/* Get supported clocks */
-		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_SUPPORTED;
-		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-		if (status != MLAN_STATUS_SUCCESS) {
-			ret = -EFAULT;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len > 2) {
+			PRINTM(MERROR, "Invalid number of args!\n");
+			ret = -EINVAL;
 			goto done;
 		}
+		cfp_code->cfp_code_bg = data[0];
+		if (user_data_len == 2)
+			cfp_code->cfp_code_a = data[1];
+		req->action = MLAN_ACT_SET;
+	}
 
-		length_index =
-			MIN(cfg->param.sys_clock.sys_clk_num, MLAN_MAX_CLK_NUM);
-
-		/* Supported clocks */
-		for (i = 1; i <= length_index; i++)
-			data[i + data_length] =
-				(int)cfg->param.sys_clock.sys_clk[i - 1];
-
-		data_length += length_index;
-
-		/* Send length as first element */
-		data[0] = data_length;
-		data_length++;
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
 
-		moal_memcpy_ext(priv->phandle, respbuf, data,
-				sizeof(int) * data_length, respbuflen);
-		ret = data_length * sizeof(int);
+	if (!user_data_len) {
+		data[0] = cfp_code->cfp_code_bg;
+		data[1] = cfp_code->cfp_code_a;
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+				sizeof(data), respbuflen);
+		ret = sizeof(data);
 	}
 
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Get GTK/PTK
+ * @brief               mcast aggr group configure
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return              0 --success, otherwise fail
  */
-static int woal_priv_get_key(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_mcast_aggr_group_cfg(moal_private *priv, t_u8 *respbuf,
+					  t_u32 respbuflen)
 {
-	int ret = 0, copy_len = 0;
+	int ret = 0;
 	int header_len = 0;
-	unsigned int i;
-	t_u8 key_ascii[256];
-	t_u8 *tmp;
-	mlan_ds_sec_cfg *sec = NULL;
-	mlan_ioctl_req *req = NULL;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	mcast_aggr_group *mcast_cfg = NULL;
+	int index = 0;
+	struct mcast_node *node = NULL;
+	unsigned long flags;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_GET_KEY);
-	if (strlen(respbuf) != header_len) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
-		goto done;
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MCAST_AGGR_GROUP);
+	mcast_cfg = (mcast_aggr_group *)(respbuf + header_len);
+	if (mcast_cfg->action == ACTION_ADD) {
+		if (priv->num_mcast_addr >= MLAN_MAX_MULTICAST_LIST_SIZE) {
+			PRINTM(MERROR, "mcast_aggr_group already full!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		woal_add_mcast_node(priv, mcast_cfg->mcast_addr);
+	} else if (mcast_cfg->action == ACTION_REMOVE) {
+		woal_remove_mcast_node(priv, mcast_cfg->mcast_addr);
 	}
-	memset(key_ascii, 0x00, sizeof(key_ascii));
-	tmp = key_ascii;
+	memset(mcast_cfg, 0, sizeof(mcast_aggr_group));
 
-	if (priv->media_connected == MFALSE) {
-		PRINTM(MERROR, "Can't get key in un-associated state\n");
-		ret = -EFAULT;
-		goto done;
+	spin_lock_irqsave(&priv->mcast_lock, flags);
+	list_for_each_entry (node, &priv->mcast_list, link) {
+		moal_memcpy_ext(priv->phandle, &mcast_cfg->mac_list[index],
+				node->mcast_addr, ETH_ALEN, ETH_ALEN);
+		index++;
 	}
+	spin_unlock_irqrestore(&priv->mcast_lock, flags);
+	mcast_cfg->num_mcast_addr = index;
+	priv->num_mcast_addr = index;
+	ret = header_len + sizeof(mcast_aggr_group);
+done:
+	LEAVE();
+	return ret;
+}
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
-		goto done;
-	}
+/**
+ * @brief               mcast aggr configure
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return              0 --success, otherwise fail
+ */
+static int woal_priv_mc_aggr_cfg(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_mc_aggr_cfg *mc_cfg;
+	int ret = 0;
+	int header_len = 0;
 
-	/* Get Unicast Key */
-	req->req_id = MLAN_IOCTL_SEC_CFG;
-	req->action = MLAN_ACT_GET;
-	sec = (mlan_ds_sec_cfg *)req->pbuf;
-	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
-	sec->param.encrypt_key.key_index = 0;
-	sec->param.encrypt_key.key_flags = 0;
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
 		ret = -EFAULT;
 		goto done;
 	}
-	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "PTK: ");
-		tmp += 5;
-		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
-	}
 
-	/* Get Multicase Key */
-	req->req_id = MLAN_IOCTL_SEC_CFG;
-	req->action = MLAN_ACT_GET;
-	sec = (mlan_ds_sec_cfg *)req->pbuf;
-	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
-	sec->param.encrypt_key.key_index = 0;
-	sec->param.encrypt_key.key_flags = KEY_FLAG_GROUP_KEY;
-	memset(sec->param.encrypt_key.mac_addr, 0x0, MLAN_MAC_ADDR_LENGTH);
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
-	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "GTK: ");
-		tmp += 5;
-		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
-	}
 
-	/* Get IGTK Key */
-	req->req_id = MLAN_IOCTL_SEC_CFG;
-	req->action = MLAN_ACT_GET;
-	sec = (mlan_ds_sec_cfg *)req->pbuf;
-	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
-	sec->param.encrypt_key.key_index = 0;
-	sec->param.encrypt_key.key_flags = KEY_FLAG_AES_MCAST_IGTK;
-	memset(sec->param.encrypt_key.mac_addr, 0x0, MLAN_MAC_ADDR_LENGTH);
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_MC_AGGR_CFG;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MC_AGGR_CFG);
+	mc_cfg = (mlan_ds_mc_aggr_cfg *)(respbuf + header_len);
+	ioctl_req->action = mc_cfg->action;
+	misc->param.mc_aggr_cfg.enable_bitmap = mc_cfg->enable_bitmap;
+	misc->param.mc_aggr_cfg.mask_bitmap = mc_cfg->mask_bitmap;
+	misc->param.mc_aggr_cfg.cts2self_offset = mc_cfg->cts2self_offset;
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
-	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "IGTK: ");
-		tmp += 6;
-		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
-	}
 
-	copy_len = tmp - key_ascii;
-	moal_memcpy_ext(priv->phandle, respbuf, &key_ascii, copy_len,
-			respbuflen);
-	ret = copy_len;
+	mc_cfg->enable_bitmap = misc->param.mc_aggr_cfg.enable_bitmap;
+	mc_cfg->mask_bitmap = misc->param.mc_aggr_cfg.mask_bitmap;
+	mc_cfg->cts2self_offset = misc->param.mc_aggr_cfg.cts2self_offset;
+	ret = header_len + sizeof(misc->param.mc_aggr_cfg);
+
+	if (mc_cfg->mask_bitmap & MC_AGGR_CTRL) {
+		if (mc_cfg->enable_bitmap & MC_AGGR_CTRL)
+			priv->enable_mc_aggr = MTRUE;
+		else
+			priv->enable_mc_aggr = MFALSE;
+	}
 done:
 	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
+		kfree(ioctl_req);
 
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Associate to a specific indexed entry in the ScanTable
+ * @brief               per peer stats configure
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return              0 --success, otherwise fail
  */
-static int woal_priv_associate_ssid_bssid(moal_private *priv, t_u8 *respbuf,
-					  t_u32 respbuflen)
+static int woal_priv_stats(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 {
-	int ret = 0, copy_len = 0;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_stats *stats;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
 	int header_len = 0;
-	mlan_ssid_bssid ssid_bssid;
-#ifdef REASSOCIATION
-	mlan_bss_info bss_info;
-#endif
-	char buf[64];
-	t_u8 buflen;
-	t_u8 mac_idx;
-	t_u8 i;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ASSOCIATE);
-	if (strlen(respbuf) == header_len) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
-	copy_len = strlen(respbuf) - header_len;
-	mac_idx = 0;
-	buflen = MIN(copy_len, (sizeof(buf) - 1));
-	memset(buf, 0, sizeof(buf));
-	memset(&ssid_bssid, 0, sizeof(ssid_bssid));
-
-	if (buflen < (3 * ETH_ALEN) + 2) {
-		PRINTM(MERROR,
-		       "Associate: Insufficient length in IOCTL input\n");
 
-		/* buffer should be at least 3 characters per BSSID octet "00:"
-		**   plus a space separater and at least 1 char in the SSID
-		*/
-		ret = -EINVAL;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
-	moal_memcpy_ext(priv->phandle, buf, respbuf + header_len, buflen,
-			sizeof(buf));
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_STATS;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	/* Skip white space */
-	for (i = 0; (i < buflen) && (buf[i] == ' '); i++)
-		;
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_STATS);
+	stats = (mlan_ds_stats *)(respbuf + header_len);
+	ioctl_req->action = stats->action;
 
-	/* Copy/Convert the BSSID */
-	for (; (i < buflen) && (mac_idx < ETH_ALEN) && (buf[i] != ' '); i++) {
-		if (buf[i] == ':') {
-			mac_idx++;
-		} else {
-			ssid_bssid.bssid[mac_idx] = (t_u8)woal_atox(buf + i);
+	moal_memcpy_ext(priv->phandle, &misc->param.stats, stats,
+			sizeof(mlan_ds_stats) + stats->tlv_len - 1,
+			sizeof(mlan_ds_stats) + stats->tlv_len - 1);
 
-			while (((i < buflen) && isxdigit(buf[i + 1])))
-				/* Skip entire hex value */
-				i++;
-		}
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
 	}
 
-	/* Skip one space between the BSSID and start of the SSID */
-	i++;
+	moal_memcpy_ext(priv->phandle, respbuf + header_len,
+			(mlan_ds_stats *)&misc->param.stats, ioctl_req->buf_len,
+			respbuflen - header_len);
+	ret = header_len + ioctl_req->buf_len;
 
-	/* Copy the SSID */
-	ssid_bssid.ssid.ssid_len = buflen - i;
-	moal_memcpy_ext(priv->phandle, ssid_bssid.ssid.ssid, buf + i,
-			sizeof(ssid_bssid.ssid.ssid),
-			sizeof(ssid_bssid.ssid.ssid));
+done:
+	LEAVE();
+	return ret;
+}
+/**
+ * @brief               get channel load results
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return              0 --success, otherwise fail
+ */
+static int woal_priv_get_ch_load_results(moal_private *priv, t_u8 *respbuf,
+					 t_u32 respbuflen)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_ch_load *cl_cfg;
+	int ret = 0;
+	int header_len = 0;
 
-	PRINTM(MCMND, "iwpriv assoc: AP=[" MACSTR "], ssid(%d)=[%s]\n",
-	       MAC2STR(ssid_bssid.bssid), (int)ssid_bssid.ssid.ssid_len,
-	       ssid_bssid.ssid.ssid);
+	ENTER();
 
-	if (MLAN_STATUS_SUCCESS !=
-	    woal_bss_start(priv, MOAL_IOCTL_WAIT, &ssid_bssid)) {
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
 		ret = -EFAULT;
 		goto done;
 	}
 
-#ifdef REASSOCIATION
-	memset(&bss_info, 0x00, sizeof(bss_info));
-	if (MLAN_STATUS_SUCCESS ==
-	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
-		moal_memcpy_ext(priv->phandle, &priv->prev_ssid_bssid.ssid,
-				&bss_info.ssid, sizeof(mlan_802_11_ssid),
-				sizeof(mlan_802_11_ssid));
-		moal_memcpy_ext(priv->phandle, &priv->prev_ssid_bssid.bssid,
-				&bss_info.bssid, MLAN_MAC_ADDR_LENGTH,
-				sizeof(mlan_802_11_mac_addr));
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
 	}
-#endif /* REASSOCIATION */
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CH_LOAD_RESULTS;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CH_LOAD_RESULTS);
+	cl_cfg = (mlan_ds_ch_load *)(respbuf + header_len);
+	ioctl_req->action = cl_cfg->action;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EAGAIN;
+		goto done;
+	}
+
+	cl_cfg->ch_load_param = misc->param.ch_load.ch_load_param;
+	cl_cfg->noise = misc->param.ch_load.noise;
+	cl_cfg->rx_quality = misc->param.ch_load.rx_quality;
+	ret = header_len + sizeof(misc->param.ch_load);
 
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
 	LEAVE();
-	return 0;
+	return ret;
 }
 
-/* Maximum input output characters in group WOAL_SET_GET_256_CHAR */
-#define MAX_IN_OUT_CHAR 256
-/** Tx BF Global conf argument index */
-#define BF_ENABLE_PARAM 1
-#define SOUND_ENABLE_PARAM 2
-#define FB_TYPE_PARAM 3
-#define SNR_THRESHOLD_PARAM 4
-#define SOUND_INTVL_PARAM 5
-#define BF_MODE_PARAM 6
-#define MAX_TX_BF_GLOBAL_ARGS 6
-#define BF_CFG_ACT_GET 0
-#define BF_CFG_ACT_SET 1
-
 /**
- * @brief               Set/Get Transmit beamforming configuration
+ * @brief               get channel load
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return              0 --success, otherwise fail
  */
-static int woal_priv_tx_bf_cfg(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_get_ch_load(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_ch_load *cl_cfg;
+	int ret = 0;
 	int header_len = 0;
-	int ret = 0, copy_len = 0;
-	int bf_action = 0, interval = 0;
-	int snr = 0, i, tmp_val = 0;
-	t_u8 buf[MAX_IN_OUT_CHAR], char_count = 0;
-	t_u8 *str, *token, *pos;
-	t_u16 action = 0;
-
-	mlan_ds_11n_tx_bf_cfg bf_cfg;
-	mlan_trigger_sound_args *bf_sound = NULL;
-	mlan_tx_bf_peer_args *tx_bf_peer = NULL;
-	mlan_snr_thr_args *bf_snr = NULL;
-	mlan_bf_periodicity_args *bf_periodicity = NULL;
-	mlan_bf_global_cfg_args *bf_global = NULL;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TX_BF_CFG);
-	if (strlen(respbuf) == header_len) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
-	memset(&bf_cfg, 0, sizeof(bf_cfg));
-	/* Pointer to corresponding buffer */
-	bf_sound = bf_cfg.body.bf_sound;
-	tx_bf_peer = bf_cfg.body.tx_bf_peer;
-	bf_snr = bf_cfg.body.bf_snr;
-	bf_periodicity = bf_cfg.body.bf_periodicity;
-	bf_global = &bf_cfg.body.bf_global_cfg;
 
-	/* Total characters in buffer */
-	char_count = strlen(respbuf) - header_len;
-	copy_len = char_count;
-	memset(buf, 0, sizeof(buf));
-	if (char_count) {
-		if (copy_len > sizeof(buf)) {
-			PRINTM(MERROR, "Too many arguments\n");
-			ret = -EINVAL;
-			goto done;
-		}
-		moal_memcpy_ext(priv->phandle, buf, respbuf + header_len,
-				copy_len, sizeof(buf));
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
 
-		if (char_count > 1 && buf[1] != ';') {
-			PRINTM(MERROR,
-			       "No action argument. Separate with ';'\n");
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CH_LOAD;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CH_LOAD);
+	cl_cfg = (mlan_ds_ch_load *)(respbuf + header_len);
+	ioctl_req->action = cl_cfg->action;
+	misc->param.ch_load.ch_load_param = cl_cfg->ch_load_param;
+	misc->param.ch_load.noise = cl_cfg->noise;
+	misc->param.ch_load.rx_quality = cl_cfg->rx_quality;
+	misc->param.ch_load.duration = cl_cfg->duration;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_NO_WAIT);
+	if (status != MLAN_STATUS_SUCCESS && status != MLAN_STATUS_PENDING) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ret = header_len + sizeof(misc->param.ch_load);
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get Tx/Rx antenna
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_set_get_tx_rx_ant(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
+{
+	int ret = 0;
+	int user_data_len = 0, header_len = 0;
+	mlan_ds_radio_cfg *radio = NULL;
+	mlan_ioctl_req *req = NULL;
+	int data[3] = {0};
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ANT_CFG);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_radio_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	radio = (mlan_ds_radio_cfg *)req->pbuf;
+	radio->sub_command = MLAN_OID_ANT_CFG;
+	req->req_id = MLAN_IOCTL_RADIO_CFG;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len > 2) {
+			PRINTM(MERROR, "Invalid number of args!\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		/* Replace ';' with NULL in the string to separate args */
-		for (i = 0; i < char_count; i++) {
-			if (buf[i] == ';')
-				buf[i] = '\0';
+		if (priv->phandle->feature_control & FEATURE_CTRL_STREAM_2X2) {
+			radio->param.ant_cfg.tx_antenna = data[0];
+			radio->param.ant_cfg.rx_antenna = data[0];
+			if (user_data_len == 2)
+				radio->param.ant_cfg.rx_antenna = data[1];
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+			if (IS_CARD9098(priv->phandle->card_type) ||
+			    IS_CARD9097(priv->phandle->card_type) ||
+			    IS_CARDIW62X(priv->phandle->card_type)) {
+				woal_cfg80211_notify_antcfg(
+					priv, priv->phandle->wiphy, radio);
+			}
+#endif
+		} else {
+			radio->param.ant_cfg_1x1.antenna = data[0];
+			if (user_data_len == 2)
+				radio->param.ant_cfg_1x1.evaluate_time =
+					data[1];
 		}
-		/* The first byte represents the beamforming action */
-		if (woal_atoi(&bf_action, &buf[0]) != MLAN_STATUS_SUCCESS) {
+		req->action = MLAN_ACT_SET;
+	}
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (!user_data_len) {
+		if (priv->phandle->feature_control & FEATURE_CTRL_STREAM_2X2) {
+			data[0] = radio->param.ant_cfg.tx_antenna;
+			data[1] = radio->param.ant_cfg.rx_antenna;
+			if (data[0] && data[1])
+				ret = sizeof(int) * 2;
+			else
+				ret = sizeof(int) * 1;
+			moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+					sizeof(data), respbuflen);
+		} else {
+			data[0] = (int)radio->param.ant_cfg_1x1.antenna;
+			data[1] = (int)radio->param.ant_cfg_1x1.evaluate_time;
+			data[2] = (int)radio->param.ant_cfg_1x1.current_antenna;
+			moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+					sizeof(data), respbuflen);
+			ret = sizeof(data);
+		}
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/*
+ * @brief               Set/Get CWMode
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_set_get_cwmode(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_cw_mode_ctrl *cwmode;
+	int ret = 0;
+	int header_len = 0;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CWMODE_CTRL;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CWMODE);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		ioctl_req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		ioctl_req->action = MLAN_ACT_SET;
+
+		cwmode = (mlan_ds_cw_mode_ctrl *)(respbuf + header_len +
+						  sizeof(t_u8));
+		misc->param.cwmode.mode = cwmode->mode;
+		misc->param.cwmode.txPower = cwmode->txPower;
+		misc->param.cwmode.rateInfo = cwmode->rateInfo;
+		misc->param.cwmode.channel = cwmode->channel;
+		misc->param.cwmode.chanInfo = cwmode->chanInfo;
+		misc->param.cwmode.pktLength = cwmode->pktLength;
+	}
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&misc->param.cwmode,
+			sizeof(misc->param.cwmode), respbuflen);
+	ret = sizeof(misc->param.cwmode);
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get out band independent reset
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_ind_rst_cfg(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
+{
+	int ret = 0;
+	int user_data_len = 0, header_len = 0;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	int data[2] = {0};
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_IND_RST_CFG);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	memset(misc, 0, sizeof(mlan_ds_misc_cfg));
+	misc->sub_command = MLAN_OID_MISC_IND_RST_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len > 2) {
+			PRINTM(MERROR, "Invalid number of args!\n");
 			ret = -EINVAL;
 			goto done;
 		}
-		switch (bf_action) {
-		case BF_GLOBAL_CONFIGURATION:
-			if (char_count == 1) {
-				action = MLAN_ACT_GET;
-				bf_cfg.action = BF_CFG_ACT_GET;
-			} else {
-				action = MLAN_ACT_SET;
-				bf_cfg.action = BF_CFG_ACT_SET;
-				/* Eliminate action field */
-				token = &buf[2];
-				for (i = 1, str = &buf[2]; token != NULL; i++) {
-					token = strstr(str, " ");
-					pos = str;
-					if (token != NULL) {
-						*token = '\0';
-						str = token + 1;
-					}
-					woal_atoi(&tmp_val, pos);
-					switch (i) {
-					case BF_ENABLE_PARAM:
-						bf_global->bf_enbl =
-							(t_u8)tmp_val;
-						break;
-					case SOUND_ENABLE_PARAM:
-						bf_global->sounding_enbl =
-							(t_u8)tmp_val;
-						break;
-					case FB_TYPE_PARAM:
-						bf_global->fb_type =
-							(t_u8)tmp_val;
-						break;
-					case SNR_THRESHOLD_PARAM:
-						bf_global->snr_threshold =
-							(t_u8)tmp_val;
-						break;
-					case SOUND_INTVL_PARAM:
-						bf_global->sounding_interval =
-							(t_u16)tmp_val;
-						break;
-					case BF_MODE_PARAM:
-						bf_global->bf_mode =
-							(t_u8)tmp_val;
-						break;
-					default:
-						PRINTM(MERROR,
-						       "Invalid Argument\n");
-						ret = -EINVAL;
-						goto done;
-					}
+
+		if ((user_data_len == 1) || (user_data_len == 2)) {
+			req->action = MLAN_ACT_SET;
+
+			/* ir_mode */
+			if (data[0] < 0 || data[0] > 2) {
+				PRINTM(MERROR, "Invalid ir mode parameter!\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			misc->param.ind_rst_cfg.ir_mode = data[0];
+
+			/* gpio_pin */
+			if (user_data_len == 2) {
+				if ((data[1] != 0xFF) && (data[1] < 0)) {
+					PRINTM(MERROR,
+					       "Invalid gpio pin no!\n");
+					ret = -EINVAL;
+					goto done;
 				}
+				misc->param.ind_rst_cfg.gpio_pin = data[1];
+			}
+		}
+	}
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	data[0] = (int)misc->param.ind_rst_cfg.ir_mode;
+	data[1] = (int)misc->param.ind_rst_cfg.gpio_pin;
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data, sizeof(data),
+			respbuflen);
+	ret = sizeof(data);
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Get/Set system clock
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_sysclock(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
+{
+	int data[65];
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	int ret = 0, i = 0;
+	int user_data_len = 0, header_len = 0;
+	int data_length = 0, length_index = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SYSCLOCK);
+	memset(data, 0, sizeof(data));
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+	}
+
+	if (user_data_len > MLAN_MAX_CLK_NUM) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_SYS_CLOCK;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	if (user_data_len) {
+		/* SET operation */
+		req->action = MLAN_ACT_SET;
+
+		/* Set configurable clocks */
+		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_CONFIGURABLE;
+		cfg->param.sys_clock.sys_clk_num =
+			MIN(MLAN_MAX_CLK_NUM, user_data_len);
+		for (i = 0; i < cfg->param.sys_clock.sys_clk_num; i++)
+			cfg->param.sys_clock.sys_clk[i] = (t_u16)data[i];
+
+		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+		if (status != MLAN_STATUS_SUCCESS) {
+			ret = -EFAULT;
+			goto done;
+		}
+	} else {
+		/* GET operation */
+		req->action = MLAN_ACT_GET;
+
+		/* Get configurable clocks */
+		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_CONFIGURABLE;
+		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+		if (status != MLAN_STATUS_SUCCESS) {
+			ret = -EFAULT;
+			goto done;
+		}
+
+		/* Current system clock */
+		data[1] = (int)cfg->param.sys_clock.cur_sys_clk;
+		data_length = 1;
+
+		length_index =
+			MIN(cfg->param.sys_clock.sys_clk_num, MLAN_MAX_CLK_NUM);
+
+		/* Configurable clocks */
+		for (i = 1; i <= length_index; i++)
+			data[i + data_length] =
+				(int)cfg->param.sys_clock.sys_clk[i - 1];
+
+		data_length += length_index;
+
+		/* Get supported clocks */
+		cfg->param.sys_clock.sys_clk_type = MLAN_CLK_SUPPORTED;
+		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+		if (status != MLAN_STATUS_SUCCESS) {
+			ret = -EFAULT;
+			goto done;
+		}
+
+		length_index =
+			MIN(cfg->param.sys_clock.sys_clk_num, MLAN_MAX_CLK_NUM);
+
+		/* Supported clocks */
+		for (i = 1; i <= length_index; i++)
+			data[i + data_length] =
+				(int)cfg->param.sys_clock.sys_clk[i - 1];
+
+		data_length += length_index;
+
+		/* Send length as first element */
+		data[0] = data_length;
+		data_length++;
+
+		moal_memcpy_ext(priv->phandle, respbuf, data,
+				sizeof(int) * data_length, respbuflen);
+		ret = data_length * sizeof(int);
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Get GTK/PTK
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_get_key(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
+{
+	int ret = 0, copy_len = 0;
+	int header_len = 0;
+	unsigned int i;
+	t_u8 key_ascii[256];
+	t_u8 *tmp;
+	mlan_ds_sec_cfg *sec = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_GET_KEY);
+	if ((int)strlen(respbuf) != header_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	memset(key_ascii, 0x00, sizeof(key_ascii));
+	tmp = key_ascii;
+
+	if (priv->media_connected == MFALSE) {
+		PRINTM(MERROR, "Can't get key in un-associated state\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Get Unicast Key */
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+	req->action = MLAN_ACT_GET;
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
+	sec->param.encrypt_key.key_index = 0;
+	sec->param.encrypt_key.key_flags = 0;
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (sec->param.encrypt_key.key_len) {
+		snprintf((char *)tmp, CMD_BUF_LEN, "\n%s", "PTK: ");
+		tmp += 5;
+		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
+			tmp += snprintf((char *)tmp, CMD_BUF_LEN, "%02x",
+					sec->param.encrypt_key.key_material[i]);
+	}
+
+	/* Get Multicase Key */
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+	req->action = MLAN_ACT_GET;
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
+	sec->param.encrypt_key.key_index = 0;
+	sec->param.encrypt_key.key_flags = KEY_FLAG_GROUP_KEY;
+	memset(sec->param.encrypt_key.mac_addr, 0x0, MLAN_MAC_ADDR_LENGTH);
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (sec->param.encrypt_key.key_len) {
+		snprintf((char *)tmp, CMD_BUF_LEN, "\n%s", "GTK: ");
+		tmp += 5;
+		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
+			tmp += snprintf((char *)tmp, CMD_BUF_LEN, "%02x",
+					sec->param.encrypt_key.key_material[i]);
+	}
+
+	/* Get IGTK Key */
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+	req->action = MLAN_ACT_GET;
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_QUERY_KEY;
+	sec->param.encrypt_key.key_index = 0;
+	sec->param.encrypt_key.key_flags = KEY_FLAG_AES_MCAST_IGTK;
+	memset(sec->param.encrypt_key.mac_addr, 0x0, MLAN_MAC_ADDR_LENGTH);
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (sec->param.encrypt_key.key_len) {
+		snprintf((char *)tmp, CMD_BUF_LEN, "\n%s", "IGTK: ");
+		tmp += 6;
+		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
+			tmp += snprintf((char *)tmp, CMD_BUF_LEN, "%02x",
+					sec->param.encrypt_key.key_material[i]);
+	}
+
+	copy_len = tmp - key_ascii;
+	moal_memcpy_ext(priv->phandle, respbuf, &key_ascii, copy_len,
+			respbuflen);
+	ret = copy_len;
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Associate to a specific indexed entry in the ScanTable
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_associate_ssid_bssid(moal_private *priv, t_u8 *respbuf,
+					  t_u32 respbuflen)
+{
+	int ret = 0, copy_len = 0;
+	int header_len = 0;
+	mlan_ssid_bssid ssid_bssid;
+#ifdef REASSOCIATION
+	mlan_bss_info bss_info;
+#endif
+	char buf[64];
+	t_u8 buflen;
+	t_u8 mac_idx;
+	t_u8 i;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ASSOCIATE);
+	if ((int)strlen(respbuf) == header_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	copy_len = strlen(respbuf) - header_len;
+	mac_idx = 0;
+	buflen = MIN(copy_len, (int)(sizeof(buf) - 1));
+	memset(buf, 0, sizeof(buf));
+	memset(&ssid_bssid, 0, sizeof(ssid_bssid));
+
+	if (buflen < (3 * ETH_ALEN) + 2) {
+		PRINTM(MERROR,
+		       "Associate: Insufficient length in IOCTL input\n");
+
+		/* buffer should be at least 3 characters per BSSID octet "00:"
+		**   plus a space separater and at least 1 char in the SSID
+		*/
+		ret = -EINVAL;
+		goto done;
+	}
+
+	moal_memcpy_ext(priv->phandle, buf, respbuf + header_len, buflen,
+			sizeof(buf));
+
+	/* Skip white space */
+	for (i = 0; (i < buflen) && (buf[i] == ' '); i++)
+		;
+
+	/* Copy/Convert the BSSID */
+	for (; (i < buflen) && (mac_idx < ETH_ALEN) && (buf[i] != ' '); i++) {
+		if (buf[i] == ':') {
+			mac_idx++;
+		} else {
+			ssid_bssid.bssid[mac_idx] = (t_u8)woal_atox(buf + i);
+
+			while (((i < buflen) && isxdigit(buf[i + 1])))
+				/* Skip entire hex value */
+				i++;
+		}
+	}
+
+	/* Skip one space between the BSSID and start of the SSID */
+	i++;
+
+	/* Copy the SSID */
+	ssid_bssid.ssid.ssid_len = buflen - i;
+	moal_memcpy_ext(priv->phandle, ssid_bssid.ssid.ssid, buf + i,
+			sizeof(ssid_bssid.ssid.ssid),
+			sizeof(ssid_bssid.ssid.ssid));
+
+	PRINTM(MCMND, "iwpriv assoc: AP=[" MACSTR "], ssid(%d)=[%s]\n",
+	       MAC2STR(ssid_bssid.bssid), (int)ssid_bssid.ssid.ssid_len,
+	       ssid_bssid.ssid.ssid);
+
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_bss_start(priv, MOAL_IOCTL_WAIT, &ssid_bssid)) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+#ifdef REASSOCIATION
+	memset(&bss_info, 0x00, sizeof(bss_info));
+	if (MLAN_STATUS_SUCCESS ==
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		moal_memcpy_ext(priv->phandle, &priv->prev_ssid_bssid.ssid,
+				&bss_info.ssid, sizeof(mlan_802_11_ssid),
+				sizeof(mlan_802_11_ssid));
+		moal_memcpy_ext(priv->phandle, &priv->prev_ssid_bssid.bssid,
+				&bss_info.bssid, MLAN_MAC_ADDR_LENGTH,
+				sizeof(mlan_802_11_mac_addr));
+	}
+#endif /* REASSOCIATION */
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/* Maximum input output characters in group WOAL_SET_GET_256_CHAR */
+#define MAX_IN_OUT_CHAR 256
+/** Tx BF Global conf argument index */
+#define BF_ENABLE_PARAM 1
+#define SOUND_ENABLE_PARAM 2
+#define FB_TYPE_PARAM 3
+#define SNR_THRESHOLD_PARAM 4
+#define SOUND_INTVL_PARAM 5
+#define BF_MODE_PARAM 6
+#define BF_CFG_ACT_GET 0
+#define BF_CFG_ACT_SET 1
+
+/**
+ * @brief               Set/Get Transmit beamforming configuration
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_tx_bf_cfg(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
+{
+	int header_len = 0;
+	int ret = 0, copy_len = 0;
+	int bf_action = 0, interval = 0;
+	int snr = 0, i, tmp_val = 0;
+	t_u8 buf[MAX_IN_OUT_CHAR], char_count = 0;
+	t_u8 *str, *token, *pos;
+	t_u16 action = 0;
+
+	mlan_ds_11n_tx_bf_cfg bf_cfg;
+	mlan_trigger_sound_args *bf_sound = NULL;
+	mlan_tx_bf_peer_args *tx_bf_peer = NULL;
+	mlan_snr_thr_args *bf_snr = NULL;
+	mlan_bf_periodicity_args *bf_periodicity = NULL;
+	mlan_bf_global_cfg_args *bf_global = NULL;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TX_BF_CFG);
+	if ((int)strlen(respbuf) == header_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	memset(&bf_cfg, 0, sizeof(bf_cfg));
+	/* Pointer to corresponding buffer */
+	bf_sound = bf_cfg.body.bf_sound;
+	tx_bf_peer = bf_cfg.body.tx_bf_peer;
+	bf_snr = bf_cfg.body.bf_snr;
+	bf_periodicity = bf_cfg.body.bf_periodicity;
+	bf_global = &bf_cfg.body.bf_global_cfg;
+
+	/* Total characters in buffer */
+	char_count = strlen(respbuf) - header_len;
+	copy_len = char_count;
+	memset(buf, 0, sizeof(buf));
+	if (char_count) {
+		if (copy_len > (int)sizeof(buf)) {
+			PRINTM(MERROR, "Too many arguments\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		moal_memcpy_ext(priv->phandle, buf, respbuf + header_len,
+				copy_len, sizeof(buf));
+
+		if (char_count > 1 && buf[1] != ';') {
+			PRINTM(MERROR,
+			       "No action argument. Separate with ';'\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		/* Replace ';' with NULL in the string to separate args */
+		for (i = 0; i < char_count; i++) {
+			if (buf[i] == ';')
+				buf[i] = '\0';
+		}
+		/* The first byte represents the beamforming action */
+		if (woal_atoi(&bf_action, &buf[0]) != MLAN_STATUS_SUCCESS) {
+			ret = -EINVAL;
+			goto done;
+		}
+		switch (bf_action) {
+		case BF_GLOBAL_CONFIGURATION:
+			if (char_count == 1) {
+				action = MLAN_ACT_GET;
+				bf_cfg.action = BF_CFG_ACT_GET;
+			} else {
+				action = MLAN_ACT_SET;
+				bf_cfg.action = BF_CFG_ACT_SET;
+				/* Eliminate action field */
+				token = &buf[2];
+				for (i = 1, str = &buf[2]; token != NULL; i++) {
+					token = strstr(str, " ");
+					pos = str;
+					if (token != NULL) {
+						*token = '\0';
+						str = token + 1;
+					}
+					(void)woal_atoi(&tmp_val, pos);
+					switch (i) {
+					case BF_ENABLE_PARAM:
+						bf_global->bf_enbl =
+							(t_u8)tmp_val;
+						break;
+					case SOUND_ENABLE_PARAM:
+						bf_global->sounding_enbl =
+							(t_u8)tmp_val;
+						break;
+					case FB_TYPE_PARAM:
+						bf_global->fb_type =
+							(t_u8)tmp_val;
+						break;
+					case SNR_THRESHOLD_PARAM:
+						bf_global->snr_threshold =
+							(t_u8)tmp_val;
+						break;
+					case SOUND_INTVL_PARAM:
+						bf_global->sounding_interval =
+							(t_u16)tmp_val;
+						break;
+					case BF_MODE_PARAM:
+						bf_global->bf_mode =
+							(t_u8)tmp_val;
+						break;
+					default:
+						PRINTM(MERROR,
+						       "Invalid Argument\n");
+						ret = -EINVAL;
+						goto done;
+					}
+				}
+			}
+			break;
+		case TRIGGER_SOUNDING_FOR_PEER:
+			/* First arg  = 2   BfAction
+			 * Second arg = 17  MAC "00:50:43:20:BF:64" */
+			if (char_count != 19) {
+				PRINTM(MERROR, "Invalid argument\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			woal_mac2u8(bf_sound->peer_mac, &buf[2]);
+			action = MLAN_ACT_SET;
+			bf_cfg.action = BF_CFG_ACT_SET;
+			break;
+		case SET_GET_BF_PERIODICITY:
+			/* First arg  = 2   BfAction
+			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
+			 * Third arg =  1  (min char)  TX BF interval
+			 *              10 (max char)  u32 maximum value
+			 * 4294967295 */
+			if (char_count < 19 || char_count > 30) {
+				PRINTM(MERROR, "Invalid argument\n");
+				ret = -EINVAL;
+				goto done;
+			}
+
+			woal_mac2u8(bf_periodicity->peer_mac, &buf[2]);
+			if (char_count == 19) {
+				action = MLAN_ACT_GET;
+				bf_cfg.action = BF_CFG_ACT_GET;
+			} else {
+				action = MLAN_ACT_SET;
+				bf_cfg.action = BF_CFG_ACT_SET;
+				if (woal_atoi(&interval, &buf[20]) !=
+				    MLAN_STATUS_SUCCESS) {
+					ret = -EINVAL;
+					goto done;
+				}
+				bf_periodicity->interval = interval;
+			}
+			break;
+		case TX_BF_FOR_PEER_ENBL:
+			/* Handle only SET operation here
+			 * First arg  = 2   BfAction
+			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
+			 * Third arg  = 2   enable/disable bf
+			 * Fourth arg = 2   enable/disable sounding
+			 * Fifth arg  = 1   FB Type */
+			if (char_count != 25 && char_count != 1) {
+				PRINTM(MERROR, "Invalid argument\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			if (char_count == 1) {
+				action = MLAN_ACT_GET;
+				bf_cfg.action = BF_CFG_ACT_GET;
+			} else {
+				woal_mac2u8(tx_bf_peer->peer_mac, &buf[2]);
+				(void)woal_atoi(&tmp_val, &buf[20]);
+				tx_bf_peer->bf_enbl = (t_u8)tmp_val;
+				(void)woal_atoi(&tmp_val, &buf[22]);
+				tx_bf_peer->sounding_enbl = (t_u8)tmp_val;
+				(void)woal_atoi(&tmp_val, &buf[24]);
+				tx_bf_peer->fb_type = (t_u8)tmp_val;
+				action = MLAN_ACT_SET;
+				bf_cfg.action = BF_CFG_ACT_SET;
+			}
+			break;
+		case SET_SNR_THR_PEER:
+			/* First arg  = 2   BfAction
+			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
+			 * Third arg  = 1/2 SNR u8 - can be 1/2 charerters */
+			if (char_count != 1 &&
+			    !(char_count == 21 || char_count == 22)) {
+				PRINTM(MERROR, "Invalid argument\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			if (char_count == 1) {
+				action = MLAN_ACT_GET;
+				bf_cfg.action = BF_CFG_ACT_GET;
+			} else {
+				woal_mac2u8(bf_snr->peer_mac, &buf[2]);
+				if (woal_atoi(&snr, &buf[20]) !=
+				    MLAN_STATUS_SUCCESS) {
+					ret = -EINVAL;
+					goto done;
+				}
+				bf_snr->snr = snr;
+				action = MLAN_ACT_SET;
+				bf_cfg.action = BF_CFG_ACT_SET;
+			}
+			break;
+		default:
+			ret = -EINVAL;
+			goto done;
+		}
+
+		/* Save the value */
+		bf_cfg.bf_action = bf_action;
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_tx_bf_cfg(priv, action, &bf_cfg)) {
+			ret = -EFAULT;
+			goto done;
+		}
+	} else {
+		ret = -EINVAL;
+		goto done;
+	}
+
+	switch (bf_action) {
+	case BF_GLOBAL_CONFIGURATION:
+		moal_memcpy_ext(priv->phandle, respbuf, bf_global,
+				sizeof(mlan_bf_global_cfg_args), respbuflen);
+		ret = sizeof(mlan_bf_global_cfg_args);
+		break;
+	case TRIGGER_SOUNDING_FOR_PEER:
+		moal_memcpy_ext(priv->phandle, respbuf, bf_sound,
+				sizeof(mlan_bf_global_cfg_args), respbuflen);
+		ret = sizeof(mlan_bf_global_cfg_args);
+		break;
+	case SET_GET_BF_PERIODICITY:
+		moal_memcpy_ext(priv->phandle, respbuf, bf_periodicity,
+				sizeof(mlan_bf_periodicity_args), respbuflen);
+		ret = sizeof(mlan_bf_periodicity_args);
+		break;
+	case TX_BF_FOR_PEER_ENBL:
+		moal_memcpy_ext(priv->phandle, respbuf, tx_bf_peer,
+				sizeof(mlan_tx_bf_peer_args), respbuflen);
+		ret = sizeof(mlan_tx_bf_peer_args);
+		break;
+	case SET_SNR_THR_PEER:
+		moal_memcpy_ext(priv->phandle, respbuf, bf_snr,
+				sizeof(mlan_snr_thr_args), respbuflen);
+		ret = sizeof(mlan_snr_thr_args);
+		break;
+		/** Default case not required as bf_action value already
+		 * sanitized */
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+#ifdef SDIO
+/**
+ * @brief               Cmd53 read/write register
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cmd53rdwr(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
+{
+	int header_len = 0;
+	int ret = 0;
+	t_u8 *buf = NULL;
+	t_u8 *data = NULL;
+	t_u8 rw, mode;
+	t_u16 blklen = 0, blknum = 0;
+	int reg = 0;
+	t_u32 pattern_len = 0, total_len = 0;
+	t_u16 cmd_len;
+	gfp_t flag;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SD_CMD53_RW);
+
+	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	data = kzalloc(WOAL_2K_BYTES, flag);
+	if (!data) {
+		PRINTM(MERROR, "Cannot allocate buffer for command!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, &cmd_len, respbuf + header_len,
+			sizeof(cmd_len), sizeof(cmd_len));
+	buf = respbuf + header_len + sizeof(cmd_len);
+
+	rw = buf[0]; /* read/write (0/1) */
+	reg = buf[5]; /* address */
+	reg = (reg << 8) | buf[4];
+	reg = (reg << 8) | buf[3];
+	reg = (reg << 8) | buf[2];
+	mode = buf[6]; /* byte mode/block mode (0/1) */
+	blklen = buf[8]; /* block size */
+	blklen = (blklen << 8) | buf[7];
+	blknum = buf[10]; /* block number or byte number */
+	blknum = (blknum << 8) | buf[9];
+
+	if (mode == BYTE_MODE)
+		blklen = 1;
+	else
+		mode = BLOCK_MODE;
+
+	total_len = (mode == BLOCK_MODE) ? blknum * blklen : blknum;
+	if (total_len > WOAL_2K_BYTES) {
+		PRINTM(MERROR, "Total data length is too large!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	PRINTM(MINFO,
+	       "CMD53 read/write, addr = %#x, mode = %d, "
+	       "block size = %d, block(byte) number = %d\n",
+	       reg, mode, blklen, blknum);
+
+	if (!rw) {
+		sdio_claim_host(
+			((struct sdio_mmc_card *)priv->phandle->card)->func);
+		if (sdio_readsb(
+			    ((struct sdio_mmc_card *)priv->phandle->card)->func,
+			    respbuf, reg, total_len)) {
+			PRINTM(MERROR,
+			       "sdio_readsb: reading memory 0x%x failed\n",
+			       reg);
+			goto done;
+		}
+		sdio_release_host(
+			((struct sdio_mmc_card *)priv->phandle->card)->func);
+		ret = total_len;
+	} else {
+		int pos = 0;
+		pattern_len = cmd_len - 11;
+		if (pattern_len > total_len)
+			pattern_len = total_len;
+
+		/* Copy/duplicate the pattern to data buffer */
+		for (pos = 0; pos < (int)total_len; pos++)
+			data[pos] = buf[11 + (pos % pattern_len)];
+		sdio_claim_host(
+			((struct sdio_mmc_card *)priv->phandle->card)->func);
+		if (sdio_writesb(
+			    ((struct sdio_mmc_card *)priv->phandle->card)->func,
+			    reg, data, total_len))
+			PRINTM(MERROR,
+			       "sdio_writesb: writing memory 0x%x failed\n",
+			       reg);
+		sdio_release_host(
+			((struct sdio_mmc_card *)priv->phandle->card)->func);
+	}
+
+done:
+	kfree(data);
+	LEAVE();
+	return ret;
+}
+#endif /* SDIO */
+
+/**
+ * @brief               Set/Get Port Control mode
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_port_ctrl(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_sec_cfg *sec = NULL;
+	int ret = 0, data = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	ENTER();
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_CFG_PORT_CTRL_ENABLED;
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PORT_CTRL);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len == 1) {
+			sec->param.port_ctrl_enabled = data;
+			req->action = MLAN_ACT_SET;
+		} else {
+			PRINTM(MERROR, "Invalid number of parameters\n");
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (!user_data_len) {
+		moal_memcpy_ext(priv->phandle, respbuf,
+				&sec->param.port_ctrl_enabled, sizeof(int),
+				respbuflen);
+		ret = sizeof(int);
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Private IOCTL entry to get the By-passed TX packet from
+ * upper layer
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_bypassed_packet(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
+{
+	int header_len = 0;
+	int ret = 0;
+	struct sk_buff *skb = NULL;
+	struct ethhdr *eth;
+	t_u16 moreLen = 0, copyLen = 0;
+	ENTER();
+
+#define MLAN_BYPASS_PKT_EXTRA_OFFSET (4)
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PB_BYPASS);
+	copyLen = strlen(respbuf) - header_len;
+	moreLen = MLAN_MIN_DATA_HEADER_LEN + MLAN_BYPASS_PKT_EXTRA_OFFSET +
+		  sizeof(mlan_buffer);
+
+	skb = alloc_skb(copyLen + moreLen, GFP_KERNEL);
+	if (skb == NULL) {
+		PRINTM(MERROR, "kmalloc no memory !!\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	skb_reserve(skb, moreLen);
+
+	moal_memcpy_ext(priv->phandle, skb_put(skb, copyLen),
+			respbuf + header_len, copyLen, copyLen);
+
+	eth = (struct ethhdr *)skb->data;
+	eth->h_proto = __constant_htons(eth->h_proto);
+	skb->dev = priv->netdev;
+
+	HEXDUMP("Bypass TX Data", skb->data, MIN(skb->len, 100));
+
+	woal_hard_start_xmit(skb, priv->netdev);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set Robustcoex gpiocfg
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_robustcoex(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[3] = {0};
+	mlan_ds_misc_cfg *robust_coex_cfg = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	robust_coex_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	while (respbuf[0] == ' ') {
+		/** skip space */
+		respbuf++;
+	}
+
+	if (strncmp(respbuf, "gpiocfg", strlen("gpiocfg")) == 0) {
+		header_len = strlen("gpiocfg") + 1;
+		parse_arguments(respbuf + header_len, data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len > 3) {
+			PRINTM(MERROR, "Invalid parameter number\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data[0] != ROBUSTCOEX_GPIOCFG_ENABLE &&
+		    data[0] != ROBUSTCOEX_GPIOCFG_DISABLE) {
+			PRINTM(MERROR, "Invalid parameter number\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data[0] == ROBUSTCOEX_GPIOCFG_ENABLE) {
+			if (user_data_len != 3) {
+				PRINTM(MMSG,
+				       "Please provide gpio num and gpio polarity for ROBUSTCOEX_GPIOCFG_ENABLE\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			robust_coex_cfg->param.robustcoexparams.method =
+				ROBUSTCOEX_GPIO_CFG;
+			robust_coex_cfg->param.robustcoexparams.enable =
+				ROBUSTCOEX_GPIOCFG_ENABLE;
+			robust_coex_cfg->param.robustcoexparams.gpio_num =
+				data[1];
+			robust_coex_cfg->param.robustcoexparams.gpio_polarity =
+				data[2];
+		} else {
+			robust_coex_cfg->param.robustcoexparams.method =
+				ROBUSTCOEX_GPIO_CFG;
+			robust_coex_cfg->param.robustcoexparams.enable =
+				ROBUSTCOEX_GPIOCFG_DISABLE;
+			robust_coex_cfg->param.robustcoexparams.gpio_num = 0;
+			robust_coex_cfg->param.robustcoexparams.gpio_polarity =
+				0;
+		}
+		req->action = MLAN_ACT_SET;
+		req->req_id = MLAN_IOCTL_MISC_CFG;
+		robust_coex_cfg->sub_command = MLAN_OID_MISC_ROBUSTCOEX;
+	} else {
+		PRINTM(MERROR, "Invalid parameter\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set DMCS mapping policy or get DMCS status
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_dmcs(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[2] = {0};
+	mlan_ds_misc_cfg *dmcs_cfg = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DMCS);
+	dmcs_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+	if (user_data_len > 2) {
+		PRINTM(MERROR, "Invalid number of args! %d\n", user_data_len);
+		ret = -EINVAL;
+		goto done;
+	}
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	dmcs_cfg->sub_command = MLAN_OID_MISC_DMCS_CONFIG;
+	dmcs_cfg->param.dmcs_policy.subcmd = data[0];
+	switch (data[0]) {
+	case 0:
+		if (user_data_len != 2) {
+			PRINTM(MERROR, "Please provide mapping policy\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		req->action = MLAN_ACT_SET;
+		dmcs_cfg->param.dmcs_policy.mapping_policy = data[1];
+		break;
+	case 1:
+		req->action = MLAN_ACT_GET;
+		break;
+	default:
+		break;
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (req->action == MLAN_ACT_GET) {
+		moal_memcpy_ext(priv->phandle, respbuf,
+				&dmcs_cfg->param.dmcs_status,
+				sizeof(mlan_ds_misc_dmcs_status), respbuflen);
+	}
+	ret = sizeof(mlan_ds_misc_dmcs_status);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set and get boot sleep configure
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_bootsleep(moal_private *priv, t_u8 *respbuf,
+			       t_u32 respbuflen)
+{
+	int ret = MLAN_STATUS_SUCCESS;
+	int user_data_len = 0;
+	int header_len = 0;
+	int allowed = 1;
+	int data[1] = {0};
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_BOOT_SLEEP;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_BOOTSLEEP);
+
+	if ((int)strlen(respbuf) == header_len) {
+		req->action = MLAN_ACT_GET;
+	} else {
+		req->action = MLAN_ACT_SET;
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len != allowed) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
+		}
+		misc->param.boot_sleep = data[0] ? 1 : 0;
+		PRINTM(MIOCTL, "boot sleep cfg:%u\n", misc->param.boot_sleep);
+	}
+
+	ret = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT_TIMEOUT);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	moal_memcpy_ext(priv->phandle, respbuf, &misc->param.boot_sleep,
+			sizeof(misc->param.boot_sleep), respbuflen);
+	ret = sizeof(misc->param.boot_sleep);
+
+	PRINTM(MIOCTL, "boot sleep cfg: %u\n", misc->param.boot_sleep);
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  * @brief               Set and get txwatchdog check
+ *   * @param priv          Pointer to moal_private structure
+ *    * @param respbuf       Pointer to response buffer
+ *     * @param resplen       Response buffer length
+ *      *
+ *       *  @return             Number of bytes written, negative for failure.
+ *        */
+static int woal_priv_txwatchdog(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
+{
+	int ret = 0;
+	int header_len = 0;
+	int user_data_len = 0;
+	int data[1] = {0};
+	int allowed = 1;
+	t_u32 action;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TXWATCHDOG);
+
+	if (strlen(respbuf) == header_len) {
+		action = MLAN_ACT_GET;
+		ret = sizeof(t_u32);
+	} else {
+		action = MLAN_ACT_SET;
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len != allowed) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+	if (action == MLAN_ACT_SET) {
+		priv->txwatchdog_disable = ((*data == 0) ? MTRUE : MFALSE);
+	} else {
+		*data = ((priv->txwatchdog_disable == MTRUE) ? 0 : 1);
+	}
+	memcpy(respbuf, data, sizeof(t_u32));
+	PRINTM(MINFO, "priv->txwatchdog_disable:%u, action:%u, data[0]=%d\n",
+	       priv->txwatchdog_disable, action, data[0]);
+
+done:
+	LEAVE();
+	return ret;
+}
+
+#if defined(PCIE)
+/**
+ * @brief               Enable SSU support
+ * @param priv          Pointer to moal_private structure
+ * @param used_len 		used length
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_ssu_cmd(moal_private *priv, t_u8 used_len, t_u8 *respbuf,
+			     t_u32 respbuflen)
+{
+	int ret = 0;
+	mlan_ds_misc_cfg *ssu_cfg = NULL;
+	mlan_ioctl_req *req = NULL;
+	ssu_params_cfg *ssu_params;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	ssu_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	memset(&ssu_cfg->param.ssu_params, 0, sizeof(mlan_ds_ssu_params));
+	if (!used_len) {
+		req->action = MLAN_ACT_SET;
+		ssu_cfg->param.ssu_params.nskip = 0;
+		ssu_cfg->param.ssu_params.nsel = 1;
+		ssu_cfg->param.ssu_params.adcdownsample = 3;
+		ssu_cfg->param.ssu_params.mask_adc_pkt = 0;
+		ssu_cfg->param.ssu_params.out_16bits = 1;
+	} else {
+		ssu_params = (ssu_params_cfg *)respbuf;
+		DBG_HEXDUMP(MCMD_D, "User SSU params:", respbuf,
+			    sizeof(mlan_ds_ssu_params));
+		if (ssu_params->ssu_mode == 2)
+			req->action = MLAN_ACT_DEFAULT;
+		else {
+			req->action = MLAN_ACT_SET;
+			ssu_cfg->param.ssu_params.nskip = ssu_params->nskip;
+			ssu_cfg->param.ssu_params.nsel = ssu_params->nsel;
+			ssu_cfg->param.ssu_params.adcdownsample =
+				ssu_params->adcdownsample;
+			ssu_cfg->param.ssu_params.mask_adc_pkt =
+				ssu_params->mask_adc_pkt;
+			ssu_cfg->param.ssu_params.out_16bits =
+				ssu_params->out_16bits;
+			ssu_cfg->param.ssu_params.spec_pwr_enable =
+				ssu_params->spec_pwr_enable;
+			ssu_cfg->param.ssu_params.rate_deduction =
+				ssu_params->rate_deduction;
+			ssu_cfg->param.ssu_params.n_pkt_avg =
+				ssu_params->n_pkt_avg;
+		}
+	}
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	ssu_cfg->sub_command = MLAN_OID_MISC_SSU;
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+#endif
+
+/**
+ * @brief               Configure the hal/phy cfg params
+ *
+ *  The command structure contains the following parameters
+ *      dot11b_psd_mask: 1: enable, 0: disable
+ *      Reserved : reserved 7 params for future such use
+ *
+ *  @param priv    Pointer to the mlan_private driver data struct
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return         Number of bytes written if successful else negative value
+ */
+static int woal_priv_hal_phy_cfg_cmd(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	int ret = 0;
+	mlan_ds_hal_phy_cfg_params *data_ptr;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	data_ptr = (mlan_ds_hal_phy_cfg_params *)respbuf;
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_HAL_PHY_CFG;
+
+	cfg->param.hal_phy_cfg_params.dot11b_psd_mask_cfg =
+		data_ptr->dot11b_psd_mask_cfg;
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Enable/disable CSI support
+ *
+ *  The command structure contains the following parameters
+ *      csi_enable: 1: enable, 0: diable
+ *      csi_filter_cnt: Number of CSI filters
+ *      csi_filter: CSI filters
+ *
+ *  @param priv    Pointer to the mlan_private driver data struct
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return         Number of bytes written if successful else negative value
+ */
+static int woal_priv_csi_cmd(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	int ret = 0;
+	mlan_ds_csi_params *data_ptr;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	data_ptr = (mlan_ds_csi_params *)respbuf;
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_CSI;
+
+	cfg->param.csi_params.csi_enable = data_ptr->csi_enable;
+	if (data_ptr->csi_enable == 1) {
+		cfg->param.csi_params.head_id = data_ptr->head_id;
+		cfg->param.csi_params.tail_id = data_ptr->tail_id;
+		cfg->param.csi_params.csi_filter_cnt = data_ptr->csi_filter_cnt;
+		cfg->param.csi_params.chip_id = data_ptr->chip_id;
+		if (cfg->param.csi_params.csi_filter_cnt > CSI_FILTER_MAX)
+			cfg->param.csi_params.csi_filter_cnt = CSI_FILTER_MAX;
+		moal_memcpy_ext(priv->phandle, cfg->param.csi_params.csi_filter,
+				data_ptr->csi_filter,
+				sizeof(mlan_csi_filter_t) *
+					cfg->param.csi_params.csi_filter_cnt,
+				sizeof(mlan_csi_filter_t) * CSI_FILTER_MAX);
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               configure 11ax HE capability or HE operation
+ *
+ *
+ *  @param priv    Pointer to the mlan_private driver data struct
+ *  @param respbuf      A pointer to response buffer
+ *  @param len          length used
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return         Number of bytes written if successful else negative value
+ */
+static int woal_priv_11axcfg_cmd(moal_private *priv, t_u8 *respbuf, t_u8 len,
+				 t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11ax_cfg *cfg = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11ax_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11AX_CFG;
+	req->action = MLAN_ACT_SET;
+	cfg = (mlan_ds_11ax_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_11AX_HE_CFG;
+	if (len)
+		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.he_cfg,
+				respbuf, len, sizeof(mlan_ds_11ax_he_cfg));
+	else
+		req->action = MLAN_ACT_GET;
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&cfg->param.he_cfg,
+			sizeof(mlan_ds_11ax_he_cfg), respbuflen);
+	ret = sizeof(mlan_ds_11ax_he_cfg);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+/**
+ * @brief               Configure TWT Setup parameters
+ *
+ * @param priv          Pointer to the mlan_private driver data struct
+ * @param respbuf       A pointer to response buffer
+ * @param len           Length used
+ * @param respbuflen    Available length of response buffer
+ *
+ * @return              Number of bytes written if successful else negative
+ * value
+ */
+static int woal_priv_twt_setup(moal_private *priv, t_u8 *respbuf, t_u8 len,
+			       t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_twtcfg *cfg = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_twtcfg));
+	if (req == NULL) {
+		PRINTM(MERROR, "Failed to allocate ioctl_req!\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11AX_CFG;
+	req->action = MLAN_ACT_SET;
+	cfg = (mlan_ds_twtcfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_11AX_TWT_CFG;
+	cfg->sub_id = MLAN_11AX_TWT_SETUP_SUBID;
+
+	if (len) {
+		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.twt_setup,
+				respbuf, len, sizeof(mlan_ds_twt_setup));
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "woal_request_ioctl failed!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ret = sizeof(mlan_ds_twt_setup);
+done:
+	if (status != MLAN_STATUS_PENDING) {
+		kfree(req);
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Configure TWT Tear down parameters
+ *
+ * @param priv          Pointer to the mlan_private driver data struct
+ * @param respbuf       A pointer to response buffer
+ * @param len           Length used
+ * @param respbuflen    Available length of response buffer
+ *
+ * @return              Number of bytes written if successful else negative
+ * value
+ */
+static int woal_priv_twt_teardown(moal_private *priv, t_u8 *respbuf, t_u8 len,
+				  t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_twtcfg *cfg = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_twtcfg));
+	if (req == NULL) {
+		PRINTM(MERROR, "Failed to allocate ioctl_req!\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11AX_CFG;
+	req->action = MLAN_ACT_SET;
+	cfg = (mlan_ds_twtcfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_11AX_TWT_CFG;
+	cfg->sub_id = MLAN_11AX_TWT_TEARDOWN_SUBID;
+
+	if (len) {
+		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.twt_teardown,
+				respbuf, len, sizeof(mlan_ds_twt_teardown));
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "woal_request_ioctl failed!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ret = sizeof(mlan_ds_twt_teardown);
+done:
+	if (status != MLAN_STATUS_PENDING) {
+		kfree(req);
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+* @brief               Configure TWT Report parameters
+
+ *@param priv          Pointer to the mlan_private driver data struct
+ *@param respbuf       A pointer to response buffer
+ *@param len           Length used
+ *@param respbuflen    Available length of response buffer
+
+ *@return              Number of bytes written if successful else negative value
+*/
+static int woal_priv_twt_report(moal_private *priv, t_u8 *respbuf, t_u8 len,
+				t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_twtcfg *cfg = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_twtcfg));
+	if (req == NULL) {
+		PRINTM(MERROR, "Failed to allocate ioctl_req!\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_11AX_CFG;
+	req->action = MLAN_ACT_GET;
+	cfg = (mlan_ds_twtcfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_11AX_TWT_CFG;
+	cfg->sub_id = MLAN_11AX_TWT_REPORT_SUBID;
+
+	if (len) {
+		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.twt_report,
+				respbuf, len, sizeof(mlan_ds_twt_report));
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "woal_request_ioctl failed!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ret = sizeof(mlan_ds_twt_report);
+done:
+	if (status != MLAN_STATUS_PENDING) {
+		kfree(req);
+	}
+	LEAVE();
+	return ret;
+}
+
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(UAP_CFG80211)
+/**
+ * @brief               Set/Get P2P NoA (Notice of Absence) parameters
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cfg_noa(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[7];
+	mlan_ds_wifi_direct_config noa_cfg;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_NOA);
+	memset(&noa_cfg, 0, sizeof(noa_cfg));
+
+	memset(data, 0, sizeof(data));
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len > 5) {
+		PRINTM(MERROR, "invalid parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	noa_cfg.flags |= WIFI_DIRECT_NOA;
+
+	if (woal_p2p_config(priv, MLAN_ACT_GET, &noa_cfg) !=
+	    MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "Could not get P2P noa config\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		moal_memcpy_ext(priv->phandle, respbuf, &noa_cfg,
+				sizeof(noa_cfg), respbuflen);
+		ret = sizeof(noa_cfg);
+	} else {
+		switch (user_data_len) {
+		case 5:
+			noa_cfg.noa_interval = (t_u32)data[4];
+			/* fall through */
+		case 4:
+			noa_cfg.noa_duration = (t_u32)data[3];
+			/* fall through */
+		case 3:
+			if (data[2] < 1 || data[2] > 255) {
+				PRINTM(MERROR,
+				       "Invalid number of absence intervals\n");
+				ret = -EINVAL;
+				goto done;
 			}
-			break;
-		case TRIGGER_SOUNDING_FOR_PEER:
-			/* First arg  = 2   BfAction
-			 * Second arg = 17  MAC "00:50:43:20:BF:64" */
-			if (char_count != 19) {
-				PRINTM(MERROR, "Invalid argument\n");
+			noa_cfg.noa_count = (t_u8)data[2];
+			/* fall through */
+		case 2:
+			if (data[1] < 0 || data[1] > 255) {
+				PRINTM(MERROR, "Invalid Index\n");
 				ret = -EINVAL;
 				goto done;
 			}
-			woal_mac2u8(bf_sound->peer_mac, &buf[2]);
-			action = MLAN_ACT_SET;
-			bf_cfg.action = BF_CFG_ACT_SET;
-			break;
-		case SET_GET_BF_PERIODICITY:
-			/* First arg  = 2   BfAction
-			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
-			 * Third arg =  1  (min char)  TX BF interval
-			 *              10 (max char)  u32 maximum value
-			 * 4294967295 */
-			if (char_count < 19 || char_count > 30) {
-				PRINTM(MERROR, "Invalid argument\n");
+			noa_cfg.index = (t_u16)data[1];
+			/* fall through */
+		case 1:
+			if (data[0] < 0 || data[0] > 1) {
+				PRINTM(MERROR, "Invalid noa enable\n");
 				ret = -EINVAL;
 				goto done;
 			}
+			noa_cfg.noa_enable = (t_u8)data[0];
+			noa_cfg.flags |= WIFI_DIRECT_NOA;
+			break;
+		default:
+			break;
+		}
+		if (woal_p2p_config(priv, MLAN_ACT_SET, &noa_cfg) !=
+		    MLAN_STATUS_SUCCESS) {
+			PRINTM(MERROR, "woal_p2p_config fail\n");
+			ret = -EFAULT;
+		}
+	}
 
-			woal_mac2u8(bf_periodicity->peer_mac, &buf[2]);
-			if (char_count == 19) {
-				action = MLAN_ACT_GET;
-				bf_cfg.action = BF_CFG_ACT_GET;
-			} else {
-				action = MLAN_ACT_SET;
-				bf_cfg.action = BF_CFG_ACT_SET;
-				if (woal_atoi(&interval, &buf[20]) !=
-				    MLAN_STATUS_SUCCESS) {
-					ret = -EINVAL;
-					goto done;
-				}
-				bf_periodicity->interval = interval;
+done:
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get P2P OPP-PS parameters
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cfg_opp_ps(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[7];
+	mlan_ds_wifi_direct_config opp_ps_cfg;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_OPP_PS);
+	memset(&opp_ps_cfg, 0, sizeof(opp_ps_cfg));
+
+	memset(data, 0, sizeof(data));
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len > 2) {
+		PRINTM(MERROR, "invalid parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	opp_ps_cfg.flags |= WIFI_DIRECT_OPP_PS;
+
+	if (woal_p2p_config(priv, MLAN_ACT_GET, &opp_ps_cfg) !=
+	    MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "Could not get P2P opp ps config\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		moal_memcpy_ext(priv->phandle, respbuf, &opp_ps_cfg,
+				sizeof(opp_ps_cfg), respbuflen);
+		ret = sizeof(opp_ps_cfg);
+	} else {
+		switch (user_data_len) {
+		case 2:
+			opp_ps_cfg.ct_window = (t_u8)data[1];
+			/* fall through */
+		case 1:
+			if (data[0] < 0 || data[0] > 1) {
+				PRINTM(MERROR, "Invalid ps enable\n");
+				ret = -EINVAL;
+				goto done;
 			}
+			opp_ps_cfg.opp_ps_enable = (t_u8)data[0];
+			opp_ps_cfg.flags |= WIFI_DIRECT_OPP_PS;
+			/* fall through */
+		default:
 			break;
-		case TX_BF_FOR_PEER_ENBL:
-			/* Handle only SET operation here
-			 * First arg  = 2   BfAction
-			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
-			 * Third arg  = 2   enable/disable bf
-			 * Fourth arg = 2   enable/disable sounding
-			 * Fifth arg  = 1   FB Type */
-			if (char_count != 25 && char_count != 1) {
-				PRINTM(MERROR, "Invalid argument\n");
+		}
+		if (woal_p2p_config(priv, MLAN_ACT_SET, &opp_ps_cfg) !=
+		    MLAN_STATUS_SUCCESS) {
+			PRINTM(MERROR, "woal_p2p_config fail\n");
+			ret = -EINVAL;
+		}
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+#endif
+#endif
+
+/**
+ * @brief               Set/Get GPIO TSF latch clock sync config parameters
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cfg_clock_sync(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[5];
+	mlan_ds_gpio_tsf_latch *clock_sync_cfg = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc_cfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_CLOCK_SYNC);
+
+	memset(data, 0, sizeof(data));
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len > 5) {
+		PRINTM(MERROR, "invalid parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	misc_cfg->sub_command = MLAN_OID_MISC_GPIO_TSF_LATCH;
+	clock_sync_cfg = &misc_cfg->param.gpio_tsf_latch_config;
+	memset(clock_sync_cfg, 0, sizeof(mlan_ds_gpio_tsf_latch));
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		req->action = MLAN_ACT_GET;
+		user_data_len = 0;
+	} else {
+		req->action = MLAN_ACT_SET;
+		switch (user_data_len) {
+		case 5:
+			clock_sync_cfg->clock_sync_gpio_pulse_width =
+				(t_u16)data[4];
+			/* fall through */
+		case 4:
+			if (data[3] < 0 || data[3] > 1) {
+				PRINTM(MERROR, "Invalid Level/Trigger\n");
 				ret = -EINVAL;
 				goto done;
 			}
-			if (char_count == 1) {
-				action = MLAN_ACT_GET;
-				bf_cfg.action = BF_CFG_ACT_GET;
-			} else {
-				woal_mac2u8(tx_bf_peer->peer_mac, &buf[2]);
-				woal_atoi(&tmp_val, &buf[20]);
-				tx_bf_peer->bf_enbl = (t_u8)tmp_val;
-				woal_atoi(&tmp_val, &buf[22]);
-				tx_bf_peer->sounding_enbl = (t_u8)tmp_val;
-				woal_atoi(&tmp_val, &buf[24]);
-				tx_bf_peer->fb_type = (t_u8)tmp_val;
-				action = MLAN_ACT_SET;
-				bf_cfg.action = BF_CFG_ACT_SET;
+			clock_sync_cfg->clock_sync_gpio_level_toggle =
+				(t_u8)data[3];
+			/* fall through */
+		case 3:
+			if (data[2] < 1 || data[2] > 255) {
+				PRINTM(MERROR,
+				       "Invalid number of GPIO Pin Number\n");
+				ret = -EINVAL;
+				goto done;
 			}
-			break;
-		case SET_SNR_THR_PEER:
-			/* First arg  = 2   BfAction
-			 * Second arg = 18  MAC "00:50:43:20:BF:64;"
-			 * Third arg  = 1/2 SNR u8 - can be 1/2 charerters */
-			if (char_count != 1 &&
-			    !(char_count == 21 || char_count == 22)) {
-				PRINTM(MERROR, "Invalid argument\n");
+			clock_sync_cfg->clock_sync_gpio_pin_number =
+				(t_u8)data[2];
+			/* fall through */
+		case 2:
+			if (data[1] < 0 || data[1] > 2) {
+				PRINTM(MERROR, "Invalid Role\n");
 				ret = -EINVAL;
 				goto done;
 			}
-			if (char_count == 1) {
-				action = MLAN_ACT_GET;
-				bf_cfg.action = BF_CFG_ACT_GET;
-			} else {
-				woal_mac2u8(bf_snr->peer_mac, &buf[2]);
-				if (woal_atoi(&snr, &buf[20]) !=
-				    MLAN_STATUS_SUCCESS) {
-					ret = -EINVAL;
-					goto done;
-				}
-				bf_snr->snr = snr;
-				action = MLAN_ACT_SET;
-				bf_cfg.action = BF_CFG_ACT_SET;
+			clock_sync_cfg->clock_sync_Role = (t_u8)data[1];
+			/* fall through */
+		case 1:
+			if (data[0] < 0 || data[0] > 2) {
+				PRINTM(MERROR, "Invalid Mode\n");
+				ret = -EINVAL;
+				goto done;
 			}
+			clock_sync_cfg->clock_sync_mode = (t_u8)data[0];
 			break;
 		default:
+			break;
+		}
+	}
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (!user_data_len) {
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)clock_sync_cfg,
+				sizeof(mlan_ds_gpio_tsf_latch), respbuflen);
+		ret = sizeof(mlan_ds_gpio_tsf_latch);
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get GPIO TSF latch get tsf info config parameters
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cfg_get_tsf_info(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[1];
+	mlan_ds_tsf_info *tsf_info;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc_cfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_GET_TSF_INFO);
+
+	memset(data, 0, sizeof(data));
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len > 1) {
+		PRINTM(MERROR, "invalid parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_GET;
+	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	misc_cfg->sub_command = MLAN_OID_MISC_GET_TSF_INFO;
+	tsf_info = &misc_cfg->param.tsf_info;
+	memset(tsf_info, 0, sizeof(mlan_ds_tsf_info));
+	if (user_data_len == 1) {
+		if (data[0] < 0 || data[0] > 1) {
+			PRINTM(MERROR, "Invalid tsf Format\n");
 			ret = -EINVAL;
 			goto done;
 		}
+		tsf_info->tsf_format = data[0];
+	}
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)tsf_info,
+			sizeof(mlan_ds_tsf_info), respbuflen);
+	ret = sizeof(mlan_ds_tsf_info);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
 
-		/* Save the value */
-		bf_cfg.bf_action = bf_action;
-		if (MLAN_STATUS_SUCCESS !=
-		    woal_set_get_tx_bf_cfg(priv, action, &bf_cfg)) {
-			ret = -EFAULT;
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get cross chip sync config parameters
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cross_chip_synch(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
+{
+	mlan_ds_cross_chip_synch *cross_chip_sync = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc_cfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int data[5] = {0};
+	int header_len = 0;
+	int user_data_len = 0;
+	int ret = 0;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (!respbuf) {
+		PRINTM(MERROR, "response buffer is not available!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CROSS_CHIP_SYNCH);
+
+	memset(data, 0, sizeof(data));
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len > 5) {
+		PRINTM(MERROR, "invalid parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	misc_cfg->sub_command = MLAN_OID_MISC_CROSS_CHIP_SYNCH;
+	cross_chip_sync = &misc_cfg->param.cross_chip_synch;
+	memset(cross_chip_sync, 0, sizeof(mlan_ds_cross_chip_synch));
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		req->action = MLAN_ACT_GET;
+		user_data_len = 0;
+	} else {
+		req->action = MLAN_ACT_SET;
+
+		if (data[0] < 0 || data[0] > 1) {
+			PRINTM(MERROR, "Invalid start_stop value\n");
+			ret = -EINVAL;
 			goto done;
+		} else if (data[1] < 1 || data[1] > 2) {
+			PRINTM(MERROR, "Invalid role value\n");
+			ret = -EINVAL;
+			goto done;
+		} else {
+			cross_chip_sync->start_stop = (t_u8)data[0];
+			cross_chip_sync->role = (t_u8)data[1];
+			cross_chip_sync->period = (t_u32)data[2];
+			cross_chip_sync->init_tsf_low = (t_u32)data[3];
+			cross_chip_sync->init_tsf_high = (t_u32)data[4];
 		}
-	} else {
-		ret = -EINVAL;
+	}
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
 		goto done;
 	}
 
-	switch (bf_action) {
-	case BF_GLOBAL_CONFIGURATION:
-		moal_memcpy_ext(priv->phandle, respbuf, bf_global,
-				sizeof(mlan_bf_global_cfg_args), respbuflen);
-		ret = sizeof(mlan_bf_global_cfg_args);
-		break;
-	case TRIGGER_SOUNDING_FOR_PEER:
-		moal_memcpy_ext(priv->phandle, respbuf, bf_sound,
-				sizeof(mlan_bf_global_cfg_args), respbuflen);
-		ret = sizeof(mlan_bf_global_cfg_args);
-		break;
-	case SET_GET_BF_PERIODICITY:
-		moal_memcpy_ext(priv->phandle, respbuf, bf_periodicity,
-				sizeof(mlan_bf_periodicity_args), respbuflen);
-		ret = sizeof(mlan_bf_periodicity_args);
-		break;
-	case TX_BF_FOR_PEER_ENBL:
-		moal_memcpy_ext(priv->phandle, respbuf, tx_bf_peer,
-				sizeof(mlan_tx_bf_peer_args), respbuflen);
-		ret = sizeof(mlan_tx_bf_peer_args);
-		break;
-	case SET_SNR_THR_PEER:
-		moal_memcpy_ext(priv->phandle, respbuf, bf_snr,
-				sizeof(mlan_snr_thr_args), respbuflen);
-		ret = sizeof(mlan_snr_thr_args);
-		break;
-	default:
-		ret = 0;
+	if (!user_data_len) {
+		/* Copy back to userspace call */
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)cross_chip_sync,
+				sizeof(mlan_ds_cross_chip_synch), respbuflen);
+		ret = sizeof(mlan_ds_cross_chip_synch);
 	}
 
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
 	LEAVE();
 	return ret;
 }
 
-#ifdef SDIO
+#ifdef UAP_SUPPORT
 /**
- * @brief               Cmd53 read/write register
+ * @brief               Set/Get target channel
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_cmd53rdwr(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_target_channel(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
-	int header_len = 0;
-	int ret = 0;
-	t_u8 *buf = NULL;
-	t_u8 *data = NULL;
-	t_u8 rw, func, mode;
-	t_u16 blklen = 0, blknum = 0;
-	int reg = 0;
-	t_u32 pattern_len = 0, total_len = 0;
-	t_u16 cmd_len;
-	gfp_t flag;
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[1];
+
+	ENTER();
+	if (!priv || (priv->bss_type != MLAN_BSS_TYPE_UAP)) {
+		PRINTM(MERROR, "priv is null or interface is not AP");
+		ret = -EFAULT;
+		LEAVE();
+		return ret;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TARGET_CHANNEL);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len > 1) {
+			PRINTM(MERROR, "Invalid parameter number\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (user_data_len)
+			priv->target_chan = data[0];
+	}
+	data[0] = priv->target_chan;
+	moal_memcpy_ext(priv->phandle, respbuf, &data, sizeof(data),
+			respbuflen);
+	ret = sizeof(int);
+done:
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               Set/Get backup channel
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_backup_channel(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
+{
+	int header_len = 0, user_data_len = 0;
+	int ret = 0, data[1];
+
+	ENTER();
+	if (!priv || (priv->bss_type != MLAN_BSS_TYPE_UAP)) {
+		PRINTM(MERROR, "priv is null or interface is not AP");
+		ret = -EFAULT;
+		LEAVE();
+		return ret;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_BACKUP_CHANNEL);
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len > 1) {
+			PRINTM(MERROR, "Invalid parameter number\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (user_data_len)
+			priv->backup_chan = data[0];
+	}
+	data[0] = priv->backup_chan;
+	moal_memcpy_ext(priv->phandle, respbuf, &data, sizeof(data),
+			respbuflen);
+	ret = sizeof(int);
+done:
+
+	LEAVE();
+	return ret;
+}
+#endif
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#ifdef WIFI_DIRECT_SUPPORT
+#define DEF_NOA_INTERVAL 100
+/**
+ ** @brief               Set/Get P2P NoA (Notice of Absence) parameters
+ ** @param priv          Pointer to moal_private structure
+ ** @param respbuf       Pointer to response buffer
+ ** @param resplen       Response buffer length
+ **
+ **  @return             Number of bytes written, negative for failure.
+ **/
+static int woal_p2p_ps_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+{
+	int user_data_len = 0;
+	int ret = 0, data[2];
+	u32 duration = priv->phandle->noa_duration;
+	u32 interval = 0;
 
 	ENTER();
-
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_SD_CMD53_RW);
-
-	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
-	data = kzalloc(WOAL_2K_BYTES, flag);
-	if (!data) {
-		PRINTM(MERROR, "Cannot allocate buffer for command!\n");
-		ret = -EFAULT;
+	if (strlen(respbuf) > strlen("P2P_PERIODIC_SLEEP")) {
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(respbuf + strlen("P2P_PERIODIC_SLEEP") + 1,
+				data, ARRAY_SIZE(data), &user_data_len);
+	}
+	if ((user_data_len != 1) && (user_data_len != 2)) {
+		PRINTM(MERROR,
+		       " Invalid parameter number for P2P_PERIODIC_SLEEP");
+		ret = -EINVAL;
 		goto done;
 	}
-	moal_memcpy_ext(priv->phandle, &cmd_len, respbuf + header_len,
-			sizeof(cmd_len), sizeof(cmd_len));
-	buf = respbuf + header_len + sizeof(cmd_len);
-
-	rw = buf[0]; /* read/write (0/1) */
-	func = buf[1]; /* func (0/1/2) */
-	reg = buf[5]; /* address */
-	reg = (reg << 8) | buf[4];
-	reg = (reg << 8) | buf[3];
-	reg = (reg << 8) | buf[2];
-	mode = buf[6]; /* byte mode/block mode (0/1) */
-	blklen = buf[8]; /* block size */
-	blklen = (blklen << 8) | buf[7];
-	blknum = buf[10]; /* block number or byte number */
-	blknum = (blknum << 8) | buf[9];
-
-	if (mode == BYTE_MODE)
-		blklen = 1;
+	if (data[0] < DEF_NOA_INTERVAL)
+		interval = DEF_NOA_INTERVAL;
 	else
-		mode = BLOCK_MODE;
+		interval = (data[0] + DEF_NOA_INTERVAL - 1) / DEF_NOA_INTERVAL *
+			   DEF_NOA_INTERVAL;
 
-	total_len = (mode == BLOCK_MODE) ? blknum * blklen : blknum;
-	if (total_len > WOAL_2K_BYTES) {
-		PRINTM(MERROR, "Total data length is too large!\n");
+	if (user_data_len == 2)
+		duration = data[1];
+	if (duration >= interval) {
+		PRINTM(MERROR,
+		       " Invalid noa duration/interval! duration=%d interval=%d\n",
+		       duration, interval);
 		ret = -EINVAL;
 		goto done;
 	}
-	PRINTM(MINFO,
-	       "CMD53 read/write, func = %d, addr = %#x, mode = %d, "
-	       "block size = %d, block(byte) number = %d\n",
-	       func, reg, mode, blklen, blknum);
-
-	if (!rw) {
-		sdio_claim_host(
-			((struct sdio_mmc_card *)priv->phandle->card)->func);
-		if (sdio_readsb(
-			    ((struct sdio_mmc_card *)priv->phandle->card)->func,
-			    respbuf, reg, total_len)) {
-			PRINTM(MERROR,
-			       "sdio_readsb: reading memory 0x%x failed\n",
-			       reg);
-			goto done;
-		}
-		sdio_release_host(
-			((struct sdio_mmc_card *)priv->phandle->card)->func);
-		ret = total_len;
-	} else {
-		int pos = 0;
-		pattern_len = cmd_len - 11;
-		if (pattern_len > total_len)
-			pattern_len = total_len;
-
-		/* Copy/duplicate the pattern to data buffer */
-		for (pos = 0; pos < total_len; pos++)
-			data[pos] = buf[11 + (pos % pattern_len)];
-		sdio_claim_host(
-			((struct sdio_mmc_card *)priv->phandle->card)->func);
-		if (sdio_writesb(
-			    ((struct sdio_mmc_card *)priv->phandle->card)->func,
-			    reg, data, total_len))
-			PRINTM(MERROR,
-			       "sdio_writesb: writing memory 0x%x failed\n",
-			       reg);
-		sdio_release_host(
-			((struct sdio_mmc_card *)priv->phandle->card)->func);
-	}
-
+	priv->phandle->noa_interval = interval;
+	priv->phandle->noa_duration = duration;
+	PRINTM(MIOCTL, "configure noa interval=%d, duration=%d\n",
+	       priv->phandle->noa_interval, priv->phandle->noa_duration);
 done:
-	kfree(data);
 	LEAVE();
 	return ret;
 }
-#endif /* SDIO */
+#endif
+#endif
 
 /**
- * @brief               Set/Get Port Control mode
+ * @brief               Set/Get DFS repeater mode
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_port_ctrl(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_dfs_repeater_cfg(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
-	int header_len = 0, user_data_len = 0;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data[1] = {0};
 	mlan_ioctl_req *req = NULL;
-	mlan_ds_sec_cfg *sec = NULL;
-	int ret = 0, data = 0;
+	mlan_ds_misc_cfg *misc_cfg = NULL;
+	mlan_ds_misc_dfs_repeater *dfs_repeater = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+
 	ENTER();
 
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_REPEATER_CFG);
+
 	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
 		ret = -ENOMEM;
 		goto done;
 	}
 
 	/* Fill request buffer */
-	sec = (mlan_ds_sec_cfg *)req->pbuf;
-	sec->sub_command = MLAN_OID_SEC_CFG_PORT_CTRL_ENABLED;
-	req->req_id = MLAN_IOCTL_SEC_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	misc_cfg->sub_command = MLAN_OID_MISC_DFS_REAPTER_MODE;
+	dfs_repeater =
+		(mlan_ds_misc_dfs_repeater *)&misc_cfg->param.dfs_repeater;
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PORT_CTRL);
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
 	} else {
 		/* SET operation */
-		parse_arguments(respbuf + header_len, &data,
-				sizeof(data) / sizeof(int), &user_data_len);
-		if (user_data_len == 1) {
-			sec->param.port_ctrl_enabled = data;
-			req->action = MLAN_ACT_SET;
-		} else {
-			PRINTM(MERROR, "Invalid number of parameters\n");
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
+		}
+		if ((data[0] != MTRUE) && (data[0] != MFALSE)) {
+			PRINTM(MERROR, "Invalid DFS repeater mode %d\n",
+			       data[0]);
 			ret = -EINVAL;
 			goto done;
 		}
+		dfs_repeater->mode = (t_u16)data[0];
+
+		req->action = MLAN_ACT_SET;
 	}
 
 	/* Send IOCTL request to MLAN */
@@ -12113,12 +15743,16 @@ static int woal_priv_port_ctrl(moal_private *priv, t_u8 *respbuf,
 	}
 
 	if (!user_data_len) {
-		moal_memcpy_ext(priv->phandle, respbuf,
-				&sec->param.port_ctrl_enabled, sizeof(int),
-				respbuflen);
-		ret = sizeof(int);
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)dfs_repeater,
+				sizeof(mlan_ds_misc_dfs_repeater), respbuflen);
+		ret = sizeof(mlan_ds_misc_dfs_repeater);
 	}
 
+	/* Store current value of DFS repeater mode for futher references. eg.,
+	 * for avoiding CAC timers
+	 */
+	priv->phandle->dfs_repeater_mode = dfs_repeater->mode;
+
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
@@ -12127,234 +15761,297 @@ static int woal_priv_port_ctrl(moal_private *priv, t_u8 *respbuf,
 	return ret;
 }
 
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 /**
- * @brief               Private IOCTL entry to get the By-passed TX packet from
- * upper layer
+ * @brief               Set/Get MIRACAST configuration parameters
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_bypassed_packet(moal_private *priv, t_u8 *respbuf,
-				     t_u32 respbuflen)
+static int woal_priv_miracast_cfg(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
-	int header_len = 0;
 	int ret = 0;
-	struct sk_buff *skb = NULL;
-	struct ethhdr *eth;
-	t_u16 moreLen = 0, copyLen = 0;
+	int user_data_len = 0, header_len = 0, data[3] = {0, 0, 0};
+
 	ENTER();
 
-#define MLAN_BYPASS_PKT_EXTRA_OFFSET (4)
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PB_BYPASS);
-	copyLen = strlen(respbuf) - header_len;
-	moreLen = MLAN_MIN_DATA_HEADER_LEN + MLAN_BYPASS_PKT_EXTRA_OFFSET +
-		  sizeof(mlan_buffer);
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MIRACAST_CFG);
 
-	skb = alloc_skb(copyLen + moreLen, GFP_KERNEL);
-	if (skb == NULL) {
-		PRINTM(MERROR, "kmalloc no memory !!\n");
-		LEAVE();
-		return -ENOMEM;
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		data[0] = priv->phandle->miracast_mode;
+		data[1] = priv->phandle->miracast_scan_time;
+		data[2] = priv->phandle->scan_chan_gap;
+
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+				sizeof(data), respbuflen);
+		ret = sizeof(data);
+	} else {
+		/* SET operation */
+		memset(data, 0, sizeof(data));
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+
+		if (user_data_len > 3) {
+			PRINTM(MERROR, "Too many arguments\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data[0] < 0 || data[0] > 2 || data[1] < 0 || data[2] < 0) {
+			PRINTM(MERROR, "Invalid argument\n");
+			ret = -EINVAL;
+			goto done;
+		}
 	}
 
-	skb_reserve(skb, moreLen);
+	if (user_data_len >= 1)
+		priv->phandle->miracast_mode = (t_u8)data[0];
+	if (user_data_len >= 2)
+		priv->phandle->miracast_scan_time = (t_u16)data[1];
+	if (user_data_len == 3)
+		priv->phandle->scan_chan_gap = (t_u16)data[2];
 
-	moal_memcpy_ext(priv->phandle, skb_put(skb, copyLen),
-			respbuf + header_len, copyLen, copyLen);
+done:
+	LEAVE();
+	return ret;
+}
 
-	eth = (struct ethhdr *)skb->data;
-	eth->h_proto = __constant_htons(eth->h_proto);
-	skb->dev = priv->netdev;
+/**
+ *   @brief Configuring scan gap for miracast mode
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             0 --success, otherwise failure
+ */
+static int woal_set_scan_chan_gap(moal_private *priv, t_u8 *respbuf,
+				  int respbuflen)
+{
+	t_u32 data[2];
+	int ret = 0;
+	int user_data_len = 0;
 
-	HEXDUMP("Bypass TX Data", skb->data, MIN(skb->len, 100));
+	ENTER();
 
-	woal_hard_start_xmit(skb, priv->netdev);
+	if (strlen(respbuf) > strlen("SCAN_TIMING")) {
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(respbuf + strlen("SCAN_TIMING") + 1, data,
+				ARRAY_SIZE(data), &user_data_len);
+	}
 
+	if (user_data_len != 2) {
+		PRINTM(MERROR, "Invalid arguments for scan timing\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	priv->phandle->miracast_scan_time = (t_u16)data[0];
+	priv->phandle->scan_chan_gap = (t_u16)data[1];
+done:
 	LEAVE();
 	return ret;
 }
+#endif
+#endif
 
 /**
- * @brief               Set Robustcoex gpiocfg
+ * @brief               Set/Get control to coex RX window size configuration
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_robustcoex(moal_private *priv, t_u8 *respbuf,
-				t_u32 respbuflen)
+static int woal_priv_coex_rx_winsize(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
-	int header_len = 0, user_data_len = 0;
-	int ret = 0, data[3] = {0};
-	mlan_ds_misc_cfg *robust_coex_cfg = NULL;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 	mlan_ioctl_req *req = NULL;
+	mlan_ds_11n_cfg *cfg_11n = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_COEX_RX_WINSIZE);
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
 	if (req == NULL) {
 		ret = -ENOMEM;
 		goto done;
 	}
-	robust_coex_cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	while (respbuf[0] == ' ') {
-		/** skip space */
-		respbuf++;
-	}
 
-	if (strncmp(respbuf, "gpiocfg", strlen("gpiocfg")) == 0) {
-		header_len = strlen("gpiocfg") + 1;
-		parse_arguments(respbuf + header_len, data,
+	/* Fill request buffer */
+	req->req_id = MLAN_IOCTL_11N_CFG;
+	cfg_11n = (mlan_ds_11n_cfg *)req->pbuf;
+	cfg_11n->sub_command = MLAN_OID_11N_CFG_COEX_RX_WINSIZE;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
 				sizeof(data) / sizeof(int), &user_data_len);
-		if (user_data_len > 3) {
-			PRINTM(MERROR, "Invalid parameter number\n");
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
 			ret = -EINVAL;
 			goto done;
 		}
-		if (data[0] != ROBUSTCOEX_GPIOCFG_ENABLE &&
-		    data[0] != ROBUSTCOEX_GPIOCFG_DISABLE) {
-			PRINTM(MERROR, "Invalid parameter number\n");
+		if ((data != MTRUE) && (data != MFALSE)) {
+			PRINTM(MERROR,
+			       "Invalid coex RX window size parameter %d\n",
+			       data);
 			ret = -EINVAL;
 			goto done;
 		}
-		if (data[0] == ROBUSTCOEX_GPIOCFG_ENABLE) {
-			if (user_data_len != 3) {
-				PRINTM(MMSG,
-				       "Please provide gpio num and gpio polarity for ROBUSTCOEX_GPIOCFG_ENABLE\n");
-				ret = -EINVAL;
-				goto done;
-			}
-			robust_coex_cfg->param.robustcoexparams.method =
-				ROBUSTCOEX_GPIO_CFG;
-			robust_coex_cfg->param.robustcoexparams.enable =
-				ROBUSTCOEX_GPIOCFG_ENABLE;
-			robust_coex_cfg->param.robustcoexparams.gpio_num =
-				data[1];
-			robust_coex_cfg->param.robustcoexparams.gpio_polarity =
-				data[2];
-		} else {
-			robust_coex_cfg->param.robustcoexparams.method =
-				ROBUSTCOEX_GPIO_CFG;
-			robust_coex_cfg->param.robustcoexparams.enable =
-				ROBUSTCOEX_GPIOCFG_DISABLE;
-			robust_coex_cfg->param.robustcoexparams.gpio_num = 0;
-			robust_coex_cfg->param.robustcoexparams.gpio_polarity =
-				0;
-		}
+		cfg_11n->param.coex_rx_winsize = data;
 		req->action = MLAN_ACT_SET;
-		req->req_id = MLAN_IOCTL_MISC_CFG;
-		robust_coex_cfg->sub_command = MLAN_OID_MISC_ROBUSTCOEX;
-	} else {
-		PRINTM(MERROR, "Invalid parameter\n");
-		ret = -EFAULT;
-		goto done;
 	}
+
+	/* Send IOCTL request to MLAN */
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
 
+	if (!user_data_len) {
+		moal_memcpy_ext(priv->phandle, respbuf,
+				(t_u8 *)&cfg_11n->param.coex_rx_winsize,
+				sizeof(t_u32), respbuflen);
+		ret = sizeof(t_u32);
+	}
+
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Set DMCS mapping policy or get DMCS status
+ * @brief               Set/Get control to TX AMPDU configuration on infra link
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_dmcs(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_txaggrctrl(moal_private *priv, t_u8 *respbuf,
+				t_u32 respbuflen)
 {
-	int header_len = 0, user_data_len = 0;
-	int ret = 0, data[2] = {0};
-	mlan_ds_misc_cfg *dmcs_cfg = NULL;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 	mlan_ioctl_req *req = NULL;
+	mlan_ds_11n_cfg *cfg_11n = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DMCS);
-	dmcs_cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-			&user_data_len);
-	if (user_data_len > 2) {
-		PRINTM(MERROR, "Invalid number of args! %d\n", user_data_len);
-		ret = -EINVAL;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TX_AGGR_CTRL);
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-	dmcs_cfg->sub_command = MLAN_OID_MISC_DMCS_CONFIG;
-	dmcs_cfg->param.dmcs_policy.subcmd = data[0];
-	switch (data[0]) {
-	case 0:
-		if (user_data_len != 2) {
-			PRINTM(MERROR, "Please provide mapping policy\n");
+
+	/* Fill request buffer */
+	req->req_id = MLAN_IOCTL_11N_CFG;
+	cfg_11n = (mlan_ds_11n_cfg *)req->pbuf;
+	cfg_11n->sub_command = MLAN_OID_11N_CFG_TX_AGGR_CTRL;
+
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
+		}
+		if ((data != MTRUE) && (data != MFALSE)) {
+			PRINTM(MERROR, "Invalid txaggrctrl parameter %d\n",
+			       data);
 			ret = -EINVAL;
 			goto done;
 		}
+		cfg_11n->param.txaggrctrl = data;
 		req->action = MLAN_ACT_SET;
-		dmcs_cfg->param.dmcs_policy.mapping_policy = data[1];
-		break;
-	case 1:
-		req->action = MLAN_ACT_GET;
-		break;
-	default:
-		break;
 	}
 
+	/* Send IOCTL request to MLAN */
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
-	if (req->action == MLAN_ACT_GET) {
+
+	if (!user_data_len) {
 		moal_memcpy_ext(priv->phandle, respbuf,
-				&dmcs_cfg->param.dmcs_status,
-				sizeof(mlan_ds_misc_dmcs_status), respbuflen);
+				(t_u8 *)&cfg_11n->param.txaggrctrl,
+				sizeof(t_u32), respbuflen);
+		ret = sizeof(t_u32);
 	}
-	ret = sizeof(mlan_ds_misc_dmcs_status);
+
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Set and get boot sleep configure
+ * @brief               Set/Get control to enable/disable auto TDLS
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_bootsleep(moal_private *priv, t_u8 *respbuf,
+static int woal_priv_auto_tdls(moal_private *priv, t_u8 *respbuf,
 			       t_u32 respbuflen)
 {
-	int ret = MLAN_STATUS_SUCCESS;
-	int user_data_len = 0;
-	int header_len = 0;
-	int allowed = 1;
-	int data[1] = {0};
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *misc = NULL;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 
 	ENTER();
 
@@ -12364,718 +16061,817 @@ static int woal_priv_bootsleep(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		LEAVE();
-		return -ENOMEM;
-	}
-
-	misc = (mlan_ds_misc_cfg *)req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_BOOT_SLEEP;
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_BOOTSLEEP);
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_AUTO_TDLS);
 
-	if (strlen(respbuf) == header_len) {
-		req->action = MLAN_ACT_GET;
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		data = priv->enable_auto_tdls;
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&data,
+				sizeof(data), respbuflen);
+		ret = sizeof(data);
 	} else {
-		req->action = MLAN_ACT_SET;
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
-		if (user_data_len != allowed) {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len != 1) {
 			PRINTM(MERROR, "Invalid number of args! %d\n",
 			       user_data_len);
 			ret = -EINVAL;
 			goto done;
 		}
-		misc->param.boot_sleep = data[0] ? 1 : 0;
-		PRINTM(MIOCTL, "boot sleep cfg:%u\n", misc->param.boot_sleep);
-	}
-
-	ret = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT_TIMEOUT);
-	if (ret != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
+		if ((data != MTRUE) && (data != MFALSE)) {
+			PRINTM(MERROR, "Invalid autotdls parameter %d\n", data);
+			ret = -EINVAL;
+			goto done;
+		}
+		priv->enable_auto_tdls = (t_u8)data;
 	}
 
-	moal_memcpy_ext(priv->phandle, respbuf, &misc->param.boot_sleep,
-			sizeof(misc->param.boot_sleep), respbuflen);
-	ret = sizeof(misc->param.boot_sleep);
-
-	PRINTM(MIOCTL, "boot sleep cfg: %u\n", misc->param.boot_sleep);
-
 done:
-	if (ret != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
 	return ret;
 }
 
-#if defined(PCIE)
+#ifdef PCIE
 /**
- * @brief               Enable SSU support
+ * @brief               Read/Write PCIE register
+ *
  * @param priv          Pointer to moal_private structure
- * @param used_len 		used length
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
  *
- *  @return             Number of bytes written, negative for failure.
+ * @return              Number of bytes written, negative for failure.
  */
-static int woal_priv_ssu_cmd(moal_private *priv, t_u8 used_len, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_pcie_reg_rw(moal_private *priv, t_u8 *respbuf,
+				 t_u32 respbuflen)
 {
-	int ret = 0;
-	mlan_ds_misc_cfg *ssu_cfg = NULL;
-	mlan_ioctl_req *req = NULL;
-	ssu_params_cfg *ssu_params;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	moal_handle *handle = priv->phandle;
+	int data[3];
+	t_u32 reg;
+	t_u32 value;
+	int ret = MLAN_STATUS_SUCCESS;
+	int user_data_len = 0, header_len = 0;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	memset(data, 0, sizeof(data));
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PCIE_REG_RW);
+	if ((int)strlen(respbuf) == header_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
 		goto done;
 	}
-	ssu_cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	memset(&ssu_cfg->param.ssu_params, 0, sizeof(mlan_ds_ssu_params));
-	if (!used_len) {
-		req->action = MLAN_ACT_SET;
-		ssu_cfg->param.ssu_params.nskip = 0;
-		ssu_cfg->param.ssu_params.nsel = 1;
-		ssu_cfg->param.ssu_params.adcdownsample = 3;
-		ssu_cfg->param.ssu_params.mask_adc_pkt = 0;
-		ssu_cfg->param.ssu_params.out_16bits = 1;
-	} else {
-		ssu_params = (ssu_params_cfg *)respbuf;
-		DBG_HEXDUMP(MCMD_D, "User SSU params:", respbuf,
-			    sizeof(mlan_ds_ssu_params));
-		if (ssu_params->ssu_mode == 2)
-			req->action = MLAN_ACT_DEFAULT;
-		else {
-			req->action = MLAN_ACT_SET;
-			ssu_cfg->param.ssu_params.nskip = ssu_params->nskip;
-			ssu_cfg->param.ssu_params.nsel = ssu_params->nsel;
-			ssu_cfg->param.ssu_params.adcdownsample =
-				ssu_params->adcdownsample;
-			ssu_cfg->param.ssu_params.mask_adc_pkt =
-				ssu_params->mask_adc_pkt;
-			ssu_cfg->param.ssu_params.out_16bits =
-				ssu_params->out_16bits;
-			ssu_cfg->param.ssu_params.spec_pwr_enable =
-				ssu_params->spec_pwr_enable;
-			ssu_cfg->param.ssu_params.rate_deduction =
-				ssu_params->rate_deduction;
-			ssu_cfg->param.ssu_params.n_pkt_avg =
-				ssu_params->n_pkt_avg;
-		}
-	}
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-	ssu_cfg->sub_command = MLAN_OID_MISC_SSU;
 
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+	if ((user_data_len != 1) && (user_data_len != 2)) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
 		goto done;
 	}
 
+	reg = (t_u32)data[0];
+	if (user_data_len == 1) {
+		if (moal_read_reg(handle, reg, &value)) {
+			ret = -EFAULT;
+			goto done;
+		}
+		data[1] = value;
+	} else {
+		value = data[1];
+		if (moal_write_reg(handle, reg, value)) {
+			ret = -EFAULT;
+			goto done;
+		}
+	}
+	moal_memcpy_ext(handle, respbuf, (t_u8 *)data, sizeof(data),
+			respbuflen);
+	ret = sizeof(data);
+
 done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
- * @brief               configure 11ax HE capability or HE operation
- *
+ * @brief               Read/Write PCIE register/memory from BAR0
  *
- *  @param priv    Pointer to the mlan_private driver data struct
- *  @param respbuf      A pointer to response buffer
- *  @param len          length used
- *  @param respbuflen   Available length of response buffer
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
  *
- *  @return         Number of bytes written if successful else negative value
+ * @return              Number of bytes written, negative for failure.
  */
-static int woal_priv_11axcfg_cmd(moal_private *priv, t_u8 *respbuf, t_u8 len,
-				 t_u32 respbuflen)
+static int woal_priv_pcie_bar0_reg_rw(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_11ax_cfg *cfg = NULL;
-	mlan_ds_11ax_he_cfg *data_ptr = NULL;
-	int ret = 0;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	moal_handle *handle = priv->phandle;
+	pcie_service_card *card = (pcie_service_card *)handle->card;
+	int data[3];
+	t_u32 reg;
+	t_u32 value;
+	int ret = MLAN_STATUS_SUCCESS;
+	int user_data_len = 0, header_len = 0;
 
 	ENTER();
 
-	data_ptr = (mlan_ds_11ax_he_cfg *)respbuf;
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11ax_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	memset(data, 0, sizeof(data));
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PCIE_BAR0_REG_RW);
+	if ((int)strlen(respbuf) == header_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
 		goto done;
 	}
 
-	req->req_id = MLAN_IOCTL_11AX_CFG;
-	req->action = MLAN_ACT_SET;
-	cfg = (mlan_ds_11ax_cfg *)req->pbuf;
-	cfg->sub_command = MLAN_OID_11AX_HE_CFG;
-	if (len)
-		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.he_cfg,
-				respbuf, len, sizeof(mlan_ds_11ax_he_cfg));
-	else
-		req->action = MLAN_ACT_GET;
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+	if ((user_data_len != 1) && (user_data_len != 2)) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
 		goto done;
 	}
-	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&cfg->param.he_cfg,
-			sizeof(mlan_ds_11ax_he_cfg), respbuflen);
-	ret = sizeof(mlan_ds_11ax_he_cfg);
+
+	reg = (t_u32)data[0];
+	if (user_data_len == 1) {
+		value = ioread32(card->pci_mmap + reg);
+		if (value == MLAN_STATUS_FAILURE) {
+			ret = -EFAULT;
+			goto done;
+		}
+		data[1] = value;
+	} else {
+		value = data[1];
+		iowrite32(value, card->pci_mmap + reg);
+	}
+	moal_memcpy_ext(handle, respbuf, (t_u8 *)data, sizeof(data),
+			respbuflen);
+	ret = sizeof(data);
+
 done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
 	return ret;
 }
+#endif
+
 /**
- * @brief               Configure TWT Setup parameters
+ * @brief               Get SOC temperature
  *
- * @param priv          Pointer to the mlan_private driver data struct
- * @param respbuf       A pointer to response buffer
- * @param len           Length used
- * @param respbuflen    Available length of response buffer
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
  *
- * @return              Number of bytes written if successful else negative
- * value
+ * @return              Number of bytes written, negative for failure.
  */
-static int woal_priv_twt_setup(moal_private *priv, t_u8 *respbuf, t_u8 len,
-			       t_u32 respbuflen)
+static int woal_priv_get_sensor_temp(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
-	mlan_ds_twtcfg *cfg = NULL;
+	mlan_ds_misc_cfg *pcfg = NULL;
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_twtcfg));
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		PRINTM(MERROR, "Failed to allocate ioctl_req!\n");
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	req->req_id = MLAN_IOCTL_11AX_CFG;
-	req->action = MLAN_ACT_SET;
-	cfg = (mlan_ds_twtcfg *)req->pbuf;
-	cfg->sub_command = MLAN_OID_11AX_TWT_CFG;
-	cfg->sub_id = MLAN_11AX_TWT_SETUP_SUBID;
-
-	if (len) {
-		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.twt_setup,
-				respbuf, len, sizeof(mlan_ds_twt_setup));
-	}
+	pcfg = (mlan_ds_misc_cfg *)req->pbuf;
+	pcfg->sub_command = MLAN_OID_MISC_GET_SENSOR_TEMP;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_GET;
 
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "woal_request_ioctl failed!\n");
 		ret = -EFAULT;
 		goto done;
 	}
 
-	ret = sizeof(mlan_ds_twt_setup);
+	memset(respbuf, 0, respbuflen);
+	moal_memcpy_ext(priv->phandle, respbuf,
+			&pcfg->param.sensor_temp.temperature, sizeof(t_u32),
+			respbuflen);
+
+	ret = sizeof(t_u32);
+
 done:
-	if (status != MLAN_STATUS_PENDING) {
+	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
-	}
 	LEAVE();
 	return ret;
 }
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 /**
- * @brief               Configure TWT Tear down parameters
+ * @brief               Enable/disable DFS offload
  *
- * @param priv          Pointer to the mlan_private driver data struct
- * @param respbuf       A pointer to response buffer
- * @param len           Length used
- * @param respbuflen    Available length of response buffer
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
  *
- * @return              Number of bytes written if successful else negative
- * value
+ * @return              Number of bytes written, negative for failure.
  */
-static int woal_priv_twt_teardown(moal_private *priv, t_u8 *respbuf, t_u8 len,
-				  t_u32 respbuflen)
+static int woal_priv_dfs_offload_enable(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_twtcfg *cfg = NULL;
-	int ret = 0;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0, dfs_offload_en = 0, user_data_len = 0, header_len = 0,
+	    dfs_offload;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_twtcfg));
-	if (req == NULL) {
-		PRINTM(MERROR, "Failed to allocate ioctl_req!\n");
-		ret = -ENOMEM;
+	if (!priv) {
+		PRINTM(MERROR, "priv is NULL\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	req->req_id = MLAN_IOCTL_11AX_CFG;
-	req->action = MLAN_ACT_SET;
-	cfg = (mlan_ds_twtcfg *)req->pbuf;
-	cfg->sub_command = MLAN_OID_11AX_TWT_CFG;
-	cfg->sub_id = MLAN_11AX_TWT_TEARDOWN_SUBID;
-
-	if (len) {
-		moal_memcpy_ext(priv->phandle, (t_u8 *)&cfg->param.twt_teardown,
-				respbuf, len, sizeof(mlan_ds_twt_teardown));
+	dfs_offload = moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD);
+	if (woal_is_any_interface_active(priv->phandle)) {
+		PRINTM(MERROR,
+		       "DFS offload enable/disable do not allowed after BSS started!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_OFFLOAD);
+	parse_arguments(respbuf + header_len, &dfs_offload_en,
+			sizeof(dfs_offload_en) / sizeof(int), &user_data_len);
+	if (user_data_len != 1) {
+		PRINTM(MERROR, "Invalid number of args! %d\n", user_data_len);
+		ret = -EINVAL;
+		goto done;
 	}
 
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "woal_request_ioctl failed!\n");
-		ret = -EFAULT;
+	if (dfs_offload_en != 0 && dfs_offload_en != 1) {
+		PRINTM(MERROR, "Invalid args!\n");
+		ret = -EINVAL;
 		goto done;
 	}
-
-	ret = sizeof(mlan_ds_twt_teardown);
+	if (dfs_offload != dfs_offload_en) {
+		dfs_offload = dfs_offload_en;
+		if (dfs_offload)
+			moal_extflg_set(priv->phandle, EXT_DFS_OFFLOAD);
+		else
+			moal_extflg_clear(priv->phandle, EXT_DFS_OFFLOAD);
+	}
 done:
-	if (status != MLAN_STATUS_PENDING) {
-		kfree(req);
-	}
 	LEAVE();
 	return ret;
 }
+#endif
+#endif
 
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(UAP_CFG80211)
 /**
- * @brief               Set/Get P2P NoA (Notice of Absence) parameters
+ * @brief               Set/Get TDLS CS off channel value
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
+
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_cfg_noa(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_tdls_cs_chan(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
-	int header_len = 0, user_data_len = 0;
-	int ret = 0, data[7];
-	mlan_ds_wifi_direct_config noa_cfg;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_NOA);
-	memset(&noa_cfg, 0, sizeof(noa_cfg));
-
-	memset(data, 0, sizeof(data));
-	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-			&user_data_len);
-
-	if (user_data_len > 5) {
-		PRINTM(MERROR, "invalid parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	noa_cfg.flags |= WIFI_DIRECT_NOA;
-
-	if (woal_p2p_config(priv, MLAN_ACT_GET, &noa_cfg) !=
-	    MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "Could not get P2P noa config\n");
-		ret = -EINVAL;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
-	if (strlen(respbuf) == header_len) {
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_CS_CHANNEL;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen("TDLS_CS_CHAN");
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
-		moal_memcpy_ext(priv->phandle, respbuf, &noa_cfg,
-				sizeof(noa_cfg), respbuflen);
-		ret = sizeof(noa_cfg);
+		ioctl_req->action = MLAN_ACT_GET;
 	} else {
-		switch (user_data_len) {
-		case 5:
-			noa_cfg.noa_interval = (t_u32)data[4];
-			/* fall through */
-		case 4:
-			noa_cfg.noa_duration = (t_u32)data[3];
-			/* fall through */
-		case 3:
-			if (data[2] < 1 || data[2] > 255) {
-				PRINTM(MERROR,
-				       "Invalid number of absence intervals\n");
-				ret = -EINVAL;
-				goto done;
-			}
-			noa_cfg.noa_count = (t_u8)data[2];
-			/* fall through */
-		case 2:
-			if (data[1] < 0 || data[1] > 255) {
-				PRINTM(MERROR, "Invalid Index\n");
-				ret = -EINVAL;
-				goto done;
-			}
-			noa_cfg.index = (t_u16)data[1];
-			/* fall through */
-		case 1:
-			if (data[0] < 0 || data[0] > 1) {
-				PRINTM(MERROR, "Invalid noa enable\n");
-				ret = -EINVAL;
-				goto done;
-			}
-			noa_cfg.noa_enable = (t_u8)data[0];
-			noa_cfg.flags |= WIFI_DIRECT_NOA;
-			break;
-		default:
-			break;
+		/* SET operation */
+		parse_arguments(respbuf + header_len + 1, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
 		}
-		woal_p2p_config(priv, MLAN_ACT_SET, &noa_cfg);
+		ioctl_req->action = MLAN_ACT_SET;
+		misc->param.tdls_cs_channel = (t_u8)data;
+	}
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
 	}
 
+	ret = snprintf(respbuf, CMD_BUF_LEN, "off channel %d\n",
+		       misc->param.tdls_cs_channel) +
+	      1;
+
+	PRINTM(MIOCTL, "tdls CS channel %d\n", misc->param.tdls_cs_channel);
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
 
 	LEAVE();
 	return ret;
 }
-
 /**
- * @brief               Set/Get P2P OPP-PS parameters
+ * @brief               Set/Get TDLS idle timeout value
+ *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
+
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_cfg_opp_ps(moal_private *priv, t_u8 *respbuf,
-				t_u32 respbuflen)
+static int woal_priv_tdls_idle_time(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
-	int header_len = 0, user_data_len = 0;
-	int ret = 0, data[7];
-	mlan_ds_wifi_direct_config opp_ps_cfg;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_CFG_OPP_PS);
-	memset(&opp_ps_cfg, 0, sizeof(opp_ps_cfg));
-
-	memset(data, 0, sizeof(data));
-	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-			&user_data_len);
-
-	if (user_data_len > 2) {
-		PRINTM(MERROR, "invalid parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	opp_ps_cfg.flags |= WIFI_DIRECT_OPP_PS;
-
-	if (woal_p2p_config(priv, MLAN_ACT_GET, &opp_ps_cfg) !=
-	    MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "Could not get P2P opp ps config\n");
-		ret = -EINVAL;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
-	if (strlen(respbuf) == header_len) {
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_IDLE_TIME;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TDLS_IDLE_TIME);
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
-		moal_memcpy_ext(priv->phandle, respbuf, &opp_ps_cfg,
-				sizeof(opp_ps_cfg), respbuflen);
-		ret = sizeof(opp_ps_cfg);
+		ioctl_req->action = MLAN_ACT_GET;
 	} else {
-		switch (user_data_len) {
-		case 2:
-			opp_ps_cfg.ct_window = (t_u8)data[1];
-			/* fall through */
-		case 1:
-			if (data[0] < 0 || data[0] > 1) {
-				PRINTM(MERROR, "Invalid ps enable\n");
-				ret = -EINVAL;
-				goto done;
-			}
-			opp_ps_cfg.opp_ps_enable = (t_u8)data[0];
-			opp_ps_cfg.flags |= WIFI_DIRECT_OPP_PS;
-			/* fall through */
-		default:
-			break;
+		/* SET operation */
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid number of args! %d\n",
+			       user_data_len);
+			ret = -EINVAL;
+			goto done;
 		}
-		woal_p2p_config(priv, MLAN_ACT_SET, &opp_ps_cfg);
+		ioctl_req->action = MLAN_ACT_SET;
+		misc->param.tdls_idle_time = (t_u16)data;
 	}
 
-done:
-
-	LEAVE();
-	return ret;
-}
-#endif
-#endif
-
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-#ifdef WIFI_DIRECT_SUPPORT
-#define DEF_NOA_INTERVAL 100
-/**
- ** @brief               Set/Get P2P NoA (Notice of Absence) parameters
- ** @param priv          Pointer to moal_private structure
- ** @param respbuf       Pointer to response buffer
- ** @param resplen       Response buffer length
- **
- **  @return             Number of bytes written, negative for failure.
- **/
-static int woal_p2p_ps_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
-{
-	int user_data_len = 0;
-	int ret = 0, data[2];
-	u32 duration = priv->phandle->noa_duration;
-	u32 interval = 0;
-
-	ENTER();
-	if (strlen(respbuf) > strlen("P2P_PERIODIC_SLEEP")) {
-		memset((char *)data, 0, sizeof(data));
-		parse_arguments(respbuf + strlen("P2P_PERIODIC_SLEEP") + 1,
-				data, ARRAY_SIZE(data), &user_data_len);
-	}
-	if ((user_data_len != 1) && (user_data_len != 2)) {
-		PRINTM(MERROR,
-		       " Invalid parameter number for P2P_PERIODIC_SLEEP");
-		ret = -EINVAL;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
 		goto done;
 	}
-	if (data[0] < DEF_NOA_INTERVAL)
-		interval = DEF_NOA_INTERVAL;
-	else
-		interval = (data[0] + DEF_NOA_INTERVAL - 1) / DEF_NOA_INTERVAL *
-			   DEF_NOA_INTERVAL;
 
-	if (user_data_len == 2)
-		duration = data[1];
-	if (duration >= interval) {
-		PRINTM(MERROR,
-		       " Invalid noa duration/interval! duration=%d interval=%d\n",
-		       duration, interval);
-		ret = -EINVAL;
-		goto done;
-	}
-	priv->phandle->noa_interval = interval;
-	priv->phandle->noa_duration = duration;
-	PRINTM(MIOCTL, "configure noa interval=%d, duration=%d\n",
-	       priv->phandle->noa_interval, priv->phandle->noa_duration);
+	moal_memcpy_ext(priv->phandle, respbuf,
+			(t_u8 *)&misc->param.tdls_idle_time, sizeof(t_u16),
+			respbuflen);
+	ret = sizeof(t_u16);
+
+	PRINTM(MIOCTL, "tdls idle time %d\n", misc->param.tdls_idle_time);
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
 	LEAVE();
 	return ret;
 }
-#endif
-#endif
 
 /**
- * @brief               Set/Get DFS repeater mode
+ * @brief               Set/Get dynamic bandwidth
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
+
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_dfs_repeater_cfg(moal_private *priv, t_u8 *respbuf,
-				      t_u32 respbuflen)
+static int woal_priv_config_dyn_bw(moal_private *priv, t_u8 *respbuf,
+				   t_u32 respbuflen)
 {
-	int ret = 0;
-	int user_data_len = 0, header_len = 0, data[1] = {0};
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *misc_cfg = NULL;
-	mlan_ds_misc_dfs_repeater *dfs_repeater = NULL;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+	int user_data_len = 0, header_len = 0, data = 0;
 
 	ENTER();
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_REPEATER_CFG);
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
 
-	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	/* Fill request buffer */
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-	misc_cfg = (mlan_ds_misc_cfg *)req->pbuf;
-	misc_cfg->sub_command = MLAN_OID_MISC_DFS_REAPTER_MODE;
-	dfs_repeater =
-		(mlan_ds_misc_dfs_repeater *)&misc_cfg->param.dfs_repeater;
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_DYN_BW;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	if (strlen(respbuf) == header_len) {
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DYN_BW);
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
-		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
+		ioctl_req->action = MLAN_ACT_GET;
 	} else {
 		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
+		parse_arguments(respbuf + header_len, &data,
+				sizeof(data) / sizeof(int), &user_data_len);
 		if (user_data_len != 1) {
 			PRINTM(MERROR, "Invalid number of args! %d\n",
 			       user_data_len);
 			ret = -EINVAL;
 			goto done;
 		}
-		if ((data[0] != MTRUE) && (data[0] != MFALSE)) {
-			PRINTM(MERROR, "Invalid DFS repeater mode %d\n",
-			       data[0]);
-			ret = -EINVAL;
-			goto done;
-		}
-		dfs_repeater->mode = (t_u16)data[0];
-
-		req->action = MLAN_ACT_SET;
+		ioctl_req->action = MLAN_ACT_SET;
+		misc->param.dyn_bw = (t_u16)data;
 	}
 
-	/* Send IOCTL request to MLAN */
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
 
-	if (!user_data_len) {
-		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)dfs_repeater,
-				sizeof(mlan_ds_misc_dfs_repeater), respbuflen);
-		ret = sizeof(mlan_ds_misc_dfs_repeater);
-	}
-
-	/* Store current value of DFS repeater mode for futher references. eg.,
-	 * for avoiding CAC timers
-	 */
-	priv->phandle->dfs_repeater_mode = dfs_repeater->mode;
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&misc->param.dyn_bw,
+			sizeof(t_u16), respbuflen);
+	ret = sizeof(t_u16);
 
+	PRINTM(MIOCTL, "Dynamic bandwidth %d\n", misc->param.dyn_bw);
 done:
 	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
+		kfree(ioctl_req);
 
 	LEAVE();
 	return ret;
 }
 
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if defined(UAP_SUPPORT)
 /**
- * @brief               Set/Get MIRACAST configuration parameters
+ * @brief               Check validation of channel and oper class
  *
  * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param channel       channel
+ * @param oper_class    oper_class
+ * @param bandwidth     band width
  *
- *  @return             Number of bytes written, negative for failure.
+ *  @return             SUCCESS/FAIL
  */
-static int woal_priv_miracast_cfg(moal_private *priv, t_u8 *respbuf,
-				  t_u32 respbuflen)
+static int woal_check_valid_channel_operclass(moal_private *priv, int channel,
+					      int oper_class, t_u8 bandwidth)
 {
 	int ret = 0;
-	int user_data_len = 0, header_len = 0, data[3] = {0, 0, 0};
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	t_u8 bw;
 
 	ENTER();
 
-	if (!priv || !priv->phandle) {
-		PRINTM(MERROR, "priv or handle is null\n");
-		ret = -EFAULT;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
+	switch (bandwidth) {
+	case CHANNEL_BW_40MHZ_ABOVE:
+	case CHANNEL_BW_40MHZ_BELOW:
+		bw = CHAN_BW_40MHZ;
+		break;
+	case CHANNEL_BW_80MHZ:
+		bw = CHAN_BW_80MHZ;
+		break;
+	default:
+		bw = CHAN_BW_20MHZ;
+		break;
+	}
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_MIRACAST_CFG);
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_OPER_CLASS_CHECK;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_GET;
+	misc->param.bw_chan_oper.oper_class = (t_u8)oper_class;
+	misc->param.bw_chan_oper.channel = (t_u8)channel;
+	misc->param.bw_chan_oper.bandwidth = (t_u8)bw;
 
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		data[0] = priv->phandle->miracast_mode;
-		data[1] = priv->phandle->miracast_scan_time;
-		data[2] = priv->phandle->scan_chan_gap;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
 
-		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
-				sizeof(data), respbuflen);
-		ret = sizeof(data);
-	} else {
-		/* SET operation */
-		memset(data, 0, sizeof(data));
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
 
-		if (user_data_len > 3) {
-			PRINTM(MERROR, "Too many arguments\n");
-			ret = -EINVAL;
-			goto done;
-		}
-		if (data[0] < 0 || data[0] > 2 || data[1] < 0 || data[2] < 0) {
-			PRINTM(MERROR, "Invalid argument\n");
-			ret = -EINVAL;
-			goto done;
-		}
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief Enable radar detect for DFS channel
+ *
+ * @param priv            A pointer to moal private structure
+ * @param chan            channel
+ * @return                N/A
+ */
+static void woal_enable_dfs(moal_private *priv, t_u8 channel, t_u8 wait_option)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_chan_rep_req *pchan_rpt_req = NULL;
+	mlan_ds_11h_cfg *p11h_cfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	ENTER();
+	PRINTM(MCMND, "Enable Radar detect, chan %d\n", channel);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (NULL == req) {
+		PRINTM(MIOCTL, "No Memory to allocate ioctl buffer\n");
+		LEAVE();
+		return;
 	}
+	p11h_cfg = (mlan_ds_11h_cfg *)req->pbuf;
+	pchan_rpt_req = &p11h_cfg->param.chan_rpt_req;
+	pchan_rpt_req->startFreq = 5000;
+	pchan_rpt_req->chanNum = channel;
+	pchan_rpt_req->host_based = MTRUE;
+	pchan_rpt_req->millisec_dwell_time = 0;
 
-	if (user_data_len >= 1)
-		priv->phandle->miracast_mode = (t_u8)data[0];
-	if (user_data_len >= 2)
-		priv->phandle->miracast_scan_time = (t_u16)data[1];
-	if (user_data_len == 3)
-		priv->phandle->scan_chan_gap = (t_u16)data[2];
+	p11h_cfg->sub_command = MLAN_OID_11H_CHANNEL_CHECK;
+	req->req_id = MLAN_IOCTL_11H_CFG;
+	req->action = MLAN_ACT_SET;
+	/* Send Channel Check command and wait until the report is ready */
+	status = woal_request_ioctl(priv, req, wait_option);
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief send CSA/ECSA action frame
+ *
+ ** @param priv          Pointer to moal_private structure
+ *  @param block_tx      0-no need block traffic 1- need block traffic
+ *  @param oper_class    oper_class
+ *  @param channel       channel
+ *  @param switch count  how many csa/ecsa beacon will send out
+ *  @param wait_option
+ *
+ *  @return             channel center frequency center, if found; O, otherwise
+ */
+static int woal_action_channel_switch(moal_private *priv, t_u8 block_tx,
+				      t_u8 oper_class, t_u8 channel,
+				      t_u8 switch_count, t_u8 mode,
+				      t_u8 wait_option)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_bss *bss = NULL;
+	mlan_ioctl_req *req = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
 
+	bss = (mlan_ds_bss *)req->pbuf;
+	bss->sub_command = MLAN_OID_ACTION_CHAN_SWITCH;
+	req->req_id = MLAN_IOCTL_BSS;
+	req->action = MLAN_ACT_SET;
+	bss->param.chanswitch.mode = mode;
+	bss->param.chanswitch.chan_switch_mode = block_tx;
+	bss->param.chanswitch.new_channel_num = channel;
+	if (!switch_count)
+		bss->param.chanswitch.chan_switch_count = DEF_NUM_PKTS;
+	else if (!mode) /* bcast action frame */
+		bss->param.chanswitch.chan_switch_count =
+			MIN(switch_count, MAX_NUM_PKTS);
+	else /* ucast action frame */
+		bss->param.chanswitch.chan_switch_count = switch_count;
+	bss->param.chanswitch.new_oper_class = oper_class;
+	ret = woal_request_ioctl(priv, req, wait_option);
 done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
 	LEAVE();
 	return ret;
 }
 
+#ifdef UAP_SUPPORT
 /**
- *   @brief Configuring scan gap for miracast mode
+ *  @brief move the uAP to transition channel
  *
- *  @param priv         A pointer to moal_private structure
- *  @param respbuf      A pointer to response buffer
- *  @param respbuflen   Available length of response buffer
+ *  @param priv          Pointer to moal_private structure
  *
- *  @return             0 --success, otherwise failure
+ *  @return              N/A
  */
-int woal_set_scan_chan_gap(moal_private *priv, t_u8 *respbuf, int respbuflen)
+void woal_move_to_next_channel(moal_private *priv)
+{
+	mlan_ds_11h_chan_dfs_state ch_dfs;
+	t_u8 next_chan = 0;
+	if (priv->target_chan) {
+		next_chan = priv->target_chan;
+		priv->target_chan = 0;
+	} else if (priv->backup_chan) {
+		next_chan = priv->backup_chan;
+	}
+	if (!next_chan)
+		return;
+	memset(&ch_dfs, 0, sizeof(ch_dfs));
+	ch_dfs.channel = next_chan;
+	if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET, &ch_dfs))
+		PRINTM(MERROR, "%s: woal_11h_chan_dfs_state failed \n",
+		       __func__);
+	if (ch_dfs.dfs_required)
+		woal_enable_dfs(priv, next_chan, MOAL_NO_WAIT);
+	woal_action_channel_switch(priv, MTRUE, 0, next_chan,
+				   priv->chan_num_pkts, priv->chan_mode,
+				   MOAL_NO_WAIT);
+	return;
+}
+#endif
+
+/**
+ * @brief               Set extended channel switch ie
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
+ *
+ * @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_extend_channel_switch(moal_private *priv, t_u8 *respbuf,
+					   t_u32 respbuflen)
 {
-	t_u32 data[2];
 	int ret = 0;
 	int user_data_len = 0;
+	int data[6] = {0};
+	t_u8 band = BAND_2GHZ;
+	t_u8 channel;
+	mlan_ds_11h_chan_dfs_state ch_dfs;
 
 	ENTER();
 
-	if (strlen(respbuf) > strlen("SCAN_TIMING")) {
-		memset((char *)data, 0, sizeof(data));
-		parse_arguments(respbuf + strlen("SCAN_TIMING") + 1, data,
-				ARRAY_SIZE(data), &user_data_len);
+	if (!priv || !priv->phandle || (priv->bss_role != MLAN_BSS_ROLE_UAP) ||
+	    (priv->bss_started != MTRUE)) {
+		PRINTM(MERROR,
+		       "priv or handle is null or interface is not AP/GO"
+		       "or AP is not started\n");
+		ret = -EFAULT;
+		LEAVE();
+		return ret;
+	}
+
+	parse_arguments(respbuf + strlen(CMD_NXP) +
+				strlen(PRIV_CMD_EXTEND_CHAN_SWITCH),
+			data, ARRAY_SIZE(data), &user_data_len);
+
+	if (sizeof(int) * user_data_len > sizeof(data)) {
+		PRINTM(MERROR, "Too many arguments\n");
+		ret = -EINVAL;
+		LEAVE();
+		return ret;
+	}
+	if (user_data_len < 4) {
+		PRINTM(MERROR, "Too few arguments\n");
+		ret = -EINVAL;
+		LEAVE();
+		return ret;
+	}
+	channel = data[2];
+	if (data[1]) {
+		if (woal_check_valid_channel_operclass(priv, data[2], data[1],
+						       data[4])) {
+			PRINTM(MERROR, "Wrong channel switch parameters!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+	}
+
+	if (channel > MAX_BG_CHANNEL)
+		band = BAND_5GHZ;
+	/* For 2.4G/6G channels skip the DFS checks */
+	if (band == BAND_5GHZ) {
+		memset(&ch_dfs, 0, sizeof(ch_dfs));
+		ch_dfs.channel = data[2];
+
+		if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET, &ch_dfs)) {
+			PRINTM(MERROR, "%s: woal_11h_chan_dfs_state failed \n",
+			       __func__);
+			ret = -EFAULT;
+			LEAVE();
+			return ret;
+		}
+
+		if (ch_dfs.dfs_required &&
+		    (ch_dfs.dfs_state == DFS_UNAVAILABLE ||
+		     ch_dfs.dfs_state == DFS_USABLE)) {
+			PRINTM(MERROR,
+			       "DFS: Channel=%d is not Available, cannot switch to this channel\n",
+			       data[2]);
+			ret = -EFAULT;
+			LEAVE();
+			return ret;
+		}
+
+		if (ch_dfs.dfs_required) {
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			woal_update_channels_dfs_state(priv, channel, data[4],
+						       DFS_AVAILABLE);
+#endif
+#endif
+			woal_enable_dfs(priv, data[2], MOAL_IOCTL_WAIT);
+		}
 	}
-
-	if (user_data_len != 2) {
-		PRINTM(MERROR, "Invalid arguments for scan timing\n");
+	if (data[5] && (data[5] < 0 || data[5] > 3)) {
+		PRINTM(MERROR,
+		       "Wrong channel switch parameters for ucast action frame!\n");
 		ret = -EINVAL;
 		goto done;
 	}
-	priv->phandle->miracast_scan_time = (t_u16)data[0];
-	priv->phandle->scan_chan_gap = (t_u16)data[1];
+
+	if (!data[3]) {
+		if (!data[5] && (data[4] < 0 || data[4] > MAX_NUM_PKTS)) {
+			PRINTM(MERROR,
+			       "Bcast action frame count exceeds maximum %d!\n",
+			       MAX_NUM_PKTS);
+			ret = -EINVAL;
+			goto done;
+		}
+		priv->chan_mode = data[5] & DEFAULT_CHAN_MODE_MASK;
+		priv->chan_num_pkts = data[4];
+	}
+
+	if (data[3])
+		woal_channel_switch(priv, data[0], data[1], data[2], data[3],
+				    band, data[4], MFALSE);
+	else
+		woal_action_channel_switch(priv, data[0], data[1], data[2],
+					   data[4], data[5], MOAL_IOCTL_WAIT);
 done:
 	LEAVE();
 	return ret;
 }
-#endif
-#endif
 
 /**
- * @brief               Set/Get control to coex RX window size configuration
+ * @brief               P2P extended channel switch
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
+
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_coex_rx_winsize(moal_private *priv, t_u8 *respbuf,
-				     t_u32 respbuflen)
+static int woal_priv_p2p_ecsa(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
 {
 	int ret = 0;
-	int user_data_len = 0, header_len = 0, data = 0;
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_11n_cfg *cfg_11n = NULL;
+	int user_data_len = 0, header_len = 0;
+	int data[2] = {0};
+	t_u8 bw = 0, oper_class = 0, channel = 0;
+	IEEEtypes_ExtChanSwitchAnn_t *ext_chan_switch = NULL;
+	custom_ie *pcust_chansw_ie = NULL;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
@@ -13086,318 +16882,930 @@ static int woal_priv_coex_rx_winsize(moal_private *priv, t_u8 *respbuf,
 		goto done;
 	}
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_COEX_RX_WINSIZE);
+	if (priv->bss_role != MLAN_BSS_ROLE_UAP) {
+		PRINTM(MERROR,
+		       "Extended Channel Switch is only allowed for AP/GO mode\n");
+		ret = -EFAULT;
+		goto done;
+	}
 
-	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
-	if (req == NULL) {
+	if (priv->bss_started != MTRUE) {
+		PRINTM(MERROR, "AP is not started!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	/* Fill request buffer */
-	req->req_id = MLAN_IOCTL_11N_CFG;
-	cfg_11n = (mlan_ds_11n_cfg *)req->pbuf;
-	cfg_11n->sub_command = MLAN_OID_11N_CFG_COEX_RX_WINSIZE;
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CUSTOM_IE;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_SET;
+	misc->param.cust_ie.type = TLV_TYPE_MGMT_IE;
+	misc->param.cust_ie.len = (sizeof(custom_ie) - MAX_IE_SIZE);
 
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
-	} else {
-		/* SET operation */
-		parse_arguments(respbuf + header_len, &data,
-				sizeof(data) / sizeof(int), &user_data_len);
-		if (user_data_len != 1) {
-			PRINTM(MERROR, "Invalid number of args! %d\n",
-			       user_data_len);
-			ret = -EINVAL;
-			goto done;
-		}
-		if ((data != MTRUE) && (data != MFALSE)) {
-			PRINTM(MERROR,
-			       "Invalid coex RX window size parameter %d\n",
-			       data);
-			ret = -EINVAL;
-			goto done;
-		}
-		cfg_11n->param.coex_rx_winsize = data;
-		req->action = MLAN_ACT_SET;
+	pcust_chansw_ie = (custom_ie *)&misc->param.cust_ie.ie_data_list[0];
+	pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
+	pcust_chansw_ie->ie_length = sizeof(IEEEtypes_ExtChanSwitchAnn_t);
+	pcust_chansw_ie->mgmt_subtype_mask =
+		MGMT_MASK_BEACON | MGMT_MASK_PROBE_RESP; /*Add IE for
+							    BEACON/probe resp*/
+	ext_chan_switch =
+		(IEEEtypes_ExtChanSwitchAnn_t *)pcust_chansw_ie->ie_buffer;
+
+	header_len = strlen("P2P_ECSA");
+	parse_arguments(respbuf + header_len + 1, data, ARRAY_SIZE(data),
+			&user_data_len);
+
+	if (user_data_len != 2) {
+		PRINTM(MERROR, "Invalid parameters\n");
+		ret = -EFAULT;
+		goto done;
 	}
 
-	/* Send IOCTL request to MLAN */
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
+	channel = data[0];
+	/* bandwidth 20:20M 40:40M 80:80M*/
+	bw = data[1];
+	if (bw != 20 && bw != 40 && bw != 80) {
+		PRINTM(MERROR, "Unsupported bandwidth\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	if (channel >= 52 && channel <= 144) {
+		PRINTM(MERROR, "Switch to DFS channel is not allowed!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	woal_priv_get_nonglobal_operclass_by_bw_channel(priv, bw, channel,
+							&oper_class);
+	if (oper_class == 0) {
+		PRINTM(MERROR, "Wrong parameters!\n");
 		ret = -EFAULT;
 		goto done;
 	}
+	ext_chan_switch->element_id = EXTEND_CHANNEL_SWITCH_ANN;
+	ext_chan_switch->len = 4;
+	ext_chan_switch->chan_switch_mode = 1;
+	ext_chan_switch->new_oper_class = oper_class;
+	ext_chan_switch->new_channel_num = channel;
+	ext_chan_switch->chan_switch_count = DEF_CHAN_SWITCH_COUNT;
 
-	if (!user_data_len) {
-		moal_memcpy_ext(priv->phandle, respbuf,
-				(t_u8 *)&cfg_11n->param.coex_rx_winsize,
-				sizeof(t_u32), respbuflen);
-		ret = sizeof(t_u32);
+	if (ext_chan_switch->chan_switch_mode) {
+		if (netif_carrier_ok(priv->netdev))
+			netif_carrier_off(priv->netdev);
+		woal_stop_queue(priv->netdev);
+		priv->uap_tx_blocked = MTRUE;
+	}
+
+	DBG_HEXDUMP(MCMD_D, "ECSA IE", (t_u8 *)pcust_chansw_ie->ie_buffer,
+		    pcust_chansw_ie->ie_length);
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
 	}
 
+	priv->phandle->chsw_wait_q_woken = MFALSE;
+	/* wait for channel switch to complete  */
+	(void)wait_event_interruptible_timeout(
+		priv->phandle->chsw_wait_q, priv->phandle->chsw_wait_q_woken,
+		(u32)HZ * (ext_chan_switch->chan_switch_count + 2) * 110 /
+			1000);
+
+	pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
+	pcust_chansw_ie->mgmt_subtype_mask = 0;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "Failed to clear ECSA IE\n");
+	}
 done:
 	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
+		kfree(ioctl_req);
 
 	LEAVE();
 	return ret;
 }
+#endif
 
-#ifdef PCIE
 /**
- * @brief               Read/Write PCIE register
+* @brief               Set random mac configure value (ON/OFF)
+*
+* @param priv          Pointer to moal_private structure
+* @param respbuf       Pointer to response buffer
+* @param resplen       Response buffer length
+
+*  @return             Number of bytes written, negative for failure.
+*/
+static int woal_priv_config_random_mac(moal_private *priv, t_u8 *respbuf,
+				       t_u32 respbuflen)
+{
+	int ret = 0;
+	int header_len = 0, space_len = 0, i;
+	t_u8 rand_data[3];
+	const t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0, 0, 0, 0, 0, 0};
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	header_len = strlen("FAKEMAC");
+	if ((int)strlen(respbuf) >= header_len) {
+		for (i = 0; i < (int)(strlen(respbuf) - header_len - 1); i++) {
+			if (respbuf[header_len + 1 + i] != ' ')
+				break;
+		}
+		space_len = i;
+
+		if (strncmp(respbuf + header_len + 1 + space_len, "On",
+			    strlen("On")) == 0) {
+			if (memcmp(priv->random_mac, zero_mac,
+				   MLAN_MAC_ADDR_LENGTH)) {
+				ret = snprintf(respbuf, CMD_BUF_LEN,
+					       "FAKEMAC has been On\n") +
+				      1;
+				goto done;
+			}
+			moal_memcpy_ext(priv->phandle, priv->random_mac,
+					priv->current_addr, ETH_ALEN,
+					MLAN_MAC_ADDR_LENGTH);
+			get_random_bytes(rand_data, 3);
+			moal_memcpy_ext(priv->phandle, priv->random_mac + 3,
+					rand_data, 3, 3);
+			PRINTM(MMSG, "FAKEMAC parameter is On\n");
+		} else if (strncmp(respbuf + header_len + 1 + space_len, "Off",
+				   strlen("Off")) == 0) {
+			memset(priv->random_mac, 0, ETH_ALEN);
+			PRINTM(MMSG, "FAKEMAC parameter is Off\n");
+		} else {
+			PRINTM(MERROR, "Invalid parameter!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+	} else {
+		PRINTM(MERROR, "Invalid parameter!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief               enable/disable roaming offload to firmware
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
- * @return              Number of bytes written, negative for failure.
+
+ *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_pcie_reg_rw(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_priv_set_roam_offload(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
-	moal_handle *handle = priv->phandle;
-	int data[3];
-	t_u32 reg;
-	t_u32 value;
-	int ret = MLAN_STATUS_SUCCESS;
-	int user_data_len = 0, header_len = 0;
+	int user_data_len = 0, header_len = 0, ret = 0;
+	int data = 0;
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	t_u8 enable = 0;
+#endif
+#endif
 
 	ENTER();
 
-	memset(data, 0, sizeof(data));
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PCIE_REG_RW);
-	if (strlen(respbuf) == header_len) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-			&user_data_len);
-	if ((user_data_len != 1) && (user_data_len != 2)) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
+		ret = -EFAULT;
 		goto done;
 	}
+#endif
+#endif
 
-	reg = (t_u32)data[0];
-	if (user_data_len == 1) {
-		if (moal_read_reg(handle, reg, &value)) {
-			ret = -EFAULT;
-			goto done;
-		}
-		data[1] = value;
-	} else {
-		value = data[1];
-		if (moal_write_reg(handle, reg, value)) {
-			ret = -EFAULT;
-			goto done;
-		}
+	header_len = strlen("SETROAMOFFLOAD");
+	parse_arguments(respbuf + header_len + 1, &data, 1, &user_data_len);
+
+	if (data < 0 || data > 5) {
+		PRINTM(MERROR, "Invalid parameters\n");
+		ret = -EFAULT;
+		goto done;
 	}
-	moal_memcpy_ext(handle, respbuf, (t_u8 *)data, sizeof(data),
-			respbuflen);
-	ret = sizeof(data);
 
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	if (!data) {
+		woal_cfg80211_vendor_event(priv, event_set_key_mgmt_offload,
+					   &enable, sizeof(enable));
+	}
+#endif
+#endif
+
+	ret = woal_enable_fw_roaming(priv, data);
 done:
+
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Read/Write PCIE register/memory from BAR0
+ * @brief               set roaming offload aplist to firmware
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
- * @return              Number of bytes written, negative for failure.
+
+ *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_pcie_bar0_reg_rw(moal_private *priv, t_u8 *respbuf,
-				      t_u32 respbuflen)
+static int woal_priv_set_roam_offload_aplist(moal_private *priv, t_u8 *respbuf,
+					     t_u32 respbuflen)
 {
-	moal_handle *handle = priv->phandle;
-	pcie_service_card *card = (pcie_service_card *)handle->card;
-	int data[3];
-	t_u32 reg;
-	t_u32 value;
-	int ret = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_roam_offload *roam = NULL;
+	mlan_ds_misc_roam_offload_aplist *aplist = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0, i = 0;
 	int user_data_len = 0, header_len = 0;
+	int ap_count = 0;
+	char *begin = NULL, *end = NULL;
+	t_u8 mac_addr[6];
 
 	ENTER();
 
-	memset(data, 0, sizeof(data));
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_PCIE_BAR0_REG_RW);
-	if (strlen(respbuf) == header_len) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-			&user_data_len);
-	if ((user_data_len != 1) && (user_data_len != 2)) {
-		PRINTM(MERROR, "Invalid number of parameters\n");
-		ret = -EINVAL;
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
+		ret = -EFAULT;
+		goto done;
+	}
+#endif
+#endif
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
 
-	reg = (t_u32)data[0];
-	if (user_data_len == 1) {
-		value = ioread32(card->pci_mmap + reg);
-		if (value == MLAN_STATUS_FAILURE) {
-			ret = -EFAULT;
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_ROAM_OFFLOAD_APLIST;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	roam = (mlan_ds_misc_roam_offload *)&misc->param.roam_offload;
+	/*Set enable to invalid value(valid: 0, 1, 2)*/
+	roam->enable = 3;
+	aplist = &roam->aplist;
+
+	header_len = strlen("SETROAMOFFLAPLIST");
+	user_data_len = strlen(respbuf) - header_len;
+	if (!user_data_len) {
+		/* GET operation */
+		ioctl_req->action = MLAN_ACT_GET;
+	} else {
+		begin = &respbuf[header_len + 1];
+		end = begin;
+		while (begin && *begin == ' ') {
+			begin++;
+			end++;
+		}
+		while (end && *end != ' ')
+			end++;
+		if (end != NULL)
+			*end = '\0';
+		end++;
+		if (begin) {
+			if (woal_atoi(&ap_count, begin) !=
+			    MLAN_STATUS_SUCCESS) {
+				ret = -EINVAL;
+				goto done;
+			}
+		}
+		aplist->ap_num = ap_count;
+		if (ap_count > 0 && ap_count <= MAX_AP_LIST) {
+			/* SET operation */
+			ioctl_req->action = MLAN_ACT_SET;
+			for (i = 0; i < ap_count; i++) {
+				begin = end;
+				while (begin && *begin == ' ') {
+					begin++;
+					end++;
+				}
+				while (end && *end != ' ' && *end != '\0')
+					end++;
+				if (end == begin) {
+					PRINTM(MERROR,
+					       "AP number %d is wrong\n",
+					       ap_count);
+					ret = -EINVAL;
+					goto done;
+				}
+				if (end != NULL)
+					*end = '\0';
+				end++;
+				woal_mac2u8(mac_addr, begin);
+				moal_memcpy_ext(priv->phandle,
+						aplist->ap_mac[i], mac_addr,
+						MLAN_MAC_ADDR_LENGTH,
+						MLAN_MAC_ADDR_LENGTH);
+			}
+		} else {
+			PRINTM(MERROR,
+			       "AP number is wrong.Support max 8 APs\n");
+			ret = -EINVAL;
 			goto done;
 		}
-		data[1] = value;
-	} else {
-		value = data[1];
-		iowrite32(value, card->pci_mmap + reg);
 	}
-	moal_memcpy_ext(handle, respbuf, (t_u8 *)data, sizeof(data),
-			respbuflen);
-	ret = sizeof(data);
+
+	DBG_HEXDUMP(MERROR, "APLIST", (t_u8 *)aplist->ap_mac,
+		    aplist->ap_num * MLAN_MAC_ADDR_LENGTH);
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
 
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
 	LEAVE();
 	return ret;
 }
-#endif
-
 /**
- * @brief               Get SOC temperature
+ * @brief               Configure roaming offload to firmware
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
- * @return              Number of bytes written, negative for failure.
+
+ *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_get_sensor_temp(moal_private *priv, t_u8 *respbuf,
-				     t_u32 respbuflen)
+static int woal_priv_roam_offload_cfg(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *pcfg = NULL;
-	int ret = 0;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0, user_data_len = 0, header_len = 0, data = 0;
+	char *begin = NULL, *end = NULL, *pvariable_name = NULL;
+	t_u8 mac_addr[MLAN_MAC_ADDR_LENGTH];
+	woal_roam_offload_cfg roam_offload_cfg;
+	t_u8 len = 0;
+	int count = 0, i = 0;
 
 	ENTER();
 
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
 		goto done;
 	}
 
-	pcfg = (mlan_ds_misc_cfg *)req->pbuf;
-	pcfg->sub_command = MLAN_OID_MISC_GET_SENSOR_TEMP;
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-	req->action = MLAN_ACT_GET;
-
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
 		ret = -EFAULT;
 		goto done;
 	}
+#endif
+#endif
 
-	memset(respbuf, 0, respbuflen);
-	moal_memcpy_ext(priv->phandle, respbuf,
-			&pcfg->param.sensor_temp.temperature, sizeof(t_u32),
-			respbuflen);
+	memset((char *)&roam_offload_cfg, 0, sizeof(roam_offload_cfg));
+	header_len = strlen("CFGROAMOFFLOAD");
+	user_data_len = strlen(respbuf) - header_len;
+	if (!user_data_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	roam_offload_cfg.band_rssi.band_preferred = 0xff;
+	roam_offload_cfg.trigger_condition = 0xff;
+	end = &respbuf[header_len];
+	while (((t_u8 *)end - &respbuf[header_len]) < user_data_len - 1) {
+		end++;
+		begin = end;
+		while (begin && *begin == ' ') {
+			begin++;
+			end++;
+		}
+		while (end && *end != ' ' && *end != '\0' && *end != '=')
+			end++;
+		if (end == begin) {
+			PRINTM(MERROR, "Invalid command specified!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (end)
+			*end = '\0';
+		pvariable_name = begin;
 
-	ret = sizeof(t_u32);
+		if (((t_u8 *)end - &respbuf[header_len]) >= user_data_len) {
+			PRINTM(MERROR, "Invalid command length!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		end++;
+		begin = end;
+		while (begin && (*begin == ' ' || *begin == '=')) {
+			begin++;
+			end++;
+		}
+		while (end && *end != ' ' && *end != '\0' && *end != '=')
+			end++;
+		if (end == begin) {
+			PRINTM(MERROR, "Invalid command specified!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (end != NULL)
+			*end = '\0';
+		if (pvariable_name && begin) {
+			if (strcmp(pvariable_name, "AUTO_RECONNECT") == 0) {
+				(void)woal_atoi(&data, begin);
+			} else if (strcmp(pvariable_name, "BSSID") == 0) {
+				woal_mac2u8(mac_addr, begin);
+				moal_memcpy_ext(priv->phandle,
+						roam_offload_cfg.bssid,
+						mac_addr, MLAN_MAC_ADDR_LENGTH,
+						MLAN_MAC_ADDR_LENGTH);
+			} else if (strcmp(pvariable_name, "BLACKLIST") == 0) {
+				if (woal_atoi(&count, begin) !=
+				    MLAN_STATUS_SUCCESS) {
+					ret = -EINVAL;
+					goto done;
+				}
+				if (count > 0 && count <= MAX_AP_LIST) {
+					roam_offload_cfg.black_list.ap_num =
+						count;
+					for (i = 0; i < count; i++) {
+						end++;
+						begin = end;
+						while (begin && *begin == ' ') {
+							begin++;
+							end++;
+						}
+						while (end && *end != ' ' &&
+						       *end != '\0')
+							end++;
+						if (end == begin) {
+							PRINTM(MERROR,
+							       "BSSID %d is wrong\n",
+							       count);
+							ret = -EINVAL;
+							goto done;
+						}
+						if (end != NULL)
+							*end = '\0';
+						woal_mac2u8(mac_addr, begin);
+						moal_memcpy_ext(
+							priv->phandle,
+							roam_offload_cfg
+								.black_list
+								.ap_mac[i],
+							mac_addr,
+							MLAN_MAC_ADDR_LENGTH,
+							MLAN_MAC_ADDR_LENGTH);
+					}
+				} else {
+					PRINTM(MERROR,
+					       "BSSID number is wrong.Support max %d BSSIDs\n",
+					       MAX_AP_LIST);
+					ret = -EINVAL;
+					goto done;
+				}
+			} else if (strcmp(pvariable_name, "SSID") == 0) {
+				if (woal_atoi(&count, begin) !=
+				    MLAN_STATUS_SUCCESS) {
+					ret = -EINVAL;
+					goto done;
+				}
+				if (count > 0 && count <= MAX_SSID_NUM) {
+					roam_offload_cfg.ssid_list.ssid_num =
+						count;
+					for (i = 0; i < count; i++) {
+						end++;
+						begin = end;
+						while (begin && *begin == ' ') {
+							begin++;
+							end++;
+						}
+						while (end && *end != ' ' &&
+						       *end != '\0') {
+							end++;
+							len++;
+						}
+						if ((end == begin) ||
+						    len >= MLAN_MAX_SSID_LENGTH) {
+							PRINTM(MERROR,
+							       "SSID %d is wrong\n",
+							       count);
+							ret = -EINVAL;
+							goto done;
+						}
+						if (end != NULL)
+							*end = '\0';
+						roam_offload_cfg.ssid_list
+							.ssids[i]
+							.ssid_len = len + 1;
+						moal_memcpy_ext(
+							priv->phandle,
+							(t_u8 *)&roam_offload_cfg
+								.ssid_list
+								.ssids[i]
+								.ssid,
+							begin, len + 1,
+							MLAN_MAX_SSID_LENGTH);
+						len = 0;
+					}
+				} else {
+					PRINTM(MERROR,
+					       "SSID number is wrong.Support max %d SSIDs\n",
+					       MAX_SSID_NUM);
+					ret = -EINVAL;
+					goto done;
+				}
+			} else if (strcmp(pvariable_name, "RETRY_COUNT") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.retry_count = (t_u8)data;
+			} else if (strcmp(pvariable_name,
+					  "TRIGGER_CONDITION") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.trigger_condition =
+					(t_u16)data;
+			} else if (strcmp(pvariable_name, "MAX_RSSI") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.max_rssi = (t_u8)data;
+				roam_offload_cfg.rssi_param_set_flag = 1;
+			} else if (strcmp(pvariable_name, "MIN_RSSI") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.min_rssi = (t_u8)data;
+				roam_offload_cfg.rssi_param_set_flag = 1;
+			} else if (strcmp(pvariable_name, "STEP_RSSI") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.step_rssi = (t_u8)data;
+				roam_offload_cfg.rssi_param_set_flag = 1;
+			} else if (strcmp(pvariable_name, "BAND_PREFER") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.band_rssi.band_preferred =
+					(t_u8)data;
+				roam_offload_cfg.band_rssi_flag = 1;
+			} else if (strcmp(pvariable_name, "RSSI_HYSTERESIS") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.band_rssi.rssi_hysteresis =
+					(t_u8)data;
+				roam_offload_cfg.band_rssi_flag = 1;
+			}
+
+			else if (strcmp(pvariable_name, "BSSTYPE") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.bgscan_cfg.bss_type =
+					(t_u8)data;
+				roam_offload_cfg.bgscan_set_flag++;
+			} else if (strcmp(pvariable_name, "CHANSPERSCAN") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.bgscan_cfg.channels_per_scan =
+					(t_u8)data;
+				roam_offload_cfg.bgscan_set_flag++;
+			} else if (strcmp(pvariable_name, "BGRPTCONDITION") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.bgscan_cfg.bg_rpt_condition =
+					(t_u32)data;
+				roam_offload_cfg.bgscan_set_flag++;
+			} else if (strcmp(pvariable_name, "SCANINTERVAL") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.bgscan_cfg.scan_interval =
+					(t_u32)data;
+				roam_offload_cfg.bgscan_set_flag++;
+			}
+
+			else if (strcmp(pvariable_name, "EESMODE") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.ees_mode = (t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "EESRPTCONDITION") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.ees_rpt_condition =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "HIGHSCANPERIOD") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.high_scan_period =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "HIGHSCANCOUNT") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.high_scan_count =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "MIDSCANPERIOD") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.mid_scan_period =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "MIDSCANCOUNT") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.mid_scan_count =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "LOWSCANPERIOD") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.low_scan_period =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			} else if (strcmp(pvariable_name, "LOWSCANCOUNT") ==
+				   0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.ees_cfg.low_scan_count =
+					(t_u16)data;
+				roam_offload_cfg.ees_param_set_flag++;
+			}
+
+			else if (strcmp(pvariable_name, "BCNMISSTHRESHOLD") ==
+				 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.bcn_miss_threshold =
+					(t_u8)data;
+			}
 
+			else if (strcmp(pvariable_name,
+					"PREBCNMISSTHRESHOLD") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.pre_bcn_miss_threshold =
+					(t_u8)data;
+			} else if (strcmp(pvariable_name, "REPEATCOUNT") == 0) {
+				(void)woal_atoi(&data, begin);
+				roam_offload_cfg.repeat_count = (t_u16)data;
+			} else {
+				PRINTM(MERROR, "Un-support parameter: %s\n",
+				       pvariable_name);
+				ret = -EINVAL;
+				goto done;
+			}
+		}
+	}
+	if (priv->phandle->fw_roam_enable == AUTO_RECONNECT) {
+		moal_memcpy_ext(priv->phandle,
+				priv->phandle->auto_reconnect_bssid,
+				roam_offload_cfg.bssid, MLAN_MAC_ADDR_LENGTH,
+				sizeof(mlan_802_11_mac_addr));
+		moal_memcpy_ext(priv->phandle,
+				&priv->phandle->auto_reconnect_ssid,
+				&roam_offload_cfg.ssid_list.ssids[0],
+				sizeof(mlan_802_11_ssid),
+				sizeof(mlan_802_11_ssid));
+		priv->phandle->auto_reconnect_retry_count = (t_u8)data;
+	} else {
+		if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS))
+			moal_memcpy_ext(priv->phandle,
+					(void *)&priv->phandle->fw_roam_params,
+					(void *)&roam_offload_cfg,
+					sizeof(roam_offload_cfg),
+					sizeof(priv->phandle->fw_roam_params));
+		else {
+			if (woal_config_fw_roaming(priv, ROAM_OFFLOAD_PARAM_CFG,
+						   &roam_offload_cfg)) {
+				PRINTM(MERROR,
+				       "%s: config fw roaming failed \n",
+				       __func__);
+				ret = -EFAULT;
+			}
+		}
+	}
 done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(req);
 	LEAVE();
 	return ret;
 }
 
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 /**
- * @brief               Enable/disable DFS offload
+ * @brief               Configure roaming SSID passphrase
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
  * @param resplen       Response buffer length
- *
- * @return              Number of bytes written, negative for failure.
+
+ *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_dfs_offload_enable(moal_private *priv, t_u8 *respbuf,
-					t_u32 respbuflen)
+static int woal_priv_set_roam_passphrase(moal_private *priv, t_u8 *respbuf,
+					 t_u32 respbuflen)
 {
-	struct wiphy *wiphy = NULL;
-	int ret = 0, dfs_offload_en = 0, user_data_len = 0, header_len = 0,
-	    dfs_offload;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_sec_cfg *sec = NULL;
+	int ret = 0, action = -1;
+	int user_data_len = 0, header_len = 0;
+	char *begin, *end, *opt, *item;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	woal_roam_offload_cfg roam_offload_cfg;
+	mlan_ds_passphrase *ssid_passphrase = NULL;
 
 	ENTER();
 
-	if (priv && priv->wdev)
-		wiphy = priv->wdev->wiphy;
-	if (!wiphy) {
-		PRINTM(MERROR, "wiphy is NULL\n");
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
 		ret = -EFAULT;
 		goto done;
 	}
-	dfs_offload = moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD);
-	if (woal_is_any_interface_active(priv->phandle)) {
-		PRINTM(MERROR,
-		       "DFS offload enable/disable do not allowed after BSS started!\n");
+
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
 		ret = -EFAULT;
 		goto done;
 	}
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DFS_OFFLOAD);
-	parse_arguments(respbuf + header_len, &dfs_offload_en,
-			sizeof(dfs_offload_en) / sizeof(int), &user_data_len);
-	if (user_data_len != 1) {
-		PRINTM(MERROR, "Invalid number of args! %d\n", user_data_len);
+#endif
+#endif
+
+	memset((char *)&roam_offload_cfg, 0, sizeof(roam_offload_cfg));
+	header_len = strlen("SETROAMPASSPHRASE");
+	user_data_len = strlen(respbuf) - header_len;
+	if (!user_data_len) {
+		PRINTM(MERROR, "Invalid number of parameters\n");
 		ret = -EINVAL;
 		goto done;
 	}
 
-	if (dfs_offload_en != 0 && dfs_offload_en != 1) {
-		PRINTM(MERROR, "Invalid args!\n");
+	/* Parse the buf to get the cmd_action */
+	begin = respbuf + header_len;
+	while (begin && *begin == ' ')
+		begin++;
+	end = woal_strsep(&begin, ';', '/');
+	if (end)
+		action = woal_atox(end);
+	PRINTM(MMSG, "action= %d\n", action);
+	if (action != 1 || end[1] != '\0') {
+		PRINTM(MERROR, "Invalid action argument %s\n", end);
 		ret = -EINVAL;
 		goto done;
 	}
-	if (dfs_offload != dfs_offload_en) {
-		dfs_offload = dfs_offload_en;
-		if (dfs_offload)
-			moal_extflg_set(priv->phandle, EXT_DFS_OFFLOAD);
-		else
-			moal_extflg_clear(priv->phandle, EXT_DFS_OFFLOAD);
-		woal_update_radar_chans_dfs_state(wiphy);
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_CFG_PASSPHRASE;
+	sec->multi_passphrase = 1;
+	req->action = MLAN_ACT_SET;
+
+	/*Parse the buffer like "ssid=xxx passphrase=xxxx;ssid=xxx
+	 * passphrase=xxx"*/
+	while (begin) {
+		while (begin && *begin == ' ')
+			begin++;
+		end = woal_strsep(&begin, ';', '/');
+		item = woal_strsep(&end, ' ', '/');
+		opt = woal_strsep(&item, '=', '/');
+		while (opt) {
+			if (roam_offload_cfg.userset_passphrase >=
+			    MAX_SEC_SSID_NUM - 1) {
+				PRINTM(MERROR,
+				       "Support max %d security SSIDs!\n",
+				       MAX_SEC_SSID_NUM);
+				break;
+			}
+			ssid_passphrase =
+				&sec->param.roam_passphrase
+					 [roam_offload_cfg.userset_passphrase];
+			if (!opt || !item || !end) {
+				PRINTM(MERROR, "Invalid option\n");
+				ret = -EINVAL;
+				goto done;
+			} else if (!strnicmp(opt, "ssid", strlen(opt))) {
+				if (strlen(end) > MLAN_MAX_SSID_LENGTH) {
+					PRINTM(MERROR,
+					       "SSID length exceeds max length\n");
+					ret = -EFAULT;
+					goto done;
+				}
+				ssid_passphrase->ssid.ssid_len = strlen(item);
+				strncpy((char *)ssid_passphrase->ssid.ssid,
+					item,
+					MIN(strlen(item),
+					    MLAN_MAX_SSID_LENGTH));
+				PRINTM(MINFO, "ssid=%s, len=%d\n",
+				       ssid_passphrase->ssid.ssid,
+				       (int)ssid_passphrase->ssid.ssid_len);
+			} else if (!strnicmp(opt, "passphrase", strlen(opt)) &&
+				   req->action == MLAN_ACT_SET) {
+				if (strlen(item) < MLAN_MIN_PASSPHRASE_LENGTH ||
+				    strlen(item) > MLAN_MAX_PASSPHRASE_LENGTH) {
+					PRINTM(MERROR,
+					       "Invalid length for passphrase\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				ssid_passphrase->psk_type = MLAN_PSK_PASSPHRASE;
+				moal_memcpy_ext(priv->phandle,
+						ssid_passphrase->psk.passphrase
+							.passphrase,
+						item, strlen(item),
+						MLAN_MAX_PASSPHRASE_LENGTH);
+				ssid_passphrase->psk.passphrase.passphrase_len =
+					strlen(item);
+				PRINTM(MINFO, "passphrase=%s, len=%d\n",
+				       ssid_passphrase->psk.passphrase
+					       .passphrase,
+				       (int)ssid_passphrase->psk.passphrase
+					       .passphrase_len);
+			} else {
+				PRINTM(MERROR, "Invalid option %s\n", opt);
+				ret = -EINVAL;
+				goto done;
+			}
+			if (!end || *end == '\0')
+				break;
+			while (end && *end == ' ')
+				end++;
+			item = woal_strsep(&end, ' ', '/');
+			opt = woal_strsep(&item, '=', '/');
+		}
+		roam_offload_cfg.userset_passphrase++;
+	}
+
+	if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS)) {
+		moal_memcpy_ext(priv->phandle,
+				(char *)priv->phandle->ssid_passphrase,
+				(char *)sec->param.roam_passphrase,
+				MAX_SEC_SSID_NUM * sizeof(mlan_ds_passphrase),
+				MAX_SEC_SSID_NUM * sizeof(mlan_ds_passphrase));
+		priv->phandle->fw_roam_params.userset_passphrase =
+			roam_offload_cfg.userset_passphrase;
+		goto done;
+	}
+
+	if (woal_config_fw_roaming(priv, ROAM_OFFLOAD_ENABLE,
+				   &roam_offload_cfg)) {
+		PRINTM(MERROR, "%s: config fw roaming failed \n", __func__);
+		ret = -EFAULT;
+		goto done;
+	}
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
 	}
+
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
 	LEAVE();
 	return ret;
 }
-#endif
-#endif
 
 /**
- * @brief               Set/Get dynamic bandwidth
+ * @brief               Download start keep alive parameters
  *
  * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @param mkeep_alive_id       keep alive ID number
+ * @param ip_pke        IP packet from host
+ * @param ip_pke_len    IP packet length from host
+ * @param src_mac       Source MAC address
+ * @param dst_mac       Destination MAC address
+ * @param period_msec   Send keep alive packet interval
 
- *  @return             Number of bytes written, negative for failure.
+ * @return      0: success  fail otherwise
  */
-static int woal_priv_config_dyn_bw(moal_private *priv, t_u8 *respbuf,
-				   t_u32 respbuflen)
+int woal_start_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id,
+			   t_u8 *ip_pkt, t_u16 ip_pkt_len, t_u8 *src_mac,
+			   t_u8 *dst_mac, t_u32 period_msec,
+			   t_u32 retry_interval, t_u8 retry_cnt)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	int ret = 0;
-	int user_data_len = 0, header_len = 0, data = 0;
 
 	ENTER();
 
@@ -13414,38 +17822,37 @@ static int woal_priv_config_dyn_bw(moal_private *priv, t_u8 *respbuf,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_DYN_BW;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_DYN_BW);
-	if (strlen(respbuf) == header_len) {
-		/* GET operation */
-		ioctl_req->action = MLAN_ACT_GET;
-	} else {
-		/* SET operation */
-		parse_arguments(respbuf + header_len, &data,
-				sizeof(data) / sizeof(int), &user_data_len);
-		if (user_data_len != 1) {
-			PRINTM(MERROR, "Invalid number of args! %d\n",
-			       user_data_len);
-			ret = -EINVAL;
-			goto done;
-		}
-		ioctl_req->action = MLAN_ACT_SET;
-		misc->param.dyn_bw = (t_u16)data;
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
+		PRINTM(MERROR, "Invalid parameters\n");
+		ret = -EFAULT;
+		goto done;
 	}
 
+	/* SET operation */
+	ioctl_req->action = MLAN_ACT_SET;
+	misc->param.keep_alive.mkeep_alive_id = mkeep_alive_id;
+	misc->param.keep_alive.enable = true;
+	misc->param.keep_alive.send_interval = period_msec;
+	misc->param.keep_alive.retry_interval = retry_interval;
+	misc->param.keep_alive.retry_count = retry_cnt;
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.dst_mac, dst_mac,
+			MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.src_mac, src_mac,
+			MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	misc->param.keep_alive.pkt_len =
+		MIN(ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.packet, ip_pkt,
+			ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
+
 	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
 
-	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)&misc->param.dyn_bw,
-			sizeof(t_u16), respbuflen);
-	ret = sizeof(t_u16);
-
-	PRINTM(MIOCTL, "Dynamic bandwidth %d\n", misc->param.dyn_bw);
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(ioctl_req);
@@ -13454,26 +17861,33 @@ static int woal_priv_config_dyn_bw(moal_private *priv, t_u8 *respbuf,
 	return ret;
 }
 
-#if defined(UAP_SUPPORT)
 /**
- * @brief               Check validation of channel and oper class
+ * @brief               Download stop keep alive parameters
  *
  * @param priv          Pointer to moal_private structure
- * @param channel       channel
- * @param oper_class    oper_class
+ * @param mkeep_alive_id       keep alive ID number
+ * @param ip_pkt        Last packet
+ * @param ip_pkt_len    Last packet length
 
- *  @return             SUCCESS/FAIL
+ * @return      0: success  fail otherwise
  */
-static int woal_check_valid_channel_operclass(moal_private *priv, int channel,
-					      int oper_class)
+int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
+			  t_u8 *ip_pkt, t_u8 *pkt_len)
 {
-	int ret = 0;
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_keep_alive *misc_keep_alive = NULL;
+	int ret = 0;
 
 	ENTER();
 
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
 	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
@@ -13481,11 +17895,20 @@ static int woal_check_valid_channel_operclass(moal_private *priv, int channel,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_OPER_CLASS_CHECK;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc_keep_alive = &misc->param.keep_alive;
+
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
+		PRINTM(MERROR, "Invalid parameters\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	/* GET operation */
 	ioctl_req->action = MLAN_ACT_GET;
-	misc->param.bw_chan_oper.oper_class = (t_u8)oper_class;
-	misc->param.bw_chan_oper.channel = (t_u8)channel;
+	misc_keep_alive->mkeep_alive_id = mkeep_alive_id;
+	misc_keep_alive->enable = false;
 
 	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
@@ -13493,88 +17916,74 @@ static int woal_check_valid_channel_operclass(moal_private *priv, int channel,
 		goto done;
 	}
 
-done:
-	if (status != MLAN_STATUS_PENDING)
-		kfree(ioctl_req);
-
-	LEAVE();
-	return ret;
-}
+	if (!misc_keep_alive->enable) {
+		PRINTM(MERROR, "ID %d is already stop\n", mkeep_alive_id);
+		goto done;
+	}
 
-/**
- ** @brief               Set extended channel switch ie
- **
- ** @param priv          Pointer to moal_private structure
- ** @param respbuf       Pointer to response buffer
- ** @param resplen       Response buffer length
- **
- ** @return             Number of bytes written, negative for failure.
- **/
-static int woal_priv_extend_channel_switch(moal_private *priv, t_u8 *respbuf,
-					   t_u32 respbuflen)
-{
-	int ret = 0;
-	int user_data_len = 0;
-	int data[5] = {0};
-	ENTER();
+	if (reset)
+		ioctl_req->action = MLAN_ACT_RESET;
+	else
+		/* SET operation */
+		ioctl_req->action = MLAN_ACT_SET;
+	misc_keep_alive->mkeep_alive_id = mkeep_alive_id;
+	misc_keep_alive->enable = false;
 
-	if (!priv || !priv->phandle || (priv->bss_role != MLAN_BSS_ROLE_UAP) ||
-	    (priv->bss_started != MTRUE)) {
-		PRINTM(MERROR,
-		       "priv or handle is null or interface is not AP/GO"
-		       "or AP is not started\n");
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
-		LEAVE();
-		return ret;
+		goto done;
 	}
 
-	parse_arguments(respbuf + strlen(CMD_NXP) +
-				strlen(PRIV_CMD_EXTEND_CHAN_SWITCH),
-			data, ARRAY_SIZE(data), &user_data_len);
-
-	if (sizeof(int) * user_data_len > sizeof(data)) {
-		PRINTM(MERROR, "Too many arguments\n");
-		ret = -EINVAL;
-		LEAVE();
-		return ret;
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	if (IS_STA_CFG80211(priv->phandle->params.cfg80211_wext)) {
+		ret = woal_mkeep_alive_vendor_event(priv,
+						    &misc->param.keep_alive);
+		if (ret)
+			PRINTM(MERROR,
+			       "Keep alive vendor event upload failed\n");
+	}
+#endif
+#endif
+	if (pkt_len) {
+		*pkt_len = MIN(misc_keep_alive->pkt_len,
+			       (MKEEP_ALIVE_IP_PKT_MAX - 1));
+		PRINTM(MINFO, "keep alive stop pkt_len is %d\n", *pkt_len);
 	}
+	if (*pkt_len && ip_pkt)
+		moal_memcpy_ext(priv->phandle, ip_pkt, misc_keep_alive->packet,
+				*pkt_len, *pkt_len);
 
-	if (data[1]) {
-		if (woal_check_valid_channel_operclass(priv, data[2],
-						       data[1])) {
-			PRINTM(MERROR, "Wrong channel switch parameters!\n");
-			ret = -EINVAL;
-			goto done;
-		}
-	}
-	woal_channel_switch(priv, data[0], data[1], data[2], data[3], data[4],
-			    MFALSE);
 done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               P2P extended channel switch
+ * @brief               Save cloud keep alive params in driver handle
  *
  * @param priv          Pointer to moal_private structure
- * @param respbuf       Pointer to response buffer
- * @param resplen       Response buffer length
+ * @params              Other params for keep alive
 
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_p2p_ecsa(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
+					   t_u8 mkeep_alive_id, t_u8 enable,
+					   t_u16 ether_type, t_u8 *ip_pkt,
+					   t_u16 ip_pkt_len, t_u8 *src_mac,
+					   t_u8 *dst_mac, t_u32 period_msec,
+					   t_u32 retry_interval, t_u8 retry_cnt)
+
 {
-	int ret = 0;
-	int user_data_len = 0, header_len = 0;
-	int data[2] = {0};
-	t_u8 bw = 0, oper_class = 0, channel = 0;
-	IEEEtypes_ExtChanSwitchAnn_t *ext_chan_switch = NULL;
-	custom_ie *pcust_chansw_ie = NULL;
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+	mlan_ds_misc_keep_alive *keep_alive = NULL;
+	moal_handle *phandle = NULL;
 
 	ENTER();
 
@@ -13583,19 +17992,7 @@ static int woal_priv_p2p_ecsa(moal_private *priv, t_u8 *respbuf,
 		ret = -EFAULT;
 		goto done;
 	}
-
-	if (priv->bss_role != MLAN_BSS_ROLE_UAP) {
-		PRINTM(MERROR,
-		       "Extended Channel Switch is only allowed for AP/GO mode\n");
-		ret = -EFAULT;
-		goto done;
-	}
-
-	if (priv->bss_started != MTRUE) {
-		PRINTM(MERROR, "AP is not started!\n");
-		ret = -EFAULT;
-		goto done;
-	}
+	phandle = priv->phandle;
 
 	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
@@ -13604,176 +18001,107 @@ static int woal_priv_p2p_ecsa(moal_private *priv, t_u8 *respbuf,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_CUSTOM_IE;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
-	ioctl_req->action = MLAN_ACT_SET;
-	misc->param.cust_ie.type = TLV_TYPE_MGMT_IE;
-	misc->param.cust_ie.len = (sizeof(custom_ie) - MAX_IE_SIZE);
-
-	pcust_chansw_ie = (custom_ie *)&misc->param.cust_ie.ie_data_list[0];
-	pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
-	pcust_chansw_ie->ie_length = sizeof(IEEEtypes_ExtChanSwitchAnn_t);
-	pcust_chansw_ie->mgmt_subtype_mask =
-		MGMT_MASK_BEACON | MGMT_MASK_PROBE_RESP; /*Add IE for
-							    BEACON/probe resp*/
-	ext_chan_switch =
-		(IEEEtypes_ExtChanSwitchAnn_t *)pcust_chansw_ie->ie_buffer;
 
-	header_len = strlen("P2P_ECSA");
-	parse_arguments(respbuf + header_len + 1, data, ARRAY_SIZE(data),
-			&user_data_len);
-
-	if (user_data_len != 2) {
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
 		PRINTM(MERROR, "Invalid parameters\n");
-		ret = -EFAULT;
-		goto done;
-	}
-
-	channel = data[0];
-	/* bandwidth 20:20M 40:40M 80:80M*/
-	bw = data[1];
-	if (bw != 20 && bw != 40 && bw != 80) {
-		PRINTM(MERROR, "Unsupported bandwidth\n");
-		ret = -EINVAL;
-		goto done;
-	}
-	if (channel >= 52 && channel <= 144) {
-		PRINTM(MERROR, "Switch to DFS channel is not allowed!\n");
 		ret = -EINVAL;
 		goto done;
 	}
 
-	woal_priv_get_nonglobal_operclass_by_bw_channel(priv, bw, channel,
-							&oper_class);
-	if (oper_class == 0) {
-		PRINTM(MERROR, "Wrong parameters!\n");
+	/* GET operation */
+	ioctl_req->action = MLAN_ACT_GET;
+	misc->param.keep_alive.mkeep_alive_id = mkeep_alive_id;
+	misc->param.keep_alive.enable = true;
+
+	ret = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
-	ext_chan_switch->element_id = EXTEND_CHANNEL_SWITCH_ANN;
-	ext_chan_switch->len = 4;
-	ext_chan_switch->chan_switch_mode = 1;
-	ext_chan_switch->new_oper_class = oper_class;
-	ext_chan_switch->new_channel_num = channel;
-	ext_chan_switch->chan_switch_count = DEF_CHAN_SWITCH_COUNT;
-
-	if (ext_chan_switch->chan_switch_mode) {
-		if (netif_carrier_ok(priv->netdev))
-			netif_carrier_off(priv->netdev);
-		woal_stop_queue(priv->netdev);
-		priv->uap_tx_blocked = MTRUE;
-	}
 
-	DBG_HEXDUMP(MCMD_D, "ECSA IE", (t_u8 *)pcust_chansw_ie->ie_buffer,
-		    pcust_chansw_ie->ie_length);
-
-	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
+	if (misc->param.keep_alive.enable) {
+		PRINTM(MERROR, "ID %d is in use\n", mkeep_alive_id);
+		ret = -EINVAL;
 		goto done;
 	}
 
-	priv->phandle->chsw_wait_q_woken = MFALSE;
-	/* wait for channel switch to complete  */
-	wait_event_interruptible_timeout(
-		priv->phandle->chsw_wait_q, priv->phandle->chsw_wait_q_woken,
-		(u32)HZ * (ext_chan_switch->chan_switch_count + 2) * 110 /
-			1000);
-
-	pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
-	pcust_chansw_ie->mgmt_subtype_mask = 0;
-	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "Failed to clear ECSA IE\n");
+	keep_alive = &phandle->keep_alive[mkeep_alive_id];
+	keep_alive->mkeep_alive_id = mkeep_alive_id;
+	keep_alive->enable = enable;
+	if (enable) {
+		keep_alive->cached = true;
+		keep_alive->send_interval = period_msec;
+		keep_alive->retry_interval = retry_interval;
+		keep_alive->retry_count = retry_cnt;
+		moal_memcpy_ext(phandle, keep_alive->dst_mac, dst_mac,
+				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		moal_memcpy_ext(phandle, keep_alive->src_mac, src_mac,
+				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+		keep_alive->pkt_len = MIN(ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
+		moal_memcpy_ext(phandle, keep_alive->packet, ip_pkt, ip_pkt_len,
+				MKEEP_ALIVE_IP_PKT_MAX);
+		if (ether_type)
+			keep_alive->ether_type = ether_type;
+		else
+			keep_alive->ether_type = 0;
 	}
+
 done:
-	if (status != MLAN_STATUS_PENDING)
+	if (ret != MLAN_STATUS_PENDING)
 		kfree(ioctl_req);
 
 	LEAVE();
 	return ret;
 }
-#endif
 
 /**
-* @brief               Set random mac configure value (ON/OFF)
-*
-* @param priv          Pointer to moal_private structure
-* @param respbuf       Pointer to response buffer
-* @param resplen       Response buffer length
+ * @brief               Cloud keep alive feature
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param respbuf       Pointer to response buffer
+ * @param resplen       Response buffer length
 
-*  @return             Number of bytes written, negative for failure.
-*/
-static int woal_priv_config_random_mac(moal_private *priv, t_u8 *respbuf,
-				       t_u32 respbuflen)
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_cloud_keep_alive(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	int ret = 0;
-	int header_len = 0, space_len = 0, i;
-	t_u8 rand_data[3];
-	const t_u8 zero_mac[MLAN_MAC_ADDR_LENGTH] = {0, 0, 0, 0, 0, 0};
-	char fakemac_sts[16];
+	cloud_keep_alive *keep_alive = NULL;
+	int header_len = 0;
 
 	ENTER();
 
-	if (!priv || !priv->phandle) {
-		PRINTM(MERROR, "priv or handle is null\n");
-		ret = -EFAULT;
-		goto done;
-	}
+	header_len = strlen(PRIV_CMD_CLOUD_KEEP_ALIVE);
 
-	header_len = strlen("FAKEMAC");
-	if (strlen(respbuf) >= header_len) {
-		for (i = 0; i < (strlen(respbuf) - header_len - 1); i++) {
-			if (respbuf[header_len + 1 + i] != ' ')
-				break;
-		}
-		space_len = i;
+	keep_alive = (cloud_keep_alive *)(respbuf + header_len);
 
-		if (strncmp(respbuf + header_len + 1 + space_len, "On",
-			    strlen("On")) == 0) {
-			if (memcmp(priv->random_mac, zero_mac,
-				   MLAN_MAC_ADDR_LENGTH)) {
-				ret = sprintf(respbuf,
-					      "FAKEMAC has been On\n") +
-				      1;
-				goto done;
-			}
-			moal_memcpy_ext(priv->phandle, priv->random_mac,
-					priv->current_addr, ETH_ALEN,
-					MLAN_MAC_ADDR_LENGTH);
-			get_random_bytes(rand_data, 3);
-			moal_memcpy_ext(priv->phandle, priv->random_mac + 3,
-					rand_data, 3, 3);
-		} else if (strncmp(respbuf + header_len + 1 + space_len, "Off",
-				   strlen("Off")) == 0) {
-			memset(priv->random_mac, 0, ETH_ALEN);
-		} else {
-			PRINTM(MERROR, "Invalid parameter!\n");
-			ret = -EINVAL;
-			goto done;
-		}
+	if (keep_alive->enable) {
+		ret = woal_priv_save_cloud_keep_alive_params(
+			priv, keep_alive->mkeep_alive_id, keep_alive->enable, 0,
+			keep_alive->pkt, keep_alive->pkt_len,
+			keep_alive->src_mac, keep_alive->dst_mac,
+			keep_alive->sendInterval, keep_alive->retryInterval,
+			keep_alive->retryCount);
 	} else {
-		PRINTM(MERROR, "Invalid parameter!\n");
-		ret = -EINVAL;
-		goto done;
+		if (0 != woal_stop_mkeep_alive(priv, keep_alive->mkeep_alive_id,
+					       keep_alive->reset,
+					       keep_alive->pkt,
+					       &keep_alive->pkt_len)) {
+			ret = -EFAULT;
+			return ret;
+		}
+		ret = respbuflen;
 	}
 
-	memset(fakemac_sts, 0, sizeof(fakemac_sts));
-	snprintf(fakemac_sts, sizeof(fakemac_sts), "%s",
-		 (respbuf + header_len + 1 + space_len));
-	ret = snprintf(respbuf, respbuflen, "FAKEMAC parameter is %s\n",
-		       fakemac_sts) +
-	      1;
-	PRINTM(MMSG, "FAKEMAC parameter is %s\n",
-	       (t_u8 *)(respbuf + header_len + 1 + space_len));
-
-done:
 	LEAVE();
 	return ret;
 }
 
 /**
- * @brief               Download start keep alive parameters
+ * @brief               Download start keep alive rx parameters
  *
  * @param priv          Pointer to moal_private structure
  * @param mkeep_alive_id       keep alive ID number
@@ -13781,14 +18109,12 @@ static int woal_priv_config_random_mac(moal_private *priv, t_u8 *respbuf,
  * @param ip_pke_len    IP packet length from host
  * @param src_mac       Source MAC address
  * @param dst_mac       Destination MAC address
- * @param period_msec   Send keep alive packet interval
 
  * @return      0: success  fail otherwise
  */
-int woal_start_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id,
-			   t_u8 *ip_pkt, t_u16 ip_pkt_len, t_u8 *src_mac,
-			   t_u8 *dst_mac, t_u32 period_msec,
-			   t_u32 retry_interval, t_u8 retry_cnt)
+int woal_start_mkeep_alive_rx(moal_private *priv, t_u8 mkeep_alive_id,
+			      t_u8 *ip_pkt, t_u16 ip_pkt_len, t_u8 *src_mac,
+			      t_u8 *dst_mac)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -13810,30 +18136,27 @@ int woal_start_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_RX_ID) {
 		PRINTM(MERROR, "Invalid parameters\n");
-		ret = -EFAULT;
-		goto done;
-	}
-
-	/* SET operation */
-	ioctl_req->action = MLAN_ACT_SET;
-	misc->param.keep_alive.mkeep_alive_id = mkeep_alive_id;
-	misc->param.keep_alive.enable = true;
-	misc->param.keep_alive.send_interval = period_msec;
-	misc->param.keep_alive.retry_interval = retry_interval;
-	misc->param.keep_alive.retry_count = retry_cnt;
-	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.dst_mac, dst_mac,
-			MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.src_mac, src_mac,
-			MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-	misc->param.keep_alive.pkt_len =
-		MIN(ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
-	moal_memcpy_ext(priv->phandle, misc->param.keep_alive.packet, ip_pkt,
-			ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
+		ret = -EFAULT;
+		goto done;
+	}
+
+	/* SET operation */
+	ioctl_req->action = MLAN_ACT_SET;
+	misc->param.keep_alive_rx.mkeep_alive_id = mkeep_alive_id;
+	misc->param.keep_alive_rx.enable = true;
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive_rx.dst_mac,
+			dst_mac, MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive_rx.src_mac,
+			src_mac, MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
+	misc->param.keep_alive_rx.pkt_len =
+		MIN(ip_pkt_len, MKEEP_ALIVE_ACK_PKT_MAX);
+	moal_memcpy_ext(priv->phandle, misc->param.keep_alive_rx.packet, ip_pkt,
+			ip_pkt_len, MKEEP_ALIVE_ACK_PKT_MAX);
 
 	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
@@ -13850,7 +18173,7 @@ int woal_start_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id,
 }
 
 /**
- * @brief               Download stop keep alive parameters
+ * @brief               Download stop keep alive rx parameters
  *
  * @param priv          Pointer to moal_private structure
  * @param mkeep_alive_id       keep alive ID number
@@ -13859,13 +18182,13 @@ int woal_start_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id,
 
  * @return      0: success  fail otherwise
  */
-int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
-			  t_u8 *ip_pkt, t_u8 *pkt_len)
+int woal_stop_mkeep_alive_rx(moal_private *priv, t_u8 mkeep_alive_id,
+			     t_u8 reset, t_u8 *ip_pkt, t_u8 *pkt_len)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
-	mlan_ds_misc_keep_alive *misc_keep_alive = NULL;
+	mlan_ds_misc_keep_alive_rx *misc_keep_alive_rx = NULL;
 	int ret = 0;
 
 	ENTER();
@@ -13883,11 +18206,11 @@ int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
-	misc_keep_alive = &misc->param.keep_alive;
+	misc_keep_alive_rx = &misc->param.keep_alive_rx;
 
-	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_RX_ID) {
 		PRINTM(MERROR, "Invalid parameters\n");
 		ret = -EFAULT;
 		goto done;
@@ -13895,8 +18218,8 @@ int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
 
 	/* GET operation */
 	ioctl_req->action = MLAN_ACT_GET;
-	misc_keep_alive->mkeep_alive_id = mkeep_alive_id;
-	misc_keep_alive->enable = false;
+	misc_keep_alive_rx->mkeep_alive_id = mkeep_alive_id;
+	misc_keep_alive_rx->enable = false;
 
 	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
@@ -13904,7 +18227,7 @@ int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
 		goto done;
 	}
 
-	if (!misc_keep_alive->enable) {
+	if (!misc_keep_alive_rx->enable) {
 		PRINTM(MERROR, "ID %d is already stop\n", mkeep_alive_id);
 		goto done;
 	}
@@ -13914,34 +18237,22 @@ int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
 	else
 		/* SET operation */
 		ioctl_req->action = MLAN_ACT_SET;
-	misc_keep_alive->mkeep_alive_id = mkeep_alive_id;
-	misc_keep_alive->enable = false;
+	misc_keep_alive_rx->mkeep_alive_id = mkeep_alive_id;
+	misc_keep_alive_rx->enable = false;
 
 	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
 		ret = -EFAULT;
 		goto done;
 	}
-
-#ifdef STA_CFG80211
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	if (IS_STA_CFG80211(priv->phandle->params.cfg80211_wext)) {
-		ret = woal_mkeep_alive_vendor_event(priv,
-						    &misc->param.keep_alive);
-		if (ret)
-			PRINTM(MERROR,
-			       "Keep alive vendor event upload failed\n");
-	}
-#endif
-#endif
 	if (pkt_len) {
-		*pkt_len = MIN(misc_keep_alive->pkt_len,
-			       (MKEEP_ALIVE_IP_PKT_MAX - 1));
-		PRINTM(MINFO, "keep alive stop pkt_len is %d\n", *pkt_len);
+		*pkt_len = MIN(misc_keep_alive_rx->pkt_len,
+			       (MKEEP_ALIVE_ACK_PKT_MAX - 1));
+		PRINTM(MINFO, "keep alive rx stop pkt_len is %d\n", *pkt_len);
 	}
 	if (*pkt_len && ip_pkt)
-		moal_memcpy_ext(priv->phandle, ip_pkt, misc_keep_alive->packet,
-				*pkt_len, *pkt_len);
+		moal_memcpy_ext(priv->phandle, ip_pkt,
+				misc_keep_alive_rx->packet, *pkt_len, *pkt_len);
 
 done:
 	if (status != MLAN_STATUS_PENDING)
@@ -13959,18 +18270,16 @@ int woal_stop_mkeep_alive(moal_private *priv, t_u8 mkeep_alive_id, t_u8 reset,
 
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
-					   t_u8 mkeep_alive_id, t_u8 enable,
-					   t_u16 ether_type, t_u8 *ip_pkt,
-					   t_u16 ip_pkt_len, t_u8 *src_mac,
-					   t_u8 *dst_mac, t_u32 period_msec,
-					   t_u32 retry_interval, t_u8 retry_cnt)
-
+int woal_priv_save_cloud_keep_alive_params_rx(moal_private *priv,
+					      t_u8 mkeep_alive_id, t_u8 enable,
+					      t_u16 ether_type, t_u8 *ip_pkt,
+					      t_u16 ip_pkt_len, t_u8 *src_mac,
+					      t_u8 *dst_mac)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	int ret = 0;
-	mlan_ds_misc_keep_alive *keep_alive = NULL;
+	mlan_ds_misc_keep_alive_rx *keep_alive_rx = NULL;
 	moal_handle *phandle = NULL;
 
 	ENTER();
@@ -13989,10 +18298,10 @@ int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
 	}
 
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE;
+	misc->sub_command = MLAN_OID_MISC_CLOUD_KEEP_ALIVE_RX;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
 
-	if (mkeep_alive_id >= MAX_KEEP_ALIVE_ID) {
+	if (mkeep_alive_id >= MAX_KEEP_ALIVE_RX_ID) {
 		PRINTM(MERROR, "Invalid parameters\n");
 		ret = -EINVAL;
 		goto done;
@@ -14000,8 +18309,8 @@ int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
 
 	/* GET operation */
 	ioctl_req->action = MLAN_ACT_GET;
-	misc->param.keep_alive.mkeep_alive_id = mkeep_alive_id;
-	misc->param.keep_alive.enable = true;
+	misc->param.keep_alive_rx.mkeep_alive_id = mkeep_alive_id;
+	misc->param.keep_alive_rx.enable = true;
 
 	ret = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (ret != MLAN_STATUS_SUCCESS) {
@@ -14009,31 +18318,29 @@ int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
 		goto done;
 	}
 
-	if (misc->param.keep_alive.enable) {
+	if (misc->param.keep_alive_rx.enable) {
 		PRINTM(MERROR, "ID %d is in use\n", mkeep_alive_id);
 		ret = -EINVAL;
 		goto done;
 	}
 
-	keep_alive = &phandle->keep_alive[mkeep_alive_id];
-	keep_alive->mkeep_alive_id = mkeep_alive_id;
-	keep_alive->enable = enable;
+	keep_alive_rx = &phandle->keep_alive_rx[mkeep_alive_id];
+	keep_alive_rx->mkeep_alive_id = mkeep_alive_id;
+	keep_alive_rx->enable = enable;
 	if (enable) {
-		keep_alive->cached = true;
-		keep_alive->send_interval = period_msec;
-		keep_alive->retry_interval = retry_interval;
-		keep_alive->retry_count = retry_cnt;
-		moal_memcpy_ext(phandle, keep_alive->dst_mac, dst_mac,
+		keep_alive_rx->cached = true;
+		moal_memcpy_ext(phandle, keep_alive_rx->dst_mac, dst_mac,
 				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-		moal_memcpy_ext(phandle, keep_alive->src_mac, src_mac,
+		moal_memcpy_ext(phandle, keep_alive_rx->src_mac, src_mac,
 				MLAN_MAC_ADDR_LENGTH, MLAN_MAC_ADDR_LENGTH);
-		keep_alive->pkt_len = MIN(ip_pkt_len, MKEEP_ALIVE_IP_PKT_MAX);
-		moal_memcpy_ext(phandle, keep_alive->packet, ip_pkt, ip_pkt_len,
-				MKEEP_ALIVE_IP_PKT_MAX);
+		keep_alive_rx->pkt_len =
+			MIN(ip_pkt_len, MKEEP_ALIVE_ACK_PKT_MAX);
+		moal_memcpy_ext(phandle, keep_alive_rx->packet, ip_pkt,
+				ip_pkt_len, MKEEP_ALIVE_ACK_PKT_MAX);
 		if (ether_type)
-			keep_alive->ether_type = ether_type;
+			keep_alive_rx->ether_type = ether_type;
 		else
-			keep_alive->ether_type = 0;
+			keep_alive_rx->ether_type = 0;
 	}
 
 done:
@@ -14045,7 +18352,7 @@ int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
 }
 
 /**
- * @brief               Cloud keep alive feature
+ * @brief               Cloud keep alive rx feature
  *
  * @param priv          Pointer to moal_private structure
  * @param respbuf       Pointer to response buffer
@@ -14053,31 +18360,30 @@ int woal_priv_save_cloud_keep_alive_params(moal_private *priv,
 
  *  @return             Number of bytes written, negative for failure.
  */
-static int woal_priv_cloud_keep_alive(moal_private *priv, t_u8 *respbuf,
-				      t_u32 respbuflen)
+static int woal_priv_cloud_keep_alive_rx(moal_private *priv, t_u8 *respbuf,
+					 t_u32 respbuflen)
 {
 	int ret = 0;
-	cloud_keep_alive *keep_alive = NULL;
+	cloud_keep_alive_rx *keep_alive_rx = NULL;
 	int header_len = 0;
 
 	ENTER();
 
-	header_len = strlen(PRIV_CMD_CLOUD_KEEP_ALIVE);
+	header_len = strlen(PRIV_CMD_CLOUD_KEEP_ALIVE_RX);
 
-	keep_alive = (cloud_keep_alive *)(respbuf + header_len);
+	keep_alive_rx = (cloud_keep_alive_rx *)(respbuf + header_len);
 
-	if (keep_alive->enable) {
-		ret = woal_priv_save_cloud_keep_alive_params(
-			priv, keep_alive->mkeep_alive_id, keep_alive->enable, 0,
-			keep_alive->pkt, keep_alive->pkt_len,
-			keep_alive->src_mac, keep_alive->dst_mac,
-			keep_alive->sendInterval, keep_alive->retryInterval,
-			keep_alive->retryCount);
+	if (keep_alive_rx->enable) {
+		ret = woal_priv_save_cloud_keep_alive_params_rx(
+			priv, keep_alive_rx->mkeep_alive_id,
+			keep_alive_rx->enable, 0, keep_alive_rx->pkt,
+			keep_alive_rx->pkt_len, keep_alive_rx->src_mac,
+			keep_alive_rx->dst_mac);
 	} else {
-		if (0 != woal_stop_mkeep_alive(priv, keep_alive->mkeep_alive_id,
-					       keep_alive->reset,
-					       keep_alive->pkt,
-					       &keep_alive->pkt_len)) {
+		if (0 != woal_stop_mkeep_alive_rx(
+				 priv, keep_alive_rx->mkeep_alive_id,
+				 keep_alive_rx->reset, keep_alive_rx->pkt,
+				 &keep_alive_rx->pkt_len)) {
 			ret = -EFAULT;
 			return ret;
 		}
@@ -14094,10 +18400,11 @@ static int woal_priv_cloud_keep_alive(moal_private *priv, t_u8 *respbuf,
  *  @param priv         A pointer to moal_private structure
  *  @param respbuf      A pointer to response buffer
  *  @param respbuflen   Available length of response buffer
- *
+
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_rx_abort_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_rx_abort_cfg(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -14127,7 +18434,7 @@ int woal_priv_rx_abort_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_RX_ABORT_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14170,6 +18477,90 @@ int woal_priv_rx_abort_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 	LEAVE();
 	return ret;
 }
+/**
+ *  @brief Set/Get static OFDM DESENSE CFG
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_ofdm_desense_cfg(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	int ret = 0;
+	int data[2] = {0};
+	int header_len = 0, user_data_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!respbuf) {
+		PRINTM(MERROR, "response buffer is not available!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_OFDM_DESENSE_CFG);
+	user_data_len = strlen(respbuf) - header_len;
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_OFDM_DESENSE_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len > 2 ||
+		    (data[0] == MTRUE && user_data_len != 2)) {
+			PRINTM(MERROR, "Invalid number of args!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (data[0] == MTRUE && data[1] > 0x7f) {
+			PRINTM(MERROR, "Invalid threshold value\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		misc->param.ofdm_desense_cfg.enable = (t_u8)data[0];
+		if (user_data_len == 2)
+			misc->param.ofdm_desense_cfg.cca_threshold =
+				(t_s8)data[1];
+		req->action = MLAN_ACT_SET;
+	}
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	data[0] = misc->param.ofdm_desense_cfg.enable;
+	data[1] = misc->param.ofdm_desense_cfg.cca_threshold;
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data, sizeof(data),
+			respbuflen);
+	ret = sizeof(data);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
 
 /**
  *  @brief Set/Get dynamic rx abort config
@@ -14180,13 +18571,13 @@ int woal_priv_rx_abort_cfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
-			       t_u32 respbuflen)
+static int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
+				      t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	int ret = 0;
-	int data[3] = {0};
+	int data[7] = {0};
 	int header_len = 0, user_data_len = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
@@ -14211,7 +18602,7 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_RX_ABORT_CFG_EXT;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14219,8 +18610,9 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
 		/* SET operation */
 		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
 				&user_data_len);
-		if (user_data_len > 3 ||
-		    (data[0] == MTRUE && user_data_len != 3)) {
+		if (user_data_len > 4 ||
+		    ((data[0] == MTRUE && user_data_len != 3) &&
+		     (data[0] == MTRUE && user_data_len != 4))) {
 			PRINTM(MERROR, "Invalid number of args!\n");
 			ret = -EINVAL;
 			goto done;
@@ -14231,12 +18623,18 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
 				ret = -EINVAL;
 				goto done;
 			}
-			if (data[2] > 0x7f) {
+			if (data[2] > 0x7f && data[2] != 0xff) {
 				PRINTM(MERROR,
 				       "Invalid ceil threshold value\n");
 				ret = -EINVAL;
 				goto done;
 			}
+			if (data[3] > 0x7f) {
+				PRINTM(MERROR,
+				       "Invalid floor threshold value\n");
+				ret = -EINVAL;
+				goto done;
+			}
 		}
 		misc->param.rx_abort_cfg_ext.enable = (t_u8)data[0];
 		if (user_data_len > 1) {
@@ -14244,6 +18642,19 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
 				(t_s8)data[1];
 			misc->param.rx_abort_cfg_ext.ceil_rssi_threshold =
 				(t_s8)data[2];
+			/** not to update floor_rssi_threshold if not included
+			 * in coammnd */
+			if (user_data_len == 3)
+				misc->param.rx_abort_cfg_ext
+					.floor_rssi_threshold = 0xff;
+			else
+				misc->param.rx_abort_cfg_ext
+					.floor_rssi_threshold = (t_s8)data[3];
+
+			misc->param.rx_abort_cfg_ext
+				.current_dynamic_rssi_threshold = 0;
+			misc->param.rx_abort_cfg_ext.rssi_default_config = 0;
+			misc->param.rx_abort_cfg_ext.edmac_enable = 0;
 		}
 		req->action = MLAN_ACT_SET;
 	}
@@ -14257,6 +18668,11 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
 	data[0] = misc->param.rx_abort_cfg_ext.enable;
 	data[1] = misc->param.rx_abort_cfg_ext.rssi_margin;
 	data[2] = misc->param.rx_abort_cfg_ext.ceil_rssi_threshold;
+	data[3] = misc->param.rx_abort_cfg_ext.floor_rssi_threshold;
+	data[4] = misc->param.rx_abort_cfg_ext.current_dynamic_rssi_threshold;
+	data[5] = misc->param.rx_abort_cfg_ext.rssi_default_config;
+	data[6] = misc->param.rx_abort_cfg_ext.edmac_enable;
+
 	moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data, sizeof(data),
 			respbuflen);
 	ret = sizeof(data);
@@ -14277,8 +18693,8 @@ int woal_priv_rx_abort_cfg_ext(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_dot11mc_unassoc_ftm_cfg(moal_private *priv, t_u8 *respbuf,
-				      t_u32 respbuflen)
+static int woal_priv_dot11mc_unassoc_ftm_cfg(moal_private *priv, t_u8 *respbuf,
+					     t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -14308,7 +18724,7 @@ int woal_priv_dot11mc_unassoc_ftm_cfg(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_DOT11MC_UNASSOC_FTM_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14357,8 +18773,8 @@ int woal_priv_dot11mc_unassoc_ftm_cfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_tx_ampdu_prot_mode(moal_private *priv, t_u8 *respbuf,
-				 t_u32 respbuflen)
+static int woal_priv_tx_ampdu_prot_mode(moal_private *priv, t_u8 *respbuf,
+					t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -14388,7 +18804,7 @@ int woal_priv_tx_ampdu_prot_mode(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_TX_AMPDU_PROT_MODE;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14437,8 +18853,8 @@ int woal_priv_tx_ampdu_prot_mode(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_rate_adapt_cfg(moal_private *priv, t_u8 *respbuf,
-			     t_u32 respbuflen)
+static int woal_priv_rate_adapt_cfg(moal_private *priv, t_u8 *respbuf,
+				    t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -14468,7 +18884,7 @@ int woal_priv_rate_adapt_cfg(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_RATE_ADAPT_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14543,8 +18959,8 @@ int woal_priv_rate_adapt_cfg(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_cck_desense_cfg(moal_private *priv, t_u8 *respbuf,
-			      t_u32 respbuflen)
+static int woal_priv_cck_desense_cfg(moal_private *priv, t_u8 *respbuf,
+				     t_u32 respbuflen)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -14574,7 +18990,7 @@ int woal_priv_cck_desense_cfg(moal_private *priv, t_u8 *respbuf,
 	misc = (mlan_ds_misc_cfg *)req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_CCK_DESENSE_CFG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if ((int)strlen(respbuf) == header_len) {
 		/* GET operation */
 		user_data_len = 0;
 		req->action = MLAN_ACT_GET;
@@ -14695,7 +19111,7 @@ static int woal_priv_set_get_lpm(moal_private *priv, t_u8 *respbuf,
 	if (IS_CARD9098(priv->phandle->card_type) ||
 	    IS_CARD9097(priv->phandle->card_type)) {
 		header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_LPM);
-		if (strlen(respbuf) == header_len) {
+		if ((int)strlen(respbuf) == header_len) {
 			/* GET operation */
 			user_data_len = 0;
 		} else {
@@ -14747,7 +19163,191 @@ static int woal_priv_set_get_lpm(moal_private *priv, t_u8 *respbuf,
 }
 
 /**
- *  @brief Set/Get HW ARB config
+ *  @brief Set/Get HW ARB config
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param respbuf      A pointer to response buffer
+ *  @param respbuflen   Available length of response buffer
+ *
+ *  @return             Number of bytes written, negative for failure.
+ */
+static int woal_priv_arbcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	int ret = 0;
+	int data[1];
+	int header_len = 0, user_data_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!respbuf) {
+		PRINTM(MERROR, "response buffer is not available!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ARB_CFG);
+	user_data_len = strlen(respbuf) - header_len;
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	/* Fill request buffer */
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_ARB_CONFIG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	if ((int)strlen(respbuf) == header_len) {
+		/* GET operation */
+		user_data_len = 0;
+		req->action = MLAN_ACT_GET;
+	} else {
+		/* SET operation */
+		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+				&user_data_len);
+		if (user_data_len != 1) {
+			PRINTM(MERROR, "Invalid Parameter\n");
+			ret = -EFAULT;
+			goto done;
+		}
+		if (data[0] < 0 || data[0] > 4) {
+			PRINTM(MERROR, "Invalid Parameter: arb mode 0-4\n");
+			ret = -EFAULT;
+			goto done;
+		}
+		misc->param.arb_cfg.arb_mode = (t_u32)data[0];
+		req->action = MLAN_ACT_SET;
+	}
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	data[0] = misc->param.arb_cfg.arb_mode;
+	moal_memcpy_ext(priv->phandle, respbuf, (t_u32 *)data, sizeof(data),
+			respbuflen);
+	ret = sizeof(data);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief      Timer function for TP state command.
+ *
+ *  @param data pointer to a buffer
+ *
+ *  @return     N/A
+ */
+void woal_tp_acnt_timer_func(void *context)
+{
+	moal_handle *phandle = (moal_handle *)context;
+	int i = 0;
+
+	if (phandle == NULL)
+		return;
+	PRINTM(MDATA, "####### CPU%d: tp acnt timer\n", smp_processor_id());
+	/* Tx TP accounting */
+	for (i = 0; i < MAX_TP_ACCOUNT_DROP_POINT_NUM; i++) {
+		phandle->tp_acnt.tx_bytes_rate[i] =
+			phandle->tp_acnt.tx_bytes[i] -
+			phandle->tp_acnt.tx_bytes_last[i];
+		phandle->tp_acnt.tx_bytes_last[i] =
+			phandle->tp_acnt.tx_bytes[i];
+		phandle->tp_acnt.tx_packets_rate[i] =
+			phandle->tp_acnt.tx_packets[i] -
+			phandle->tp_acnt.tx_packets_last[i];
+		phandle->tp_acnt.tx_packets_last[i] =
+			phandle->tp_acnt.tx_packets[i];
+	}
+	phandle->tp_acnt.tx_pending = atomic_read(&phandle->tx_pending);
+	/* Tx Interrupt accounting */
+	phandle->tp_acnt.tx_intr_rate =
+		phandle->tp_acnt.tx_intr_cnt - phandle->tp_acnt.tx_intr_last;
+	phandle->tp_acnt.tx_intr_last = phandle->tp_acnt.tx_intr_cnt;
+
+	/* Rx TP accounting */
+	for (i = 0; i < MAX_TP_ACCOUNT_DROP_POINT_NUM; i++) {
+		phandle->tp_acnt.rx_bytes_rate[i] =
+			phandle->tp_acnt.rx_bytes[i] -
+			phandle->tp_acnt.rx_bytes_last[i];
+		phandle->tp_acnt.rx_bytes_last[i] =
+			phandle->tp_acnt.rx_bytes[i];
+		phandle->tp_acnt.rx_packets_rate[i] =
+			phandle->tp_acnt.rx_packets[i] -
+			phandle->tp_acnt.rx_packets_last[i];
+		phandle->tp_acnt.rx_packets_last[i] =
+			phandle->tp_acnt.rx_packets[i];
+	}
+	phandle->tp_acnt.rx_pending = atomic_read(&phandle->rx_pending);
+	// Interrupt accounting, RX
+	phandle->tp_acnt.rx_intr_rate =
+		phandle->tp_acnt.rx_intr_cnt - phandle->tp_acnt.rx_intr_last;
+	phandle->tp_acnt.rx_intr_last = phandle->tp_acnt.rx_intr_cnt;
+	phandle->tp_acnt.rx_amsdu_cnt_rate = phandle->tp_acnt.rx_amsdu_cnt -
+					     phandle->tp_acnt.rx_amsdu_cnt_last;
+	phandle->tp_acnt.rx_amsdu_cnt_last = phandle->tp_acnt.rx_amsdu_cnt;
+
+	phandle->tp_acnt.rx_amsdu_pkt_cnt_rate =
+		phandle->tp_acnt.rx_amsdu_pkt_cnt -
+		phandle->tp_acnt.rx_amsdu_pkt_cnt_last;
+	phandle->tp_acnt.rx_amsdu_pkt_cnt_last =
+		phandle->tp_acnt.rx_amsdu_pkt_cnt;
+
+	phandle->tp_acnt.tx_amsdu_cnt_rate = phandle->tp_acnt.tx_amsdu_cnt -
+					     phandle->tp_acnt.tx_amsdu_cnt_last;
+	phandle->tp_acnt.tx_amsdu_cnt_last = phandle->tp_acnt.tx_amsdu_cnt;
+
+	phandle->tp_acnt.tx_amsdu_pkt_cnt_rate =
+		phandle->tp_acnt.tx_amsdu_pkt_cnt -
+		phandle->tp_acnt.tx_amsdu_pkt_cnt_last;
+	phandle->tp_acnt.tx_amsdu_pkt_cnt_last =
+		phandle->tp_acnt.tx_amsdu_pkt_cnt;
+
+	/* re-arm timer */
+	woal_mod_timer(&phandle->tp_acnt.timer, 1000);
+}
+
+/**
+ *  @brief      set tp state to mlan
+ *
+ *  @param priv  pointer to moal_private
+ *
+ *  @return     N/A
+ */
+void woal_set_tp_state(moal_private *priv)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	moal_handle *handle = priv->phandle;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL)
+		return;
+	/* Fill request buffer */
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TP_STATE;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc->param.tp_state.on = handle->tp_acnt.on;
+	misc->param.tp_state.drop_point = handle->tp_acnt.drop_point;
+	req->action = MLAN_ACT_SET;
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	return;
+}
+
+/**
+ *  @brief Set/Get TP statistics.
  *
  *  @param priv         A pointer to moal_private structure
  *  @param respbuf      A pointer to response buffer
@@ -14755,14 +19355,13 @@ static int woal_priv_set_get_lpm(moal_private *priv, t_u8 *respbuf,
  *
  *  @return             Number of bytes written, negative for failure.
  */
-int woal_priv_arbcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
+static int woal_priv_set_tp_state(moal_private *priv, t_u8 *respbuf,
+				  t_u32 respbuflen)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_misc_cfg *misc = NULL;
+	moal_handle *handle = priv->phandle;
 	int ret = 0;
-	int data[1];
+	int data[2];
 	int header_len = 0, user_data_len = 0;
-	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
@@ -14771,58 +19370,128 @@ int woal_priv_arbcfg(moal_private *priv, t_u8 *respbuf, t_u32 respbuflen)
 		ret = -EINVAL;
 		goto done;
 	}
-	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_ARB_CFG);
+	header_len = strlen(CMD_NXP) + strlen(PRIV_CMD_TP_STATE);
 	user_data_len = strlen(respbuf) - header_len;
-
-	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
-	if (req == NULL) {
-		ret = -ENOMEM;
+	parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
+			&user_data_len);
+	if (user_data_len > 2) {
+		PRINTM(MERROR, "Invalid number of args!\n");
+		ret = -EINVAL;
 		goto done;
 	}
-	/* Fill request buffer */
-	misc = (mlan_ds_misc_cfg *)req->pbuf;
-	misc->sub_command = MLAN_OID_MISC_ARB_CONFIG;
-	req->req_id = MLAN_IOCTL_MISC_CFG;
-	if (strlen(respbuf) == header_len) {
+	if (user_data_len) {
+		handle->tp_acnt.on = data[0];
+		/* Enable TP statistics collection */
+		if (data[0] == 1) {
+			handle->tp_acnt.drop_point = data[1];
+			if (handle->is_tp_acnt_timer_set == MFALSE) {
+				woal_initialize_timer(&handle->tp_acnt.timer,
+						      woal_tp_acnt_timer_func,
+						      handle);
+				handle->is_tp_acnt_timer_set = MTRUE;
+				woal_mod_timer(&handle->tp_acnt.timer, 1000);
+			}
+		} else {
+			if (handle->is_tp_acnt_timer_set) {
+				woal_cancel_timer(&handle->tp_acnt.timer);
+				handle->is_tp_acnt_timer_set = MFALSE;
+			}
+			memset((void *)&handle->tp_acnt, 0,
+			       sizeof(moal_tp_acnt_t));
+		}
+		woal_set_tp_state(priv);
+	}
+	/* Get command results */
+	if (user_data_len == 0) {
+		moal_memcpy_ext(handle, respbuf, (t_u8 *)(&handle->tp_acnt),
+				sizeof(handle->tp_acnt), respbuflen);
+		ret = sizeof(handle->tp_acnt);
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+static int woal_priv_ips_cfg(moal_private *priv, t_u8 *respbuf,
+			     t_u32 respbuflen)
+{
+	moal_handle *handle = priv->phandle;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	t_u32 data[1];
+	int ret = 0;
+	int user_data_len = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+	if (strlen(respbuf) == (strlen(CMD_NXP) + strlen(PRIV_CMD_IPS_CFG))) {
 		/* GET operation */
 		user_data_len = 0;
-		req->action = MLAN_ACT_GET;
 	} else {
 		/* SET operation */
-		parse_arguments(respbuf + header_len, data, ARRAY_SIZE(data),
-				&user_data_len);
-		if (user_data_len != 1) {
-			PRINTM(MERROR, "Invalid Parameter\n");
-			ret = -EFAULT;
+		memset((char *)data, 0, sizeof(data));
+		parse_arguments(respbuf + strlen(CMD_NXP) +
+					strlen(PRIV_CMD_IPS_CFG),
+				data, ARRAY_SIZE(data), &user_data_len);
+	}
+	if (user_data_len) {
+		/* Allocate an IOCTL request buffer */
+		req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+		if (req == NULL) {
+			ret = -ENOMEM;
 			goto done;
 		}
-		if (data[0] < 0 || data[0] > 4) {
-			PRINTM(MERROR, "Invalid Parameter: arb mode 0-4\n");
+		/* Fill request buffer */
+		misc = (mlan_ds_misc_cfg *)req->pbuf;
+		misc->sub_command = MLAN_OID_MISC_IPS_CFG;
+		req->req_id = MLAN_IOCTL_MISC_CFG;
+		misc->param.ips_ctrl = data[0];
+		req->action = MLAN_ACT_SET;
+		/* Send IOCTL request to MLAN */
+		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+		if (status != MLAN_STATUS_SUCCESS) {
 			ret = -EFAULT;
 			goto done;
 		}
-		misc->param.arb_cfg.arb_mode = (t_u32)data[0];
-		req->action = MLAN_ACT_SET;
-	}
-	/* Send IOCTL request to MLAN */
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
+		handle->ips_ctrl = data[0];
+	} else {
+		data[0] = handle->ips_ctrl;
+		moal_memcpy_ext(priv->phandle, respbuf, (t_u8 *)data,
+				sizeof(data), respbuflen);
 	}
-
-	data[0] = misc->param.arb_cfg.arb_mode;
-	moal_memcpy_ext(priv->phandle, respbuf, (t_u32 *)data, sizeof(data),
-			respbuflen);
 	ret = sizeof(data);
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+static int woal_priv_get_uuid(moal_private *priv, t_u8 *respbuf,
+			      t_u32 respbuflen)
+{
+	int ret = -1;
+	mlan_fw_info fw_info;
+
+	ENTER();
+
+	if (!respbuf) {
+		PRINTM(MERROR, "response buffer is not available!\n");
+		ret = -1;
+	} else {
+		fw_info.uuid_lo = fw_info.uuid_hi = 0x0ULL;
+
+		woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
+		snprintf(respbuf, MLAN_MAX_UUID_LEN + 1, "%016llx%016llx",
+			 fw_info.uuid_lo, fw_info.uuid_hi);
+		ret = strlen(respbuf);
+	}
 
 	LEAVE();
 	return ret;
 }
+
 /**
  *  @brief Set priv command for Android
  *  @param dev          A pointer to net_device structure
@@ -14850,7 +19519,9 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 	int len = 0;
 	gfp_t flag;
 	char *cmd_buf = NULL;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	int cfg80211_wext;
+#endif
 
 	ENTER();
 	if (!priv || !priv->phandle) {
@@ -14858,13 +19529,14 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		ret = -EFAULT;
 		goto done;
 	}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	cfg80211_wext = priv->phandle->params.cfg80211_wext;
+#endif
 	if (copy_from_user(&priv_cmd, req->ifr_data,
 			   sizeof(android_wifi_priv_cmd))) {
 		ret = -EFAULT;
 		goto done;
 	}
-#define CMD_BUF_LEN 3072
 	if (priv_cmd.used_len < 0 || priv_cmd.total_len <= 0 ||
 	    priv_cmd.used_len > priv_cmd.total_len) {
 		PRINTM(MERROR,
@@ -14889,7 +19561,8 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 #else
 	cmd_buf = priv_cmd.buf;
 #endif
-	if (copy_from_user(buf, cmd_buf, priv_cmd.total_len)) {
+	if (copy_from_user(buf, (const void __user *)cmd_buf,
+			   priv_cmd.total_len)) {
 		ret = -EFAULT;
 		goto done;
 	}
@@ -15059,6 +19732,16 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 						   priv_cmd.total_len);
 			goto handled;
 #endif
+#if defined(UAP_SUPPORT)
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_SETMODE,
+				    strlen(PRIV_CMD_SETMODE)) == 0) {
+			/* Set multi_ap mode */
+			len = woal_uap_set_multiap_mode(priv, buf,
+							priv_cmd.total_len);
+			goto handled;
+#endif
+#endif
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_BSSROLE,
@@ -15158,6 +19841,12 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 						   priv_cmd.total_len, 0);
 			goto handled;
 #endif
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_AUTOASSOC,
+				    strlen(PRIV_CMD_AUTOASSOC)) == 0) {
+			/* Auto assoc */
+			len = woal_priv_setgetautoassoc(priv, buf,
+							priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_WAKEUPREASON,
 				    strlen(PRIV_CMD_WAKEUPREASON)) == 0) {
@@ -15299,6 +19988,14 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_rx_abort_cfg(priv, buf,
 						     priv_cmd.total_len);
 			goto handled;
+
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_OFDM_DESENSE_CFG,
+				    strlen(PRIV_CMD_OFDM_DESENSE_CFG)) == 0) {
+			/* OFDM DESENSE config */
+			len = woal_priv_ofdm_desense_cfg(priv, buf,
+							 priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_TX_AMPDU_PROT_MODE,
 				    strlen(PRIV_CMD_TX_AMPDU_PROT_MODE)) == 0) {
@@ -15418,6 +20115,32 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_ssu_cmd(priv, len, pdata,
 						priv_cmd.total_len);
 			goto handled;
+#endif
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_HAL_PHY_CFG,
+				    strlen(PRIV_CMD_HAL_PHY_CFG)) == 0) {
+			/* Set hal_phy config */
+			pdata = buf + strlen(CMD_NXP) +
+				strlen(PRIV_CMD_HAL_PHY_CFG);
+			len = priv_cmd.total_len -
+			      strlen(PRIV_CMD_HAL_PHY_CFG) - strlen(CMD_NXP);
+			len = woal_priv_hal_phy_cfg_cmd(priv, pdata, len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_CSI,
+				    strlen(PRIV_CMD_CSI)) == 0) {
+			/* Set CSI config */
+			pdata = buf + strlen(CMD_NXP) + strlen(PRIV_CMD_CSI);
+			len = priv_cmd.total_len - strlen(PRIV_CMD_CSI) -
+			      strlen(CMD_NXP);
+			priv->csi_seq = 0;
+			len = woal_priv_csi_cmd(priv, pdata, len);
+			goto handled;
+#ifdef STA_SUPPORT
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_ARPFILTER,
+				    strlen(PRIV_CMD_ARPFILTER)) == 0) {
+			/* ARPFilter Configuration */
+			len = woal_priv_arpfilter(priv, buf,
+						  priv_cmd.total_len);
+			goto handled;
 #endif
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_AUTO_ARP,
 				    strlen(PRIV_CMD_AUTO_ARP)) == 0) {
@@ -15431,14 +20154,6 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_hotspotcfg(priv, buf,
 						   priv_cmd.total_len);
 			goto handled;
-#ifdef RX_PACKET_COALESCE
-		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_RX_COAL_CFG,
-				    strlen(PRIV_CMD_RX_COAL_CFG)) == 0) {
-			/* RX packet coalescing Configuration */
-			len = woal_priv_rx_pkt_coalesce_cfg(priv, buf,
-							    priv_cmd.total_len);
-			goto handled;
-#endif
 
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_MGMT_FRAME_CTRL,
@@ -15513,6 +20228,26 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_region_code(priv, buf,
 						    priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_DRCS_CFG,
+				    strlen(PRIV_CMD_DRCS_CFG)) == 0) {
+			/* DRCS configuration for mc_cfg_ext*/
+			len = woal_priv_drcs_time_slicing_cfg(
+				priv, buf, priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_MULTI_CHAN_CFG,
+				    strlen(PRIV_CMD_MULTI_CHAN_CFG)) == 0) {
+			/* Channel time and buffer weight configuration */
+			len = woal_priv_multi_chan_config(priv, buf,
+							  priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_MULTI_CHAN_POLICY,
+				    strlen(PRIV_CMD_MULTI_CHAN_POLICY)) == 0) {
+			/* Multi-channel Policy enable/disable */
+			len = woal_priv_multi_chan_policy(priv, buf,
+							  priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_FWMACADDR,
 				    strlen(PRIV_CMD_FWMACADDR)) == 0) {
 			/* Set FW MAC address */
@@ -15528,8 +20263,8 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				len = woal_priv_offchannel(priv, buf,
 							   priv_cmd.total_len);
 			} else
-				len = sprintf(buf,
-					      "CFG80211 is not enabled\n") +
+				len = snprintf(buf, CMD_BUF_LEN,
+					       "CFG80211 is not enabled\n") +
 				      1;
 			goto handled;
 #endif
@@ -15708,6 +20443,43 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_11n_amsdu_aggr_ctrl(priv, buf,
 							    priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_MCAST_AGGR_GROUP,
+				    strlen(PRIV_CMD_MCAST_AGGR_GROUP)) == 0) {
+			/* mcast_aggr_group cfg*/
+			len = woal_priv_mcast_aggr_group_cfg(
+				priv, buf, priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_MC_AGGR_CFG,
+				    strlen(PRIV_CMD_MC_AGGR_CFG)) == 0) {
+			/* mc_aggr_cfg*/
+			len = woal_priv_mc_aggr_cfg(priv, buf,
+						    priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_STATS,
+				    strlen(PRIV_CMD_STATS)) == 0) {
+			/* stats */
+			len = woal_priv_stats(priv, buf, priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_CH_LOAD,
+				    strlen(PRIV_CMD_CH_LOAD)) == 0) {
+			/* mc_aggr_cfg*/
+			len = woal_priv_get_ch_load(priv, buf,
+						    priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_CROSS_CHIP_SYNCH,
+				    strlen(PRIV_CMD_CROSS_CHIP_SYNCH)) == 0) {
+			len = woal_priv_cross_chip_synch(priv, buf,
+							 priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_CH_LOAD_RESULTS,
+				    strlen(PRIV_CMD_CH_LOAD_RESULTS)) == 0) {
+			/* mc_aggr_cfg*/
+			len = woal_priv_get_ch_load_results(priv, buf,
+							    priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_TX_BF_CAP,
 				    strlen(PRIV_CMD_TX_BF_CAP)) == 0) {
 			/* Set/Get Transmit beamforming capabilities */
@@ -15721,17 +20493,60 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_sleep_params_ioctl(priv, buf,
 							   priv_cmd.total_len);
 			goto handled;
+#ifdef UAP_SUPPORT
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_NET_MON,
+				    strlen(PRIV_CMD_NET_MON)) == 0) {
+			/* Set/Get network monitor configurations */
+			len = woal_priv_net_monitor_ioctl(priv, buf,
+							  priv_cmd.total_len);
+			goto handled;
+#endif
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_DFS_TESTING,
 				    strlen(PRIV_CMD_DFS_TESTING)) == 0) {
 			/* Set/Get DFS Testing settings */
 			len = woal_priv_dfs_testing(priv, buf,
 						    priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_CLEAR_NOP,
+				    strlen(PRIV_CMD_CLEAR_NOP)) == 0) {
+			/* Set/Get DFS Testing settings */
+			len = woal_priv_clear_nop(priv, buf,
+						  priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_NOP_LIST,
+				    strlen(PRIV_CMD_NOP_LIST)) == 0) {
+			/* Set/Get DFS Testing settings */
+			len = woal_priv_nop_list(priv, buf, priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_FAKE_RADAR,
+				    strlen(PRIV_CMD_FAKE_RADAR)) == 0) {
+			/* mcast_aggr_group cfg*/
+			len = woal_priv_fake_radar(priv, buf,
+						   priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_DFS53_CFG,
 				    strlen(PRIV_CMD_DFS53_CFG)) == 0) {
 			/* Set/Get DFS W53 settings */
 			len = woal_priv_dfs53cfg(priv, buf, priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_DFS_MODE,
+				    strlen(PRIV_CMD_DFS_MODE)) == 0) {
+			/* Set/Get DFS mode settings */
+			len = woal_priv_dfs_mode(priv, buf, priv_cmd.total_len);
+			goto handled;
+#ifdef UAP_SUPPORT
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_DFS_CAC,
+				    strlen(PRIV_CMD_DFS_CAC)) == 0) {
+			/* perform CAC */
+			len = woal_priv_do_dfs_cac(priv, buf,
+						   priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_AUTODFS,
+				    strlen(PRIV_CMD_AUTODFS)) == 0) {
+			len = woal_priv_auto_dfs_cfg(priv, buf,
+						     priv_cmd.total_len);
+			goto handled;
+#endif
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_ARB_CFG,
 				    strlen(PRIV_CMD_ARB_CFG)) == 0) {
 			/* Set/Get CFP table codes */
@@ -15788,6 +20603,11 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_port_ctrl(priv, buf,
 						  priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_TXWATCHDOG,
+				    strlen(PRIV_CMD_TXWATCHDOG)) == 0) {
+			len = woal_priv_txwatchdog(priv, buf,
+						   priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_PB_BYPASS,
 				    strlen(PRIV_CMD_PB_BYPASS)) == 0) {
 			/* Private IOCTL entry to get the By-passed TX packet
@@ -15809,6 +20629,36 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 						   priv_cmd.total_len);
 			goto handled;
 #endif
+#endif
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_CFG_CLOCK_SYNC,
+				    strlen(PRIV_CMD_CFG_CLOCK_SYNC)) == 0) {
+			/* Set/Get P2P NoA (Notice of Absence) parameters */
+			len = woal_priv_cfg_clock_sync(priv, buf,
+						       priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_CFG_GET_TSF_INFO,
+				    strlen(PRIV_CMD_CFG_GET_TSF_INFO)) == 0) {
+			/* Get TSF info */
+			len = woal_priv_cfg_get_tsf_info(priv, buf,
+							 priv_cmd.total_len);
+			goto handled;
+#ifdef UAP_SUPPORT
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_TARGET_CHANNEL,
+				    strlen(PRIV_CMD_TARGET_CHANNEL)) == 0) {
+			/* Get/Set Target channel*/
+			len = woal_priv_target_channel(priv, buf,
+						       priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_BACKUP_CHANNEL,
+				    strlen(PRIV_CMD_BACKUP_CHANNEL)) == 0) {
+			/* Get/Set Backup channel*/
+			len = woal_priv_backup_channel(priv, buf,
+						       priv_cmd.total_len);
+			goto handled;
 #endif
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_DFS_REPEATER_CFG,
@@ -15835,6 +20685,19 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_coex_rx_winsize(priv, buf,
 							priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_TX_AGGR_CTRL,
+				    strlen(PRIV_CMD_TX_AGGR_CTRL)) == 0) {
+			/* Set/Get control to TX AMPDU on infra link */
+			len = woal_priv_txaggrctrl(priv, buf,
+						   priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_AUTO_TDLS,
+				    strlen(PRIV_CMD_AUTO_TDLS)) == 0) {
+			/* Set/Get control to enable/disable auto TDLS */
+			len = woal_priv_auto_tdls(priv, buf,
+						  priv_cmd.total_len);
+			goto handled;
 #ifdef PCIE
 		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_PCIE_REG_RW,
 				    strlen(PRIV_CMD_PCIE_REG_RW)) == 0) {
@@ -15850,6 +20713,13 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 							 priv_cmd.total_len);
 			goto handled;
 #endif
+		} else if (strnicmp(buf + strlen(CMD_NXP),
+				    PRIV_CMD_TDLS_IDLE_TIME,
+				    strlen(PRIV_CMD_TDLS_IDLE_TIME)) == 0) {
+			/* Set/Get TDLS idle timeout value */
+			len = woal_priv_tdls_idle_time(priv, buf,
+						       priv_cmd.total_len);
+			goto handled;
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_GET_SENSOR_TEMP,
 				    strlen(PRIV_CMD_GET_SENSOR_TEMP)) == 0) {
@@ -15866,8 +20736,8 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				len = woal_priv_dfs_offload_enable(
 					priv, buf, priv_cmd.total_len);
 			else
-				len = sprintf(buf,
-					      "CFG80211 is not enabled\n") +
+				len = snprintf(buf, CMD_BUF_LEN,
+					       "CFG80211 is not enabled\n") +
 				      1;
 			goto handled;
 #endif
@@ -15936,6 +20806,17 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 						     priv_cmd.total_len);
 			len += strlen(PRIV_CMD_TWT_TEARDOWN) + strlen(CMD_NXP);
 			goto handled;
+
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_TWT_REPORT,
+				    strlen(PRIV_CMD_TWT_REPORT)) == 0) {
+			pdata = buf + strlen(CMD_NXP) +
+				strlen(PRIV_CMD_TWT_REPORT);
+			len = priv_cmd.used_len - strlen(PRIV_CMD_TWT_REPORT) -
+			      strlen(CMD_NXP);
+			len = woal_priv_twt_report(priv, pdata, len,
+						   priv_cmd.total_len);
+			len += strlen(PRIV_CMD_TWT_REPORT) + strlen(CMD_NXP);
+			goto handled;
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 		} else if (strnicmp(buf + strlen(CMD_NXP),
 				    PRIV_CMD_GET_CFG_CHAN_LIST,
@@ -15945,8 +20826,8 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				len = woal_priv_getcfgchanlist(
 					priv, buf, priv_cmd.total_len);
 			else
-				len = sprintf(buf,
-					      "CFG80211 is not enabled\n") +
+				len = snprintf(buf, CMD_BUF_LEN,
+					       "CFG80211 is not enabled\n") +
 				      1;
 			goto handled;
 #endif
@@ -15956,6 +20837,20 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			len = woal_priv_set_get_lpm(priv, buf,
 						    priv_cmd.total_len);
 			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_TP_STATE,
+				    strlen(PRIV_CMD_TP_STATE)) == 0) {
+			/* Set/Get TP accounting state */
+			len = woal_priv_set_tp_state(priv, buf,
+						     priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_IPS_CFG,
+				    strlen(PRIV_CMD_IPS_CFG)) == 0) {
+			len = woal_priv_ips_cfg(priv, buf, priv_cmd.total_len);
+			goto handled;
+		} else if (strnicmp(buf + strlen(CMD_NXP), PRIV_CMD_GET_SB_UUID,
+				    strlen(PRIV_CMD_GET_SB_UUID)) == 0) {
+			len = woal_priv_get_uuid(priv, buf, priv_cmd.total_len);
+			goto handled;
 		} else {
 			PRINTM(MERROR,
 			       "Unknown NXP PRIVATE command %s, ignored\n",
@@ -15973,7 +20868,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SCAN-CFG", strlen("SCAN-CFG")) == 0) {
 		PRINTM(MIOCTL, "Set SCAN CFG\n");
 		if (MLAN_STATUS_SUCCESS !=
@@ -15981,7 +20876,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RSSI", strlen("RSSI")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
@@ -15995,11 +20890,12 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "%.32s rssi %d\n",
-				      bss_info.ssid.ssid, signal.bcn_rssi_avg) +
+			len = snprintf(buf, CMD_BUF_LEN, "%.32s rssi %d\n",
+				       bss_info.ssid.ssid,
+				       signal.bcn_rssi_avg) +
 			      1;
 		} else {
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 		}
 	} else if (strncmp(buf, "LINKSPEED", strlen("LINKSPEED")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -16008,16 +20904,17 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			goto done;
 		}
 		PRINTM(MIOCTL, "tx rate=%d\n", (int)rate.rate);
-		len = sprintf(buf, "LinkSpeed %d\n",
-			      (int)(rate.rate * 500000 / 1000000)) +
+		len = snprintf(buf, CMD_BUF_LEN, "LinkSpeed %d\n",
+			       (int)(rate.rate * 500000 / 1000000)) +
 		      1;
 	} else
 #endif
 		if (strncmp(buf, "MACADDR", strlen("MACADDR")) == 0) {
-		len = sprintf(buf, "Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
-			      priv->current_addr[0], priv->current_addr[1],
-			      priv->current_addr[2], priv->current_addr[3],
-			      priv->current_addr[4], priv->current_addr[5]) +
+		len = snprintf(buf, CMD_BUF_LEN,
+			       "Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+			       priv->current_addr[0], priv->current_addr[1],
+			       priv->current_addr[2], priv->current_addr[3],
+			       priv->current_addr[4], priv->current_addr[5]) +
 		      1;
 	}
 #ifdef STA_SUPPORT
@@ -16027,7 +20924,9 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "powermode = %d\n", power_mode) + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "powermode = %d\n",
+			       power_mode) +
+		      1;
 	} else if (strncmp(buf, "SCAN-ACTIVE", strlen("SCAN-ACTIVE")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_set_scan_type(priv, MLAN_SCAN_TYPE_ACTIVE)) {
@@ -16036,7 +20935,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 		priv->scan_type = MLAN_SCAN_TYPE_ACTIVE;
 		PRINTM(MIOCTL, "Set Active Scan\n");
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SCAN-PASSIVE", strlen("SCAN-PASSIVE")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_set_scan_type(priv, MLAN_SCAN_TYPE_PASSIVE)) {
@@ -16045,7 +20944,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 		priv->scan_type = MLAN_SCAN_TYPE_PASSIVE;
 		PRINTM(MIOCTL, "Set Passive Scan\n");
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "POWERMODE", strlen("POWERMODE")) == 0) {
 		pdata = buf + strlen("POWERMODE") + 1;
 		if (!moal_extflg_isset(priv->phandle, EXT_HW_TEST)) {
@@ -16055,7 +20954,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				goto done;
 			}
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SETROAMING", strlen("SETROAMING")) == 0) {
 		pdata = buf + strlen("SETROAMING") + 1;
 #ifdef STA_CFG80211
@@ -16073,7 +20972,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			PRINTM(MIOCTL, "Roaming disabled\n");
 		}
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "ROAM", strlen("ROAM")) == 0) {
 		pdata = buf + strlen("ROAM") + 1;
 #ifdef STA_CFG80211
@@ -16091,7 +20990,15 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			PRINTM(MIOCTL, "Roaming disabled\n");
 		}
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
+	} else if (strncmp(buf, "COUNTRYCODE", strlen("COUNTRYCODE")) == 0) {
+		memset(country_code, 0, sizeof(country_code));
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_countrycode(priv, country_code)) {
+			ret = -EFAULT;
+			goto done;
+		}
+		len = snprintf(buf, CMD_BUF_LEN, "%s\n", country_code) + 1;
 	} else if (strncmp(buf, "COUNTRY", strlen("COUNTRY")) == 0) {
 		copy_len = strlen(buf) - strlen("COUNTRY") - 1;
 		if (copy_len > COUNTRY_CODE_LEN || copy_len <= 0) {
@@ -16104,7 +21011,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				buf + strlen("COUNTRY") + 1, copy_len,
 				COUNTRY_CODE_LEN);
 		PRINTM(MIOCTL, "Set COUNTRY %s\n", country_code);
-		if (moal_extflg_isset(priv->phandle, EXT_CNTRY_TXPWR)) {
+		if (priv->phandle->params.cntry_txpwr) {
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_request_country_power_table(priv,
 							     country_code)) {
@@ -16114,14 +21021,16 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 #ifdef STA_CFG80211
 		if (IS_STA_CFG80211(cfg80211_wext)) {
-			PRINTM(MIOCTL, "Notify country code=%s\n",
-			       country_code);
 			if (!moal_extflg_isset(priv->phandle,
-					       EXT_DISABLE_REGD_BY_DRIVER))
+					       EXT_DISABLE_REGD_BY_DRIVER)) {
+				PRINTM(MIOCTL, "Notify country code=%s\n",
+				       country_code);
+
 				regulatory_hint(priv->wdev->wiphy,
 						country_code);
-			len = sprintf(buf, "OK\n") + 1;
-			goto done;
+				len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
+				goto done;
+			}
 		}
 #endif
 		if (MLAN_STATUS_SUCCESS !=
@@ -16129,7 +21038,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (memcmp(buf, WEXT_CSCAN_HEADER, WEXT_CSCAN_HEADER_SIZE) ==
 		   0) {
 		PRINTM(MIOCTL, "Set Combo Scan\n");
@@ -16138,40 +21047,40 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "GETBAND", strlen("GETBAND")) == 0) {
 		if (MLAN_STATUS_SUCCESS != woal_get_band(priv, &band)) {
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "Band %d\n", band) + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "Band %d\n", band) + 1;
 	} else if (strncmp(buf, "SETBAND", strlen("SETBAND")) == 0) {
 		pband = buf + strlen("SETBAND") + 1;
 		if (MLAN_STATUS_SUCCESS != woal_set_band(priv, pband)) {
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #endif
 	else if (strncmp(buf, "START", strlen("START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "STOP", strlen("STOP")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #ifdef UAP_SUPPORT
 	else if (strncmp(buf, "AP_BSS_START", strlen("AP_BSS_START")) == 0) {
 		ret = woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_START);
 		if (ret)
 			goto done;
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "AP_BSS_STOP", strlen("AP_BSS_STOP")) == 0) {
 		ret = woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP);
 		if (ret)
 			goto done;
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "AP_SET_CFG", strlen("AP_SET_CFG")) == 0) {
-		if (priv_cmd.total_len <= strlen("AP_SET_CFG") + 1)
+		if (priv_cmd.total_len <= (int)strlen("AP_SET_CFG") + 1)
 			goto done;
 		pdata = buf + strlen("AP_SET_CFG") + 1;
 		ret = woal_uap_set_ap_cfg(priv, pdata,
@@ -16179,34 +21088,34 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 						  strlen("AP_SET_CFG") - 1);
 		if (ret)
 			goto done;
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "WL_FW_RELOAD", strlen("WL_FW_RELOAD")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "AP_GET_STA_LIST", strlen("AP_GET_STA_LIST")) ==
 		   0) {
 		/* TODO Add STA list support */
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #endif
 	else if (strncmp(buf, "SETSUSPENDOPT", strlen("SETSUSPENDOPT")) == 0) {
 		/* it will be done by GUI */
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SETSUSPENDMODE", strlen("SETSUSPENDMODE")) ==
 		   0) {
 		/* it will be done by GUI */
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXMODE", strlen("BTCOEXMODE")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXSCAN-START",
 			   strlen("BTCOEXSCAN-START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXSCAN-STOP", strlen("BTCOEXSCAN-STOP")) ==
 		   0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #ifdef STA_SUPPORT
 	else if (strncmp(buf, "BGSCAN-START", strlen("BGSCAN-START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BGSCAN-CONFIG", strlen("BGSCAN-CONFIG")) ==
 		   0) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -16216,10 +21125,10 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 		priv->bg_scan_start = MTRUE;
 		priv->bg_scan_reported = MFALSE;
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BGSCAN-STOP", strlen("BGSCAN-STOP")) == 0) {
 		if (priv->bg_scan_start && !priv->scan_cfg.rssi_threshold) {
-			if (MLAN_STATUS_SUCCESS !=
+			if (MLAN_STATUS_FAILURE ==
 			    woal_stop_bg_scan(priv, MOAL_NO_WAIT)) {
 				ret = -EFAULT;
 				goto done;
@@ -16227,7 +21136,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			priv->bg_scan_start = MFALSE;
 			priv->bg_scan_reported = MFALSE;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-START", strlen("RXFILTER-START")) ==
 		   0) {
 #ifdef MEF_CFG_RX_FILTER
@@ -16235,7 +21144,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		if (ret)
 			goto done;
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-STOP", strlen("RXFILTER-STOP")) ==
 		   0) {
 #ifdef MEF_CFG_RX_FILTER
@@ -16243,7 +21152,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		if (ret)
 			goto done;
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #ifdef STA_CFG80211
 	else if (strncmp(buf, "GET_EVENT", strlen("GET_EVENT")) == 0) {
@@ -16252,10 +21161,12 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 				woal_inform_bss_from_scan_result(
 					priv, NULL, MOAL_IOCTL_WAIT);
 		}
-		len = sprintf(buf, "EVENT=%d\n", priv->last_event) + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "EVENT=%d\n",
+			       priv->last_event) +
+		      1;
 		priv->last_event = 0;
 	} else if (strncmp(buf, "GET_802_11W", strlen("GET_802_11W")) == 0) {
-		len = sprintf(buf, "802_11W=ENABLED\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "802_11W=ENABLED\n") + 1;
 	}
 #endif /* STA_CFG80211 */
 	else if (strncmp(buf, "RXFILTER-ADD", strlen("RXFILTER-ADD")) == 0) {
@@ -16264,7 +21175,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-REMOVE", strlen("RXFILTER-REMOVE")) ==
 		   0) {
 		pdata = buf + strlen("RXFILTER-REMOVE") + 1;
@@ -16272,7 +21183,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "QOSINFO", strlen("QOSINFO")) == 0) {
 		pdata = buf + strlen("QOSINFO") + 1;
 #ifdef STA_SUPPORT
@@ -16282,14 +21193,14 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			goto done;
 		}
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SLEEPPD", strlen("SLEEPPD")) == 0) {
 		pdata = buf + strlen("SLEEPPD") + 1;
 		if (MLAN_STATUS_SUCCESS != woal_set_sleeppd(priv, pdata)) {
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SET_AP_WPS_P2P_IE",
 			   strlen("SET_AP_WPS_P2P_IE")) == 0) {
 		pdata = buf + strlen("SET_AP_WPS_P2P_IE") + 1;
@@ -16310,7 +21221,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 #endif
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #endif
 	else if (strncmp(buf, "P2P_DEV_ADDR", strlen("P2P_DEV_ADDR")) == 0) {
@@ -16343,7 +21254,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 #endif
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strnicmp(buf, "SCAN_TIMING", strlen("SCAN_TIMING")) == 0) {
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
@@ -16354,7 +21265,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		}
 #endif
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strnicmp(buf, "BA_WSIZE_RX", strlen("BA_WSIZE_RX")) == 0) {
 		pdata = buf + strlen("BA_WSIZE_RX") + 1;
 		len = priv_cmd.total_len - strlen("BA_WSIZE_RX") - 1;
@@ -16363,7 +21274,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strnicmp(buf, "BA_WSIZE_TX", strlen("BA_WSIZE_TX")) == 0) {
 		pdata = buf + strlen("BA_WSIZE_TX") + 1;
 		len = priv_cmd.total_len - strlen("BA_WSIZE_TX") - 1;
@@ -16372,7 +21283,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "FAKE_SCAN_COMPLETE",
 			   strlen("FAKE_SCAN_COMPLETE")) == 0) {
 		pdata = buf + strlen("FAKE_SCAN_COMPLETE") + 1;
@@ -16385,7 +21296,7 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			PRINTM(MIOCTL, "fake scan complete disabled\n");
 		}
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #ifdef WIFI_DIRECT_SUPPORT
@@ -16396,13 +21307,15 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
 	}
 #endif
 #endif
 	else if (strncmp(buf, "WLS_BATCHING", strlen("WLS_BATCHING")) == 0) {
 		/* TODO */
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, CMD_BUF_LEN, "OK\n") + 1;
+	} else if (strncmp(buf, "TDLS_CS_CHAN", strlen("TDLS_CS_CHAN")) == 0) {
+		len = woal_priv_tdls_cs_chan(priv, buf, priv_cmd.total_len);
 	}
 #if defined(UAP_SUPPORT)
 	else if (strncmp(buf, "P2P_ECSA", strlen("P2P_ECSA")) == 0) {
@@ -16412,6 +21325,24 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 	else if (strncmp(buf, "FAKEMAC", strlen("FAKEMAC")) == 0) {
 		len = woal_priv_config_random_mac(priv, buf,
 						  priv_cmd.total_len);
+	} else if (strncmp(buf, "SETROAMOFFLOAD", strlen("SETROAMOFFLOAD")) ==
+		   0) {
+		len = woal_priv_set_roam_offload(priv, buf, priv_cmd.total_len);
+	} else if (strncmp(buf, "SETROAMOFFLAPLIST",
+			   strlen("SETROAMOFFLAPLIST")) == 0) {
+		len = woal_priv_set_roam_offload_aplist(priv, buf,
+							priv_cmd.total_len);
+	} else if (strncmp(buf, "CFGROAMOFFLOAD", strlen("CFGROAMOFFLOAD")) ==
+		   0) {
+		len = woal_priv_roam_offload_cfg(priv, buf, priv_cmd.total_len);
+	} else if (strncmp(buf, "SETROAMPASSPHRASE",
+			   strlen("SETROAMPASSPHRASE")) == 0) {
+		len = woal_priv_set_roam_passphrase(priv, buf,
+						    priv_cmd.total_len);
+	} else if (strncmp(buf, PRIV_CMD_CLOUD_KEEP_ALIVE_RX,
+			   strlen(PRIV_CMD_CLOUD_KEEP_ALIVE_RX)) == 0) {
+		len = woal_priv_cloud_keep_alive_rx(priv, buf,
+						    priv_cmd.total_len);
 	} else if (strncmp(buf, PRIV_CMD_CLOUD_KEEP_ALIVE,
 			   strlen(PRIV_CMD_CLOUD_KEEP_ALIVE)) == 0) {
 		len = woal_priv_cloud_keep_alive(priv, buf, priv_cmd.total_len);
@@ -16445,7 +21376,8 @@ int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req)
 		if (priv_cmd.used_len <= priv_cmd.total_len) {
 			memset(buf + priv_cmd.used_len, 0,
 			       (size_t)(CMD_BUF_LEN - priv_cmd.used_len));
-			if (copy_to_user(cmd_buf, buf, priv_cmd.total_len)) {
+			if (copy_to_user((void __user *)cmd_buf, buf,
+					 priv_cmd.total_len)) {
 				PRINTM(MERROR,
 				       "%s: failed to copy data to user buffer\n",
 				       __FUNCTION__);
@@ -16693,12 +21625,25 @@ int wlan_get_scan_table_ret_entry(BSSDescriptor_t *pbss_desc, t_u8 **ppbuffer,
  *
  *  @return          0 --success, otherwise fail
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+int woal_do_ioctl(struct net_device *dev, struct ifreq *req, void __user *data,
+		  int cmd)
+#else
 int woal_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+#endif
+
 {
 	int ret = 0;
 
 	ENTER();
 
+#ifdef CONFIG_COMPAT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	if (in_compat_syscall()) /* not implemented yet */
+		return -EOPNOTSUPP;
+#endif
+#endif
+
 	PRINTM(MINFO, "woal_do_ioctl: ioctl cmd = 0x%x\n", cmd);
 	switch (cmd) {
 	case WOAL_ANDROID_DEF_CMD:
@@ -16711,6 +21656,9 @@ int woal_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 	case WOAL_MGMT_FRAME_TX:
 		ret = woal_send_host_packet(dev, req);
 		break;
+	case WOAL_TDLS_CONFIG:
+		ret = woal_tdls_config_ioctl(dev, req);
+		break;
 	case WOAL_ANDROID_PRIV_CMD:
 		ret = woal_android_priv_cmd(dev, req);
 		break;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.h
old mode 100644
new mode 100755
index f27d269d1..9eca736d7
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_eth_ioctl.h
@@ -4,7 +4,7 @@
  * @brief This file contains definition for private IOCTL call.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2023 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -82,6 +82,9 @@ Change log:
 #define PRIV_CMD_GET_STA_LIST "getstalist"
 #define PRIV_CMD_BSS_CONFIG "bssconfig"
 #endif
+#if defined(UAP_SUPPORT)
+#define PRIV_CMD_SETMODE "setmode"
+#endif
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 #define PRIV_CMD_BSSROLE "bssrole"
@@ -110,6 +113,7 @@ typedef struct _chan_stats {
 #define PRIV_CMD_ASSOCESSID "assocessid"
 #define PRIV_CMD_ASSOCBSSID "assocessid_bssid"
 #endif
+#define PRIV_CMD_AUTOASSOC "assocctrl"
 #define PRIV_CMD_WAKEUPREASON "wakeupreason"
 #ifdef STA_SUPPORT
 #define PRIV_CMD_LISTENINTERVAL "listeninterval"
@@ -148,6 +152,7 @@ typedef struct _chan_stats {
 #ifdef SDIO
 #define PRIV_CMD_SDCMD52RW "sdcmd52rw"
 #endif
+#define PRIV_CMD_ARPFILTER "arpfilter"
 #define PRIV_CMD_HOTSPOTCFG "hotspotcfg"
 #define PRIV_CMD_MGMT_FRAME_CTRL "mgmtframectrl"
 #define PRIV_CMD_QCONFIG "qconfig"
@@ -212,8 +217,15 @@ typedef struct _chan_stats {
 #define PRIV_CMD_MPA_CTRL "mpactrl"
 #endif
 #define PRIV_CMD_SLEEP_PARAMS "sleepparams"
+#define PRIV_CMD_NET_MON "netmon"
 #define PRIV_CMD_DFS_TESTING "dfstesting"
+#define PRIV_CMD_CLEAR_NOP "clear_nop"
+#define PRIV_CMD_NOP_LIST "nop_list"
+#define PRIV_CMD_FAKE_RADAR "fake_radar"
 #define PRIV_CMD_DFS53_CFG "dfs53cfg"
+#define PRIV_CMD_DFS_MODE "dfs_mode"
+#define PRIV_CMD_DFS_CAC "dfs_cac"
+#define PRIV_CMD_AUTODFS "autodfs"
 #define PRIV_CMD_CFP_CODE "cfpcode"
 #define PRIV_CMD_CWMODE "cwmode"
 #define PRIV_CMD_ANT_CFG "antcfg"
@@ -226,15 +238,20 @@ typedef struct _chan_stats {
 #ifdef SDIO
 #define PRIV_CMD_SD_CMD53_RW "sdcmd53rw"
 #endif
-#ifdef RX_PACKET_COALESCE
-#define PRIV_CMD_RX_COAL_CFG "rxpktcoal_cfg"
-#endif
+#define PRIV_CMD_MULTI_CHAN_CFG "mc_cfg"
+#define PRIV_CMD_MULTI_CHAN_POLICY "mc_policy"
+#define PRIV_CMD_DRCS_CFG "mc_cfg_ext"
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(UAP_CFG80211)
 #define PRIV_CMD_CFG_NOA "cfg_noa"
 #define PRIV_CMD_CFG_OPP_PS "cfg_opp_ps"
 #endif
 #endif
+#define PRIV_CMD_CFG_CLOCK_SYNC "clocksync"
+#define PRIV_CMD_CFG_GET_TSF_INFO "gettsfinfo"
+#define PRIV_CMD_TARGET_CHANNEL "targetchan"
+#define PRIV_CMD_BACKUP_CHANNEL "backupchan"
+
 #define PRIV_CMD_DFS_REPEATER_CFG "dfs_repeater"
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
@@ -242,6 +259,8 @@ typedef struct _chan_stats {
 #endif
 #endif
 #define PRIV_CMD_COEX_RX_WINSIZE "coex_rx_winsize"
+#define PRIV_CMD_TX_AGGR_CTRL "txaggrctrl"
+#define PRIV_CMD_AUTO_TDLS "autotdls"
 
 #ifdef PCIE
 #define PRIV_CMD_PCIE_REG_RW "pcieregrw"
@@ -257,6 +276,8 @@ typedef struct _chan_stats {
 #define PRIV_CMD_EXTEND_CHAN_SWITCH "channel_switch"
 #endif
 
+#define PRIV_CMD_TDLS_IDLE_TIME "tdls_idle_time"
+
 #define PRIV_CMD_DYN_BW "dyn_bw"
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
@@ -274,10 +295,19 @@ typedef struct _chan_stats {
 /**Private command ID to set/get independent reset*/
 #define PRIV_CMD_IND_RST_CFG "indrstcfg"
 
+#define PRIV_CMD_MCAST_AGGR_GROUP "mcast_aggr_group"
+#define PRIV_CMD_MC_AGGR_CFG "mc_aggr_cfg"
+#define PRIV_CMD_STATS "stats"
+#define PRIV_CMD_CH_LOAD "getchload"
+#define PRIV_CMD_CH_LOAD_RESULTS "getloadresults"
+#define PRIV_CMD_CROSS_CHIP_SYNCH "crosssynch"
+
 #define PRIV_CMD_ARB_CFG "arb"
 
 /**Private command to configure static rx abort config */
 #define PRIV_CMD_RX_ABORT_CFG "rx_abort_cfg"
+/**Private command to configure static OFDM DESENSE config */
+#define PRIV_CMD_OFDM_DESENSE_CFG "ofdm_desense_cfg"
 /**Private command to configure dynamic rx abort config */
 #define PRIV_CMD_RX_ABORT_CFG_EXT "rx_abort_cfg_ext"
 #define TX_AMPDU_RTS_CTS 0
@@ -294,10 +324,15 @@ typedef struct _chan_stats {
 /**Private command to configure cck desense config */
 #define PRIV_CMD_CCK_DESENSE_CFG "cck_desense_cfg"
 #define PRIV_CMD_DOT11MC_UNASSOC_FTM_CFG "dot11mc_unassoc_ftm_cfg"
+#define PRIV_CMD_HAL_PHY_CFG "hal_phy_cfg"
+#define PRIV_CMD_IPS_CFG "ips_cfg"
 
 /** Private command ID for Android default commands */
 #define WOAL_ANDROID_DEF_CMD (SIOCDEVPRIVATE + 1)
 
+/** Private command ID to send TLD configuration */
+#define WOAL_TDLS_CONFIG (SIOCDEVPRIVATE + 5)
+
 /** Private command ID to pass mgmt frame */
 #define WOAL_MGMT_FRAME_TX WOAL_MGMT_FRAME_TX_IOCTL
 
@@ -341,8 +376,16 @@ typedef struct _ssu_params_cfg {
 } __attribute__((packed)) ssu_params_cfg;
 #endif
 
+#define PRIV_CMD_CSI "csi"
+
 #define PRIV_CMD_BOOTSLEEP "bootsleep"
 
+/** Private command ID to config txwatchdog enable/disable */
+#define PRIV_CMD_TXWATCHDOG "txwatchdog"
+
+/** Private command to get secure boot uuid */
+#define PRIV_CMD_GET_SB_UUID "getuuid"
+
 /** Private command: 11AX Cfg */
 #define PRIV_CMD_11AXCFG "11axcfg"
 /** Private command: 11AX Cmd */
@@ -353,11 +396,17 @@ typedef struct _ssu_params_cfg {
 #define PRIV_CMD_TWT_SETUP "twt_setup"
 /** Private command: TWT Teardown Cfg */
 #define PRIV_CMD_TWT_TEARDOWN "twt_teardown"
+/** Private command: TWT report Cfg */
+#define PRIV_CMD_TWT_REPORT "twt_report"
 
 #define PRIV_CMD_LPM "lpm"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+int woal_do_ioctl(struct net_device *dev, struct ifreq *req, void __user *data,
+		  int cmd);
+#else
 int woal_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd);
-
+#endif
 /*
  * For android private commands, fixed value of ioctl is used.
  * Internally commands are differentiated using strings.
@@ -491,6 +540,28 @@ typedef struct woal_priv_addba {
 	t_u32 rx_amsdu;
 } woal_addba;
 
+/** Action field value : get */
+#define ACTION_GET 0
+/** Action field value : set */
+#define ACTION_SET 1
+/** Action field value:  add */
+#define ACTION_ADD 2
+/** Action field value:  remove */
+#define ACTION_REMOVE 3
+
+#define MC_AGGR_CTRL MBIT(0)
+/* mcast_aggr_group */
+typedef struct _mcast_aggr_group {
+	/** action */
+	t_u32 action;
+	/** mcast addr */
+	t_u8 mcast_addr[ETH_ALEN];
+	/** Number of multicast addresses in the list */
+	t_u32 num_mcast_addr;
+	/** Multicast address list */
+	mlan_802_11_mac_addr mac_list[MLAN_MAX_MULTICAST_LIST_SIZE];
+} mcast_aggr_group, *pmcast_aggr_group;
+
 typedef struct _txrate_setting {
 	t_u16 preamble : 2; /*BIT1-BIT0:
 			     *  For legacy 11b: preamble type
@@ -592,8 +663,6 @@ typedef struct woal_priv_esuppmode_cfg {
 } woal_esuppmode_cfg;
 
 mlan_status woal_set_ap_wps_p2p_ie(moal_private *priv, t_u8 *ie, size_t len);
-mlan_status woal_ioctl_aggr_prio_tbl(moal_private *priv, t_u32 action,
-				     mlan_ds_11n_aggr_prio_tbl *aggr_prio_tbl);
 
 int woal_android_priv_cmd(struct net_device *dev, struct ifreq *req);
 
@@ -623,6 +692,26 @@ typedef struct _cloud_keep_alive {
 	/** packet content */
 	t_u8 pkt[255];
 } __ATTRIB_PACK__ cloud_keep_alive;
+/** cloud keep alive parameters */
+#define PRIV_CMD_CLOUD_KEEP_ALIVE_RX "cloud_keep_alive_rx"
+typedef struct _cloud_keep_alive_rx {
+	/** id */
+	t_u8 mkeep_alive_id;
+	/** enable/disable of this id */
+	t_u8 enable;
+	/** enable/disable reset*/
+	t_u8 reset;
+	/** Reserved */
+	t_u8 reserved;
+	/** Destination MAC address */
+	t_u8 dst_mac[ETH_ALEN];
+	/** Source MAC address */
+	t_u8 src_mac[ETH_ALEN];
+	/** packet length */
+	t_u8 pkt_len;
+	/** packet content */
+	t_u8 pkt[100];
+} __ATTRIB_PACK__ cloud_keep_alive_rx;
 
 #define TLV_TYPE_PER_PKT_CFG 0x0001
 #define TX_PKT_CTRL MBIT(0)
@@ -670,4 +759,6 @@ typedef struct {
 	/** chan_list */
 	wlan_ieee80211_chan chan_list[];
 } __ATTRIB_PACK__ wlan_ieee80211_chan_list;
+
+#define PRIV_CMD_TP_STATE "tp_state"
 #endif /* _WOAL_ETH_PRIV_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_init.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_init.c
old mode 100644
new mode 100755
index 077a6614d..0ce0adb67
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_init.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_init.c
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2018-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -26,170 +26,216 @@
 extern pmoal_handle m_handle[];
 
 /** Firmware name */
-char *fw_name;
-int req_fw_nowait;
+static char *fw_name;
+static int req_fw_nowait;
 int fw_reload;
+int auto_fw_reload;
+
+static char *hw_name;
 
 /** MAC address */
-char *mac_addr;
+static char *mac_addr;
 /** Module param cfg file */
-char *mod_para;
+static char *mod_para;
 
 #ifdef MFG_CMD_SUPPORT
 /** Mfg mode */
 int mfg_mode;
 #endif
+int rf_test_mode;
 
 #if defined(SDIO)
 /** SDIO interrupt mode (0: INT_MODE_SDIO, 1: INT_MODE_GPIO) */
-int intmode = INT_MODE_SDIO;
+static int intmode = INT_MODE_SDIO;
 /** GPIO interrupt pin number */
-int gpiopin;
+static int gpiopin;
 #endif
 
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
-int disable_regd_by_driver = 1;
+static int disable_regd_by_driver = 1;
 /** Region alpha2 string */
-char *reg_alpha2;
+static char *reg_alpha2;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-int country_ie_ignore;
-int beacon_hints;
+static int country_ie_ignore;
+static int beacon_hints;
 #endif
 #endif
+static int cfg80211_drcs;
 
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-int host_mlme;
+static int host_mlme = 1;
 #endif
 #endif
 
+static int roamoffload_in_hs;
+
+static int drcs_chantime_mode;
+
 /** Auto deep sleep */
-int auto_ds;
+static int auto_ds;
+
+/** net_rx mode*/
+static int net_rx;
+/** amsdu deaggr mode */
+static int amsdu_deaggr;
+
+static int ext_scan;
 
 /** IEEE PS mode */
-int ps_mode;
+static int ps_mode;
 /** passive to active scan */
-int p2a_scan;
+static int p2a_scan;
 /** scan chan gap */
-int scan_chan_gap;
+static int scan_chan_gap;
+/** sched scan */
+static int sched_scan = 1;
 /** Max Tx buffer size */
 int max_tx_buf;
 
 #ifdef STA_SUPPORT
 /** Max STA interfaces */
-int max_sta_bss = DEF_STA_BSS;
+static int max_sta_bss = DEF_STA_BSS;
 /** STA interface name */
-char *sta_name;
+static char *sta_name;
 #endif
 
 #ifdef UAP_SUPPORT
 /** Max uAP interfaces */
-int max_uap_bss = DEF_UAP_BSS;
+static int max_uap_bss = DEF_UAP_BSS;
 /** uAP interface name */
-char *uap_name;
+static char *uap_name;
 /** Max uAP station number */
-int uap_max_sta;
+static int uap_max_sta;
+/** WACP mode */
+static int wacp_mode = WACP_MODE_DEFAULT;
 #endif
 
 #ifdef WIFI_DIRECT_SUPPORT
 /** Max WIFIDIRECT interfaces */
-int max_wfd_bss = DEF_WIFIDIRECT_BSS;
+static int max_wfd_bss = DEF_WIFIDIRECT_BSS;
 /** WIFIDIRECT interface name */
-char *wfd_name;
+static char *wfd_name;
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 /** max VIRTUAL bss */
-int max_vir_bss = DEF_VIRTUAL_BSS;
+static int max_vir_bss = DEF_VIRTUAL_BSS;
 #endif
 #endif
 
-#ifdef SDIO_SUSPEND_RESUME
 /** PM keep power */
-int pm_keep_power = 1;
+static int pm_keep_power = 1;
+#ifdef SDIO_SUSPEND_RESUME
 /** HS when shutdown */
-int shutdown_hs;
+static int shutdown_hs;
 #endif
 
 #if defined(SDIO)
 /** SDIO slew rate */
-int slew_rate = 3;
+static int slew_rate = 3;
+#endif
+int tx_work = 0;
+
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+/**
+ * RPS to steer packets to specific CPU
+ * Default value of 0 keeps rps disabled by default
+ */
+static int rps = 0;
+
+/**
+ * rps cpu mask
+ * rps can be configure to any value between 0x1 - 0xf
+ * ex: value of 0x3(0011) indicates to use cpu-0 and cpu-1
+ */
+#define RPS_CPU_MASK 0xf
+#endif
+#endif
+
+static int tx_skb_clone = 0;
+#ifdef IMX_SUPPORT
+static int pmqos = 1;
+#else
+static int pmqos = 0;
 #endif
 
+static int chan_track = 0;
+static int mcs32 = 1;
+/** hs_auto_arp setting */
+static int hs_auto_arp = 0;
+
 #if defined(STA_SUPPORT)
 /** 802.11d configuration */
-int cfg_11d;
+static int cfg_11d;
 #endif
 
 /** fw serial download check */
-int fw_serial = 1;
+static int fw_serial = 1;
 
 /** napi support*/
-int napi;
+static int napi;
 
 /** DPD data config file */
-char *dpd_data_cfg;
+static char *dpd_data_cfg;
 
 /** CAL data config file */
-char *cal_data_cfg;
+static char *cal_data_cfg;
 /** Init config file (MAC address, register etc.) */
-char *init_cfg;
+static char *init_cfg;
 
 /** Set configuration data of Tx power limitation */
-char *txpwrlimit_cfg;
+static char *txpwrlimit_cfg;
 /** Allow setting tx power table of country */
-int cntry_txpwr;
+static int cntry_txpwr;
 
 /** Init hostcmd file */
-char *init_hostcmd_cfg;
-char *band_steer_cfg;
+static char *init_hostcmd_cfg;
+static char *band_steer_cfg;
 
 #if defined(STA_WEXT) || defined(UAP_WEXT)
 /** CFG80211 and WEXT mode */
-int cfg80211_wext = STA_WEXT_MASK | UAP_WEXT_MASK;
+static int cfg80211_wext =
+	STA_WEXT_MASK | UAP_WEXT_MASK | STA_CFG80211_MASK | UAP_CFG80211_MASK;
 #else
 /** CFG80211 mode */
-int cfg80211_wext = STA_CFG80211_MASK | UAP_CFG80211_MASK;
-#endif
-
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-int fw_region = 1;
-#endif
+static int cfg80211_wext = STA_CFG80211_MASK | UAP_CFG80211_MASK;
 #endif
 
 /** Work queue priority */
-int wq_sched_prio;
+static int wq_sched_prio;
 /** Work queue scheduling policy */
-int wq_sched_policy = SCHED_NORMAL;
+static int wq_sched_policy = SCHED_NORMAL;
 /** rx_work flag */
-int rx_work;
+static int rx_work;
 
 #if defined(USB)
 int skip_fwdnld;
 #endif
 
 /* Enable/disable aggrctrl */
-int aggrctrl;
+static int aggrctrl;
 
 #ifdef USB
 /* Enable/disable USB aggregation feature */
-int usb_aggr;
+static int usb_aggr;
 #endif
 
 #ifdef PCIE
 /* Enable/disable Message Signaled Interrupt (MSI) */
 int pcie_int_mode = PCIE_INT_MODE_MSI;
+static int ring_size;
 #endif /* PCIE */
 
-int low_power_mode_enable;
+static int low_power_mode_enable;
 
-int hw_test;
+static int hw_test;
 
 #ifdef CONFIG_OF
 int dts_enable = 1;
 #endif
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-int dfs_offload;
+static int dfs_offload;
 #endif
 
 #ifdef ANDROID_KERNEL
@@ -198,50 +244,63 @@ int wakelock_timeout = WAKE_LOCK_TIMEOUT;
 
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 #ifdef WIFI_DIRECT_SUPPORT
-int drv_mode = (DRV_MODE_STA | DRV_MODE_UAP | DRV_MODE_WIFIDIRECT);
+static int drv_mode = (DRV_MODE_STA | DRV_MODE_UAP | DRV_MODE_WIFIDIRECT);
 #else
-int drv_mode = (DRV_MODE_STA | DRV_MODE_UAP);
+static int drv_mode = (DRV_MODE_STA | DRV_MODE_UAP);
 #endif /* WIFI_DIRECT_SUPPORT */
 #else
 #ifdef STA_SUPPORT
-int drv_mode = DRV_MODE_STA;
+static int drv_mode = DRV_MODE_STA;
 #else
-int drv_mode = DRV_MODE_UAP;
+static int drv_mode = DRV_MODE_UAP;
 #endif /* STA_SUPPORT */
 #endif /* STA_SUPPORT & UAP_SUPPORT */
 
-int gtk_rekey_offload = GTK_REKEY_OFFLOAD_DISABLE;
+static int gtk_rekey_offload = GTK_REKEY_OFFLOAD_DISABLE;
 
-int pmic;
+static int pmic;
 
-int antcfg;
+static int antcfg;
 
-t_u32 uap_oper_ctrl;
+static t_u32 uap_oper_ctrl;
 
-int hs_wake_interval = 400;
-int indication_gpio = 0xff;
-int disconnect_on_suspend;
-int hs_mimo_switch;
+static int hs_wake_interval = 400;
+static int indication_gpio = 0xff;
+static int disconnect_on_suspend;
+static int hs_mimo_switch;
 
-int indrstcfg = 0xffffffff;
+static int indrstcfg = 0xffffffff;
 
 /** all the feature are enabled */
 #define DEFAULT_DEV_CAP_MASK 0xffffffff
-t_u32 dev_cap_mask = DEFAULT_DEV_CAP_MASK;
+static t_u32 dev_cap_mask = DEFAULT_DEV_CAP_MASK;
 #ifdef SDIO
-int sdio_rx_aggr = MTRUE;
+static int sdio_rx_aggr = MTRUE;
 #endif
 
 /** The global variable of scan beacon buffer **/
-int fixed_beacon_buffer;
+static int fixed_beacon_buffer;
 
 #ifdef WIFI_DIRECT_SUPPORT
-int GoAgeoutTime;
+static int GoAgeoutTime;
 #endif
 
-t_u16 multi_dtim;
+static t_u16 multi_dtim;
+
+static t_u16 inact_tmo;
 
-t_u16 inact_tmo;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+/* default filter flag 0x27 Stands for
+  (MLAN_NETMON_NON_BSS_BCN | \
+   MLAN_NETMON_DATA | \
+   MLAN_NETMON_CONTROL | \
+   MLAN_NETMON_MANAGEMENT)
+*/
+#define DEFAULT_NETMON_FILTER 0x27
+static int mon_filter = DEFAULT_NETMON_FILTER;
+#endif
+#endif
 
 #ifdef DEBUG_LEVEL1
 #ifdef DEBUG_LEVEL2
@@ -254,6 +313,9 @@ t_u32 drvdbg = DEFAULT_DEBUG_MASK;
 #endif /* DEBUG_LEVEL1 */
 
 static card_type_entry card_type_map_tbl[] = {
+#ifdef SD8801
+	{CARD_TYPE_SD8801, 0, CARD_SD8801},
+#endif
 #ifdef SD8887
 	{CARD_TYPE_SD8887, 0, CARD_SD8887},
 #endif
@@ -278,6 +340,13 @@ static card_type_entry card_type_map_tbl[] = {
 #ifdef SD9098
 	{CARD_TYPE_SD9098, 0, CARD_SD9098},
 #endif
+#ifdef SD9177
+	{CARD_TYPE_SD9177, 0, CARD_SD9177},
+#endif
+#ifdef SDIW62X
+	{CARD_TYPE_SDIW62X, 0, CARD_SDIW62X},
+#endif
+	{CARD_TYPE_SDAW693, 0, CARD_SDAW693},
 #ifdef PCIE8897
 	{CARD_TYPE_PCIE8897, 0, CARD_PCIE8897},
 #endif
@@ -290,6 +359,14 @@ static card_type_entry card_type_map_tbl[] = {
 #ifdef PCIE9098
 	{CARD_TYPE_PCIE9098, 0, CARD_PCIE9098},
 #endif
+	{CARD_TYPE_PCIEAW693, 0, CARD_PCIEAW693},
+#ifdef PCIEIW62X
+	{CARD_TYPE_PCIEIW62X, 0, CARD_PCIEIW62X},
+#endif
+#ifdef USB8801
+	{CARD_TYPE_USB8801, 0, CARD_USB8801},
+#endif
+
 #ifdef USB8897
 	{CARD_TYPE_USB8897, 0, CARD_USB8897},
 #endif
@@ -305,10 +382,16 @@ static card_type_entry card_type_map_tbl[] = {
 #ifdef USB9097
 	{CARD_TYPE_USB9097, 0, CARD_USB9097},
 #endif
+#ifdef USBIW62X
+	{CARD_TYPE_USBIW62X, 0, CARD_USBIW62X},
+#endif
+
 };
 
-int dfs53cfg = DFS_W53_DEFAULT_FW;
+static int dfs53cfg = DFS_W53_DEFAULT_FW;
 
+static int keep_previous_scan = 1;
+static int auto_11ax = 1;
 /**
  *  @brief This function read a line in module parameter file
  *
@@ -324,7 +407,8 @@ static t_size parse_cfg_get_line(t_u8 *data, t_size size, t_u8 *line_pos)
 
 	ENTER();
 
-	if (pos >= size) { /* reach the end */
+	if ((pos >= (t_s32)size) || (data == NULL) ||
+	    (line_pos == NULL)) { /* reach the end */
 		pos = 0; /* Reset position for rfkill */
 		LEAVE();
 		return -1;
@@ -333,7 +417,7 @@ static t_size parse_cfg_get_line(t_u8 *data, t_size size, t_u8 *line_pos)
 	src = data + pos;
 	dest = line_pos;
 
-	while (pos < size && *src != '\x0A' && *src != '\0') {
+	while (pos < (t_s32)size && *src != '\x0A' && *src != '\0') {
 		if (*src != ' ' && *src != '\t') /* parse space */
 			*dest++ = *src++;
 		else
@@ -498,12 +582,12 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 	moal_mod_para *params = &handle->params;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 
-	while (parse_cfg_get_line(data, size, line) != -1) {
+	while ((int)parse_cfg_get_line(data, size, line) != -1) {
 		if (strncmp(line, "}", strlen("}")) == 0) {
 			end = 1;
 			break;
 		}
-		if (end == 0 && strstr(line, "{") != 0)
+		if (end == 0 && strstr(line, "{") != NULL)
 			break;
 		if (strncmp(line, "hw_test", strlen("hw_test")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
@@ -559,6 +643,14 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				goto err;
 			params->fw_reload = out_data;
 			PRINTM(MMSG, "fw_reload %d\n", params->fw_reload);
+		} else if (strncmp(line, "auto_fw_reload",
+				   strlen("auto_fw_reload")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->auto_fw_reload = out_data;
+			PRINTM(MMSG, "auto_fw_reload %d\n",
+			       params->auto_fw_reload);
 		} else if (strncmp(line, "fw_serial", strlen("fw_serial")) ==
 			   0) {
 			if (parse_line_read_int(line, &out_data) !=
@@ -572,6 +664,12 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			       moal_extflg_isset(handle, EXT_FW_SERIAL) ?
 				       "on" :
 				       "off");
+		} else if (strncmp(line, "hw_name", strlen("hw_name")) == 0) {
+			if (parse_line_read_string(line, &out_str) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			woal_dup_string(&params->hw_name, out_str);
+			PRINTM(MMSG, "hw_name=%s\n", params->hw_name);
 		} else if (strncmp(line, "mac_addr", strlen("mac_addr")) == 0) {
 			if (parse_line_read_string(line, &out_str) !=
 			    MLAN_STATUS_SUCCESS)
@@ -588,13 +686,42 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			PRINTM(MMSG, "mfg_mode = %d\n", params->mfg_mode);
 		}
 #endif
-		else if (strncmp(line, "drv_mode", strlen("drv_mode")) == 0) {
+		else if (strncmp(line, "rf_test_mode",
+				 strlen("rf_test_mode")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->rf_test_mode = out_data;
+			PRINTM(MMSG, "rf_test_mode = %d\n",
+			       params->rf_test_mode);
+		} else if (strncmp(line, "drv_mode", strlen("drv_mode")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
 				goto err;
 			params->drv_mode = out_data;
 			PRINTM(MMSG, "drv_mode = %d\n", params->drv_mode);
 		}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+		else if (strncmp(line, "mon_filter", strlen("mon_filter")) ==
+			 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->mon_filter = out_data;
+			PRINTM(MMSG, "mon_filter = %d\n", params->mon_filter);
+		}
+#endif
+#endif
+#ifdef DEBUG_LEVEL1
+		else if (strncmp(line, "drvdbg", strlen("drvdbg")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->drvdbg = out_data;
+			PRINTM(MMSG, "drvdbg = %d\n", params->drvdbg);
+		}
+#endif
 #ifdef STA_SUPPORT
 		else if (strncmp(line, "max_sta_bss", strlen("max_sta_bss")) ==
 			 0) {
@@ -652,6 +779,26 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				goto err;
 			params->auto_ds = out_data;
 			PRINTM(MMSG, "auto_ds = %d\n", params->auto_ds);
+		} else if (strncmp(line, "net_rx", strlen("net_rx")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->net_rx = out_data;
+			PRINTM(MMSG, "net_rx = %d\n", params->net_rx);
+		} else if (strncmp(line, "amsdu_deaggr",
+				   strlen("amsdu_deaggr")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->amsdu_deaggr = out_data;
+			PRINTM(MMSG, "amsdu_deaggr = %d\n",
+			       params->amsdu_deaggr);
+		} else if (strncmp(line, "ext_scan", strlen("ext_scan")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->ext_scan = out_data;
+			PRINTM(MMSG, "ext_scan = %d\n", params->ext_scan);
 		} else if (strncmp(line, "ps_mode", strlen("ps_mode")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
@@ -672,6 +819,13 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			params->scan_chan_gap = out_data;
 			PRINTM(MMSG, "scan_chan_gap = %d\n",
 			       params->scan_chan_gap);
+		} else if (strncmp(line, "sched_scan", strlen("sched_scan")) ==
+			   0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->sched_scan = out_data;
+			PRINTM(MMSG, "sched_scan = %d\n", params->sched_scan);
 		} else if (strncmp(line, "max_tx_buf", strlen("max_tx_buf")) ==
 			   0) {
 			if (parse_line_read_int(line, &out_data) !=
@@ -700,7 +854,6 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			PRINTM(MMSG, "gpiopin = %d\n", params->gpiopin);
 		}
 #endif
-#if defined(SDIO) && defined(SDIO_SUSPEND_RESUME)
 		else if (strncmp(line, "pm_keep_power",
 				 strlen("pm_keep_power")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
@@ -714,8 +867,10 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			       moal_extflg_isset(handle, EXT_PM_KEEP_POWER) ?
 				       "on" :
 				       "off");
-		} else if (strncmp(line, "shutdown_hs",
-				   strlen("shutdown_hs")) == 0) {
+		}
+#if defined(SDIO) && defined(SDIO_SUSPEND_RESUME)
+		else if (strncmp(line, "shutdown_hs", strlen("shutdown_hs")) ==
+			 0) {
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
 				goto err;
@@ -780,14 +935,8 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
 				goto err;
-			if (out_data)
-				moal_extflg_set(handle, EXT_CNTRY_TXPWR);
-			else
-				moal_extflg_clear(handle, EXT_CNTRY_TXPWR);
-			PRINTM(MMSG, "cntry_txpwr %s\n",
-			       moal_extflg_isset(handle, EXT_CNTRY_TXPWR) ?
-				       "on" :
-				       "off");
+			params->cntry_txpwr = out_data;
+			PRINTM(MMSG, "cntry_txpwr = %d\n", params->cntry_txpwr);
 		} else if (strncmp(line, "init_hostcmd_cfg",
 				   strlen("init_hostcmd_cfg")) == 0) {
 			if (parse_line_read_string(line, &out_str) !=
@@ -885,6 +1034,14 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			params->pcie_int_mode = out_data;
 			PRINTM(MMSG, "pcie_int_mode=%d\n",
 			       params->pcie_int_mode);
+		} else if (IS_PCIE(handle->card_type) &&
+			   strncmp(line, "ring_size", strlen("ring_size")) ==
+				   0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->ring_size = out_data;
+			PRINTM(MMSG, "ring_size=%d\n", params->ring_size);
 		}
 #endif
 		else if (strncmp(line, "low_power_mode_enable",
@@ -936,11 +1093,6 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				       "off");
 		}
 #endif
-#if defined(SD8997) || defined(PCIE8997) || defined(USB8997) ||                \
-	defined(SD8977) || defined(SD8987) || defined(SD9098) ||               \
-	defined(USB9098) || defined(PCIE9098) || defined(SD9097) ||            \
-	defined(USB9097) || defined(PCIE9097) || defined(SD8978) ||            \
-	defined(USB8978)
 		else if (strncmp(line, "pmic", strlen("pmic")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
@@ -952,9 +1104,7 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			PRINTM(MMSG, "pmic %s\n",
 			       moal_extflg_isset(handle, EXT_PMIC) ? "on" :
 								     "off");
-		}
-#endif
-		else if (strncmp(line, "antcfg", strlen("antcfg")) == 0) {
+		} else if (strncmp(line, "antcfg", strlen("antcfg")) == 0) {
 			if (parse_line_read_int(line, &out_data) !=
 			    MLAN_STATUS_SUCCESS)
 				goto err;
@@ -1077,6 +1227,55 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			PRINTM(MMSG, "napi %s\n",
 			       moal_extflg_isset(handle, EXT_NAPI) ? "on" :
 								     "off");
+		} else if (strncmp(line, "tx_work", strlen("tx_work")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_TX_WORK);
+			else
+				moal_extflg_clear(handle, EXT_TX_WORK);
+			PRINTM(MMSG, "tx_work %s\n",
+			       moal_extflg_isset(handle, EXT_TX_WORK) ? "on" :
+									"off");
+		}
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		else if (strncmp(line, "rps", strlen("rps")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+
+			handle->params.rps = out_data & RPS_CPU_MASK;
+			PRINTM(MMSG, "rps set to %x from cfg\n",
+			       handle->params.rps);
+		}
+#endif
+#endif
+		else if (strncmp(line, "tx_skb_clone",
+				 strlen("tx_skb_clone")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_TX_SKB_CLONE);
+			else
+				moal_extflg_clear(handle, EXT_TX_SKB_CLONE);
+			PRINTM(MMSG, "tx_skb_clone %s\n",
+			       moal_extflg_isset(handle, EXT_TX_SKB_CLONE) ?
+				       "on" :
+				       "off");
+		} else if (strncmp(line, "pmqos", strlen("pmqos")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_PMQOS);
+			else
+				moal_extflg_clear(handle, EXT_PMQOS);
+			PRINTM(MMSG, "pmqos %s\n",
+			       moal_extflg_isset(handle, EXT_PMQOS) ? "on" :
+								      "off");
 		}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 		else if (strncmp(line, "dfs_offload", strlen("dfs_offload")) ==
@@ -1094,6 +1293,43 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				       "off");
 		}
 #endif
+		else if (strncmp(line, "cfg80211_drcs",
+				 strlen("cfg80211_drcs")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_CFG80211_DRCS);
+			else
+				moal_extflg_clear(handle, EXT_CFG80211_DRCS);
+			PRINTM(MMSG, "cfg80211_drcs %s\n",
+			       moal_extflg_isset(handle, EXT_CFG80211_DRCS) ?
+				       "on" :
+				       "off");
+		} else if (strncmp(line, "drcs_chantime_mode",
+				   strlen("drcs_chantime_mode")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->drcs_chantime_mode = out_data;
+			PRINTM(MMSG, "drcs_chantime_mode=%d\n",
+			       params->drcs_chantime_mode);
+		} else if (strncmp(line, "roamoffload_in_hs",
+				   strlen("roamoffload_in_hs")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_ROAMOFFLOAD_IN_HS);
+			else
+				moal_extflg_clear(handle,
+						  EXT_ROAMOFFLOAD_IN_HS);
+			PRINTM(MMSG, "roamoffload_in_hs %s\n",
+			       moal_extflg_isset(handle,
+						 EXT_ROAMOFFLOAD_IN_HS) ?
+				       "on" :
+				       "off");
+		}
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 		else if (strncmp(line, "disable_regd_by_driver",
 				 strlen("disable_regd_by_driver")) == 0) {
@@ -1109,8 +1345,8 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 			PRINTM(MMSG, "reg domain set by driver=%s\n",
 			       moal_extflg_isset(handle,
 						 EXT_DISABLE_REGD_BY_DRIVER) ?
-				       "disable" :
-				       "enable");
+				       "enable" :
+				       "disable");
 		} else if (strncmp(line, "reg_alpha2", strlen("reg_alpha2")) ==
 			   0) {
 			if (parse_line_read_string(line, &out_str) !=
@@ -1146,8 +1382,8 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				moal_extflg_clear(handle, EXT_BEACON_HINTS);
 			PRINTM(MMSG, "beacon_hints=%s\n",
 			       moal_extflg_isset(handle, EXT_BEACON_HINTS) ?
-				       "disable" :
-				       "enable");
+				       "enable" :
+				       "disable");
 		}
 #endif
 #endif
@@ -1159,8 +1395,29 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				goto err;
 			params->uap_max_sta = out_data;
 			PRINTM(MMSG, "uap_max_sta=%d\n", params->uap_max_sta);
+		} else if (strncmp(line, "wacp_mode", strlen("wacp_mode")) ==
+			   0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->wacp_mode = out_data;
+			PRINTM(MMSG, "wacp_moe=%d\n", params->wacp_mode);
 		}
 #endif
+		else if (strncmp(line, "mcs32", strlen("mcs32")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->mcs32 = out_data;
+			PRINTM(MMSG, "mcs32=%d\n", params->mcs32);
+		} else if (strncmp(line, "hs_auto_arp",
+				   strlen("hs_auto_arp")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->hs_auto_arp = out_data;
+			PRINTM(MMSG, "hs_auto_arp=%d\n", params->hs_auto_arp);
+		}
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		else if (strncmp(line, "host_mlme", strlen("host_mlme")) == 0) {
@@ -1173,8 +1430,8 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				moal_extflg_clear(handle, EXT_HOST_MLME);
 			PRINTM(MMSG, "host_mlme=%s\n",
 			       moal_extflg_isset(handle, EXT_HOST_MLME) ?
-				       "disable" :
-				       "enable");
+				       "enable" :
+				       "disable");
 		}
 #endif
 #endif
@@ -1184,6 +1441,32 @@ static mlan_status parse_cfg_read_block(t_u8 *data, t_u32 size,
 				goto err;
 			params->dfs53cfg = out_data;
 			PRINTM(MMSG, "dfs53cfg= %d\n", params->dfs53cfg);
+		} else if (strncmp(line, "chan_track", strlen("chan_track")) ==
+			   0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			if (out_data)
+				moal_extflg_set(handle, EXT_CHAN_TRACK);
+
+			PRINTM(MMSG, "chan_track= %s\n",
+			       moal_extflg_isset(handle, EXT_PMQOS) ? "on" :
+								      "off");
+		} else if (strncmp(line, "keep_previous_scan",
+				   strlen("keep_previous_scan")) == 0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->keep_previous_scan = out_data;
+			PRINTM(MMSG, "keep_previous_scan=%d\n",
+			       params->keep_previous_scan);
+		} else if (strncmp(line, "auto_11ax", strlen("auto_11ax")) ==
+			   0) {
+			if (parse_line_read_int(line, &out_data) !=
+			    MLAN_STATUS_SUCCESS)
+				goto err;
+			params->auto_11ax = out_data;
+			PRINTM(MMSG, "auto_11ax=%d\n", params->auto_11ax);
 		}
 	}
 	if (end)
@@ -1224,8 +1507,16 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	}
 	if (params)
 		handle->params.fw_reload = params->fw_reload;
+
+	handle->params.auto_fw_reload = auto_fw_reload;
+	if (params)
+		handle->params.auto_fw_reload = params->auto_fw_reload;
 	if (fw_serial)
 		moal_extflg_set(handle, EXT_FW_SERIAL);
+	woal_dup_string(&handle->params.hw_name, hw_name);
+	if (params && params->hw_name)
+		woal_dup_string(&handle->params.hw_name, params->hw_name);
+
 	woal_dup_string(&handle->params.mac_addr, mac_addr);
 	if (params && params->mac_addr)
 		woal_dup_string(&handle->params.mac_addr, params->mac_addr);
@@ -1234,9 +1525,26 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	if (params)
 		handle->params.mfg_mode = params->mfg_mode;
 #endif
+	handle->params.rf_test_mode = rf_test_mode;
+	if (params)
+		handle->params.rf_test_mode = params->rf_test_mode;
+
 	handle->params.drv_mode = drv_mode;
 	if (params)
 		handle->params.drv_mode = params->drv_mode;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	handle->params.mon_filter = mon_filter;
+	if (params)
+		handle->params.mon_filter = params->mon_filter;
+#endif
+#endif
+#ifdef DEBUG_LEVEL1
+	handle->params.drvdbg = drvdbg;
+	if (params)
+		handle->params.drvdbg = params->drvdbg;
+#endif
+
 #ifdef STA_SUPPORT
 	handle->params.max_sta_bss = max_sta_bss;
 	woal_dup_string(&handle->params.sta_name, sta_name);
@@ -1249,12 +1557,21 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	handle->params.max_uap_bss = max_uap_bss;
 	woal_dup_string(&handle->params.uap_name, uap_name);
 	handle->params.uap_max_sta = uap_max_sta;
+	handle->params.wacp_mode = wacp_mode;
+	handle->params.mcs32 = mcs32;
 	if (params) {
 		handle->params.max_uap_bss = params->max_uap_bss;
 		woal_dup_string(&handle->params.uap_name, params->uap_name);
 		handle->params.uap_max_sta = params->uap_max_sta;
+		handle->params.wacp_mode = params->wacp_mode;
+		handle->params.mcs32 = params->mcs32;
 	}
 #endif /* UAP_SUPPORT */
+
+	handle->params.hs_auto_arp = hs_auto_arp;
+	if (params) {
+		handle->params.hs_auto_arp = params->hs_auto_arp;
+	}
 #ifdef WIFI_DIRECT_SUPPORT
 	handle->params.max_wfd_bss = max_wfd_bss;
 	woal_dup_string(&handle->params.wfd_name, wfd_name);
@@ -1271,15 +1588,29 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	handle->params.auto_ds = auto_ds;
 	if (params)
 		handle->params.auto_ds = params->auto_ds;
+	handle->params.net_rx = net_rx;
+	if (params)
+		handle->params.net_rx = params->net_rx;
+
+	handle->params.amsdu_deaggr = amsdu_deaggr;
+	if (params)
+		handle->params.amsdu_deaggr = params->amsdu_deaggr;
+
+	handle->params.ext_scan = ext_scan;
+	if (params)
+		handle->params.ext_scan = params->ext_scan;
+
 	handle->params.ps_mode = ps_mode;
 	handle->params.p2a_scan = p2a_scan;
 	handle->params.scan_chan_gap = scan_chan_gap;
+	handle->params.sched_scan = sched_scan;
 	handle->params.max_tx_buf = max_tx_buf;
 	if (params) {
 		handle->params.ps_mode = params->ps_mode;
 		handle->params.max_tx_buf = params->max_tx_buf;
 		handle->params.p2a_scan = params->p2a_scan;
 		handle->params.scan_chan_gap = params->scan_chan_gap;
+		handle->params.sched_scan = params->sched_scan;
 	}
 #if defined(SDIO)
 	if (intmode)
@@ -1288,9 +1619,9 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	if (params)
 		handle->params.gpiopin = params->gpiopin;
 #endif
-#if defined(SDIO) && defined(SDIO_SUSPEND_RESUME)
 	if (pm_keep_power)
 		moal_extflg_set(handle, EXT_PM_KEEP_POWER);
+#if defined(SDIO) && defined(SDIO_SUSPEND_RESUME)
 	if (shutdown_hs)
 		moal_extflg_set(handle, EXT_SHUTDOWN_HS);
 #endif
@@ -1301,6 +1632,8 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 #endif
 #if defined(SDIO)
 	handle->params.slew_rate = slew_rate;
+	if (params)
+		handle->params.slew_rate = params->slew_rate;
 #endif
 	woal_dup_string(&handle->params.dpd_data_cfg, dpd_data_cfg);
 	if (params)
@@ -1317,8 +1650,9 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	if (params)
 		woal_dup_string(&handle->params.txpwrlimit_cfg,
 				params->txpwrlimit_cfg);
-	if (cntry_txpwr)
-		moal_extflg_set(handle, EXT_CNTRY_TXPWR);
+	handle->params.cntry_txpwr = cntry_txpwr;
+	if (params)
+		handle->params.cntry_txpwr = params->cntry_txpwr;
 	woal_dup_string(&handle->params.init_hostcmd_cfg, init_hostcmd_cfg);
 	if (params)
 		woal_dup_string(&handle->params.init_hostcmd_cfg,
@@ -1354,6 +1688,9 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	handle->params.pcie_int_mode = pcie_int_mode;
 	if (params)
 		handle->params.pcie_int_mode = params->pcie_int_mode;
+	handle->params.ring_size = ring_size;
+	if (params)
+		handle->params.ring_size = params->ring_size;
 #endif /* PCIE */
 	if (low_power_mode_enable)
 		moal_extflg_set(handle, EXT_LOW_PW_MODE);
@@ -1370,14 +1707,8 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	if (sdio_rx_aggr)
 		moal_extflg_set(handle, EXT_SDIO_RX_AGGR);
 #endif
-#if defined(SD8997) || defined(PCIE8997) || defined(USB8997) ||                \
-	defined(SD8977) || defined(SD8987) || defined(SD9098) ||               \
-	defined(USB9098) || defined(PCIE9098) || defined(SD9097) ||            \
-	defined(USB9097) || defined(PCIE9097) || defined(SD8978) ||            \
-	defined(USB8978)
 	if (pmic)
 		moal_extflg_set(handle, EXT_PMIC);
-#endif
 	handle->params.antcfg = antcfg;
 	if (params)
 		handle->params.antcfg = params->antcfg;
@@ -1415,16 +1746,41 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 	}
 	if (napi)
 		moal_extflg_set(handle, EXT_NAPI);
+	if (tx_work)
+		moal_extflg_set(handle, EXT_TX_WORK);
+
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	handle->params.rps = rps & RPS_CPU_MASK;
+	PRINTM(MMSG, "rps set to %x from module param\n", handle->params.rps);
+#endif
+#endif
+
+	if (tx_skb_clone)
+		moal_extflg_set(handle, EXT_TX_SKB_CLONE);
+	if (pmqos)
+		moal_extflg_set(handle, EXT_PMQOS);
+
+	if (chan_track)
+		moal_extflg_set(handle, EXT_CHAN_TRACK);
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	if (dfs_offload)
 		moal_extflg_set(handle, EXT_DFS_OFFLOAD);
 #endif
+	if (roamoffload_in_hs)
+		moal_extflg_set(handle, EXT_ROAMOFFLOAD_IN_HS);
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	if (host_mlme)
 		moal_extflg_set(handle, EXT_HOST_MLME);
 #endif
 #endif
+	if (cfg80211_drcs)
+		moal_extflg_set(handle, EXT_CFG80211_DRCS);
+	handle->params.drcs_chantime_mode = drcs_chantime_mode;
+	if (params)
+		handle->params.drcs_chantime_mode = params->drcs_chantime_mode;
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	if (disable_regd_by_driver)
 		moal_extflg_set(handle, EXT_DISABLE_REGD_BY_DRIVER);
@@ -1463,6 +1819,8 @@ static void woal_setup_module_param(moal_handle *handle, moal_mod_para *params)
 		if (params)
 			handle->params.dfs53cfg = params->dfs53cfg;
 	}
+	handle->params.keep_previous_scan = keep_previous_scan;
+	handle->params.auto_11ax = auto_11ax;
 }
 
 /**
@@ -1480,6 +1838,11 @@ void woal_free_module_param(moal_handle *handle)
 		kfree(params->fw_name);
 		params->fw_name = NULL;
 	}
+	if (params->hw_name) {
+		kfree(params->hw_name);
+		params->hw_name = NULL;
+	}
+
 	if (params->mac_addr) {
 		kfree(params->mac_addr);
 		params->mac_addr = NULL;
@@ -1544,6 +1907,7 @@ static mlan_status woal_req_mod_param(moal_handle *handle, char *mod_file)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	struct device *dev = handle->hotplug_device;
+	int status;
 
 	if (dev == NULL) {
 		PRINTM(MERROR, "No device attached\n");
@@ -1551,10 +1915,12 @@ static mlan_status woal_req_mod_param(moal_handle *handle, char *mod_file)
 		goto out;
 	}
 
-	ret = request_firmware(&handle->param_data, mod_file, dev);
-	if (ret < 0)
+	status = request_firmware(&handle->param_data, mod_file, dev);
+	if (status < 0) {
 		PRINTM(MERROR, "Request firmware: %s failed, error: %d\n",
 		       mod_file, ret);
+		ret = MLAN_STATUS_FAILURE;
+	}
 out:
 	return ret;
 }
@@ -1622,6 +1988,47 @@ void woal_init_from_dev_tree(void)
 			}
 		}
 #endif
+		else if (!strncmp(prop->name, "tx_work", strlen("tx_work"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "tx_work=0x%x\n", data);
+				tx_work = data;
+			}
+		}
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		else if (!strncmp(prop->name, "rps", strlen("rps"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "rps=0x%x\n", data);
+				rps = data;
+			}
+		}
+#endif
+#endif
+		else if (!strncmp(prop->name, "tx_skb_clone",
+				  strlen("tx_skb_clone"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "tx_skb_clone=0x%x\n", data);
+				tx_skb_clone = data;
+			}
+		} else if (!strncmp(prop->name, "pmqos", strlen("pmqos"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "pmqos=0x%x\n", data);
+				pmqos = data;
+			}
+		} else if (!strncmp(prop->name, "mcs32", strlen("mcs32"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "mcs32=0x%x\n", data);
+				mcs32 = data;
+			}
+		}
+
+		else if (!strncmp(prop->name, "hs_auto_arp",
+				  strlen("hs_auto_arp"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "hs_auto_arp=0x%x\n", data);
+				hs_auto_arp = data;
+			}
+		}
 #ifdef MFG_CMD_SUPPORT
 		else if (!strncmp(prop->name, "mfg_mode", strlen("mfg_mode"))) {
 			if (!of_property_read_u32(dt_node, prop->name, &data)) {
@@ -1630,7 +2037,14 @@ void woal_init_from_dev_tree(void)
 			}
 		}
 #endif
-		else if (!strncmp(prop->name, "mac_addr", strlen("mac_addr"))) {
+		else if (!strncmp(prop->name, "rf_test_mode",
+				  strlen("rf_test_mode"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "rf_test_mode=0x%x\n", data);
+				rf_test_mode = data;
+			}
+		} else if (!strncmp(prop->name, "mac_addr",
+				    strlen("mac_addr"))) {
 			if (!of_property_read_string(dt_node, prop->name,
 						     &string_data)) {
 				mac_addr = (char *)string_data;
@@ -1642,6 +2056,12 @@ void woal_init_from_dev_tree(void)
 				fw_name = (char *)string_data;
 				PRINTM(MIOCTL, "fw_name=%s\n", fw_name);
 			}
+		} else if (!strncmp(prop->name, "hw_name", strlen("hw_name"))) {
+			if (!of_property_read_string(dt_node, prop->name,
+						     &string_data)) {
+				hw_name = (char *)string_data;
+				PRINTM(MIOCTL, "hw_name=%s\n", hw_name);
+			}
 		}
 #if defined(STA_WEXT) || defined(UAP_WEXT)
 		else if (!strncmp(prop->name, "cfg80211_wext",
@@ -1711,6 +2131,12 @@ void woal_init_from_dev_tree(void)
 				PRINTM(MIOCTL, "max_vir_bss=0x%x\n", data);
 				max_vir_bss = data;
 			}
+		} else if (!strncmp(prop->name, "cfg80211_drcs",
+				    strlen("cfg80211_drcs"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "cfg80211_drcs=0x%x\n", data);
+				cfg80211_drcs = data;
+			}
 		}
 #endif
 #endif
@@ -1815,6 +2241,13 @@ void woal_init_from_dev_tree(void)
 				indrstcfg = data;
 				PRINTM(MIOCTL, "indrstcfg=%d\n", indrstcfg);
 			}
+		} else if (!strncmp(prop->name, "drcs_chantime_mode",
+				    strlen("drcs_chantime_mode"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				drcs_chantime_mode = data;
+				PRINTM(MIOCTL, "drcs_chantime_mode=%d\n",
+				       drcs_chantime_mode);
+			}
 		} else if (!strncmp(prop->name, "fixed_beacon_buffer",
 				    strlen("fixed_beacon_buffer"))) {
 			if (!of_property_read_u32(dt_node, prop->name, &data)) {
@@ -1844,8 +2277,15 @@ void woal_init_from_dev_tree(void)
 			}
 		}
 #endif
-		else if (!strncmp(prop->name, "gtk_rekey_offload",
-				  strlen("gtk_rekey_offload"))) {
+		else if (!strncmp(prop->name, "roamoffload_in_hs",
+				  strlen("roamoffload_in_hs"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				roamoffload_in_hs = data;
+				PRINTM(MIOCTL, "roamoffload_in_hs=%d\n",
+				       roamoffload_in_hs);
+			}
+		} else if (!strncmp(prop->name, "gtk_rekey_offload",
+				    strlen("gtk_rekey_offload"))) {
 			if (!of_property_read_u32(dt_node, prop->name, &data)) {
 				gtk_rekey_offload = data;
 				PRINTM(MIOCTL, "gtk_rekey_offload=%d\n",
@@ -1870,7 +2310,55 @@ void woal_init_from_dev_tree(void)
 				PRINTM(MERROR, "uap_max_sta=0x%x\n", data);
 				uap_max_sta = data;
 			}
+		} else if (!strncmp(prop->name, "wacp_mode",
+				    strlen("wacp_mode"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MERROR, "wacp_mode=0x%x\n", data);
+				wacp_mode = data;
+			}
+		}
+#endif
+		else if (!strncmp(prop->name, "mcs32", strlen("mcs32"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MERROR, "mcs32=0x%x\n", data);
+				mcs32 = data;
+			}
+		} else if (!strncmp(prop->name, "sched_scan",
+				    strlen("sched_scan"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MIOCTL, "sched_scan=%d\n", data);
+				sched_scan = data;
+			}
+		} else if (!strncmp(prop->name, "chan_track",
+				    strlen("chan_track"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				chan_track = data;
+				PRINTM(MIOCTL, "chan_track=%d\n", chan_track);
+			}
+		} else if (!strncmp(prop->name, "keep_previous_scan",
+				    strlen("keep_previous_scan"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MERROR, "keep_previous_scan=0x%x\n",
+				       data);
+				keep_previous_scan = data;
+			}
+		} else if (!strncmp(prop->name, "auto_11ax",
+				    strlen("auto_11ax"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MERROR, "auto_11ax=0x%x\n", data);
+				auto_11ax = data;
+			}
+		}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+		else if (!strncmp(prop->name, "mon_filter",
+				  strlen("mon_filter"))) {
+			if (!of_property_read_u32(dt_node, prop->name, &data)) {
+				PRINTM(MERROR, "mon_filter=0x%x\n", data);
+				mon_filter = data;
+			}
 		}
+#endif
 #endif
 	}
 	LEAVE();
@@ -1885,7 +2373,7 @@ void woal_init_from_dev_tree(void)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_validate_cfg_id(moal_handle *handle)
+static mlan_status woal_validate_cfg_id(moal_handle *handle)
 {
 	int i;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
@@ -1909,16 +2397,16 @@ mlan_status woal_validate_cfg_id(moal_handle *handle)
  *
  *  @return       MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status parse_skip_cfg_block(t_u8 *data, t_u32 size)
+static mlan_status parse_skip_cfg_block(t_u8 *data, t_u32 size)
 {
 	int end = 0;
 	t_u8 line[MAX_LINE_LEN];
-	while (parse_cfg_get_line(data, size, line) != -1) {
+	while ((int)parse_cfg_get_line(data, size, line) != -1) {
 		if (strncmp(line, "}", strlen("}")) == 0) {
 			end = 1;
 			break;
 		}
-		if (end == 0 && strstr(line, "{") != 0)
+		if (end == 0 && strstr(line, "{") != NULL)
 			break;
 	}
 	return (end == 1) ? MLAN_STATUS_SUCCESS : MLAN_STATUS_FAILURE;
@@ -1932,7 +2420,7 @@ mlan_status parse_skip_cfg_block(t_u8 *data, t_u32 size)
  *
  *  @return       MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_cfg_fallback_process(moal_handle *handle)
+static mlan_status woal_cfg_fallback_process(moal_handle *handle)
 {
 	int i, blk_id = 0x7fffffff, idx = -1;
 	mlan_status ret = MLAN_STATUS_FAILURE;
@@ -1998,7 +2486,7 @@ mlan_status woal_init_module_param(moal_handle *handle)
 	       card_type_map_tbl[i].name);
 	size = handle->param_data->size;
 	data = (t_u8 *)handle->param_data->data;
-	while (parse_cfg_get_line(data, size, line) != -1) {
+	while ((int)parse_cfg_get_line(data, size, line) != -1) {
 		if (line[0] == '#')
 			continue;
 		if (strstr(line, "={")) {
@@ -2014,7 +2502,8 @@ mlan_status woal_init_module_param(moal_handle *handle)
 				if (blk_id == NULL)
 					handle->blk_id = 0;
 				else
-					woal_atoi(&handle->blk_id, blk_id);
+					(void)woal_atoi(&handle->blk_id,
+							blk_id);
 				PRINTM(MINFO,
 				       "Validation check, %s, config block: %d\n",
 				       card_type, handle->blk_id);
@@ -2047,7 +2536,7 @@ mlan_status woal_init_module_param(moal_handle *handle)
 	if (handle->param_data) {
 		release_firmware(handle->param_data);
 		/* rewind pos */
-		parse_cfg_get_line(NULL, 0, NULL);
+		(void)parse_cfg_get_line(NULL, 0, NULL);
 	}
 	if (ret != MLAN_STATUS_SUCCESS) {
 		PRINTM(MERROR, "Invalid block: %s\n", line);
@@ -2065,6 +2554,9 @@ MODULE_PARM_DESC(hw_test, "0: Disable hardware test; 1: Enable hardware test");
 module_param(dts_enable, int, 0);
 MODULE_PARM_DESC(dts_enable, "0: Disable DTS; 1: Enable DTS");
 #endif
+module_param(hw_name, charp, 0660);
+MODULE_PARM_DESC(hw_name, "hardware name");
+
 module_param(fw_name, charp, 0660);
 MODULE_PARM_DESC(fw_name, "Firmware name");
 module_param(req_fw_nowait, int, 0);
@@ -2074,6 +2566,14 @@ MODULE_PARM_DESC(
 module_param(fw_reload, int, 0);
 MODULE_PARM_DESC(fw_reload,
 		 "0: disable fw_reload; 1: enable fw reload feature");
+module_param(auto_fw_reload, int, 0);
+#ifdef PCIE
+MODULE_PARM_DESC(auto_fw_reload,
+		 "BIT0: enable auto fw_reload; BIT1:enable PCIe in-band reset");
+#else
+MODULE_PARM_DESC(auto_fw_reload, "BIT0: enable auto fw_reload");
+#endif
+
 module_param(fw_serial, int, 0);
 MODULE_PARM_DESC(
 	fw_serial,
@@ -2085,8 +2585,13 @@ module_param(mfg_mode, int, 0660);
 MODULE_PARM_DESC(mfg_mode,
 		 "0: Download normal firmware; 1: Download MFG firmware");
 #endif /* MFG_CMD_SUPPORT */
+module_param(rf_test_mode, int, 0660);
+MODULE_PARM_DESC(
+	rf_test_mode,
+	"0: Download normal firmware; 1: Download RF_TEST_MODE firmware");
 module_param(drv_mode, int, 0660);
-MODULE_PARM_DESC(drv_mode, "Bit 0: STA; Bit 1: uAP; Bit 2: WIFIDIRECT");
+MODULE_PARM_DESC(drv_mode,
+		 "Bit 0: STA; Bit 1: uAP; Bit 2: WIFIDIRECT; Bit 7: ZERO_DFS");
 
 #ifdef STA_SUPPORT
 module_param(max_sta_bss, int, 0);
@@ -2118,6 +2623,10 @@ module_param(auto_ds, int, 0660);
 MODULE_PARM_DESC(
 	auto_ds,
 	"0: MLAN default; 1: Enable auto deep sleep; 2: Disable auto deep sleep");
+module_param(ext_scan, int, 0660);
+MODULE_PARM_DESC(
+	ext_scan,
+	"0: MLAN default; 1: Enable Extended Scan; 2: Enable Enhanced Extended Scan");
 module_param(ps_mode, int, 0660);
 MODULE_PARM_DESC(
 	ps_mode,
@@ -2130,6 +2639,9 @@ module_param(scan_chan_gap, int, 0660);
 MODULE_PARM_DESC(
 	scan_chan_gap,
 	"Time gap between two scans in milliseconds when connected to AP(max value 500ms)");
+module_param(sched_scan, int, 0);
+MODULE_PARM_DESC(sched_scan,
+		 "0: disable sched_scan; 1: enable sched_scan default");
 module_param(max_tx_buf, int, 0);
 MODULE_PARM_DESC(max_tx_buf, "Maximum Tx buffer size (2048/4096/8192)");
 
@@ -2140,9 +2652,9 @@ module_param(gpiopin, int, 0);
 MODULE_PARM_DESC(gpiopin, "255:new GPIO int mode, other vlue: gpio pin number");
 #endif
 
-#ifdef SDIO_SUSPEND_RESUME
 module_param(pm_keep_power, int, 0);
 MODULE_PARM_DESC(pm_keep_power, "1: PM keep power; 0: PM no power");
+#ifdef SDIO_SUSPEND_RESUME
 module_param(shutdown_hs, int, 0);
 MODULE_PARM_DESC(shutdown_hs,
 		 "1: Enable HS when shutdown; 0: No HS when shutdown");
@@ -2158,6 +2670,26 @@ MODULE_PARM_DESC(
 	slew_rate,
 	"0:has the slowest slew rate, then 01, then 02, and 03 has the highest slew rate");
 #endif
+module_param(tx_work, uint, 0660);
+MODULE_PARM_DESC(tx_work, "1: Enable tx_work; 0: Disable tx_work");
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+module_param(rps, uint, 0660);
+MODULE_PARM_DESC(
+	rps,
+	"bit0-bit4(0x1 - 0xf): Enables rps on specific cpu ; 0: Disables rps");
+#endif
+#endif
+module_param(tx_skb_clone, uint, 0660);
+MODULE_PARM_DESC(tx_skb_clone,
+		 "1: Enable tx_skb_clone; 0: Disable tx_skb_clone");
+module_param(pmqos, uint, 0660);
+MODULE_PARM_DESC(pmqos, "1: Enable pmqos; 0: Disable pmqos");
+module_param(mcs32, uint, 0660);
+MODULE_PARM_DESC(mcs32, "1: Enable mcs32; 0: Disable mcs32");
+module_param(hs_auto_arp, uint, 0660);
+MODULE_PARM_DESC(hs_auto_arp, "1: Enable hs_auto_arp; 0: Disable hs_auto_arp");
+
 module_param(dpd_data_cfg, charp, 0);
 MODULE_PARM_DESC(dpd_data_cfg, "DPD data file name");
 module_param(init_cfg, charp, 0);
@@ -2170,26 +2702,19 @@ MODULE_PARM_DESC(txpwrlimit_cfg,
 module_param(cntry_txpwr, int, 0);
 MODULE_PARM_DESC(
 	cntry_txpwr,
-	"Allow setting tx power table of country; 0: disable (default), 1: enable.");
+	"0: disable (default), 1: enable set country txpower table 2: enable set country rgpower table");
 module_param(init_hostcmd_cfg, charp, 0);
 MODULE_PARM_DESC(init_hostcmd_cfg, "Init hostcmd file name");
 module_param(band_steer_cfg, charp, 0);
 MODULE_PARM_DESC(band_steer_cfg, "band steer cfg file name");
 module_param(cfg80211_wext, int, 0660);
-MODULE_PARM_DESC(cfg80211_wext,
-#ifdef STA_WEXT
-		 "Bit 0: STA WEXT; "
-#endif
-#ifdef UAP_WEXT
-		 "Bit 1: UAP WEXT; "
-#endif
-#ifdef STA_CFG80211
-		 "Bit 2: STA CFG80211; "
-#endif
-#ifdef UAP_CFG80211
-		 "Bit 3: UAP CFG80211;"
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+MODULE_PARM_DESC(
+	cfg80211_wext,
+	"Bit 0: STA WEXT Bit 1: UAP WEXT Bit 2: STA CFG80211 Bit 3: UAP CFG80211");
+#else
+MODULE_PARM_DESC(cfg80211_wext, "Bit 0: STA WEXT Bit 1: UAP WEXT Bit 2");
 #endif
-);
 #if defined(USB)
 module_param(skip_fwdnld, int, 0);
 MODULE_PARM_DESC(skip_fwdnld, "0: Enable FW download; 1: Disable FW download");
@@ -2213,6 +2738,9 @@ MODULE_PARM_DESC(usb_aggr,
 		 "0: MLAN default; 1: Enable USB aggr; 2: Disable USB aggr");
 #endif
 #ifdef PCIE
+module_param(ring_size, int, 0);
+MODULE_PARM_DESC(ring_size,
+		 "adma dma ring size: 32/64/128/256/512, default 128");
 module_param(pcie_int_mode, int, 0);
 MODULE_PARM_DESC(pcie_int_mode, "0: Legacy mode; 1: MSI mode; 2: MSI-X mode");
 #endif /* PCIE */
@@ -2226,6 +2754,12 @@ MODULE_PARM_DESC(wakelock_timeout, "set wakelock_timeout value (ms)");
 
 module_param(dev_cap_mask, uint, 0);
 MODULE_PARM_DESC(dev_cap_mask, "Device capability mask");
+module_param(net_rx, int, 0);
+MODULE_PARM_DESC(net_rx,
+		 "0: use netif_rx_ni in rx; 1: use netif_receive_skb in rx");
+module_param(amsdu_deaggr, int, 0);
+MODULE_PARM_DESC(amsdu_deaggr,
+		 "0: default; 1: Try to avoid buf copy in amsud deaggregation");
 
 #ifdef SDIO
 module_param(sdio_rx_aggr, int, 0);
@@ -2298,15 +2832,33 @@ module_param(dfs_offload, int, 0);
 MODULE_PARM_DESC(dfs_offload, "1: enable dfs offload; 0: disable dfs offload.");
 #endif
 
+module_param(drcs_chantime_mode, int, 0);
+MODULE_PARM_DESC(
+	drcs_chantime_mode,
+	"0: use default value;Bit31~Bit24:Channel time for channel index0;Bit23~Bit16:mode for channel index0;Bit15~Bit8:Channel time for channel index1;Bit7~Bit0:mode for channel index1; mode:0--PM1,1--Null2Self.");
+module_param(cfg80211_drcs, int, 0);
+MODULE_PARM_DESC(cfg80211_drcs,
+		 "1: Enable DRCS support; 0: Disable DRCS support");
+
+module_param(roamoffload_in_hs, int, 0);
+MODULE_PARM_DESC(
+	roamoffload_in_hs,
+	"1: enable fw roaming only when host suspend; 0: always enable fw roaming.");
+
 #ifdef UAP_SUPPORT
 module_param(uap_max_sta, int, 0);
 MODULE_PARM_DESC(uap_max_sta, "Maximum station number for UAP/GO.");
+module_param(wacp_mode, int, 0);
+MODULE_PARM_DESC(
+	wacp_mode,
+	"WACP mode for UAP/GO 0: WACP_MODE_DEFAULT; 1: WACP_MODE_1; 2: WACP_MODE_2");
 #endif
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 module_param(host_mlme, int, 0);
-MODULE_PARM_DESC(host_mlme,
-		 "1: Enable Host MLME Support; 0: Disable Host MLME support");
+MODULE_PARM_DESC(
+	host_mlme,
+	"1: Enable Host MLME Support (Default); 0: Disable Host MLME support");
 #endif
 #endif
 
@@ -2330,3 +2882,25 @@ MODULE_PARM_DESC(beacon_hints,
 
 module_param(dfs53cfg, int, 0);
 MODULE_PARM_DESC(dfs53cfg, "0: fw default; 1: new w53 dfs; 2: old w53 dfs");
+
+module_param(chan_track, int, 0);
+MODULE_PARM_DESC(
+	chan_track,
+	"1: Set channel tracking; 0: Restore channel tracking for 9098 only");
+
+module_param(keep_previous_scan, int, 0);
+MODULE_PARM_DESC(
+	keep_previous_scan,
+	"1: keep previous scan result; 0: flush previous scan result before start scan ");
+
+module_param(auto_11ax, int, 0);
+MODULE_PARM_DESC(auto_11ax, "1: enable auto_11ax; 0: disable auto_11ax ");
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+module_param(mon_filter, int, 0);
+MODULE_PARM_DESC(
+	mon_filter,
+	"Bit6:TX frames excluding control; Bit5:non-bss beacons; Bit3:unicast destined non-promiscuous frames only; Bit2:data frames; Bit1:control frames; Bit0:management frames");
+#endif
+#endif
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_ioctl.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_ioctl.c
old mode 100644
new mode 100755
index a6df8c052..8a98b3177
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_ioctl.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_ioctl.c
@@ -3,7 +3,7 @@
  * @brief This file contains ioctl function to MLAN
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -76,6 +76,7 @@ typedef struct _region_code_mapping_t {
 
 /** Region code mapping table */
 static region_code_mapping_t region_code_mapping[] = {
+	{"00", 0x00}, /* World       */
 	{"US", 0x10}, /* US FCC      */
 	{"CA", 0x20}, /* IC Canada   */
 	{"SG", 0x10}, /* Singapore   */
@@ -94,6 +95,7 @@ static region_code_mapping_t region_code_mapping[] = {
 
 /** EEPROM Region code mapping table */
 static region_code_mapping_t hw_region_code_mapping[] = {
+	{"00 ", 0x00}, /* World       */
 	{"US ", 0x10}, /* US FCC      */
 	{"CA ", 0x20}, /* IC Canada   */
 	{"KR ", 0x30}, /* Korea       */
@@ -106,10 +108,16 @@ static region_code_mapping_t hw_region_code_mapping[] = {
 
 /** Country code for ETSI */
 static t_u8 eu_country_code_table[][COUNTRY_CODE_LEN] = {
-	"AL", "AD", "AT", "AU", "BY", "BE", "BA", "BG", "HR", "CY", "CZ", "DK",
-	"EE", "FI", "FR", "MK", "DE", "GR", "HU", "IS", "IE", "IT", "KR", "LV",
-	"LI", "LT", "LU", "MT", "MD", "MC", "ME", "NL", "NO", "PL", "RO", "RU",
-	"SM", "RS", "SI", "SK", "ES", "SE", "CH", "TR", "UA", "UK", "GB", "NE"};
+	"AL", "AD", "AT", "AU", "BE", "BA", "BG", "HR", "CY", "CZ", "DK", "EE",
+	"FI", "FR", "MK", "DE", "GR", "HU", "IS", "IE", "IT", "LV", "LI", "LT",
+	"LU", "MT", "MD", "MC", "ME", "NL", "NO", "PL", "RO", "SM", "RS", "SI",
+	"SK", "ES", "SE", "CH", "TR", "UA", "UK", "GB", "NE", "NZ", "DZ", "AO",
+	"AM", "AW", "BH", "BD", "BT", "BO", "BQ", "BW", "VG", "BF", "BI", "KH",
+	"CL", "KM", "CG", "CD", "CW", "EG", "FO", "GF", "PF", "GE", "GI", "GP",
+	"HK", "IN", "ID", "IM", "IL", "JE", "KE", "XK", "KW", "LA", "LR", "MW",
+	"MV", "MQ", "MR", "YT", "MA", "MZ", "MM", "NA", "NC", "NG", "OM", "PS",
+	"PT", "QA", "RW", "RE", "BL", "MF", "VC", "SA", "SC", "ZA", "SZ", "SY",
+	"TZ", "TG", "TN", "AE", "VA", "EH", "YE", "ZM", "ZW"};
 
 /********************************************************
 			Global Variables
@@ -126,11 +134,6 @@ extern const struct net_device_ops woal_netdev_ops;
 #endif
 #endif
 
-#ifdef MFG_CMD_SUPPORT
-/** Mfg mode */
-extern int mfg_mode;
-#endif
-
 /********************************************************
 			Local Functions
 ********************************************************/
@@ -141,7 +144,7 @@ extern int mfg_mode;
  *
  *  @return                 Region code
  */
-t_bool woal_is_country_code_supported(t_u8 *country_code)
+static t_bool woal_is_country_code_supported(t_u8 *country_code)
 {
 	t_u8 i;
 	ENTER();
@@ -166,7 +169,7 @@ t_bool woal_is_country_code_supported(t_u8 *country_code)
  *
  *  @return                 Region code
  */
-t_u8 region_string_2_region_code(char *region_string)
+static t_u8 region_string_2_region_code(char *region_string)
 {
 	t_u8 i;
 
@@ -255,12 +258,22 @@ t_u8 woal_is_valid_alpha2(char *alpha2)
 /**
  * @brief Get second channel offset
  *
+ * @param priv         A pointer to moal_private structure
  * @param chan             channel num
  * @return                second channel offset
  */
-t_u8 woal_get_second_channel_offset(int chan)
+t_u8 woal_get_second_channel_offset(moal_private *priv, int chan)
 {
 	t_u8 chan2Offset = SEC_CHAN_NONE;
+	mlan_bss_info bss_info;
+
+	memset(&bss_info, 0, sizeof(bss_info));
+	/* Special Case: 20Mhz-only Channel */
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info))
+		return chan2Offset;
+	if (bss_info.region_code != COUNTRY_CODE_US && chan == 165)
+		return chan2Offset;
 
 	switch (chan) {
 	case 36:
@@ -275,6 +288,8 @@ t_u8 woal_get_second_channel_offset(int chan)
 	case 140:
 	case 149:
 	case 157:
+	case 165:
+	case 173:
 		chan2Offset = SEC_CHAN_ABOVE;
 		break;
 	case 40:
@@ -289,12 +304,10 @@ t_u8 woal_get_second_channel_offset(int chan)
 	case 144:
 	case 153:
 	case 161:
+	case 169:
+	case 177:
 		chan2Offset = SEC_CHAN_BELOW;
 		break;
-	case 165:
-		/* Special Case: 20Mhz-only Channel */
-		chan2Offset = SEC_CHAN_NONE;
-		break;
 	}
 	return chan2Offset;
 }
@@ -310,7 +323,7 @@ t_u8 woal_get_second_channel_offset(int chan)
 static inline void woal_copy_mc_addr(mlan_multicast_list *mlist,
 				     mlan_802_11_mac_addr mac)
 {
-	int i = 0;
+	t_u32 i = 0;
 	for (i = 0; i < mlist->num_multicast_addr; i++) {
 		if (!memcmp(&mlist->mac_list[i], mac, ETH_ALEN))
 			return;
@@ -629,7 +642,8 @@ mlan_status woal_request_ioctl(moal_private *priv, mlan_ioctl_req *req,
 
 	sub_command = *(t_u32 *)req->pbuf;
 
-	if (sub_command != MLAN_OID_GET_DEBUG_INFO) {
+	if (sub_command != MLAN_OID_GET_DEBUG_INFO &&
+	    sub_command != MLAN_OID_MISC_WARM_RESET) {
 		if (priv->phandle->surprise_removed == MTRUE ||
 		    priv->phandle->driver_status) {
 			PRINTM(MCMND,
@@ -644,7 +658,7 @@ mlan_status woal_request_ioctl(moal_private *priv, mlan_ioctl_req *req,
 		}
 #ifdef MFG_CMD_SUPPORT
 		if (mfg_mode && sub_command != MLAN_OID_MISC_HOST_CMD) {
-			PRINTM(MCMND, "IOCTL is not allowed while suspended\n");
+			PRINTM(MCMND, "Only HOST_CMD allowed in MFG mode\n");
 			LEAVE();
 			return MLAN_STATUS_FAILURE;
 		}
@@ -670,6 +684,8 @@ mlan_status woal_request_ioctl(moal_private *priv, mlan_ioctl_req *req,
 				priv->phandle->cac_period_jiffies -
 				(jiffies - priv->phandle->meas_start_jiffies);
 		}
+		if (priv->phandle->cac_restart)
+			cac_left_jiffies = DEF_CAC_DWELL_TIME * HZ / 1000;
 		if (cac_left_jiffies < 0) {
 			/* Avoid driver hang in FW died during CAC measure
 			 * period */
@@ -845,8 +861,12 @@ mlan_status woal_request_set_mac_address(moal_private *priv, t_u8 wait_option)
 		       "set mac address failed! status=%d, error_code=0x%x\n",
 		       status, req->status_code);
 	} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+		eth_hw_addr_set(priv->netdev, priv->current_addr);
+#else
 		moal_memcpy_ext(priv->phandle, priv->netdev->dev_addr,
 				priv->current_addr, ETH_ALEN, ETH_ALEN);
+#endif
 		HEXDUMP("priv->MacAddr:", priv->current_addr, ETH_ALEN);
 	}
 done:
@@ -897,9 +917,9 @@ void woal_request_set_multicast_list(moal_private *priv, struct net_device *dev)
 		if (mc_count > MLAN_MAX_MULTICAST_LIST_SIZE)
 			bss->param.multicast_list.mode = MLAN_ALL_MULTI_MODE;
 	}
-
+	PRINTM(MCMND, "%s set multicast_list\n", dev->name);
 	/* Send IOCTL request to MLAN */
-	status = woal_request_ioctl(priv, req, MOAL_NO_WAIT);
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
 done:
@@ -954,6 +974,8 @@ mlan_status woal_disconnect(moal_private *priv, t_u8 wait_option, t_u8 *mac,
 #ifdef REASSOCIATION
 	priv->reassoc_required = MFALSE;
 #endif /* REASSOCIATION */
+	priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+	priv->auto_assoc_priv.drv_reconnect.status = MFALSE;
 	LEAVE();
 	return status;
 }
@@ -1010,6 +1032,202 @@ int woal_priv_get_nonglobal_operclass_by_bw_channel(moal_private *priv,
 }
 #endif
 
+#ifdef UAP_SUPPORT
+/**
+ *  @brief Check current uap/go connection status
+ *         Need handle channel switch if current channel is DFS channel
+ *
+ *  @param priv          A pointer to moal_private structure
+ *  @param wait_option          Wait option
+ *  @param new channel          new channel
+ *  @return              N/A
+ */
+static void woal_check_uap_dfs_status(moal_private *priv, t_u8 wait_option,
+				      t_u8 new_channel)
+{
+	chan_band_info channel;
+	mlan_bss_info bss_info;
+#if defined(UAP_SUPPORT)
+	IEEEtypes_ChanSwitchAnn_t *chan_switch = NULL;
+	IEEEtypes_ExtChanSwitchAnn_t *ext_chan_switch = NULL;
+	custom_ie *pcust_chansw_ie = NULL;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	t_u8 bw = 0, oper_class = 0;
+#endif
+
+	/* Get BSS information */
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, wait_option, &bss_info))
+		goto done;
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_set_get_ap_channel(priv, MLAN_ACT_GET, wait_option, &channel))
+		goto done;
+	PRINTM(MCMND, "is_11h_active=%d dfs_check_channel=%d\n",
+	       bss_info.is_11h_active, bss_info.dfs_check_channel);
+	PRINTM(MCMND, "uap current channel=%d new_channel=%d\n",
+	       channel.channel, new_channel);
+#if defined(UAP_SUPPORT)
+	if (new_channel == channel.channel)
+		goto done;
+	if (bss_info.is_11h_active &&
+	    (bss_info.dfs_check_channel == channel.channel)) {
+		if (new_channel < MAX_BG_CHANNEL) {
+			bw = 20;
+		} else {
+			switch (channel.bandcfg.chanWidth) {
+			case CHAN_BW_20MHZ:
+				bw = 20;
+				break;
+			case CHAN_BW_40MHZ:
+				bw = 40;
+				break;
+			case CHAN_BW_80MHZ:
+				bw = 80;
+				break;
+			default:
+				break;
+			}
+		}
+		woal_priv_get_nonglobal_operclass_by_bw_channel(
+			priv, bw, new_channel, &oper_class);
+		PRINTM(MCMND,
+		       "Switch the uap channel from %d to %d, oper_class=%d bw=%d\n",
+		       channel.channel, new_channel, oper_class, bw);
+		ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+		if (ioctl_req) {
+			misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+			misc->sub_command = MLAN_OID_MISC_CUSTOM_IE;
+			ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+			ioctl_req->action = MLAN_ACT_SET;
+			misc->param.cust_ie.type = TLV_TYPE_MGMT_IE;
+			misc->param.cust_ie.len =
+				sizeof(custom_ie) - MAX_IE_SIZE;
+			pcust_chansw_ie = (custom_ie *)&misc->param.cust_ie
+						  .ie_data_list[0];
+			pcust_chansw_ie->ie_index = 0xffff; /*Auto index */
+			if (!oper_class) {
+				pcust_chansw_ie->ie_length =
+					sizeof(IEEEtypes_ChanSwitchAnn_t);
+				pcust_chansw_ie->mgmt_subtype_mask =
+					MGMT_MASK_BEACON |
+					MGMT_MASK_PROBE_RESP; /*Add IE for
+								 BEACON/probe
+								 resp*/
+				chan_switch =
+					(IEEEtypes_ChanSwitchAnn_t *)
+						pcust_chansw_ie->ie_buffer;
+				chan_switch->element_id = CHANNEL_SWITCH_ANN;
+				chan_switch->len =
+					sizeof(IEEEtypes_ChanSwitchAnn_t) -
+					sizeof(IEEEtypes_Header_t);
+				chan_switch->chan_switch_mode = 1; /* STA should
+								      not
+								      transmit
+								    */
+				chan_switch->new_channel_num = new_channel;
+				chan_switch->chan_switch_count =
+					DEF_CHAN_SWITCH_COUNT;
+				DBG_HEXDUMP(MCMD_D, "CSA IE",
+					    (t_u8 *)pcust_chansw_ie->ie_buffer,
+					    pcust_chansw_ie->ie_length);
+			} else {
+				pcust_chansw_ie->ie_length =
+					sizeof(IEEEtypes_ExtChanSwitchAnn_t);
+				pcust_chansw_ie->mgmt_subtype_mask =
+					MGMT_MASK_BEACON |
+					MGMT_MASK_PROBE_RESP; /*Add IE for
+								 BEACON/probe
+								 resp*/
+				ext_chan_switch =
+					(IEEEtypes_ExtChanSwitchAnn_t *)
+						pcust_chansw_ie->ie_buffer;
+				ext_chan_switch->element_id =
+					EXTEND_CHANNEL_SWITCH_ANN;
+				ext_chan_switch->len =
+					sizeof(IEEEtypes_ExtChanSwitchAnn_t) -
+					sizeof(IEEEtypes_Header_t);
+				ext_chan_switch->chan_switch_mode =
+					1; /* STA should not transmit */
+				ext_chan_switch->new_channel_num = new_channel;
+				ext_chan_switch->chan_switch_count =
+					DEF_CHAN_SWITCH_COUNT;
+				ext_chan_switch->new_oper_class = oper_class;
+				DBG_HEXDUMP(MCMD_D, "ECSA IE",
+					    (t_u8 *)pcust_chansw_ie->ie_buffer,
+					    pcust_chansw_ie->ie_length);
+			}
+			status = woal_request_ioctl(priv, ioctl_req,
+						    wait_option);
+			if (status != MLAN_STATUS_SUCCESS) {
+				PRINTM(MERROR, "Failed to set CSA IE\n");
+				goto done;
+			}
+			PRINTM(MCMND, "CSA/ECSA ie index=%d\n",
+			       pcust_chansw_ie->ie_index);
+			priv->phandle->chsw_wait_q_woken = MFALSE;
+			/* wait for channel switch to complete  */
+			wait_event_interruptible_timeout(
+				priv->phandle->chsw_wait_q,
+				priv->phandle->chsw_wait_q_woken,
+				(u32)HZ * (DEF_CHAN_SWITCH_COUNT + 2) * 110 /
+					1000);
+
+			pcust_chansw_ie->ie_index = 0xffff;
+			pcust_chansw_ie->mgmt_subtype_mask =
+				MLAN_CUSTOM_IE_DELETE_MASK;
+			status = woal_request_ioctl(priv, ioctl_req,
+						    MOAL_IOCTL_WAIT);
+			if (status != MLAN_STATUS_SUCCESS) {
+				PRINTM(MERROR, "Failed to clear CSA/ECSA IE\n");
+			}
+		}
+	}
+#endif
+done:
+#if defined(UAP_SUPPORT)
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+#endif
+	return;
+}
+
+/**
+ *  @brief Check current multi-channel connections
+ *
+ *  @param priv          A pointer to moal_private structure
+ *  @param wait_option          Wait option
+ *  @param new channel  new channel
+ *
+ *  @return              N/A
+ */
+void woal_check_mc_connection(moal_private *priv, t_u8 wait_option,
+			      t_u8 new_channel)
+{
+	moal_handle *handle = priv->phandle;
+#ifdef UAP_SUPPORT
+	int i;
+#endif
+	t_u16 enable = 0;
+
+	woal_mc_policy_cfg(priv, &enable, wait_option, MLAN_ACT_GET);
+	if (!enable)
+		return;
+#ifdef UAP_SUPPORT
+	for (i = 0; i < handle->priv_num; i++) {
+		if (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_UAP) {
+			if (handle->priv[i]->bss_started == MTRUE)
+				woal_check_uap_dfs_status(handle->priv[i],
+							  wait_option,
+							  new_channel);
+		}
+	}
+#endif
+	return;
+}
+#endif
+
 /**
  *  @brief Send bss_start command to MLAN
  *
@@ -1026,6 +1244,9 @@ mlan_status woal_bss_start(moal_private *priv, t_u8 wait_option,
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_bss *bss = NULL;
 	mlan_status status;
+#ifdef UAP_SUPPORT
+	mlan_ssid_bssid temp_ssid_bssid;
+#endif
 
 	ENTER();
 
@@ -1035,6 +1256,18 @@ mlan_status woal_bss_start(moal_private *priv, t_u8 wait_option,
 		if (netif_carrier_ok(priv->netdev))
 			netif_carrier_off(priv->netdev);
 	}
+#ifdef UAP_SUPPORT
+	if (!ssid_bssid) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+	moal_memcpy_ext(priv->phandle, &temp_ssid_bssid, ssid_bssid,
+			sizeof(mlan_ssid_bssid), sizeof(mlan_ssid_bssid));
+	if (MLAN_STATUS_SUCCESS ==
+	    woal_find_best_network(priv, wait_option, &temp_ssid_bssid))
+		woal_check_mc_connection(priv, wait_option,
+					 temp_ssid_bssid.channel);
+#endif
 
 	/* Allocate an IOCTL request buffer */
 	req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
@@ -1287,7 +1520,7 @@ int woal_pre_warmreset(moal_private *priv)
 #endif
 	woal_cancel_cac_block(priv);
 	/* Reset all interfaces */
-	ret = woal_reset_intf(priv, MOAL_IOCTL_WAIT, MTRUE);
+	woal_reset_intf(priv, MOAL_IOCTL_WAIT, MTRUE);
 	/* Initialize private structures */
 	for (intf_num = 0; intf_num < handle->priv_num; intf_num++) {
 		woal_init_priv(handle->priv[intf_num], MOAL_IOCTL_WAIT);
@@ -1652,7 +1885,7 @@ mlan_status woal_set_get_power_mgmt(moal_private *priv, t_u32 action,
  * @return         MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --success, otherwise
  * fail
  */
-int woal_set_countrycode(moal_private *priv, char *country)
+static int woal_set_countrycode(moal_private *priv, char *country)
 {
 	int ret = 0;
 	mlan_ioctl_req *req = NULL;
@@ -1824,6 +2057,53 @@ mlan_status woal_get_assoc_rsp(moal_private *priv,
 	LEAVE();
 	return ret;
 }
+
+/**
+ *  @brief Get assoc_req IEs buffer
+ *
+ *  @param priv                 A pointer to moal_private structure
+ *  @param assoc_rsp            A pointer to mlan_ds_misc_assoc_rsp structure
+ *  @param wait_option          wait option
+ *
+ *  @return                     MLAN_STATUS_SUCCESS -- success, otherwise fail
+ */
+mlan_status woal_get_assoc_req(moal_private *priv,
+			       mlan_ds_misc_assoc_req *assoc_req,
+			       t_u8 wait_option)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MERROR,
+		       "Fail to allocate buffer for get assoc request\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	misc = (pmlan_ds_misc_cfg)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_ASSOC_REQ;
+	req->action = MLAN_ACT_GET;
+
+	ret = woal_request_ioctl(priv, req, wait_option);
+	if (ret == MLAN_STATUS_SUCCESS && assoc_req)
+		moal_memcpy_ext(priv->phandle, assoc_req,
+				&misc->param.assoc_req,
+				sizeof(mlan_ds_misc_assoc_req),
+				sizeof(mlan_ds_misc_assoc_req));
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
 #endif
 
 /**
@@ -1863,15 +2143,24 @@ mlan_status woal_request_get_fw_info(moal_private *priv, t_u8 wait_option,
 	status = woal_request_ioctl(priv, req, wait_option);
 	if (status == MLAN_STATUS_SUCCESS) {
 		priv->phandle->fw_release_number = info->param.fw_info.fw_ver;
+		priv->phandle->fw_hotfix_version =
+			info->param.fw_info.hotfix_version;
 		priv->phandle->fw_ecsa_enable = info->param.fw_info.ecsa_enable;
+		priv->phandle->fw_bands = info->param.fw_info.fw_bands;
 		priv->phandle->fw_getlog_enable =
 			info->param.fw_info.getlog_enable;
+		priv->phandle->fw_roaming_support =
+			info->param.fw_info.fw_roaming_support;
 		if (priv->current_addr[0] == 0xff)
 			moal_memcpy_ext(priv->phandle, priv->current_addr,
 					&info->param.fw_info.mac_addr,
 					sizeof(mlan_802_11_mac_addr), ETH_ALEN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+		eth_hw_addr_set(priv->netdev, priv->current_addr);
+#else
 		moal_memcpy_ext(priv->phandle, priv->netdev->dev_addr,
 				priv->current_addr, ETH_ALEN, ETH_ALEN);
+#endif
 		if (fw_info)
 			moal_memcpy_ext(priv->phandle, fw_info,
 					&info->param.fw_info,
@@ -1986,7 +2275,6 @@ int woal_request_extcap(moal_private *priv, t_u8 *buf, t_u8 len)
 mlan_status woal_get_debug_info(moal_private *priv, t_u8 wait_option,
 				mlan_debug_info *debug_info)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_get_info *info = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -1996,7 +2284,7 @@ mlan_status woal_get_debug_info(moal_private *priv, t_u8 wait_option,
 	req = woal_alloc_mlan_ioctl_req(sizeof(t_u32) +
 					sizeof(mlan_debug_info));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -2219,7 +2507,7 @@ int woal_custom_ie_ioctl(struct net_device *dev, struct ifreq *req)
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
-	mlan_ds_misc_custom_ie *custom_ie = NULL;
+	mlan_ds_misc_custom_ie *pcustom_ie = NULL;
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	gfp_t flag;
@@ -2234,13 +2522,13 @@ int woal_custom_ie_ioctl(struct net_device *dev, struct ifreq *req)
 	}
 
 	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
-	custom_ie = kzalloc(sizeof(mlan_ds_misc_custom_ie), flag);
-	if (!custom_ie) {
+	pcustom_ie = kzalloc(sizeof(mlan_ds_misc_custom_ie), flag);
+	if (!pcustom_ie) {
 		ret = -ENOMEM;
 		goto done;
 	}
 
-	if (copy_from_user(custom_ie, req->ifr_data,
+	if (copy_from_user(pcustom_ie, req->ifr_data,
 			   sizeof(mlan_ds_misc_custom_ie))) {
 		PRINTM(MERROR, "Copy from user failed\n");
 		ret = -EFAULT;
@@ -2256,13 +2544,13 @@ int woal_custom_ie_ioctl(struct net_device *dev, struct ifreq *req)
 	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
 	misc->sub_command = MLAN_OID_MISC_CUSTOM_IE;
 	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
-	if ((custom_ie->len == 0) ||
-	    (custom_ie->len == sizeof(custom_ie->ie_data_list[0].ie_index)))
+	if ((pcustom_ie->len == 0) ||
+	    (pcustom_ie->len == sizeof(pcustom_ie->ie_data_list[0].ie_index)))
 		ioctl_req->action = MLAN_ACT_GET;
 	else
 		ioctl_req->action = MLAN_ACT_SET;
 
-	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, custom_ie,
+	moal_memcpy_ext(priv->phandle, &misc->param.cust_ie, pcustom_ie,
 			sizeof(mlan_ds_misc_custom_ie),
 			sizeof(mlan_ds_misc_custom_ie));
 
@@ -2287,7 +2575,7 @@ int woal_custom_ie_ioctl(struct net_device *dev, struct ifreq *req)
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(ioctl_req);
-	kfree(custom_ie);
+	kfree(pcustom_ie);
 	LEAVE();
 	return ret;
 }
@@ -2431,6 +2719,88 @@ int woal_set_get_custom_ie(moal_private *priv, t_u16 mask, t_u8 *ie, int ie_len)
 }
 #endif /* defined(HOST_TXRX_MGMT_FRAME) && defined(UAP_WEXT) */
 
+/**
+ *  @brief TDLS configuration ioctl handler
+ *
+ *  @param dev      A pointer to net_device structure
+ *  @param req      A pointer to ifreq structure
+ *  @return         0 --success, otherwise fail
+ */
+int woal_tdls_config_ioctl(struct net_device *dev, struct ifreq *req)
+{
+	moal_private *priv = (moal_private *)netdev_priv(dev);
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_tdls_config *tdls_data = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	gfp_t flag;
+
+	ENTER();
+
+	/* Sanity check */
+	if (req->ifr_data == NULL) {
+		PRINTM(MERROR, "woal_tdls_config_ioctl() corrupt data\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	tdls_data = kzalloc(sizeof(mlan_ds_misc_tdls_config), flag);
+	if (!tdls_data) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	if (copy_from_user(tdls_data, req->ifr_data,
+			   sizeof(mlan_ds_misc_tdls_config))) {
+		PRINTM(MERROR, "Copy from user failed\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_CONFIG;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	if (tdls_data->tdls_action == WLAN_TDLS_DISCOVERY_REQ ||
+	    tdls_data->tdls_action == WLAN_TDLS_LINK_STATUS)
+		ioctl_req->action = MLAN_ACT_GET;
+	else
+		ioctl_req->action = MLAN_ACT_SET;
+
+	moal_memcpy_ext(priv->phandle, &misc->param.tdls_config, tdls_data,
+			sizeof(mlan_ds_misc_tdls_config),
+			sizeof(mlan_ds_misc_tdls_config));
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	if (tdls_data->tdls_action == WLAN_TDLS_DISCOVERY_REQ ||
+	    tdls_data->tdls_action == WLAN_TDLS_LINK_STATUS) {
+		if (copy_to_user(req->ifr_data, &misc->param.tdls_config,
+				 sizeof(mlan_ds_misc_tdls_config))) {
+			PRINTM(MERROR, "Copy to user failed!\n");
+			ret = -EFAULT;
+			goto done;
+		}
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	kfree(tdls_data);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief ioctl function get BSS type
  *
@@ -2595,14 +2965,19 @@ int woal_set_get_bss_role(moal_private *priv, struct iwreq *wrq)
 			ret = -EINVAL;
 			goto done;
 		}
-		if (bss_role == GET_BSS_ROLE(priv)) {
+		if (bss_role == (int)GET_BSS_ROLE(priv)) {
 			PRINTM(MWARN, "Already BSS is in desired role\n");
 			ret = -EINVAL;
 			goto done;
 		}
 		action = MLAN_ACT_SET;
 		/* Reset interface */
-		woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_reset_intf(priv, MOAL_IOCTL_WAIT, MFALSE)) {
+			PRINTM(MERROR, "%s: reset_intf failed \n", __func__);
+			ret = -EFAULT;
+			goto done;
+		}
 	}
 
 	if (MLAN_STATUS_SUCCESS != woal_bss_role_cfg(priv, action,
@@ -2638,59 +3013,443 @@ int woal_set_get_bss_role(moal_private *priv, struct iwreq *wrq)
 #endif /* STA_WEXT || UAP_WEXT */
 #endif /* STA_SUPPORT && UAP_SUPPORT */
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 /**
- *  @brief Set/Get DTIM period
+ *  @brief Enable IPv6 Router Advertisement offload
  *
- *  @param priv                 A pointer to moal_private structure
- *  @param action               Action set or get
- *  @param wait_option          Wait option
- *  @param value                DTIM period
+ *  @param handle  A pointer to moal_handle structure
+ *  @param enable  enable or disable
  *
- *  @return                     MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --
- * success, otherwise fail
+ *  @return        MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success, otherwise
+ * fail
  */
-mlan_status woal_set_get_dtim_period(moal_private *priv, t_u32 action,
-				     t_u8 wait_option, t_u8 *value)
+static mlan_status woal_set_ipv6_ra_offload(moal_handle *handle, t_u8 enable)
 {
-	mlan_ioctl_req *req = NULL;
-	mlan_ds_snmp_mib *mib = NULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	moal_private *priv = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_ipv6_ra_offload *ipv6_ra;
+	int i = 0;
 
 	ENTER();
 
-	/* Allocate an IOCTL request buffer */
-	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_snmp_mib));
+	for (i = 0; i < handle->priv_num && (priv = handle->priv[i]); i++) {
+		if (priv->ipv6_addr_configured)
+			break;
+	}
+
+	if (!priv || !priv->ipv6_addr_configured) {
+		PRINTM(MIOCTL, "No IPv6 address configured\n");
+		goto done;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
+		PRINTM(MIOCTL, "IOCTL req allocated failed!\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
-
-	/* Fill request buffer */
-	mib = (mlan_ds_snmp_mib *)req->pbuf;
-	mib->sub_command = MLAN_OID_SNMP_MIB_DTIM_PERIOD;
-	req->req_id = MLAN_IOCTL_SNMP_MIB;
-	req->action = action;
-
-	if (action == MLAN_ACT_SET)
-		mib->param.dtim_period = *value;
-
-	/* Send IOCTL request to MLAN */
-	ret = woal_request_ioctl(priv, req, wait_option);
-	if (ret == MLAN_STATUS_SUCCESS && action == MLAN_ACT_GET)
-		*value = (t_u8)mib->param.dtim_period;
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_IPV6_RA_OFFLOAD;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	ipv6_ra = &misc->param.ipv6_ra_offload;
+	ipv6_ra->enable = enable;
+	moal_memcpy_ext(priv->phandle, ipv6_ra->ipv6_addr, priv->ipv6_addr, 16,
+			sizeof(ipv6_ra->ipv6_addr));
+	ret = woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_STA), req,
+				 MOAL_NO_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS && ret != MLAN_STATUS_PENDING)
+		PRINTM(MIOCTL, "Set IPv6 RA offload failed\n");
 
 done:
-	if (ret != MLAN_STATUS_PENDING)
+	if (ret != MLAN_STATUS_PENDING && req != NULL)
 		kfree(req);
 	LEAVE();
 	return ret;
 }
+#endif
 
-/**
- *  @brief Get Host Sleep parameters
- *
- *  @param priv         A pointer to moal_private structure
- *  @param action       Action: set or get
+static mlan_status woal_set_wake_on_mdns(moal_handle *handle, t_u8 enable)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_mef_flt_cfg *mef_cfg = NULL;
+	mef_entry_t *entry = NULL;
+	mef_filter_t *filter = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MIOCTL, "IOCTL req allocated failed!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_MEF_FLT_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+
+	mef_cfg = (mlan_ds_misc_mef_flt_cfg *)(&misc->param.mef_flt_cfg);
+	mef_cfg->mef_act_type = MEF_ACT_WOWLAN;
+	mef_cfg->criteria = MBIT(3);
+
+	entry = (mef_entry_t *)&mef_cfg->mef_entry;
+	entry->mode = MBIT(0);
+	entry->action = 3;
+
+	filter = (mef_filter_t *)entry->filter_item;
+	filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT | FILLING_OFFSET |
+			     FILLING_BYTE_SEQ);
+	filter->type = TYPE_BYTE_EQ;
+	filter->repeat = 1;
+	filter->offset = 20;
+	filter->num_byte_seq = 2;
+	moal_memcpy_ext(handle, filter->byte_seq, "\x08\x00", 2,
+			sizeof(filter->byte_seq));
+	entry->rpn[1] = RPN_TYPE_AND;
+
+	filter++;
+	filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT | FILLING_OFFSET |
+			     FILLING_BYTE_SEQ);
+	filter->type = TYPE_BYTE_EQ;
+	filter->repeat = 1;
+	filter->offset = 38;
+	filter->num_bytes = 4;
+	moal_memcpy_ext(handle, filter->byte_seq, "\xe0\x00\x00\xfb", 4,
+			sizeof(filter->byte_seq));
+	entry->rpn[2] = RPN_TYPE_AND;
+	filter++;
+	filter->fill_flag = (FILLING_TYPE | FILLING_PATTERN | FILLING_OFFSET |
+			     FILLING_NUM_BYTES);
+	filter->type = TYPE_BYTE_EQ + 1;
+	filter->pattern = 17;
+	filter->offset = 31;
+	filter->num_bytes = 1;
+	entry->rpn[3] = RPN_TYPE_AND;
+	filter++;
+	filter->fill_flag = (FILLING_TYPE | FILLING_PATTERN | FILLING_OFFSET |
+			     FILLING_NUM_BYTES);
+	filter->type = TYPE_BYTE_EQ + 1;
+	filter->pattern = 5353;
+	filter->offset = 44;
+	filter->num_bytes = 2;
+	filter++;
+	entry->filter_num = 4;
+	if (enable) {
+		mef_cfg->op_code = MLAN_OP_ADD_MDNS;
+	} else {
+		mef_cfg->op_code = MLAN_IPADDR_OP_IP_REMOVE;
+	}
+	ret = woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), req,
+				 MOAL_NO_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS && ret != MLAN_STATUS_PENDING)
+		PRINTM(MIOCTL, "Set Mdns wake up failed! ret=%d\n", ret);
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+/**
+ *  @brief Enable IPv6 Neighbor Solicitation offload
+ *
+ *  @param handle  A pointer to moal_handle structure
+ *  @param enable  enable or disable mef entry
+ *
+ *  @return        MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success, otherwise
+ * fail
+ */
+static mlan_status woal_set_ipv6_ns_offload(moal_handle *handle, t_u8 enable)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_mef_flt_cfg *mef_cfg = NULL;
+	mef_entry_t *entry = NULL;
+	mef_filter_t *filter = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MIOCTL, "IOCTL req allocated failed!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_MEF_FLT_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+
+	mef_cfg = (mlan_ds_misc_mef_flt_cfg *)(&misc->param.mef_flt_cfg);
+	mef_cfg->mef_act_type = MEF_ACT_IPV6_NS;
+	mef_cfg->criteria = (MBIT(1) | MBIT(3));
+
+	entry = (mef_entry_t *)&mef_cfg->mef_entry;
+	entry->mode = MBIT(0);
+	entry->action = 0x40;
+	filter = (mef_filter_t *)entry->filter_item;
+	filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT | FILLING_OFFSET |
+			     FILLING_BYTE_SEQ);
+	filter->type = TYPE_BYTE_EQ;
+	filter->repeat = 1;
+	filter->offset = 20;
+	filter->num_byte_seq = 2;
+	moal_memcpy_ext(handle, filter->byte_seq, "\x86\xdd", 2,
+			sizeof(filter->byte_seq));
+	entry->rpn[1] = RPN_TYPE_AND;
+
+	filter++;
+	filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT | FILLING_OFFSET |
+			     FILLING_BYTE_SEQ);
+	filter->type = TYPE_BYTE_EQ;
+	filter->repeat = 1;
+	filter->offset = 62;
+	filter->num_byte_seq = 1;
+	moal_memcpy_ext(handle, filter->byte_seq, "\x87", 1,
+			sizeof(filter->byte_seq));
+	entry->filter_num = 2;
+	if (enable) {
+		mef_cfg->op_code = MLAN_OP_ADD_IPV6_NS;
+	} else {
+		mef_cfg->op_code = MLAN_IPADDR_OP_IP_REMOVE;
+	}
+	ret = woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), req,
+				 MOAL_NO_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS && ret != MLAN_STATUS_PENDING)
+		PRINTM(MIOCTL, "Set ipv6 ns offload failed! ret=%d\n", ret);
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+#endif
+
+/**
+ *  @brief Set auto arp resp
+ *
+ *  @param handle         A pointer to moal_handle structure
+ *  @param enable         enable/disable
+ *
+ *  @return               MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ * otherwise fail
+ */
+static mlan_status woal_set_auto_arp(moal_handle *handle, t_u8 enable)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int i = 0;
+	moal_private *priv = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_ipaddr_cfg ipaddr_cfg;
+
+	ENTER();
+
+	memset(&ipaddr_cfg, 0, sizeof(ipaddr_cfg));
+	for (i = 0; i < handle->priv_num && (priv = handle->priv[i]); i++) {
+		if (priv && priv->ip_addr_type != IPADDR_TYPE_NONE) {
+			moal_memcpy_ext(
+				handle,
+				ipaddr_cfg.ip_addr[ipaddr_cfg.ip_addr_num],
+				priv->ip_addr, IPADDR_LEN, IPADDR_LEN);
+			ipaddr_cfg.ip_addr_num++;
+		}
+	}
+	if (ipaddr_cfg.ip_addr_num == 0) {
+		PRINTM(MIOCTL, "No IP addr configured.\n");
+		goto done;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MIOCTL, "IOCTL req allocated failed!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_IP_ADDR;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	moal_memcpy_ext(handle, &misc->param.ipaddr_cfg, &ipaddr_cfg,
+			sizeof(ipaddr_cfg), sizeof(misc->param.ipaddr_cfg));
+	if (enable) {
+		misc->param.ipaddr_cfg.op_code = MLAN_IPADDR_OP_ARP_FILTER |
+						 MLAN_IPADDR_OP_AUTO_ARP_RESP;
+		misc->param.ipaddr_cfg.ip_addr_type = IPADDR_TYPE_IPV4;
+	} else {
+		/** remove ip */
+		misc->param.ipaddr_cfg.op_code = MLAN_IPADDR_OP_IP_REMOVE;
+	}
+	ret = woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), req,
+				 MOAL_NO_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS && ret != MLAN_STATUS_PENDING)
+		PRINTM(MIOCTL, "Set auto arp IOCTL failed!\n");
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set auto arp resp with enhancement method
+ *
+ *  @param handle         A pointer to moal_handle structure
+ *  @param enable         enable/disable
+ *
+ *  @return               MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ * otherwise fail
+ */
+mlan_status woal_set_auto_arp_ext(moal_handle *handle, t_u8 enable)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	int i = 0, ip_addr_num = 0;
+	moal_private *priv = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_mef_flt_cfg *mef_cfg = NULL;
+	mef_entry_t *entry = NULL;
+	mef_filter_t *filter = NULL;
+	t_u8 ip_addr[MAX_IPADDR][IPADDR_LEN];
+
+	ENTER();
+
+	memset(&mef_cfg, 0, sizeof(mef_cfg));
+	for (i = 0; i < handle->priv_num && (priv = handle->priv[i]); i++) {
+		if (priv && priv->ip_addr_type != IPADDR_TYPE_NONE) {
+			moal_memcpy_ext(handle, ip_addr[ip_addr_num],
+					priv->ip_addr, IPADDR_LEN, IPADDR_LEN);
+			ip_addr_num++;
+		}
+	}
+	if (ip_addr_num == 0) {
+		PRINTM(MIOCTL, "No IP addr configured.\n");
+		goto done;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		PRINTM(MIOCTL, "IOCTL req allocated failed!\n");
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_MEF_FLT_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+
+	mef_cfg = (mlan_ds_misc_mef_flt_cfg *)(&(misc->param.mef_flt_cfg));
+	mef_cfg->mef_act_type = MEF_ACT_AUTOARP;
+	mef_cfg->criteria = (MBIT(0) | MBIT(1));
+
+	entry = (mef_entry_t *)&mef_cfg->mef_entry;
+	entry->mode = MBIT(0);
+	entry->action = 0x10;
+
+	filter = (mef_filter_t *)(entry->filter_item);
+	filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT | FILLING_OFFSET |
+			     FILLING_BYTE_SEQ);
+	filter->type = TYPE_BYTE_EQ;
+	filter->repeat = 1;
+	filter->offset = 20;
+	filter->num_byte_seq = 2;
+	moal_memcpy_ext(handle, filter->byte_seq, "\x08\x06", 2,
+			sizeof(filter->byte_seq));
+	entry->rpn[1] = RPN_TYPE_AND;
+
+	for (i = 0; i < ip_addr_num; i++) {
+		filter++;
+		filter->fill_flag = (FILLING_TYPE | FILLING_REPEAT |
+				     FILLING_OFFSET | FILLING_BYTE_SEQ);
+		filter->type = TYPE_BYTE_EQ;
+		filter->repeat = 1;
+		filter->offset = 46;
+		filter->num_byte_seq = 4;
+		moal_memcpy_ext(handle, filter->byte_seq, &ip_addr[i],
+				sizeof(t_u32), sizeof(filter->byte_seq));
+		if (i > 1)
+			entry->rpn[i] = RPN_TYPE_OR;
+	}
+	entry->filter_num = ip_addr_num + 1;
+
+	if (enable)
+		mef_cfg->op_code = MLAN_IPADDR_OP_ARP_FILTER |
+				   MLAN_IPADDR_OP_AUTO_ARP_RESP;
+	else
+		/** remove ip */
+		mef_cfg->op_code = MLAN_IPADDR_OP_IP_REMOVE;
+	ret = woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), req,
+				 MOAL_NO_WAIT);
+	if (ret != MLAN_STATUS_SUCCESS && ret != MLAN_STATUS_PENDING)
+		PRINTM(MIOCTL, "Set auto arp IOCTL failed!\n");
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Set/Get DTIM period
+ *
+ *  @param priv                 A pointer to moal_private structure
+ *  @param action               Action set or get
+ *  @param wait_option          Wait option
+ *  @param value                DTIM period
+ *
+ *  @return                     MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --
+ * success, otherwise fail
+ */
+mlan_status woal_set_get_dtim_period(moal_private *priv, t_u32 action,
+				     t_u8 wait_option, t_u8 *value)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_snmp_mib *mib = NULL;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_snmp_mib));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	mib = (mlan_ds_snmp_mib *)req->pbuf;
+	mib->sub_command = MLAN_OID_SNMP_MIB_DTIM_PERIOD;
+	req->req_id = MLAN_IOCTL_SNMP_MIB;
+	req->action = action;
+
+	if (action == MLAN_ACT_SET)
+		mib->param.dtim_period = *value;
+
+	/* Send IOCTL request to MLAN */
+	ret = woal_request_ioctl(priv, req, wait_option);
+	if (ret == MLAN_STATUS_SUCCESS && action == MLAN_ACT_GET)
+		*value = (t_u8)mib->param.dtim_period;
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief Get Host Sleep parameters
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param action       Action: set or get
  *  @param wait_option  Wait option (MOAL_WAIT or MOAL_NO_WAIT)
  *  @param hscfg        A pointer to mlan_ds_hs_cfg structure
  *
@@ -2709,7 +3468,7 @@ mlan_status woal_set_get_hs_params(moal_private *priv, t_u16 action,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_pm_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -2847,7 +3606,11 @@ mlan_status woal_set_get_wowlan_config(moal_private *priv, t_u16 action,
  */
 mlan_status woal_cancel_hs(moal_private *priv, t_u8 wait_option)
 {
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	moal_handle *handle = NULL;
+#endif
+#endif
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_hs_cfg hscfg;
 #ifdef STA_CFG80211
@@ -2857,19 +3620,64 @@ mlan_status woal_cancel_hs(moal_private *priv, t_u8 wait_option)
 #endif
 	ENTER();
 
+	memset(&hscfg, 0, sizeof(mlan_ds_hs_cfg));
+
 	if (!priv) {
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
-	handle = priv->phandle;
 	/* Cancel Host Sleep */
-
 	hscfg.conditions = HOST_SLEEP_CFG_CANCEL;
 	hscfg.is_invoke_hostcmd = MTRUE;
 	ret = woal_set_get_hs_params(priv, MLAN_ACT_SET, wait_option, &hscfg);
+	if (ret != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "%s: woal_set_get_hs_params failed \n",
+		       __func__);
+		LEAVE();
+		return ret;
+	}
+	if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS)) {
+		/*Disable firmware roaming*/
+		woal_enable_fw_roaming(priv, 0);
+	}
+	if (priv->phandle->fw_roam_enable == ROAM_OFFLOAD_WITH_BSSID ||
+	    priv->phandle->fw_roam_enable == ROAM_OFFLOAD_WITH_SSID ||
+	    priv->phandle->fw_roam_enable == AUTO_RECONNECT)
+		woal_config_fw_roaming(priv, ROAM_OFFLOAD_RESUME_CFG, NULL);
+#ifdef STA_CFG80211
+	if (priv->phandle->fw_roam_enable == AUTO_RECONNECT)
+		woal_set_clear_pmk(priv, MLAN_ACT_CLEAR);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	if (priv->phandle->hs_auto_arp) {
+		PRINTM(MIOCTL, "Cancel Host Sleep... remove ipv6 offload\n");
+		/** Set ipv6 router advertisement message offload */
+		woal_set_ipv6_ra_offload(priv->phandle, MFALSE);
+	}
+	/** Set Neighbor Solitation message offload */
+	woal_set_ipv6_ns_offload(priv->phandle, MFALSE);
+#endif
+#endif
+
+	if (priv->phandle->hs_auto_arp) {
+		PRINTM(MIOCTL, "Cancel Host Sleep... remove Mdns wake up\n");
+		/** Set ipv6 router advertisement message offload */
+		woal_set_wake_on_mdns(priv->phandle, MFALSE);
+	}
+
+	if (priv->phandle->hs_auto_arp) {
+		PRINTM(MIOCTL, "Cancel Host Sleep... remove FW auto arp\n");
+		/* remove auto arp from FW */
+		woal_set_auto_arp(priv->phandle, MFALSE);
+		/* remove auto arp from FW */
+		woal_set_auto_arp_ext(priv->phandle, MFALSE);
+	}
 
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+	handle = priv->phandle;
 	if (GTK_REKEY_OFFLOAD_SUSPEND == handle->params.gtk_rekey_offload) {
 		PRINTM(MIOCTL,
 		       "Cancel Host Sleep... clear gtk rekey offload of FW\n");
@@ -2877,9 +3685,13 @@ mlan_status woal_cancel_hs(moal_private *priv, t_u8 wait_option)
 			if (handle->priv[i] &&
 			    handle->priv[i]->gtk_data_ready) {
 				PRINTM(MCMND, "clear GTK in resume\n");
-				woal_set_rekey_data(handle->priv[i], NULL,
-						    MLAN_ACT_CLEAR,
-						    wait_option);
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_set_rekey_data(handle->priv[i], NULL,
+							MLAN_ACT_CLEAR,
+							wait_option))
+					PRINTM(MERROR,
+					       "%s: clear GTK in resume failed \n",
+					       __func__);
 			}
 		}
 	}
@@ -2890,50 +3702,205 @@ mlan_status woal_cancel_hs(moal_private *priv, t_u8 wait_option)
 	return ret;
 }
 
-/**  @brief This function enables the host sleep
+/**  @brief This function config fw roaming parameters
  *
  *  @param priv     A Pointer to the moal_private structure
  *  @return         MTRUE or MFALSE
  */
-int woal_enable_hs(moal_private *priv)
+static int woal_set_fw_roaming_params(moal_private *priv)
 {
-	mlan_ds_hs_cfg hscfg;
-	moal_handle *handle = NULL;
-	int hs_actived = MFALSE;
-	int timeout = 0;
-	int i;
-#ifdef SDIO_SUSPEND_RESUME
-	mlan_ds_ps_info pm_info;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_sec_cfg *sec = NULL;
+	woal_roam_offload_cfg roam_offload_cfg;
+#ifdef STA_CFG80211
+	t_u8 zero[MLAN_MAX_KEY_LENGTH] = {0};
 #endif
-	pmlan_ds_misc_keep_alive keep_alive = NULL;
 
-	ENTER();
+	/*Enable fw roaming*/
+	woal_config_fw_roaming(priv, ROAM_OFFLOAD_ENABLE, NULL);
+	/*Download fw roaming parameters*/
+	woal_config_fw_roaming(priv, ROAM_OFFLOAD_PARAM_CFG,
+			       &priv->phandle->fw_roam_params);
 
-	if (priv == NULL) {
-		PRINTM(MERROR, "Invalid priv\n");
+	/*Download userset passphrase key and current connection's PMK*/
+#ifdef STA_CFG80211
+	if (!priv->phandle->fw_roam_params.userset_passphrase) {
+		woal_set_clear_pmk(priv, MLAN_ACT_SET);
 		goto done;
 	}
-	handle = priv->phandle;
-	if (handle->hs_activated == MTRUE) {
-		PRINTM(MIOCTL, "HS Already actived\n");
-		hs_actived = MTRUE;
+#endif
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
-	for (i = 0; i < MIN(handle->priv_num, MLAN_MAX_BSS_NUM); i++) {
-		if (handle->priv[i] &&
-		    (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_STA)) {
-			if (moal_extflg_isset(handle,
-					      EXT_DISCONNECT_ON_SUSPEND) &&
-			    handle->priv[i]->media_connected == MTRUE) {
-				PRINTM(MIOCTL, "disconnect on suspend\n");
-				woal_disconnect(handle->priv[i], MOAL_NO_WAIT,
-						NULL, DEF_DEAUTH_REASON_CODE);
-			}
-		}
-		if (handle->priv[i]) {
-			PRINTM(MIOCTL, "woal_delba_all on priv[%d]\n", i);
-			woal_delba_all(handle->priv[i], MOAL_NO_WAIT);
-		}
+
+	req->req_id = MLAN_IOCTL_SEC_CFG;
+	sec = (mlan_ds_sec_cfg *)req->pbuf;
+	sec->sub_command = MLAN_OID_SEC_CFG_PASSPHRASE;
+	sec->multi_passphrase = 1;
+	req->action = MLAN_ACT_SET;
+
+	/*Copy user set passphrase*/
+	moal_memcpy_ext(priv->phandle, (char *)sec->param.roam_passphrase,
+			(char *)priv->phandle->ssid_passphrase,
+			MAX_SEC_SSID_NUM * sizeof(mlan_ds_passphrase),
+			MAX_SEC_SSID_NUM * sizeof(mlan_ds_passphrase));
+	roam_offload_cfg.userset_passphrase =
+		priv->phandle->fw_roam_params.userset_passphrase;
+#ifdef STA_CFG80211
+	if (memcmp(priv->pmk.pmk, zero, MLAN_MAX_KEY_LENGTH)) {
+		/*Download current connection PMK*/
+		if (priv->pmk_saved) {
+			woal_set_clear_pmk(priv, MLAN_ACT_SET);
+			priv->pmk_saved = false;
+		}
+	}
+#endif
+	/*Set userset to mlan adapter*/
+	woal_config_fw_roaming(priv, ROAM_OFFLOAD_ENABLE, &roam_offload_cfg);
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**  @brief This function enable/disable fw roaming
+ *
+ *  @param priv     A Pointer to the moal_private structure
+ *  @param enable   Enable/disable fw roaming
+ *  @return         MTRUE or MFALSE
+ */
+int woal_enable_fw_roaming(moal_private *priv, int data)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_roam_offload *roam = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	if (!data && !priv->phandle->fw_roam_enable) {
+		PRINTM(MIOCTL, "Fw roaming already disabled\n");
+		goto done;
+	}
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_ROAM_OFFLOAD;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	roam = (mlan_ds_misc_roam_offload *)&misc->param.roam_offload;
+	roam->aplist.ap_num = 0;
+	/* SET operation */
+	ioctl_req->action = MLAN_ACT_SET;
+	roam->enable = data;
+	roam->config_mode = ROAM_OFFLOAD_ENABLE;
+
+	if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS) && data) {
+		priv->phandle->fw_roam_enable = data;
+		goto done;
+	}
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	priv->phandle->fw_roam_enable = data;
+	if (!data) {
+		memset((char *)&priv->phandle->fw_roam_params, 0,
+		       sizeof(woal_roam_offload_cfg));
+		memset((char *)&priv->phandle->ssid_passphrase, 0,
+		       MAX_SEC_SSID_NUM * sizeof(mlan_ds_passphrase));
+	}
+#ifdef STA_CFG80211
+	else if (priv->media_connected && priv->pmk_saved) {
+		woal_set_clear_pmk(priv, MLAN_ACT_SET);
+		priv->pmk_saved = false;
+	}
+#endif
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
+	return ret;
+}
+
+/**  @brief This function enables the host sleep
+ *
+ *  @param priv     A Pointer to the moal_private structure
+ *  @return         MTRUE or MFALSE
+ */
+int woal_enable_hs(moal_private *priv)
+{
+	mlan_ds_hs_cfg hscfg;
+	moal_handle *handle = NULL;
+	int hs_actived = MFALSE;
+	int timeout = 0;
+	int i;
+#ifdef SDIO_SUSPEND_RESUME
+	mlan_ds_ps_info pm_info;
+#endif
+	pmlan_ds_misc_keep_alive keep_alive = NULL;
+	pmlan_ds_misc_keep_alive_rx keep_alive_rx = NULL;
+	t_u8 media_connected = MFALSE;
+
+	ENTER();
+
+	if (priv == NULL) {
+		PRINTM(MERROR, "Invalid priv\n");
+		goto done;
+	}
+	handle = priv->phandle;
+	if (handle->hs_activated == MTRUE) {
+		PRINTM(MIOCTL, "HS Already actived\n");
+		hs_actived = MTRUE;
+		goto done;
+	}
+	for (i = 0; i < MIN(handle->priv_num, MLAN_MAX_BSS_NUM); i++) {
+		if (handle->priv[i] &&
+		    (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_STA)) {
+			if (moal_extflg_isset(handle,
+					      EXT_DISCONNECT_ON_SUSPEND) &&
+			    handle->priv[i]->media_connected == MTRUE) {
+				PRINTM(MIOCTL, "disconnect on suspend\n");
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_disconnect(handle->priv[i],
+						    MOAL_NO_WAIT, NULL,
+						    DEF_DEAUTH_REASON_CODE)) {
+					PRINTM(MIOCTL,
+					       "disconnect on suspend failed\n");
+				}
+			}
+		}
+		if (handle->priv[i]) {
+			PRINTM(MIOCTL, "woal_delba_all on priv[%d]\n", i);
+			woal_delba_all(handle->priv[i], MOAL_NO_WAIT);
+		}
 	}
 
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
@@ -2948,10 +3915,12 @@ int woal_enable_hs(moal_private *priv)
 		moal_private *remain_priv =
 			priv->phandle->priv[priv->phandle->remain_bss_index];
 		if (remain_priv) {
-			woal_cfg80211_remain_on_channel_cfg(remain_priv,
-							    MOAL_NO_WAIT, MTRUE,
-							    &channel_status,
-							    NULL, 0, 0);
+			if (woal_cfg80211_remain_on_channel_cfg(
+				    remain_priv, MOAL_NO_WAIT, MTRUE,
+				    &channel_status, NULL, 0, 0)) {
+				PRINTM(MIOCTL,
+				       "Failed to cancel pending remain on channel\n");
+			}
 			if (priv->phandle->cookie) {
 				cfg80211_remain_on_channel_expired(
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
@@ -2977,6 +3946,46 @@ int woal_enable_hs(moal_private *priv)
 	woal_reconfig_bgscan(priv->phandle);
 #endif
 
+	if (moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS) &&
+	    handle->fw_roam_enable) {
+		woal_set_fw_roaming_params(priv);
+	}
+	if (handle->fw_roam_enable == ROAM_OFFLOAD_WITH_BSSID ||
+	    handle->fw_roam_enable == ROAM_OFFLOAD_WITH_SSID ||
+	    handle->fw_roam_enable == AUTO_RECONNECT) {
+		woal_config_fw_roaming(priv, ROAM_OFFLOAD_SUSPEND_CFG, NULL);
+#ifdef STA_CFG80211
+		if (priv->phandle->fw_roam_enable == AUTO_RECONNECT)
+			woal_set_clear_pmk(priv, MLAN_ACT_SET);
+#endif
+	}
+	media_connected = woal_check_media_connected(handle);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	if (handle->hs_auto_arp && media_connected) {
+		PRINTM(MIOCTL, "Host Sleep enabled... set ipv6 offload\n");
+		/** Set ipv6 router advertisement message offload */
+		woal_set_ipv6_ra_offload(handle, MTRUE);
+		/** Set Neighbor Solitation message offload */
+		woal_set_ipv6_ns_offload(handle, MTRUE);
+	}
+#endif
+#endif
+
+	if (handle->hs_auto_arp) {
+		PRINTM(MIOCTL, "Host Sleep enabled... set mdns wake up\n");
+		/**MDNS wake up**/
+		woal_set_wake_on_mdns(handle, MTRUE);
+	}
+
+	if (handle->hs_auto_arp && media_connected) {
+		PRINTM(MIOCTL, "Host Sleep enabled... set FW auto arp\n");
+		/* Set auto arp response configuration to Fw */
+		woal_set_auto_arp(handle, MTRUE);
+		/* Set auto arp response configuration to Fw */
+		woal_set_auto_arp_ext(handle, MTRUE);
+	}
+
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	if (GTK_REKEY_OFFLOAD_SUSPEND == handle->params.gtk_rekey_offload) {
@@ -2986,10 +3995,14 @@ int woal_enable_hs(moal_private *priv)
 			if (handle->priv[i] &&
 			    handle->priv[i]->gtk_data_ready) {
 				PRINTM(MCMND, "set GTK before suspend\n");
-				woal_set_rekey_data(
-					handle->priv[i],
-					&handle->priv[i]->gtk_rekey_data,
-					MLAN_ACT_SET, MOAL_NO_WAIT);
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_set_rekey_data(
+					    handle->priv[i],
+					    &handle->priv[i]->gtk_rekey_data,
+					    MLAN_ACT_SET, MOAL_NO_WAIT))
+					PRINTM(MERROR,
+					       "%s: set GTR before suspend failed \n",
+					       __func__);
 			}
 		}
 	}
@@ -3011,6 +4024,21 @@ int woal_enable_hs(moal_private *priv)
 			memset(keep_alive->packet, 0, MKEEP_ALIVE_IP_PKT_MAX);
 		}
 	}
+	for (i = 0; i < MAX_KEEP_ALIVE_RX_ID; i++) {
+		keep_alive_rx = &handle->keep_alive_rx[i];
+		if (keep_alive_rx && keep_alive_rx->cached &&
+		    keep_alive_rx->enable) {
+			keep_alive_rx->cached = MFALSE;
+			woal_start_mkeep_alive_rx(
+				woal_get_priv(handle, MLAN_BSS_ROLE_ANY),
+				keep_alive_rx->mkeep_alive_id,
+				keep_alive_rx->packet, keep_alive_rx->pkt_len,
+				keep_alive_rx->src_mac, keep_alive_rx->dst_mac);
+			keep_alive_rx->pkt_len = 0;
+			memset(keep_alive_rx->packet, 0,
+			       MKEEP_ALIVE_ACK_PKT_MAX);
+		}
+	}
 	/* Enable Host Sleep */
 	handle->hs_activate_wait_q_woken = MFALSE;
 	memset(&hscfg, 0, sizeof(mlan_ds_hs_cfg));
@@ -3126,7 +4154,6 @@ mlan_status woal_request_soft_reset(moal_handle *handle)
 mlan_status woal_set_wapi_enable(moal_private *priv, t_u8 wait_option,
 				 t_u32 enable)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -3135,7 +4162,7 @@ mlan_status woal_set_wapi_enable(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -3166,6 +4193,7 @@ mlan_status woal_set_wapi_enable(moal_private *priv, t_u8 wait_option,
  */
 void woal_get_version(moal_handle *handle, char *version, int max_len)
 {
+	t_u8 hotfix_ver = 0;
 	union {
 		t_u32 l;
 		t_u8 c[4];
@@ -3174,9 +4202,17 @@ void woal_get_version(moal_handle *handle, char *version, int max_len)
 
 	ENTER();
 
+	hotfix_ver = handle->fw_hotfix_version;
 	ver.l = handle->fw_release_number;
-	snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u", ver.c[2], ver.c[1],
-		 ver.c[0], ver.c[3]);
+
+	if (hotfix_ver) {
+		snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u.%u", ver.c[2],
+			 ver.c[1], ver.c[0], ver.c[3], hotfix_ver);
+
+	} else {
+		snprintf(fw_ver, sizeof(fw_ver), "%u.%u.%u.p%u", ver.c[2],
+			 ver.c[1], ver.c[0], ver.c[3]);
+	}
 
 	snprintf(version, max_len, handle->driver_version, fw_ver);
 
@@ -3298,11 +4334,11 @@ int woal_get_driver_verext(moal_private *priv, struct ifreq *ireq)
  *  @brief Set driver debug bit masks to mlan in order to enhance performance
  *
  *  @param priv         A pointer to moal_private structure
- *  @param drvdbg       Driver debug level
+ *  @param drv_dbg       Driver debug level
  *
  *  @return             0 --success, otherwise fail
  */
-int woal_set_drvdbg(moal_private *priv, t_u32 drvdbg)
+int woal_set_drvdbg(moal_private *priv, t_u32 drv_dbg)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
@@ -3320,7 +4356,7 @@ int woal_set_drvdbg(moal_private *priv, t_u32 drvdbg)
 	misc->sub_command = MLAN_OID_MISC_DRVDBG;
 	req->req_id = MLAN_IOCTL_MISC_CFG;
 	req->action = MLAN_ACT_SET;
-	misc->param.drvdbg = drvdbg;
+	misc->param.drvdbg = drv_dbg;
 
 	ret = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 
@@ -3710,7 +4746,10 @@ void woal_cancel_cac_block(moal_private *priv)
 	if (priv->phandle->cac_period == MTRUE) {
 		priv->phandle->cac_period = MFALSE;
 		/* Make sure Chan Report is cancelled */
-		woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT);
+		if (woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR,
+			       "%s: Cancelling CAC chan report in FW failed \n",
+			       __func__);
 		priv->phandle->meas_start_jiffies = 0;
 		if (priv->phandle->delay_bss_start == MTRUE)
 			priv->phandle->delay_bss_start = MFALSE;
@@ -3748,6 +4787,10 @@ int woal_11h_channel_check_ioctl(moal_private *priv, t_u8 wait_option)
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11h_cfg *ds_11hcfg = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
+#ifdef UAP_SUPPORT
+	chan_band_info chan;
+	chan_band_info uapchan;
+#endif
 
 	ENTER();
 
@@ -3768,6 +4811,41 @@ int woal_11h_channel_check_ioctl(moal_private *priv, t_u8 wait_option)
 	}
 
 	if (woal_is_any_interface_active(priv->phandle)) {
+#ifdef UAP_SUPPORT
+		/* When any other interface is active
+		 * Get rid of CAC timer when drcs is disabled */
+		t_u16 enable = 0;
+		if (priv->phandle->card_info->drcs)
+			ret = woal_mc_policy_cfg(priv, &enable, wait_option,
+						 MLAN_ACT_GET);
+		if (!enable) {
+			LEAVE();
+			return ret;
+		} else {
+			woal_get_active_intf_channel(priv, &chan);
+			woal_set_get_ap_channel(priv, MLAN_ACT_GET,
+						MOAL_IOCTL_WAIT, &uapchan);
+			if (chan.channel != uapchan.channel) {
+				if (uapchan.is_dfs_chan) {
+					PRINTM(MERROR,
+					       "DFS channel is not allowed when another connection exists on different channel\n");
+					PRINTM(MERROR,
+					       "Another connection's channel=%d, dfs channel=%d\n",
+					       chan.channel, uapchan.channel);
+					return -EINVAL;
+				} else {
+					// check if we need move first uap0 from
+					// DFS channel to new non dfs channel
+					woal_check_mc_connection(
+						priv, wait_option,
+						uapchan.channel);
+				}
+			}
+		}
+#else
+		LEAVE();
+		return status;
+#endif
 	}
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
@@ -3826,7 +4904,7 @@ int woal_11h_cancel_chan_report_ioctl(moal_private *priv, t_u8 wait_option)
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
-
+	PRINTM(MCMND, "wlan: woal_11h_cancel_chan_report\n");
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
 	if (req == NULL) {
 		ret = -ENOMEM;
@@ -4004,7 +5082,6 @@ mlan_status woal_p2p_config(moal_private *priv, t_u32 action,
 mlan_status woal_get_sta_channel(moal_private *priv, t_u8 wait_option,
 				 chan_band_info *channel)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_bss *bss = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4014,7 +5091,7 @@ mlan_status woal_get_sta_channel(moal_private *priv, t_u8 wait_option,
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
 	if (req == NULL) {
 		PRINTM(MERROR, "woal_get_sta_channel req alloc fail\n");
-		ret = MLAN_STATUS_FAILURE;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4051,7 +5128,6 @@ mlan_status woal_get_sta_channel(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_signal_info(moal_private *priv, t_u8 wait_option,
 				 mlan_ds_get_signal *signal)
 {
-	int ret = 0;
 	mlan_ds_get_info *info = NULL;
 	mlan_ioctl_req *req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4061,7 +5137,7 @@ mlan_status woal_get_signal_info(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_get_info));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4111,7 +5187,6 @@ mlan_status woal_get_signal_info(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_scan_table(moal_private *priv, t_u8 wait_option,
 				mlan_scan_resp *scan_resp)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_scan *scan = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4125,7 +5200,7 @@ mlan_status woal_get_scan_table(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_scan));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4341,7 +5416,6 @@ mlan_status woal_find_best_network(moal_private *priv, t_u8 wait_option,
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_bss *bss = NULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	t_u8 *mac = 0;
 
 	ENTER();
 
@@ -4372,9 +5446,9 @@ mlan_status woal_find_best_network(moal_private *priv, t_u8 wait_option,
 		moal_memcpy_ext(priv->phandle, ssid_bssid,
 				&bss->param.ssid_bssid, sizeof(mlan_ssid_bssid),
 				sizeof(mlan_ssid_bssid));
-		mac = (t_u8 *)&ssid_bssid->bssid;
 		PRINTM(MINFO, "Find network: ssid=%s, " MACSTR ", idx=%d\n",
-		       ssid_bssid->ssid.ssid, MAC2STR(mac),
+		       ssid_bssid->ssid.ssid,
+		       MAC2STR((t_u8 *)&ssid_bssid->bssid),
 		       (int)ssid_bssid->idx);
 	}
 
@@ -4443,7 +5517,6 @@ mlan_status woal_11d_check_ap_channel(moal_private *priv, t_u8 wait_option,
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_bss *bss = NULL;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-	t_u8 *mac = 0;
 
 	ENTER();
 
@@ -4468,9 +5541,8 @@ mlan_status woal_11d_check_ap_channel(moal_private *priv, t_u8 wait_option,
 	moal_memcpy_ext(priv->phandle, &bss->param.ssid_bssid, ssid_bssid,
 			sizeof(mlan_ssid_bssid), sizeof(mlan_ssid_bssid));
 
-	mac = (t_u8 *)&ssid_bssid->bssid;
 	PRINTM(MINFO, "ssid=%s, " MACSTR ", idx=%d\n", ssid_bssid->ssid.ssid,
-	       MAC2STR(mac), (int)ssid_bssid->idx);
+	       MAC2STR((t_u8 *)&ssid_bssid->bssid), (int)ssid_bssid->idx);
 
 	/* Send IOCTL request to MLAN */
 	ret = woal_request_ioctl(priv, req, wait_option);
@@ -4495,7 +5567,6 @@ mlan_status woal_11d_check_ap_channel(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_auth_mode(moal_private *priv, t_u8 wait_option,
 			       t_u32 *auth_mode)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4504,7 +5575,7 @@ mlan_status woal_get_auth_mode(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4538,7 +5609,6 @@ mlan_status woal_get_auth_mode(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_encrypt_mode(moal_private *priv, t_u8 wait_option,
 				  t_u32 *encrypt_mode)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4548,7 +5618,7 @@ mlan_status woal_get_encrypt_mode(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4582,7 +5652,6 @@ mlan_status woal_get_encrypt_mode(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_wpa_enable(moal_private *priv, t_u8 wait_option,
 				t_u32 *enable)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4592,7 +5661,7 @@ mlan_status woal_get_wpa_enable(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4626,7 +5695,6 @@ mlan_status woal_get_wpa_enable(moal_private *priv, t_u8 wait_option,
 mlan_status woal_set_auth_mode(moal_private *priv, t_u8 wait_option,
 			       t_u32 auth_mode)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4635,7 +5703,7 @@ mlan_status woal_set_auth_mode(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4668,7 +5736,6 @@ mlan_status woal_set_auth_mode(moal_private *priv, t_u8 wait_option,
 mlan_status woal_set_encrypt_mode(moal_private *priv, t_u8 wait_option,
 				  t_u32 encrypt_mode)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4677,7 +5744,7 @@ mlan_status woal_set_encrypt_mode(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4710,7 +5777,6 @@ mlan_status woal_set_encrypt_mode(moal_private *priv, t_u8 wait_option,
 mlan_status woal_set_wpa_enable(moal_private *priv, t_u8 wait_option,
 				t_u32 enable)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4719,7 +5785,7 @@ mlan_status woal_set_wpa_enable(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4750,7 +5816,6 @@ mlan_status woal_set_wpa_enable(moal_private *priv, t_u8 wait_option,
  */
 mlan_status woal_enable_wep_key(moal_private *priv, t_u8 wait_option)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -4759,7 +5824,7 @@ mlan_status woal_enable_wep_key(moal_private *priv, t_u8 wait_option)
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -5009,6 +6074,7 @@ mlan_status woal_cancel_scan(moal_private *priv, t_u8 wait_option)
 	spin_lock_irqsave(&handle->scan_req_lock, flags);
 	if (IS_STA_CFG80211(handle->params.cfg80211_wext) &&
 	    handle->scan_request) {
+		cancel_delayed_work(&handle->scan_timeout_work);
 		/** some supplicant can not handle SCAN abort event */
 		if (scan_priv->bss_type == MLAN_BSS_TYPE_STA)
 			woal_cfg80211_scan_done(handle->scan_request, MTRUE);
@@ -5045,6 +6111,8 @@ int woal_find_essid(moal_private *priv, mlan_ssid_bssid *ssid_bssid,
 	wifi_timeval t;
 	ENTER();
 
+	memset(&scan_resp, 0, sizeof(scan_resp));
+
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_get_scan_table(priv, wait_option, &scan_resp)) {
 		LEAVE();
@@ -5070,6 +6138,136 @@ int woal_find_essid(moal_private *priv, mlan_ssid_bssid *ssid_bssid,
 	return ret;
 }
 
+/**
+ * @brief                    auto reconnection configure
+ *
+ * @param priv               Pointer to moal_private structure
+ * @param cfg_mode           configure mode
+ * @param roam_offload_cfg   Pointer to woal_roam_offload_cfg structure
+ *
+ *  @return                  0-success, negative for failure.
+ */
+int woal_config_fw_roaming(moal_private *priv, t_u8 cfg_mode,
+			   woal_roam_offload_cfg *roam_offload_cfg)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_roam_offload *roam = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	int ret = 0;
+
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_ROAM_OFFLOAD;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	roam = (mlan_ds_misc_roam_offload *)&misc->param.roam_offload;
+	roam->aplist.ap_num = 0;
+	ioctl_req->action = MLAN_ACT_SET;
+	roam->enable = priv->phandle->fw_roam_enable;
+	roam->config_mode = cfg_mode;
+
+	if ((roam->config_mode == ROAM_OFFLOAD_ENABLE) && roam_offload_cfg) {
+		roam->userset_passphrase = roam_offload_cfg->userset_passphrase;
+		if (roam->userset_passphrase)
+			roam->enable = 0;
+	}
+	if (roam->config_mode == ROAM_OFFLOAD_PARAM_CFG) {
+		moal_memcpy_ext(priv->phandle, (t_u8 *)&roam->bssid_reconnect,
+				(t_u8 *)&roam_offload_cfg->bssid,
+				MLAN_MAC_ADDR_LENGTH,
+				sizeof(roam->bssid_reconnect));
+		if (roam_offload_cfg->ssid_list.ssid_num) {
+			moal_memcpy_ext(priv->phandle, (t_u8 *)&roam->ssid_list,
+					(t_u8 *)&roam_offload_cfg->ssid_list,
+					sizeof(mlan_ds_misc_ssid_list),
+					sizeof(mlan_ds_misc_ssid_list));
+		}
+		if (roam_offload_cfg->black_list.ap_num) {
+			moal_memcpy_ext(
+				priv->phandle, (t_u8 *)&roam->black_list,
+				(t_u8 *)&roam_offload_cfg->black_list,
+				sizeof(mlan_ds_misc_roam_offload_aplist),
+				sizeof(mlan_ds_misc_roam_offload_aplist));
+		}
+		roam->trigger_condition = roam_offload_cfg->trigger_condition;
+		roam->retry_count = roam_offload_cfg->retry_count;
+		if (roam_offload_cfg->rssi_param_set_flag) {
+			roam->para_rssi.set_flag = 1;
+			roam->para_rssi.max_rssi = roam_offload_cfg->max_rssi;
+			roam->para_rssi.min_rssi = roam_offload_cfg->min_rssi;
+			roam->para_rssi.step_rssi = roam_offload_cfg->step_rssi;
+		}
+		if (roam_offload_cfg->band_rssi_flag) {
+			roam->band_rssi_flag = roam_offload_cfg->band_rssi_flag;
+			moal_memcpy_ext(priv->phandle, (t_u8 *)&roam->band_rssi,
+					(t_u8 *)&roam_offload_cfg->band_rssi,
+					sizeof(mlan_ds_misc_band_rssi),
+					sizeof(mlan_ds_misc_band_rssi));
+		}
+		if (roam_offload_cfg->bgscan_set_flag) {
+			roam->bgscan_set_flag =
+				roam_offload_cfg->bgscan_set_flag;
+			moal_memcpy_ext(priv->phandle,
+					(t_u8 *)&roam->bgscan_cfg,
+					(t_u8 *)&roam_offload_cfg->bgscan_cfg,
+					sizeof(mlan_ds_misc_bgscan_cfg),
+					sizeof(mlan_ds_misc_bgscan_cfg));
+		}
+		if (roam_offload_cfg->ees_param_set_flag) {
+			roam->ees_param_set_flag =
+				roam_offload_cfg->ees_param_set_flag;
+			moal_memcpy_ext(priv->phandle, (t_u8 *)&roam->ees_cfg,
+					(t_u8 *)&roam_offload_cfg->ees_cfg,
+					sizeof(mlan_ds_misc_ees_cfg),
+					sizeof(mlan_ds_misc_ees_cfg));
+		}
+		roam->bcn_miss_threshold = roam_offload_cfg->bcn_miss_threshold;
+		roam->pre_bcn_miss_threshold =
+			roam_offload_cfg->pre_bcn_miss_threshold;
+		roam->repeat_count = roam_offload_cfg->repeat_count;
+	}
+	if (roam->config_mode == ROAM_OFFLOAD_SUSPEND_CFG) {
+		moal_memcpy_ext(priv->phandle, roam->bssid_reconnect,
+				priv->phandle->auto_reconnect_bssid,
+				MLAN_MAC_ADDR_LENGTH,
+				sizeof(roam->bssid_reconnect));
+		roam->ssid_list.ssid_num = 1;
+		moal_memcpy_ext(
+			priv->phandle, (t_u8 *)&roam->ssid_list.ssids[0].ssid,
+			(t_u8 *)&priv->phandle->auto_reconnect_ssid.ssid,
+			priv->phandle->auto_reconnect_ssid.ssid_len,
+			MLAN_MAX_SSID_LENGTH);
+		roam->retry_count = priv->phandle->auto_reconnect_retry_count;
+	}
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Request user scan
  *
@@ -5253,7 +6451,12 @@ void woal_config_bgscan_and_rssi(moal_private *priv, t_u8 set_rssi)
 		return;
 	}
 	memset(&bss_info, 0, sizeof(bss_info));
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		PRINTM(MIOCTL, "Get BSS Info Failed\n");
+		LEAVE();
+		return;
+	}
 	if (!bss_info.media_connected) {
 		PRINTM(MIOCTL, "We already lost connection\n");
 		LEAVE();
@@ -5269,7 +6472,11 @@ void woal_config_bgscan_and_rssi(moal_private *priv, t_u8 set_rssi)
 	priv->scan_cfg.rssi_threshold = priv->rssi_low - RSSI_HYSTERESIS;
 	priv->scan_cfg.repeat_count = DEF_REPEAT_COUNT;
 	priv->scan_cfg.scan_interval = MIN_BGSCAN_INTERVAL;
-	woal_get_band(priv, &band);
+	if (MLAN_STATUS_SUCCESS != woal_get_band(priv, &band)) {
+		PRINTM(MERROR, "woal get band fail\n");
+		LEAVE();
+		return;
+	}
 	switch (band) {
 	case WIFI_FREQUENCY_BAND_2GHZ:
 		priv->scan_cfg.chan_list[0].radio_type = 0 | BAND_SPECIFIED;
@@ -5286,12 +6493,19 @@ void woal_config_bgscan_and_rssi(moal_private *priv, t_u8 set_rssi)
 	moal_memcpy_ext(priv->phandle, priv->scan_cfg.random_mac,
 			priv->random_mac, ETH_ALEN,
 			sizeof(priv->scan_cfg.random_mac));
-	woal_request_bgscan(priv, MOAL_NO_WAIT, &priv->scan_cfg);
+	if (MLAN_STATUS_FAILURE ==
+	    woal_request_bgscan(priv, MOAL_NO_WAIT, &priv->scan_cfg)) {
+		PRINTM(MERROR, "request bgscan fail\n");
+		LEAVE();
+		return;
+	}
 	if (set_rssi &&
 	    ((priv->rssi_low + RSSI_HYSTERESIS) <= LOWEST_RSSI_THRESHOLD)) {
 		priv->rssi_low += RSSI_HYSTERESIS;
 		snprintf(rssi_low, sizeof(rssi_low), "%d", priv->rssi_low);
-		woal_set_rssi_low_threshold(priv, rssi_low, MOAL_NO_WAIT);
+		if (MLAN_STATUS_FAILURE ==
+		    woal_set_rssi_low_threshold(priv, rssi_low, MOAL_NO_WAIT))
+			PRINTM(MERROR, "set_rssi_low_threshold fail\n");
 	}
 	LEAVE();
 }
@@ -5307,15 +6521,20 @@ void woal_config_bgscan_and_rssi(moal_private *priv, t_u8 set_rssi)
  */
 mlan_status woal_stop_bg_scan(moal_private *priv, t_u8 wait_option)
 {
-	wlan_bgscan_cfg scan_cfg;
+	wlan_bgscan_cfg *scan_cfg;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	ENTER();
 
-	memset(&scan_cfg, 0, sizeof(scan_cfg));
-	scan_cfg.action = BG_SCAN_ACT_SET;
-	scan_cfg.enable = MFALSE;
-	ret = woal_request_bgscan(priv, wait_option, &scan_cfg);
-
+	scan_cfg = kmalloc(sizeof(wlan_bgscan_cfg), GFP_KERNEL);
+	if (!scan_cfg) {
+		LEAVE();
+		return ret;
+	}
+	memset(scan_cfg, 0, sizeof(wlan_bgscan_cfg));
+	scan_cfg->action = BG_SCAN_ACT_SET;
+	scan_cfg->enable = MFALSE;
+	ret = woal_request_bgscan(priv, wait_option, scan_cfg);
+	kfree(scan_cfg);
 	LEAVE();
 	return ret;
 }
@@ -5419,8 +6638,7 @@ mlan_status woal_set_rssi_threshold(moal_private *priv, t_u32 event_id,
 	mlan_ds_misc_cfg *misc = NULL;
 
 	ENTER();
-	if (priv->media_connected == MFALSE)
-		goto done;
+
 	if (priv->mrvl_rssi_low || !priv->cqm_rssi_thold)
 		goto done;
 	if (event_id == MLAN_EVENT_ID_FW_BCN_RSSI_LOW) {
@@ -5640,7 +6858,7 @@ mlan_status woal_set_powermode(moal_private *priv, char *powermode)
 int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 {
 	int ret = 0;
-	wlan_user_scan_cfg scan_cfg;
+	wlan_user_scan_cfg *scan_cfg;
 	t_u8 *ptr = buf + WEXT_CSCAN_HEADER_SIZE;
 	int buf_left = length - WEXT_CSCAN_HEADER_SIZE;
 	int num_ssid = 0;
@@ -5651,10 +6869,19 @@ int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 	t_u16 specific_scan_time = 0;
 
 	ENTER();
-	memset(&scan_cfg, 0, sizeof(scan_cfg));
-	while (buf_left >= 2) {
-		switch (*ptr) {
-		case WEXT_CSCAN_SSID_SECTION:
+
+	scan_cfg = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_cfg) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	memset(scan_cfg, 0, sizeof(wlan_user_scan_cfg));
+	while (buf_left >= 2) {
+		switch (*ptr) {
+		case WEXT_CSCAN_SSID_SECTION:
 			ssid_len = *(ptr + 1);
 			if ((buf_left < (ssid_len + 2)) ||
 			    (ssid_len > MLAN_MAX_SSID_LENGTH)) {
@@ -5666,11 +6893,11 @@ int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 			}
 			if (ssid_len &&
 			    (num_ssid < (MRVDRV_MAX_SSID_LIST_LENGTH - 1))) {
-				strncpy(scan_cfg.ssid_list[num_ssid].ssid,
+				strncpy(scan_cfg->ssid_list[num_ssid].ssid,
 					ptr + 2, ssid_len);
-				scan_cfg.ssid_list[num_ssid].max_len = 0;
+				scan_cfg->ssid_list[num_ssid].max_len = 0;
 				PRINTM(MIOCTL, "Combo scan: ssid=%s\n",
-				       scan_cfg.ssid_list[num_ssid].ssid);
+				       scan_cfg->ssid_list[num_ssid].ssid);
 				num_ssid++;
 			}
 			buf_left -= ssid_len + 2;
@@ -5687,9 +6914,9 @@ int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 				break;
 			}
 			for (i = 0; i < num_chan; i++) {
-				scan_cfg.chan_list[i].chan_number = ptr[2 + i];
+				scan_cfg->chan_list[i].chan_number = ptr[2 + i];
 				PRINTM(MIOCTL, "Combo scan: chan=%d\n",
-				       scan_cfg.chan_list[i].chan_number);
+				       scan_cfg->chan_list[i].chan_number);
 			}
 			buf_left -= 2 + num_chan;
 			ptr += 2 + num_chan;
@@ -5737,11 +6964,11 @@ int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 	if (num_ssid || num_chan) {
 		if (num_ssid) {
 			/* Add broadcast scan to ssid_list */
-			scan_cfg.ssid_list[num_ssid].max_len = 0xff;
+			scan_cfg->ssid_list[num_ssid].max_len = 0xff;
 			if (priv->scan_type == MLAN_SCAN_TYPE_PASSIVE)
 				woal_set_scan_type(priv, MLAN_SCAN_TYPE_ACTIVE);
 		}
-		if (MLAN_STATUS_FAILURE == woal_do_scan(priv, &scan_cfg))
+		if (MLAN_STATUS_FAILURE == woal_do_scan(priv, scan_cfg))
 			ret = -EFAULT;
 		if (num_ssid && (priv->scan_type == MLAN_SCAN_TYPE_PASSIVE))
 			woal_set_scan_type(priv, MLAN_SCAN_TYPE_PASSIVE);
@@ -5751,6 +6978,7 @@ int woal_set_combo_scan(moal_private *priv, char *buf, int length)
 			ret = -EFAULT;
 	}
 done:
+	kfree(scan_cfg);
 	LEAVE();
 	return ret;
 }
@@ -6287,7 +7515,8 @@ mlan_status woal_usb_aggr_init(moal_handle *handle)
 	else
 		moal_memcpy_ext(handle, &cardp->tx_aggr_ctrl,
 				&aggr_param->tx_aggr_ctrl,
-				sizeof(usb_aggr_ctrl), sizeof(usb_aggr_ctrl));
+				sizeof(usb_aggr_ctrl_cfg),
+				sizeof(usb_aggr_ctrl_cfg));
 
 	if (req->status_code) {
 		/* Disable the feature if FW return failure/unsupported */
@@ -6317,7 +7546,8 @@ mlan_status woal_usb_aggr_init(moal_handle *handle)
 		/* Default is disable, update only for enable case */
 		moal_memcpy_ext(handle, &cardp->rx_deaggr_ctrl,
 				&aggr_param->rx_deaggr_ctrl,
-				sizeof(usb_aggr_ctrl), sizeof(usb_aggr_ctrl));
+				sizeof(usb_aggr_ctrl_cfg),
+				sizeof(usb_aggr_ctrl_cfg));
 
 		/* Ensure the next data URBs will use the modified parameters */
 		if (!atomic_read(&cardp->rx_data_urb_pending)) {
@@ -6335,6 +7565,92 @@ mlan_status woal_usb_aggr_init(moal_handle *handle)
 }
 #endif
 
+/**
+ * @brief Set/Get configure multi-channel policy
+ *
+ * @param priv		A pointer to moal_private structure
+ * @param enable	A pointer to enable
+ * @param wait_option	wait_option of ioctl
+ * @param action	action of ioctl
+ *
+ * @return          MLAN_STATUS_SUCCESS -- success, otherwise fail
+ */
+mlan_status woal_mc_policy_cfg(moal_private *priv, t_u16 *enable,
+			       t_u8 wait_option, t_u8 action)
+{
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->sub_command = MLAN_OID_MISC_MULTI_CHAN_POLICY;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = action;
+	if (MLAN_ACT_SET == action)
+		cfg->param.multi_chan_policy = *enable;
+	status = woal_request_ioctl(priv, req, wait_option);
+	if (status != MLAN_STATUS_SUCCESS)
+		goto done;
+	if (MLAN_ACT_GET == action)
+		*enable = cfg->param.multi_chan_policy;
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return status;
+}
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+/**
+ * @brief Set multi ap flag to mlan layer
+ *
+ * @param priv		A pointer to moal_private structure
+ * @param wait_option	wait_option of ioctl
+ * @param flag	    multi ap flag
+ *
+ * @return          MLAN_STATUS_SUCCESS -- success, otherwise fail
+ */
+mlan_status woal_multi_ap_cfg(moal_private *priv, t_u8 wait_option, t_u8 flag)
+{
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *cfg = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	cfg = (mlan_ds_misc_cfg *)req->pbuf;
+	cfg->param.multi_ap_flag = flag;
+	cfg->sub_command = MLAN_OID_MISC_MULTI_AP_CFG;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+
+	status = woal_request_ioctl(priv, req, wait_option);
+	if (status != MLAN_STATUS_SUCCESS)
+		goto done;
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return status;
+}
+#endif
+
 /**
  *  @brief Set hotspot configuration value to mlan layer
  *
@@ -6378,6 +7694,73 @@ mlan_status woal_set_hotspotcfg(moal_private *priv, t_u8 wait_option,
 	return ret;
 }
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+/**
+ * @brief               Set/Get network monitor configurations
+ *
+ * @param priv          Pointer to moal_private structure
+ * @param wait_option  wait option
+ * @param enable	    Enable/Disable
+ * @param filter	    Filter flag - Management/Control/Data
+ * @param band_chan_cfg           Network monitor band channel config
+ *
+ * @return             MLAN_STATUS_SUCCESS -- success, otherwise fail
+ */
+mlan_status woal_set_net_monitor(moal_private *priv, t_u8 wait_option,
+				 t_u8 enable, t_u8 filter,
+				 netmon_band_chan_cfg *band_chan_cfg)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_net_monitor *net_mon = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	net_mon = (mlan_ds_misc_net_monitor *)&misc->param.net_mon;
+	misc->sub_command = MLAN_OID_MISC_NET_MONITOR;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	net_mon->enable_net_mon = enable;
+	if (net_mon->enable_net_mon) {
+		net_mon->filter_flag = filter;
+		if (band_chan_cfg && band_chan_cfg->channel) {
+			net_mon->band = band_chan_cfg->band;
+			net_mon->channel = band_chan_cfg->channel;
+			net_mon->chan_bandwidth = band_chan_cfg->chan_bandwidth;
+		}
+	}
+
+	status = woal_request_ioctl(priv, req, wait_option);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* update chan band values from response in band_chan_cfg */
+	if (net_mon->enable_net_mon) {
+		if (band_chan_cfg) {
+			band_chan_cfg->band = net_mon->band;
+			band_chan_cfg->channel = net_mon->channel;
+			band_chan_cfg->chan_bandwidth = net_mon->chan_bandwidth;
+		}
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+
+	LEAVE();
+	return ret;
+}
+#endif
+
 /**
  *  @brief Send delelte all BA command to MLAN
  *
@@ -6427,6 +7810,279 @@ mlan_status woal_delba_all(moal_private *priv, t_u8 wait_option)
 	return ret;
 }
 
+/**
+ *  @brief config RTT to mlan layer
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param ch_info   A pointer to wifi_channel_info
+ *  @param bandcfg  A pointer to Band_Config_t
+ *
+ *  @return            void
+ */
+void woal_channel_info_to_bandcfg(moal_private *priv,
+				  wifi_channel_info *ch_info,
+				  Band_Config_t *bandcfg)
+{
+	t_u8 channel = 0;
+
+	if (!ch_info || !bandcfg)
+		return;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	channel = ieee80211_frequency_to_channel(ch_info->center_freq);
+#endif
+
+	switch (ch_info->width) {
+	case WIFI_CHAN_WIDTH_10:
+		bandcfg->chanWidth = CHAN_BW_10MHZ;
+		break;
+	case WIFI_CHAN_WIDTH_20:
+		bandcfg->chanWidth = CHAN_BW_20MHZ;
+		break;
+	case WIFI_CHAN_WIDTH_40:
+		bandcfg->chanWidth = CHAN_BW_40MHZ;
+		break;
+	case WIFI_CHAN_WIDTH_80:
+		bandcfg->chanWidth = CHAN_BW_80MHZ;
+		break;
+	default:
+		bandcfg->chanWidth = CHAN_BW_20MHZ;
+		break;
+	}
+	bandcfg->chan2Offset = SEC_CHAN_NONE;
+	if (bandcfg->chanWidth == CHAN_BW_40MHZ) {
+		if (ch_info->center_freq0 < ch_info->center_freq)
+			bandcfg->chan2Offset = SEC_CHAN_BELOW;
+		else
+			bandcfg->chan2Offset = SEC_CHAN_ABOVE;
+	} else if (bandcfg->chanWidth == CHAN_BW_80MHZ)
+		bandcfg->chan2Offset =
+			woal_get_second_channel_offset(priv, channel);
+	bandcfg->chanBand = (channel <= MAX_BG_CHANNEL) ? BAND_2GHZ : BAND_5GHZ;
+	bandcfg->scanMode = SCAN_MODE_MANUAL;
+
+	return;
+}
+
+/**
+ *  @brief config RTT to mlan layer
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param ch_info   A pointer to wifi_channel_info
+ *  @param bandcfg  A pointer to Band_Config_t
+ *
+ *  @return            void
+ */
+void woal_bandcfg_to_channel_info(moal_private *priv, Band_Config_t *bandcfg,
+				  t_u8 channel, wifi_channel_info *ch_info)
+{
+	if (!ch_info || !bandcfg)
+		return;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	ch_info->center_freq = ieee80211_channel_to_frequency(
+		channel, (channel <= MAX_BG_CHANNEL) ? NL80211_BAND_2GHZ :
+						       NL80211_BAND_5GHZ);
+#endif
+
+	switch (bandcfg->chanWidth) {
+	case CHAN_BW_10MHZ:
+		ch_info->width = WIFI_CHAN_WIDTH_10;
+		break;
+	case CHAN_BW_20MHZ:
+		ch_info->width = WIFI_CHAN_WIDTH_20;
+		break;
+	case CHAN_BW_40MHZ:
+		ch_info->width = WIFI_CHAN_WIDTH_40;
+		break;
+	case CHAN_BW_80MHZ:
+		ch_info->width = WIFI_CHAN_WIDTH_80;
+		break;
+	default:
+		ch_info->width = WIFI_CHAN_WIDTH_20;
+		break;
+	}
+
+	return;
+}
+
+/**
+ *  @brief config RTT to mlan layer
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wait_option  wait option
+ *  @param hotspotcfg   A pointer to rtt_config_params_t
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ * otherwise fail
+ */
+mlan_status woal_config_rtt(moal_private *priv, t_u8 wait_option,
+			    wifi_rtt_config_params_t *rtt_params_in)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_rtt_config_params *rtt_params = NULL;
+	t_u32 i = 0;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	req->action = MLAN_ACT_SET;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CONFIG_RTT;
+	rtt_params = &(misc->param.rtt_params);
+	rtt_params->rtt_config_num = rtt_params_in->rtt_config_num;
+	for (i = 0; i < MIN(rtt_params->rtt_config_num, MAX_RTT_CONFIG_NUM);
+	     i++) {
+		moal_memcpy_ext(priv->phandle, rtt_params->rtt_config[i].addr,
+				rtt_params_in->rtt_config[i].addr,
+				sizeof(rtt_params->rtt_config[i].addr),
+				sizeof(rtt_params->rtt_config[i].addr));
+		rtt_params->rtt_config[i].type =
+			rtt_params_in->rtt_config[i].type;
+		rtt_params->rtt_config[i].peer =
+			rtt_params_in->rtt_config[i].peer;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+		rtt_params->rtt_config[i]
+			.channel = ieee80211_frequency_to_channel(
+			rtt_params_in->rtt_config[i].channel.center_freq);
+#endif
+		woal_channel_info_to_bandcfg(
+			priv, &(rtt_params_in->rtt_config[i].channel),
+			&(rtt_params->rtt_config[i].bandcfg));
+		rtt_params->rtt_config[i].burst_period =
+			rtt_params_in->rtt_config[i].burst_period;
+		rtt_params->rtt_config[i].num_burst =
+			rtt_params_in->rtt_config[i].num_burst;
+		rtt_params->rtt_config[i].num_frames_per_burst =
+			rtt_params_in->rtt_config[i].num_frames_per_burst;
+		rtt_params->rtt_config[i].num_retries_per_rtt_frame =
+			rtt_params_in->rtt_config[i].num_retries_per_rtt_frame;
+		rtt_params->rtt_config[i].num_retries_per_ftmr =
+			rtt_params_in->rtt_config[i].num_retries_per_ftmr;
+		rtt_params->rtt_config[i].LCI_request =
+			rtt_params_in->rtt_config[i].LCI_request;
+		rtt_params->rtt_config[i].LCR_request =
+			rtt_params_in->rtt_config[i].LCR_request;
+		rtt_params->rtt_config[i].burst_duration =
+			rtt_params_in->rtt_config[i].burst_duration;
+		rtt_params->rtt_config[i].preamble =
+			rtt_params_in->rtt_config[i].preamble;
+		rtt_params->rtt_config[i].bw = rtt_params_in->rtt_config[i].bw;
+	}
+
+	ret = woal_request_ioctl(priv, req, wait_option);
+	if (ret != MLAN_STATUS_SUCCESS)
+		goto done;
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief cancel RTT to mlan layer
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wait_option  wait option
+ *  @param hotspotcfg   A pointer to rtt_config_params_t
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ * otherwise fail
+ */
+mlan_status woal_cancel_rtt(moal_private *priv, t_u8 wait_option,
+			    t_u32 addr_num, t_u8 addr[][MLAN_MAC_ADDR_LENGTH])
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_rtt_cancel_params *rtt_cancel = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	req->action = MLAN_ACT_SET;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_CANCEL_RTT;
+	rtt_cancel = &(misc->param.rtt_cancel);
+	rtt_cancel->rtt_cancel_num = addr_num;
+	moal_memcpy_ext(priv->phandle, rtt_cancel->rtt_cancel, addr,
+			sizeof(rtt_cancel->rtt_cancel[0]) *
+				rtt_cancel->rtt_cancel_num,
+			sizeof(rtt_cancel->rtt_cancel[0]) * MAX_RTT_CONFIG_NUM);
+	ret = woal_request_ioctl(priv, req, wait_option);
+	if (ret != MLAN_STATUS_SUCCESS)
+		goto done;
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief cancel RTT to mlan layer
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wait_option  wait option
+ *  @param hotspotcfg   A pointer to rtt_config_params_t
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ * otherwise fail
+ */
+mlan_status woal_rtt_responder_cfg(moal_private *priv, t_u8 wait_option,
+				   mlan_rtt_responder *rtt_rsp_cfg)
+{
+	mlan_status ret = MLAN_STATUS_SUCCESS;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	req->action = MLAN_ACT_SET;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_RTT_RESPONDER_CFG;
+	moal_memcpy_ext(priv->phandle, &(misc->param.rtt_rsp_cfg), rtt_rsp_cfg,
+			sizeof(misc->param.rtt_rsp_cfg),
+			sizeof(misc->param.rtt_rsp_cfg));
+
+	ret = woal_request_ioctl(priv, req, wait_option);
+	if (ret != MLAN_STATUS_SUCCESS)
+		goto done;
+	moal_memcpy_ext(priv->phandle, rtt_rsp_cfg, &(misc->param.rtt_rsp_cfg),
+			sizeof(*rtt_rsp_cfg), sizeof(*rtt_rsp_cfg));
+
+done:
+	if (ret != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Send 11d enable/disable command to firmware.
  *
@@ -6472,30 +8128,115 @@ mlan_status woal_set_11d(moal_private *priv, t_u8 wait_option, t_u8 enable)
  *  @param priv     Pointer to moal_private structure
  *  @param info     Pointer to mlan_ds_misc_cfg structure
  *
- *  @return         N/A
+ *  @return         N/A
+ */
+void woal_ioctl_get_misc_conf(moal_private *priv, mlan_ds_misc_cfg *info)
+{
+	ENTER();
+	switch (info->sub_command) {
+	default:
+		break;
+	}
+}
+
+#ifdef CONFIG_PROC_FS
+#define RADIO_MODE_STR_LEN 20
+#define TX_PWR_STR_LEN 20
+#define TX_CONT_STR_LEN 50
+#define TX_FRAME_STR_LEN 200
+#define TRIGGER_FRAME_STR_LEN 250
+#define HE_TB_TX_STR_LEN 30
+
+/*
+ *  @brief Parse mfg cmd radio mode string
+ *
+ *  @param s        A pointer to user buffer
+ *  @param len      Length of user buffer
+ *  @param d        A pointer to mfg_cmd_generic_cfg struct
+ *  @return         0 on success, -EINVAL otherwise
+ */
+static int parse_radio_mode_string(const char *s, size_t len,
+				   struct mfg_cmd_generic_cfg *d)
+{
+	int ret = MLAN_STATUS_SUCCESS;
+	char *string = NULL;
+	char *tmp = NULL;
+	char *pos = NULL;
+	gfp_t flag;
+
+	ENTER();
+	if (!s || !d) {
+		LEAVE();
+		return -EINVAL;
+	}
+	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	string = kzalloc(RADIO_MODE_STR_LEN, flag);
+	if (string == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	moal_memcpy_ext(NULL, string, s + strlen("radio_mode="),
+			len - strlen("radio_mode="), RADIO_MODE_STR_LEN - 1);
+
+	tmp = string;
+	string = strstrip(string);
+
+	/* radio mode index 0 */
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->data1 = (t_u32)woal_string_to_number(pos);
+
+	/* radio mode index 1 */
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->data2 = (t_u32)woal_string_to_number(pos);
+
+	if ((d->data1 > 14) || (d->data2 > 14))
+		ret = -EINVAL;
+
+	kfree(tmp);
+	LEAVE();
+	return ret;
+}
+
+#ifdef SD9177
+/*
+ *  @brief PowerLevelToDUT11Bits
+ *
+ *  @param Pwr		A user txpwr values of type int
+ *  @param PowerLevel	A Pointer of uint32 type for converted txpwr vals
+ *  @return		nothing just exit
  */
-void woal_ioctl_get_misc_conf(moal_private *priv, mlan_ds_misc_cfg *info)
+
+static void PowerLevelToDUT11Bits(int Pwr, t_u32 *PowerLevel)
 {
-	ENTER();
-	switch (info->sub_command) {
-	default:
-		break;
+	int Z = 0;
+
+	if ((Pwr > 64) || (Pwr < -64))
+		return;
+
+	Z = (int)(Pwr * 16);
+	if (Z < 0) {
+		Z = Z + (1 << 11);
 	}
+	(*PowerLevel) = (t_u32)Z;
+
+	return;
 }
+#endif
 
-#ifdef CONFIG_PROC_FS
-#define TX_PWR_STR_LEN 20
-#define TX_CONT_STR_LEN 50
-#define TX_FRAME_STR_LEN 80
 /*
  *  @brief Parse mfg cmd tx pwr string
  *
+ *  @param handle   A pointer to moal_handle structure
  *  @param s        A pointer to user buffer
  *  @param len      Length of user buffer
  *  @param d        A pointer to mfg_cmd_generic_cfg struct
  *  @return         0 on success, -EINVAL otherwise
  */
-static int parse_tx_pwr_string(const char *s, size_t len,
+
+static int parse_tx_pwr_string(moal_handle *handle, const char *s, size_t len,
 			       struct mfg_cmd_generic_cfg *d)
 {
 	int ret = MLAN_STATUS_SUCCESS;
@@ -6503,12 +8244,21 @@ static int parse_tx_pwr_string(const char *s, size_t len,
 	char *tmp = NULL;
 	char *pos = NULL;
 	gfp_t flag;
+#ifdef SD9177
+	t_u32 tx_pwr_converted = 0xffffffff;
+	int tx_pwr_local = 0;
+	t_u8 fc_card = MFALSE;
+#endif
 
 	ENTER();
 	if (!s || !d) {
 		LEAVE();
 		return -EINVAL;
 	}
+#ifdef SD9177
+	if (IS_SD9177(handle->card_type))
+		fc_card = MTRUE;
+#endif
 	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
 	string = kzalloc(TX_PWR_STR_LEN, flag);
 	if (string == NULL) {
@@ -6524,9 +8274,18 @@ static int parse_tx_pwr_string(const char *s, size_t len,
 
 	/* tx power value */
 	pos = strsep(&string, " \t");
-	if (pos)
+#ifdef SD9177
+	if (fc_card && pos) {
+		/* for sd9177 we need to convert user power vals including -ve
+		 * vals as per labtool */
+		tx_pwr_local = woal_string_to_number(pos);
+		PowerLevelToDUT11Bits(tx_pwr_local, &tx_pwr_converted);
+		d->data1 = tx_pwr_converted;
+	} else
+#endif
+		if (pos) {
 		d->data1 = (t_u32)woal_string_to_number(pos);
-
+	}
 	/* modulation */
 	pos = strsep(&string, " \t");
 	if (pos)
@@ -6537,7 +8296,12 @@ static int parse_tx_pwr_string(const char *s, size_t len,
 	if (pos)
 		d->data3 = (t_u32)woal_string_to_number(pos);
 
-	if ((d->data1 > 24) || (d->data2 > 2))
+#ifdef SD9177
+	if (((!fc_card) && ((d->data1 > 24) && (d->data1 != 0xffffffff))) ||
+	    (d->data2 > 2))
+#else
+	if (((d->data1 > 24) && (d->data1 != 0xffffffff)) || (d->data2 > 2))
+#endif
 		ret = -EINVAL;
 
 	kfree(tmp);
@@ -6583,13 +8347,13 @@ static int parse_tx_cont_string(const char *s, size_t len,
 	if (pos)
 		d->enable_tx = (t_u32)woal_string_to_number(pos);
 
-	if (d->enable_tx == MFALSE)
-		goto done;
-
 	pos = strsep(&string, " \t");
 	if (pos)
 		d->cw_mode = (t_u32)woal_string_to_number(pos);
 
+	if (d->enable_tx == MFALSE)
+		goto done;
+
 	pos = strsep(&string, " \t");
 	if (pos)
 		d->payload_pattern = (t_u32)woal_string_to_number(pos);
@@ -6614,6 +8378,209 @@ static int parse_tx_cont_string(const char *s, size_t len,
 	LEAVE();
 	return ret;
 }
+/*
+ *  @brief Parse mfg cmd trigger string
+ *
+ *  @param s        A pointer to user buffer
+ *  @param len      Length of user buffer
+ *  @param d        A pointer to mfg_cmd_tx_frame2 struct
+ *  @return         0 on success, -EINVAL otherwise
+ */
+static int parse_trigger_frame_string(const char *s, size_t len,
+				      mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t *d)
+{
+	int ret = MLAN_STATUS_SUCCESS;
+	char *string = NULL;
+	char *tmp = NULL;
+	char *pos = NULL;
+	gfp_t flag;
+
+	ENTER();
+	if (!s || !d) {
+		LEAVE();
+		return -EINVAL;
+	}
+	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	string = kzalloc(TRIGGER_FRAME_STR_LEN, flag);
+	if (string == NULL)
+		return -ENOMEM;
+
+	moal_memcpy_ext(NULL, string, s + strlen("trigger_frame="),
+			len - strlen("trigger_frame="),
+			TRIGGER_FRAME_STR_LEN - 1);
+
+	tmp = string;
+	string = strstrip(string);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->enable_tx = (t_u32)woal_string_to_number(pos);
+
+	if (d->enable_tx == MFALSE)
+		goto done;
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->standalone_hetb = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->frmCtl.type = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->frmCtl.sub_type = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->duration = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.trigger_type =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ul_len = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.more_tf =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.cs_required =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ul_bw = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ltf_type =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ltf_mode =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ltf_symbol =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ul_stbc =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ldpc_ess =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.ap_tx_pwr =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.pre_fec_pad_fct =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.pe_disambig =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.spatial_reuse =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.doppler =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_common_field.he_sig2 =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.aid12 =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ru_alloc_reg =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ru_alloc =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ul_coding_type =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ul_mcs =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ul_dcm =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ss_alloc =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->trig_user_info_field.ul_target_rssi =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->basic_trig_user_info.mpdu_mu_sf =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->basic_trig_user_info.tid_al =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->basic_trig_user_info.ac_pl =
+			(t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->basic_trig_user_info.pref_ac =
+			(t_u32)woal_string_to_number(pos);
+
+	if (d->enable_tx > 1)
+		ret = -EINVAL;
+
+done:
+	kfree(tmp);
+	LEAVE();
+	return ret;
+}
 
 /*
  *  @brief Parse mfg cmd tx frame string
@@ -6704,12 +8671,42 @@ static int parse_tx_frame_string(const char *s, size_t len,
 	if (pos)
 		d->stbc = (t_u32)woal_string_to_number(pos);
 
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->NumPkt = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->MaxPE = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->BeamChange = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->Dcm = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->Doppler = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->MidP = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->QNum = (t_u32)woal_string_to_number(pos);
+
 	pos = strsep(&string, " \t");
 	if (pos) {
+		char *begin, *end;
+		begin = pos;
 		for (i = 0; i < ETH_ALEN; i++) {
-			pos = strsep(&string, ":");
-			if (pos)
-				d->bssid[i] = woal_atox(pos);
+			end = woal_strsep(&begin, ':', '/');
+			if (end)
+				d->bssid[i] = woal_atox(end);
 		}
 	}
 
@@ -6725,7 +8722,69 @@ static int parse_tx_frame_string(const char *s, size_t len,
 	LEAVE();
 	return ret;
 }
-/**
+
+/*
+ *  @brief Parse mfg cmd HE TB Tx string
+ *
+ *  @param s        A pointer to user buffer
+ *  @param len      Length of user buffer
+ *  @param d        A pointer to mfg_Cmd_HE_TBTx_t struct
+ *  @return         0 on success, -EINVAL otherwise
+ */
+static int parse_he_tb_tx_string(const char *s, size_t len,
+				 struct mfg_Cmd_HE_TBTx_t *d)
+{
+	int ret = MLAN_STATUS_SUCCESS;
+	char *string = NULL;
+	char *pos = NULL;
+	char *tmp = NULL;
+	gfp_t flag;
+
+	ENTER();
+	if (!s || !d) {
+		LEAVE();
+		return -EINVAL;
+	}
+	flag = (in_atomic() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	string = kzalloc(HE_TB_TX_STR_LEN, flag);
+	if (string == NULL)
+		return -ENOMEM;
+
+	moal_memcpy_ext(NULL, string, s + strlen("he_tb_tx="),
+			len - strlen("he_tb_tx="), HE_TB_TX_STR_LEN - 1);
+
+	tmp = string;
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->enable = (t_u32)woal_string_to_number(pos);
+
+	if (d->enable == MFALSE)
+		goto done;
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->qnum = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->aid = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->axq_mu_timer = (t_u32)woal_string_to_number(pos);
+
+	pos = strsep(&string, " \t");
+	if (pos)
+		d->tx_power = (t_u16)woal_string_to_number(pos);
+
+	if (d->enable > 1)
+		ret = -EINVAL;
+
+done:
+	kfree(tmp);
+	LEAVE();
+	return ret;
+}
+/*
  *  @brief This function enables/disables RF test mode in firmware
  *
  *  @param handle   A pointer to moal_handle structure
@@ -6849,8 +8908,13 @@ mlan_status woal_process_rf_test_mode_cmd(moal_handle *handle, t_u32 cmd,
 		break;
 	case MFG_CMD_CLR_RX_ERR:
 		break;
+	case MFG_CMD_RADIO_MODE_CFG:
+		if (parse_radio_mode_string(buffer, len,
+					    &misc->param.mfg_generic_cfg))
+			err = MTRUE;
+		break;
 	case MFG_CMD_RFPWR:
-		if (parse_tx_pwr_string(buffer, len,
+		if (parse_tx_pwr_string(handle, buffer, len,
 					&misc->param.mfg_generic_cfg))
 			err = MTRUE;
 		break;
@@ -6865,6 +8929,18 @@ mlan_status woal_process_rf_test_mode_cmd(moal_handle *handle, t_u32 cmd,
 					  &misc->param.mfg_tx_frame2))
 			err = MTRUE;
 		break;
+	case MFG_CMD_CONFIG_MAC_HE_TB_TX:
+		misc->sub_command = MLAN_OID_MISC_RF_TEST_HE_POWER;
+		if (parse_he_tb_tx_string(buffer, len,
+					  &misc->param.mfg_he_power))
+			err = MTRUE;
+		break;
+	case MFG_CMD_CONFIG_TRIGGER_FRAME:
+		misc->sub_command = MLAN_OID_MISC_RF_TEST_CONFIG_TRIGGER_FRAME;
+		if (parse_trigger_frame_string(
+			    buffer, len, &misc->param.mfg_tx_trigger_config))
+			err = MTRUE;
+		break;
 	default:
 		err = MTRUE;
 	}
@@ -6889,6 +8965,12 @@ mlan_status woal_process_rf_test_mode_cmd(moal_handle *handle, t_u32 cmd,
 	case MFG_CMD_RX_ANT:
 		handle->rf_data->rx_antenna = misc->param.mfg_generic_cfg.data1;
 		break;
+	case MFG_CMD_RADIO_MODE_CFG:
+		handle->rf_data->radio_mode[0] =
+			misc->param.mfg_generic_cfg.data1;
+		handle->rf_data->radio_mode[1] =
+			misc->param.mfg_generic_cfg.data2;
+		break;
 	case MFG_CMD_RF_BAND_AG:
 		handle->rf_data->band = misc->param.mfg_generic_cfg.data1;
 		/* set fw default bw and channel config on band change */
@@ -6961,11 +9043,52 @@ mlan_status woal_process_rf_test_mode_cmd(moal_handle *handle, t_u32 cmd,
 			misc->param.mfg_tx_frame2.gf_mode;
 		handle->rf_data->tx_frame_data[12] =
 			misc->param.mfg_tx_frame2.stbc;
+		handle->rf_data->tx_frame_data[13] =
+			misc->param.mfg_tx_frame2.NumPkt;
+		handle->rf_data->tx_frame_data[14] =
+			misc->param.mfg_tx_frame2.MaxPE;
+		handle->rf_data->tx_frame_data[15] =
+			misc->param.mfg_tx_frame2.BeamChange;
+		handle->rf_data->tx_frame_data[16] =
+			misc->param.mfg_tx_frame2.Dcm;
+		handle->rf_data->tx_frame_data[17] =
+			misc->param.mfg_tx_frame2.Doppler;
+		handle->rf_data->tx_frame_data[18] =
+			misc->param.mfg_tx_frame2.MidP;
+		handle->rf_data->tx_frame_data[19] =
+			misc->param.mfg_tx_frame2.QNum;
 		for (i = 0; i < ETH_ALEN; i++) {
 			handle->rf_data->bssid[i] =
 				misc->param.mfg_tx_frame2.bssid[i];
 		}
 		break;
+	case MFG_CMD_CONFIG_MAC_HE_TB_TX:
+		handle->rf_data->he_tb_tx[0] = misc->param.mfg_he_power.enable;
+		handle->rf_data->he_tb_tx[1] = misc->param.mfg_he_power.qnum;
+		handle->rf_data->he_tb_tx[2] = misc->param.mfg_he_power.aid;
+		handle->rf_data->he_tb_tx[3] =
+			misc->param.mfg_he_power.axq_mu_timer;
+		handle->rf_data->he_tb_tx_power[0] =
+			misc->param.mfg_he_power.tx_power;
+		break;
+	case MFG_CMD_CONFIG_TRIGGER_FRAME:
+		handle->rf_data->mfg_tx_trigger_config.enable_tx =
+			misc->param.mfg_tx_trigger_config.enable_tx;
+		handle->rf_data->mfg_tx_trigger_config.standalone_hetb =
+			misc->param.mfg_tx_trigger_config.standalone_hetb;
+		handle->rf_data->mfg_tx_trigger_config.frmCtl.type =
+			misc->param.mfg_tx_trigger_config.frmCtl.type;
+		handle->rf_data->mfg_tx_trigger_config.frmCtl.sub_type =
+			misc->param.mfg_tx_trigger_config.frmCtl.sub_type;
+		handle->rf_data->mfg_tx_trigger_config.duration =
+			misc->param.mfg_tx_trigger_config.duration;
+		handle->rf_data->mfg_tx_trigger_config.trig_common_field =
+			misc->param.mfg_tx_trigger_config.trig_common_field;
+		handle->rf_data->mfg_tx_trigger_config.trig_user_info_field =
+			misc->param.mfg_tx_trigger_config.trig_user_info_field;
+		handle->rf_data->mfg_tx_trigger_config.basic_trig_user_info =
+			misc->param.mfg_tx_trigger_config.basic_trig_user_info;
+		break;
 	}
 done:
 	if (err || ret != MLAN_STATUS_PENDING)
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.c
old mode 100644
new mode 100755
index a4d5f0b8b..0cee5e16d
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.c
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -60,16 +60,26 @@ Change log:
 #include <linux/tcp.h>
 #include <net/tcp.h>
 #include <net/dsfield.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#include <linux/mpls.h>
+#endif
+#include <linux/if_vlan.h>
 
 #ifdef CONFIG_OF
 #include <linux/of.h>
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+#include <net/addrconf.h>
+#endif
+#endif
+
 /********************************************************
 		 Global Variables
  ********************************************************/
 /** the pointer of new fwdump fname for each dump**/
-char *fwdump_fname;
+static char *fwdump_fname;
 /** Semaphore for add/remove card */
 struct semaphore AddRemoveCardSem;
 /**
@@ -77,20 +87,47 @@ struct semaphore AddRemoveCardSem;
  * structure variable
  **/
 moal_handle *m_handle[MAX_MLAN_ADAPTER];
-/** Global veriable for usb independent reset */
-extern int fw_reload;
-
-extern int wifi_status;
-
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-extern int fw_region;
-#endif
-#endif
+static int reg_work;
 /********************************************************
 		Local Variables
 ********************************************************/
 
+#ifdef SD8801
+static struct _card_info card_info_SD8801 = {
+	.embedded_supp = 0,
+	.drcs = 0,
+	.go_noa = 0,
+	.v14_fw_api = 1,
+	.v16_fw_api = 0,
+	.v17_fw_api = 0,
+	.pmic = 0,
+	.cal_data_cfg = 0,
+	.low_power_enable = 1,
+	.rx_rate_max = 76,
+	.histogram_table_num = 1,
+	.feature_control = FEATURE_CTRL_DEFAULT & (~FEATURE_CTRL_STREAM_2X2),
+	.fw_name = SD8801_DEFAULT_WLAN_FW_NAME,
+	.fw_name_wlan = SD8801_DEFAULT_WLAN_FW_NAME,
+#ifdef SDIO
+	.dump_fw_info = 0,
+	.dump_fw_ctrl_reg = 0x63,
+	.dump_fw_start_reg = 0x64,
+	.dump_fw_end_reg = 0x6A,
+	.dump_fw_host_ready = 0xee,
+	.dump_reg.reg_table = {0x28, 0x30, 0x34, 0x38, 0x3c},
+	.dump_reg.reg_table_size = 5,
+	.scratch_reg = 0x60,
+	.func1_reg_start = 0x10,
+	.func1_reg_end = 0x17,
+	.fw_reset_reg = 0x64,
+	.fw_reset_val = 0,
+	.slew_rate_reg = 0x8000231C,
+	.slew_rate_bit_offset = 14,
+#endif
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 0,
+};
+#endif
 #ifdef SD8887
 static struct _card_info card_info_SD8887 = {
 	.embedded_supp = 1,
@@ -123,6 +160,7 @@ static struct _card_info card_info_SD8887 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 0,
 	.per_pkt_cfg_support = 0,
 };
 #endif
@@ -158,6 +196,7 @@ static struct _card_info card_info_SD8897 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 0,
 	.per_pkt_cfg_support = 0,
 };
 #endif
@@ -177,6 +216,7 @@ static struct _card_info card_info_PCIE8897 = {
 	.rev_id_reg = 0x0c58,
 	.fw_name = PCIE8897_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = PCIE8897_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 0,
 	.per_pkt_cfg_support = 0,
 };
 #endif
@@ -195,6 +235,7 @@ static struct _card_info card_info_USB8897 = {
 	.feature_control = FEATURE_CTRL_DEFAULT,
 	.fw_name = USB8897_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = USB8897_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 0,
 	.per_pkt_cfg_support = 0,
 };
 #endif
@@ -233,6 +274,7 @@ static struct _card_info card_info_SD8977 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -271,6 +313,7 @@ static struct _card_info card_info_SD8978 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -309,6 +352,7 @@ static struct _card_info card_info_SD8997 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -348,6 +392,7 @@ static struct _card_info card_info_SD9098 = {
 	.slew_rate_reg = 0x90002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -387,6 +432,125 @@ static struct _card_info card_info_SD9097 = {
 	.slew_rate_reg = 0x90002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+#endif
+
+#ifdef SDIW62X
+static struct _card_info card_info_SDIW62X = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.histogram_table_num = 3,
+	.feature_control = FEATURE_CTRL_DEFAULT,
+	.rev_id_reg = 0xc8,
+	.host_strap_reg = 0xf4,
+	.magic_reg = 0xf0,
+	.fw_name = SDIW62X_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = SDIW62X_DEFAULT_WLAN_FW_NAME,
+#ifdef SDIO
+	.dump_fw_info = DUMP_FW_SDIO_V3,
+	.dump_fw_ctrl_reg = 0xf9,
+	.dump_fw_start_reg = 0xf1,
+	.dump_fw_end_reg = 0xf8,
+	.dump_fw_host_ready = 0xcc,
+	.dump_reg.reg_table = {0x08, 0x58, 0x5C, 0x5D, 0x60, 0x61, 0x62, 0x64,
+			       0x65, 0x66, 0x68, 0x69, 0x6a},
+	.dump_reg.reg_table_size = 13,
+	.scratch_reg = 0xe8,
+	.func1_reg_start = 0x10,
+	.func1_reg_end = 0x17,
+	.fw_reset_reg = 0x0EE,
+	.fw_reset_val = 0x99,
+	.slew_rate_reg = 0x90002328,
+	.slew_rate_bit_offset = 12,
+#endif
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+#endif
+
+static struct _card_info card_info_SDAW693 = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.histogram_table_num = 3,
+	.feature_control = FEATURE_CTRL_DEFAULT,
+	.rev_id_reg = 0xc8,
+	.host_strap_reg = 0xf4,
+	.magic_reg = 0xf0,
+	.fw_name = SDAW693_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = SDAW693_DEFAULT_WLAN_FW_NAME,
+#ifdef SDIO
+	.dump_fw_info = DUMP_FW_SDIO_V3,
+	.dump_fw_ctrl_reg = 0xf9,
+	.dump_fw_start_reg = 0xf1,
+	.dump_fw_end_reg = 0xf8,
+	.dump_fw_host_ready = 0xcc,
+	.dump_reg.reg_table = {0x08, 0x58, 0x5C, 0x5D, 0x60, 0x61, 0x62, 0x64,
+			       0x65, 0x66, 0x68, 0x69, 0x6a},
+	.dump_reg.reg_table_size = 13,
+	.scratch_reg = 0xe8,
+	.func1_reg_start = 0x10,
+	.func1_reg_end = 0x17,
+	.fw_reset_reg = 0x0EE,
+	.fw_reset_val = 0x99,
+	.slew_rate_reg = 0x90002328,
+	.slew_rate_bit_offset = 12,
+#endif
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+
+#ifdef SD9177
+static struct _card_info card_info_SD9177 = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.histogram_table_num = 3,
+	.feature_control = FEATURE_CTRL_DEFAULT & (~FEATURE_CTRL_STREAM_2X2),
+	.rev_id_reg = 0xc8,
+	.host_strap_reg = 0xf4,
+	.magic_reg = 0xf0,
+	.fw_name = SD9177_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = SD9177_DEFAULT_WLAN_FW_NAME,
+#ifdef SDIO
+	.dump_fw_info = DUMP_FW_SDIO_V3,
+	.dump_fw_ctrl_reg = 0xf9,
+	.dump_fw_start_reg = 0xf1,
+	.dump_fw_end_reg = 0xf8,
+	.dump_fw_host_ready = 0xcc,
+	.dump_reg.reg_table = {0x08, 0x58, 0x5C, 0x5D, 0x60, 0x61, 0x62, 0x64,
+			       0x65, 0x66, 0x68, 0x69, 0x6a},
+	.dump_reg.reg_table_size = 13,
+	.scratch_reg = 0xe8,
+	.func1_reg_start = 0x10,
+	.func1_reg_end = 0x17,
+	.fw_reset_reg = 0x0EE,
+	.fw_reset_val = 0x99,
+	.slew_rate_reg = 0x90002328,
+	.slew_rate_bit_offset = 12,
+#endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -408,6 +572,7 @@ static struct _card_info card_info_PCIE8997 = {
 	.magic_reg = 0x0cd4,
 	.fw_name = PCIE8997_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = PCIE8997_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -430,6 +595,9 @@ static struct _card_info card_info_PCIE9097 = {
 	.magic_reg = 0x1c74,
 	.fw_name = PCIE9097_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = PCIE9097_DEFAULT_WLAN_FW_NAME,
+	.fw_reset_reg = 0x1c94,
+	.fw_reset_val = 0x98,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -452,8 +620,81 @@ static struct _card_info card_info_PCIE9098 = {
 	.magic_reg = 0x1c74,
 	.fw_name = PCIE9098_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = PCIE9098_DEFAULT_WLAN_FW_NAME,
+	.fw_reset_reg = 0x1c94,
+	.fw_reset_val = 0x98,
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+#endif
+
+#ifdef PCIEIW62X
+static struct _card_info card_info_PCIEIW62X = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.histogram_table_num = 3,
+	.feature_control = FEATURE_CTRL_DEFAULT,
+	.rev_id_reg = 0x8,
+	.host_strap_reg = 0x1c70,
+	.magic_reg = 0x1c74,
+	.boot_mode_reg = 0x1c8c,
+	.fw_name = PCIEIW62X_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = PCIEIW62X_DEFAULT_WLAN_FW_NAME,
+	.fw_reset_reg = 0x1c94,
+	.fw_reset_val = 0x98,
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+#endif
+
+static struct _card_info card_info_PCIEAW693 = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.histogram_table_num = 3,
+	.feature_control = FEATURE_CTRL_DEFAULT,
+	.rev_id_reg = 0x8,
+	.host_strap_reg = 0x1c70,
+	.magic_reg = 0x1c74,
+	.fw_name = PCIEAW693_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = PCIEAW693_DEFAULT_WLAN_FW_NAME,
+	.fw_reset_reg = 0x1c94,
+	.fw_reset_val = 0x98,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
+
+#ifdef USB8801
+static struct _card_info card_info_USB8801 = {
+	.embedded_supp = 0,
+	.drcs = 0,
+	.go_noa = 0,
+	.v14_fw_api = 1,
+	.v16_fw_api = 0,
+	.v17_fw_api = 0,
+	.pmic = 0,
+	.cal_data_cfg = 0,
+	.low_power_enable = 1,
+	.rx_rate_max = 76,
+	.feature_control = FEATURE_CTRL_DEFAULT & (~FEATURE_CTRL_STREAM_2X2),
+	.histogram_table_num = 1,
+	.fw_name = USB8801_DEFAULT_WLAN_FW_NAME,
+	.fw_name_wlan = USB8801_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 0,
+};
 #endif
 
 #ifdef USB8978
@@ -470,6 +711,7 @@ static struct _card_info card_info_USB8978 = {
 	.histogram_table_num = 1,
 	.fw_name = USB8978_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = USB8978_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -488,6 +730,7 @@ static struct _card_info card_info_USB8997 = {
 	.histogram_table_num = 3,
 	.fw_name = USB8997_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = USB8997_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -507,6 +750,7 @@ static struct _card_info card_info_USB9098 = {
 	.histogram_table_num = 3,
 	.fw_name = USB9098_DEFAULT_COMBO_FW_NAME,
 	.fw_name_wlan = USB9098_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -526,9 +770,31 @@ static struct _card_info card_info_USB9097 = {
 	.histogram_table_num = 3,
 	.fw_name = USBUSB9097_COMBO_V1_FW_NAME,
 	.fw_name_wlan = USB9097_WLAN_V1_FW_NAME,
+	.sniffer_support = 1,
+	.per_pkt_cfg_support = 1,
+};
+#endif
+
+#ifdef USBIW62X
+static struct _card_info card_info_USBIW62X = {
+	.embedded_supp = 1,
+	.drcs = 1,
+	.go_noa = 1,
+	.v16_fw_api = 1,
+	.v17_fw_api = 1,
+	.pmic = 1,
+	.cal_data_cfg = 0,
+	.low_power_enable = 0,
+	.rx_rate_max = 412,
+	.feature_control = FEATURE_CTRL_DEFAULT,
+	.histogram_table_num = 3,
+	.fw_name = USBIW62X_DEFAULT_COMBO_FW_NAME,
+	.fw_name_wlan = USBIW62X_DEFAULT_WLAN_FW_NAME,
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
+
 #ifdef SD8987
 static struct _card_info card_info_SD8987 = {
 	.embedded_supp = 1,
@@ -562,6 +828,7 @@ static struct _card_info card_info_SD8987 = {
 	.slew_rate_reg = 0x80002328,
 	.slew_rate_bit_offset = 12,
 #endif
+	.sniffer_support = 1,
 	.per_pkt_cfg_support = 1,
 };
 #endif
@@ -585,6 +852,7 @@ static mlan_callbacks woal_callbacks = {
 	.moal_shutdown_fw_complete = moal_shutdown_fw_complete,
 	.moal_send_packet_complete = moal_send_packet_complete,
 	.moal_recv_packet = moal_recv_packet,
+	.moal_recv_amsdu_packet = moal_recv_amsdu_packet,
 	.moal_recv_event = moal_recv_event,
 	.moal_ioctl_complete = moal_ioctl_complete,
 	.moal_alloc_mlan_buffer = moal_alloc_mlan_buffer,
@@ -631,15 +899,21 @@ static mlan_callbacks woal_callbacks = {
 	.moal_print_netintf = moal_print_netintf,
 	.moal_assert = moal_assert,
 	.moal_hist_data_add = moal_hist_data_add,
+	.moal_updata_peer_signal = moal_updata_peer_signal,
+	.moal_do_div = moal_do_div,
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
 	.moal_wait_hostcmd_complete = moal_wait_hostcmd_complete,
 	.moal_notify_hostcmd_complete = moal_notify_hostcmd_complete,
 #endif
+	.moal_tp_accounting = moal_tp_accounting,
+	.moal_tp_accounting_rx_param = moal_tp_accounting_rx_param,
+	.moal_amsdu_tp_accounting = moal_amsdu_tp_accounting,
 };
 
 int woal_open(struct net_device *dev);
 int woal_close(struct net_device *dev);
 int woal_set_mac_address(struct net_device *dev, void *addr);
+int woal_change_mtu(struct net_device *dev, int new_mtu);
 void woal_tx_timeout(struct net_device *dev
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
 		     ,
@@ -677,34 +951,123 @@ static moal_handle *reset_handle;
 static struct workqueue_struct *hang_workqueue;
 /** Hang work */
 static struct work_struct hang_work;
+/** register workqueue */
+static struct workqueue_struct *register_workqueue;
+/** register work */
+static struct work_struct register_work;
 
 /**
- *  @brief This function process FW hang
+ *  @brief This function send fw dump event to kernel
+ *
+ *  @param priv       Pointer to structure moal_private
+ *
+ *  @return        N/A
+ */
+void woal_send_fw_dump_complete_event(moal_private *priv)
+{
+	int cfg80211_wext = priv->phandle->params.cfg80211_wext;
+#ifdef STA_WEXT
+	if (IS_STA_WEXT(cfg80211_wext))
+		woal_send_iwevcustom_event(priv, CUS_EVT_FW_DUMP_DONE);
+#endif
+#ifdef STA_CFG80211
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+	if (IS_STA_CFG80211(cfg80211_wext))
+		woal_cfg80211_vendor_event_fw_dump(priv);
+#endif
+#endif
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_broadcast_event(priv, CUS_EVT_FW_DUMP_DONE,
+				 strlen(CUS_EVT_FW_DUMP_DONE)))
+		PRINTM(MINFO, "%s: woal_broadcast_event failed \n", __func__);
+
+	return;
+}
+
+/**
+ *  @brief This function clean up adapter
  *
  *  @param handle       Pointer to structure moal_handle
  *
  *  @return        N/A
  */
-static void woal_hang_work_queue(struct work_struct *work)
+void woal_clean_up(moal_handle *handle)
 {
 	int i;
-	ENTER();
-	if (!reset_handle) {
-		LEAVE();
-		return;
+	moal_private *priv;
+	int cfg80211_wext = 0;
+	cfg80211_wext = handle->params.cfg80211_wext;
+#ifdef STA_CFG80211
+	if (IS_STA_CFG80211(cfg80211_wext) && handle->scan_request &&
+	    handle->scan_priv) {
+		moal_private *scan_priv = handle->scan_priv;
+		/** some supplicant can not handle SCAN abort event */
+		if (scan_priv->bss_type == MLAN_BSS_TYPE_STA)
+			woal_cfg80211_scan_done(handle->scan_request, MTRUE);
+		else
+			woal_cfg80211_scan_done(handle->scan_request, MFALSE);
+		handle->scan_request = NULL;
+		handle->scan_priv = NULL;
+		cancel_delayed_work_sync(&handle->scan_timeout_work);
+		handle->scan_pending_on_block = MFALSE;
+		MOAL_REL_SEMAPHORE(&handle->async_sem);
 	}
-	for (i = 0; i < reset_handle->priv_num; i++) {
-		if (reset_handle->priv[i] && reset_handle->priv[i]->netdev) {
-			PRINTM(MMSG, "Close netdev %s\n",
-			       reset_handle->priv[i]->netdev->name);
-			rtnl_lock();
-			dev_close(reset_handle->priv[i]->netdev);
-			rtnl_unlock();
-			break;
+#endif
+	for (i = 0; i < handle->priv_num; i++) {
+		if (handle->priv[i]) {
+			priv = handle->priv[i];
+			woal_stop_queue(priv->netdev);
+			if (netif_carrier_ok(priv->netdev))
+				netif_carrier_off(priv->netdev);
+			priv->media_connected = MFALSE;
+			// disconnect
+			moal_connection_status_check_pmqos(priv->phandle);
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+			if (IS_STA_CFG80211(cfg80211_wext) && priv->wdev &&
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			    priv->wdev->connected) {
+#else
+			    priv->wdev->current_bss) {
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+				if (priv->host_mlme)
+					woal_host_mlme_disconnect(
+						priv,
+						MLAN_REASON_DEAUTH_LEAVING,
+						NULL);
+				else
+#endif
+					cfg80211_disconnected(priv->netdev, 0,
+							      NULL, 0,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+							      true,
+#endif
+							      GFP_KERNEL);
+			}
+#endif
+#endif
+			// stop bgscan
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+			if (IS_STA_CFG80211(cfg80211_wext) &&
+			    priv->sched_scanning) {
+				priv->bg_scan_start = MFALSE;
+				priv->bg_scan_reported = MFALSE;
+				cfg80211_sched_scan_stopped(priv->wdev->wiphy
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+							    ,
+							    priv->bg_scan_reqid
+#endif
+				);
+				priv->sched_scanning = MFALSE;
+			}
+#endif
+#endif
 		}
 	}
-	reset_handle = NULL;
-	LEAVE();
+	return;
 }
 
 /**
@@ -714,17 +1077,220 @@ static void woal_hang_work_queue(struct work_struct *work)
  *
  *  @return        N/A
  */
-void woal_process_hang(moal_handle *handle)
+static void woal_hang_work_queue(struct work_struct *work)
 {
+	int i;
+	moal_private *priv;
+	int cfg80211_wext = 0;
+	int ret = 0;
+	t_u8 reload_mode = 0;
 	ENTER();
-	if (reset_handle == NULL) {
-		PRINTM(MMSG, "Start to process hanging\n");
-		reset_handle = handle;
-		mlan_ioctl(handle->pmlan_adapter, NULL);
-		queue_work(hang_workqueue, &hang_work);
+	if (!reset_handle) {
+		LEAVE();
+		return;
+	}
+
+	mlan_ioctl(reset_handle->pmlan_adapter, NULL);
+	cfg80211_wext = reset_handle->params.cfg80211_wext;
+	// stop pending scan
+#ifdef STA_CFG80211
+	if (IS_STA_CFG80211(cfg80211_wext) && reset_handle->scan_request &&
+	    reset_handle->scan_priv) {
+		moal_private *scan_priv = reset_handle->scan_priv;
+		/** some supplicant can not handle SCAN abort event */
+		if (scan_priv->bss_type == MLAN_BSS_TYPE_STA)
+			woal_cfg80211_scan_done(reset_handle->scan_request,
+						MTRUE);
+		else
+			woal_cfg80211_scan_done(reset_handle->scan_request,
+						MFALSE);
+		reset_handle->scan_request = NULL;
+		reset_handle->scan_priv = NULL;
+		cancel_delayed_work_sync(&reset_handle->scan_timeout_work);
+		reset_handle->scan_pending_on_block = MFALSE;
+		MOAL_REL_SEMAPHORE(&reset_handle->async_sem);
+	}
+#endif
+
+	for (i = 0; i < reset_handle->priv_num; i++) {
+		if (reset_handle->priv[i]) {
+			priv = reset_handle->priv[i];
+			woal_stop_queue(priv->netdev);
+			if (netif_carrier_ok(priv->netdev))
+				netif_carrier_off(priv->netdev);
+			priv->media_connected = MFALSE;
+			// disconnect
+			moal_connection_status_check_pmqos(priv->phandle);
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+			if (IS_STA_CFG80211(cfg80211_wext) && priv->wdev &&
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			    priv->wdev->connected) {
+#else
+			    priv->wdev->current_bss) {
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+				if (priv->host_mlme)
+					woal_host_mlme_disconnect(
+						priv,
+						MLAN_REASON_DEAUTH_LEAVING,
+						NULL);
+				else
+#endif
+					cfg80211_disconnected(priv->netdev, 0,
+							      NULL, 0,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+							      true,
+#endif
+							      GFP_KERNEL);
+			}
+#endif
+#endif
+			// stop bgscan
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+			if (IS_STA_CFG80211(cfg80211_wext) &&
+			    priv->sched_scanning && priv->wdev) {
+				priv->bg_scan_start = MFALSE;
+				priv->bg_scan_reported = MFALSE;
+				cfg80211_sched_scan_stopped(priv->wdev->wiphy
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+							    ,
+							    priv->bg_scan_reqid
+#endif
+				);
+				priv->sched_scanning = MFALSE;
+			}
+#endif
+#endif
+		}
+	}
+	woal_flush_workqueue(reset_handle);
+	if (reset_handle->params.auto_fw_reload) {
+		priv = woal_get_priv(reset_handle, MLAN_BSS_ROLE_ANY);
+		if (priv) {
+			woal_broadcast_event(priv, CUS_EVT_FW_RECOVER_START,
+					     strlen(CUS_EVT_FW_RECOVER_START));
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			if (IS_STA_OR_UAP_CFG80211(cfg80211_wext))
+				woal_cfg80211_vendor_event(
+					priv, event_fw_reset_start,
+					CUS_EVT_FW_RECOVER_START,
+					strlen(CUS_EVT_FW_RECOVER_START));
+#endif
+#endif
+		}
+		if (IS_SD(reset_handle->card_type)) {
+			PRINTM(MMSG, "WIFI auto_fw_reload: fw_reload=1\n");
+			ret = woal_request_fw_reload(
+				reset_handle, FW_RELOAD_SDIO_INBAND_RESET);
+		}
+#ifdef PCIE
+		else if (IS_PCIE(reset_handle->card_type)) {
+#define FW_RELOAD_PCIE_IN_BAND_RESET 3
+			if (reset_handle->params.auto_fw_reload ==
+			    FW_RELOAD_PCIE_IN_BAND_RESET) {
+				PRINTM(MMSG,
+				       "WIFI auto_fw_reload: fw_reload=6\n");
+				ret = woal_request_fw_reload(
+					reset_handle,
+					FW_RELOAD_PCIE_INBAND_RESET);
+			} else {
+				reset_handle->init_wait_q_woken = MFALSE;
+				PRINTM(MMSG,
+				       "WIFI auto_fw_reload: fw_reload=4\n");
+				ret = woal_request_fw_reload(
+					reset_handle, FW_RELOAD_PCIE_RESET);
+				if (!ret) {
+					/* Wait for FLR to complete */
+					wait_event_timeout(
+						reset_handle->init_wait_q,
+						reset_handle->init_wait_q_woken,
+						10 * HZ);
+					if (reset_handle->hardware_status !=
+					    HardwareStatusReady)
+						ret = -1;
+				}
+			}
+		}
+#endif
+		priv = woal_get_priv(reset_handle, MLAN_BSS_ROLE_ANY);
+		if (priv) {
+			if (ret) {
+				woal_broadcast_event(
+					priv, CUS_EVT_FW_RECOVER_FAIL,
+					strlen(CUS_EVT_FW_RECOVER_FAIL));
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+				if (IS_STA_OR_UAP_CFG80211(cfg80211_wext))
+					woal_cfg80211_vendor_event(
+						priv, event_fw_reset_failure,
+						CUS_EVT_FW_RECOVER_FAIL,
+						strlen(CUS_EVT_FW_RECOVER_FAIL));
+#endif
+#endif
+			} else {
+				woal_broadcast_event(
+					priv, CUS_EVT_FW_RECOVER_SUCCESS,
+					strlen(CUS_EVT_FW_RECOVER_SUCCESS));
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+				if (IS_STA_OR_UAP_CFG80211(cfg80211_wext))
+					woal_cfg80211_vendor_event(
+						priv, event_fw_reset_success,
+						CUS_EVT_FW_RECOVER_SUCCESS,
+						strlen(CUS_EVT_FW_RECOVER_SUCCESS));
+#endif
+#endif
+			}
+		}
+		reset_handle = NULL;
+		LEAVE();
+		return;
+	}
+	priv = woal_get_priv(reset_handle, MLAN_BSS_ROLE_ANY);
+	if (priv) {
+		woal_broadcast_event(priv, CUS_EVT_DRIVER_HANG,
+				     strlen(CUS_EVT_DRIVER_HANG));
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		if (IS_STA_OR_UAP_CFG80211(cfg80211_wext)) {
+			PRINTM(MMSG, "Send event_hang(0x0) vendor event");
+			if (IS_SD(reset_handle->card_type)) {
+				reload_mode = FW_RELOAD_SDIO_INBAND_RESET;
+			} else if (IS_PCIE(reset_handle->card_type)) {
+				reload_mode = FW_RELOAD_PCIE_INBAND_RESET;
+				// Todo: add check for FW_RELOAD_PCIE_RESET -
+				// FLR
+			}
+			woal_cfg80211_driver_hang_event(priv, reload_mode);
+		}
+#endif
+#endif
+	}
+	reset_handle = NULL;
+	LEAVE();
+}
+
+/**
+ *  @brief This function process FW hang
+ *
+ *  @param handle       Pointer to structure moal_handle
+ *
+ *  @return        N/A
+ */
+void woal_process_hang(moal_handle *handle)
+{
+	ENTER();
+	if (reset_handle == NULL) {
+		PRINTM(MMSG, "Start to process hanging\n");
+		reset_handle = handle;
+		queue_work(hang_workqueue, &hang_work);
 #ifdef ANDROID_KERNEL
 #define WAKE_LOCK_HANG 5000
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 		__pm_wakeup_event(&reset_handle->ws, WAKE_LOCK_HANG);
 #else
 		wake_lock_timeout(&reset_handle->wake_lock,
@@ -747,6 +1313,8 @@ t_u8 woal_is_any_interface_active(moal_handle *handle)
 {
 	int i;
 	for (i = 0; i < handle->priv_num; i++) {
+		if (!handle->priv[i])
+			continue;
 #ifdef STA_SUPPORT
 		if (GET_BSS_ROLE(handle->priv[i]) == MLAN_BSS_ROLE_STA) {
 			if (handle->priv[i]->media_connected == MTRUE)
@@ -763,6 +1331,260 @@ t_u8 woal_is_any_interface_active(moal_handle *handle)
 	return MFALSE;
 }
 
+#ifdef STA_CFG80211
+/**  @brief This function set/clear pmk to FW
+ *
+ *  @param priv     A Pointer to the moal_private structure
+ *  @param action     set/clear action
+ *
+ *  @return      0: success  fail otherwise
+ */
+int woal_set_clear_pmk(moal_private *priv, t_u8 action)
+{
+	mlan_ioctl_req *req;
+	mlan_ds_sec_cfg *sec;
+	mlan_status status;
+	int ret = 0;
+	t_u8 zero[MLAN_MAX_KEY_LENGTH] = {0};
+	ENTER();
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
+
+	if (req == NULL) {
+		ret = -ENOMEM;
+	} else {
+		sec = (mlan_ds_sec_cfg *)req->pbuf;
+		sec->sub_command = MLAN_OID_SEC_CFG_PASSPHRASE;
+		req->req_id = MLAN_IOCTL_SEC_CFG;
+		req->action = action;
+
+		if (action == MLAN_ACT_SET) {
+			sec->param.passphrase.psk_type = MLAN_PSK_PMK;
+			if (memcmp(priv->pmk.pmk, zero, MLAN_MAX_KEY_LENGTH))
+				moal_memcpy_ext(
+					priv->phandle,
+					&sec->param.passphrase.psk.pmk.pmk,
+					priv->pmk.pmk, MLAN_MAX_KEY_LENGTH,
+					sizeof(sec->param.passphrase.psk.pmk
+						       .pmk));
+			if (memcmp(priv->pmk.pmk_r0, zero,
+				   MLAN_MAX_KEY_LENGTH) &&
+			    memcmp(priv->pmk.pmk_r0_name, zero,
+				   MLAN_MAX_PMKR0_NAME_LENGTH)) {
+				moal_memcpy_ext(
+					priv->phandle,
+					&sec->param.passphrase.psk.pmk.pmk_r0,
+					priv->pmk.pmk_r0, MLAN_MAX_KEY_LENGTH,
+					sizeof(sec->param.passphrase.psk.pmk
+						       .pmk_r0));
+				moal_memcpy_ext(
+					priv->phandle,
+					&sec->param.passphrase.psk.pmk
+						 .pmk_r0_name,
+					priv->pmk.pmk_r0_name,
+					MLAN_MAX_PMKR0_NAME_LENGTH,
+					sizeof(sec->param.passphrase.psk.pmk
+						       .pmk_r0_name));
+			}
+		}
+
+		status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+		if (MLAN_STATUS_SUCCESS != status)
+			ret = -EFAULT;
+		if (status != MLAN_STATUS_PENDING)
+			kfree(req);
+	}
+
+	LEAVE();
+	return ret;
+}
+#endif
+
+/**
+ *  @brief This function handle the net interface ipaddr change event
+ *
+ *  @param nb      pointer to the notifier_block
+ *  @param event   event type
+ *  @param ptr     pointer to event struct
+ *
+ *  @return        NOTIFY_DONE or NOTIFY_OK
+ */
+static int woal_netdevice_event(struct notifier_block *nb, unsigned long event,
+				void *ptr)
+{
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
+	struct net_device *ndev;
+	moal_private *priv;
+
+	int ret = NOTIFY_OK;
+#ifdef STA_CFG80211
+	char rssi_low[11];
+#endif
+	ENTER();
+
+	ndev = ifa->ifa_dev->dev;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	if (!ndev || ndev->netdev_ops->ndo_open != woal_open)
+#else
+	if (!ndev || ndev->open != woal_open)
+#endif
+	{
+		PRINTM(MIOCTL, "IP changes not for us, ignore. ndev[%p]\n",
+		       ndev);
+		if (ndev)
+			PRINTM(MIOCTL, "changes on %s\n", ndev->name);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+	priv = (moal_private *)netdev_priv(ndev);
+	if (priv->bss_type != MLAN_BSS_TYPE_STA
+#ifdef WIFI_DIRECT_SUPPORT
+	    && priv->bss_type != MLAN_BSS_TYPE_WIFIDIRECT
+#endif
+	) {
+		PRINTM(MIOCTL, "Bss type [%d] is not STA/P2P, ignore\n",
+		       (int)priv->bss_type);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+
+	switch (event) {
+	case NETDEV_UP:
+		PRINTM(MIOCTL, "[%s]: New ip addr: 0x%08x\n", ndev->name,
+		       ifa->ifa_address);
+		/* Save the IP addr now */
+		moal_memcpy_ext(priv->phandle, priv->ip_addr, &ifa->ifa_address,
+				sizeof(ifa->ifa_address),
+				sizeof(priv->ip_addr));
+		priv->ip_addr_type = IPADDR_TYPE_IPV4;
+#ifdef STA_CFG80211
+		if (!moal_extflg_isset(priv->phandle, EXT_HW_TEST)) {
+			snprintf(rssi_low, sizeof(rssi_low), "%d",
+				 priv->rssi_low);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_rssi_low_threshold(priv, rssi_low,
+							MOAL_IOCTL_WAIT)) {
+				PRINTM(MERROR,
+				       "%s: woal_set_rssi_low_threshold failed \n",
+				       __func__);
+				goto done;
+			}
+		}
+#endif
+#ifdef STA_CFG80211
+		if (priv->phandle->fw_roam_enable &&
+		    (priv->phandle->fw_roam_enable != AUTO_RECONNECT) &&
+		    !moal_extflg_isset(priv->phandle, EXT_ROAMOFFLOAD_IN_HS)) {
+			snprintf(rssi_low, sizeof(rssi_low), "%d",
+				 priv->rssi_low);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_rssi_low_threshold(priv, rssi_low,
+							MOAL_IOCTL_WAIT)) {
+				PRINTM(MERROR,
+				       "%s: woal_set_rssi_low_threshold failed \n",
+				       __func__);
+				goto done;
+			}
+			if (priv->pmk_saved) {
+				woal_set_clear_pmk(priv, MLAN_ACT_SET);
+				priv->pmk_saved = false;
+			}
+		}
+#endif
+		break;
+	case NETDEV_DOWN:
+		PRINTM(MIOCTL, "[%s]: Ip addr removed.\n", ndev->name);
+		priv->ip_addr_type = IPADDR_TYPE_NONE;
+		memset(priv->ip_addr, 0, sizeof(priv->ip_addr));
+		break;
+	default:
+		PRINTM(MIOCTL, "[%s]: Ignore event: %u\n", ndev->name,
+		       (unsigned int)event);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+/**
+ *  @brief This function handle the net interface ipv6 address change event
+ *
+ *  @param nb      pointer to the notifier_block
+ *  @param event   event type
+ *  @param ptr     pointer to event struct
+ *
+ *  @return        NOTIFY_DONE or NOTIFY_OK
+ */
+static int woal_inet6_netdeive_event(struct notifier_block *nb,
+				     unsigned long event, void *ptr)
+{
+	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
+	struct net_device *ndev = ifa->idev->dev;
+	moal_private *priv;
+	int ret = NOTIFY_OK;
+
+	ENTER();
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	if (!ndev || ndev->netdev_ops->ndo_open != woal_open)
+#else
+	if (!ndev || ndev->open != woal_open)
+#endif
+	{
+		PRINTM(MIOCTL, "IPV6 changes not for us, ignore. ndev[%p]\n",
+		       ndev);
+		if (ndev)
+			PRINTM(MIOCTL, "changes on %s\n", ndev->name);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+	priv = (moal_private *)netdev_priv(ndev);
+	if (!priv) {
+		PRINTM(MERROR, "Invalid private structure\n");
+		goto done;
+	}
+	if (priv->bss_type != MLAN_BSS_TYPE_STA
+#ifdef WIFI_DIRECT_SUPPORT
+	    && priv->bss_type != MLAN_BSS_TYPE_WIFIDIRECT
+#endif
+	) {
+		PRINTM(MIOCTL, "Bss type [%d] is not STA/P2P, ignore\n",
+		       (int)priv->bss_type);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+
+	switch (event) {
+	case NETDEV_UP:
+		PRINTM(MIOCTL, "[%s]: New ipv6 addr\n", ndev->name);
+		moal_memcpy_ext(priv->phandle, priv->ipv6_addr,
+				(t_u8 *)&ifa->addr, sizeof(priv->ipv6_addr),
+				sizeof(priv->ipv6_addr));
+		priv->ipv6_addr_configured = MTRUE;
+		break;
+	case NETDEV_DOWN:
+		PRINTM(MIOCTL, "[%s]: Ipv6 addr removed.\n", ndev->name);
+		memset(priv->ipv6_addr, 0, sizeof(priv->ipv6_addr));
+		priv->ipv6_addr_configured = MFALSE;
+		break;
+	default:
+		PRINTM(MIOCTL, "[%s]: Ignore event: %u\n", ndev->name,
+		       (unsigned int)event);
+		ret = NOTIFY_DONE;
+		goto done;
+	}
+done:
+	LEAVE();
+	return ret;
+}
+#endif
+#endif
+
 /**
  *  @brief This function validates a SSID as being able to be printed
  *
@@ -987,7 +1809,6 @@ const t_u8 *woal_parse_ext_ie_tlv(const t_u8 *ie, int len, t_u8 ext_id)
  */
 t_u32 woal_get_mode(moal_private *priv, t_u8 wait_option)
 {
-	int ret = 0;
 	mlan_ds_bss *bss = NULL;
 	mlan_ioctl_req *req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -1001,7 +1822,7 @@ t_u32 woal_get_mode(moal_private *priv, t_u8 wait_option)
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -1085,6 +1906,7 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 #ifdef WIFI_DIRECT_SUPPORT
 	int max_wfd_bss = handle->params.max_wfd_bss;
 #endif
+	int max_dfs_bss = MAX_DFS_BSS;
 
 	ENTER();
 
@@ -1132,6 +1954,8 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 
 #endif /* WIFI_DIRECT_SUPPORT */
 
+	if (drv_mode_local & DRV_MODE_DFS)
+		intf_num += max_dfs_bss;
 	/* Create BSS attribute table */
 	if ((intf_num == 0) || (intf_num > MLAN_MAX_BSS_NUM)) {
 		PRINTM(MERROR, "Unsupported number of BSS %d\n", intf_num);
@@ -1152,7 +1976,7 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 #ifdef STA_SUPPORT
 	if (drv_mode_local & DRV_MODE_STA) {
 		for (j = 0; j < max_sta_bss; j++) {
-			if (i >= intf_num)
+			if (i >= (int)intf_num)
 				break;
 			bss_tbl[i].bss_type = MLAN_BSS_TYPE_STA;
 			bss_tbl[i].frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
@@ -1168,7 +1992,7 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 #ifdef UAP_SUPPORT
 	if (drv_mode_local & DRV_MODE_UAP) {
 		for (j = 0; j < max_uap_bss; j++) {
-			if (i >= intf_num)
+			if (i >= (int)intf_num)
 				break;
 			bss_tbl[i].bss_type = MLAN_BSS_TYPE_UAP;
 			bss_tbl[i].frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
@@ -1184,7 +2008,7 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 #ifdef WIFI_DIRECT_SUPPORT
 	if (drv_mode_local & DRV_MODE_WIFIDIRECT) {
 		for (j = 0; j < max_wfd_bss; j++) {
-			if (i >= intf_num)
+			if (i >= (int)intf_num)
 				break;
 			bss_tbl[i].bss_type = MLAN_BSS_TYPE_WIFIDIRECT;
 			bss_tbl[i].frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
@@ -1200,11 +2024,25 @@ mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local)
 	}
 #endif /* WIFI_DIRECT_SUPPORT */
 
+	if (drv_mode_local & DRV_MODE_DFS) {
+		for (j = 0; j < max_dfs_bss; j++) {
+			if (i >= (int)intf_num)
+				break;
+			bss_tbl[i].bss_type = MLAN_BSS_TYPE_DFS;
+			bss_tbl[i].frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
+			bss_tbl[i].active = MTRUE;
+			bss_tbl[i].bss_priority = 0;
+			bss_tbl[i].bss_num = j;
+			bss_tbl[i].bss_virtual = MFALSE;
+			i++;
+		}
+	}
+
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 	/** append virtual interface at the end of table */
 	for (j = 0; j < max_vir_bss; j++) {
-		if (i >= intf_num)
+		if (i >= (int)intf_num)
 			break;
 		bss_tbl[i].bss_type = MLAN_BSS_TYPE_WIFIDIRECT;
 		bss_tbl[i].frame_type = MLAN_DATA_FRAME_TYPE_ETH_II;
@@ -1308,7 +2146,7 @@ mlan_status woal_init_sw(moal_handle *handle)
 
 	handle->is_suspended = MFALSE;
 	handle->hs_activated = MFALSE;
-	handle->hs_auto_arp = MTRUE;
+	handle->hs_auto_arp = (t_u8)handle->params.hs_auto_arp;
 	handle->suspend_fail = MFALSE;
 	handle->hs_skip_count = 0;
 	handle->hs_force_count = 0;
@@ -1339,6 +2177,9 @@ mlan_status woal_init_sw(moal_handle *handle)
 #endif
 #endif
 
+#ifdef STA_CFG80211
+	handle->scan_timeout = SCAN_TIMEOUT_25S;
+#endif
 	if (IS_USB(handle->card_type))
 		init_waitqueue_head(&handle->suspend_wait_q);
 	init_waitqueue_head(&handle->hs_activate_wait_q);
@@ -1364,6 +2205,9 @@ mlan_status woal_init_sw(moal_handle *handle)
 	handle->cac_bss_index = 0xff;
 #endif
 #endif
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+	handle->mon_if = NULL;
+#endif
 
 #ifdef REASSOCIATION
 	MOAL_INIT_SEMAPHORE(&handle->reassoc_sem);
@@ -1376,6 +2220,11 @@ mlan_status woal_init_sw(moal_handle *handle)
 	handle->is_reassoc_timer_set = MFALSE;
 #endif /* REASSOCIATION */
 
+	/* Initialize the timer for the FW dump*/
+	woal_initialize_timer(&handle->fw_dump_timer, woal_fw_dump_timer_func,
+			      handle);
+	handle->is_fw_dump_timer_set = MFALSE;
+
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 	/* Initialize the timer for GO timeout */
@@ -1397,6 +2246,17 @@ mlan_status woal_init_sw(moal_handle *handle)
 #endif
 #endif
 
+	handle->rtt_capa.rtt_one_sided_supported = MTRUE;
+	handle->rtt_capa.rtt_ftm_supported = MTRUE;
+	handle->rtt_capa.lci_support = MTRUE;
+	handle->rtt_capa.lcr_support = MTRUE;
+	handle->rtt_capa.preamble_support =
+		PREAMBLE_LEGACY | PREAMBLE_HT | PREAMBLE_VHT;
+	handle->rtt_capa.bw_support =
+		BW_20_SUPPORT | BW_40_SUPPORT | BW_80_SUPPORT;
+	handle->rtt_capa.responder_supported = MTRUE;
+	handle->rtt_capa.mc_version = 60;
+
 	/* Register to MLAN */
 	memset(&device, 0, sizeof(mlan_device));
 	device.pmoal_handle = handle;
@@ -1409,6 +2269,7 @@ mlan_status woal_init_sw(moal_handle *handle)
 		device.rx_cmd_ep = cardp->rx_cmd_ep;
 		device.tx_data_ep = cardp->tx_data_ep;
 		device.rx_data_ep = cardp->rx_data_ep;
+		device.tx_data2_ep = cardp->tx_data2_ep;
 	}
 #endif
 #ifdef MFG_CMD_SUPPORT
@@ -1420,6 +2281,7 @@ mlan_status woal_init_sw(moal_handle *handle)
 	device.fixed_beacon_buffer =
 		(t_u32)moal_extflg_isset(handle, EXT_FIX_BCN_BUF);
 	device.auto_ds = (t_u32)handle->params.auto_ds;
+	device.ext_scan = (t_u8)handle->params.ext_scan;
 	device.ps_mode = (t_u32)handle->params.ps_mode;
 	device.passive_to_active_scan = (t_u8)handle->params.p2a_scan;
 	device.max_tx_buf = (t_u32)handle->params.max_tx_buf;
@@ -1427,6 +2289,11 @@ mlan_status woal_init_sw(moal_handle *handle)
 	device.cfg_11d = (t_u32)handle->params.cfg_11d;
 #endif
 	device.indrstcfg = (t_u32)handle->params.indrstcfg;
+	device.drcs_chantime_mode = (t_u32)handle->params.drcs_chantime_mode;
+#ifdef PCIE
+	if (IS_PCIE(handle->card_type))
+		device.ring_size = handle->params.ring_size;
+#endif
 #ifdef SDIO
 	if (IS_SD(handle->card_type)) {
 		device.sdio_rx_aggr_enable =
@@ -1481,11 +2348,16 @@ mlan_status woal_init_sw(moal_handle *handle)
 #ifdef UAP_SUPPORT
 	device.uap_max_sta = handle->params.uap_max_sta;
 #endif
+	device.mcs32 = handle->params.mcs32;
 	device.hs_wake_interval = handle->params.hs_wake_interval;
 	device.indication_gpio = handle->params.indication_gpio;
 	device.hs_mimo_switch = moal_extflg_isset(handle, EXT_HS_MIMO_SWITCH);
 
 	device.dfs53cfg = handle->params.dfs53cfg;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	device.dfs_offload = moal_extflg_isset(handle, EXT_DFS_OFFLOAD);
+#endif
+	device.second_mac = handle->second_mac;
 
 	for (i = 0; i < handle->drv_mode.intf_num; i++) {
 		device.bss_attr[i].bss_type =
@@ -1502,11 +2374,8 @@ mlan_status woal_init_sw(moal_handle *handle)
 	}
 	moal_memcpy_ext(handle, &device.callbacks, &woal_callbacks,
 			sizeof(mlan_callbacks), sizeof(mlan_callbacks));
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	device.fw_region = fw_region;
-#endif
-#endif
+	if (!handle->params.amsdu_deaggr)
+		device.callbacks.moal_recv_amsdu_packet = NULL;
 	device.drv_mode = handle->params.drv_mode;
 	if (MLAN_STATUS_SUCCESS == mlan_register(&device, &pmlan))
 		handle->pmlan_adapter = pmlan;
@@ -1538,9 +2407,7 @@ void woal_free_moal_handle(moal_handle *handle)
 	/* Unregister wiphy device and free */
 	if (handle->wiphy) {
 		wiphy_unregister(handle->wiphy);
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
-		woal_cfg80211_free_iftype_data(handle->wiphy);
-#endif
+		woal_cfg80211_free_bands(handle->wiphy);
 		wiphy_free(handle->wiphy);
 		handle->wiphy = NULL;
 	}
@@ -1615,7 +2482,7 @@ static t_size parse_cfg_get_line(t_u8 *data, t_size size, t_u8 *line_pos)
 
 	ENTER();
 
-	if (pos >= size) { /* reach the end */
+	if (pos >= (t_s32)size) { /* reach the end */
 		pos = 0; /* Reset position for rfkill */
 		LEAVE();
 		return -1;
@@ -1624,7 +2491,7 @@ static t_size parse_cfg_get_line(t_u8 *data, t_size size, t_u8 *line_pos)
 	src = data + pos;
 	dest = line_pos;
 
-	while ((dest - line_pos < MAX_LINE_LEN - 1) && pos < size &&
+	while ((dest - line_pos < MAX_LINE_LEN - 1) && pos < (t_s32)size &&
 	       *src != '\x0A' && *src != '\0') {
 		if (*src != ' ' && *src != '\t') /* parse space */
 			*dest++ = *src++;
@@ -1766,6 +2633,8 @@ static t_u32 woal_set_sdio_slew_rate(moal_handle *handle)
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	moal_private *priv = NULL;
 	t_u32 new_value = 0;
+	t_u32 reg_type = MLAN_REG_MAC;
+	int status;
 
 	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
 	if (!priv)
@@ -1774,10 +2643,13 @@ static t_u32 woal_set_sdio_slew_rate(moal_handle *handle)
 	if ((handle->card_info->slew_rate_reg != 0) &&
 	    (handle->params.slew_rate > 3 || handle->params.slew_rate < 0))
 		return MLAN_STATUS_FAILURE;
+	if (IS_SD9098(handle->card_type) || IS_SD9097(handle->card_type) ||
+	    IS_SDIW62X(handle->card_type) || IS_SD9177(handle->card_type))
+		reg_type = MLAN_REG_CIU;
 
-	ret = woal_getset_regrdwr(priv, MLAN_ACT_GET, MLAN_REG_MAC,
-				  handle->card_info->slew_rate_reg, &value);
-	if (ret < 0) {
+	status = woal_getset_regrdwr(priv, MLAN_ACT_GET, reg_type,
+				     handle->card_info->slew_rate_reg, &value);
+	if (status < 0) {
 		PRINTM(MERROR, "woal_getset_regrdwr get REG_MAC failed\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
@@ -1790,10 +2662,10 @@ static t_u32 woal_set_sdio_slew_rate(moal_handle *handle)
 		PRINTM(MMSG, "Set REG 0x%8x: 0x%x slew_rate=%d\n",
 		       handle->card_info->slew_rate_reg, new_value,
 		       handle->params.slew_rate);
-		ret = woal_getset_regrdwr(priv, MLAN_ACT_SET, MLAN_REG_MAC,
-					  handle->card_info->slew_rate_reg,
-					  &new_value);
-		if (ret < 0) {
+		status = woal_getset_regrdwr(priv, MLAN_ACT_SET, reg_type,
+					     handle->card_info->slew_rate_reg,
+					     &new_value);
+		if (status < 0) {
 			PRINTM(MERROR,
 			       "woal_getset_regrdwr get REG_MAC failed\n");
 			ret = MLAN_STATUS_FAILURE;
@@ -1882,7 +2754,7 @@ static t_u32 woal_process_init_cfg(moal_handle *handle, t_u8 *data, t_size size)
 
 	ENTER();
 
-	while ((line_len = parse_cfg_get_line(data, size, s)) != -1) {
+	while ((int)(line_len = parse_cfg_get_line(data, size, s)) != -1) {
 		pos = s;
 		while (*pos == ' ' || *pos == '\t')
 			pos++;
@@ -1953,6 +2825,12 @@ static t_u32 woal_process_init_cfg(moal_handle *handle, t_u8 *data, t_size size)
 							       "Set MAC address failed\n");
 							goto done;
 						}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+						eth_hw_addr_set(
+							handle->priv[i]->netdev,
+							handle->priv[i]
+								->current_addr);
+#else
 						moal_memcpy_ext(
 							handle,
 							handle->priv[i]
@@ -1961,6 +2839,7 @@ static t_u32 woal_process_init_cfg(moal_handle *handle, t_u8 *data, t_size size)
 							handle->priv[i]
 								->current_addr,
 							ETH_ALEN, ETH_ALEN);
+#endif
 						index++; /* Mark found one
 							    interface matching
 							  */
@@ -2012,8 +2891,8 @@ static t_u32 woal_process_init_cfg(moal_handle *handle, t_u8 *data, t_size size)
 				goto done;
 			}
 			/* Copy value */
-			strncpy(value, intf_s,
-				MIN((MAX_PARAM_LEN - 1), strlen(intf_s)));
+			memcpy(value, intf_s,
+			       MIN((MAX_PARAM_LEN - 1), strlen(intf_s)));
 
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_process_regrdwr(handle, type, offset, value)) {
@@ -2043,8 +2922,8 @@ static t_u32 woal_process_init_cfg(moal_handle *handle, t_u8 *data, t_size size)
  *    @param wait_option  wait option
  *    @return             MLAN_STATUS_SUCCESS--success, otherwise--fail
  */
-static t_u32 woal_process_hostcmd_cfg(moal_handle *handle, t_u8 *data,
-				      t_size size, t_u8 wait_option)
+static mlan_status woal_process_hostcmd_cfg(moal_handle *handle, t_u8 *data,
+					    t_size size, t_u8 wait_option)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u8 *pos = data;
@@ -2063,10 +2942,11 @@ static t_u32 woal_process_hostcmd_cfg(moal_handle *handle, t_u8 *data,
 	buf = kzalloc(CMD_BUF_LEN, flag);
 	if (!buf) {
 		PRINTM(MERROR, "Could not allocate buffer space!\n");
+		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 	ptr = buf;
-	strcpy(ptr, CMD_STR);
+	strncpy(ptr, CMD_STR, CMD_BUF_LEN);
 	ptr = buf + strlen(CMD_STR) + sizeof(t_u32);
 	while ((pos - data) < size) {
 		while (*pos == ' ' || *pos == '\t')
@@ -2147,8 +3027,9 @@ static t_u32 woal_process_hostcmd_cfg(moal_handle *handle, t_u8 *data,
  *
  * @return          N/A
  */
-void woal_request_init_user_conf_callback(const struct firmware *firmware,
-					  void *context)
+static void
+woal_request_init_user_conf_callback(const struct firmware *firmware,
+				     void *context)
 {
 	moal_handle *handle;
 
@@ -2254,6 +3135,12 @@ mlan_status woal_vdll_req_fw(moal_handle *handle)
 	if (vdll_fw) {
 		PRINTM(MMSG, "VDLL: Request firmware: %s\n", vdll_fw);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT, vdll_fw,
+				    handle->hotplug_device, GFP_KERNEL, handle,
+				    woal_request_vdll_fw_callback)) < 0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG, vdll_fw,
@@ -2271,6 +3158,7 @@ mlan_status woal_vdll_req_fw(moal_handle *handle)
 				    handle->hotplug_device, handle,
 				    woal_request_vdll_fw_callback)) < 0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "VDLL: request_firmware_nowait() failed\n");
@@ -2386,7 +3274,14 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 	ENTER();
 
 	if (type == INIT_CFG_DATA) {
+		PRINTM(MMSG, "Request firmware: %s\n", init_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT, init_cfg,
+				    handle->hotplug_device, GFP_KERNEL, handle,
+				    woal_request_init_cfg_data_callback)) < 0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG, init_cfg,
@@ -2404,6 +3299,7 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 				    handle->hotplug_device, handle,
 				    woal_request_init_cfg_data_callback)) < 0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "Init config file request_firmware_nowait() failed\n");
@@ -2428,9 +3324,18 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
+		PRINTM(MMSG, "Request firmware: %s\n", country_txpwrlimit);
 		/* 'country_txpwrlimit' holds the value of Configured Tx Power
 		 * Limit */
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT,
+				    country_txpwrlimit, handle->hotplug_device,
+				    GFP_KERNEL, handle,
+				    woal_request_init_user_conf_callback)) <
+			    0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2453,6 +3358,7 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 				    woal_request_init_user_conf_callback)) <
 			    0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "country txpwrlimit config file request_firmware_nowait() failed\n");
@@ -2463,9 +3369,16 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 				handle->init_user_conf_wait_q,
 				handle->init_user_conf_wait_flag);
 		} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			int status =
+				request_firmware_direct(&handle->user_data,
+							country_txpwrlimit,
+							handle->hotplug_device);
+#else
 			int status = request_firmware(&handle->user_data,
 						      country_txpwrlimit,
 						      handle->hotplug_device);
+#endif
 			/* File does not exist, skip download */
 			if (status == -ENOENT) {
 				ret = MLAN_STATUS_FILE_ERR;
@@ -2479,7 +3392,16 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 			}
 		}
 	} else if (type == INIT_HOSTCMD_CFG_DATA) {
+		PRINTM(MMSG, "Request firmware: %s\n", init_hostcmd_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT,
+				    init_hostcmd_cfg, handle->hotplug_device,
+				    GFP_KERNEL, handle,
+				    woal_request_init_user_conf_callback)) <
+			    0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2502,6 +3424,7 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 				    woal_request_init_user_conf_callback)) <
 			    0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "Init hostcmd config file request_firmware_nowait() failed\n");
@@ -2522,7 +3445,16 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 		}
 	}
 	if (type == BAND_STEER_CFG_DATA) {
+		PRINTM(MMSG, "Request firmware: %s\n", band_steer_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT,
+				    band_steer_cfg, handle->hotplug_device,
+				    GFP_KERNEL, handle,
+				    woal_request_init_user_conf_callback)) <
+			    0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2545,6 +3477,7 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 				    woal_request_init_user_conf_callback)) <
 			    0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "band_steer_cfg request_firmware_nowait() failed\n");
@@ -2566,7 +3499,7 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 	}
 	if (handle->user_data) {
 		cfg_data = (t_u8 *)(handle->user_data)->data;
-		len = (handle->user_data)->size;
+		len = (t_size)((handle->user_data)->size);
 		if (type == INIT_HOSTCMD_CFG_DATA ||
 		    type == BAND_STEER_CFG_DATA ||
 		    type == COUNTRY_POWER_TABLE) {
@@ -2593,6 +3526,52 @@ static t_u32 woal_set_user_init_data(moal_handle *handle, int type,
 	return ret;
 }
 
+static int woal_netdevice_event(struct notifier_block *nb, unsigned long event,
+				void *ptr);
+
+#ifdef UAP_SUPPORT
+/**
+ *  @brief Configure WACP Mode
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wait_option  Wait option
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ *                          otherwise fail
+ */
+mlan_status woal_set_wacp_mode(moal_private *priv, t_u8 wait_option)
+{
+	// moal_private      *priv = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *pcfg_misc = NULL;
+	mlan_status status;
+
+	ENTER();
+
+	/* Allocate an IOCTL request buffer */
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	pcfg_misc = (mlan_ds_misc_cfg *)req->pbuf;
+	pcfg_misc->sub_command = MLAN_OID_MISC_WACP_MODE;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	pcfg_misc->param.wacp_mode = priv->phandle->params.wacp_mode;
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, wait_option);
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return status;
+}
+#endif
+
 /**
  *  @brief Configure aggrctrl
  *
@@ -2640,6 +3619,87 @@ mlan_status woal_init_aggr_ctrl(moal_handle *handle, t_u8 wait_option)
 	return status;
 }
 
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+static ssize_t woal_set_rps_map(struct netdev_rx_queue *queue, const char *buf,
+				size_t len)
+{
+	struct rps_map *old_map, *map;
+	cpumask_var_t mask;
+	int err, cpu, i;
+	static DEFINE_MUTEX(local_rps_map_mutex);
+
+	if (!queue || !queue->dev) {
+		PRINTM(MERROR, "%s: queue=%px or queue->dev is NULL\n",
+		       __func__, queue);
+		return -EINVAL;
+	}
+
+	if (!alloc_cpumask_var(&mask, GFP_KERNEL)) {
+		PRINTM(MERROR, "%s: alloc_cpumask_var fail.\n", __func__);
+		return -ENOMEM;
+	}
+
+	err = bitmap_parse(buf, len, cpumask_bits(mask), nr_cpumask_bits);
+	if (err) {
+		PRINTM(MERROR, "%s: bitmap_parse fail err=%d.\n", __func__,
+		       err);
+		free_cpumask_var(mask);
+		return -EINVAL;
+	}
+
+	map = kzalloc(max_t(unsigned int, RPS_MAP_SIZE(cpumask_weight(mask)),
+			    L1_CACHE_BYTES),
+		      GFP_KERNEL);
+	if (!map) {
+		PRINTM(MERROR, "%s: kzalloc map fail.\n", __func__);
+		free_cpumask_var(mask);
+		return -ENOMEM;
+	}
+
+	i = 0;
+	for_each_cpu_and (cpu, mask, cpu_online_mask) {
+		PRINTM(MCMND, "map->cpus[%d]=%d\n", i, cpu);
+		map->cpus[i++] = cpu;
+	}
+
+	if (i) {
+		map->len = i;
+		PRINTM(MCMND, "map->len=%d\n", map->len);
+	} else {
+		kfree(map);
+		map = NULL;
+	}
+
+	mutex_lock(&local_rps_map_mutex);
+	old_map = rcu_dereference_protected(
+		queue->rps_map, mutex_is_locked(&local_rps_map_mutex));
+	rcu_assign_pointer(queue->rps_map, map);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 2, 0)
+	if (map)
+		static_branch_inc(&rps_needed);
+	if (old_map)
+		static_branch_dec(&rps_needed);
+#else
+	if (map)
+		static_key_slow_inc(&rps_needed);
+	if (old_map)
+		static_key_slow_dec(&rps_needed);
+
+#endif
+	mutex_unlock(&local_rps_map_mutex);
+
+	if (old_map)
+		kfree_rcu(old_map, rcu);
+
+	PRINTM(MMSG, "%s on %s: buf=%s(%u) (%d i=%d)\n", __func__,
+	       queue->dev->name, buf, (t_u32)len, nr_cpumask_bits, i);
+	free_cpumask_var(mask);
+	return len;
+}
+#endif
+#endif
+
 /**
  * @brief Add interfaces DPC
  *
@@ -2647,11 +3707,19 @@ mlan_status woal_init_aggr_ctrl(moal_handle *handle, t_u8 wait_option)
  *
  * @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_add_card_dpc(moal_handle *handle)
+static mlan_status woal_add_card_dpc(moal_handle *handle)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	int i;
 	char str_buf[MLAN_MAX_VER_STR_LEN];
+
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	moal_private *priv_rps = NULL;
+	t_u8 rps_buf[2];
+#endif
+#endif
+
 	ENTER();
 
 #if defined(USB)
@@ -2680,6 +3748,12 @@ mlan_status woal_add_card_dpc(moal_handle *handle)
 	woal_get_version(handle, str_buf, sizeof(str_buf) - 1);
 	PRINTM(MMSG, "wlan: version = %s\n", str_buf);
 
+	handle->woal_notifier.notifier_call = woal_netdevice_event;
+	if (register_inetaddr_notifier(&handle->woal_notifier)) {
+		PRINTM(MFATAL,
+		       "Error registering register_inetaddr_notifier\n");
+		goto err;
+	}
 #ifdef MFG_CMD_SUPPORT
 	if (handle->params.mfg_mode == MLAN_INIT_PARA_ENABLED)
 		goto done;
@@ -2721,6 +3795,9 @@ mlan_status woal_add_card_dpc(moal_handle *handle)
 		PRINTM(MERROR, "Unable to set Low Power Mode\n");
 	}
 
+	/* Add channel tracking check */
+	woal_set_chan_track_mode(handle, MOAL_IOCTL_WAIT);
+
 #if defined(SDIO)
 	if (IS_SD(handle->card_type))
 		woal_set_sdio_slew_rate(handle);
@@ -2749,6 +3826,39 @@ mlan_status woal_add_card_dpc(moal_handle *handle)
 		woal_set_uap_operation_ctrl(handle);
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	handle->woal_inet6_notifier.notifier_call = woal_inet6_netdeive_event;
+	if (register_inet6addr_notifier(&handle->woal_inet6_notifier)) {
+		PRINTM(MFATAL,
+		       "Error registering register_inet6addr_notifier\n");
+		goto err;
+	}
+#endif
+#endif
+
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (handle->params.rps) {
+		priv_rps = woal_get_priv_bss_type(handle, MLAN_BSS_TYPE_STA);
+		snprintf(rps_buf, sizeof(rps_buf), "%x", handle->params.rps);
+		if (priv_rps) {
+			PRINTM(MCMND,
+			       "num_rx_queues=%u real_num_rx_queues=%u\n",
+			       priv_rps->netdev->num_rx_queues,
+			       priv_rps->netdev->real_num_rx_queues);
+			for (i = 0;
+			     i < (int)MIN(priv_rps->netdev->num_rx_queues,
+					  priv_rps->netdev->real_num_rx_queues);
+			     i++) {
+				woal_set_rps_map(&(priv_rps->netdev->_rx[i]),
+						 rps_buf, strlen(rps_buf));
+			}
+		}
+	}
+#endif
+#endif
+
 #ifdef MFG_CMD_SUPPORT
 done:
 #endif
@@ -2759,6 +3869,12 @@ mlan_status woal_add_card_dpc(moal_handle *handle)
 	}
 	if (ret != MLAN_STATUS_SUCCESS) {
 		PRINTM(MERROR, "Failed to add interface\n");
+		unregister_inetaddr_notifier(&handle->woal_notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+		unregister_inet6addr_notifier(&handle->woal_inet6_notifier);
+#endif
+#endif
 
 		for (i = 0; i < MIN(MLAN_MAX_BSS_NUM, handle->priv_num); i++)
 			woal_remove_interface(handle, i);
@@ -2781,15 +3897,22 @@ mlan_status woal_add_card_dpc(moal_handle *handle)
 static mlan_status woal_req_dpd_data(moal_handle *handle,
 				     mlan_init_param *param)
 {
-	int ret = MLAN_STATUS_SUCCESS;
+	mlan_status ret = MLAN_STATUS_SUCCESS;
 	t_u8 req_fw_nowait = moal_extflg_isset(handle, EXT_REQ_FW_NOWAIT);
 	char *dpd_data_cfg = handle->params.dpd_data_cfg;
-	mlan_status status = MLAN_STATUS_SUCCESS;
+	int status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
 	if (dpd_data_cfg && strncmp(dpd_data_cfg, "none", strlen("none"))) {
+		PRINTM(MMSG, "Request firmware: %s\n", dpd_data_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT, dpd_data_cfg,
+				    handle->hotplug_device, GFP_KERNEL, handle,
+				    woal_request_init_dpd_conf_callback)) < 0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2809,6 +3932,7 @@ static mlan_status woal_req_dpd_data(moal_handle *handle,
 				    handle->hotplug_device, handle,
 				    woal_request_init_dpd_conf_callback)) < 0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "DPD data request_firmware_nowait() failed\n");
@@ -2860,7 +3984,17 @@ static mlan_status woal_req_txpwr_data(moal_handle *handle,
 	ENTER();
 
 	if (txpwrlimit_cfg && strncmp(txpwrlimit_cfg, "none", strlen("none"))) {
+		PRINTM(MMSG, "Download txpwrlimit_cfg=%s\n",
+		       handle->params.txpwrlimit_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT,
+				    txpwrlimit_cfg, handle->hotplug_device,
+				    GFP_KERNEL, handle,
+				    woal_request_init_txpwr_conf_callback)) <
+			    0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2883,6 +4017,7 @@ static mlan_status woal_req_txpwr_data(moal_handle *handle,
 				    woal_request_init_txpwr_conf_callback)) <
 			    0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "Region txpwrlimit cfg data "
@@ -2933,7 +4068,15 @@ static mlan_status woal_req_cal_data(moal_handle *handle,
 	ENTER();
 	/** Cal data request */
 	if (cal_data_cfg && strncmp(cal_data_cfg, "none", strlen("none"))) {
+		PRINTM(MMSG, "Request firmware: %s\n", cal_data_cfg);
 		if (req_fw_nowait) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+			if ((request_firmware_nowait(
+				    THIS_MODULE, FW_ACTION_UEVENT, cal_data_cfg,
+				    handle->hotplug_device, GFP_KERNEL, handle,
+				    woal_request_init_user_conf_callback)) <
+			    0) {
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 			if ((request_firmware_nowait(
 				    THIS_MODULE, FW_ACTION_HOTPLUG,
@@ -2956,6 +4099,7 @@ static mlan_status woal_req_cal_data(moal_handle *handle,
 				    woal_request_init_user_conf_callback)) <
 			    0) {
 #endif
+#endif
 #endif
 				PRINTM(MERROR,
 				       "Cal data request_firmware_nowait() failed\n");
@@ -3061,10 +4205,10 @@ static mlan_status woal_init_fw_dpc(moal_handle *handle)
 			fw.fw_reload = handle->params.fw_reload;
 		else
 			fw.fw_reload = 0;
-		wifi_status = 0;
+		wifi_status = WIFI_STATUS_FW_DNLD;
 		ret = mlan_dnld_fw(handle->pmlan_adapter, &fw);
 		if (ret == MLAN_STATUS_FAILURE) {
-			wifi_status = 1;
+			wifi_status = WIFI_STATUS_DNLD_FW_FAIL;
 			PRINTM(MERROR,
 			       "WLAN: Fail download FW with nowwait: %u\n",
 			       moal_extflg_isset(handle, EXT_REQ_FW_NOWAIT));
@@ -3072,20 +4216,22 @@ static mlan_status woal_init_fw_dpc(moal_handle *handle)
 				handle->ops.reg_dbg(handle);
 			goto done;
 		}
-		wifi_status = 0;
+		wifi_status = WIFI_STATUS_FW_DNLD_COMPLETE;
 
 #if defined(USB)
 		if (handle->boot_state == USB_FW_DNLD) {
 			if (!IS_USB8997(handle->card_type) &&
 			    !IS_USB9098(handle->card_type) &&
 			    !IS_USB9097(handle->card_type) &&
+			    !IS_USBIW62X(handle->card_type) &&
 			    !IS_USB8978(handle->card_type))
 				ret = woal_reset_usb_dev(handle);
 			goto done;
 		}
 #endif /* USB_NEW_FW_DNLD */
 		PRINTM(MMSG, "WLAN FW is active\n");
-		handle->driver_status = MFALSE;
+		if (!handle->fw_reload)
+			handle->driver_status = MFALSE;
 	}
 
 	moal_get_boot_ktime(handle, &handle->on_time);
@@ -3118,28 +4264,40 @@ static mlan_status woal_init_fw_dpc(moal_handle *handle)
 			goto done;
 	}
 #endif /* USB */
-	if (handle->fw_reload)
-		goto done;
-	handle->init_wait_q_woken = MFALSE;
-
 	ret = mlan_set_init_param(handle->pmlan_adapter, &param);
+	if (handle->fw_reload) {
+		LEAVE();
+		return ret;
+	}
+	handle->init_wait_q_woken = MFALSE;
+	wifi_status = WIFI_STATUS_INIT_FW;
 	ret = mlan_init_fw(handle->pmlan_adapter);
 	if (ret == MLAN_STATUS_FAILURE) {
-		wifi_status = 2;
+		wifi_status = WIFI_STATUS_INIT_FW_FAIL;
 		goto done;
 	} else if (ret == MLAN_STATUS_SUCCESS) {
+		wifi_status = WIFI_STATUS_OK;
 		handle->hardware_status = HardwareStatusReady;
 		goto done;
 	}
 	/* Wait for mlan_init to complete */
 	wait_event_timeout(handle->init_wait_q, handle->init_wait_q_woken,
-			   5 * HZ);
+			   10 * HZ);
 	if (handle->hardware_status != HardwareStatusReady) {
-		woal_moal_debug_info(woal_get_priv(handle, MLAN_BSS_ROLE_ANY),
-				     handle, MTRUE);
+		wifi_status = WIFI_STATUS_INIT_FW_FAIL;
+		if (handle->ops.reg_dbg)
+			handle->ops.reg_dbg(handle);
+#ifdef DEBUG_LEVEL1
+		if (drvdbg & MFW_D) {
+			drvdbg &= ~MFW_D;
+			if (handle->ops.dump_fw_info)
+				handle->ops.dump_fw_info(handle);
+		}
+#endif
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
+	wifi_status = WIFI_STATUS_OK;
 	ret = MLAN_STATUS_SUCCESS;
 done:
 	if (handle->dpd_data) {
@@ -3187,7 +4345,10 @@ static mlan_status woal_request_fw_dpc(moal_handle *handle,
 		       "request_firmware_nowait failed for %s. Retrying..\n",
 		       handle->drv_mode.fw_name);
 		woal_sched_timeout(MOAL_TIMER_1S);
-		woal_request_fw(handle);
+		ret = woal_request_fw(handle);
+		if (ret != MLAN_STATUS_SUCCESS)
+			PRINTM(MERROR, "%s: woal_request_fw failed!\n",
+			       __func__);
 		LEAVE();
 		return ret;
 	}
@@ -3225,7 +4386,9 @@ static void woal_request_fw_callback(const struct firmware *firmware,
 
 	handle = (moal_handle *)context;
 	handle->firmware = firmware;
-	woal_request_fw_dpc((moal_handle *)context, firmware);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_request_fw_dpc((moal_handle *)context, firmware))
+		PRINTM(MERROR, "woal_request_fw_dpc failed\n");
 	if (firmware) {
 		release_firmware(firmware);
 		handle->firmware = NULL;
@@ -3252,6 +4415,13 @@ mlan_status woal_request_fw(moal_handle *handle)
 	PRINTM(MMSG, "Request firmware: %s\n", handle->drv_mode.fw_name);
 
 	if (req_fw_nowait && !handle->fw_reload) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
+		err = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,
+					      handle->drv_mode.fw_name,
+					      handle->hotplug_device,
+					      GFP_KERNEL, handle,
+					      woal_request_fw_callback);
+#else
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 32)
 		err = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
 					      handle->drv_mode.fw_name,
@@ -3270,6 +4440,7 @@ mlan_status woal_request_fw(moal_handle *handle)
 					      handle->hotplug_device, handle,
 					      woal_request_fw_callback);
 #endif
+#endif
 #endif
 		if (err < 0) {
 			PRINTM(MFATAL,
@@ -3362,79 +4533,69 @@ void woal_fill_mlan_buffer(moal_private *priv, mlan_buffer *pmbuf,
 {
 	wifi_timeval tstamp;
 	struct ethhdr *eth;
-	t_u8 tid = 0;
 	dot11_txcontrol *txcontrol;
 	t_u8 tx_ctrl_flag = MFALSE;
 	int i = 0;
 	ENTER();
-	/*
-	 * skb->priority values from 256->263 are magic values to
-	 * directly indicate a specific 802.1d priority.  This is used
-	 * to allow 802.1d priority to be passed directly in from VLAN
-	 * tags, etc.
-	 */
-	if (IS_SKB_MAGIC_VLAN(skb)) {
-		tid = GET_VLAN_PRIO(skb);
-	} else {
-		eth = (struct ethhdr *)skb->data;
-
-		switch (eth->h_proto) {
-		case __constant_htons(ETH_P_IP):
-			tid = priv->dscp_map[SKB_TOS(skb) >> DSCP_OFFSET];
-			if (tid == 0xFF)
-				tid = (IPTOS_PREC(SKB_TOS(skb)) >>
-				       IPTOS_OFFSET);
-			PRINTM(MDAT_D,
-			       "packet type ETH_P_IP: dscp[%x], map[%x], tid=%d\n",
-			       SKB_TOS(skb) >> DSCP_OFFSET,
-			       priv->dscp_map[SKB_TOS(skb) >> DSCP_OFFSET],
-			       tid);
-			break;
-		case __constant_htons(ETH_P_IPV6):
-			tid = SKB_TIDV6(skb);
-			PRINTM(MDAT_D,
-			       "packet type ETH_P_IPV6: %04x, tid=%#x prio=%#x\n",
-			       eth->h_proto, tid, skb->priority);
-			break;
-		case __constant_htons(ETH_P_ARP):
-			tid = 0;
-			PRINTM(MDATA, "ARP packet %04x\n", eth->h_proto);
-			break;
-		default:
-			tid = 0;
-			if (priv->tx_protocols.protocol_num) {
-				for (i = 0; i < priv->tx_protocols.protocol_num;
-				     i++) {
-					if (eth->h_proto ==
-					    __constant_htons(
-						    priv->tx_protocols
-							    .protocols[i]))
-						tx_ctrl_flag = MTRUE;
-				}
+
+	eth = (struct ethhdr *)skb->data;
+
+	switch (eth->h_proto) {
+	case __constant_htons(ETH_P_IP):
+		PRINTM(MINFO, "packet type ETH_P_IP: %04x, prio=%#x\n",
+		       eth->h_proto, skb->priority);
+		break;
+	case __constant_htons(ETH_P_IPV6):
+		PRINTM(MINFO, "packet type ETH_P_IPV6: %04x, prio=%#x\n",
+		       eth->h_proto, skb->priority);
+		break;
+	case __constant_htons(ETH_P_ARP):
+		skb->priority = 0;
+		PRINTM(MINFO, "ARP packet %04x prio=%#x\n", eth->h_proto,
+		       skb->priority);
+		break;
+	default:
+		skb->priority = 0;
+		if (priv->tx_protocols.protocol_num) {
+			for (i = 0; i < priv->tx_protocols.protocol_num; i++) {
+				if (eth->h_proto ==
+				    __constant_htons(
+					    priv->tx_protocols.protocols[i]))
+					tx_ctrl_flag = MTRUE;
 			}
-			if (tx_ctrl_flag) {
-				txcontrol = (dot11_txcontrol
-						     *)(skb->data +
+		}
+		if (tx_ctrl_flag) {
+			txcontrol = (dot11_txcontrol *)(skb->data +
 							sizeof(struct ethhdr));
-				pmbuf->u.tx_info.data_rate =
-					txcontrol->datarate;
-				pmbuf->u.tx_info.channel = txcontrol->channel;
-				pmbuf->u.tx_info.bw = txcontrol->bw;
-				pmbuf->u.tx_info.tx_power.val =
-					txcontrol->power;
-				pmbuf->u.tx_info.retry_limit =
-					txcontrol->retry_limit;
-				tid = txcontrol->priority;
-				memmove(skb->data + sizeof(dot11_txcontrol),
-					skb->data, sizeof(struct ethhdr));
-				skb_pull(skb, sizeof(dot11_txcontrol));
-				pmbuf->flags |= MLAN_BUF_FLAG_TX_CTRL;
-			}
-			break;
+			pmbuf->u.tx_info.data_rate = txcontrol->datarate;
+			pmbuf->u.tx_info.channel = txcontrol->channel;
+			pmbuf->u.tx_info.bw = txcontrol->bw;
+			pmbuf->u.tx_info.tx_power.val = txcontrol->power;
+			pmbuf->u.tx_info.retry_limit = txcontrol->retry_limit;
+			skb->priority = txcontrol->priority;
+			memmove(skb->data + sizeof(dot11_txcontrol), skb->data,
+				sizeof(struct ethhdr));
+			skb_pull(skb, sizeof(dot11_txcontrol));
+			pmbuf->flags |= MLAN_BUF_FLAG_TX_CTRL;
 		}
+		break;
 	}
+	PRINTM(MDAT_D, "packet %04x prio=%#x\n", eth->h_proto, skb->priority);
 
-	skb->priority = tid;
+	if (priv->enable_mc_aggr && priv->num_mcast_addr) {
+		if (woal_find_mcast_node_tx(priv, skb)) {
+			mc_txcontrol *tx_ctrl =
+				(mc_txcontrol *)(skb->data + skb->len -
+						 sizeof(mc_txcontrol));
+			moal_memcpy_ext(priv->phandle,
+					(t_u8 *)&pmbuf->u.mc_tx_info,
+					(t_u8 *)tx_ctrl, sizeof(mc_txcontrol),
+					sizeof(mc_txcontrol));
+			pmbuf->flags |= MLAN_BUF_FLAG_MC_AGGR_PKT;
+			// use AC_VO
+			skb->priority = 6;
+		}
+	}
 
 	/* Record the current time the packet was queued; used to determine
 	 *   the amount of time the packet was queued in the driver before it
@@ -3443,18 +4604,7 @@ void woal_fill_mlan_buffer(moal_private *priv, mlan_buffer *pmbuf,
 	 *   and MSDU lifetime expiry.
 	 */
 	woal_get_monotonic_time(&tstamp);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
-	skb->tstamp = ktime_get_raw();
-#else
-	skb->tstamp = timeval_to_ktime(tstamp);
-#endif
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 14)
-	skb_set_timestamp(skb, &tstamp);
-#else
-	moal_memcpy_ext(priv->phandle, &skb->stamp, &tstamp, sizeof(skb->stamp),
-			sizeof(skb->stamp));
-#endif
+	skb->tstamp = ktime_get_real();
 
 	pmbuf->pdesc = skb;
 	pmbuf->pbuf = skb->head + sizeof(mlan_buffer);
@@ -3474,96 +4624,404 @@ void woal_fill_mlan_buffer(moal_private *priv, mlan_buffer *pmbuf,
 	return;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
-static struct device_type wlan_type = {
-	.name = "wlan",
-};
-#endif
-
-#ifdef STA_SUPPORT
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-/** Network device handlers */
-const struct net_device_ops woal_netdev_ops = {
-	.ndo_open = woal_open,
-	.ndo_start_xmit = woal_hard_start_xmit,
-	.ndo_stop = woal_close,
-	.ndo_do_ioctl = woal_do_ioctl,
-	.ndo_set_mac_address = woal_set_mac_address,
-	.ndo_tx_timeout = woal_tx_timeout,
-	.ndo_get_stats = woal_get_stats,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
-	.ndo_set_rx_mode = woal_set_multicast_list,
-#else
-	.ndo_set_multicast_list = woal_set_multicast_list,
-#endif
-	.ndo_select_queue = woal_select_queue,
-	.ndo_validate_addr = eth_validate_addr,
-};
-#endif
-
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
 /**
- *  @brief This function initializes the private structure
- *          and dev structure for station mode
+ * @brief This function opens the network device for monitor interface
  *
- *  @param dev      A pointer to net_device structure
- *  @param priv     A pointer to moal_private structure
+ * @param dev             A pointer to net_device structure
  *
- *  @return         MLAN_STATUS_SUCCESS
+ * @return                0 -- success, otherwise fail
  */
-mlan_status woal_init_sta_dev(struct net_device *dev, moal_private *priv)
+static int woal_mon_open(struct net_device *ndev)
 {
 	ENTER();
+	LEAVE();
+	return 0;
+}
 
-	/* Setup the OS Interface to our functions */
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
-	dev->open = woal_open;
-	dev->hard_start_xmit = woal_hard_start_xmit;
-	dev->stop = woal_close;
-	dev->do_ioctl = woal_do_ioctl;
-	dev->set_mac_address = woal_set_mac_address;
-	dev->tx_timeout = woal_tx_timeout;
-	dev->get_stats = woal_get_stats;
-	dev->set_multicast_list = woal_set_multicast_list;
-#else
-	dev->netdev_ops = &woal_netdev_ops;
-#endif
-	dev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-	dev->needed_headroom += MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
-				priv->extra_tx_head_len;
-#else
-	dev->hard_header_len += MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
-				priv->extra_tx_head_len;
-#endif
-#ifdef STA_WEXT
-	if (IS_STA_WEXT(priv->phandle->params.cfg80211_wext)) {
-#if WIRELESS_EXT < 21
-		dev->get_wireless_stats = woal_get_wireless_stats;
-#endif
-		dev->wireless_handlers =
-			(struct iw_handler_def *)&woal_handler_def;
-	}
-#endif
-	dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+/**
+ * @brief This function closes the network device for monitor interface
+ *
+ * @param dev             A pointer to net_device structure
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_mon_close(struct net_device *ndev)
+{
+	ENTER();
+	LEAVE();
+	return 0;
+}
 
-#ifdef STA_CFG80211
-	if (IS_STA_CFG80211(priv->phandle->params.cfg80211_wext))
-		init_waitqueue_head(&priv->ft_wait_q);
-#endif
+/**
+ * @brief This function sets the MAC address to firmware for monitor interface
+ *
+ * @param dev             A pointer to net_device structure
+ * @param addr            MAC address to set
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_mon_set_mac_address(struct net_device *ndev, void *addr)
+{
+	ENTER();
 	LEAVE();
-	return MLAN_STATUS_SUCCESS;
+	return 0;
 }
-#endif /* STA_SUPPORT */
 
-#ifdef UAP_SUPPORT
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+/**
+ * @brief This function sets multicast address to firmware for monitor interface
+ *
+ * @param dev             A pointer to net_device structure
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static void woal_mon_set_multicast_list(struct net_device *ndev)
+{
+	ENTER();
+	LEAVE();
+}
+
+/**
+ * @brief This function handles packet transmission for monitor interface
+ *
+ * @param skb             A pointer to sk_buff structure
+ * @param dev             A pointer to net_device structure
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static netdev_tx_t woal_mon_hard_start_xmit(struct sk_buff *skb,
+					    struct net_device *ndev)
+{
+	int len_rthdr;
+	int qos_len = 0;
+	int dot11_hdr_len = 24;
+	int snap_len = 6;
+	unsigned char *pdata;
+	unsigned short fc;
+	unsigned char src_mac_addr[6];
+	unsigned char dst_mac_addr[6];
+	struct ieee80211_hdr *dot11_hdr;
+	struct ieee80211_radiotap_header *prthdr =
+		(struct ieee80211_radiotap_header *)skb->data;
+	monitor_iface *mon_if = netdev_priv(ndev);
+
+	ENTER();
+
+	if (mon_if == NULL || mon_if->base_ndev == NULL) {
+		goto fail;
+	}
+
+	/* check for not even having the fixed radiotap header part */
+	if (unlikely(skb->len < sizeof(struct ieee80211_radiotap_header))) {
+		PRINTM(MERROR,
+		       "Invalid radiotap hdr length,"
+		       "skb->len: %d\n",
+		       skb->len);
+		goto fail; /* too short to be possibly valid */
+	}
+
+	/* is it a header version we can trust to find length from? */
+	if (unlikely(prthdr->it_version))
+		goto fail; /* only version 0 is supported */
+
+	/* then there must be a radiotap header with a length we can use */
+	len_rthdr = ieee80211_get_radiotap_len(skb->data);
+
+	/* does the skb contain enough to deliver on the alleged length? */
+	if (unlikely((int)skb->len < len_rthdr)) {
+		PRINTM(MERROR,
+		       "Invalid data length,"
+		       "skb->len: %d\n",
+		       skb->len);
+		goto fail; /* skb too short for claimed rt header extent */
+	}
+
+	/* Skip the ratiotap header */
+	skb_pull(skb, len_rthdr);
+
+	dot11_hdr = (struct ieee80211_hdr *)skb->data;
+	fc = le16_to_cpu(dot11_hdr->frame_control);
+	if ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {
+		/* Check if this ia a Wireless Distribution System (WDS) frame
+		 * which has 4 MAC addresses
+		 */
+		if (dot11_hdr->frame_control & (__force __le16)0x0080)
+			qos_len = 2;
+		if ((dot11_hdr->frame_control & (__force __le16)0x0300) ==
+		    (__force __le16)0x0300)
+			dot11_hdr_len += 6;
+
+		moal_memcpy_ext(NULL, dst_mac_addr, dot11_hdr->addr1,
+				sizeof(dst_mac_addr), sizeof(dst_mac_addr));
+		moal_memcpy_ext(NULL, src_mac_addr, dot11_hdr->addr2,
+				sizeof(src_mac_addr), sizeof(src_mac_addr));
+
+		/* Skip the 802.11 header, QoS (if any) and SNAP, but leave
+		 * spaces for for two MAC addresses
+		 */
+		skb_pull(skb, dot11_hdr_len + qos_len + snap_len -
+				      sizeof(src_mac_addr) * 2);
+		pdata = (unsigned char *)skb->data;
+		moal_memcpy_ext(NULL, pdata, dst_mac_addr, sizeof(dst_mac_addr),
+				(t_u32)skb->len);
+		moal_memcpy_ext(NULL, pdata + sizeof(dst_mac_addr),
+				src_mac_addr, sizeof(src_mac_addr),
+				(t_u32)skb->len - sizeof(dst_mac_addr));
+
+		LEAVE();
+		return woal_hard_start_xmit(skb, mon_if->base_ndev);
+	}
+
+fail:
+	dev_kfree_skb(skb);
+	LEAVE();
+	return NETDEV_TX_OK;
+}
+
+/**
+ *  @brief This function returns the network statistics
+ *
+ *  @param dev     A pointer to net_device structure
+ *
+ *  @return        A pointer to net_device_stats structure
+ */
+static struct net_device_stats *woal_mon_get_stats(struct net_device *dev)
+{
+	monitor_iface *mon_if = (monitor_iface *)netdev_priv(dev);
+	return &mon_if->stats;
+}
+
+static const struct net_device_ops woal_cfg80211_mon_if_ops = {
+	.ndo_open = woal_mon_open,
+	.ndo_start_xmit = woal_mon_hard_start_xmit,
+	.ndo_stop = woal_mon_close,
+	.ndo_get_stats = woal_mon_get_stats,
+	.ndo_set_mac_address = woal_mon_set_mac_address,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_rx_mode = woal_mon_set_multicast_list,
+#else
+	.ndo_set_multicast_list = woal_mon_set_multicast_list,
+#endif
+};
+
+/**
+ * @brief This function setup monitor interface
+ *
+ * @param dev             A pointer to net_device structure
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static void woal_mon_if_setup(struct net_device *dev)
+{
+	ENTER();
+	ether_setup(dev);
+	dev->netdev_ops = &woal_cfg80211_mon_if_ops;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 11, 9)
+	dev->needs_free_netdev = true;
+#else
+	dev->destructor = free_netdev;
+#endif
+	LEAVE();
+}
+
+/**
+ * @brief Request the driver to add a monitor interface
+ *
+ * @param priv             A pointer to moal_private
+ * @param name              Virtual interface name
+ * @param name_assign_type  Interface name assignment type
+ *
+ * @return                  A pointer to monitor_iface
+ */
+monitor_iface *woal_prepare_mon_if(moal_private *priv, const char *name,
+				   unsigned char name_assign_type)
+{
+	int ret = 0;
+	moal_handle *handle = priv->phandle;
+	struct net_device *ndev = NULL;
+	monitor_iface *mon_if = NULL;
+
+	ENTER();
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+	ndev = alloc_netdev_mq(sizeof(*mon_if), name, name_assign_type,
+			       woal_mon_if_setup, 1);
+#else
+	ndev = alloc_netdev_mq(sizeof(*mon_if), name, NET_NAME_UNKNOWN,
+			       woal_mon_if_setup, 1);
+#endif
+#else
+	ndev = alloc_netdev_mq(sizeof(*mon_if), name, woal_mon_if_setup, 1);
+#endif
+#else
+	ndev = alloc_netdev_mq(sizeof(*mon_if), name, woal_mon_if_setup);
+#endif
+	if (!ndev) {
+		PRINTM(MFATAL, "Init virtual ethernet device failed\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+	ret = dev_alloc_name(ndev, ndev->name);
+	if (ret < 0) {
+		PRINTM(MFATAL, "Net device alloc name fail.\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+	//?memcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);
+
+	mon_if = netdev_priv(ndev);
+	moal_memcpy_ext(handle, mon_if->ifname, ndev->name, IFNAMSIZ, IFNAMSIZ);
+
+	ndev->type = ARPHRD_IEEE80211_RADIOTAP;
+	ndev->netdev_ops = &woal_cfg80211_mon_if_ops;
+
+	mon_if->priv = priv;
+	mon_if->mon_ndev = ndev;
+	mon_if->base_ndev = priv->netdev;
+	mon_if->radiotap_enabled = 1;
+	mon_if->flag = 1;
+
+fail:
+	if (ret) {
+		if (ndev)
+			free_netdev(ndev);
+		LEAVE();
+		return NULL;
+	}
+
+	LEAVE();
+	return mon_if;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33)
+static struct device_type wlan_type = {
+	.name = "wlan",
+};
+#endif
+
+#ifdef STA_SUPPORT
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+/** Network device handlers */
+const struct net_device_ops woal_netdev_ops = {
+	.ndo_open = woal_open,
+	.ndo_start_xmit = woal_hard_start_xmit,
+	.ndo_stop = woal_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	.ndo_siocdevprivate = woal_do_ioctl,
+#else
+	.ndo_do_ioctl = woal_do_ioctl,
+#endif
+	.ndo_set_mac_address = woal_set_mac_address,
+	.ndo_change_mtu = woal_change_mtu,
+	.ndo_tx_timeout = woal_tx_timeout,
+	.ndo_get_stats = woal_get_stats,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	.ndo_set_rx_mode = woal_set_multicast_list,
+#else
+	.ndo_set_multicast_list = woal_set_multicast_list,
+#endif
+	.ndo_select_queue = woal_select_queue,
+	.ndo_validate_addr = eth_validate_addr,
+};
+#endif
+
+#define MAX_MTU_SIZE 2000
+/**
+ *  @brief This function initializes the private structure
+ *          and dev structure for station mode
+ *
+ *  @param dev      A pointer to net_device structure
+ *  @param priv     A pointer to moal_private structure
+ *
+ *  @return         MLAN_STATUS_SUCCESS
+ */
+mlan_status woal_init_sta_dev(struct net_device *dev, moal_private *priv)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	mlan_fw_info fw_info;
+#endif
+	ENTER();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+#ifdef MFG_CMD_SUPPORT
+	if (priv->phandle->params.mfg_mode != MLAN_INIT_PARA_ENABLED) {
+#endif
+		memset(&fw_info, 0, sizeof(mlan_fw_info));
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info)) {
+			PRINTM(MERROR, "%s: get_fw_info failed \n", __func__);
+			return MLAN_STATUS_FAILURE;
+		}
+		if (fw_info.tx_buf_size >
+		    (MAX_MTU_SIZE + MLAN_MIN_DATA_HEADER_LEN +
+		     priv->extra_tx_head_len)) {
+			dev->max_mtu = MAX_MTU_SIZE;
+			PRINTM(MINFO, "wlan: %s set max_mtu %d\n", dev->name,
+			       dev->max_mtu);
+		}
+#ifdef MFG_CMD_SUPPORT
+	}
+#endif
+#endif
+	/* Setup the OS Interface to our functions */
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
+	dev->open = woal_open;
+	dev->hard_start_xmit = woal_hard_start_xmit;
+	dev->stop = woal_close;
+	dev->do_ioctl = woal_do_ioctl;
+	dev->set_mac_address = woal_set_mac_address;
+	dev->tx_timeout = woal_tx_timeout;
+	dev->get_stats = woal_get_stats;
+	dev->set_multicast_list = woal_set_multicast_list;
+#else
+	dev->netdev_ops = &woal_netdev_ops;
+#endif
+	dev->watchdog_timeo = MRVDRV_DEFAULT_WATCHDOG_TIMEOUT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	dev->needed_headroom += MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
+				priv->extra_tx_head_len;
+#else
+	dev->hard_header_len += MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
+				priv->extra_tx_head_len;
+#endif
+#ifdef STA_WEXT
+	if (IS_STA_WEXT(priv->phandle->params.cfg80211_wext)) {
+#if WIRELESS_EXT < 21
+		dev->get_wireless_stats = woal_get_wireless_stats;
+#endif
+		dev->wireless_handlers =
+			(struct iw_handler_def *)&woal_handler_def;
+	}
+#endif
+	dev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+
+#ifdef STA_CFG80211
+	if (IS_STA_CFG80211(priv->phandle->params.cfg80211_wext))
+		init_waitqueue_head(&priv->ft_wait_q);
+#endif
+	LEAVE();
+	return MLAN_STATUS_SUCCESS;
+}
+#endif /* STA_SUPPORT */
+
+#ifdef UAP_SUPPORT
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 /** Network device handlers */
 const struct net_device_ops woal_uap_netdev_ops = {
 	.ndo_open = woal_open,
 	.ndo_start_xmit = woal_hard_start_xmit,
 	.ndo_stop = woal_close,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	.ndo_siocdevprivate = woal_uap_do_ioctl,
+#else
 	.ndo_do_ioctl = woal_uap_do_ioctl,
+#endif
 	.ndo_set_mac_address = woal_set_mac_address,
+	.ndo_change_mtu = woal_change_mtu,
 	.ndo_tx_timeout = woal_tx_timeout,
 	.ndo_get_stats = woal_get_stats,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
@@ -3588,9 +5046,25 @@ const struct net_device_ops woal_uap_netdev_ops = {
 mlan_status woal_init_uap_dev(struct net_device *dev, moal_private *priv)
 {
 	mlan_status status = MLAN_STATUS_SUCCESS;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	mlan_fw_info fw_info;
+#endif
 
 	ENTER();
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+	memset(&fw_info, 0, sizeof(mlan_fw_info));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info)) {
+		PRINTM(MERROR, "%s: get_fw_info failed \n", __func__);
+		return MLAN_STATUS_FAILURE;
+	}
+	if (fw_info.tx_buf_size > (MAX_MTU_SIZE + MLAN_MIN_DATA_HEADER_LEN +
+				   priv->extra_tx_head_len)) {
+		dev->max_mtu = MAX_MTU_SIZE;
+		PRINTM(MMSG, "wlan: %s set max_mtu %d\n", dev->name,
+		       dev->max_mtu);
+	}
+#endif
 	/* Setup the OS Interface to our functions */
 #if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 29)
 	dev->open = woal_open;
@@ -3612,6 +5086,11 @@ mlan_status woal_init_uap_dev(struct net_device *dev, moal_private *priv)
 	dev->hard_header_len += MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
 				priv->extra_tx_head_len;
 #endif
+	/** don't need register to wext */
+	if (priv->bss_type == MLAN_BSS_TYPE_DFS) {
+		LEAVE();
+		return status;
+	}
 #ifdef UAP_WEXT
 	if (IS_UAP_WEXT(priv->phandle->params.cfg80211_wext)) {
 #if WIRELESS_EXT < 21
@@ -3652,61 +5131,67 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 #endif
 	ENTER();
 
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-#define MAX_WMM_QUEUE 4
-	/* Allocate an Ethernet device */
-	dev = alloc_etherdev_mq(sizeof(moal_private), MAX_WMM_QUEUE);
-#else
-	dev = alloc_etherdev(sizeof(moal_private));
-#endif
-	if (!dev) {
-		PRINTM(MFATAL, "Init virtual ethernet device failed\n");
-		goto error;
-	}
-	/* Allocate device name */
-#ifdef STA_SUPPORT
 	memset(name, 0, sizeof(name));
-	if (handle->params.sta_name)
-		snprintf(name, sizeof(name), "%s%%d", handle->params.sta_name);
-	else if (handle->second_mac)
-		snprintf(name, sizeof(name), "m%s", default_mlan_name);
-	else
-		snprintf(name, sizeof(name), "%s", default_mlan_name);
-
-	if ((bss_type == MLAN_BSS_TYPE_STA) &&
-	    (dev_alloc_name(dev, name) < 0)) {
-		PRINTM(MERROR, "Could not allocate mlan device name\n");
-		goto error;
-	}
+	switch (bss_type) {
+#ifdef STA_SUPPORT
+	case MLAN_BSS_TYPE_STA:
+		if (handle->params.sta_name)
+			snprintf(name, sizeof(name), "%s%%d",
+				 handle->params.sta_name);
+		else if (handle->second_mac)
+			snprintf(name, sizeof(name), "m%s", default_mlan_name);
+		else
+			snprintf(name, sizeof(name), "%s", default_mlan_name);
+		break;
 #endif
 #ifdef UAP_SUPPORT
-	memset(name, 0, sizeof(name));
-	if (handle->params.uap_name)
-		snprintf(name, sizeof(name), "%s%%d", handle->params.uap_name);
-	else if (handle->second_mac)
-		snprintf(name, sizeof(name), "m%s", default_uap_name);
-	else
-		snprintf(name, sizeof(name), "%s", default_uap_name);
-	if ((bss_type == MLAN_BSS_TYPE_UAP) &&
-	    (dev_alloc_name(dev, name) < 0)) {
-		PRINTM(MERROR, "Could not allocate uap device name\n");
-		goto error;
-	}
+	case MLAN_BSS_TYPE_UAP:
+		if (handle->params.uap_name)
+			snprintf(name, sizeof(name), "%s%%d",
+				 handle->params.uap_name);
+		else if (handle->second_mac)
+			snprintf(name, sizeof(name), "m%s", default_uap_name);
+		else
+			snprintf(name, sizeof(name), "%s", default_uap_name);
+		break;
 #endif
 #ifdef WIFI_DIRECT_SUPPORT
-	memset(name, 0, sizeof(name));
-	if (handle->params.wfd_name)
-		snprintf(name, sizeof(name), "%s%%d", handle->params.wfd_name);
-	else if (handle->second_mac)
-		snprintf(name, sizeof(name), "m%s", default_wfd_name);
-	else
-		snprintf(name, sizeof(name), "%s", default_wfd_name);
-	if ((bss_type == MLAN_BSS_TYPE_WIFIDIRECT) &&
-	    (dev_alloc_name(dev, name) < 0)) {
-		PRINTM(MERROR, "Could not allocate wifidirect device name\n");
-		goto error;
+	case MLAN_BSS_TYPE_WIFIDIRECT:
+		if (handle->params.wfd_name)
+			snprintf(name, sizeof(name), "%s%%d",
+				 handle->params.wfd_name);
+		else if (handle->second_mac)
+			snprintf(name, sizeof(name), "m%s", default_wfd_name);
+		else
+			snprintf(name, sizeof(name), "%s", default_wfd_name);
+		break;
+#endif
+	case MLAN_BSS_TYPE_DFS:
+		if (handle->second_mac)
+			snprintf(name, sizeof(name), "m%s", default_dfs_name);
+		else
+			snprintf(name, sizeof(name), "%s", default_dfs_name);
+		break;
+	default:
+		PRINTM(MERROR, "woal_add_interface: invalid bss_type=%d\n",
+		       bss_type);
+		return NULL;
 	}
+
+#define MAX_WMM_QUEUE 4
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+	/* Allocate an net device */
+	dev = alloc_netdev_mq(sizeof(moal_private), name, NET_NAME_UNKNOWN,
+			      ether_setup, MAX_WMM_QUEUE);
+#else
+	dev = alloc_netdev_mq(sizeof(moal_private), name, ether_setup,
+			      MAX_WMM_QUEUE);
 #endif
+
+	if (!dev) {
+		PRINTM(MERROR, "alloc_netdev failed\n");
+		goto error;
+	}
 	priv = (moal_private *)netdev_priv(dev);
 	/* Save the priv to handle */
 	handle->priv[bss_index] = priv;
@@ -3717,20 +5202,30 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 	priv->bss_index = bss_index;
 	priv->bss_type = bss_type;
 	priv->extra_tx_head_len = 0;
-	if (bss_type == MLAN_BSS_TYPE_STA)
+	if (bss_type == MLAN_BSS_TYPE_STA) {
 		priv->bss_role = MLAN_BSS_ROLE_STA;
-	else if (bss_type == MLAN_BSS_TYPE_UAP)
+	} else if (bss_type == MLAN_BSS_TYPE_UAP) {
 		priv->bss_role = MLAN_BSS_ROLE_UAP;
+	}
 #ifdef WIFI_DIRECT_SUPPORT
 	else if (bss_type == MLAN_BSS_TYPE_WIFIDIRECT)
 		priv->bss_role = MLAN_BSS_ROLE_STA;
 #endif
+	else if (bss_type == MLAN_BSS_TYPE_DFS)
+		priv->bss_role = MLAN_BSS_ROLE_UAP;
 
 	INIT_LIST_HEAD(&priv->tcp_sess_queue);
 	spin_lock_init(&priv->tcp_sess_lock);
+#ifdef STA_SUPPORT
+	INIT_LIST_HEAD(&priv->tdls_list);
+	spin_lock_init(&priv->tdls_lock);
+#endif
 
 	INIT_LIST_HEAD(&priv->tx_stat_queue);
 	spin_lock_init(&priv->tx_stat_lock);
+	INIT_LIST_HEAD(&priv->mcast_list);
+	spin_lock_init(&priv->mcast_lock);
+
 #ifdef STA_CFG80211
 #ifdef STA_SUPPORT
 	spin_lock_init(&priv->connect_lock);
@@ -3761,7 +5256,7 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 		woal_init_sta_dev(dev, priv);
 #endif
 #ifdef UAP_SUPPORT
-	if (bss_type == MLAN_BSS_TYPE_UAP) {
+	if (bss_type == MLAN_BSS_TYPE_UAP || bss_type == MLAN_BSS_TYPE_DFS) {
 		if (MLAN_STATUS_SUCCESS != woal_init_uap_dev(dev, priv))
 			goto error;
 	}
@@ -3837,12 +5332,14 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 				goto error;
 			}
 	}
+
 #endif /* STA_SUPPORT */
 #endif /* STA_CFG80211 */
 #ifdef UAP_CFG80211
 #ifdef UAP_SUPPORT
 	if ((priv->bss_role == MLAN_BSS_ROLE_UAP) &&
-	    IS_UAP_CFG80211(handle->params.cfg80211_wext)) {
+	    IS_UAP_CFG80211(handle->params.cfg80211_wext) &&
+	    bss_type != MLAN_BSS_TYPE_DFS) {
 		/* Register cfg80211 for UAP */
 		if (woal_register_uap_cfg80211(dev, bss_type)) {
 			PRINTM(MERROR, "Cannot register UAP with cfg80211\n");
@@ -3850,8 +5347,8 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 		}
 	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
-	strcpy(csa_str, "CSA");
-	strcat(csa_str, name);
+	strncpy(csa_str, "CSA", sizeof(csa_str));
+	strncat(csa_str, name, sizeof(csa_str) - 1);
 	priv->csa_workqueue = alloc_workqueue(
 		csa_str, WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
 	if (!priv->csa_workqueue) {
@@ -3863,6 +5360,20 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 #endif
 #endif /*UAP_CFG80211 */
 
+	/* Create workqueue for main process */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	priv->mclist_workqueue =
+		alloc_workqueue("MCLIST_WORK_QUEUE",
+				WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
+#else
+	priv->mclist_workqueue = create_workqueue("MCLIST_WORK_QUEUE");
+#endif
+	if (!priv->mclist_workqueue) {
+		PRINTM(MERROR, "cannot alloc mclist workqueue \n");
+		goto error;
+	}
+	MLAN_INIT_WORK(&priv->mclist_work, woal_mclist_work_queue);
+
 	/* Initialize priv structure */
 	woal_init_priv(priv, MOAL_IOCTL_WAIT);
 
@@ -3882,25 +5393,38 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 	netif_carrier_off(dev);
 	woal_stop_queue(dev);
 
-	PRINTM(MINFO, "%s: NXP 802.11 Adapter\n", dev->name);
+	PRINTM(MMSG, "Register NXP 802.11 Adapter %s\n", dev->name);
 
 	if (bss_type == MLAN_BSS_TYPE_STA ||
 	    priv->bss_type == MLAN_BSS_TYPE_UAP) {
+#ifdef MFG_CMD_SUPPORT
+		if (priv->phandle->params.mfg_mode != MLAN_INIT_PARA_ENABLED) {
+#endif
 #if defined(SD8887) || defined(SD8987)
-		mlan_fw_info fw_info;
-		memset(&fw_info, 0, sizeof(mlan_fw_info));
-		woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
-		if (MFALSE
+			mlan_fw_info fw_info;
+			memset(&fw_info, 0, sizeof(mlan_fw_info));
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT,
+						     &fw_info)) {
+				PRINTM(MERROR, "%s: get_fw_info failed \n",
+				       __func__);
+				goto error;
+			}
+			if (MFALSE
 #ifdef SD8887
-		    || IS_SD8887(handle->card_type)
+			    || IS_SD8887(handle->card_type)
 #endif
 #ifdef SD8987
-		    || IS_SD8987(handle->card_type)
+			    || IS_SD8987(handle->card_type)
 #endif
-		) {
-			if ((fw_info.antinfo & ANT_DIVERSITY_2G) &&
-			    (fw_info.antinfo & ANT_DIVERSITY_5G))
-				handle->card_info->histogram_table_num = 4;
+			) {
+				if ((fw_info.antinfo & ANT_DIVERSITY_2G) &&
+				    (fw_info.antinfo & ANT_DIVERSITY_5G))
+					handle->card_info->histogram_table_num =
+						4;
+			}
+#endif
+#ifdef MFG_CMD_SUPPORT
 		}
 #endif
 
@@ -3928,9 +5452,14 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 	return priv;
 error:
 	handle->priv_num = bss_index;
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	/* Unregister wiphy device and free */
 	if (priv) {
+		if (priv->mclist_workqueue) {
+			flush_workqueue(priv->mclist_workqueue);
+			destroy_workqueue(priv->mclist_workqueue);
+			priv->mclist_workqueue = NULL;
+		}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 		if (priv->wdev &&
 		    IS_STA_OR_UAP_CFG80211(handle->params.cfg80211_wext))
 			priv->wdev = NULL;
@@ -3942,8 +5471,8 @@ moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_index,
 		}
 #endif
 #endif
-	}
 #endif
+	}
 	if (dev && dev->reg_state == NETREG_REGISTERED)
 		unregister_netdev(dev);
 	if (dev)
@@ -3968,6 +5497,12 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 	union iwreq_data wrqu;
 #endif
 	int i = 0;
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	int count = 0;
+#endif
+#endif
 	ENTER();
 
 	if (!priv || !priv->netdev)
@@ -3976,6 +5511,7 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 
 	if (priv->media_connected == MTRUE) {
 		priv->media_connected = MFALSE;
+		moal_connection_status_check_pmqos(handle);
 #if defined(STA_WEXT) || defined(UAP_WEXT)
 		if (IS_STA_OR_UAP_WEXT(handle->params.cfg80211_wext) &&
 		    GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
@@ -3990,10 +5526,18 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 
 	woal_flush_tx_stat_queue(priv);
 
+#ifdef STA_CFG80211
+	if (priv->bss_type == MLAN_BSS_TYPE_STA)
+		woal_flush_tdls_list(priv);
+#endif
+	woal_flush_mcast_list(priv);
+
 #ifdef STA_CFG80211
 	if (priv->bss_type == MLAN_BSS_TYPE_STA &&
 	    IS_STA_CFG80211(handle->params.cfg80211_wext)) {
-		woal_flush_pmksa_list(priv);
+		if (woal_flush_pmksa_list(priv))
+			PRINTM(MERROR, "%s: woal_flush_pmksa_list failed!\n",
+			       __func__);
 		if (priv->okc_roaming_ie) {
 			kfree(priv->okc_roaming_ie);
 			priv->okc_roaming_ie = NULL;
@@ -4026,6 +5570,12 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 	if (dev->reg_state == NETREG_REGISTERED)
 		unregister_netdev(dev);
 
+	if (priv->mclist_workqueue) {
+		flush_workqueue(priv->mclist_workqueue);
+		destroy_workqueue(priv->mclist_workqueue);
+		priv->mclist_workqueue = NULL;
+	}
+
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	/* Unregister wiphy device and free */
 	if (priv->wdev && IS_STA_OR_UAP_CFG80211(handle->params.cfg80211_wext))
@@ -4040,10 +5590,12 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 #endif
 #endif
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA ||
 	    GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)
 		woal_deinit_wifi_hal(priv);
+#endif
 #endif
 
 		/* Clear the priv in handle */
@@ -4052,6 +5604,18 @@ void woal_remove_interface(moal_handle *handle, t_u8 bss_index)
 	if (IS_STA_OR_UAP_CFG80211(handle->params.cfg80211_wext))
 		priv->phandle->wiphy->extended_capabilities = NULL;
 #endif
+#ifdef UAP_SUPPORT
+	/* Clear the whole backhaul station list in moal */
+	for (count = 0; count < MAX_STA_COUNT; count++) {
+		if (priv->vlan_sta_list[count]) {
+			if (priv->vlan_sta_list[count]->is_valid)
+				unregister_netdevice(
+					priv->vlan_sta_list[count]->netdev);
+			kfree(priv->vlan_sta_list[count]);
+		}
+		priv->vlan_sta_list[count] = NULL;
+	}
+#endif
 #endif
 	priv->phandle->priv[priv->bss_index] = NULL;
 	priv->phandle = NULL;
@@ -4148,10 +5712,15 @@ mlan_status woal_set_user_antcfg(moal_handle *handle, t_u8 wait_option)
 
 	if (handle->feature_control & FEATURE_CTRL_STREAM_2X2) {
 		if (IS_CARD9098(handle->card_type) ||
-		    IS_CARD9097(handle->card_type))
+		    IS_CARD9097(handle->card_type) ||
+		    IS_CARDIW62X(handle->card_type)) {
 			radio->param.ant_cfg.tx_antenna =
 				radio->param.ant_cfg.rx_antenna = antcfg;
-		else {
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+			woal_cfg80211_notify_antcfg(priv, priv->phandle->wiphy,
+						    radio);
+#endif
+		} else {
 			radio->param.ant_cfg.tx_antenna =
 				(antcfg & 0x0030) >> 4;
 			radio->param.ant_cfg.rx_antenna = antcfg & 0x0003;
@@ -4213,6 +5782,53 @@ mlan_status woal_set_low_pwr_mode(moal_handle *handle, t_u8 wait_option)
 	return status;
 }
 
+/**
+ *  @brief Configure MLAN for channel tracking mode
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wait_option  Wait option
+ *
+ *  @return             MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
+ *                          otherwise fail
+ */
+mlan_status woal_set_chan_track_mode(moal_handle *handle, t_u8 wait_option)
+{
+	moal_private *priv = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_snmp_mib *mib = NULL;
+	mlan_status status;
+
+	ENTER();
+
+	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+	if (!priv) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Allocate an IOCTL request buffer */
+	req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
+		sizeof(mlan_ds_snmp_mib));
+	if (req == NULL) {
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	/* Fill request buffer */
+	mib = (mlan_ds_snmp_mib *)req->pbuf;
+	mib->sub_command = MLAN_OID_SNMP_MIB_CHAN_TRACK;
+	mib->param.chan_track = moal_extflg_isset(handle, EXT_CHAN_TRACK);
+	req->req_id = MLAN_IOCTL_SNMP_MIB;
+	req->action = MLAN_ACT_SET;
+
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, wait_option);
+done:
+	kfree(req);
+	LEAVE();
+	return status;
+}
+
 /**
  *  @brief Send FW shutdown command to MLAN
  *
@@ -4285,7 +5901,7 @@ int woal_hexval(char chr)
  *
  *  @return          N/A
  */
-void woal_flush_evt_queue(moal_handle *handle)
+static void woal_flush_evt_queue(moal_handle *handle)
 {
 	struct woal_event *evt = NULL, *tmp_node;
 	unsigned long flags;
@@ -4300,6 +5916,29 @@ void woal_flush_evt_queue(moal_handle *handle)
 	spin_unlock_irqrestore(&handle->evt_lock, flags);
 }
 
+/**
+ *  @brief This function flush all works in the queue
+ *
+ *  @param handle    A pointer to moal_handle
+ *
+ *  @return        N/A
+ */
+void woal_flush_workqueue(moal_handle *handle)
+{
+	ENTER();
+
+	/* Terminate main workqueue */
+	if (handle->workqueue)
+		flush_workqueue(handle->workqueue);
+	if (handle->rx_workqueue)
+		flush_workqueue(handle->rx_workqueue);
+	if (handle->evt_workqueue)
+		flush_workqueue(handle->evt_workqueue);
+	if (handle->tx_workqueue)
+		flush_workqueue(handle->tx_workqueue);
+	LEAVE();
+}
+
 /**
  *  @brief This function cancel all works in the queue
  *  and destroy the main workqueue.
@@ -4329,7 +5968,11 @@ void woal_terminate_workqueue(moal_handle *handle)
 		destroy_workqueue(handle->evt_workqueue);
 		handle->evt_workqueue = NULL;
 	}
-
+	if (handle->tx_workqueue) {
+		flush_workqueue(handle->tx_workqueue);
+		destroy_workqueue(handle->tx_workqueue);
+		handle->tx_workqueue = NULL;
+	}
 	LEAVE();
 }
 
@@ -4351,9 +5994,15 @@ int woal_open(struct net_device *dev)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
 	struct usb_interface *intf =
 		((struct usb_card_rec *)priv->phandle->card)->intf;
+#else
+	// struct usb_device *udev = ((struct usb_card_rec
+	// *)(priv->phandle->card))->udev;
 #endif /* < 2.6.34 */
 #endif /* USB_SUSPEND_RESUME */
 	t_u8 carrier_on = MFALSE;
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	int cfg80211_wext = priv->phandle->params.cfg80211_wext;
+#endif
 
 	ENTER();
 
@@ -4366,19 +6015,13 @@ int woal_open(struct net_device *dev)
 #if defined(USB)
 	if (IS_USB(priv->phandle->card_type)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
-		intf->pm_usage_cnt = 1;
-#else
-		atomic_set(&intf->pm_usage_cnt, 1);
-#endif /* < 2.6.32 */
-		usb_autopm_put_interface(intf);
+		/* Error enabling PM on interface */
+		if (usb_autopm_get_interface(intf)) {
+			LEAVE();
+			return -EIO;
+		}
 #else
-		struct usb_device *udev =
-			((struct usb_card_rec *)(priv->phandle->card))->udev;
-		usb_lock_device(udev);
-		atomic_set(&udev->dev.power.usage_count, 1);
-		usb_enable_autosuspend(udev);
-		usb_unlock_device(udev);
+		// atomic_set(&udev->dev.power.usage_count, 1);
 #endif /* < 2.6.34 */
 	}
 #endif /* USB_SUSPEND_RESUME */
@@ -4426,6 +6069,14 @@ int woal_open(struct net_device *dev)
 	    (priv->media_connected || priv->is_adhoc_link_sensed))
 		carrier_on = MTRUE;
 #endif
+
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	if (IS_STA_OR_UAP_CFG80211(cfg80211_wext)) {
+		if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP_VLAN)
+			carrier_on = MTRUE;
+	}
+#endif
+
 	if (carrier_on == MTRUE) {
 		if (!netif_carrier_ok(priv->netdev))
 			netif_carrier_on(priv->netdev);
@@ -4453,6 +6104,9 @@ int woal_close(struct net_device *dev)
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
 	struct usb_interface *intf =
 		((struct usb_card_rec *)priv->phandle->card)->intf;
+#else
+	// struct usb_device *udev = ((struct usb_card_rec
+	// *)(priv->phandle->card))->udev;
 #endif /* < 2.6.34 */
 #endif /* USB_SUSPEND_RESUME */
 #ifdef STA_CFG80211
@@ -4460,17 +6114,47 @@ int woal_close(struct net_device *dev)
 #endif
 	ENTER();
 
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	if (IS_STA_OR_UAP_CFG80211(cfg80211_wext)) {
+		/** For multi-ap virtual interface */
+		if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP_VLAN) {
+			woal_stop_queue(priv->netdev);
+			MODULE_PUT;
+			LEAVE();
+			return 0;
+		}
+	}
+#endif
+
 	woal_flush_tx_stat_queue(priv);
 
+	if ((priv->media_connected == MTRUE)
+#ifdef UAP_SUPPORT
+	    || (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)
+#endif
+	) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_disconnect(priv, MOAL_IOCTL_WAIT, NULL,
+				    DEF_DEAUTH_REASON_CODE)) {
+			PRINTM(MERROR, "%s: woal_disconnect failed \n",
+			       __func__);
+		}
+		priv->media_connected = MFALSE;
+	}
+
 #ifdef STA_SUPPORT
 #ifdef STA_CFG80211
-	if (IS_STA_CFG80211(cfg80211_wext) &&
-	    (priv->bss_type == MLAN_BSS_TYPE_STA))
+	if (IS_STA_CFG80211(cfg80211_wext))
 		woal_clear_conn_params(priv);
 	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+	if (IS_STA_CFG80211(cfg80211_wext) && priv->wdev->connected) {
+#else
 	if (IS_STA_CFG80211(cfg80211_wext) && priv->wdev->current_bss) {
+#endif
 		priv->cfg_disconnect = MTRUE;
 		cfg80211_disconnected(priv->netdev, 0, NULL, 0,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
@@ -4502,19 +6186,9 @@ int woal_close(struct net_device *dev)
 #if defined(USB)
 	if (IS_USB(priv->phandle->card_type)) {
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 34)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
-		intf->pm_usage_cnt = 0;
-#else
-		atomic_set(&intf->pm_usage_cnt, 0);
-#endif /* < 2.6.32 */
-		usb_autopm_get_interface(intf);
+		usb_autopm_put_interface(intf);
 #else
-		struct usb_device *udev =
-			((struct usb_card_rec *)(priv->phandle->card))->udev;
-		usb_lock_device(udev);
-		atomic_set(&udev->dev.power.usage_count, 0);
-		usb_disable_autosuspend(udev);
-		usb_unlock_device(udev);
+		// atomic_set(&udev->dev.power.usage_count, 0);
 #endif /* < 2.6.34 */
 	}
 #endif /* USB_SUSPEND_RESUME */
@@ -4523,6 +6197,54 @@ int woal_close(struct net_device *dev)
 	return 0;
 }
 
+#define DEF_MTU_SIZE 1500
+/**
+ *  @brief This function disable the ampdu
+ *
+ *  @param priv     A pointer to mlan_private structure
+ *  @param new_mtu  new mtu size
+ *
+ *  @return        0 --success, otherwise fail
+ */
+void woal_disable_ampdu(moal_private *priv)
+{
+	mlan_ds_11n_aggr_prio_tbl aggr_prio_tbl;
+	int i;
+	memset(&aggr_prio_tbl, 0, sizeof(aggr_prio_tbl));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_ioctl_aggr_prio_tbl(priv, MLAN_ACT_GET, &aggr_prio_tbl)) {
+		goto done;
+	}
+	for (i = 0; i < MAX_NUM_TID; i++)
+		aggr_prio_tbl.ampdu[i] = 0xff;
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_ioctl_aggr_prio_tbl(priv, MLAN_ACT_SET, &aggr_prio_tbl)) {
+		goto done;
+	}
+done:
+	return;
+}
+
+/**
+ *  @brief This function change the MTU size
+ *
+ *  @param dev     A pointer to mlan_private structure
+ *  @param new_mtu  new mtu size
+ *
+ *  @return        0 --success, otherwise fail
+ */
+int woal_change_mtu(struct net_device *dev, int new_mtu)
+{
+	moal_private *priv = (moal_private *)netdev_priv(dev);
+	dev->mtu = new_mtu;
+	// disable AMPDU with mtu size > 1500
+	if (new_mtu > DEF_MTU_SIZE)
+		woal_disable_ampdu(priv);
+	PRINTM(MCMND, "wlan: change_mtu to %d\n", new_mtu);
+
+	return 0;
+}
+
 /**
  *  @brief This function sets the MAC address to firmware.
  *
@@ -4547,11 +6269,18 @@ int woal_set_mac_address(struct net_device *dev, void *addr)
 		return -EFAULT;
 	}
 
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	/* No need to set mac address for multi-ap virtual interface */
+	if ((dev->ieee80211_ptr) &&
+	    (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP_VLAN))
+		return 0;
+#endif
+
 	moal_memcpy_ext(priv->phandle, prev_addr, priv->current_addr, ETH_ALEN,
 			ETH_ALEN);
 	memset(priv->current_addr, 0, ETH_ALEN);
 	/* dev->dev_addr is 6 bytes */
-	HEXDUMP("dev->dev_addr:", dev->dev_addr, ETH_ALEN);
+	HEXDUMP("dev->dev_addr:", (t_u8 *)dev->dev_addr, ETH_ALEN);
 
 	HEXDUMP("addr:", (t_u8 *)phw_addr->sa_data, ETH_ALEN);
 	moal_memcpy_ext(priv->phandle, priv->current_addr, phw_addr->sa_data,
@@ -4577,8 +6306,12 @@ int woal_set_mac_address(struct net_device *dev, void *addr)
 		goto done;
 	}
 	HEXDUMP("priv->MacAddr:", priv->current_addr, ETH_ALEN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	eth_hw_addr_set(dev, priv->current_addr);
+#else
 	moal_memcpy_ext(priv->phandle, dev->dev_addr, priv->current_addr,
 			ETH_ALEN, ETH_ALEN);
+#endif
 done:
 	LEAVE();
 	return ret;
@@ -4728,18 +6461,19 @@ void woal_mlan_debug_info(moal_private *priv)
 
 	PRINTM(MERROR, "last_cmd_index = %d\n", info->last_cmd_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_id[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_cmd_id[i]);
 	PRINTM(MERROR, "last_cmd_id = %s\n", str);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_act[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_cmd_act[i]);
 	PRINTM(MERROR, "last_cmd_act = %s\n", str);
 	PRINTM(MERROR, "last_cmd_resp_index = %d\n", info->last_cmd_resp_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_resp_id[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ",
+			      info->last_cmd_resp_id[i]);
 	PRINTM(MERROR, "last_cmd_resp_id = %s\n", str);
 	PRINTM(MERROR, "last_event_index = %d\n", info->last_event_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_event[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_event[i]);
 	PRINTM(MERROR, "last_event = %s", str);
 
 	PRINTM(MERROR, "num_data_h2c_failure = %d\n",
@@ -4764,15 +6498,18 @@ void woal_mlan_debug_info(moal_private *priv)
 		       (unsigned int)info->mp_rd_bitmap, info->curr_rd_port);
 		PRINTM(MERROR, "mp_wr_bitmap=0x%x curr_wr_port=0x%x\n",
 		       (unsigned int)info->mp_wr_bitmap, info->curr_wr_port);
-		PRINTM(MERROR, "mp_invalid_update=%d\n",
-		       info->mp_invalid_update);
+		PRINTM(MERROR, "mp_data_port_mask=0x%x\n",
+		       info->mp_data_port_mask);
+		PRINTM(MERROR,
+		       "last_recv_rd_bitmap=0x%x mp_invalid_update=%d\n",
+		       info->last_recv_rd_bitmap, info->mp_invalid_update);
 		mp_aggr_pkt_limit = info->mp_aggr_pkt_limit;
 		PRINTM(MERROR, "last_recv_wr_bitmap=0x%x last_mp_index = %d\n",
 		       info->last_recv_wr_bitmap, info->last_mp_index);
 		for (i = 0; i < SDIO_MP_DBG_NUM; i++) {
 			for (s = str, j = 0; j < mp_aggr_pkt_limit; j++)
-				s += sprintf(
-					s, "0x%02x ",
+				s += snprintf(
+					s, MAX_BUF_LEN, "0x%02x ",
 					info->last_mp_wr_info
 						[i * mp_aggr_pkt_limit + j]);
 
@@ -4794,15 +6531,8 @@ void woal_mlan_debug_info(moal_private *priv)
 		PRINTM(MERROR, "eventbd_rdptr=0x%x event_wrptr=0x%x\n",
 		       info->eventbd_rdptr, info->eventbd_wrptr);
 		PRINTM(MERROR, "last_wr_index:%d\n",
-		       info->txbd_wrptr & (MLAN_MAX_TXRX_BD - 1));
-		PRINTM(MERROR, "Tx pkt size:\n");
-		for (s = str, i = 0; i < MLAN_MAX_TXRX_BD; i++) {
-			s += sprintf(s, "%d ", info->last_tx_pkt_size[i]);
-			if (((i + 1) % 16) == 0) {
-				PRINTM(MERROR, "%s\n", str);
-				s = str;
-			}
-		}
+		       info->txbd_wrptr & (info->txrx_bd_size - 1));
+		PRINTM(MERROR, "TxRx BD size:%d\n", info->txrx_bd_size);
 	}
 #endif
 	PRINTM(MERROR, "num_event_deauth = %d\n", info->num_event_deauth);
@@ -4821,9 +6551,11 @@ void woal_mlan_debug_info(moal_private *priv)
 	PRINTM(MERROR, "max_tx_buf_size = %d\n", info->max_tx_buf_size);
 	PRINTM(MERROR, "tx_buf_size = %d\n", info->tx_buf_size);
 	PRINTM(MERROR, "curr_tx_buf_size = %d\n", info->curr_tx_buf_size);
+	PRINTM(MERROR, "bypass_pkt_count=%d\n", info->bypass_pkt_count);
 
 	PRINTM(MERROR, "data_sent=%d cmd_sent=%d\n", info->data_sent,
 	       info->cmd_sent);
+	PRINTM(MERROR, "data_sent_cnt=%u\n", info->data_sent_cnt);
 
 	PRINTM(MERROR, "ps_mode=%d ps_state=%d\n", info->ps_mode,
 	       info->ps_state);
@@ -4837,7 +6569,8 @@ void woal_mlan_debug_info(moal_private *priv)
 	PRINTM(MERROR, "tx_lock_flag = %d\n", info->tx_lock_flag);
 	PRINTM(MERROR, "port_open = %d\n", info->port_open);
 	PRINTM(MERROR, "scan_processing = %d\n", info->scan_processing);
-	for (i = 0; i < info->ralist_num; i++) {
+	PRINTM(MERROR, "scan_state = 0x%x\n", info->scan_state);
+	for (i = 0; i < (int)info->ralist_num; i++) {
 		PRINTM(MERROR,
 		       "ralist ra: %02x:%02x:%02x:%02x:%02x:%02x tid=%d pkts=%d pause=%d\n",
 		       info->ralist[i].ra[0], info->ralist[i].ra[1],
@@ -4868,7 +6601,7 @@ void woal_mlan_debug_info(moal_private *priv)
  *
  *  @return         N/A
  */
-void woal_ioctl_timeout(moal_handle *handle)
+static void woal_ioctl_timeout(moal_handle *handle)
 {
 	moal_private *priv = NULL;
 
@@ -4900,7 +6633,7 @@ void woal_tx_timeout(struct net_device *dev
 )
 {
 	moal_private *priv = (moal_private *)netdev_priv(dev);
-
+	t_u8 auto_fw_dump = MFALSE;
 	ENTER();
 
 	priv->num_tx_timeout++;
@@ -4908,23 +6641,19 @@ void woal_tx_timeout(struct net_device *dev
 	       dev->name, priv->bss_index, priv->num_tx_timeout);
 	woal_set_trans_start(dev);
 
-	if (priv->num_tx_timeout == NUM_TX_TIMEOUT_THRESHOLD) {
+	if (priv->num_tx_timeout == NUM_TX_TIMEOUT_THRESHOLD &&
+	    priv->txwatchdog_disable == MFALSE) {
+#ifdef DEBUG_LEVEL1
+		if (drvdbg & MFW_D)
+			auto_fw_dump = MTRUE;
+#endif
 		woal_mlan_debug_info(priv);
 		woal_moal_debug_info(priv, NULL, MFALSE);
-		woal_broadcast_event(priv, CUS_EVT_DRIVER_HANG,
-				     strlen(CUS_EVT_DRIVER_HANG));
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-		if (IS_STA_OR_UAP_CFG80211(priv->phandle->params.cfg80211_wext))
-			woal_cfg80211_vendor_event(priv, event_hang,
-						   CUS_EVT_DRIVER_HANG,
-						   strlen(CUS_EVT_DRIVER_HANG));
-#endif
-#endif
 		priv->phandle->driver_status = MTRUE;
-		woal_process_hang(priv->phandle);
+		if (!auto_fw_dump && !priv->phandle->fw_dump)
+			woal_process_hang(priv->phandle);
 
-		wifi_status = 3;
+		wifi_status = WIFI_STATUS_TX_TIMEOUT;
 	}
 
 	LEAVE();
@@ -4943,6 +6672,77 @@ struct net_device_stats *woal_get_stats(struct net_device *dev)
 	return &priv->stats;
 }
 
+#if !defined(STA_CFG80211) && !defined(UAP_CFG80211)
+/**
+ *  @brief This function determine the 802.1p/1d tag to use
+ *
+ *  @param skb
+ *
+ *  @return          tid
+ */
+unsigned int woal_classify8021d(struct sk_buff *skb)
+{
+	unsigned int dscp;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	unsigned char vlan_priority;
+#endif
+	unsigned int tid;
+
+	/* skb->priority values from 256->263 are magic values to
+	 * directly indicate a specific 802.1d priority.  This is used
+	 * to allow 802.1d priority to be passed directly in from VLAN
+	 * tags, etc.
+	 */
+	if (skb->priority >= 256 && skb->priority <= 263) {
+		tid = skb->priority - 256;
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	if (skb_vlan_tag_present(skb)) {
+		vlan_priority = (skb_vlan_tag_get(skb) & VLAN_PRIO_MASK) >>
+				VLAN_PRIO_SHIFT;
+		if (vlan_priority > 0) {
+			tid = vlan_priority;
+			goto out;
+		}
+	}
+#endif
+	switch (skb->protocol) {
+	case htons(ETH_P_IP):
+		dscp = ipv4_get_dsfield(ip_hdr(skb)) & 0xfc;
+		break;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	case htons(ETH_P_IPV6):
+		dscp = ipv6_get_dsfield(ipv6_hdr(skb)) & 0xfc;
+		break;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	case htons(ETH_P_MPLS_UC):
+	case htons(ETH_P_MPLS_MC): {
+		struct mpls_label mpls_tmp, *mpls;
+
+		mpls = skb_header_pointer(skb, sizeof(struct ethhdr),
+					  sizeof(*mpls), &mpls_tmp);
+		if (!mpls)
+			return 0;
+
+		tid = (ntohl(mpls->entry) & MPLS_LS_TC_MASK) >>
+		      MPLS_LS_TC_SHIFT;
+		goto out;
+	}
+	case htons(ETH_P_80221):
+		/* 802.21 is always network control traffic */
+		return 7;
+#endif
+	default:
+		return 0;
+	}
+	tid = dscp >> 5;
+out:
+	return tid;
+}
+#endif
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 /**
  *  @brief This function handles wmm queue select
@@ -4970,7 +6770,6 @@ u16 woal_select_queue(struct net_device *dev, struct sk_buff *skb
 )
 {
 	moal_private *priv = (moal_private *)netdev_priv(dev);
-	struct ethhdr *eth = NULL;
 	t_u8 tid = 0;
 	t_u8 index = 0;
 
@@ -4979,32 +6778,27 @@ u16 woal_select_queue(struct net_device *dev, struct sk_buff *skb
 		LEAVE();
 		return index;
 	}
-	/*
-	 * skb->priority values from 256->263 are magic values to
-	 * directly indicate a specific 802.1d priority.  This is used
-	 * to allow 802.1d priority to be passed directly in from VLAN
-	 * tags, etc.
-	 */
-	if (IS_SKB_MAGIC_VLAN(skb)) {
-		tid = GET_VLAN_PRIO(skb);
-	} else {
-		eth = (struct ethhdr *)skb->data;
-		switch (eth->h_proto) {
-		case __constant_htons(ETH_P_IP):
-			tid = priv->dscp_map[SKB_TOS(skb) >> DSCP_OFFSET];
-			if (tid == 0xFF)
-				tid = (IPTOS_PREC(SKB_TOS(skb)) >>
-				       IPTOS_OFFSET);
-			break;
-		case __constant_htons(ETH_P_IPV6):
-			tid = SKB_TIDV6(skb);
-			break;
-		case __constant_htons(ETH_P_ARP):
-		default:
-			break;
-		}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	tid = skb->priority = cfg80211_classify8021d(skb, NULL);
+#else
+	tid = skb->priority = cfg80211_classify8021d(skb);
+#endif
+#else
+	tid = skb->priority = woal_classify8021d(skb);
+#endif
+#define NXP_ETH_P_EAPOL 0x888E
+#define NXP_ETH_P_WAPI 0x8884
+	switch (skb->protocol) {
+	case htons(ETH_P_ARP):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	case htons(ETH_P_TDLS):
+#endif
+	case htons(NXP_ETH_P_EAPOL):
+	case htons(NXP_ETH_P_WAPI):
+		tid = skb->priority = 7;
+		break;
 	}
-
 	index = mlan_select_wmm_queue(priv->phandle->pmlan_adapter,
 				      priv->bss_index, tid);
 	PRINTM(MDATA, "select queue: tid=%d, index=%d\n", tid, index);
@@ -5052,6 +6846,9 @@ void woal_flush_tx_stat_queue(moal_private *priv)
 	}
 	INIT_LIST_HEAD(&priv->tx_stat_queue);
 	spin_unlock_irqrestore(&priv->tx_stat_lock, flags);
+	spin_lock_bh(&(priv->tx_q.lock));
+	__skb_queue_purge(&priv->tx_q);
+	spin_unlock_bh(&(priv->tx_q.lock));
 }
 
 /**
@@ -5106,6 +6903,193 @@ void woal_remove_tx_info(moal_private *priv, t_u8 tx_seq_num)
 	LEAVE();
 }
 
+/**
+ *  @brief This function flush mcast list
+ *
+ *  @param priv      A pointer to moal_private structure
+ *
+ *  @return          N/A
+ */
+void woal_flush_mcast_list(moal_private *priv)
+{
+	struct mcast_node *node = NULL, *tmp_node;
+	unsigned long flags;
+	spin_lock_irqsave(&priv->mcast_lock, flags);
+	list_for_each_entry_safe (node, tmp_node, &priv->mcast_list, link) {
+		list_del(&node->link);
+		kfree(node);
+	}
+	INIT_LIST_HEAD(&priv->mcast_list);
+	priv->num_mcast_addr = 0;
+	spin_unlock_irqrestore(&priv->mcast_lock, flags);
+}
+
+/**
+ *  @brief  find mcast node from tx packet
+ *
+ *  @param priv      A pointer to moal_private structure
+ *  @param skb       A pointer to skb buffer.
+ *
+ *  @return          N/A
+ */
+t_u8 woal_find_mcast_node_tx(moal_private *priv, struct sk_buff *skb)
+{
+	struct mcast_node *node = NULL;
+	unsigned long flags;
+	t_u8 ret = MFALSE;
+	t_u8 ra[MLAN_MAC_ADDR_LENGTH] = {0};
+	ENTER();
+	moal_memcpy_ext(priv->phandle, ra, skb->data, MLAN_MAC_ADDR_LENGTH,
+			sizeof(ra));
+	if (ra[0] & 0x01) {
+		spin_lock_irqsave(&priv->mcast_lock, flags);
+		list_for_each_entry (node, &priv->mcast_list, link) {
+			if (!memcmp(node->mcast_addr, ra, ETH_ALEN)) {
+				ret = MTRUE;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&priv->mcast_lock, flags);
+	}
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief add mcast node
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param peer                  A point to peer address
+ *
+ * @return                      N/A
+ */
+t_void woal_add_mcast_node(moal_private *priv, t_u8 *mcast_addr)
+{
+	struct mcast_node *node = NULL;
+	unsigned long flags;
+	t_u8 find_node = MFALSE;
+	if (priv) {
+		spin_lock_irqsave(&priv->mcast_lock, flags);
+		list_for_each_entry (node, &priv->mcast_list, link) {
+			if (!memcmp(node->mcast_addr, mcast_addr, ETH_ALEN)) {
+				find_node = MTRUE;
+				break;
+			}
+		}
+		if (!find_node) {
+			/* create new mcast node */
+			node = kzalloc(sizeof(struct mcast_node), GFP_ATOMIC);
+			if (node) {
+				moal_memcpy_ext(priv->phandle, node->mcast_addr,
+						mcast_addr, ETH_ALEN, ETH_ALEN);
+				INIT_LIST_HEAD(&node->link);
+				list_add_tail(&node->link, &priv->mcast_list);
+				PRINTM(MCMND,
+				       "Add to mcast list: node=" MACSTR "\n",
+				       MAC2STR(mcast_addr));
+			}
+		}
+		spin_unlock_irqrestore(&priv->mcast_lock, flags);
+	}
+}
+
+/**
+ *  @brief This function remove mcast node
+ *
+ *  @param priv      		A pointer to moal_private structure
+ *  @param mcast_addr       mcast address
+ *
+ *  @return	         N/A
+ */
+void woal_remove_mcast_node(moal_private *priv, t_u8 *mcast_addr)
+{
+	struct mcast_node *node, *tmp = NULL;
+	unsigned long flags;
+	ENTER();
+
+	spin_lock_irqsave(&priv->mcast_lock, flags);
+	list_for_each_entry_safe (node, tmp, &priv->mcast_list, link) {
+		if (!memcmp(node->mcast_addr, mcast_addr, ETH_ALEN)) {
+			list_del(&node->link);
+			kfree(node);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&priv->mcast_lock, flags);
+
+	LEAVE();
+}
+
+#ifdef STA_CFG80211
+/**
+ *  @brief This function flush tcp session queue
+ *
+ *  @param priv      A pointer to moal_private structure
+ *
+ *  @return          N/A
+ */
+void woal_flush_tdls_list(moal_private *priv)
+{
+	struct tdls_peer *peer = NULL, *tmp_node;
+	unsigned long flags;
+	spin_lock_irqsave(&priv->tdls_lock, flags);
+	list_for_each_entry_safe (peer, tmp_node, &priv->tdls_list, link) {
+		list_del(&peer->link);
+		kfree(peer);
+	}
+	INIT_LIST_HEAD(&priv->tdls_list);
+	spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	priv->tdls_check_tx = MFALSE;
+}
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+/**
+ *  @brief  check the tx packet for tdls auto set up
+ *
+ *  @param priv      A pointer to moal_private structure
+ *  @param skb       A pointer to skb buffer.
+ *
+ *  @return          N/A
+ */
+static void woal_tdls_check_tx(moal_private *priv, struct sk_buff *skb)
+{
+	struct tdls_peer *peer = NULL;
+	unsigned long flags;
+	t_u8 ra[MLAN_MAC_ADDR_LENGTH] = {0};
+	ENTER();
+	moal_memcpy_ext(priv->phandle, ra, skb->data, MLAN_MAC_ADDR_LENGTH,
+			sizeof(ra));
+	spin_lock_irqsave(&priv->tdls_lock, flags);
+	list_for_each_entry (peer, &priv->tdls_list, link) {
+		if (!memcmp(peer->peer_addr, ra, ETH_ALEN)) {
+			if (peer->rssi &&
+			    (peer->rssi <= TDLS_RSSI_HIGH_THRESHOLD)) {
+				if ((peer->link_status == TDLS_NOT_SETUP) &&
+				    (peer->num_failure <
+				     TDLS_MAX_FAILURE_COUNT)) {
+					peer->link_status =
+						TDLS_SETUP_INPROGRESS;
+					PRINTM(MMSG,
+					       "Wlan: Set up TDLS link,peer=" MACSTR
+					       " rssi=%d\n",
+					       MAC2STR(peer->peer_addr),
+					       -peer->rssi);
+					cfg80211_tdls_oper_request(
+						priv->netdev, peer->peer_addr,
+						NL80211_TDLS_SETUP, 0,
+						GFP_ATOMIC);
+					priv->tdls_check_tx = MFALSE;
+				}
+			}
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	LEAVE();
+}
+#endif
+#endif
+
 /**
  *  @brief This function flush tcp session queue
  *
@@ -5122,7 +7106,7 @@ void woal_flush_tcp_sess_queue(moal_private *priv)
 	list_for_each_entry_safe (tcp_sess, tmp_node, &priv->tcp_sess_queue,
 				  link) {
 		list_del(&tcp_sess->link);
-		if (tcp_sess->is_timer_set)
+		if (atomic_read(&tcp_sess->is_timer_set))
 			woal_cancel_timer(&tcp_sess->ack_timer);
 		skb = (struct sk_buff *)tcp_sess->ack_skb;
 		if (skb)
@@ -5167,6 +7151,37 @@ static inline struct tcp_sess *woal_get_tcp_sess(moal_private *priv,
 	return NULL;
 }
 
+#define TCP_SESS_AGEOUT 300
+/**
+ *  @brief This function flush tcp session queue
+ *
+ *  @param priv      A pointer to moal_private structure
+ *
+ *  @return          N/A
+ */
+static void woal_ageout_tcp_sess_queue(moal_private *priv)
+{
+	struct tcp_sess *tcp_sess = NULL, *tmp_node;
+	wifi_timeval t;
+	struct sk_buff *skb;
+	woal_get_monotonic_time(&t);
+	list_for_each_entry_safe (tcp_sess, tmp_node, &priv->tcp_sess_queue,
+				  link) {
+		if (t.time_sec >
+		    (tcp_sess->update_time.time_sec + TCP_SESS_AGEOUT)) {
+			PRINTM(MDATA, "wlan: ageout TCP seesion %p\n",
+			       tcp_sess);
+			list_del(&tcp_sess->link);
+			if (atomic_read(&tcp_sess->is_timer_set))
+				woal_cancel_timer(&tcp_sess->ack_timer);
+			skb = (struct sk_buff *)tcp_sess->ack_skb;
+			if (skb)
+				dev_kfree_skb_any(skb);
+			kfree(tcp_sess);
+		}
+	}
+}
+
 /**
  *  @brief This function send the holding tcp ack packet
  *  re-assoc thread.
@@ -5174,7 +7189,7 @@ static inline struct tcp_sess *woal_get_tcp_sess(moal_private *priv,
  *  @param context  A pointer to context
  *  @return         N/A
  */
-void woal_tcp_ack_timer_func(void *context)
+static void woal_tcp_ack_timer_func(void *context)
 {
 	struct tcp_sess *tcp_session = (struct tcp_sess *)context;
 	moal_private *priv = (moal_private *)tcp_session->priv;
@@ -5187,25 +7202,29 @@ void woal_tcp_ack_timer_func(void *context)
 #endif
 	ENTER();
 	spin_lock_irqsave(&priv->tcp_sess_lock, flags);
-	tcp_session->is_timer_set = MFALSE;
+	atomic_set(&tcp_session->is_timer_set, MFALSE);
 	skb = (struct sk_buff *)tcp_session->ack_skb;
 	pmbuf = (mlan_buffer *)tcp_session->pmbuf;
 	tcp_session->ack_skb = NULL;
 	tcp_session->pmbuf = NULL;
 	spin_unlock_irqrestore(&priv->tcp_sess_lock, flags);
 	if (skb && pmbuf) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+		index = skb_get_queue_mapping(skb);
+#endif
 		status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
 		switch (status) {
 		case MLAN_STATUS_PENDING:
 			atomic_inc(&priv->phandle->tx_pending);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-			index = skb_get_queue_mapping(skb);
 			atomic_inc(&priv->wmm_tx_pending[index]);
 			if (atomic_read(&priv->wmm_tx_pending[index]) >=
 			    MAX_TX_PENDING) {
 				struct netdev_queue *txq = netdev_get_tx_queue(
 					priv->netdev, index);
 				netif_tx_stop_queue(txq);
+				moal_tp_accounting_rx_param(
+					(t_void *)priv->phandle, 8, 0);
 				PRINTM(MINFO, "Stop Kernel Queue : %d\n",
 				       index);
 			}
@@ -5241,7 +7260,7 @@ void woal_tcp_ack_timer_func(void *context)
  *  @param tcp_session  A pointer to tcp_session
  *  @return         N/A
  */
-void woal_send_tcp_ack(moal_private *priv, struct tcp_sess *tcp_session)
+static void woal_send_tcp_ack(moal_private *priv, struct tcp_sess *tcp_session)
 {
 	mlan_status status;
 	struct sk_buff *skb = (struct sk_buff *)tcp_session->ack_skb;
@@ -5250,24 +7269,27 @@ void woal_send_tcp_ack(moal_private *priv, struct tcp_sess *tcp_session)
 	t_u32 index = 0;
 #endif
 	ENTER();
-	if (tcp_session->is_timer_set) {
+	if (atomic_cmpxchg(&tcp_session->is_timer_set, MTRUE, MFALSE)) {
 		woal_cancel_timer(&tcp_session->ack_timer);
-		tcp_session->is_timer_set = MFALSE;
 	}
 	tcp_session->ack_skb = NULL;
 	tcp_session->pmbuf = NULL;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	index = skb_get_queue_mapping(skb);
+#endif
 	status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
 	switch (status) {
 	case MLAN_STATUS_PENDING:
 		atomic_inc(&priv->phandle->tx_pending);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-		index = skb_get_queue_mapping(skb);
 		atomic_inc(&priv->wmm_tx_pending[index]);
 		if (atomic_read(&priv->wmm_tx_pending[index]) >=
 		    MAX_TX_PENDING) {
 			struct netdev_queue *txq =
 				netdev_get_tx_queue(priv->netdev, index);
 			netif_tx_stop_queue(txq);
+			moal_tp_accounting_rx_param((t_void *)priv->phandle, 8,
+						    0);
 			PRINTM(MINFO, "Stop Kernel Queue : %d\n", index);
 		}
 #else
@@ -5296,9 +7318,11 @@ void woal_send_tcp_ack(moal_private *priv, struct tcp_sess *tcp_session)
  *  @param priv      A pointer to moal_private structure
  *  @param pmbuf     A pointer to mlan_buffer associated with a skb
  *
- *  @return          1, if it's dropped; 0, if not dropped
+ *  @return          1, if it's dropped; 2, if it's hold 0, if not dropped and
+ * not hold
+ *
  */
-int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
+static int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -5327,6 +7351,7 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 	if (*((t_u8 *)tcph + 13) == 0x10) {
 		/* Only replace ACK */
 		if (ntohs(iph->tot_len) > (iph->ihl + tcph->doff) * 4) {
+			priv->tcp_ack_payload++;
 			/* Don't drop ACK with payload */
 			/* TODO: should we delete previous TCP session */
 			LEAVE();
@@ -5334,9 +7359,14 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 		}
 		priv->tcp_ack_cnt++;
 		spin_lock_irqsave(&priv->tcp_sess_lock, flags);
-		tcp_session = woal_get_tcp_sess(priv, iph->saddr, tcph->source,
-						iph->daddr, tcph->dest);
+		tcp_session = woal_get_tcp_sess(priv, (__force t_u32)iph->saddr,
+						(__force t_u16)tcph->source,
+						(__force t_u32)iph->daddr,
+						(__force t_u16)tcph->dest);
 		if (!tcp_session) {
+			/* check any aging out sessions can be removed */
+			woal_ageout_tcp_sess_queue(priv);
+
 			tcp_session =
 				kmalloc(sizeof(struct tcp_sess), GFP_ATOMIC);
 			if (!tcp_session) {
@@ -5345,13 +7375,17 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 						       flags);
 				goto done;
 			}
+			woal_get_monotonic_time(&tcp_session->update_time);
+			PRINTM(MDATA, "wlan: create TCP seesion %p\n",
+			       tcp_session);
+
 			tcp_session->ack_skb = pmbuf->pdesc;
 			tcp_session->pmbuf = pmbuf;
 			pmbuf->flags |= MLAN_BUF_FLAG_TCP_ACK;
-			tcp_session->src_ip_addr = iph->saddr;
-			tcp_session->dst_ip_addr = iph->daddr;
-			tcp_session->src_tcp_port = tcph->source;
-			tcp_session->dst_tcp_port = tcph->dest;
+			tcp_session->src_ip_addr = (__force t_u32)iph->saddr;
+			tcp_session->dst_ip_addr = (__force t_u32)iph->daddr;
+			tcp_session->src_tcp_port = (__force t_u32)tcph->source;
+			tcp_session->dst_tcp_port = (__force t_u32)tcph->dest;
 			tcp_session->ack_seq = ntohl(tcph->ack_seq);
 			tcp_session->priv = (void *)priv;
 			skb = (struct sk_buff *)pmbuf->pdesc;
@@ -5360,7 +7394,7 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 			woal_initialize_timer(&tcp_session->ack_timer,
 					      woal_tcp_ack_timer_func,
 					      tcp_session);
-			tcp_session->is_timer_set = MTRUE;
+			atomic_set(&tcp_session->is_timer_set, MTRUE);
 			woal_mod_timer(&tcp_session->ack_timer, MOAL_TIMER_1MS);
 			list_add_tail(&tcp_session->link,
 				      &priv->tcp_sess_queue);
@@ -5369,6 +7403,7 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 			LEAVE();
 			return ret;
 		} else if (!tcp_session->ack_skb) {
+			woal_get_monotonic_time(&tcp_session->update_time);
 			tcp_session->ack_skb = pmbuf->pdesc;
 			tcp_session->pmbuf = pmbuf;
 			pmbuf->flags |= MLAN_BUF_FLAG_TCP_ACK;
@@ -5376,13 +7411,14 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 			tcp_session->priv = (void *)priv;
 			skb = (struct sk_buff *)pmbuf->pdesc;
 			skb->cb[0] = 0;
-			tcp_session->is_timer_set = MTRUE;
+			atomic_set(&tcp_session->is_timer_set, MTRUE);
 			woal_mod_timer(&tcp_session->ack_timer, MOAL_TIMER_1MS);
 			spin_unlock_irqrestore(&priv->tcp_sess_lock, flags);
 			ret = HOLD_TCP_ACK;
 			LEAVE();
 			return ret;
 		}
+		woal_get_monotonic_time(&tcp_session->update_time);
 		ack_seq = ntohl(tcph->ack_seq);
 		skb = (struct sk_buff *)tcp_session->ack_skb;
 		if (likely(ack_seq > tcp_session->ack_seq) &&
@@ -5393,9 +7429,7 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 			tcp_session->ack_seq = ack_seq;
 			ret = DROP_TCP_ACK;
 			skb->cb[0]++;
-// We will drop 90% tcp ack
-#define TCP_ACK_MAX_HOLD 9
-			if (skb->cb[0] >= TCP_ACK_MAX_HOLD)
+			if (skb->cb[0] >= priv->tcp_ack_max_hold)
 				woal_send_tcp_ack(priv, tcp_session);
 			spin_unlock_irqrestore(&priv->tcp_sess_lock, flags);
 			skb = (struct sk_buff *)pmbuf->pdesc;
@@ -5408,22 +7442,188 @@ int woal_process_tcp_ack(moal_private *priv, mlan_buffer *pmbuf)
 			return ret;
 		}
 	}
+
 done:
 	LEAVE();
 	return ret;
 }
 
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+/**
+ *  @brief This function sends Tx pkt to monitor iface
+ *
+ *  @param priv      A pointer to moal_private structure
+ *
+ *  @param pmbuf     A mlan buffer
+ *  @return          N/A
+ */
+void woal_send_tx_pkt_to_mon_if(moal_private *priv, pmlan_buffer pmbuf)
+{
+	struct ieee80211_hdr *dot11_hdr = NULL;
+	struct radiotap_info *rt = NULL;
+	pmlan_buffer pmbuf2 = NULL;
+	t_u8 *ptr = NULL;
+	int len, hdr_len;
+	t_u16 fc;
+	t_u8 rfc1042_eth_hdr[ETH_ALEN] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
+	moal_handle *handle = priv->phandle;
+
+	if (!priv || !pmbuf)
+		return;
+
+	/* Only STA and uAP mode are supported */
+	if (!(priv->bss_type == MLAN_BSS_TYPE_STA ||
+	      priv->bss_type == MLAN_BSS_TYPE_UAP))
+		return;
+
+	ENTER();
+	pmbuf2 = woal_alloc_mlan_buffer(handle, pmbuf->data_len + 64);
+	if (!pmbuf2) {
+		PRINTM(MERROR,
+		       "Failed to allocate mlan_buffer for Tx sniffer packet");
+		goto done;
+	}
+	pmbuf2->bss_index = pmbuf->bss_index;
+	pmbuf2->buf_type = pmbuf->buf_type;
+	pmbuf2->priority = pmbuf->priority;
+	pmbuf2->in_ts_sec = pmbuf->in_ts_sec;
+	pmbuf2->in_ts_usec = pmbuf->in_ts_usec;
+	pmbuf2->flags |= MLAN_BUF_FLAG_NET_MONITOR;
+
+	/* attach 802.11 hdr */
+	dot11_hdr = (struct ieee80211_hdr *)((t_u8 *)pmbuf2->pbuf +
+					     pmbuf2->data_offset);
+	memset((t_u8 *)dot11_hdr, 0, sizeof(struct ieee80211_hdr));
+
+	fc = cpu_to_le16(IEEE80211_FTYPE_DATA | IEEE80211_STYPE_QOS_DATA);
+
+	ptr = (t_u8 *)pmbuf->pbuf + pmbuf->data_offset;
+	hdr_len = sizeof(struct ieee80211_hdr);
+
+	switch (priv->bss_type) {
+	case MLAN_BSS_TYPE_STA:
+		fc |= cpu_to_le16(IEEE80211_FCTL_TODS);
+		/* BSSID SA DA */
+		memcpy(dot11_hdr->addr1, priv->cfg_bssid, ETH_ALEN);
+		memcpy(dot11_hdr->addr2, ptr + ETH_ALEN, ETH_ALEN);
+		memcpy(dot11_hdr->addr3, ptr, ETH_ALEN);
+		hdr_len -= ETH_ALEN;
+		break;
+	case MLAN_BSS_TYPE_UAP:
+		fc |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+		/* DA BSSID SA */
+		memcpy(dot11_hdr->addr1, ptr, ETH_ALEN);
+		memcpy(dot11_hdr->addr2, priv->current_addr, ETH_ALEN);
+		memcpy(dot11_hdr->addr3, ptr + ETH_ALEN, ETH_ALEN);
+		/* subtract mac addr field size for 3 address 802.11 header */
+		hdr_len -= ETH_ALEN;
+		break;
+	default:
+		woal_free_mlan_buffer(priv->phandle, pmbuf2);
+		goto done;
+	}
+
+	dot11_hdr->frame_control = fc;
+	/* add 2 bytes for qos ctrl flags */
+	hdr_len += 2;
+
+	/* Add LLC/SNAP rfc1042 header after 802.11 hdr */
+	memcpy((t_u8 *)dot11_hdr + hdr_len, &rfc1042_eth_hdr, ETH_ALEN);
+
+	/* Copy out rest of the data frame */
+	len = pmbuf->data_len - 2 * ETH_ALEN;
+	ptr += 2 * ETH_ALEN;
+	memcpy(pmbuf2->pbuf + pmbuf2->data_offset + hdr_len +
+		       sizeof(rfc1042_eth_hdr),
+	       ptr, len);
+
+	pmbuf2->data_len = hdr_len + sizeof(rfc1042_eth_hdr) + len;
+
+	rt = (struct radiotap_info *)((t_u8 *)pmbuf2->pbuf +
+				      pmbuf2->data_offset -
+				      sizeof(radiotap_info));
+	memset(rt, 0x00, sizeof(radiotap_info));
+	/* TODO: Fill radiotap header here */
+	/* Send this duplicated packet to Rx monitor pkt handler */
+	if (moal_recv_packet(handle, pmbuf2) != MLAN_STATUS_PENDING)
+		woal_free_mlan_buffer(priv->phandle, pmbuf2);
+done:
+	LEAVE();
+}
+#endif
+#endif
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+/**
+ *  @brief This function check if the packet is easymesh packet
+ *
+ *  @param priv      A pointer to moal_private structure
+ *  @param skb       A pointer to sk_buff structure
+ *
+ *  @return          MTRUE/MFALSE
+ */
+static BOOLEAN woal_check_easymesh_packet(moal_private *priv,
+					  mlan_buffer *pmbuf)
+{
+	struct sk_buff *skb = pmbuf->pdesc;
+	ENTER();
+
+	/** not construct 4 address if SA is same as local address */
+	if (!moal_memcmp(NULL, (skb->data + 6), priv->current_addr, ETH_ALEN)) {
+		PRINTM(MINFO,
+		       "%s: SA is same as local address " FULL_MACSTR "\n",
+		       __func__, FULL_MAC2STR(priv->current_addr));
+		LEAVE();
+		return MFALSE;
+	}
+
+	/* RA TA */
+	switch (priv->wdev->iftype) {
+#ifdef UAP_SUPPORT
+	case NL80211_IFTYPE_AP_VLAN:
+		PRINTM(MDAT_D, "%s: Easymesh AP_VLAN\n", priv->netdev->name);
+		moal_memcpy_ext(priv->phandle, pmbuf->mac,
+				priv->vlan_sta_ptr->peer_mac,
+				MLAN_MAC_ADDR_LENGTH, ETH_ALEN);
+		pmbuf->flags |= MLAN_BUF_FLAG_EASYMESH;
+		break;
+#endif
+	case NL80211_IFTYPE_STATION:
+		PRINTM(MDAT_D, "%s Easymesh STATION\n", priv->netdev->name);
+		moal_memcpy_ext(priv->phandle, pmbuf->mac, priv->cfg_bssid,
+				ETH_ALEN, ETH_ALEN);
+		pmbuf->flags |= MLAN_BUF_FLAG_EASYMESH;
+		break;
+	default:
+		PRINTM(MERROR, "Not supported iftype\n");
+		LEAVE();
+		return MFALSE;
+	}
+	PRINTM(MDAT_D,
+	       "Easymesh Tx %s:\nRA: " FULL_MACSTR "\nTA: " FULL_MACSTR
+	       "\nDA: " FULL_MACSTR "\nSA: " FULL_MACSTR "\n",
+	       __func__, FULL_MAC2STR(pmbuf->mac),
+	       FULL_MAC2STR(priv->current_addr), FULL_MAC2STR(skb->data),
+	       FULL_MAC2STR(skb->data + ETH_ALEN));
+
+	LEAVE();
+	return MTRUE;
+}
+#endif
+#endif
+
 /**
  *  @brief This function handles packet transmission
  *
  *  @param skb     A pointer to sk_buff structure
  *  @param dev     A pointer to net_device structure
  *
- *  @return        0 --success
+ *  @return        N/A
  */
-netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static void woal_start_xmit(moal_private *priv, struct sk_buff *skb)
 {
-	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_buffer *pmbuf = NULL;
 	mlan_status status;
 	struct sk_buff *new_skb = NULL;
@@ -5432,33 +7632,39 @@ netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 #endif
 	int ret = 0;
 
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	BOOLEAN multi_ap_packet = MFALSE;
+#endif
+#endif
+
 	ENTER();
-	PRINTM(MDATA, "%lu : %s (bss=%d): Data <= kernel\n", jiffies, dev->name,
-	       priv->bss_index);
 
-	if (priv->phandle->surprise_removed == MTRUE) {
-		dev_kfree_skb_any(skb);
-		priv->stats.tx_dropped++;
-		goto done;
-	}
 	priv->num_tx_timeout = 0;
-	if (!skb->len || (skb->len > ETH_FRAME_LEN)) {
+	if (!skb->len ||
+	    (skb->len > (priv->netdev->mtu + sizeof(struct ethhdr)))) {
 		PRINTM(MERROR, "Tx Error: Bad skb length %d : %d\n", skb->len,
-		       ETH_FRAME_LEN);
+		       priv->netdev->mtu);
 		dev_kfree_skb_any(skb);
 		priv->stats.tx_dropped++;
 		goto done;
 	}
-	if (skb->cloned || (skb_headroom(skb) <
-			    (MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
-			     priv->extra_tx_head_len))) {
-		PRINTM(MWARN,
-		       "Tx: skb cloned %d or Insufficient skb headroom %d\n",
-		       skb->cloned, skb_headroom(skb));
+	// kernel crash with cloned skb without copy
+	// 2 AGO case
+	// uap0  <-->muap0 bridge
+	if (moal_extflg_isset(priv->phandle, EXT_TX_SKB_CLONE) || skb->cloned ||
+	    (skb_headroom(skb) <
+	     (MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
+	      priv->extra_tx_head_len))) {
+		PRINTM(MINFO,
+		       "Tx: skb cloned %d skb headroom %d tx_skb_clone=%d \n",
+		       skb->cloned, skb_headroom(skb),
+		       moal_extflg_isset(priv->phandle, EXT_TX_SKB_CLONE));
 		/* Insufficient skb headroom - allocate a new skb */
 		new_skb = skb_realloc_headroom(
 			skb, MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
 				     priv->extra_tx_head_len);
+		moal_tp_accounting_rx_param((t_void *)priv->phandle, 7, 0);
 		if (unlikely(!new_skb)) {
 			PRINTM(MERROR, "Tx: Cannot allocate skb\n");
 			dev_kfree_skb_any(skb);
@@ -5468,34 +7674,74 @@ netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		if (new_skb != skb)
 			dev_kfree_skb_any(skb);
 		skb = new_skb;
+
 		PRINTM(MINFO, "new skb headroom %d\n", skb_headroom(skb));
 	}
 	pmbuf = (mlan_buffer *)skb->head;
 	memset((t_u8 *)pmbuf, 0, sizeof(mlan_buffer));
 	pmbuf->bss_index = priv->bss_index;
 	woal_fill_mlan_buffer(priv, pmbuf, skb);
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	if (priv->wdev->use_4addr) {
+		if ((priv->wdev->iftype == NL80211_IFTYPE_AP_VLAN &&
+		     !priv->vlan_sta_ptr) ||
+		    (priv->wdev->iftype == NL80211_IFTYPE_STATION &&
+		     !priv->media_connected)) {
+			priv->stats.tx_dropped++;
+			dev_kfree_skb_any(skb);
+			LEAVE();
+			return;
+		}
+		multi_ap_packet = woal_check_easymesh_packet(priv, pmbuf);
+	}
+#endif
+#endif
+
 	if (priv->enable_tcp_ack_enh == MTRUE) {
 		ret = woal_process_tcp_ack(priv, pmbuf);
 		if (ret)
 			goto done;
 	}
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (priv->phandle->mon_if &&
+	    (priv->phandle->mon_if->flag & MLAN_NETMON_DATA) &&
+	    (priv->phandle->mon_if->flag & MLAN_NETMON_TX))
+		woal_send_tx_pkt_to_mon_if(priv, pmbuf);
+#endif
+#endif
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	if (priv->enable_auto_tdls && priv->tdls_check_tx)
+		woal_tdls_check_tx(priv, skb);
+#endif
+#endif
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 	index = skb_get_queue_mapping(skb);
+	index = MIN(index, 3);
 #endif
 
+	if (is_zero_timeval(priv->phandle->tx_time_start)) {
+		priv->phandle->tx_time_start.time_sec = pmbuf->in_ts_sec;
+		priv->phandle->tx_time_start.time_usec = pmbuf->in_ts_usec;
+		PRINTM(MINFO, "%s : start_timeval=%d:%d \n", __func__,
+		       priv->phandle->tx_time_start.time_sec,
+		       priv->phandle->tx_time_start.time_usec);
+	}
 	status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
 	switch (status) {
 	case MLAN_STATUS_PENDING:
-		if (is_zero_timeval(priv->phandle->tx_time_start)) {
-			priv->phandle->tx_time_start.time_sec =
-				pmbuf->in_ts_sec;
-			priv->phandle->tx_time_start.time_usec =
-				pmbuf->in_ts_usec;
-			PRINTM(MINFO, "%s : start_timeval=%d:%d \n", __func__,
-			       priv->phandle->tx_time_start.time_sec,
-			       priv->phandle->tx_time_start.time_usec);
-		}
 		atomic_inc(&priv->phandle->tx_pending);
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+		if (priv->wdev->iftype == NL80211_IFTYPE_AP_VLAN)
+			priv = priv->parent_priv;
+#endif
+#endif
+
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 		atomic_inc(&priv->wmm_tx_pending[index]);
 		if (atomic_read(&priv->wmm_tx_pending[index]) >=
@@ -5503,12 +7749,15 @@ netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			struct netdev_queue *txq =
 				netdev_get_tx_queue(priv->netdev, index);
 			netif_tx_stop_queue(txq);
+			moal_tp_accounting_rx_param((t_void *)priv->phandle, 8,
+						    0);
 			PRINTM(MINFO, "Stop Kernel Queue : %d\n", index);
 		}
 #else
 		if (atomic_read(&priv->phandle->tx_pending) >= MAX_TX_PENDING)
 			woal_stop_queue(priv->netdev);
 #endif /*#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)*/
+
 		if (!mlan_is_main_process_running(priv->phandle->pmlan_adapter))
 			queue_work(priv->phandle->workqueue,
 				   &priv->phandle->main_work);
@@ -5524,6 +7773,50 @@ netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		dev_kfree_skb_any(skb);
 		break;
 	}
+done:
+	LEAVE();
+	return;
+}
+
+/**
+ *  @brief This function handles packet transmission
+ *
+ *  @param skb     A pointer to sk_buff structure
+ *  @param dev     A pointer to net_device structure
+ *
+ *  @return        0 --success
+ */
+netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	moal_private *priv = (moal_private *)netdev_priv(dev);
+	ENTER();
+	PRINTM(MDATA, "%lu : %s (bss=%d): Data <= kernel\n", jiffies, dev->name,
+	       priv->bss_index);
+
+	/* Collect TP statistics */
+	if (priv->phandle->tp_acnt.on)
+		moal_tp_accounting(priv->phandle, skb, 1);
+	/* Drop Tx packets at drop point 1 */
+	if (priv->phandle->tp_acnt.drop_point == 1) {
+		dev_kfree_skb_any(skb);
+		LEAVE();
+		return 0;
+	}
+	if (priv->phandle->surprise_removed == MTRUE) {
+		dev_kfree_skb_any(skb);
+		priv->stats.tx_dropped++;
+		goto done;
+	}
+	if (moal_extflg_isset(priv->phandle, EXT_TX_WORK)) {
+		spin_lock_bh(&(priv->tx_q.lock));
+		__skb_queue_tail(&(priv->tx_q), skb);
+		spin_unlock_bh(&(priv->tx_q.lock));
+
+		queue_work(priv->phandle->tx_workqueue,
+			   &priv->phandle->tx_work);
+		goto done;
+	}
+	woal_start_xmit(priv, skb);
 done:
 	LEAVE();
 	return 0;
@@ -5596,6 +7889,9 @@ mlan_status woal_atoi(int *data, char *a)
 		} else {
 			if ((i == 0) && (a[i] == '-')) {
 				mul = -1;
+			} else if (a[i] == 0xa) {
+				// line feed
+				break;
 			} else {
 				PRINTM(MERROR, "Invalid char %c in string %s\n",
 				       a[i], a);
@@ -5733,7 +8029,7 @@ void woal_set_multicast_list(struct net_device *dev)
 {
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	ENTER();
-	woal_request_set_multicast_list(priv, dev);
+	queue_work(priv->mclist_workqueue, &priv->mclist_work);
 	LEAVE();
 }
 #endif
@@ -5749,6 +8045,12 @@ void woal_set_multicast_list(struct net_device *dev)
  */
 void woal_init_priv(moal_private *priv, t_u8 wait_option)
 {
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	int i;
+#endif
+#endif
+
 	ENTER();
 #ifdef STA_SUPPORT
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
@@ -5758,6 +8060,12 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
 		priv->scan_type = MLAN_SCAN_TYPE_ACTIVE;
 		priv->bg_scan_start = MFALSE;
 		priv->bg_scan_reported = MFALSE;
+		priv->sched_scanning = MFALSE;
+#ifdef STA_CFG80211
+		priv->roaming_enabled = MFALSE;
+		priv->roaming_required = MFALSE;
+#endif
+
 		memset(&priv->nick_name, 0, sizeof(priv->nick_name));
 		priv->num_tx_timeout = 0;
 		priv->rx_filter = 0;
@@ -5766,18 +8074,31 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
 		priv->reassoc_on = MFALSE;
 		priv->set_asynced_essid_flag = MFALSE;
 #endif
+		priv->auto_assoc_priv.auto_assoc_type_on = 2;
+		priv->auto_assoc_priv.auto_assoc_trigger_flag =
+			AUTO_ASSOC_TYPE_DRV_RECONN;
+		memset(&priv->auto_assoc_priv.drv_assoc, 0,
+		       sizeof(drv_auto_assoc));
+		memset(&priv->auto_assoc_priv.drv_reconnect, 0,
+		       sizeof(drv_auto_assoc));
+		priv->auto_assoc_priv.drv_reconnect.retry_count = 0xff;
 #ifdef STA_CFG80211
 		memset(&priv->sme_current, 0,
 		       sizeof(struct cfg80211_connect_params));
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 		woal_init_wifi_hal(priv);
+#endif
 #endif
 	}
 #endif /* STA_SUPPORT */
 #ifdef UAP_SUPPORT
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
 		priv->bss_started = MFALSE;
+		priv->uap_host_based = MFALSE;
+		priv->skip_cac = MFALSE;
+
 #ifdef UAP_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 		memset(&priv->chan, 0, sizeof(struct cfg80211_chan_def));
@@ -5786,13 +8107,24 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
 		memset(&priv->beacon_after, 0,
 		       sizeof(struct cfg80211_beacon_data));
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 		woal_init_wifi_hal(priv);
 #endif
+#endif
+#endif
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+		priv->vlan_sta_ptr = NULL;
+		for (i = 0; i < MAX_STA_COUNT; i++)
+			priv->vlan_sta_list[i] = NULL;
+#endif
 #endif
 	}
 #endif
 
+	skb_queue_head_init(&priv->tx_q);
 	memset(&priv->tx_protocols, 0, sizeof(dot11_protocol));
 	memset(&priv->rx_protocols, 0, sizeof(dot11_protocol));
 	priv->media_connected = MFALSE;
@@ -5808,19 +8140,37 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
 	priv->proberesp_p2p_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
 	priv->assocresp_qos_map_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
 	priv->beacon_vendor_index = MLAN_CUSTOM_IE_AUTO_IDX_MASK;
+	priv->mgmt_subtype_mask = 0;
+	priv->cfg_disconnect = MFALSE;
+	priv->cfg_connect = MFALSE;
 #endif
 #ifdef STA_SUPPORT
+#ifdef STA_CFG80211
+	priv->pmk_saved = MFALSE;
+	memset(&priv->pmk, 0, sizeof(mlan_pmk_t));
+#endif
 #endif
 
 	priv->enable_tcp_ack_enh = MTRUE;
+	priv->tcp_ack_drop_cnt = 0;
+	priv->tcp_ack_cnt = 0;
+	priv->tcp_ack_payload = 0;
+	priv->tcp_ack_max_hold = TCP_ACK_MAX_HOLD;
+
+	priv->enable_auto_tdls = MFALSE;
+	priv->tdls_check_tx = MFALSE;
 
 	priv->gtk_data_ready = MFALSE;
 	memset(&priv->gtk_rekey_data, 0, sizeof(mlan_ds_misc_gtk_rekey_data));
 
-	woal_request_get_fw_info(priv, wait_option, NULL);
-
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_request_get_fw_info(priv, wait_option, NULL)) {
+		PRINTM(MERROR, "%s: get_fw_info failed \n", __func__);
+		return;
+	}
 	/* Set MAC address from the insmod command line */
-	if (priv->phandle->set_mac_addr) {
+	if (priv->phandle->set_mac_addr &&
+	    priv->bss_type != MLAN_BSS_TYPE_DFS) {
 		memset(priv->current_addr, 0, ETH_ALEN);
 		moal_memcpy_ext(priv->phandle, priv->current_addr,
 				priv->phandle->mac_addr, ETH_ALEN, ETH_ALEN);
@@ -5865,17 +8215,45 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
 	if (priv->bss_type != MLAN_BSS_TYPE_WIFIDIRECT)
 #endif
 	{
-		priv->current_addr[4] += priv->bss_index;
+		if (priv->bss_index) {
+			priv->current_addr[0] |= 0x02;
+			priv->current_addr[4] += priv->bss_index;
+		}
 		PRINTM(MCMND, "Set %s interface addr: " MACSTR "\n",
 		       priv->netdev->name, MAC2STR(priv->current_addr));
 	}
 
-	woal_request_set_mac_address(priv, MOAL_IOCTL_WAIT);
+	/* ZeroDFS interface doesn't need to set mac address to fw */
+	if (priv->bss_type != MLAN_BSS_TYPE_DFS) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_request_set_mac_address(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR, "%s: set mac address failed \n",
+			       __func__);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	eth_hw_addr_set(priv->netdev, priv->current_addr);
+#else
 	moal_memcpy_ext(priv->phandle, priv->netdev->dev_addr,
 			priv->current_addr, ETH_ALEN, ETH_ALEN);
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	priv->host_mlme = 0;
+	priv->auth_flag = 0;
+	priv->auth_alg = 0xFFFF;
+#endif
 
 #ifdef UAP_SUPPORT
+	priv->target_chan = 0;
+	priv->backup_chan = 0;
+	priv->chan_mode = DEFAULT_CHAN_MODE_MASK;
+	priv->chan_num_pkts = DEFAULT_RETRY_PKTS;
 	priv->user_cac_period_msec = 0;
+	priv->chan_under_nop = MFALSE;
+#endif
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	priv->multi_ap_flag = 0;
+#endif
 #endif
 	LEAVE();
 }
@@ -5891,7 +8269,7 @@ void woal_init_priv(moal_private *priv, t_u8 wait_option)
  *
  *  @return             MLAN_STATUS_SUCCESS --success, otherwise fail
  */
-int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
+mlan_status woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 {
 	int ret = MLAN_STATUS_SUCCESS;
 	int intf_num;
@@ -5906,10 +8284,35 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 	}
 	handle = priv->phandle;
 
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+	/* Unregister and detach connected radiotap net device */
+	if (handle->mon_if) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_net_monitor(handle->mon_if->priv, wait_option,
+					 MFALSE, 0, NULL)) {
+			PRINTM(MERROR, "%s: stop net monitor failed \n",
+			       __func__);
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+#endif
+		netif_device_detach(handle->mon_if->mon_ndev);
+		if (handle->mon_if->mon_ndev->reg_state == NETREG_REGISTERED)
+			unregister_netdev(handle->mon_if->mon_ndev);
+		handle->mon_if = NULL;
+	}
+#endif
 	if (handle->rf_test_mode)
 		woal_process_rf_test_mode(handle, MFG_CMD_UNSET_TEST_MODE);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#endif
 #ifdef STA_SUPPORT
-	woal_cancel_scan(priv, wait_option);
+	if (MLAN_STATUS_SUCCESS != woal_cancel_scan(priv, wait_option)) {
+		PRINTM(MERROR, "%s: cancel scan failed \n", __func__);
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
 #endif
 
 	/* Stop queue and detach device */
@@ -5925,7 +8328,12 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 
 	/* Get BSS info */
 	memset(&bss_info, 0, sizeof(bss_info));
-	woal_get_bss_info(priv, wait_option, &bss_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, wait_option, &bss_info)) {
+		PRINTM(MERROR, "%s: get bss info failed \n", __func__);
+		ret = MLAN_STATUS_FAILURE;
+		goto done;
+	}
 
 	/* Cancel host sleep */
 	if (bss_info.is_hs_configured) {
@@ -5943,8 +8351,14 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 		    || (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)
 #endif
 		) {
-			woal_disconnect(priv, wait_option, NULL,
-					DEF_DEAUTH_REASON_CODE);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_disconnect(priv, wait_option, NULL,
+					    DEF_DEAUTH_REASON_CODE)) {
+				PRINTM(MERROR, "%s: woal_disconnect failed \n",
+				       __func__);
+				ret = MLAN_STATUS_FAILURE;
+				goto done;
+			}
 			priv->media_connected = MFALSE;
 		}
 	} else {
@@ -5956,9 +8370,16 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 				MLAN_BSS_ROLE_UAP)
 #endif
 			) {
-				woal_disconnect(handle->priv[intf_num],
-						wait_option, NULL,
-						DEF_DEAUTH_REASON_CODE);
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_disconnect(handle->priv[intf_num],
+						    wait_option, NULL,
+						    DEF_DEAUTH_REASON_CODE)) {
+					PRINTM(MERROR,
+					       "%s: woal_disconnect failed \n",
+					       __func__);
+					ret = MLAN_STATUS_FAILURE;
+					goto done;
+				}
 				handle->priv[intf_num]->media_connected =
 					MFALSE;
 			}
@@ -5970,11 +8391,17 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 	if (!all_intf) {
 		handle->reassoc_on &= ~MBIT(priv->bss_index);
 		priv->reassoc_on = MFALSE;
+		priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+		priv->auto_assoc_priv.drv_reconnect.status = MFALSE;
 		priv->set_asynced_essid_flag = MFALSE;
 	} else {
 		handle->reassoc_on = 0;
 		for (intf_num = 0; intf_num < handle->priv_num; intf_num++) {
 			handle->priv[intf_num]->reassoc_on = MFALSE;
+			handle->priv[intf_num]
+				->auto_assoc_priv.drv_assoc.status = MFALSE;
+			handle->priv[intf_num]
+				->auto_assoc_priv.drv_reconnect.status = MFALSE;
 			handle->priv[intf_num]->set_asynced_essid_flag = MFALSE;
 		}
 	}
@@ -5984,6 +8411,11 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
 	}
 #endif /* REASSOCIATION */
 
+	if (handle->is_fw_dump_timer_set) {
+		woal_cancel_timer(&handle->fw_dump_timer);
+		handle->is_fw_dump_timer_set = MFALSE;
+	}
+
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 	if (handle->is_go_timer_set) {
@@ -6015,7 +8447,7 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf)
  *
  *  @return             moal_private pointer or NULL
  */
-moal_private *woal_bss_index_to_priv(moal_handle *handle, t_u8 bss_index)
+moal_private *woal_bss_index_to_priv(moal_handle *handle, t_u32 bss_index)
 {
 	int i;
 
@@ -6133,7 +8565,7 @@ void woal_free_mlan_buffer(moal_handle *handle, pmlan_buffer pmbuf)
  *
  *  @param phandle   A pointer to moal_handle
  *
- *  @return         N/A
+ *  @return         0-success , otherwise failure.
  */
 static int woal_get_card_info(moal_handle *phandle)
 {
@@ -6142,6 +8574,11 @@ static int woal_get_card_info(moal_handle *phandle)
 	ENTER();
 
 	switch (phandle->card_type) {
+#ifdef SD8801
+	case CARD_TYPE_SD8801:
+		phandle->card_info = &card_info_SD8801;
+		break;
+#endif
 #ifdef SD8887
 	case CARD_TYPE_SD8887:
 		phandle->card_info = &card_info_SD8887;
@@ -6186,6 +8623,20 @@ static int woal_get_card_info(moal_handle *phandle)
 	case CARD_TYPE_SD9097:
 		phandle->card_info = &card_info_SD9097;
 		break;
+#endif
+	case CARD_TYPE_SDAW693:
+		phandle->card_info = &card_info_SDAW693;
+		break;
+#ifdef SDIW62X
+	case CARD_TYPE_SDIW62X:
+		phandle->card_info = &card_info_SDIW62X;
+		break;
+#endif
+#ifdef SD9177
+	case CARD_TYPE_SD9177:
+		phandle->card_info = &card_info_SD9177;
+		phandle->event_fw_dump = MFALSE;
+		break;
 #endif
 #ifdef PCIE8997
 	case CARD_TYPE_PCIE8997:
@@ -6196,6 +8647,14 @@ static int woal_get_card_info(moal_handle *phandle)
 	case CARD_TYPE_PCIE9097:
 		phandle->card_info = &card_info_PCIE9097;
 		break;
+#endif
+	case CARD_TYPE_PCIEAW693:
+		phandle->card_info = &card_info_PCIEAW693;
+		break;
+#ifdef PCIEIW62X
+	case CARD_TYPE_PCIEIW62X:
+		phandle->card_info = &card_info_PCIEIW62X;
+		break;
 #endif
 #ifdef PCIE9098
 	case CARD_TYPE_PCIE9098:
@@ -6203,6 +8662,11 @@ static int woal_get_card_info(moal_handle *phandle)
 		phandle->event_fw_dump = MTRUE;
 		break;
 #endif
+#ifdef USB8801
+	case CARD_TYPE_USB8801:
+		phandle->card_info = &card_info_USB8801;
+		break;
+#endif
 #ifdef USB8997
 	case CARD_TYPE_USB8997:
 		phandle->card_info = &card_info_USB8997;
@@ -6223,6 +8687,11 @@ static int woal_get_card_info(moal_handle *phandle)
 		phandle->card_info = &card_info_USB9097;
 		break;
 #endif
+#ifdef USBIW62X
+	case CARD_TYPE_USBIW62X:
+		phandle->card_info = &card_info_USBIW62X;
+		break;
+#endif
 #ifdef SD8987
 	case CARD_TYPE_SD8987:
 		phandle->card_info = &card_info_SD8987;
@@ -6262,40 +8731,20 @@ mlan_status woal_broadcast_event(moal_private *priv, t_u8 *payload, t_u32 len)
 	ENTER();
 
 	/* interface name to be prepended to event */
-	if ((len + IFNAMSIZ) > NL_MAX_PAYLOAD
-#ifdef WIFI_DIRECT_SUPPORT
-				       * 2
-#endif
-	) {
+	/* NL_MAX_PAYLOAD = 3 * 1024 */
+	if ((len + IFNAMSIZ) > NL_MAX_PAYLOAD) {
 		PRINTM(MERROR, "event size is too big, len=%d\n", (int)len);
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 	if (sk) {
 		/* Allocate skb */
-#ifdef WIFI_DIRECT_SUPPORT
-		if ((len + IFNAMSIZ) > NL_MAX_PAYLOAD) {
-			skb = alloc_skb(NLMSG_SPACE(NL_MAX_PAYLOAD * 2),
-					GFP_ATOMIC);
-			if (!skb) {
-				PRINTM(MERROR,
-				       "Could not allocate skb for netlink\n");
-				ret = MLAN_STATUS_FAILURE;
-				goto done;
-			}
-		} else {
-#endif
-			skb = alloc_skb(NLMSG_SPACE(NL_MAX_PAYLOAD),
-					GFP_ATOMIC);
-			if (!skb) {
-				PRINTM(MERROR,
-				       "Could not allocate skb for netlink\n");
-				ret = MLAN_STATUS_FAILURE;
-				goto done;
-			}
-#ifdef WIFI_DIRECT_SUPPORT
+		skb = alloc_skb(NLMSG_SPACE(NL_MAX_PAYLOAD), GFP_ATOMIC);
+		if (!skb) {
+			PRINTM(MERROR, "Could not allocate skb for netlink\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
 		}
-#endif
 		memset(skb->data, 0, NLMSG_SPACE(NL_MAX_PAYLOAD));
 
 		nlh = (struct nlmsghdr *)skb->data;
@@ -6373,12 +8822,19 @@ int woal_reassociation_thread(void *data)
 	int i;
 	BOOLEAN reassoc_timer_req;
 	mlan_802_11_ssid req_ssid;
-	mlan_ssid_bssid ssid_bssid;
+	mlan_ssid_bssid *ssid_bssid = NULL;
 	mlan_status status;
 	mlan_bss_info bss_info;
 	t_u32 timer_val = MOAL_TIMER_10S;
+	t_u32 retry_count = 0;
+	t_u32 retry_interval = 0;
 	t_u8 zero_mac[] = {0, 0, 0, 0, 0, 0};
 	ENTER();
+	ssid_bssid = kmalloc(sizeof(mlan_ssid_bssid), GFP_KERNEL);
+	if (!ssid_bssid) {
+		LEAVE();
+		return 0;
+	}
 
 	woal_activate_thread(pmoal_thread);
 	init_waitqueue_entry(&wait, current);
@@ -6440,7 +8896,87 @@ int woal_reassociation_thread(void *data)
 			    (priv = handle->priv[i]);
 		     i++) {
 			if (priv->reassoc_required == MFALSE) {
-				priv->set_asynced_essid_flag = MFALSE;
+				priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
+				continue;
+			}
+
+			if (priv->auto_assoc_priv.auto_assoc_trigger_flag ==
+				    AUTO_ASSOC_TYPE_DRV_RECONN ||
+			    priv->auto_assoc_priv.auto_assoc_trigger_flag ==
+				    AUTO_ASSOC_TYPE_DRV_ASSOC) {
+				if (priv->auto_assoc_priv
+					    .auto_assoc_trigger_flag ==
+				    AUTO_ASSOC_TYPE_DRV_RECONN) {
+					retry_count = priv->auto_assoc_priv
+							      .drv_reconnect
+							      .retry_count;
+					retry_interval =
+						priv->auto_assoc_priv
+							.drv_reconnect
+							.retry_interval *
+						1000;
+					if (retry_count == 0xff)
+						retry_count =
+							AUTO_ASSOC_RETRY_FOREVER;
+					priv->auto_assoc_priv.drv_reconnect
+						.status = MTRUE;
+					PRINTM(MINFO,
+					       "Auto assoc: driver auto re-connect triggered\n");
+				}
+				if (priv->auto_assoc_priv
+					    .auto_assoc_trigger_flag ==
+				    AUTO_ASSOC_TYPE_DRV_ASSOC) {
+					/* disconnect before driver
+					 * assoc */
+					woal_disconnect(priv, MOAL_IOCTL_WAIT,
+							NULL,
+							DEF_DEAUTH_REASON_CODE);
+					if (priv->auto_assoc_priv
+						    .auto_assoc_type_on &
+					    (0x1 << (AUTO_ASSOC_TYPE_DRV_ASSOC -
+						     1))) {
+						retry_count =
+							priv->auto_assoc_priv
+								.drv_assoc
+								.retry_count;
+						retry_interval =
+							priv->auto_assoc_priv
+								.drv_assoc
+								.retry_interval *
+							1000;
+						if (retry_count == 0xff)
+							retry_count =
+								AUTO_ASSOC_RETRY_FOREVER;
+						else
+							retry_count =
+								retry_count + 1;
+						PRINTM(MINFO,
+						       "Auto assoc: driver auto assoc triggered\n");
+					} else {
+						retry_count = 1;
+						retry_interval = 0;
+						PRINTM(MINFO,
+						       "Auto assoc: set asynced essid with drv auto assoc disable\n");
+					}
+					priv->reassoc_required = MTRUE;
+					priv->auto_assoc_priv.drv_assoc.status =
+						MTRUE;
+				}
+				priv->auto_assoc_priv.auto_assoc_trigger_flag =
+					AUTO_ASSOC_TYPE_NONE;
+			}
+
+			if (retry_count == 0 &&
+			    (priv->auto_assoc_priv.drv_assoc.status == MTRUE ||
+			     priv->auto_assoc_priv.drv_reconnect.status ==
+				     MTRUE)) {
+				PRINTM(MINFO,
+				       "Auto assoc: stop driver auto assoc: the retry count is 0\n");
+				priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
 				continue;
 			}
 
@@ -6451,7 +8987,9 @@ int woal_reassociation_thread(void *data)
 					      &bss_info)) {
 				PRINTM(MINFO, "Ressoc: Fail to get bss info\n");
 				priv->reassoc_required = MFALSE;
-				priv->set_asynced_essid_flag = MFALSE;
+				priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
 				continue;
 			}
 
@@ -6460,7 +8998,9 @@ int woal_reassociation_thread(void *data)
 				PRINTM(MINFO,
 				       "Reassoc: ad-hoc mode or media connected\n");
 				priv->reassoc_required = MFALSE;
-				priv->set_asynced_essid_flag = MFALSE;
+				priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
 				continue;
 			}
 			/** avoid on going scan from other thread */
@@ -6509,9 +9049,9 @@ int woal_reassociation_thread(void *data)
 				break;
 			}
 
-			memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+			memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
 
-			if (priv->set_asynced_essid_flag == MTRUE) {
+			if (priv->auto_assoc_priv.drv_assoc.status == MTRUE) {
 				if (priv->assoc_with_mac &&
 				    memcmp(priv->prev_ssid_bssid.bssid,
 					   zero_mac, MLAN_MAC_ADDR_LENGTH)) {
@@ -6520,40 +9060,42 @@ int woal_reassociation_thread(void *data)
 					       "Reassoc: Search AP by BSSID & SSID\n");
 					moal_memcpy_ext(
 						priv->phandle,
-						&ssid_bssid.bssid,
+						&ssid_bssid->bssid,
 						&priv->prev_ssid_bssid.bssid,
 						MLAN_MAC_ADDR_LENGTH,
 						sizeof(mlan_802_11_mac_addr));
 				} else {
-					/* Search AP by ESSID for asynced essid
-					 * setting */
+					/* Search AP by ESSID for driver
+					 * auto reassoc */
 					PRINTM(MINFO,
-					       "Set asynced essid: Search AP by ESSID\n");
+					       "Reassoc: Search AP by ESSID\n");
 				}
 
-				moal_memcpy_ext(priv->phandle, &ssid_bssid.ssid,
+				moal_memcpy_ext(priv->phandle,
+						&ssid_bssid->ssid,
 						&priv->prev_ssid_bssid.ssid,
 						sizeof(mlan_802_11_ssid),
 						sizeof(mlan_802_11_ssid));
+
 			} else {
 				/* Search AP by BSSID first */
 				PRINTM(MINFO,
 				       "Reassoc: Search AP by BSSID first\n");
 				moal_memcpy_ext(priv->phandle,
-						&ssid_bssid.bssid,
+						&ssid_bssid->bssid,
 						&priv->prev_ssid_bssid.bssid,
 						MLAN_MAC_ADDR_LENGTH,
 						sizeof(mlan_802_11_mac_addr));
 			}
 
 			status = woal_find_best_network(priv, MOAL_IOCTL_WAIT,
-							&ssid_bssid);
+							ssid_bssid);
 #ifdef STA_WEXT
 			if (status == MLAN_STATUS_SUCCESS) {
 				if (MLAN_STATUS_SUCCESS !=
 				    woal_11d_check_ap_channel(priv,
 							      MOAL_IOCTL_WAIT,
-							      &ssid_bssid)) {
+							      ssid_bssid)) {
 					PRINTM(MERROR,
 					       "Reassoc: The AP's channel is invalid for current region\n");
 					status = MLAN_STATUS_FAILURE;
@@ -6563,31 +9105,32 @@ int woal_reassociation_thread(void *data)
 			/** The find AP without ssid, we need re-search
 			 */
 			if (status == MLAN_STATUS_SUCCESS &&
-			    !ssid_bssid.ssid.ssid_len) {
+			    !ssid_bssid->ssid.ssid_len) {
 				PRINTM(MINFO,
 				       "Reassoc: Skip AP without ssid\n");
 				status = MLAN_STATUS_FAILURE;
 			}
 
-			if (priv->set_asynced_essid_flag != MTRUE &&
+			if (priv->auto_assoc_priv.drv_assoc.status != MTRUE &&
 			    MLAN_STATUS_SUCCESS != status) {
 				PRINTM(MINFO,
 				       "Reassoc: AP not found in scan list\n");
 				PRINTM(MINFO, "Reassoc: Search AP by SSID\n");
 				/* Search AP by SSID */
-				memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
-				moal_memcpy_ext(priv->phandle, &ssid_bssid.ssid,
+				memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+				moal_memcpy_ext(priv->phandle,
+						&ssid_bssid->ssid,
 						&priv->prev_ssid_bssid.ssid,
 						sizeof(mlan_802_11_ssid),
 						sizeof(mlan_802_11_ssid));
 				status = woal_find_best_network(
-					priv, MOAL_IOCTL_WAIT, &ssid_bssid);
+					priv, MOAL_IOCTL_WAIT, ssid_bssid);
 #ifdef STA_WEXT
 				if (status == MLAN_STATUS_SUCCESS) {
 					if (MLAN_STATUS_SUCCESS !=
 					    woal_11d_check_ap_channel(
 						    priv, MOAL_IOCTL_WAIT,
-						    &ssid_bssid)) {
+						    ssid_bssid)) {
 						PRINTM(MERROR,
 						       "Reassoc: The AP's channel is invalid for current region\n");
 						status = MLAN_STATUS_FAILURE;
@@ -6598,15 +9141,24 @@ int woal_reassociation_thread(void *data)
 
 			if (status == MLAN_STATUS_SUCCESS) {
 				/* set the wep key */
-				if (bss_info.wep_status)
-					woal_enable_wep_key(priv,
-							    MOAL_IOCTL_WAIT);
+				if (bss_info.wep_status) {
+					if (MLAN_STATUS_SUCCESS !=
+					    woal_enable_wep_key(
+						    priv, MOAL_IOCTL_WAIT)) {
+						PRINTM(MERROR,
+						       "Reassoc: woal_enable_wep_key failed\n");
+						status = MLAN_STATUS_FAILURE;
+					}
+				}
 				/* Zero SSID implies use BSSID to
 				 * connect */
-				memset(&ssid_bssid.ssid, 0,
+				memset(&ssid_bssid->ssid, 0,
 				       sizeof(mlan_802_11_ssid));
 				status = woal_bss_start(priv, MOAL_IOCTL_WAIT,
-							&ssid_bssid);
+							ssid_bssid);
+				if (status != MLAN_STATUS_SUCCESS)
+					PRINTM(MERROR,
+					       "Reassoc: woal_bss_start failed\n");
 			}
 
 			if (priv->media_connected == MFALSE)
@@ -6616,14 +9168,15 @@ int woal_reassociation_thread(void *data)
 				mlan_ioctl_req *req = NULL;
 
 				reassoc_timer_req = MFALSE;
-				if (priv->set_asynced_essid_flag == MTRUE) {
+				if (priv->auto_assoc_priv.drv_assoc.status ==
+				    MTRUE) {
 					memset(&bss_info, 0, sizeof(bss_info));
 					if (MLAN_STATUS_SUCCESS !=
 					    woal_get_bss_info(priv,
 							      MOAL_IOCTL_WAIT,
 							      &bss_info)) {
 						PRINTM(MINFO,
-						       "Set asynced essid: Fail to get bss info after assoc\n");
+						       "Ressoc: Fail to get bss info after driver auto reassoc\n");
 					} else {
 						moal_memcpy_ext(
 							priv->phandle,
@@ -6641,8 +9194,11 @@ int woal_reassociation_thread(void *data)
 							sizeof(priv->prev_ssid_bssid
 								       .bssid));
 					}
-					priv->set_asynced_essid_flag = MFALSE;
+					priv->auto_assoc_priv.drv_assoc.status =
+						MFALSE;
 				}
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
 				if (priv->rate_index != AUTO_RATE) {
 					req = woal_alloc_mlan_ioctl_req(
 						sizeof(mlan_ds_rate));
@@ -6684,10 +9240,18 @@ int woal_reassociation_thread(void *data)
 
 		if (reassoc_timer_req == MTRUE) {
 			handle->is_reassoc_timer_set = MTRUE;
-			if (priv && (priv->set_asynced_essid_flag == MTRUE)) {
-				PRINTM(MERROR,
-				       "Set Async ESSID: No AP found or assoc failed.\n");
-				priv->set_asynced_essid_flag = MFALSE;
+			if (priv &&
+			    (priv->auto_assoc_priv.drv_assoc.status == MTRUE ||
+			     priv->auto_assoc_priv.drv_reconnect.status ==
+				     MTRUE)) {
+				PRINTM(MEVENT,
+				       "Auto assoc: No AP found or assoc failed. "
+				       "Restarting re-assoc Timer: %d\n",
+				       (int)retry_interval);
+				if (retry_count != AUTO_ASSOC_RETRY_FOREVER)
+					retry_count--;
+				woal_mod_timer(&handle->reassoc_timer,
+					       retry_interval);
 			} else {
 				PRINTM(MEVENT,
 				       "Reassoc: No AP found or assoc failed. "
@@ -6698,12 +9262,15 @@ int woal_reassociation_thread(void *data)
 			}
 		} else {
 			if (priv) {
+				priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MFALSE;
 				priv->set_asynced_essid_flag = MFALSE;
 			}
 		}
 	}
 	woal_deactivate_thread(pmoal_thread);
-
+	kfree(ssid_bssid);
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
 }
@@ -6732,6 +9299,27 @@ void woal_reassoc_timer_func(void *context)
 }
 #endif /* REASSOCIATION */
 
+/**
+ *  @brief This function triggers process hang
+ *  re-assoc thread.
+ *
+ *  @param context  A pointer to context
+ *  @return         N/A
+ */
+void woal_fw_dump_timer_func(void *context)
+{
+	moal_handle *handle = (moal_handle *)context;
+
+	ENTER();
+
+	PRINTM(MMSG, "fw_dump_timer fired.\n");
+	handle->is_fw_dump_timer_set = MFALSE;
+	if (handle->priv_num)
+		woal_process_hang(handle);
+	LEAVE();
+	return;
+}
+
 #ifdef STA_SUPPORT
 /**
  *  @brief update dscp mapping from assoc_resp/reassoc_resp
@@ -6742,7 +9330,7 @@ void woal_reassoc_timer_func(void *context)
  */
 void woal_update_dscp_mapping(moal_private *priv)
 {
-	mlan_ds_misc_assoc_rsp assoc_rsp;
+	mlan_ds_misc_assoc_rsp *assoc_rsp = NULL;
 	IEEEtypes_AssocRsp_t *passoc_rsp = NULL;
 	IEEEtypes_Header_t *qos_mapping_ie = NULL;
 	DSCP_Range_t *pdscp_range = NULL;
@@ -6750,14 +9338,25 @@ void woal_update_dscp_mapping(moal_private *priv)
 	DSCP_Exception_t dscp_except[MAX_DSCP_EXCEPTION_NUM];
 	int i, j;
 	ENTER();
+	assoc_rsp = kmalloc(sizeof(mlan_ds_misc_assoc_rsp), GFP_KERNEL);
+	if (!assoc_rsp) {
+		LEAVE();
+		return;
+	}
+	memset(assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
+	if (MLAN_STATUS_FAILURE ==
+	    woal_get_assoc_rsp(priv, assoc_rsp, MOAL_NO_WAIT)) {
+		PRINTM(MERROR, "woal_get_assoc_rsp failed\n");
+		kfree(assoc_rsp);
+		LEAVE();
+		return;
+	}
 
-	memset(&assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
-	woal_get_assoc_rsp(priv, &assoc_rsp, MOAL_NO_WAIT);
-	passoc_rsp = (IEEEtypes_AssocRsp_t *)assoc_rsp.assoc_resp_buf;
+	passoc_rsp = (IEEEtypes_AssocRsp_t *)assoc_rsp->assoc_resp_buf;
 	memset(priv->dscp_map, 0xFF, sizeof(priv->dscp_map));
 	qos_mapping_ie = (IEEEtypes_Header_t *)woal_parse_ie_tlv(
 		passoc_rsp->ie_buffer,
-		assoc_rsp.assoc_resp_len - ASSOC_RESP_FIXED_SIZE, QOS_MAPPING);
+		assoc_rsp->assoc_resp_len - ASSOC_RESP_FIXED_SIZE, QOS_MAPPING);
 	if (qos_mapping_ie &&
 	    (qos_mapping_ie->len >= (sizeof(DSCP_Range_t) * MAX_NUM_TID))) {
 		dscp_except_num = (qos_mapping_ie->len -
@@ -6765,6 +9364,7 @@ void woal_update_dscp_mapping(moal_private *priv)
 				  sizeof(DSCP_Exception_t);
 		if (dscp_except_num > MAX_DSCP_EXCEPTION_NUM) {
 			PRINTM(MERROR, "dscp_except_num exceeds MAX limit\n");
+			kfree(assoc_rsp);
 			LEAVE();
 			return;
 		}
@@ -6803,6 +9403,7 @@ void woal_update_dscp_mapping(moal_private *priv)
 			}
 		}
 	}
+	kfree(assoc_rsp);
 	LEAVE();
 }
 
@@ -6830,14 +9431,17 @@ t_void woal_send_disconnect_to_system(moal_private *priv,
 	mlan_ds_misc_gtk_rekey_data zero_gtk;
 #endif
 #endif
+#ifdef STA_CFG80211
 	t_u16 reason_code = 0;
-
+#endif
 	ENTER();
 	priv->media_connected = MFALSE;
+#ifdef STA_CFG80211
 	if (!disconnect_reason)
 		reason_code = MLAN_REASON_DEAUTH_LEAVING;
 	else
 		reason_code = disconnect_reason;
+#endif
 	woal_stop_queue(priv->netdev);
 	if (netif_carrier_ok(priv->netdev))
 		netif_carrier_off(priv->netdev);
@@ -6852,16 +9456,26 @@ t_void woal_send_disconnect_to_system(moal_private *priv,
 	    memcmp(&priv->gtk_rekey_data, &zero_gtk,
 		   sizeof(priv->gtk_rekey_data)) != 0) {
 		PRINTM(MCMND, "clear GTK in woal_send_disconnect_to_system\n");
-		woal_set_rekey_data(priv, NULL, MLAN_ACT_CLEAR, MOAL_NO_WAIT);
+		if (MLAN_STATUS_FAILURE == woal_set_rekey_data(priv, NULL,
+							       MLAN_ACT_CLEAR,
+							       MOAL_NO_WAIT))
+			PRINTM(MERROR, "%s: clear GTK failed!\n", __func__);
 	}
 	memset(&priv->gtk_rekey_data, 0, sizeof(mlan_ds_misc_gtk_rekey_data));
 #endif
 #endif
 
+#ifdef STA_CFG80211
+	if (priv->bss_type == MLAN_BSS_TYPE_STA)
+		woal_flush_tdls_list(priv);
+#endif
+	woal_flush_mcast_list(priv);
 #ifdef STA_CFG80211
 	if (priv->bss_type == MLAN_BSS_TYPE_STA &&
 	    IS_STA_CFG80211(cfg80211_wext)) {
-		woal_flush_pmksa_list(priv);
+		if (woal_flush_pmksa_list(priv))
+			PRINTM(MERROR, "%s: woal_flush_pmksa_list failed!\n",
+			       __func__);
 		if (priv->okc_roaming_ie) {
 			kfree(priv->okc_roaming_ie);
 			priv->okc_roaming_ie = NULL;
@@ -6883,7 +9497,12 @@ t_void woal_send_disconnect_to_system(moal_private *priv,
 	if (IS_STA_CFG80211(cfg80211_wext)) {
 		spin_lock_irqsave(&priv->connect_lock, flags);
 		if (!priv->cfg_disconnect && !priv->cfg_connect && priv->wdev &&
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+		    priv->wdev->connected) {
+#else
 		    priv->wdev->current_bss) {
+#endif
 			PRINTM(MMSG,
 			       "wlan: Disconnected from " MACSTR
 			       ": Reason code %d\n",
@@ -6909,10 +9528,14 @@ t_void woal_send_disconnect_to_system(moal_private *priv,
 		} else {
 			spin_unlock_irqrestore(&priv->connect_lock, flags);
 		}
-		if (!woal_is_any_interface_active(priv->phandle))
-			woal_set_scan_time(priv, ACTIVE_SCAN_CHAN_TIME,
-					   PASSIVE_SCAN_CHAN_TIME,
-					   SPECIFIC_SCAN_CHAN_TIME);
+		if (!woal_is_any_interface_active(priv->phandle)) {
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_scan_time(priv, ACTIVE_SCAN_CHAN_TIME,
+					       PASSIVE_SCAN_CHAN_TIME,
+					       SPECIFIC_SCAN_CHAN_TIME))
+				PRINTM(MERROR, "%s: set scan time failed \n",
+				       __func__);
+		}
 		priv->ft_ie_len = 0;
 		priv->ft_pre_connect = MFALSE;
 		priv->ft_md = 0;
@@ -6923,161 +9546,106 @@ t_void woal_send_disconnect_to_system(moal_private *priv,
 
 	memset(event_buf, 0, sizeof(event_buf));
 	custom_len = strlen(CUS_EVT_AP_CONNECTED);
-	strncpy(event_buf, CUS_EVT_AP_CONNECTED,
-		MIN((sizeof(event_buf) - 1), custom_len));
-	woal_broadcast_event(priv, event_buf, custom_len + ETH_ALEN);
+	memcpy(event_buf, CUS_EVT_AP_CONNECTED,
+	       MIN((int)(sizeof(event_buf) - 1), custom_len));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_broadcast_event(priv, event_buf, custom_len + ETH_ALEN))
+		PRINTM(MINFO, "%s: woal_broadcast_event failed!\n", __func__);
 	LEAVE();
 }
 #endif /* STA_SUPPORT */
 
-#if defined(PCIE)
+#define OFFSET_SEQNUM 4
+#define OFFSET_TYPE 8
+#define DUMP_TYPE_ENDE 2
 /**
- *  @brief  This function stores the SSU dumps in a file
+ *  @brief  This function stores the FW dumps received from events
  *
  *  @param phandle     A pointer to moal_handle
  *  @param pmevent  A pointer to mlan_event structure
  *
  *  @return         N/A
  */
-t_void woal_store_ssu_dump(moal_handle *phandle, mlan_event *pmevent)
+t_void woal_store_firmware_dump(moal_handle *phandle, mlan_event *pmevent)
 {
-	struct dentry *dentry;
-	struct path path;
-	struct file *pfile_ssudump = NULL;
-	char dw_string[10];
-	loff_t pos = 0;
-	t_u32 i;
-	t_u32 *tmpbuf;
+	int ret = 0;
+	t_u16 seqnum;
+	t_u16 type = 0;
+	t_u8 *pos;
+	moal_private *priv = NULL;
 
 	ENTER();
-	dentry = kern_path_create(AT_FDCWD, "/data", &path, 1);
-	if (IS_ERR(dentry)) {
-		goto save_ssudump;
-	}
-	vfs_mkdir(path.dentry->d_inode, dentry, 0777);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
-	mutex_unlock(&path.dentry->d_inode->i_mutex);
-#else
-	inode_unlock(path.dentry->d_inode);
-#endif
 
-save_ssudump:
-	pfile_ssudump = filp_open("/data/ssudump.txt",
-				  O_CREAT | O_WRONLY | O_APPEND, 0644);
-	if (IS_ERR(pfile_ssudump)) {
-		PRINTM(MERROR, "Cannot create ssu dump file\n");
+	if (!phandle || !pmevent) {
+		PRINTM(MERROR, "Could not dump firmware info\n");
 		LEAVE();
 		return;
 	}
-	DBG_HEXDUMP(MEVT_D, "SSU addr", pmevent->event_buf, 8);
-	moal_memcpy_ext(phandle, &tmpbuf, pmevent->event_buf, 8, 8);
-	PRINTM(MEVENT, "woal_store_ssu_dump: tmpbuf %p\n", tmpbuf);
-	for (i = 0; i < pmevent->event_len / 4; i++) {
-		if ((i + 1) % 8 == 0)
-			snprintf(dw_string, sizeof(dw_string), "%08x\n",
-				 *tmpbuf);
-		else
-			snprintf(dw_string, sizeof(dw_string), "%08x ",
-				 *tmpbuf);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-		vfs_write(pfile_ssudump, dw_string, 9, &pos);
-#else
-		kernel_write(pfile_ssudump, dw_string, 9, &pos);
-#endif
-		tmpbuf++;
-	}
-	filp_close(pfile_ssudump, NULL);
-	LEAVE();
-	return;
-}
-#endif /* SSU_SUPPORT */
-
-#define OFFSET_SEQNUM 4
-#define OFFSET_TYPE 8
-#define DUMP_TYPE_ENDE 2
-t_void woal_store_firmware_dump(moal_handle *phandle, mlan_event *pmevent)
-{
-	struct file *pfile_fwdump = NULL;
-	loff_t pos = 0;
-	t_u16 seqnum;
-	t_u16 type = 0;
-	t_u8 path_name[64];
-	moal_handle *ref_handle = NULL;
+	seqnum = woal_le16_to_cpu(
+		*(t_u16 *)(pmevent->event_buf + OFFSET_SEQNUM));
+	type = woal_le16_to_cpu(*(t_u16 *)(pmevent->event_buf + OFFSET_TYPE));
 
-	ENTER();
-	if (phandle->fwdump_fname)
-		pfile_fwdump = filp_open(phandle->fwdump_fname,
-					 O_CREAT | O_WRONLY | O_APPEND, 0644);
-	else {
-		seqnum = woal_le16_to_cpu(
-			*(t_u16 *)(pmevent->event_buf + OFFSET_SEQNUM));
-		type = woal_le16_to_cpu(
-			*(t_u16 *)(pmevent->event_buf + OFFSET_TYPE));
+	if (seqnum == 1) {
+#ifdef DEBUG_LEVEL1
+		if (drvdbg & MFW_D)
+			phandle->fw_dump_status = MTRUE;
+#endif
+		if (phandle->fw_dump == MFALSE) {
+			PRINTM(MMSG, "=====FW trigger dump====\n");
+			phandle->fw_dump = MTRUE;
+			phandle->is_fw_dump_timer_set = MTRUE;
+			woal_mod_timer(&phandle->fw_dump_timer, MOAL_TIMER_5S);
+		}
 
-		if (seqnum == 1) {
-			if (drvdbg & MFW_D)
-				drvdbg &= ~MFW_D;
-			phandle->fw_dump_len = 0;
-			PRINTM(MMSG,
-			       "==== Start Receive FW dump event  ====\n");
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-			/** Create dump directort*/
-			woal_create_dump_dir(phandle, path_name,
-					     sizeof(path_name));
-#else
-			memset(path_name, 0, sizeof(path_name));
-			strcpy(path_name, "/data");
-#endif
-			PRINTM(MMSG, "Firmware Dump directory name is %s\n",
-			       path_name);
-			ref_handle = (moal_handle *)phandle->pref_mac;
-			if (ref_handle)
-				woal_dump_drv_info(ref_handle, path_name);
-			woal_dump_drv_info(phandle, path_name);
-			if (fwdump_fname) {
-				memset(fwdump_fname, 0, 64);
-			} else {
-				gfp_t flag;
-				flag = (in_atomic() || irqs_disabled()) ?
-					       GFP_ATOMIC :
-					       GFP_KERNEL;
-				fwdump_fname = kzalloc(64, flag);
-			}
-			sprintf(fwdump_fname, "%s/file_fwdump", path_name);
-			pfile_fwdump =
-				filp_open(fwdump_fname,
-					  O_CREAT | O_WRONLY | O_APPEND, 0644);
-			if (IS_ERR(pfile_fwdump)) {
-				memset(fwdump_fname, 0, 64);
-				sprintf(fwdump_fname, "%s/%s", "/var",
-					"file_fwdump");
-				pfile_fwdump =
-					filp_open(fwdump_fname,
-						  O_CREAT | O_WRONLY | O_APPEND,
-						  0644);
+		if (!phandle->fw_dump_buf) {
+			ret = moal_vmalloc(phandle, FW_DUMP_INFO_LEN,
+					   &phandle->fw_dump_buf);
+			if (ret != MLAN_STATUS_SUCCESS ||
+			    !phandle->fw_dump_buf) {
+				PRINTM(MERROR,
+				       "Failed to vmalloc fw dump buffer\n");
+				LEAVE();
+				return;
 			}
-		} else
-			pfile_fwdump =
-				filp_open(fwdump_fname,
-					  O_CREAT | O_WRONLY | O_APPEND, 0644);
-	}
-	if (IS_ERR(pfile_fwdump)) {
-		PRINTM(MERROR, "Cannot create firmware dump file\n");
-		LEAVE();
-		return;
+		} else {
+			memset(phandle->fw_dump_buf, 0x00, FW_DUMP_INFO_LEN);
+		}
+		phandle->fw_dump_len = 0;
+		PRINTM(MMSG, "==== Start Receive FW dump event  ====\n");
+	} else {
+		if (!phandle->fw_dump_buf || !phandle->fw_dump_len) {
+			PRINTM(MERROR,
+			       "Error! Fw dump buffer is null or dump len is zero\n");
+			LEAVE();
+			return;
+		}
 	}
+	pos = phandle->fw_dump_buf + phandle->fw_dump_len;
+	moal_memcpy_ext(phandle, pos, pmevent->event_buf + OFFSET_SEQNUM,
+			pmevent->event_len - OFFSET_SEQNUM,
+			FW_DUMP_INFO_LEN - phandle->fw_dump_len);
 	phandle->fw_dump_len += pmevent->event_len - OFFSET_SEQNUM;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	vfs_write(pfile_fwdump, pmevent->event_buf + OFFSET_SEQNUM,
-		  pmevent->event_len - OFFSET_SEQNUM, &pos);
-#else
-	kernel_write(pfile_fwdump, pmevent->event_buf + OFFSET_SEQNUM,
-		     pmevent->event_len - OFFSET_SEQNUM, &pos);
-#endif
-	filp_close(pfile_fwdump, NULL);
-	if (type == DUMP_TYPE_ENDE)
+
+	PRINTM(MINFO, "fw dump event: evt_len=%d toal_len=%ld\n",
+	       pmevent->event_len, (long int)phandle->fw_dump_len);
+	if (type == DUMP_TYPE_ENDE) {
 		PRINTM(MMSG, "==== FW DUMP END: %ld bytes ====\n",
 		       (long int)phandle->fw_dump_len);
+		woal_append_end_block(phandle);
+		phandle->fw_dump = MFALSE;
+		if (phandle->is_fw_dump_timer_set) {
+			woal_cancel_timer(&phandle->fw_dump_timer);
+			phandle->is_fw_dump_timer_set = MFALSE;
+		}
+		if (phandle->priv_num) {
+			priv = woal_get_priv(phandle, MLAN_BSS_ROLE_ANY);
+			if (priv)
+				woal_send_fw_dump_complete_event(priv);
+			mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
+			woal_process_hang(phandle);
+		}
+	}
+
 	LEAVE();
 	return;
 }
@@ -7109,17 +9677,17 @@ static int woal_save_hex_dump(int rowsize, const void *buf, size_t len,
 	if (rowsize != ROW_SIZE_16 && rowsize != ROW_SIZE_32)
 		rowsize = ROW_SIZE_16;
 
-	for (i = 0; i < len; i += rowsize) {
+	for (i = 0; i < (int)len; i += rowsize) {
 		linelen = min(remaining, rowsize);
 		remaining -= rowsize;
 
 		hex_dump_to_buffer(ptr + i, linelen, rowsize, 1, linebuf,
 				   sizeof(linebuf), false);
 
-		pos += sprintf(pos, "%s\n", linebuf);
+		pos += snprintf(pos, MAX_BUF_LEN, "%s\n", linebuf);
 	}
 
-	return pos - (char *)save_buf;
+	return (int)(pos - (char *)save_buf);
 }
 
 /**
@@ -7149,30 +9717,37 @@ static int woal_dump_priv_drv_info(moal_handle *handle, t_u8 *buf)
 	     index++) {
 		priv = handle->priv[index];
 		if (priv) {
-			ptr += sprintf(ptr, "[Interface : %s]\n",
-				       priv->proc_entry_name);
+			ptr += snprintf(ptr, MAX_BUF_LEN, "[Interface : %s]\n",
+					priv->proc_entry_name);
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-			ptr += sprintf(ptr, "wmm_tx_pending[0] = %d\n",
-				       atomic_read(&priv->wmm_tx_pending[0]));
-			ptr += sprintf(ptr, "wmm_tx_pending[1] = %d\n",
-				       atomic_read(&priv->wmm_tx_pending[1]));
-			ptr += sprintf(ptr, "wmm_tx_pending[2] = %d\n",
-				       atomic_read(&priv->wmm_tx_pending[2]));
-			ptr += sprintf(ptr, "wmm_tx_pending[3] = %d\n",
-				       atomic_read(&priv->wmm_tx_pending[3]));
-#endif
-			ptr += sprintf(ptr, "Media state = \"%s\"\n",
-				       ((priv->media_connected == MFALSE) ?
-						"Disconnected" :
-						"Connected"));
-			ptr += sprintf(ptr, "carrier %s\n",
-				       ((netif_carrier_ok(priv->netdev)) ?
-						"on" :
-						"off"));
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"wmm_tx_pending[0] = %d\n",
+					atomic_read(&priv->wmm_tx_pending[0]));
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"wmm_tx_pending[1] = %d\n",
+					atomic_read(&priv->wmm_tx_pending[1]));
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"wmm_tx_pending[2] = %d\n",
+					atomic_read(&priv->wmm_tx_pending[2]));
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"wmm_tx_pending[3] = %d\n",
+					atomic_read(&priv->wmm_tx_pending[3]));
+#endif
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"Media state = \"%s\"\n",
+					((priv->media_connected == MFALSE) ?
+						 "Disconnected" :
+						 "Connected"));
+			ptr += snprintf(ptr, MAX_BUF_LEN, "carrier %s\n",
+					((netif_carrier_ok(priv->netdev)) ?
+						 "on" :
+						 "off"));
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-			for (i = 0; i < (priv->netdev->num_tx_queues); i++) {
-				ptr += sprintf(
-					ptr, "tx queue %d: %s\n", i,
+			for (i = 0; i < (int)(priv->netdev->num_tx_queues);
+			     i++) {
+				ptr += snprintf(
+					ptr, MAX_BUF_LEN, "tx queue %d: %s\n",
+					i,
 					((netif_tx_queue_stopped(
 						 netdev_get_tx_queue(
 							 priv->netdev, i))) ?
@@ -7180,19 +9755,20 @@ static int woal_dump_priv_drv_info(moal_handle *handle, t_u8 *buf)
 						 "started"));
 			}
 #else
-			ptr += sprintf(ptr, "tx queue %s\n",
-				       ((netif_queue_stopped(priv->netdev)) ?
-						"stopped" :
-						"started"));
+			ptr += snprintf(ptr, MAX_BUF_LEN, "tx queue %s\n",
+					((netif_queue_stopped(priv->netdev)) ?
+						 "stopped" :
+						 "started"));
 #endif
-			ptr += sprintf(ptr, "%s: num_tx_timeout = %d\n",
-				       priv->netdev->name,
-				       priv->num_tx_timeout);
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"%s: num_tx_timeout = %d\n",
+					priv->netdev->name,
+					priv->num_tx_timeout);
 		}
 	}
 
 	LEAVE();
-	return ptr - (char *)buf;
+	return (int)(ptr - (char *)buf);
 }
 
 /**
@@ -7222,53 +9798,60 @@ static int woal_dump_moal_drv_info(moal_handle *phandle, t_u8 *buf)
 		cardp = (struct usb_card_rec *)phandle->card;
 #endif
 	ptr = (char *)buf;
-	ptr += sprintf(ptr, "------------moal_debug_info-------------\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN,
+			"------------moal_debug_info-------------\n");
 	woal_get_version(phandle, str_buf, sizeof(str_buf) - 1);
-	ptr += sprintf(ptr, "Driver version = %s\n", str_buf);
-	ptr += sprintf(ptr, "main_state = %d\n", phandle->main_state);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "Driver version = %s\n", str_buf);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "main_state = %d\n",
+			phandle->main_state);
 #ifdef USB
 	if (IS_USB(phandle->card_type)) {
-		ptr += sprintf(ptr, "tx_cmd_urb_pending = %d\n",
-			       atomic_read(&cardp->tx_cmd_urb_pending));
-		ptr += sprintf(ptr, "tx_data_urb_pending = %d\n",
-			       atomic_read(&cardp->tx_data_urb_pending));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "tx_cmd_urb_pending = %d\n",
+				atomic_read(&cardp->tx_cmd_urb_pending));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "tx_data_urb_pending = %d\n",
+				atomic_read(&cardp->tx_data_urb_pending));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "tx_data2_urb_pending = %d\n",
+				atomic_read(&cardp->tx_data2_urb_pending));
 #ifdef USB_CMD_DATA_EP
-		ptr += sprintf(ptr, "rx_cmd_urb_pending = %d\n",
-			       atomic_read(&cardp->rx_cmd_urb_pending));
-#endif
-		ptr += sprintf(ptr, "rx_data_urb_pending = %d\n",
-			       atomic_read(&cardp->rx_data_urb_pending));
-	}
-#endif
-	ptr += sprintf(ptr, "ioctl_pending = %d\n",
-		       atomic_read(&phandle->ioctl_pending));
-	ptr += sprintf(ptr, "tx_pending = %d\n",
-		       atomic_read(&phandle->tx_pending));
-	ptr += sprintf(ptr, "rx_pending = %d\n",
-		       atomic_read(&phandle->rx_pending));
-	ptr += sprintf(ptr, "lock_count = %d\n",
-		       atomic_read(&phandle->lock_count));
-	ptr += sprintf(ptr, "malloc_count = %d\n",
-		       atomic_read(&phandle->malloc_count));
-	ptr += sprintf(ptr, "mbufalloc_count = %d\n",
-		       atomic_read(&phandle->mbufalloc_count));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "rx_cmd_urb_pending = %d\n",
+				atomic_read(&cardp->rx_cmd_urb_pending));
+#endif
+		ptr += snprintf(ptr, MAX_BUF_LEN, "rx_data_urb_pending = %d\n",
+				atomic_read(&cardp->rx_data_urb_pending));
+	}
+#endif
+	ptr += snprintf(ptr, MAX_BUF_LEN, "ioctl_pending = %d\n",
+			atomic_read(&phandle->ioctl_pending));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "tx_pending = %d\n",
+			atomic_read(&phandle->tx_pending));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "rx_pending = %d\n",
+			atomic_read(&phandle->rx_pending));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "lock_count = %d\n",
+			atomic_read(&phandle->lock_count));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "malloc_count = %d\n",
+			atomic_read(&phandle->malloc_count));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "mbufalloc_count = %d\n",
+			atomic_read(&phandle->mbufalloc_count));
 #ifdef PCIE
 	if (IS_PCIE(phandle->card_type)) {
-		ptr += sprintf(ptr, "malloc_cons_count = %d\n",
-			       atomic_read(&phandle->malloc_cons_count));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "malloc_cons_count = %d\n",
+				atomic_read(&phandle->malloc_cons_count));
 	}
 #endif
-	ptr += sprintf(ptr, "hs_skip_count = %u\n", phandle->hs_skip_count);
-	ptr += sprintf(ptr, "hs_force_count = %u\n", phandle->hs_force_count);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "hs_skip_count = %u\n",
+			phandle->hs_skip_count);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "hs_force_count = %u\n",
+			phandle->hs_force_count);
 
 	ptr += woal_dump_priv_drv_info(phandle, ptr);
-	ptr += sprintf(ptr, "------------moal_debug_info End-------------\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN,
+			"------------moal_debug_info End-------------\n");
 
 	if (phandle->ops.dump_reg_info)
 		ptr += phandle->ops.dump_reg_info(phandle, ptr);
 
 	LEAVE();
-	return ptr - (char *)buf;
+	return (int)(ptr - (char *)buf);
 }
 
 /**
@@ -7304,77 +9887,97 @@ static int woal_dump_mlan_drv_info(moal_private *priv, t_u8 *buf)
 		LEAVE();
 		return 0;
 	}
-	ptr += sprintf(ptr, "------------mlan_debug_info-------------\n");
-	ptr += sprintf(ptr, "mlan_processing =%d\n", info->mlan_processing);
-	ptr += sprintf(ptr, "main_lock_flag =%d\n", info->main_lock_flag);
-	ptr += sprintf(ptr, "main_process_cnt =%d\n", info->main_process_cnt);
-	ptr += sprintf(ptr, "delay_task_flag =%d\n", info->delay_task_flag);
-	ptr += sprintf(ptr, "mlan_rx_processing =%d\n",
-		       info->mlan_rx_processing);
-	ptr += sprintf(ptr, "rx_pkts_queued =%d\n", info->rx_pkts_queued);
-	ptr += sprintf(ptr, "tx_pkts_queued =%d\n", info->tx_pkts_queued);
-	ptr += sprintf(ptr, "fw_hang_report = %d\n", info->fw_hang_report);
-	ptr += sprintf(ptr, "num_cmd_timeout = %d\n", info->num_cmd_timeout);
-	ptr += sprintf(ptr, "Timeout cmd id = 0x%x, act = 0x%x\n",
-		       info->timeout_cmd_id, info->timeout_cmd_act);
-	ptr += sprintf(ptr, "last_cmd_index = %d\n", info->last_cmd_index);
+	ptr += snprintf(ptr, MAX_BUF_LEN,
+			"------------mlan_debug_info-------------\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN, "mlan_processing =%d\n",
+			info->mlan_processing);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "main_lock_flag =%d\n",
+			info->main_lock_flag);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "main_process_cnt =%d\n",
+			info->main_process_cnt);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "delay_task_flag =%d\n",
+			info->delay_task_flag);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "mlan_rx_processing =%d\n",
+			info->mlan_rx_processing);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "rx_pkts_queued =%d\n",
+			info->rx_pkts_queued);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "tx_pkts_queued =%d\n",
+			info->tx_pkts_queued);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "fw_hang_report = %d\n",
+			info->fw_hang_report);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cmd_timeout = %d\n",
+			info->num_cmd_timeout);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "Timeout cmd id = 0x%x, act = 0x%x\n",
+			info->timeout_cmd_id, info->timeout_cmd_act);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_cmd_index = %d\n",
+			info->last_cmd_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_id[i]);
-	ptr += sprintf(ptr, "last_cmd_id = %s\n", str);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_cmd_id[i]);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_cmd_id = %s\n", str);
 
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_act[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_cmd_act[i]);
 
-	ptr += sprintf(ptr, "last_cmd_act = %s\n", str);
-	ptr += sprintf(ptr, "last_cmd_resp_index = %d\n",
-		       info->last_cmd_resp_index);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_cmd_act = %s\n", str);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_cmd_resp_index = %d\n",
+			info->last_cmd_resp_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_cmd_resp_id[i]);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ",
+			      info->last_cmd_resp_id[i]);
 
-	ptr += sprintf(ptr, "last_cmd_resp_id = %s\n", str);
-	ptr += sprintf(ptr, "last_event_index = %d\n", info->last_event_index);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_cmd_resp_id = %s\n", str);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_event_index = %d\n",
+			info->last_event_index);
 	for (s = str, i = 0; i < DBG_CMD_NUM; i++)
-		s += sprintf(s, "0x%x ", info->last_event[i]);
-
-	ptr += sprintf(ptr, "last_event = %s\n", str);
-	ptr += sprintf(ptr, "num_data_h2c_failure = %d\n",
-		       info->num_tx_host_to_card_failure);
-	ptr += sprintf(ptr, "num_cmd_h2c_failure = %d\n",
-		       info->num_cmd_host_to_card_failure);
-	ptr += sprintf(ptr, "num_alloc_buffer_failure = %d\n",
-		       info->num_alloc_buffer_failure);
-	ptr += sprintf(ptr, "num_pkt_dropped = %d\n", info->num_pkt_dropped);
+		s += snprintf(s, MAX_BUF_LEN, "0x%x ", info->last_event[i]);
+
+	ptr += snprintf(ptr, MAX_BUF_LEN, "last_event = %s\n", str);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_data_h2c_failure = %d\n",
+			info->num_tx_host_to_card_failure);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cmd_h2c_failure = %d\n",
+			info->num_cmd_host_to_card_failure);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_alloc_buffer_failure = %d\n",
+			info->num_alloc_buffer_failure);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_pkt_dropped = %d\n",
+			info->num_pkt_dropped);
 #ifdef SDIO
 	if (IS_SD(priv->phandle->card_type)) {
-		ptr += sprintf(ptr, "num_data_c2h_failure = %d\n",
-			       info->num_rx_card_to_host_failure);
-		ptr += sprintf(ptr, "num_cmdevt_c2h_failure = %d\n",
-			       info->num_cmdevt_card_to_host_failure);
-		ptr += sprintf(ptr, "num_int_read_failure = %d\n",
-			       info->num_int_read_failure);
-		ptr += sprintf(ptr, "last_int_status = %d\n",
-			       info->last_int_status);
-		ptr += sprintf(ptr, "mp_rd_bitmap=0x%x curr_rd_port=0x%x\n",
-			       (unsigned int)info->mp_rd_bitmap,
-			       info->curr_rd_port);
-		ptr += sprintf(ptr, "mp_wr_bitmap=0x%x curr_wr_port=0x%x\n",
-			       (unsigned int)info->mp_wr_bitmap,
-			       info->curr_wr_port);
-		ptr += sprintf(ptr, "mp_invalid_update=%d\n",
-			       info->mp_invalid_update);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "num_data_c2h_failure = %d\n",
+				info->num_rx_card_to_host_failure);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"num_cmdevt_c2h_failure = %d\n",
+				info->num_cmdevt_card_to_host_failure);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "num_int_read_failure = %d\n",
+				info->num_int_read_failure);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "last_int_status = %d\n",
+				info->last_int_status);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"mp_rd_bitmap=0x%x curr_rd_port=0x%x\n",
+				(unsigned int)info->mp_rd_bitmap,
+				info->curr_rd_port);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"mp_wr_bitmap=0x%x curr_wr_port=0x%x\n",
+				(unsigned int)info->mp_wr_bitmap,
+				info->curr_wr_port);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "mp_data_port_mask=0x%x\n",
+				info->mp_data_port_mask);
+		ptr += snprintf(
+			ptr, MAX_BUF_LEN,
+			"last_recv_rd_bitmap=0x%x mp_invalid_update=%d\n",
+			info->last_recv_rd_bitmap, info->mp_invalid_update);
 		mp_aggr_pkt_limit = info->mp_aggr_pkt_limit;
-		ptr += sprintf(ptr,
-			       "last_recv_wr_bitmap=0x%x last_mp_index = %d\n",
-			       info->last_recv_wr_bitmap, info->last_mp_index);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"last_recv_wr_bitmap=0x%x last_mp_index = %d\n",
+				info->last_recv_wr_bitmap, info->last_mp_index);
 		for (i = 0; i < SDIO_MP_DBG_NUM; i++) {
 			for (s = str, j = 0; j < mp_aggr_pkt_limit; j++)
-				s += sprintf(
-					s, "0x%02x ",
+				s += snprintf(
+					s, MAX_BUF_LEN, "0x%02x ",
 					info->last_mp_wr_info
 						[i * mp_aggr_pkt_limit + j]);
 
-			ptr += sprintf(
-				ptr,
+			ptr += snprintf(
+				ptr, MAX_BUF_LEN,
 				"mp_wr_bitmap: 0x%x mp_wr_ports=0x%x len=%d curr_wr_port=0x%x\n%s\n",
 				info->last_mp_wr_bitmap[i],
 				info->last_mp_wr_ports[i],
@@ -7385,156 +9988,99 @@ static int woal_dump_mlan_drv_info(moal_private *priv, t_u8 *buf)
 #endif
 #ifdef PCIE
 	if (IS_PCIE(priv->phandle->card_type)) {
-		ptr += sprintf(ptr, "txbd_rdptr=0x%x txbd_wrptr=0x%x\n",
-			       info->txbd_rdptr, info->txbd_wrptr);
-		ptr += sprintf(ptr, "rxbd_rdptr=0x%x rxbd_wrptr=0x%x\n",
-			       info->rxbd_rdptr, info->rxbd_wrptr);
-		ptr += sprintf(ptr, "eventbd_rdptr=0x%x event_wrptr=0x%x\n",
-			       info->eventbd_rdptr, info->eventbd_wrptr);
-		ptr += sprintf(ptr, "last_wr_index:%d\n",
-			       info->txbd_wrptr & (MLAN_MAX_TXRX_BD - 1));
-		ptr += sprintf(ptr, "Tx pkt size:\n");
-		for (i = 0; i < MLAN_MAX_TXRX_BD; i++) {
-			ptr += sprintf(ptr, "%04d ", info->last_tx_pkt_size[i]);
-			if (((i + 1) % 16) == 0)
-				ptr += sprintf(ptr, "\n");
-		}
-	}
-#endif
-	ptr += sprintf(ptr, "num_event_deauth = %d\n", info->num_event_deauth);
-	ptr += sprintf(ptr, "num_event_disassoc = %d\n",
-		       info->num_event_disassoc);
-	ptr += sprintf(ptr, "num_event_link_lost = %d\n",
-		       info->num_event_link_lost);
-	ptr += sprintf(ptr, "num_cmd_deauth = %d\n", info->num_cmd_deauth);
-	ptr += sprintf(ptr, "num_cmd_assoc_success = %d\n",
-		       info->num_cmd_assoc_success);
-	ptr += sprintf(ptr, "num_cmd_assoc_failure = %d\n",
-		       info->num_cmd_assoc_failure);
-	ptr += sprintf(ptr, "num_cons_assoc_failure = %d\n",
-		       info->num_cons_assoc_failure);
-	ptr += sprintf(ptr, "cmd_resp_received = %d\n",
-		       info->cmd_resp_received);
-	ptr += sprintf(ptr, "event_received = %d\n", info->event_received);
-	ptr += sprintf(ptr, "max_tx_buf_size = %d\n", info->max_tx_buf_size);
-	ptr += sprintf(ptr, "tx_buf_size = %d\n", info->tx_buf_size);
-	ptr += sprintf(ptr, "curr_tx_buf_size = %d\n", info->curr_tx_buf_size);
-
-	ptr += sprintf(ptr, "data_sent=%d cmd_sent=%d\n", info->data_sent,
-		       info->cmd_sent);
-	ptr += sprintf(ptr, "ps_mode=%d ps_state=%d\n", info->ps_mode,
-		       info->ps_state);
-	ptr += sprintf(
-		ptr, "wakeup_dev_req=%d wakeup_tries=%d pm_wakeup_timeout=%d\n",
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"txbd_rdptr=0x%x txbd_wrptr=0x%x\n",
+				info->txbd_rdptr, info->txbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"rxbd_rdptr=0x%x rxbd_wrptr=0x%x\n",
+				info->rxbd_rdptr, info->rxbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"eventbd_rdptr=0x%x event_wrptr=0x%x\n",
+				info->eventbd_rdptr, info->eventbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "last_wr_index:%d\n",
+				info->txbd_wrptr & (info->txrx_bd_size - 1));
+		ptr += snprintf(ptr, MAX_BUF_LEN, "TxRx BD size:%d\n",
+				info->txrx_bd_size);
+	}
+#endif
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_event_deauth = %d\n",
+			info->num_event_deauth);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_event_disassoc = %d\n",
+			info->num_event_disassoc);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_event_link_lost = %d\n",
+			info->num_event_link_lost);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cmd_deauth = %d\n",
+			info->num_cmd_deauth);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cmd_assoc_success = %d\n",
+			info->num_cmd_assoc_success);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cmd_assoc_failure = %d\n",
+			info->num_cmd_assoc_failure);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "num_cons_assoc_failure = %d\n",
+			info->num_cons_assoc_failure);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "cmd_resp_received = %d\n",
+			info->cmd_resp_received);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "event_received = %d\n",
+			info->event_received);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "max_tx_buf_size = %d\n",
+			info->max_tx_buf_size);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "tx_buf_size = %d\n",
+			info->tx_buf_size);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "curr_tx_buf_size = %d\n",
+			info->curr_tx_buf_size);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "bypass_pkt_count=%d\n",
+			info->bypass_pkt_count);
+
+	ptr += snprintf(ptr, MAX_BUF_LEN, "data_sent=%d cmd_sent=%d\n",
+			info->data_sent, info->cmd_sent);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "data_sent_cnt=%u\n",
+			info->data_sent_cnt);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "ps_mode=%d ps_state=%d\n",
+			info->ps_mode, info->ps_state);
+	ptr += snprintf(
+		ptr, MAX_BUF_LEN,
+		"wakeup_dev_req=%d wakeup_tries=%d pm_wakeup_timeout=%d\n",
 		info->pm_wakeup_card_req, info->pm_wakeup_fw_try,
 		info->pm_wakeup_timeout);
-	ptr += sprintf(ptr, "hs_configured=%d hs_activated=%d\n",
-		       info->is_hs_configured, info->hs_activated);
-	ptr += sprintf(ptr, "pps_uapsd_mode=%d sleep_pd=%d\n",
-		       info->pps_uapsd_mode, info->sleep_pd);
-	ptr += sprintf(ptr, "tx_lock_flag = %d\n", info->tx_lock_flag);
-	ptr += sprintf(ptr, "port_open = %d\n", info->port_open);
-	ptr += sprintf(ptr, "scan_processing = %d\n", info->scan_processing);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "hs_configured=%d hs_activated=%d\n",
+			info->is_hs_configured, info->hs_activated);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "pps_uapsd_mode=%d sleep_pd=%d\n",
+			info->pps_uapsd_mode, info->sleep_pd);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "tx_lock_flag = %d\n",
+			info->tx_lock_flag);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "port_open = %d\n", info->port_open);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "scan_processing = %d\n",
+			info->scan_processing);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "scan_state = %d\n",
+			info->scan_state);
 
 #ifdef PCIE
 	if (IS_PCIE(priv->phandle->card_type)) {
-		ptr += sprintf(ptr, "txbd: rdptr=0x%x wrptr=0x%x\n",
-			       info->txbd_rdptr, info->txbd_wrptr);
-		ptr += sprintf(ptr, "rxbd: rdptr=0x%x wrptr=0x%x\n",
-			       info->rxbd_rdptr, info->rxbd_wrptr);
-		ptr += sprintf(ptr, "eventbd: rdptr=0x%x wrptr=0x%x\n",
-			       info->eventbd_rdptr, info->eventbd_wrptr);
-		ptr += sprintf(ptr, "TXBD Ring:\n");
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"txbd: rdptr=0x%x wrptr=0x%x\n",
+				info->txbd_rdptr, info->txbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"rxbd: rdptr=0x%x wrptr=0x%x\n",
+				info->rxbd_rdptr, info->rxbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"eventbd: rdptr=0x%x wrptr=0x%x\n",
+				info->eventbd_rdptr, info->eventbd_wrptr);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "TXBD Ring:\n");
 		ptr += woal_save_hex_dump(ROW_SIZE_16, info->txbd_ring_vbase,
 					  info->txbd_ring_size, MTRUE, ptr);
-		ptr += sprintf(ptr, "RXBD Ring:\n");
+		ptr += snprintf(ptr, MAX_BUF_LEN, "RXBD Ring:\n");
 		ptr += woal_save_hex_dump(ROW_SIZE_16, info->rxbd_ring_vbase,
 					  info->rxbd_ring_size, MTRUE, ptr);
-		ptr += sprintf(ptr, "EVTBD Ring:\n");
+		ptr += snprintf(ptr, MAX_BUF_LEN, "EVTBD Ring:\n");
 		ptr += woal_save_hex_dump(ROW_SIZE_16, info->evtbd_ring_vbase,
 					  info->evtbd_ring_size, MTRUE, ptr);
 	}
 #endif
-	ptr += sprintf(ptr, "------------mlan_debug_info End-------------\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN,
+			"------------mlan_debug_info End-------------\n");
 
 	LEAVE();
 	return ptr - (char *)buf;
 }
-#define HostCmd_CMD_CFG_DATA 0x008f
-#define DEF_FW_PATH "/lib/firmware/"
-#define DEF_HOSTCMD_PATH "/lib/firmware/nxp/hostcmd.conf"
-/**
- *  @brief This function save the hostcmd response to file
- *
- *  @param phandle   A pointer to moal_handle
- *  @param pevent    A pointer to mlan_cmdresp_event
- *
- *  @return          N/A
- */
-t_void woal_save_host_cmdresp(moal_handle *phandle, mlan_cmdresp_event *pevent)
-{
-	HostCmd_DS_GEN *resp;
-	char file_path[256];
-	struct file *pfile = NULL;
-	char *dpd_data_cfg = phandle->params.dpd_data_cfg;
-	int ret;
-	t_u8 *buf;
-	t_u16 command;
-	int len = 0;
-	char *ptr;
-	loff_t pos = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	mm_segment_t fs;
-#endif
-
-	resp = (HostCmd_DS_GEN *)pevent->resp;
-	command = woal_le16_to_cpu(resp->command);
-	memset(file_path, 0, sizeof(file_path));
-	ret = moal_vmalloc(phandle, pevent->event_len * 5, &buf);
-	if (ret != MLAN_STATUS_SUCCESS || !buf) {
-		PRINTM(MERROR, "Fail to allocate memory to save hostcmd\n");
-		return;
-	}
-	memset(buf, 0, pevent->event_len * 5);
-	ptr = (char *)buf;
-	switch (command) {
-	case HostCmd_CMD_CFG_DATA:
-		if (dpd_data_cfg)
-			sprintf(file_path, "%s%s", DEF_FW_PATH, dpd_data_cfg);
-		else
-			sprintf(file_path, "%s", DEF_HOSTCMD_PATH);
-		break;
-	default:
-		sprintf(file_path, "%s", DEF_HOSTCMD_PATH);
-		break;
-	}
-	pfile = filp_open(file_path, O_CREAT | O_WRONLY | O_APPEND, 0644);
-	if (IS_ERR(pfile)) {
-		PRINTM(MERROR, "Cannot create file %s\n", file_path);
-		moal_vfree(phandle, buf);
-		return;
-	}
-	ptr += sprintf(ptr, "hostcmd_%02x=={\n", command);
-	ptr += woal_save_hex_dump(ROW_SIZE_16, resp, pevent->event_len, MFALSE,
-				  ptr);
-	ptr += sprintf(ptr, "}\n");
-	len = ptr - (char *)buf;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	vfs_write(pfile, buf, len, &pos);
-	set_fs(fs);
-#else
-	kernel_write(pfile, buf, len, &pos);
-#endif
-	PRINTM(MMSG, "Save hostcmd 0x%02x, cmd len=%d file len=%d to file %s\n",
-	       command, pevent->event_len, len, file_path);
-	if (buf)
-		moal_vfree(phandle, buf);
-	filp_close(pfile, NULL);
-	return;
-}
 
 /**
  *  @brief This function dump moal hex to file
@@ -7556,27 +10102,32 @@ static int woal_dump_moal_hex(moal_handle *phandle, t_u8 *buf)
 		return 0;
 	}
 
-	ptr += sprintf(ptr, "<--moal_handle-->\n");
-	ptr += sprintf(ptr, "moal_handle=%p, size=%ld(0x%lx)\n", phandle,
-		       (long int)sizeof(*phandle),
-		       (long unsigned int)sizeof(*phandle));
+	ptr += snprintf(ptr, MAX_BUF_LEN, "<--moal_handle-->\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN, "moal_handle=%p, size=%ld(0x%lx)\n",
+			phandle, (long int)sizeof(*phandle),
+			(long unsigned int)sizeof(*phandle));
 	ptr += woal_save_hex_dump(ROW_SIZE_16, phandle, sizeof(*phandle), MTRUE,
 				  ptr);
-	ptr += sprintf(ptr, "<--moal_handle End-->\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN, "<--moal_handle End-->\n");
 
 	for (i = 0; i < phandle->priv_num; i++) {
-		ptr += sprintf(ptr, "<--moal_private(%d)-->\n", i);
-		ptr += sprintf(ptr, "moal_private=%p, size=%ld(0x%lx)\n",
-			       phandle->priv[i],
-			       (long int)sizeof(*(phandle->priv[i])),
-			       (long unsigned int)sizeof(*(phandle->priv[i])));
+		if (!phandle->priv[i])
+			continue;
+		ptr += snprintf(ptr, MAX_BUF_LEN, "<--moal_private(%d) %s-->\n",
+				i, phandle->priv[i]->netdev->name);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"moal_private=%p, size=%ld(0x%lx)\n",
+				phandle->priv[i],
+				(long int)sizeof(*(phandle->priv[i])),
+				(long unsigned int)sizeof(*(phandle->priv[i])));
 		ptr += woal_save_hex_dump(ROW_SIZE_16, phandle->priv[i],
 					  sizeof(*(phandle->priv[i])), MTRUE,
 					  ptr);
-		ptr += sprintf(ptr, "<--moal_private(%d) End-->\n", i);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"<--moal_private(%d) End-->\n", i);
 	}
 	LEAVE();
-	return ptr - (char *)buf;
+	return (int)(ptr - (char *)buf);
 }
 
 /**
@@ -7607,260 +10158,162 @@ static int woal_dump_mlan_hex(moal_private *priv, t_u8 *buf)
 		return 0;
 	}
 
-	ptr += sprintf(ptr, "<--mlan_adapter-->\n");
-	ptr += sprintf(ptr, "mlan_adapter=%p, size=%d(0x%x)\n",
-		       info->mlan_adapter, info->mlan_adapter_size,
-		       info->mlan_adapter_size);
+	ptr += snprintf(ptr, MAX_BUF_LEN, "<--mlan_adapter-->\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN, "mlan_adapter=%p, size=%d(0x%x)\n",
+			info->mlan_adapter, info->mlan_adapter_size,
+			info->mlan_adapter_size);
 	ptr += woal_save_hex_dump(ROW_SIZE_16, info->mlan_adapter,
 				  info->mlan_adapter_size, MTRUE, ptr);
-	ptr += sprintf(ptr, "<--mlan_adapter End-->\n");
+	ptr += snprintf(ptr, MAX_BUF_LEN, "<--mlan_adapter End-->\n");
 #ifdef SDIO
 	if (IS_SD(priv->phandle->card_type) && info->mpa_buf &&
 	    info->mpa_buf_size) {
-		ptr += sprintf(ptr, "<--mlan_mpa_buf-->\n");
-		ptr += sprintf(ptr, "mlan_mpa_buf=%p, size=%d(0x%x)\n",
-			       info->mpa_buf, info->mpa_buf_size,
-			       info->mpa_buf_size);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "<--mlan_mpa_buf-->\n");
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"mlan_mpa_buf=%p, size=%d(0x%x)\n",
+				info->mpa_buf, info->mpa_buf_size,
+				info->mpa_buf_size);
 		ptr += woal_save_hex_dump(ROW_SIZE_16, info->mpa_buf,
 					  info->mpa_buf_size, MTRUE, ptr);
-		ptr += sprintf(ptr, "<--mlan_mpa_buf End-->\n");
+		ptr += snprintf(ptr, MAX_BUF_LEN, "<--mlan_mpa_buf End-->\n");
 	}
 #endif
 	for (i = 0; i < info->mlan_priv_num; i++) {
-		ptr += sprintf(ptr, "<--mlan_private(%d)-->\n", i);
-		ptr += sprintf(ptr, "mlan_private=%p, size=%d(0x%x)\n",
-			       info->mlan_priv[i], info->mlan_priv_size[i],
-			       info->mlan_priv_size[i]);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "<--mlan_private(%d)-->\n",
+				i);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"mlan_private=%p, size=%d(0x%x)\n",
+				info->mlan_priv[i], info->mlan_priv_size[i],
+				info->mlan_priv_size[i]);
 		ptr += woal_save_hex_dump(ROW_SIZE_16, info->mlan_priv[i],
 					  info->mlan_priv_size[i], MTRUE, ptr);
-		ptr += sprintf(ptr, "<--mlan_private(%d) End-->\n", i);
+		ptr += snprintf(ptr, MAX_BUF_LEN,
+				"<--mlan_private(%d) End-->\n", i);
 	}
 
 	LEAVE();
 	return ptr - (char *)buf;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 /**
- *  @brief This function create dump directory
+ *  @brief This function dump drv info to file
  *
  *  @param phandle   A pointer to moal_handle
- *  @param dir_buf   A pointer to dir_buf buffer
- *  @param buf_size  Size of dir_buf buffer
+ *  @param dump_len  A point to hold the len of drv info memory
  *
- *  @return         N/A
+ *  @return         A pointer to drv_info memory
  */
-void woal_create_dump_dir(moal_handle *phandle, char *dir_buf, int buf_size)
+t_u8 *woal_dump_drv_info(moal_handle *phandle, t_u32 *dump_len)
 {
-	struct dentry *dentry;
-	struct path path;
-	t_u32 sec, usec;
+	t_u8 *drv_buf = NULL;
+	t_u32 len = 0;
+	t_u32 total_len = 0;
+	t_u32 drv_info_size = DRV_INFO_SIZE;
 	int ret;
-
-	ENTER();
-
-	if (!phandle || !dir_buf) {
-		PRINTM(MERROR, "Can't create directory\n");
-		ret = MLAN_STATUS_FAILURE;
+	if (!phandle->priv_num)
+		return NULL;
+	if (phandle->priv_num > 3)
+		drv_info_size += (phandle->priv_num - 3) * DRV_INFO_PER_INTF;
+	PRINTM(MERROR, "=== START DRIVER INFO DUMP===");
+	ret = moal_vmalloc(phandle, drv_info_size, &drv_buf);
+	if ((ret != MLAN_STATUS_SUCCESS) || !drv_buf) {
+		PRINTM(MERROR, "Error: vmalloc drv buffer failed!\n");
 		goto done;
 	}
 
-	moal_get_system_time(phandle, &sec, &usec);
-	memset(dir_buf, 0, buf_size);
-	sprintf(dir_buf, "%s%u", "/data/dump_", sec);
-
-	dentry = kern_path_create(AT_FDCWD, dir_buf, &path, 1);
-	if (IS_ERR(dentry)) {
-		PRINTM(MERROR,
-		       "Create directory %s error, try create dir in /var",
-		       dir_buf);
-		memset(dir_buf, 0, buf_size);
-		sprintf(dir_buf, "%s%u", "/var/dump_", sec);
-		dentry = kern_path_create(AT_FDCWD, dir_buf, &path, 1);
-	}
-	if (IS_ERR(dentry)) {
-		PRINTM(MERROR, "Create directory %s error, use default folder",
-		       dir_buf);
-		goto default_dir;
-	}
-	ret = vfs_mkdir(path.dentry->d_inode, dentry, 0777);
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
-	mutex_unlock(&path.dentry->d_inode->i_mutex);
-#else
-	inode_unlock(path.dentry->d_inode);
-#endif
-
-	if (ret < 0) {
-		PRINTM(MERROR,
-		       "Create directory failure, use default folder\n");
-		PRINTM(MERROR, "Create directory failure, ret = %d\n", ret);
-		goto default_dir;
-	} else {
-		PRINTM(MMSG, "Create directory %s successfully\n", dir_buf);
-		goto done;
-	}
+	len = woal_dump_moal_drv_info(phandle, drv_buf);
+	total_len += len;
+	len = woal_dump_mlan_drv_info(woal_get_priv(phandle, MLAN_BSS_ROLE_ANY),
+				      drv_buf + total_len);
+	total_len += len;
+	len = woal_dump_moal_hex(phandle, drv_buf + total_len);
+	total_len += len;
+	len = woal_dump_mlan_hex(woal_get_priv(phandle, MLAN_BSS_ROLE_ANY),
+				 drv_buf + total_len);
+	total_len += len;
 
-default_dir:
-	memset(dir_buf, 0, buf_size);
-	sprintf(dir_buf, "%s", "/data");
+	PRINTM(MERROR, "Drv info total bytes = %ld (0x%lx)\n",
+	       (long int)total_len, (long unsigned int)total_len);
+	PRINTM(MERROR, "=== DRIVER INFO DUMP END===");
+	*dump_len = total_len;
 done:
-	LEAVE();
+	return drv_buf;
 }
-#endif
 
 /**
- *  @brief This function save dump buf to file
+ *  @brief This function adds header and copy the src data to buf
  *
- *  @param dir_name  A pointer to directory name
- *  @param file_name A pointer to file name
- *  @param buf       A pointer to dump data
- *  @param buf_len   The length of dump buf
+ *  @param phandle   A pointer to moal_handle
+ *  @param src     A ponter to source buffer
+ *  @param len     Length of raw data
+ *  @param type   Dump type
  *
- *  @return         SUCCESS OR FAILURE
+ *  return Total len of buf
  */
-mlan_status woal_save_dump_info_to_file(char *dir_name, char *file_name,
-					t_u8 *buf, t_u32 buf_len)
+int woal_save_dump_info_to_buf(moal_handle *phandle, t_u8 *src, t_u32 len,
+			       t_u32 type)
 {
-	mlan_status ret = MLAN_STATUS_SUCCESS;
-	struct file *pfile = NULL;
-	t_u8 name[64];
-	loff_t pos;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	mm_segment_t fs;
-#endif
-
-	ENTER();
-
-	if (!dir_name || !file_name || !buf) {
-		PRINTM(MERROR, "Can't save dump info to file\n");
-		ret = MLAN_STATUS_FAILURE;
-		goto done;
-	}
-
-	memset(name, 0, sizeof(name));
-	sprintf(name, "%s/%s", dir_name, file_name);
-	pfile = filp_open(name, O_CREAT | O_RDWR, 0644);
-	if (IS_ERR(pfile)) {
-		PRINTM(MMSG,
-		       "Create file %s error, try to save dump file in /var\n",
-		       name);
-		memset(name, 0, sizeof(name));
-		sprintf(name, "%s/%s", "/var", file_name);
-		pfile = filp_open(name, O_CREAT | O_RDWR, 0644);
-	}
-	if (IS_ERR(pfile)) {
-		PRINTM(MERROR, "Create Dump file for %s error\n", name);
-		ret = MLAN_STATUS_FAILURE;
-		goto done;
-	}
-
-	PRINTM(MMSG, "Dump data %s saved in %s\n", file_name, name);
-
-	pos = 0;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-	vfs_write(pfile, buf, buf_len, &pos);
-	set_fs(fs);
-#else
-	kernel_write(pfile, buf, buf_len, &pos);
-#endif
-	filp_close(pfile, NULL);
-
-	PRINTM(MMSG, "Dump data %s saved in %s successfully\n", file_name,
-	       name);
-
-done:
-	LEAVE();
-	return ret;
+	mem_dump_header header = {0};
+	t_u32 left_len = 0;
+	t_u32 len_to_copy = 0;
+	int total_len = 0;
+	t_u8 *dest = NULL;
+	int count = 0;
+	int pad = 0;
+	dest = phandle->fw_dump_buf + phandle->fw_dump_len;
+
+	left_len = len;
+	while (left_len) {
+		header.type = type;
+		if (left_len < 1024)
+			len_to_copy = left_len;
+		else
+			len_to_copy = 1024;
+		header.len = (t_u16)(len_to_copy + sizeof(t_u32));
+		header.start_addr = count * 1024;
+		moal_memcpy_ext(phandle, dest, &header, sizeof(mem_dump_header),
+				FW_DUMP_INFO_LEN - phandle->fw_dump_len);
+		dest += sizeof(mem_dump_header);
+		moal_memcpy_ext(phandle, dest, src, len_to_copy,
+				FW_DUMP_INFO_LEN - phandle->fw_dump_len -
+					sizeof(mem_dump_header));
+		dest += len_to_copy;
+		src += len_to_copy;
+		left_len -= len_to_copy;
+		// 8 bytes align
+		pad = (header.len & 7) ? (8 - (header.len & 7)) : 0;
+		dest += pad;
+		total_len += pad + len_to_copy + sizeof(mem_dump_header);
+		count++;
+	}
+	phandle->fw_dump_len += total_len;
+	PRINTM(MMSG, "type=%d, len=%d  block=%d  total=%d\n", type, len, count,
+	       total_len);
+	return total_len;
 }
 
 /**
- *  @brief This function dump drv info to file
+ *  @brief This function append end block to dump file
  *
  *  @param phandle   A pointer to moal_handle
- *  @param dir_name   A pointer to directory name
  *
- *  @return         N/A
+ *  return N/A
  */
-void woal_dump_drv_info(moal_handle *phandle, t_u8 *dir_name)
+void woal_append_end_block(moal_handle *phandle)
 {
-	int ret = 0;
-	struct file *pfile = NULL;
-	t_u8 *drv_buf = NULL;
-	t_u8 file_name[64];
-	t_u32 len = 0;
-	t_u32 total_len = 0;
-	moal_private *woal_handle = NULL;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	mm_segment_t fs;
-#endif
-	t_u32 drv_info_size = DRV_INFO_SIZE;
-
+	mem_dump_header header;
+	t_u8 *pos = phandle->fw_dump_buf + phandle->fw_dump_len;
 	ENTER();
-
-	PRINTM(MMSG, "=== START DRIVER INFO DUMP===");
-	memset(file_name, 0, sizeof(file_name));
-	if (phandle->second_mac)
-		sprintf(file_name, "%s/%s", dir_name, "file_drv_info_2");
-	else
-		sprintf(file_name, "%s/%s", dir_name, "file_drv_info");
-	pfile = filp_open(file_name, O_CREAT | O_RDWR, 0644);
-	if (IS_ERR(pfile)) {
-		PRINTM(MMSG,
-		       "Create file %s error, try create /var/file_drv_info",
-		       file_name);
-		pfile = filp_open("/var/file_drv_info", O_CREAT | O_RDWR, 0644);
-	} else {
-		PRINTM(MMSG, "DRV dump data in %s\n", file_name);
-	}
-	if (IS_ERR(pfile)) {
-		PRINTM(MMSG, "Create file_drv_info file failed\n");
-		goto done;
-	}
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	fs = get_fs();
-	set_fs(KERNEL_DS);
-#endif
-	woal_handle = woal_get_priv(phandle, MLAN_BSS_ROLE_ANY);
-
-	if (woal_handle != NULL) {
-		if (phandle->priv_num > 3)
-			drv_info_size +=
-				(phandle->priv_num - 3) * DRV_INFO_PER_INTF;
-		ret = moal_vmalloc(phandle, drv_info_size, &drv_buf);
-		if ((ret != MLAN_STATUS_SUCCESS) || !drv_buf) {
-			PRINTM(MERROR, "Error: vmalloc drv buffer failed!\n");
-			goto done;
-		}
-		len = woal_dump_moal_drv_info(phandle, drv_buf);
-		total_len += len;
-		len = woal_dump_mlan_drv_info(woal_handle, drv_buf + total_len);
-		total_len += len;
-		len = woal_dump_moal_hex(phandle, drv_buf + total_len);
-		total_len += len;
-		len = woal_dump_mlan_hex(woal_handle, drv_buf + total_len);
-		total_len += len;
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-		vfs_write(pfile, drv_buf, total_len, &pfile->f_pos);
-#else
-		kernel_write(pfile, drv_buf, total_len, &pfile->f_pos);
-#endif
-	}
-	PRINTM(MMSG, "Drv info total bytes = %ld (0x%lx)\n",
-	       (long int)total_len, (long unsigned int)total_len);
-	filp_close(pfile, NULL);
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
-	set_fs(fs);
-#endif
-	PRINTM(MMSG, "=== DRIVER INFO DUMP END===");
-done:
-	if (drv_buf)
-		moal_vfree(phandle, drv_buf);
+	memset(&header, 0, sizeof(header));
+	header.type = FW_DUMP_TYPE_ENDED;
+	header.len = 0;
+	moal_memcpy_ext(phandle, pos, &header, sizeof(mem_dump_header),
+			FW_DUMP_INFO_LEN - phandle->fw_dump_len);
+	phandle->fw_dump_len += sizeof(mem_dump_header);
+	PRINTM(MMSG, "fw dump total length is %ld\n",
+	       (long int)phandle->fw_dump_len);
 	LEAVE();
+	return;
 }
 
 /**
@@ -7902,6 +10355,8 @@ void woal_moal_debug_info(moal_private *priv, moal_handle *handle, u8 flag)
 		       atomic_read(&cardp->tx_cmd_urb_pending));
 		PRINTM(MERROR, "tx_data_urb_pending = %d\n",
 		       atomic_read(&cardp->tx_data_urb_pending));
+		PRINTM(MERROR, "tx_data2_urb_pending = %d\n",
+		       atomic_read(&cardp->tx_data2_urb_pending));
 #ifdef USB_CMD_DATA_EP
 		PRINTM(MERROR, "rx_cmd_urb_pending = %d\n",
 		       atomic_read(&cardp->rx_cmd_urb_pending));
@@ -7951,7 +10406,7 @@ void woal_moal_debug_info(moal_private *priv, moal_handle *handle, u8 flag)
 		PRINTM(MERROR, "carrier %s\n",
 		       ((netif_carrier_ok(priv->netdev)) ? "on" : "off"));
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-		for (i = 0; i < (priv->netdev->num_tx_queues); i++) {
+		for (i = 0; i < (int)(priv->netdev->num_tx_queues); i++) {
 			PRINTM(MERROR, "tx queue %d: %s\n", i,
 			       ((netif_tx_queue_stopped(
 					netdev_get_tx_queue(priv->netdev, i))) ?
@@ -7979,28 +10434,41 @@ void woal_moal_debug_info(moal_private *priv, moal_handle *handle, u8 flag)
 
 #ifdef PCIE
 	if (IS_PCIE(phandle->card_type)) {
-		if (phandle->ops.reg_dbg && (drvdbg & (MREG_D | MFW_D)))
-			phandle->ops.reg_dbg(phandle);
+#ifdef DEBUG_LEVEL1
+		if (phandle->ops.reg_dbg && (drvdbg & (MREG_D | MFW_D))) {
+			if (!phandle->event_fw_dump)
+				phandle->ops.reg_dbg(phandle);
+		}
+#endif
 	}
 #endif
 #ifdef SDIO
 	if (IS_SD(phandle->card_type)) {
 		if (flag && ((phandle->main_state == MOAL_END_MAIN_PROCESS) ||
 			     (phandle->main_state == MOAL_STATE_IDLE))) {
-			if (phandle->ops.reg_dbg && (drvdbg & (MREG_D | MFW_D)))
-				phandle->ops.reg_dbg(phandle);
+#ifdef DEBUG_LEVEL1
+			if (phandle->ops.reg_dbg &&
+			    (drvdbg & (MREG_D | MFW_D))) {
+				if (!phandle->event_fw_dump)
+					phandle->ops.reg_dbg(phandle);
+			}
+#endif
 		} else {
+#ifdef DEBUG_LEVEL1
 			if (drvdbg & (MREG_D | MFW_D)) {
-				phandle->reg_dbg = MTRUE;
-				queue_work(phandle->workqueue,
-					   &phandle->main_work);
+				if (!phandle->event_fw_dump) {
+					phandle->reg_dbg = MTRUE;
+					queue_work(phandle->workqueue,
+						   &phandle->main_work);
+				}
 			}
+#endif
 		}
 	}
 #endif
 #ifdef DEBUG_LEVEL1
-	if (drvdbg & MFW_D) {
-		drvdbg &= ~MFW_D;
+	if ((drvdbg & MFW_D) && !phandle->fw_dump_status) {
+		phandle->fw_dump_status = MTRUE;
 		phandle->fw_dbg = MTRUE;
 		queue_work(phandle->workqueue, &phandle->main_work);
 	}
@@ -8021,7 +10489,7 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	moal_handle *handle = NULL;
-	char country_name[] = "txpower_XX.bin";
+	char country_name[128];
 	char file_path[256];
 	char *last_slash = NULL;
 	char *fw_name = NULL;
@@ -8039,22 +10507,35 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
+	handle = priv->phandle;
+	memset(country_name, 0, sizeof(country_name));
+	if (handle->params.hw_name)
+		snprintf(country_name, sizeof(country_name),
+			 "%s_txpower_XX.bin", handle->params.hw_name);
+	else
+		memcpy(country_name, "txpower_XX.bin",
+		       strlen("txpower_XX.bin"));
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	if (fw_region)
-		strncpy(country_name, "rgpower_XX.bin",
-			strlen("rgpower_XX.bin"));
+	if (handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE) {
+		memset(country_name, 0, sizeof(country_name));
+		if (handle->params.hw_name)
+			snprintf(country_name, sizeof(country_name),
+				 "%s_rgpower_XX.bin", handle->params.hw_name);
+		else
+			memcpy(country_name, "rgpower_XX.bin",
+			       strlen("rgpower_XX.bin"));
+	}
 #endif
 #endif
-	handle = priv->phandle;
 
 	/* Replace XX with ISO 3166-1 alpha-2 country code */
-	strncpy(strstr(country_name, "XX"), country, strlen(country));
+	memcpy(strstr(country_name, "XX"), country, strlen(country));
 	fw_name = handle->params.fw_name;
 	memset(file_path, 0, sizeof(file_path));
 	/* file_path should be Null terminated */
 	if (fw_name) {
-		strncpy(file_path, fw_name, sizeof(file_path) - 1);
+		moal_memcpy(handle, file_path, fw_name, sizeof(file_path) - 1);
 		last_slash = strrchr(file_path, '/');
 		if (last_slash)
 			memset(last_slash + 1, 0,
@@ -8063,14 +10544,14 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
 		else
 			memset(file_path, 0, sizeof(file_path));
 	} else {
-		strncpy(file_path, "nxp/",
-			MIN((sizeof(file_path) - 1), strlen("nxp/")));
+		memcpy(file_path, "nxp/",
+		       MIN((sizeof(file_path) - 1), strlen("nxp/")));
 	}
 
 	if ((strlen(file_path) + strlen(country_name)) <
 	    (sizeof(file_path) - 1))
 		strncpy(file_path + strlen(file_path), country_name,
-			sizeof(file_path) - strlen(file_path));
+			sizeof(file_path) - strlen(file_path) - 1);
 	else {
 		PRINTM(MERROR,
 		       "file path buffer too small, fail to dnld power table\n");
@@ -8084,9 +10565,15 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	/* Try download WW rgpowertable */
-	if (fw_region && (ret == MLAN_STATUS_FILE_ERR)) {
-		strncpy(country_name, "rgpower_WW.bin",
-			strlen("rgpower_WW.bin"));
+	if ((handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE) &&
+	    (ret == MLAN_STATUS_FILE_ERR)) {
+		memset(country_name, 0, sizeof(country_name));
+		if (handle->params.hw_name)
+			snprintf(country_name, sizeof(country_name),
+				 "%s_rgpower_WW.bin", handle->params.hw_name);
+		else
+			memcpy(country_name, "rgpower_WW.bin",
+			       strlen("rgpower_WW.bin"));
 		last_slash = strrchr(file_path, '/');
 		if (last_slash)
 			memset(last_slash + 1, 0,
@@ -8094,16 +10581,24 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
 				       (last_slash - file_path));
 		else
 			memset(file_path, 0, sizeof(file_path));
-		strncpy(file_path + strlen(file_path), country_name,
-			strlen(country_name));
-#if defined(STA_CFG80211) || defined(UAP_CFG80211)
-		handle->country_code[0] = '0';
-		handle->country_code[1] = '0';
-#endif
+		if ((strlen(file_path) + strlen(country_name)) <
+		    (sizeof(file_path) - 1))
+			strncpy(file_path + strlen(file_path), country_name,
+				sizeof(file_path) - strlen(file_path) - 1);
+		else {
+			PRINTM(MERROR,
+			       "file path buffer too small, fail to dnld power table\n");
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
 		PRINTM(MMSG, "Trying again download country_power_tble: %s\n",
 		       file_path);
 		ret = woal_set_user_init_data(handle, COUNTRY_POWER_TABLE,
 					      MOAL_IOCTL_WAIT, file_path);
+		if (!ret) {
+			handle->country_code[0] = '0';
+			handle->country_code[1] = '0';
+		}
 	}
 #endif
 #endif
@@ -8119,24 +10614,102 @@ mlan_status woal_request_country_power_table(moal_private *priv, char *country)
  *
  *  @return       packets received
  */
-int woal_netdev_poll_rx(struct napi_struct *napi, int budget)
+static int woal_netdev_poll_rx(struct napi_struct *napi, int budget)
 {
 	moal_handle *handle = container_of(napi, moal_handle, napi_rx);
 	t_u8 recv = budget;
 
 	ENTER();
 	if (handle->surprise_removed == MTRUE) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		if (false == napi_complete(napi))
+			PRINTM(MINFO, "%s: napi_complete with false \n",
+			       __func__);
+#else
 		napi_complete(napi);
+#endif
 		LEAVE();
 		return 0;
 	}
-	mlan_rx_process(handle->pmlan_adapter, &recv);
-	if (recv < budget)
+	if (MLAN_STATUS_SUCCESS !=
+	    mlan_rx_process(handle->pmlan_adapter, &recv))
+		PRINTM(MERROR, "%s: mlan_rx_process failed \n", __func__);
+	if (recv < budget) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 10, 0)
+		if (false == napi_complete(napi))
+			PRINTM(MINFO, "%s: napi_complete with false \n",
+			       __func__);
+#else
 		napi_complete(napi);
+#endif
+	}
 	LEAVE();
 	return recv;
 }
 
+/**
+ *  @brief This workqueue function handles set multicast_list
+ *
+ *  @param work    A pointer to work_struct
+ *
+ *  @return        N/A
+ */
+t_void woal_mclist_work_queue(struct work_struct *work)
+{
+	moal_private *priv = container_of(work, moal_private, mclist_work);
+	woal_request_set_multicast_list(priv, priv->netdev);
+}
+
+#ifdef STA_CFG80211
+/**
+ *  @brief This workqueue function handles woal scan timeout work
+ *
+ *  @param work    A pointer to work_struct
+ *
+ *  @return        N/A
+ */
+t_void woal_scan_timeout_handler(struct work_struct *work)
+{
+	struct delayed_work *delayed_work = to_delayed_work(work);
+	moal_handle *handle =
+		container_of(delayed_work, moal_handle, scan_timeout_work);
+	unsigned long flags;
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_STA);
+	t_u8 auto_fw_dump = MFALSE;
+
+	ENTER();
+
+	if (IS_STA_CFG80211(handle->params.cfg80211_wext)) {
+		if (handle->scan_request && handle->fake_scan_complete) {
+			PRINTM(MMSG, "wlan: Send fake scan result\n");
+			if (priv)
+				woal_inform_bss_from_scan_result(priv, NULL,
+								 MOAL_NO_WAIT);
+			spin_lock_irqsave(&handle->scan_req_lock, flags);
+			woal_cfg80211_scan_done(handle->scan_request, MFALSE);
+			handle->scan_request = NULL;
+			spin_unlock_irqrestore(&handle->scan_req_lock, flags);
+		} else if (handle->scan_request) {
+			PRINTM(MMSG, "wlan: scan timeout!\n");
+#ifdef DEBUG_LEVEL1
+			if (drvdbg & MFW_D)
+				auto_fw_dump = MTRUE;
+#endif
+			if (priv) {
+				woal_mlan_debug_info(priv);
+				woal_moal_debug_info(priv, NULL, MFALSE);
+			}
+			handle->driver_status = MTRUE;
+			if (!auto_fw_dump && !handle->fw_dump && priv)
+				woal_process_hang(priv->phandle);
+			wifi_status = WIFI_STATUS_SCAN_TIMEOUT;
+		}
+	}
+
+	LEAVE();
+}
+#endif
+
 /**
  *  @brief This workqueue function handles woal event queue
  *
@@ -8174,6 +10747,17 @@ t_void woal_evt_work_queue(struct work_struct *work)
 						     &evt->chan_info);
 #endif
 #endif
+#endif
+			break;
+		case WOAL_EVENT_RX_MGMT_PKT:
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+			priv = evt->priv;
+			mutex_lock(&priv->wdev->mtx);
+			cfg80211_rx_mlme_mgmt(priv->netdev, evt->evt.event_buf,
+					      evt->evt.event_len);
+			mutex_unlock(&priv->wdev->mtx);
+#endif
 #endif
 			break;
 		case WOAL_EVENT_BGSCAN_STOP:
@@ -8194,10 +10778,34 @@ t_void woal_evt_work_queue(struct work_struct *work)
 
 		case WOAL_EVENT_ASSOC_RESP:
 			woal_host_mlme_process_assoc_resp(
-				(moal_private *)evt->priv, &evt->assoc_resp);
+				(moal_private *)evt->priv, &evt->assoc_info);
+			break;
+#endif
+#endif
+#ifdef UAP_SUPPORT
+		case WOAL_EVENT_CHAN_RPT:
+			woal_process_chan_event((moal_private *)evt->priv,
+						WOAL_EVENT_CHAN_RPT,
+						evt->radar_info.channel,
+						evt->radar_info.radar);
+			break;
+		case WOAL_EVENT_RADAR:
+			woal_process_chan_event((moal_private *)evt->priv,
+						WOAL_EVENT_RADAR,
+						evt->radar_info.channel,
+						evt->radar_info.radar);
+			break;
+#endif
+#ifdef UAP_CFG80211
+#if KERNEL_VERSION(3, 12, 0) <= CFG80211_VERSION_CODE
+		case WOAL_EVENT_CANCEL_CHANRPT:
+			woal_process_cancel_chanrpt_event(
+				(moal_private *)evt->priv);
 			break;
 #endif
 #endif
+		default:
+			break;
 		}
 		kfree(evt);
 		spin_lock_irqsave(&handle->evt_lock, flags);
@@ -8215,13 +10823,6 @@ t_void woal_evt_work_queue(struct work_struct *work)
 t_void woal_rx_work_queue(struct work_struct *work)
 {
 	moal_handle *handle = container_of(work, moal_handle, rx_work);
-#ifdef STA_CFG80211
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
-#if CFG80211_VERSION_CODE < KERNEL_VERSION(3, 14, 6)
-	moal_private *priv;
-#endif
-#endif
-#endif
 	wifi_timeval start_timeval;
 	wifi_timeval end_timeval;
 
@@ -8230,9 +10831,17 @@ t_void woal_rx_work_queue(struct work_struct *work)
 		LEAVE();
 		return;
 	}
-
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	if (handle->cfg80211_suspend == MTRUE) {
+		LEAVE();
+		return;
+	}
+#endif
+#endif
 	woal_get_monotonic_time(&start_timeval);
-	mlan_rx_process(handle->pmlan_adapter, NULL);
+	if (MLAN_STATUS_SUCCESS != mlan_rx_process(handle->pmlan_adapter, NULL))
+		PRINTM(MERROR, "%s: mlan_rx_process failed \n", __func__);
 
 	woal_get_monotonic_time(&end_timeval);
 	handle->rx_time += (t_u64)(timeval_to_usec(end_timeval) -
@@ -8247,6 +10856,54 @@ t_void woal_rx_work_queue(struct work_struct *work)
 	LEAVE();
 }
 
+/**
+ *  @brief This function dequeue pkt from list
+ *
+ *  @param list    A pointer to struct sk_buff_head
+ *
+ *  @return        skb buffer
+ */
+
+struct sk_buff *woal_skb_dequeue_spinlock(struct sk_buff_head *list)
+{
+	struct sk_buff *result;
+
+	spin_lock_bh(&list->lock);
+	result = __skb_dequeue(list);
+	spin_unlock_bh(&list->lock);
+	return result;
+}
+
+/**
+ *  @brief This workqueue function handles rx_work_process
+ *
+ *  @param work    A pointer to work_struct
+ *
+ *  @return        N/A
+ */
+t_void woal_tx_work_handler(struct work_struct *work)
+{
+	moal_handle *handle = container_of(work, moal_handle, tx_work);
+	moal_private *priv = NULL;
+	int i = 0;
+	struct sk_buff *skb = NULL;
+
+	ENTER();
+	if (handle->surprise_removed == MTRUE) {
+		LEAVE();
+		return;
+	}
+
+	for (i = 0; i < MIN(handle->priv_num, MLAN_MAX_BSS_NUM); i++) {
+		priv = handle->priv[i];
+		while ((skb = woal_skb_dequeue_spinlock(&priv->tx_q)) != NULL) {
+			woal_start_xmit(priv, skb);
+		}
+	}
+
+	LEAVE();
+}
+
 /**
  *  @brief This workqueue function handles main_process
  *
@@ -8277,7 +10934,8 @@ t_void woal_main_work_queue(struct work_struct *work)
 	}
 	if (handle->fw_dbg == MTRUE) {
 		handle->fw_dbg = MFALSE;
-		handle->ops.dump_fw_info(handle);
+		if (handle->ops.dump_fw_info)
+			handle->ops.dump_fw_info(handle);
 		LEAVE();
 		return;
 	}
@@ -8306,12 +10964,148 @@ t_void woal_main_work_queue(struct work_struct *work)
 #endif
 	handle->main_state = MOAL_START_MAIN_PROCESS;
 	/* Call MLAN main process */
-	mlan_main_process(handle->pmlan_adapter);
+	(void)mlan_main_process(handle->pmlan_adapter);
 	handle->main_state = MOAL_END_MAIN_PROCESS;
 
 	LEAVE();
 }
 
+#ifdef IMX_SUPPORT
+/**
+ *  @brief This function allocates the interrupt line to wakeup
+ *         the host, and initializes the device for wakeup
+ *
+ *  @param handle  A pointer to moal_handle structure
+ *
+ *  @return        N/A
+ */
+void woal_regist_oob_wakeup_irq(moal_handle *handle)
+{
+	int ret;
+	struct device *dev = handle->hotplug_device;
+	struct device_node *node;
+
+	ENTER();
+
+	node = of_find_compatible_node(NULL, NULL, "nxp,wifi-wake-host");
+	if (!node)
+		goto err_exit;
+
+	handle->irq_oob_wakeup = irq_of_parse_and_map(node, 0);
+	if (!handle->irq_oob_wakeup) {
+		dev_dbg(dev, "fail to parse irq_oob_wakeup from device tree\n");
+		goto err_exit;
+	}
+
+	ret = devm_request_threaded_irq(dev, handle->irq_oob_wakeup, NULL,
+					woal_oob_wakeup_irq_handler,
+					IRQF_SHARED | IRQF_ONESHOT,
+					"wifi_oob_wakeup", handle);
+	if (ret) {
+		dev_err(dev, "Failed to request irq_oob_wakeup %d (%d)\n",
+			handle->irq_oob_wakeup, ret);
+		goto err_exit;
+	}
+
+	disable_irq(handle->irq_oob_wakeup);
+
+	LEAVE();
+	return;
+
+err_exit:
+	handle->irq_oob_wakeup = -1;
+}
+
+/**
+ *  @brief This function frees the wakeup interrupt line
+ *
+ *  @param handle  A pointer to moal_handle structure
+ *
+ *  @return        N/A
+ */
+void woal_unregist_oob_wakeup_irq(moal_handle *handle)
+{
+	struct device *dev = handle->hotplug_device;
+
+	ENTER();
+	if (handle->irq_oob_wakeup >= 0) {
+		devm_free_irq(dev, handle->irq_oob_wakeup, handle);
+	}
+	LEAVE();
+}
+
+/**
+ *  @brief This function disables power management wakeup
+ *
+ *  @param handle  A pointer to moal_handle structure
+ *
+ *  @return        N/A
+ */
+void woal_disable_oob_wakeup_irq(moal_handle *handle)
+{
+	ENTER();
+
+	if (handle->irq_oob_wakeup >= 0) {
+		if (handle->wake_by_wifi)
+			disable_irq_wake(handle->irq_oob_wakeup);
+		else {
+			disable_irq_wake(handle->irq_oob_wakeup);
+			disable_irq(handle->irq_oob_wakeup);
+		}
+	}
+
+	LEAVE();
+}
+
+/**
+ *  @brief This function enables power management wakeup
+ *
+ *  @param handle  A pointer to moal_handle structure
+ *
+ *  @return        N/A
+ */
+void woal_enable_oob_wakeup_irq(moal_handle *handle)
+{
+	ENTER();
+
+	/* Enable platform specific wakeup interrupt */
+	if (handle->irq_oob_wakeup >= 0) {
+		handle->wake_by_wifi = false;
+		enable_irq(handle->irq_oob_wakeup);
+		enable_irq_wake(handle->irq_oob_wakeup);
+	}
+
+	LEAVE();
+}
+
+/**
+ *  @brief This function will be called when the wakeup IRQ occurs
+ *
+ *  @param irq     Wakeup interrupt line
+ *  @param priv    A void pointer to store moal_handle structure pointer
+ *
+ *  @return        Returns status of interrupt handler.
+ */
+irqreturn_t woal_oob_wakeup_irq_handler(int irq, void *priv)
+{
+	moal_handle *handle = priv;
+	struct device *dev = handle->hotplug_device;
+
+	ENTER();
+
+	dev_dbg(dev, "%s: OOB wakeup by wifi", __func__);
+	handle->wake_by_wifi = true;
+	disable_irq_nosync(irq);
+
+	/* Notify PM core we are wakeup source */
+	pm_wakeup_event(dev, 0);
+	pm_system_wakeup();
+
+	LEAVE();
+	return IRQ_HANDLED;
+}
+#endif /* IMX_SUPPORT */
+
 /**
  * @brief This function adds the card. it will probe the
  *      card, allocate the mlan_private and initialize the device.
@@ -8378,7 +11172,27 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 	}
 
 	/* Init module parameters */
-	woal_init_module_param(handle);
+	if (woal_init_module_param(handle)) {
+		PRINTM(MERROR, "Fail to load module parameter file\n");
+		goto err_kmalloc;
+	}
+	if (!handle->params.drv_mode) {
+		PRINTM(MMSG, "wlan: stop init_adapter, drv_mode=%d\n",
+		       handle->params.drv_mode);
+		goto err_kmalloc;
+	}
+#ifdef IMX_SUPPORT
+#ifdef SDIO
+	if (IS_SD(handle->card_type)) {
+		moal_extflg_set(handle, EXT_TX_WORK);
+		moal_extflg_set(handle, EXT_TX_SKB_CLONE);
+	}
+#endif
+#endif
+
+#ifdef DEBUG_LEVEL1
+	drvdbg = handle->params.drvdbg;
+#endif
 
 	if (handle->params.mac_addr
 #ifdef MFG_CMD_SUPPORT
@@ -8398,7 +11212,10 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 	}
 
 	/* Get card info */
-	woal_get_card_info(handle);
+	if (woal_get_card_info(handle)) {
+		PRINTM(MERROR, "Fail to get card info\n");
+		goto err_kmalloc;
+	}
 	/** Get card revision */
 	handle->ops.get_fw_name(handle);
 #ifdef STA_SUPPORT
@@ -8500,6 +11317,17 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 	INIT_LIST_HEAD(&handle->evt_queue);
 	spin_lock_init(&handle->evt_lock);
 
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	MLAN_INIT_WORK(&handle->regulatory_work, woal_regulatory_work_queue);
+#endif
+#endif
+
+#ifdef STA_CFG80211
+	INIT_DELAYED_WORK(&handle->scan_timeout_work,
+			  woal_scan_timeout_handler);
+#endif
+
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	MLAN_INIT_WORK(&handle->host_mlme_work, woal_host_mlme_work_queue);
@@ -8514,25 +11342,50 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 		handle->rx_workqueue = create_workqueue("MOAL_RX_WORKQ");
 #else
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
-		handle->rx_workqueue = alloc_workqueue(
-			"MOAL_RX_WORK_QUEUE",
+		handle->rx_workqueue = alloc_workqueue(
+			"MOAL_RX_WORK_QUEUE",
+			WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
+#else
+		handle->rx_workqueue = create_workqueue("MOAL_RX_WORK_QUEUE");
+#endif
+#endif
+		if (!handle->rx_workqueue) {
+			woal_terminate_workqueue(handle);
+			goto err_kmalloc;
+		}
+		MLAN_INIT_WORK(&handle->rx_work, woal_rx_work_queue);
+	}
+#define NAPI_BUDGET 64
+	if (moal_extflg_isset(handle, EXT_NAPI)) {
+		init_dummy_netdev(&handle->napi_dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0)
+		netif_napi_add(&handle->napi_dev, &handle->napi_rx,
+			       woal_netdev_poll_rx);
+#else
+		netif_napi_add(&handle->napi_dev, &handle->napi_rx,
+			       woal_netdev_poll_rx, NAPI_BUDGET);
+#endif
+		napi_enable(&handle->napi_rx);
+	}
+
+	if (moal_extflg_isset(handle, EXT_TX_WORK)) {
+		/* Create workqueue for tx process */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+		handle->tx_workqueue = create_workqueue("MOAL_TX_WORKQ");
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+		handle->tx_workqueue = alloc_workqueue(
+			"MOAL_TX_WORK_QUEUE",
 			WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
 #else
-		handle->rx_workqueue = create_workqueue("MOAL_RX_WORK_QUEUE");
+		handle->tx_workqueue = create_workqueue("MOAL_TX_WORK_QUEUE");
 #endif
 #endif
-		if (!handle->rx_workqueue) {
+		if (!handle->tx_workqueue) {
 			woal_terminate_workqueue(handle);
 			goto err_kmalloc;
 		}
-		MLAN_INIT_WORK(&handle->rx_work, woal_rx_work_queue);
-	}
-#define NAPI_BUDGET 64
-	if (moal_extflg_isset(handle, EXT_NAPI)) {
-		init_dummy_netdev(&handle->napi_dev);
-		netif_napi_add(&handle->napi_dev, &handle->napi_rx,
-			       woal_netdev_poll_rx, NAPI_BUDGET);
-		napi_enable(&handle->napi_rx);
+		MLAN_INIT_WORK(&handle->tx_work, woal_tx_work_handler);
 	}
 
 #ifdef REASSOCIATION
@@ -8555,7 +11408,7 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 	}
 	woal_update_firmware_name(handle);
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 	wakeup_source_init(&handle->ws, "mwlan");
 #else
 	wake_lock_init(&handle->wake_lock, WAKE_LOCK_SUSPEND, "mwlan");
@@ -8567,7 +11420,7 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 		PRINTM(MFATAL, "Firmware Init Failed\n");
 		goto err_init_fw;
 	}
-
+	device_init_wakeup(dev, true);
 #ifdef SD8887
 	if (IS_SD8887(handle->card_type)) {
 		union {
@@ -8596,7 +11449,7 @@ moal_handle *woal_add_card(void *card, struct device *dev, moal_if_ops *if_ops,
 						 handle->init_wait_q_woken);
 	}
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 	wakeup_source_trash(&handle->ws);
 #else
 	wake_lock_destroy(&handle->wake_lock);
@@ -8656,6 +11509,7 @@ mlan_status woal_remove_card(void *card)
 	}
 	if (!handle)
 		goto exit_remove;
+	device_init_wakeup(handle->hotplug_device, false);
 #ifdef MFG_CMD_SUPPORT
 	if (handle->params.mfg_mode == MLAN_INIT_PARA_ENABLED
 #if defined(USB)
@@ -8672,10 +11526,7 @@ mlan_status woal_remove_card(void *card)
 		woal_process_rf_test_mode(handle, MFG_CMD_UNSET_TEST_MODE);
 	handle->surprise_removed = MTRUE;
 
-	flush_workqueue(handle->workqueue);
-	flush_workqueue(handle->evt_workqueue);
-	if (handle->rx_workqueue)
-		flush_workqueue(handle->rx_workqueue);
+	woal_flush_workqueue(handle);
 
 	if (moal_extflg_isset(handle, EXT_NAPI)) {
 		napi_disable(&handle->napi_rx);
@@ -8719,6 +11570,12 @@ mlan_status woal_remove_card(void *card)
 		       atomic_read(&handle->tx_pending),
 		       atomic_read(&handle->ioctl_pending));
 	}
+	unregister_inetaddr_notifier(&handle->woal_notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	unregister_inet6addr_notifier(&handle->woal_inet6_notifier);
+#endif
+#endif
 
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
@@ -8741,10 +11598,29 @@ mlan_status woal_remove_card(void *card)
 #endif
 #endif
 #endif
+	if (handle->tp_acnt.on) {
+		handle->tp_acnt.on = 0;
+		handle->tp_acnt.drop_point = 0;
+		if (handle->is_tp_acnt_timer_set) {
+			woal_cancel_timer(&handle->tp_acnt.timer);
+			handle->is_tp_acnt_timer_set = MFALSE;
+		}
+	}
+
 	/* Remove interface */
 	for (i = 0; i < MIN(MLAN_MAX_BSS_NUM, handle->priv_num); i++)
 		woal_remove_interface(handle, i);
 
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+	/* Unregister and detach connected radiotap net device */
+	if (handle->mon_if) {
+		netif_device_detach(handle->mon_if->mon_ndev);
+		if (handle->mon_if->mon_ndev->reg_state == NETREG_REGISTERED)
+			unregister_netdev(handle->mon_if->mon_ndev);
+		handle->mon_if = NULL;
+	}
+#endif
+
 	woal_terminate_workqueue(handle);
 
 #ifdef UAP_CFG80211
@@ -8768,6 +11644,13 @@ mlan_status woal_remove_card(void *card)
 	while (handle->reassoc_thread.pid)
 		woal_sched_timeout(2);
 #endif /* REASSOCIATION */
+
+	PRINTM(MINFO, "Free FW dump timer\n");
+	if (handle->is_fw_dump_timer_set) {
+		woal_cancel_timer(&handle->fw_dump_timer);
+		handle->is_fw_dump_timer_set = MFALSE;
+	}
+
 #ifdef CONFIG_PROC_FS
 	woal_proc_exit(handle);
 #endif
@@ -8775,7 +11658,7 @@ mlan_status woal_remove_card(void *card)
 	PRINTM(MINFO, "unregister device\n");
 	handle->ops.unregister_dev(handle);
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 	wakeup_source_trash(&handle->ws);
 #else
 	wake_lock_destroy(&handle->wake_lock);
@@ -8827,7 +11710,11 @@ mlan_status woal_switch_drv_mode(moal_handle *handle, t_u32 mode)
 
 	/* Reset all interfaces */
 	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
-	woal_reset_intf(priv, MOAL_IOCTL_WAIT, MTRUE);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_reset_intf(priv, MOAL_IOCTL_WAIT, MTRUE)) {
+		PRINTM(MERROR, "woal_reset_inf failed!\n");
+		goto exit;
+	}
 
 	status = woal_shutdown_fw(priv, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
@@ -8861,6 +11748,13 @@ mlan_status woal_switch_drv_mode(moal_handle *handle, t_u32 mode)
 		       atomic_read(&handle->ioctl_pending));
 	}
 
+	unregister_inetaddr_notifier(&handle->woal_notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	unregister_inet6addr_notifier(&handle->woal_inet6_notifier);
+#endif
+#endif
+
 	/* Remove interface */
 	for (i = 0; i < MIN(MLAN_MAX_BSS_NUM, handle->priv_num); i++)
 		woal_remove_interface(handle, i);
@@ -8904,17 +11798,18 @@ mlan_status woal_switch_drv_mode(moal_handle *handle, t_u32 mode)
 }
 #endif
 
-#ifdef SDIO_MMC
 #define FW_POLL_TRIES 100
+#ifdef SDIO
 
 /**
  *  @brief This function reload fw
  *
  *  @param handle   A pointer to moal_handle structure
+ *  @param mode     FW_RELOAD_SDIO_INBAND_RESET or FW_RELOAD_SDIO_HW_RESET
  *
  *  @return        0--success, otherwise failure
  */
-static int woal_reset_and_reload_fw(moal_handle *handle)
+static int woal_reset_and_reload_fw(moal_handle *handle, t_u8 mode)
 {
 	int ret = 0, tries = 0;
 	t_u32 value = 1;
@@ -8922,21 +11817,25 @@ static int woal_reset_and_reload_fw(moal_handle *handle)
 	t_u8 reset_val = handle->card_info->fw_reset_val;
 
 	ENTER();
-
-	if (!IS_SD9098(handle->card_type) && !IS_SD9097(handle->card_type)) {
-		mlan_pm_wakeup_card(handle->pmlan_adapter, MTRUE);
-		/** wait SOC fully wake up */
-		for (tries = 0; tries < FW_POLL_TRIES; ++tries) {
-			ret = handle->ops.write_reg(handle, reset_reg, 0xba);
-			if (ret == MLAN_STATUS_SUCCESS) {
-				handle->ops.read_reg(handle, reset_reg, &value);
-				if (value == 0xba) {
-					PRINTM(MMSG, "FW wake up\n");
-					break;
-				}
+#ifdef SDIO_MMC
+	if (mode == FW_RELOAD_SDIO_HW_RESET) {
+		PRINTM(MCMND, "woal_sdio_reset_fw...\n");
+		woal_sdio_reset_hw(handle);
+		goto reload_fw;
+	}
+#endif
+	mlan_pm_wakeup_card(handle->pmlan_adapter, MTRUE);
+	/** wait SOC fully wake up */
+	for (tries = 0; tries < FW_POLL_TRIES; ++tries) {
+		ret = handle->ops.write_reg(handle, reset_reg, 0xba);
+		if (ret == MLAN_STATUS_SUCCESS) {
+			handle->ops.read_reg(handle, reset_reg, &value);
+			if (value == 0xba) {
+				PRINTM(MMSG, "FW wake up\n");
+				break;
 			}
-			udelay(1000);
 		}
+		udelay(1000);
 	}
 	/* Write register to notify FW */
 	if (handle->ops.write_reg(handle, reset_reg, reset_val) !=
@@ -8945,10 +11844,10 @@ static int woal_reset_and_reload_fw(moal_handle *handle)
 		ret = -EFAULT;
 		goto done;
 	}
-#if defined(SD9098) || defined(SD9097)
-	if (IS_SD9098(handle->card_type) || IS_SD9097(handle->card_type))
+	if (IS_SD9098(handle->card_type) || IS_SD9097(handle->card_type) ||
+	    IS_SDIW62X(handle->card_type) || IS_SD9177(handle->card_type) ||
+	    IS_SDAW693(handle->card_type))
 		handle->ops.write_reg(handle, 0x00, 0x10);
-#endif
 	/* Poll register around 100 ms */
 	for (tries = 0; tries < FW_POLL_TRIES; ++tries) {
 		handle->ops.read_reg(handle, reset_reg, &value);
@@ -8964,8 +11863,8 @@ static int woal_reset_and_reload_fw(moal_handle *handle)
 		ret = -EFAULT;
 		goto done;
 	}
-	if (!IS_SD9098(handle->card_type) && !IS_SD9097(handle->card_type))
-		mlan_pm_wakeup_card(handle->pmlan_adapter, MFALSE);
+	mlan_pm_wakeup_card(handle->pmlan_adapter, MFALSE);
+reload_fw:
 	/* Download FW */
 	ret = woal_request_fw(handle);
 	if (ret) {
@@ -8979,6 +11878,68 @@ static int woal_reset_and_reload_fw(moal_handle *handle)
 }
 #endif
 
+#ifdef PCIE
+/**
+ *  @brief This function reload fw for pcie
+ *
+ *  @param handle   A pointer to moal_handle structure
+ *
+ *  @return        0--success, otherwise failure
+ */
+static int woal_pcie_reset_and_reload_fw(moal_handle *handle)
+{
+	int ret = 0, tries = 0;
+	t_u32 value = 1;
+	t_u32 reset_reg = handle->card_info->fw_reset_reg;
+	t_u8 reset_val = handle->card_info->fw_reset_val;
+
+	ENTER();
+	if (!IS_PCIE9098(handle->card_type) &&
+	    !IS_PCIEIW62X(handle->card_type) &&
+	    !IS_PCIEAW693(handle->card_type) &&
+	    !IS_PCIE9097(handle->card_type)) {
+		PRINTM(MERROR, "HW don't support PCIE in-band reset\n");
+		return -EFAULT;
+	}
+
+	mlan_pm_wakeup_card(handle->pmlan_adapter, MTRUE);
+
+	/* Write register to notify FW */
+	if (handle->ops.write_reg(handle, reset_reg, reset_val) !=
+	    MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "Failed to write reregister.\n");
+		ret = -EFAULT;
+		goto done;
+	}
+	/* Poll register around 100 ms */
+	for (tries = 0; tries < FW_POLL_TRIES; ++tries) {
+		handle->ops.read_reg(handle, reset_reg, &value);
+		if (value == 0)
+			/* FW is ready */
+			break;
+		udelay(1000);
+	}
+
+	if (value) {
+		PRINTM(MERROR, "Failed to poll FW reset register %X=0x%x\n",
+		       reset_reg, value);
+		ret = -EFAULT;
+		goto done;
+	}
+	mlan_pm_wakeup_card(handle->pmlan_adapter, MFALSE);
+	/* Download FW */
+	ret = woal_request_fw(handle);
+	if (ret) {
+		ret = -EFAULT;
+		goto done;
+	}
+	PRINTM(MMSG, "PCIE FW Reload successfully.");
+done:
+	LEAVE();
+	return ret;
+}
+#endif
+
 /**
  *  @brief This function reload fw
  *
@@ -9002,15 +11963,59 @@ static int woal_reload_fw(moal_handle *handle)
 	return ret;
 }
 
-void woal_pre_reset(moal_handle *handle)
+/**
+ *  @brief This function handle the pre_reset
+ *
+ *  @param handle   A pointer to moal_handle structure
+ *
+ *  @return        NULL;
+ */
+static void woal_pre_reset(moal_handle *handle)
 {
-	int intf_num;
+	t_u8 driver_status = handle->driver_status;
+	t_u8 i;
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_STA);
+	mlan_debug_info *info = &(handle->debug_info);
+	int ioctl_pending = 0;
+
 	ENTER();
-	/** detach network interface */
-	for (intf_num = 0; intf_num < handle->priv_num; intf_num++) {
-		woal_stop_queue(handle->priv[intf_num]->netdev);
-		netif_device_detach(handle->priv[intf_num]->netdev);
+	if (!driver_status && priv)
+		woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
+	handle->driver_status = MTRUE;
+
+	if (!driver_status)
+		woal_sched_timeout_uninterruptible(MOAL_TIMER_1S);
+
+	// wait for IOCTL return
+	if (!driver_status && priv) {
+		for (i = 0; i < 5; i++) {
+			if (woal_get_debug_info(priv, MOAL_IOCTL_WAIT, info))
+				PRINTM(MERROR,
+				       "Could not retrieve debug information from MLAN\n");
+			ioctl_pending = atomic_read(&handle->ioctl_pending);
+			if (!info->pending_cmd && !ioctl_pending) {
+				PRINTM(MCMND,
+				       "fw_reload: No pending command and IOCTL\n");
+				break;
+			}
+			woal_sched_timeout_uninterruptible(MOAL_TIMER_1S);
+		}
 	}
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
+	/* Remove virtual interface */
+	woal_remove_virtual_interface(handle);
+#endif
+#endif
+#endif
+	woal_clean_up(handle);
+	/** mask host interrupt from firmware */
+	mlan_disable_host_int(handle->pmlan_adapter);
+	/** cancel all pending commands */
+	mlan_ioctl(handle->pmlan_adapter, NULL);
+	woal_flush_workqueue(handle);
+
 	handle->fw_reload = MTRUE;
 	woal_update_firmware_name(handle);
 #ifdef USB
@@ -9020,11 +12025,24 @@ void woal_pre_reset(moal_handle *handle)
 	LEAVE();
 }
 
-void woal_post_reset(moal_handle *handle)
+/**
+ *  @brief This function handle pose_reset
+ *
+ *  @param handle   A pointer to moal_handle structure
+ *
+ *  @return        NULL;
+ */
+static void woal_post_reset(moal_handle *handle)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc = NULL;
 	int intf_num;
+	char str_buf[MLAN_MAX_VER_STR_LEN];
+	mlan_fw_info fw_info;
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	t_u8 country_code[COUNTRY_CODE_LEN];
+#endif
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 #if defined(STA_WEXT) || defined(UAP_WEXT)
@@ -9036,7 +12054,6 @@ void woal_post_reset(moal_handle *handle)
 	ENTER();
 	/** un-block IOCTL */
 	handle->fw_reload = MFALSE;
-	handle->driver_status = MFALSE;
 	/* Restart the firmware */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req) {
@@ -9047,44 +12064,143 @@ void woal_post_reset(moal_handle *handle)
 		req->action = MLAN_ACT_SET;
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_request_ioctl(woal_get_priv(handle, MLAN_BSS_ROLE_ANY),
-				       req, MOAL_IOCTL_WAIT)) {
+				       req, MOAL_IOCTL_WAIT_TIMEOUT)) {
+			PRINTM(MERROR, "%s: warm reset failed \n", __func__);
 			kfree(req);
 			goto done;
 		}
 		kfree(req);
 	}
+#ifdef DEBUG_LEVEL1
+	drvdbg = handle->params.drvdbg;
+#endif
+	handle->fw_dump_status = MFALSE;
+	handle->driver_status = MFALSE;
 	handle->hardware_status = HardwareStatusReady;
+	handle->remain_on_channel = MFALSE;
+#ifdef STA_CFG80211
+	handle->scan_timeout = SCAN_TIMEOUT_25S;
+#endif
+	if (priv &&
+	    (MLAN_STATUS_SUCCESS !=
+	     woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info))) {
+		PRINTM(MERROR, "%s: get_fw_info failed \n", __func__);
+	}
+	woal_get_version(handle, str_buf, sizeof(str_buf) - 1);
+	PRINTM(MMSG, "wlan: version = %s\n", str_buf);
+	if (!handle->wifi_hal_flag) {
+		PRINTM(MMSG, "wlan: post_reset remove/add interface\n");
+		handle->surprise_removed = MTRUE;
+		for (intf_num = 0;
+		     intf_num < MIN(MLAN_MAX_BSS_NUM, handle->priv_num);
+		     intf_num++)
+			woal_remove_interface(handle, intf_num);
+		handle->priv_num = 0;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+		/* Unregister wiphy device and free */
+		if (handle->wiphy) {
+			wiphy_unregister(handle->wiphy);
+			woal_cfg80211_free_bands(handle->wiphy);
+			wiphy_free(handle->wiphy);
+			handle->wiphy = NULL;
+		}
+#endif
+		handle->surprise_removed = MFALSE;
+
+		for (intf_num = 0; intf_num < handle->drv_mode.intf_num;
+		     intf_num++) {
+			if (handle->drv_mode.bss_attr[intf_num].bss_virtual)
+				continue;
+			if (!woal_add_interface(handle, handle->priv_num,
+						handle->drv_mode
+							.bss_attr[intf_num]
+							.bss_type)) {
+				PRINTM(MERROR, "%s: add interface %d failed \n",
+				       __func__, handle->priv_num);
+				goto done;
+			}
+		}
+		PRINTM(MMSG, "wlan: post_reset remove/add interface done\n");
+		goto done;
+	}
+
+	PRINTM(MMSG, "wlan: start interfaces reset\n");
+
 	/* Reset all interfaces */
 	woal_reset_intf(woal_get_priv(handle, MLAN_BSS_ROLE_ANY),
 			MOAL_IOCTL_WAIT, MTRUE);
 	/* Initialize private structures */
 	for (intf_num = 0; intf_num < handle->priv_num; intf_num++) {
-		woal_init_priv(handle->priv[intf_num], MOAL_IOCTL_WAIT);
+		if (handle->priv[intf_num]) {
+			woal_init_priv(handle->priv[intf_num], MOAL_IOCTL_WAIT);
 #ifdef WIFI_DIRECT_SUPPORT
 #if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 #if defined(STA_WEXT) || defined(UAP_WEXT)
-		if ((handle->priv[intf_num]->bss_type ==
-		     MLAN_BSS_TYPE_WIFIDIRECT) &&
-		    (GET_BSS_ROLE(handle->priv[intf_num]) ==
-		     MLAN_BSS_ROLE_UAP)) {
-			if (MLAN_STATUS_SUCCESS !=
-			    woal_bss_role_cfg(handle->priv[intf_num],
-					      MLAN_ACT_SET, MOAL_IOCTL_WAIT,
-					      &bss_role)) {
-				goto done;
+			if ((handle->priv[intf_num]->bss_type ==
+			     MLAN_BSS_TYPE_WIFIDIRECT) &&
+			    (GET_BSS_ROLE(handle->priv[intf_num]) ==
+			     MLAN_BSS_ROLE_UAP)) {
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_bss_role_cfg(handle->priv[intf_num],
+						      MLAN_ACT_SET,
+						      MOAL_IOCTL_WAIT,
+						      &bss_role)) {
+					goto done;
+				}
 			}
-		}
 #endif /* STA_WEXT || UAP_WEXT */
 #endif /* STA_SUPPORT && UAP_SUPPORT */
 #endif /* WIFI_DIRECT_SUPPORT */
+		}
 	}
 
 	/* Enable interfaces */
 	for (intf_num = 0; intf_num < handle->priv_num; intf_num++) {
-		netif_device_attach(handle->priv[intf_num]->netdev);
-		woal_start_queue(handle->priv[intf_num]->netdev);
+		if (handle->priv[intf_num]) {
+			netif_device_attach(handle->priv[intf_num]->netdev);
+			woal_start_queue(handle->priv[intf_num]->netdev);
+		}
+	}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+	if (handle->country_code[0] && handle->country_code[1]) {
+		memset(country_code, 0, sizeof(country_code));
+		if (MTRUE ==
+		    is_cfg80211_special_region_code(handle->country_code)) {
+			country_code[0] = 'W';
+			country_code[1] = 'W';
+		} else {
+			country_code[0] = handle->country_code[0];
+			country_code[1] = handle->country_code[1];
+		}
+
+		if (handle->params.cntry_txpwr && priv)
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_request_country_power_table(priv,
+							     country_code)) {
+				PRINTM(MERROR,
+				       "Failed to get country power table\n");
+			}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		if (handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE)
+			queue_work(handle->evt_workqueue,
+				   &handle->regulatory_work);
+#endif
 	}
+#endif
+
 done:
+	if (handle->dpd_data) {
+		release_firmware(handle->dpd_data);
+		handle->dpd_data = NULL;
+	}
+	if (handle->txpwr_data) {
+		release_firmware(handle->txpwr_data);
+		handle->txpwr_data = NULL;
+	}
+	if (handle->user_data) {
+		release_firmware(handle->user_data);
+		handle->user_data = NULL;
+	}
 	LEAVE();
 	return;
 }
@@ -9097,7 +12213,7 @@ void woal_post_reset(moal_handle *handle)
  *
  *  @return        0--success, otherwise failure
  */
-void woal_request_fw_reload(moal_handle *phandle, t_u8 mode)
+int woal_request_fw_reload(moal_handle *phandle, t_u8 mode)
 {
 	int ret = 0;
 
@@ -9109,13 +12225,18 @@ void woal_request_fw_reload(moal_handle *phandle, t_u8 mode)
 	moal_handle *ref_handle = NULL;
 
 	ENTER();
+	wifi_status = WIFI_STATUS_FW_RELOAD;
 #ifdef PCIE
 	if (mode == FW_RELOAD_PCIE_RESET) {
 		card = (pcie_service_card *)handle->card;
 		pdev = card->dev;
-		pci_reset_function(pdev);
+		if (pci_reset_function(pdev)) {
+			PRINTM(MERROR, "%s: pci_reset_function failed \n",
+			       __func__);
+			ret = -1;
+		}
 		LEAVE();
-		return;
+		return ret;
 	}
 #endif
 
@@ -9127,31 +12248,64 @@ void woal_request_fw_reload(moal_handle *phandle, t_u8 mode)
 		} else {
 			ref_handle = (moal_handle *)handle->pref_mac;
 		}
-		ref_handle->driver_status = MTRUE;
 	}
-	/** start block IOCTL */
-	handle->driver_status = MTRUE;
 
 	if (mode == FW_RELOAD_WITH_EMULATION) {
 		fw_reload = FW_RELOAD_WITH_EMULATION;
 		PRINTM(MMSG, "FW reload with re-emulation...\n");
 		LEAVE();
-		return;
+		return ret;
 	}
 	woal_pre_reset(handle);
 	if (ref_handle)
 		woal_pre_reset(ref_handle);
 	if (mode == FW_RELOAD_NO_EMULATION) {
 		ret = woal_reload_fw(handle);
-		if (ref_handle)
-			woal_reload_fw(ref_handle);
+		if (ret) {
+			PRINTM(MERROR, "woal_reload_fw fail\n");
+			goto done;
+		}
+		if (ref_handle) {
+			ret = woal_reload_fw(ref_handle);
+			if (ret) {
+				PRINTM(MERROR, "woal_reload_fw fail\n");
+				goto done;
+			}
+		}
 	}
-#ifdef SDIO_MMC
-	else if (mode == FW_RELOAD_SDIO_INBAND_RESET &&
+#ifdef SDIO
+	else if ((mode == FW_RELOAD_SDIO_INBAND_RESET ||
+		  mode == FW_RELOAD_SDIO_HW_RESET) &&
 		 IS_SD(handle->card_type)) {
-		ret = woal_reset_and_reload_fw(handle);
-		if (ref_handle)
-			woal_reload_fw(ref_handle);
+		ret = woal_reset_and_reload_fw(handle, mode);
+		if (ret) {
+			PRINTM(MERROR, "woal_reset_and_reload_fw fail\n");
+			goto done;
+		}
+		if (ref_handle) {
+			ret = woal_reload_fw(ref_handle);
+			if (ret) {
+				PRINTM(MERROR, "woal_reload_fw fail\n");
+				goto done;
+			}
+		}
+	}
+#endif
+#ifdef PCIE
+	else if (mode == FW_RELOAD_PCIE_INBAND_RESET &&
+		 IS_PCIE(handle->card_type)) {
+		ret = woal_pcie_reset_and_reload_fw(handle);
+		if (ret) {
+			PRINTM(MERROR, "woal_pcie_reset_and_reload_fw fail\n");
+			goto done;
+		}
+		if (ref_handle) {
+			ret = woal_reload_fw(ref_handle);
+			if (ret) {
+				PRINTM(MERROR, "woal_reload_fw fail\n");
+				goto done;
+			}
+		}
 	}
 #endif
 	else
@@ -9163,15 +12317,23 @@ void woal_request_fw_reload(moal_handle *phandle, t_u8 mode)
 	woal_post_reset(handle);
 	if (ref_handle)
 		woal_post_reset(ref_handle);
+	wifi_status = WIFI_STATUS_OK;
 done:
 	LEAVE();
-	return;
+	return ret;
 }
 
-/** Register to bus driver function */
-static mlan_status woal_bus_register(void)
+/**
+ *  @brief This function register to bus driver
+ *
+ *  @param work   a pointer to struct work_struct
+ *
+ *  @return        N/A
+ */
+static void woal_bus_register(struct work_struct *work)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
+	PRINTM(MMSG, "wlan: Register to Bus Driver...\n");
 #ifdef SDIO
 #ifdef SDIO_MMC
 	/* Register SDIO driver */
@@ -9204,11 +12366,17 @@ static mlan_status woal_bus_register(void)
 		goto out;
 	}
 #endif
+	PRINTM(MMSG, "wlan: Register to Bus Driver Done\n");
 out:
-	return ret;
+	return;
 }
 
-/** Unregister from bus driver function */
+/**
+ *  @brief This function unregister from bus driver
+ *
+ *
+ *  @return        N/A
+ */
 static void woal_bus_unregister(void)
 {
 #ifdef SDIO
@@ -9275,13 +12443,29 @@ static int woal_init_module(void)
 #endif
 	MLAN_INIT_WORK(&hang_work, woal_hang_work_queue);
 
-	/* Register with bus */
-	ret = woal_bus_register();
-	if (ret == MLAN_STATUS_SUCCESS)
-		PRINTM(MMSG, "wlan: Driver loaded successfully\n");
-	else
-		PRINTM(MMSG, "wlan: Driver loading failed\n");
+	if (reg_work) {
+		/* Create workqueue for hang process */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+		/* For kernel less than 2.6.14 name can not be greater than 10
+			characters */
+		register_workqueue = create_workqueue("MOAL_REGISTER_WORKQ");
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+		register_workqueue = alloc_workqueue(
+			"MOAL_REGISTER_WORK_QUEUE",
+			WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
+#else
+		register_workqueue =
+			create_workqueue("MOAL_REGISTER_WORK_QUEUE");
+#endif
+#endif
 
+		MLAN_INIT_WORK(&register_work, woal_bus_register);
+		queue_work(register_workqueue, &register_work);
+	} else {
+		woal_bus_register(NULL);
+	}
+	PRINTM(MMSG, "wlan: Driver loaded successfully\n");
 	LEAVE();
 	return ret;
 }
@@ -9309,6 +12493,7 @@ static void woal_cleanup_module(void)
 		handle = m_handle[index];
 		if (!handle)
 			continue;
+		handle->params.auto_fw_reload = MFALSE;
 		if (!handle->priv_num)
 			goto exit;
 		if (MTRUE == woal_check_driver_status(handle))
@@ -9338,8 +12523,36 @@ static void woal_cleanup_module(void)
 		if (handle->rf_test_mode)
 			woal_process_rf_test_mode(handle,
 						  MFG_CMD_UNSET_TEST_MODE);
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+		/* Unregister all connected radiotap net devices */
+		if (handle->mon_if) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+			woal_set_net_monitor(handle->mon_if->priv,
+					     MOAL_IOCTL_WAIT, MFALSE, 0, NULL);
+			if (handle->ioctl_timeout) {
+				woal_ioctl_timeout(handle);
+				goto exit;
+			}
+#endif
+			netif_device_detach(handle->mon_if->mon_ndev);
+			if (handle->mon_if->mon_ndev->reg_state ==
+			    NETREG_REGISTERED)
+				unregister_netdev(handle->mon_if->mon_ndev);
+			handle->mon_if = NULL;
+		}
+#endif
 
 		for (i = 0; i < handle->priv_num; i++) {
+			/** cancel dfs monitor on deinit */
+			if (handle->priv[i] &&
+			    handle->priv[i]->bss_type == MLAN_BSS_TYPE_DFS) {
+				if (woal_11h_cancel_chan_report_ioctl(
+					    handle->priv[i], MOAL_IOCTL_WAIT))
+					PRINTM(MERROR,
+					       "%s: woal_11h_cancel_chan_report_ioctl failed \n",
+					       __func__);
+				continue;
+			}
 #ifdef STA_SUPPORT
 			if (GET_BSS_ROLE(handle->priv[i]) ==
 			    MLAN_BSS_ROLE_STA) {
@@ -9355,15 +12568,15 @@ static void woal_cleanup_module(void)
 				}
 #ifdef STA_CFG80211
 				if (IS_STA_CFG80211(
-					    handle->params.cfg80211_wext) &&
-				    (handle->priv[i]->bss_type ==
-				     MLAN_BSS_TYPE_STA))
+					    handle->params.cfg80211_wext))
 					woal_clear_conn_params(handle->priv[i]);
 				spin_lock_irqsave(&handle->scan_req_lock,
 						  flags);
 				if (IS_STA_CFG80211(
 					    handle->params.cfg80211_wext) &&
 				    handle->scan_request) {
+					cancel_delayed_work(
+						&handle->scan_timeout_work);
 					woal_cfg80211_scan_done(
 						handle->scan_request, MTRUE);
 					handle->scan_request = NULL;
@@ -9463,6 +12676,12 @@ static void woal_cleanup_module(void)
 		destroy_workqueue(hang_workqueue);
 		hang_workqueue = NULL;
 	}
+	if (reg_work && register_workqueue) {
+		flush_workqueue(register_workqueue);
+		destroy_workqueue(register_workqueue);
+		register_workqueue = NULL;
+	}
+
 	woal_root_proc_remove();
 
 	LEAVE();
@@ -9492,7 +12711,13 @@ __setup("mfg_mode=", mfg_mode_setup);
 module_init(woal_init_module);
 module_exit(woal_cleanup_module);
 
+module_param(reg_work, int, 0);
+MODULE_PARM_DESC(
+	reg_work,
+	"0: disable register work_queue; 1: enable register work_queue");
+
 MODULE_DESCRIPTION("M-WLAN Driver");
 MODULE_AUTHOR("NXP");
 MODULE_VERSION(MLAN_RELEASE_VERSION);
 MODULE_LICENSE("GPL");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.h
old mode 100644
new mode 100755
index 8421ae6ec..c17699b96
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_main.h
@@ -3,7 +3,7 @@
  * @brief This file contains wlan driver specific defines etc.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -105,7 +105,7 @@ Change log:
 #include <linux/firmware.h>
 
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 #include <linux/pm_wakeup.h>
 #include <linux/device.h>
 #else
@@ -113,6 +113,8 @@ Change log:
 #endif
 #endif
 
+#include <net/ieee80211_radiotap.h>
+
 #include "mlan.h"
 #include "moal_shim.h"
 /* Wireless header */
@@ -130,6 +132,17 @@ Change log:
 #include "moal_priv.h"
 #endif
 
+#ifdef IMX_SUPPORT
+#include <linux/of_irq.h>
+#include <linux/suspend.h>
+#endif /* IMX_SUPPORT */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#include <linux/pm_qos.h>
+#else
+#include <linux/pm_qos_params.h>
+#endif
+
 #ifndef MIN
 /** Find minimum */
 #define MIN(a, b) ((a) < (b) ? (a) : (b))
@@ -143,6 +156,22 @@ Change log:
 #define COMPAT_VERSION_CODE KERNEL_VERSION(0, 0, 0)
 #define CFG80211_VERSION_CODE MAX(LINUX_VERSION_CODE, COMPAT_VERSION_CODE)
 
+#define IMX_ANDROID_13 0
+#define IMX_ANDROID_12_BACKPORT 0
+
+#if defined(IMX_SUPPORT)
+#if defined(IMX_ANDROID)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 15, 52)
+#undef IMX_ANDROID_13
+#define IMX_ANDROID_13 1
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 15, 41)
+#undef IMX_ANDROID_12_BACKPORT
+#define IMX_ANDROID_12_BACKPORT 1
+#endif
+#endif
+#endif
+
 /**
  * Reason Code 3: STA is leaving (or has left) IBSS or ESS
  */
@@ -201,6 +230,10 @@ Change log:
 #define IEEE80211_NUM_BANDS NUM_NL80211_BANDS
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 4, 0)
+#define IEEE80211_BAND_6GHZ NL80211_BAND_6GHZ
+#endif
+
 /**
  * interface name
  */
@@ -210,18 +243,26 @@ Change log:
 #define default_nan_name "nan%d"
 #define default_mpl_name "mpl%d"
 #define default_11p_name "ocb%d"
+#define default_dfs_name "dfs%d"
 #define mwiphy_name "mwiphy%d"
 
+/** country txpower mode */
+#define CNTRY_TXPOWER_MODE 1
+/** country rgpower mode */
+#define CNTRY_RGPOWER_MODE 2
+
 /** Define BOOLEAN */
 typedef t_u8 BOOLEAN;
 
-#define INTF_CARDTYPE "---------%s-MXM"
+#define INTF_CARDTYPE "----------%s-MM"
 
 #define KERN_VERSION "5X"
 
+#define V14 "14"
 #define V15 "15"
 #define V16 "16"
 #define V17 "17"
+#define V18 "18"
 
 /** Chip Magic Value */
 #define CHIP_MAGIC_VALUE 0x24
@@ -239,10 +280,59 @@ typedef t_u8 BOOLEAN;
 #define CARD_TYPE_USB_USB 6
 /** card type PCIE_USB */
 #define CARD_TYPE_PCIE_USB 7
+/** card type SD9177_UART */
+#define CARD_TYPE_SD9177_UART 1 // As per datasheet/SoC design
+
+/* Max buffer size */
+#define MAX_BUF_LEN 512
 
 /** Driver version */
 extern char driver_version[];
 
+extern struct semaphore AddRemoveCardSem;
+extern int wifi_status;
+extern int max_tx_buf;
+extern int pcie_int_mode;
+
+#ifdef STA_SUPPORT
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+extern const struct net_device_ops woal_netdev_ops;
+#endif
+#endif
+
+#ifdef UAP_SUPPORT
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+extern const struct net_device_ops woal_uap_netdev_ops;
+#endif
+#endif
+
+/** Global veriable for usb independent reset */
+extern int fw_reload;
+
+#ifdef MFG_CMD_SUPPORT
+/** Mfg mode */
+extern int mfg_mode;
+#endif
+
+/** rf_test mode */
+extern int rf_test_mode;
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+extern int fw_region;
+#endif
+#endif
+
+#if defined(USB)
+extern int skip_fwdnld;
+#endif
+#if defined(SDIO) || defined(PCIE)
+typedef enum {
+	RDWR_STATUS_SUCCESS = 0,
+	RDWR_STATUS_FAILURE = 1,
+	RDWR_STATUS_DONE = 2
+} rdwr_status;
+#endif
 /** Private structure for MOAL */
 typedef struct _moal_private moal_private, *pmoal_private;
 /** Handle data structure for MOAL  */
@@ -258,8 +348,22 @@ typedef enum _MOAL_HARDWARE_STATUS {
 	HardwareStatusNotReady
 } MOAL_HARDWARE_STATUS;
 
+#define WIFI_STATUS_OK 0
+#define WIFI_STATUS_FW_DNLD 1
+#define WIFI_STATUS_FW_DNLD_COMPLETE 2
+#define WIFI_STATUS_INIT_FW 3
+#define WIFI_STATUS_DNLD_FW_FAIL 4
+#define WIFI_STATUS_INIT_FW_FAIL 5
+#define WIFI_STATUS_TX_TIMEOUT 6
+#define WIFI_STATUS_WIFI_HANG 7
+#define WIFI_STATUS_SCAN_TIMEOUT 8
+#define WIFI_STATUS_FW_DUMP 9
+#define WIFI_STATUS_FW_RELOAD 10
+
 /** fw cap info 11p */
 #define FW_CAPINFO_80211P MBIT(24)
+/** fw cap info bit26 for 0-DFS support */
+#define FW_CAPINFO_ZERO_DFS MBIT(31)
 /** fw cap info disable nan */
 #define FW_CAPINFO_DISABLE_NAN MBIT(29)
 /** fw cap info BGA */
@@ -320,13 +424,13 @@ static inline void woal_timer_handler(unsigned long fcontext)
 	pmoal_drv_timer timer = (pmoal_drv_timer)fcontext;
 #endif
 
-	timer->timer_function(timer->function_context);
+	if (!timer->timer_is_canceled)
+		timer->timer_function(timer->function_context);
 
-	if (timer->timer_is_periodic == MTRUE) {
+	if (timer->timer_is_periodic == MTRUE && !timer->timer_is_canceled) {
 		mod_timer(&timer->tl,
 			  jiffies + ((timer->time_period * HZ) / 1000));
 	} else {
-		timer->timer_is_canceled = MTRUE;
 		timer->time_period = 0;
 	}
 }
@@ -496,6 +600,19 @@ static inline void woal_sched_timeout(t_u32 millisec)
 	schedule_timeout((millisec * HZ) / 1000);
 }
 
+/**
+ *  @brief Schedule timeout uninterruptible
+ *
+ *  @param millisec	Timeout duration in milli second
+ *
+ *  @return		N/A
+ */
+static inline void woal_sched_timeout_uninterruptible(t_u32 millisec)
+{
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	schedule_timeout_uninterruptible((millisec * HZ) / 1000);
+}
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
 #define IN6PTON_XDIGIT 0x00010000
 #define IN6PTON_DIGIT 0x00020000
@@ -648,6 +765,21 @@ static inline int in4_pton(const char *src, int srclen, u8 *dst, int delim,
 #define NUM_TX_TIMEOUT_THRESHOLD 10
 /** Custom event : DRIVER HANG */
 #define CUS_EVT_DRIVER_HANG "EVENT=DRIVER_HANG"
+/** Custom event : FW_DUMP */
+#define CUS_EVT_FW_DUMP "EVENT=FW_DUMP"
+/** Custom event : START FW RESET */
+#define CUS_EVT_FW_RECOVER_START "EVENT=FW_RECOVER_START"
+#define CUS_EVT_FW_RECOVER_SUCCESS "EVENT=FW_RECOVER_SUCCESS"
+#define CUS_EVT_FW_RECOVER_FAIL "EVENT=FW_RECOVER_FAILURE"
+
+/** TDLS connected event */
+#define CUS_EVT_TDLS_CONNECTED "EVENT=TDLS_CONNECTED"
+/** TDLS tear down event */
+#define CUS_EVT_TDLS_TEARDOWN "EVENT=TDLS_TEARDOWN"
+/** wmm info */
+#define WMM_TYPE_INFO 0
+/** wmm parameter */
+#define WMM_TYPE_PARAMETER 1
 
 /** AP connected event */
 #define CUS_EVT_AP_CONNECTED "EVENT=AP_CONNECTED"
@@ -693,6 +825,8 @@ static inline int in4_pton(const char *src, int srclen, u8 *dst, int delim,
 /** Custom event : Deep Sleep awake */
 #define CUS_EVT_DEEP_SLEEP_AWAKE "EVENT=DS_AWAKE"
 
+#define CUS_EVT_TOD_TOA "EVENT=TOD-TOA"
+
 /** Custom event : Host Sleep activated */
 #define CUS_EVT_HS_ACTIVATED "HS_ACTIVATED"
 /** Custom event : Host Sleep deactivated */
@@ -717,15 +851,35 @@ typedef enum {
 	RESERVED // Others: reserved
 } HSWakeupReason_t;
 
+/** Custom event : Radar Detected */
+#define CUS_EVT_RADAR_DETECTED "EVENT=RADAR_DETECTED"
+/** Custom event : CAC finished */
+#define CUS_EVT_CAC_FINISHED "EVENT=CAC_FINISHED"
+/** Custom event : CAC start */
+#define CUS_EVT_CAC_START "EVENT=CAC_START"
+#ifdef UAP_SUPPORT
+void woal_move_to_next_channel(moal_private *priv);
+void woal_chan_event(moal_private *priv, t_u8 type, t_u8 channel, t_u8 radar);
+void woal_process_chan_event(moal_private *priv, t_u8 type, t_u8 channel,
+			     t_u8 radar);
+mlan_status woal_do_dfs_cac(moal_private *priv,
+			    mlan_ds_11h_chan_rep_req *ch_rpt_req);
+#endif
+
 /** Custom event : WEP ICV error */
 #define CUS_EVT_WEP_ICV_ERR "EVENT=WEP_ICV_ERR"
 
 /** Custom event : Channel Switch Announcment */
 #define CUS_EVT_CHANNEL_SWITCH_ANN "EVENT=CHANNEL_SWITCH_ANN"
 
+/** Custom event : Channel Switch complete */
+#define CUS_EVT_CHAN_SWITCH_COMPLETE "EVENT=CHANNEL_SWITCH_COMPLETE"
+
 /** Custom indiciation message sent to the application layer for WMM changes */
 #define WMM_CONFIG_CHANGE_INDICATION "WMM_CONFIG_CHANGE.indication"
 
+#define CUS_EVT_FW_DUMP_DONE "EVENT=FW_DUMP_DONE"
+
 #ifdef UAP_SUPPORT
 /** Custom event : STA connected */
 #define CUS_EVT_STA_CONNECTED "EVENT=STA_CONNECTED"
@@ -734,6 +888,8 @@ typedef enum {
 #endif
 #define FW_DEBUG_INFO "EVENT=FW_DEBUG_INFO"
 
+#define CUS_EVT_CSI "EVENT=MLAN_CSI"
+
 /** 10 seconds */
 #define MOAL_TIMER_10S 10000
 /** 5 seconds */
@@ -742,6 +898,8 @@ typedef enum {
 #define MOAL_TIMER_1S 1000
 /** 1 milisecond */
 #define MOAL_TIMER_1MS 1
+/** scan timeout set to 25 seconds */
+#define SCAN_TIMEOUT_25S 25000
 
 /** passive scan time */
 #define PASSIVE_SCAN_CHAN_TIME 110
@@ -764,19 +922,19 @@ typedef enum {
 /** Netlink protocol number */
 #define NETLINK_NXP (MAX_LINKS - 1)
 /** Netlink maximum payload size */
-#define NL_MAX_PAYLOAD 1024
+#define NL_MAX_PAYLOAD (3 * 1024)
 /** Netlink multicast group number */
 #define NL_MULTICAST_GROUP 1
 
 #define MAX_RX_PENDING_THRHLD 50
 
 /** high rx pending packets */
-#define HIGH_RX_PENDING 100
+#define USB_HIGH_RX_PENDING 100
 /** low rx pending packets */
-#define LOW_RX_PENDING 80
+#define USB_LOW_RX_PENDING 80
 
 /** MAX Tx Pending count */
-#define MAX_TX_PENDING 400
+#define MAX_TX_PENDING 800
 
 /** LOW Tx Pending count */
 #define LOW_TX_PENDING 380
@@ -791,22 +949,6 @@ typedef enum {
 /** GAP value is optional */
 #define GAP_FLAG_OPTIONAL MBIT(15)
 
-/** Macro to extract the TOS field from a skb */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22)
-#define SKB_TOS(skb) (ip_hdr(skb)->tos)
-#else
-#define SKB_TOS(skb) (skb->nh.iph->tos)
-#endif
-#define SKB_TIDV6(skb) (ipv6_get_dsfield(ipv6_hdr(skb)))
-#define IS_SKB_MAGIC_VLAN(skb) (skb->priority >= 256 && skb->priority <= 263)
-#define GET_VLAN_PRIO(skb) (skb->priority - 256)
-
-/** Offset for TOS field in the IP header */
-#define IPTOS_OFFSET 5
-
-/** Offset for DSCP in the tos field */
-#define DSCP_OFFSET 2
-
 /** max retry count for wait_event_interupptible_xx while loop */
 #define MAX_RETRY_CNT 100
 /** wait_queue structure */
@@ -874,9 +1016,14 @@ typedef struct _wait_queue {
 /** Driver mode uAP bit */
 #define DRV_MODE_UAP MBIT(1)
 /** Maximum uAP BSS */
-#define MAX_UAP_BSS 1
+#define MAX_UAP_BSS 2
 /** Default uAP BSS */
 #define DEF_UAP_BSS 1
+
+/** WACP Modes for uAP */
+#define WACP_MODE_DEFAULT 0
+#define WACP_MODE_1 1
+#define WACP_MODE_2 2
 #endif
 #ifdef WIFI_DIRECT_SUPPORT
 /** Driver mode WIFIDIRECT bit */
@@ -890,12 +1037,19 @@ typedef struct _wait_queue {
 #endif
 #endif /* WIFI_DIRECT_SUPPORT */
 
+/**Driver mode 0DFS bit**/
+#define DRV_MODE_DFS MBIT(7)
+/**Maxinmum DFS BSS**/
+#define MAX_DFS_BSS 1
+/**Default DFS BSS**/
+#define DEF_DFS_BSS 1
+
 #define DRV_MODE_WLAN (MBIT(0) | MBIT(1) | MBIT(2) | MBIT(3) | MBIT(4))
 
 /**
  * the maximum number of adapter supported
  **/
-#define MAX_MLAN_ADAPTER 3
+#define MAX_MLAN_ADAPTER 4
 
 typedef struct _moal_drv_mode {
 	/** driver mode */
@@ -908,6 +1062,8 @@ typedef struct _moal_drv_mode {
 	char *fw_name;
 } moal_drv_mode;
 
+extern moal_handle *m_handle[MAX_MLAN_ADAPTER];
+
 /** Indicate if handle->info's address */
 #define INFO_ADDR BIT(0)
 #define IS_INFO_ADDR(attr) (attr & INFO_ADDR)
@@ -952,6 +1108,7 @@ struct debug_data_priv {
 /** IP address operation: Remove */
 #define IPADDR_OP_REMOVE 0
 
+#define TCP_ACK_MAX_HOLD 9
 #define DROP_TCP_ACK 1
 #define HOLD_TCP_ACK 2
 struct tcp_sess {
@@ -972,7 +1129,9 @@ struct tcp_sess {
 	/** timer for ack */
 	moal_drv_timer ack_timer __ATTRIB_ALIGN__;
 	/** timer is set */
-	BOOLEAN is_timer_set;
+	atomic_t is_timer_set;
+	/** last update time*/
+	wifi_timeval update_time;
 };
 
 struct tx_status_info {
@@ -990,15 +1149,38 @@ struct tx_status_info {
 /** woal event type */
 enum woal_event_type {
 	WOAL_EVENT_CHAN_SWITCH,
+	WOAL_EVENT_RX_MGMT_PKT,
 	WOAL_EVENT_BGSCAN_STOP,
 #if defined(UAP_CFG80211) || defined(STA_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	WOAL_EVENT_DEAUTH,
 	WOAL_EVENT_ASSOC_RESP,
 #endif
+#endif
+	WOAL_EVENT_CHAN_RPT,
+	WOAL_EVENT_RADAR,
+#ifdef UAP_CFG80211
+#if KERNEL_VERSION(3, 12, 0) <= CFG80211_VERSION_CODE
+	WOAL_EVENT_CANCEL_CHANRPT,
+#endif
 #endif
 };
 
+/** chan_rpt_info */
+typedef struct _chan_radar_info {
+	/** channel */
+	t_u8 channel;
+	/** radar */
+	t_u8 radar;
+} chan_radar_info;
+
+typedef struct _woal_evt_buf {
+	/** Event len */
+	t_u16 event_len;
+	/** Event buffer */
+	t_u8 event_buf[1500];
+} woal_evt_buf;
+
 /** woal event */
 struct woal_event {
 	/*list head */
@@ -1009,8 +1191,10 @@ struct woal_event {
 	void *priv;
 	union {
 		chan_band_info chan_info;
-		mlan_ds_misc_assoc_rsp assoc_resp;
+		woal_evt_buf evt;
+		mlan_ds_assoc_info assoc_info;
 		int reason_code;
+		chan_radar_info radar_info;
 	};
 };
 
@@ -1059,11 +1243,88 @@ struct pmksa_entry {
 	u8 pmkid[PMKID_LEN];
 };
 
+/** default rssi low threshold */
+#define TDLS_RSSI_LOW_THRESHOLD 55
+/** default rssi high threshold */
+#define TDLS_RSSI_HIGH_THRESHOLD 50
+/** TDLS idle time */
+#define TDLS_IDLE_TIME (10 * HZ)
+/** TDLS max failure count */
+#define TDLS_MAX_FAILURE_COUNT 4
+/** TDLS tear down reason */
+#define TDLS_TEARN_DOWN_REASON_UNSPECIFIC 26
+
+/** TDLS status */
+typedef enum _tdlsStatus_e {
+	TDLS_NOT_SETUP = 0,
+	TDLS_SETUP_INPROGRESS,
+	TDLS_SETUP_COMPLETE,
+	TDLS_SETUP_FAILURE,
+	TDLS_TEAR_DOWN,
+	TDLS_SWITCHING_CHANNEL,
+	TDLS_IN_BASE_CHANNEL,
+	TDLS_IN_OFF_CHANNEL,
+} tdlsStatus_e;
+
+/** tdls peer_info */
+struct tdls_peer {
+	struct list_head link;
+	/** MAC address information */
+	t_u8 peer_addr[ETH_ALEN];
+	/** rssi */
+	int rssi;
+	/** jiffies with rssi */
+	long rssi_jiffies;
+	/** link status */
+	tdlsStatus_e link_status;
+	/** num of set up failure */
+	t_u8 num_failure;
+};
+
+/** mcast node */
+struct mcast_node {
+	struct list_head link;
+	/** mcast address information */
+	t_u8 mcast_addr[ETH_ALEN];
+};
+
+/** This is a flag for auto assoc/re-connect retry forever */
+#define AUTO_ASSOC_RETRY_FOREVER 0xFFFF
+
+typedef enum {
+	AUTO_ASSOC_TYPE_NONE = 0,
+	AUTO_ASSOC_TYPE_DRV_ASSOC,
+	AUTO_ASSOC_TYPE_DRV_RECONN,
+	AUTO_ASSOC_TYPE_FW_RECONN,
+} AUTO_ASSOC_TYPE;
+
+typedef struct {
+	/** driver auto assoc retry count */
+	t_u8 retry_count;
+	/** driver auto assoc retry interval */
+	t_u8 retry_interval;
+	/** driver auto assoc status */
+	t_u8 status;
+} drv_auto_assoc;
+
+typedef struct {
+	/** Bitmap for auto assoc type on/off */
+	t_u8 auto_assoc_type_on;
+	/** flag of being triggered by drv auto assoc/re-connect  */
+	t_u8 auto_assoc_trigger_flag;
+	/** driver auto assoc info*/
+	drv_auto_assoc drv_assoc;
+	/** driver auto re-connect info*/
+	drv_auto_assoc drv_reconnect;
+} auto_assoc;
+
 struct rf_test_mode_data {
 	/* tx antenna num */
 	t_u32 tx_antenna;
 	/* rx antenna num */
 	t_u32 rx_antenna;
+	/* radio mode */
+	t_u32 radio_mode[2];
 	/* RF band */
 	t_u32 band;
 	/* RF bandwidth */
@@ -1081,9 +1342,14 @@ struct rf_test_mode_data {
 	/* Tx continuous config values */
 	t_u32 tx_cont_data[6];
 	/* Tx frame config values */
-	t_u32 tx_frame_data[13];
+	t_u32 tx_frame_data[20];
+	/* HE TB Tx values */
+	t_u32 he_tb_tx[4];
+	t_s32 he_tb_tx_power[1];
 	/* BSSID */
 	t_u8 bssid[ETH_ALEN];
+	/* Trigger frame config values */
+	mfg_Cmd_IEEEtypes_CtlBasicTrigHdr_t mfg_tx_trigger_config;
 };
 
 /** Number of samples in histogram (/proc/mwlan/adapterX/mlan0/histogram).*/
@@ -1127,6 +1393,51 @@ enum ring_id {
 	RING_ID_MAX,
 };
 
+#define AUTO_DFS_ENABLE 0x1
+#define AUTO_DFS_DISABLE 0x0
+#define MAX_DFS_CHAN_LIST 16
+
+/** Auto Zero DFS config structure */
+typedef struct _auto_zero_dfs_cfg {
+	/** 1: start 0: stop */
+	t_u8 start_auto_zero_dfs;
+	/** start channel for ZeroDFS */
+	t_u8 cac_start_chan;
+	/** cac timer */
+	t_u32 cac_timer;
+	/** bw: 0: 20MHz  1: 40Mz above  3: 40MHz below  4: Bandwidth 80MHz */
+	t_u8 bw;
+	/** enable uap chan switch after first CAC finished*/
+	t_u8 uap_chan_switch;
+	/** enable auto zero dfs */
+	t_u8 multi_chan_dfs;
+	/** num of chan */
+	t_u8 num_of_chan;
+	/** dfs channel list */
+	t_u8 dfs_chan_list[MAX_DFS_CHAN_LIST];
+} __ATTRIB_PACK__ auto_zero_dfs_cfg;
+
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+typedef struct _station_node {
+	/** station aid */
+	t_u16 aid;
+	/** station mac address */
+	t_u8 peer_mac[MLAN_MAC_ADDR_LENGTH];
+	/** net_device that station is bind to */
+	struct net_device *netdev;
+	/** is valid flag */
+	t_u8 is_valid;
+} station_node;
+
+#define EASY_MESH_MULTI_AP_FH_BSS (t_u8)(0x20)
+#define EASY_MESH_MULTI_AP_BH_BSS (t_u8)(0x40)
+#define EASY_MESH_MULTI_AP_BH_AND_FH_BSS (t_u8)(0x60)
+
+#define EASY_MESH_MULTI_AP_BSS_MODE_1 (t_u8)(0x01)
+#define EASY_MESH_MULTI_AP_BSS_MODE_2 (t_u8)(0x02)
+#define EASY_MESH_MULTI_AP_BSS_MODE_3 (t_u8)(0x03)
+#endif
+
 /** Private structure for MOAL */
 struct _moal_private {
 	/** Handle structure */
@@ -1145,15 +1456,29 @@ struct _moal_private {
 	t_u8 current_addr[ETH_ALEN];
 	/** Media connection status */
 	BOOLEAN media_connected;
+	/** mclist work queue */
+	struct workqueue_struct *mclist_workqueue;
+	/** mclist work */
+	struct work_struct mclist_work;
 	/** Statistics of tcp ack tx dropped */
 	t_u32 tcp_ack_drop_cnt;
 	/** Statistics of tcp ack tx in total from kernel */
 	t_u32 tcp_ack_cnt;
+	/** Statistics of tcp ack with payload*/
+	t_u32 tcp_ack_payload;
 #ifdef UAP_SUPPORT
 	/** uAP started or not */
 	BOOLEAN bss_started;
 	/** host based uap flag */
 	BOOLEAN uap_host_based;
+	/** target channel */
+	t_u8 target_chan;
+	/** backup channel */
+	t_u8 backup_chan;
+	/** channel mode for channel switch */
+	t_u8 chan_mode;
+	/** number of csa for channel switch */
+	t_u8 chan_num_pkts;
 	/** uAP skip CAC*/
 	BOOLEAN skip_cac;
 	/** tx block flag */
@@ -1162,6 +1487,22 @@ struct _moal_private {
 	t_u32 user_cac_period_msec;
 	/** channel under nop */
 	BOOLEAN chan_under_nop;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+	/** radar background */
+	t_u8 radar_background;
+	/** radar background channel */
+	struct cfg80211_chan_def radar_background_chan;
+#endif
+#endif
+	/** chan_rpt_req on Zero DFS interface */
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
+	/** chan_rpt pending */
+	t_u8 chan_rpt_pending;
+	/** auto dfs cfg */
+	auto_zero_dfs_cfg auto_dfs_cfg;
+	/** index of cac */
+	int curr_cac_idx;
 #ifdef UAP_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	/** current working channel */
@@ -1179,6 +1520,12 @@ struct _moal_private {
 #endif
 #endif
 #endif
+	/** IP addr type */
+	t_u32 ip_addr_type;
+	/** IP addr */
+	t_u8 ip_addr[IPADDR_LEN];
+	t_u8 ipv6_addr_configured;
+	t_u8 ipv6_addr[16];
 #ifdef STA_SUPPORT
 	/** scan type */
 	t_u8 scan_type;
@@ -1215,6 +1562,10 @@ struct _moal_private {
 	t_u8 conn_wep_key[MAX_WEP_KEY_SIZE];
 	/** connection param */
 	struct cfg80211_connect_params sme_current;
+	/** station info */
+	struct station_info *sinfo;
+	/* associcate bss */
+	struct cfg80211_bss *assoc_bss;
 #endif
 	t_u8 wait_target_ap_pmkid;
 	wait_queue_head_t okc_wait_q __ATTRIB_ALIGN__;
@@ -1243,6 +1594,10 @@ struct _moal_private {
 	/** cipher */
 	t_u32 cipher;
 #endif
+	/** pmk saved flag */
+	t_u8 pmk_saved;
+	/** pmk */
+	mlan_pmk_t pmk;
 	/** beacon ie index */
 	t_u16 beacon_index;
 	/** proberesp ie index */
@@ -1321,6 +1676,10 @@ struct _moal_private {
 	t_u8 auth_flag;
 	/** flag for auth algorithm */
 	t_u16 auth_alg;
+	/** auth tx cnt */
+	t_u8 auth_tx_cnt;
+	/** deauth evt cnt */
+	t_u8 deauth_evt_cnt;
 #endif
 #ifdef CONFIG_PROC_FS
 	/** Proc entry */
@@ -1387,11 +1746,31 @@ struct _moal_private {
 	struct list_head tcp_sess_queue;
 	/** TCP Ack enhance flag */
 	t_u8 enable_tcp_ack_enh;
+	/** TCP Ack drop count */
+	t_u8 tcp_ack_max_hold;
 	/** TCP session spin lock */
 	spinlock_t tcp_sess_lock;
+	/** mcast spin lock */
+	spinlock_t mcast_lock;
+	/** mcast list */
+	struct list_head mcast_list;
+	/** num_mcast_addr */
+	t_u32 num_mcast_addr;
+	/** enable mc_aggr */
+	t_u8 enable_mc_aggr;
+	/** tcp list */
+	struct list_head tdls_list;
+	/** tdls spin lock */
+	spinlock_t tdls_lock;
+	/** auto tdls  flag */
+	t_u8 enable_auto_tdls;
+	/** check tx packet for tdls peer */
+	t_u8 tdls_check_tx;
+	auto_assoc auto_assoc_priv;
 #if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 	atomic_t wmm_tx_pending[4];
 #endif
+	struct sk_buff_head tx_q;
 	/** per interface extra headroom */
 	t_u16 extra_tx_head_len;
 	/** TX status spin lock */
@@ -1408,6 +1787,17 @@ struct _moal_private {
 	mlan_ds_misc_gtk_rekey_data gtk_rekey_data;
 	dot11_protocol tx_protocols;
 	dot11_protocol rx_protocols;
+	t_u16 csi_seq;
+	/** 0-disable, 1-enable */
+	t_u16 csi_enable;
+	/** default-ASCII, 1-binary */
+	t_u8 csi_dump_format;
+	/** total length of csi dump */
+	t_u32 csi_dump_len;
+	/** path name of csi dump */
+	char csi_dump_path[64];
+	/** CSI config */
+	mlan_ds_csi_params csi_config;
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
 	/** hostcmd_wait_q */
 	wait_queue_head_t hostcmd_wait_q __ATTRIB_ALIGN__;
@@ -1417,6 +1807,20 @@ struct _moal_private {
 	void *rings[RING_ID_MAX];
 	t_u8 pkt_fate_monitor_enable;
 	void *packet_filter;
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	t_u8 multi_ap_flag;
+	station_node *vlan_sta_ptr;
+	station_node *vlan_sta_list[MAX_STA_COUNT];
+	moal_private *parent_priv;
+#endif
+#endif
+	/** txwatchdog disable */
+	t_u8 txwatchdog_disable;
+
+	/** secure boot uuid lower and higher 8 bytes */
+	t_u64 uuid_lo;
+	t_u64 uuid_hi;
 };
 
 #ifdef SDIO
@@ -1441,6 +1845,8 @@ typedef struct _card_info {
 	t_bool drcs;
 	/** support Go NOA*/
 	t_bool go_noa;
+	/** support V14_FW_API*/
+	t_bool v14_fw_api;
 	/** support V16_FW_API*/
 	t_bool v16_fw_api;
 	/** support V17_FW_API*/
@@ -1464,6 +1870,8 @@ typedef struct _card_info {
 	t_u32 host_strap_reg;
 	/* Chip Magic Register */
 	t_u32 magic_reg;
+	/** Chip boot mode reg */
+	t_u32 boot_mode_reg;
 	/* FW Name */
 	char fw_name[FW_NAMW_MAX_LEN];
 	char fw_name_wlan[FW_NAMW_MAX_LEN];
@@ -1477,19 +1885,409 @@ typedef struct _card_info {
 	t_u8 scratch_reg;
 	t_u8 func1_reg_start;
 	t_u8 func1_reg_end;
-	t_u32 fw_reset_reg;
-	t_u8 fw_reset_val;
 	t_u32 slew_rate_reg;
 	t_u8 slew_rate_bit_offset;
 #endif
+#if defined(SDIO) || defined(PCIE)
+	t_u32 fw_reset_reg;
+	t_u8 fw_reset_val;
+#endif
+	t_u8 sniffer_support;
 	t_u8 per_pkt_cfg_support;
 } card_info;
 
+/** channel_field.flags */
+#define CHANNEL_FLAGS_TURBO 0x0010
+#define CHANNEL_FLAGS_CCK 0x0020
+#define CHANNEL_FLAGS_OFDM 0x0040
+#define CHANNEL_FLAGS_2GHZ 0x0080
+#define CHANNEL_FLAGS_5GHZ 0x0100
+#define CHANNEL_FLAGS_ONLY_PASSIVSCAN_ALLOW 0x0200
+#define CHANNEL_FLAGS_DYNAMIC_CCK_OFDM 0x0400
+#define CHANNEL_FLAGS_GFSK 0x0800
+struct channel_field {
+	/** frequency */
+	t_u16 frequency;
+	/** flags */
+	t_u16 flags;
+} __packed;
+
+/** mcs_field.known */
+#define MCS_KNOWN_BANDWIDTH 0x01
+#define MCS_KNOWN_MCS_INDEX_KNOWN 0x02
+#define MCS_KNOWN_GUARD_INTERVAL 0x04
+#define MCS_KNOWN_HT_FORMAT 0x08
+#define MCS_KNOWN_FEC_TYPE 0x10
+#define MCS_KNOWN_STBC_KNOWN 0x20
+#define MCS_KNOWN_NESS_KNOWN 0x40
+#define MCS_KNOWN_NESS_DATA 0x80
+/** bandwidth */
+#define RX_BW_20 0
+#define RX_BW_40 1
+#define RX_BW_20L 2
+#define RX_BW_20U 3
+#define RX_BW_80 4
+#define RX_HE_BW_20 0
+#define RX_HE_BW_40 1
+#define RX_HE_BW_80 2
+#define RX_HE_BW_160 3
+/** mcs_field.flags
+The flags field is any combination of the following:
+0x03    bandwidth - 0: 20, 1: 40, 2: 20L, 3: 20U
+0x04    guard interval - 0: long GI, 1: short GI
+0x08    HT format - 0: mixed, 1: greenfield
+0x10    FEC type - 0: BCC, 1: LDPC
+0x60    Number of STBC streams
+0x80    Ness - bit 0 (LSB) of Number of extension spatial streams */
+struct mcs_field {
+	/** known */
+	t_u8 known;
+	/** flags */
+	t_u8 flags;
+	/** mcs */
+	t_u8 mcs;
+} __packed;
+
+/** vht_field.known */
+#define VHT_KNOWN_STBC 0x0001
+#define VHT_KNOWN_TXOP_PS_NA 0x0002
+#define VHT_KNOWN_GI 0x0004
+#define VHT_KNOWN_SGI_NSYM_DIS 0x0008
+#define VHT_KNOWN_LDPC_EXTRA_OFDM_SYM 0x0010
+#define VHT_KNOWN_BEAMFORMED 0x0020
+#define VHT_KNOWN_BANDWIDTH 0x0040
+#define VHT_KNOWN_GROUP_ID 0x0080
+#define VHT_KNOWN_PARTIAL_AID 0x0100
+
+/** vht_field.flags */
+#define VHT_FLAG_STBC 0x01
+#define VHT_FLAG_TXOP_PS_NA 0x02
+#define VHT_FLAG_SGI 0x04
+#define VHT_FLAG_SGI_NSYM_M10_9 0x08
+#define VHT_FLAG_LDPC_EXTRA_OFDM_SYM 0x10
+#define VHT_FLAG_BEAMFORMED 0x20
+
+/** vht_field.coding */
+#define VHT_CODING_LDPC_USER0 0x01
+#define VHT_CODING_LDPC_USER1 0x02
+#define VHT_CODING_LDPC_USER2 0x04
+#define VHT_CODING_LDPC_USER3 0x08
+
+/** vht_field */
+struct vht_field {
+	/** pad: for vht field require 2 bytes alignment */
+	t_u8 pad;
+	/** known */
+	t_u16 known;
+	/** flags */
+	t_u8 flags;
+	/** bandwidth */
+	t_u8 bandwidth;
+	/** mcs_nss for up to 4 users */
+	t_u8 mcs_nss[4];
+	/** coding for up to 4 users */
+	t_u8 coding;
+	/** group_id */
+	t_u8 group_id;
+	/** partial_aid */
+	t_u16 partial_aid;
+} __packed;
+
+#define HE_BSS_COLOR_KNOWN 0x0002
+#define HE_BEAM_CHANGE_KNOWN 0x0004
+#define HE_UL_DL_KNOWN 0x0008
+#define HE_MCS_KNOWN 0x0020
+#define HE_DCM_KNOWN 0x0040
+#define HE_CODING_KNOWN 0x0080
+#define HE_BW_KNOWN 0x4000
+#define HE_DATA_GI_KNOWN 0x0002
+#define HE_MU_DATA 0x0002
+#define HE_CODING_LDPC_USER0 0x2000
+/** he_field - COCO */
+struct he_field {
+	t_u8 pad;
+	t_u16 data1;
+	t_u16 data2;
+	t_u16 data3;
+	t_u16 data4;
+	t_u16 data5;
+	t_u16 data6;
+} __packed;
+
+extern t_u8 ru_signal[16][9];
+extern t_u8 ru_signal_106[14][9];
+extern t_u8 ru_signal_52[9];
+
+#define MLAN_20_BIT_CH1P 0xC0000000
+#define MLAN_20_BIT_CH1S 0x0000003F
+#define MLAN_20_BIT_CH2 0x007F8000
+#define MLAN_80_CENTER_RU 0x00004000
+#define MLAN_160_CENTER_RU 0x40000000
+#define MLAN_20_BIT_CH3 0x00003FC0
+#define MLAN_20_BIT_CH4 0x7F800000
+#define MLAN_BIT_160_CH3 0x003FC000
+#define MLAN_BIT_160_CH4 0x03FC0000
+
+#define MLAN_DECODE_RU_SIGNALING_CH1(out, x, y)                                \
+	{                                                                      \
+		x = (((x << 8) & MLAN_20_BIT_CH1P)) >> 30;                     \
+		out = x | ((y & MLAN_20_BIT_CH1S) << 2);                       \
+	}
+
+#define MLAN_DECODE_RU_SIGNALING_CH3(out, x, y)                                \
+	{                                                                      \
+		out = ((y & MLAN_20_BIT_CH3) >> 6);                            \
+	}
+
+#define MLAN_DECODE_RU_SIGNALING_CH2(out, x, y)                                \
+	{                                                                      \
+		out = ((y & MLAN_20_BIT_CH2) >> 15);                           \
+	}
+
+#define MLAN_DECODE_RU_SIGNALING_CH4(out, x, y)                                \
+	{                                                                      \
+		out = ((y & MLAN_20_BIT_CH4) >> 23);                           \
+	}
+
+#define MLAN_DECODING_160_RU_CH3(out, x, y)                                    \
+	{                                                                      \
+		out = ((y & MLAN_BIT_160_CH3) >> 5);                           \
+	}
+
+#define MLAN_DECODING_160_RU_CH4(out, x, y)                                    \
+	{                                                                      \
+		out = ((y & MLAN_BIT_160_CH4) >> 22);                          \
+	}
+
+#define RU_SIGNAL_52_TONE 112
+#define TONE_MAX_USERS_52 4
+#define TONE_MAX_USERS_242 3
+#define RU_SIGNAL_26_TONE 0
+#define TONE_MAX_USERS_26 8
+#define RU_26_TONE_LIMIT 15
+#define RU_TONE_LIMIT 96
+#define RU_80_106_TONE 128
+#define RU_40_242_TONE 192
+#define RU_80_484_TONE 200
+#define RU_160_996_TONE 208
+#define RU_TONE_26 4
+#define RU_TONE_52 5
+#define RU_TONE_106 6
+#define RU_TONE_242 7
+#define RU_TONE_484 8
+#define RU_TONE_996 9
+
+#define MLAN_DECODE_RU_TONE(x, y, tone)                                           \
+	{                                                                         \
+		if ((x == RU_SIGNAL_52_TONE)) {                                   \
+			if (((y + 1) <= TONE_MAX_USERS_52)) {                     \
+				tone = RU_TONE_52;                                \
+			} else {                                                  \
+				y = (y + 1) - TONE_MAX_USERS_52;                  \
+			}                                                         \
+		} else if (x == RU_SIGNAL_26_TONE) {                              \
+			if ((y + 1) <= TONE_MAX_USERS_26) {                       \
+				tone = RU_TONE_26;                                \
+			} else {                                                  \
+				y = (y + 1) - TONE_MAX_USERS_26;                  \
+			}                                                         \
+		} else if (x <= RU_TONE_LIMIT) {                                  \
+			t_u32 ru_arr_idx;                                         \
+			ru_arr_idx = x > RU_26_TONE_LIMIT ? 1 : 0;                \
+			if ((y + 1) > (ru_arr_idx ? ru_signal_106[x / 8][8] :     \
+						    ru_signal[x][8])) {           \
+				y = (y + 1) -                                     \
+				    (ru_arr_idx ? ru_signal_106[x / 8][8] :       \
+						  ru_signal[x][8]);               \
+			} else {                                                  \
+				t_u32 ind = 0;                                    \
+				t_u32 idx = 0;                                    \
+				while (ind < 8) {                                 \
+					t_u32 tn =                                \
+						ru_arr_idx ?                      \
+							ru_signal_106[x / 8]      \
+								     [7 - ind] :  \
+							ru_signal[x][7 - ind];    \
+					ind++;                                    \
+					if (tn == 0x1 || tn == 0x0 ||             \
+					    tn == 0x2) {                          \
+						if (idx == y) {                   \
+							tone = tn ? (tn ==        \
+								     2) ?         \
+								    RU_TONE_106 : \
+								    RU_TONE_52 :  \
+								    RU_TONE_26;   \
+							break;                    \
+						} else {                          \
+							idx++;                    \
+						}                                 \
+					}                                         \
+				}                                                 \
+			}                                                         \
+		} else if (x == RU_80_106_TONE) {                                 \
+			if ((y + 1) > TONE_MAX_USERS_242) {                       \
+				y = (y + 1) - TONE_MAX_USERS_242;                 \
+			} else {                                                  \
+				tone = (y == 2) ? RU_TONE_106 :                   \
+						  (y == 1) ? 0 : RU_TONE_106;     \
+			}                                                         \
+		} else if (x == RU_40_242_TONE) {                                 \
+			if (!y) {                                                 \
+				tone = RU_TONE_242;                               \
+			} else {                                                  \
+				y--;                                              \
+			}                                                         \
+		} else if (x == RU_80_484_TONE) {                                 \
+			if (!y) {                                                 \
+				tone = RU_TONE_484;                               \
+			} else {                                                  \
+				y--;                                              \
+			}                                                         \
+		} else if (x == RU_160_996_TONE) {                                \
+			if (!y) {                                                 \
+				tone = RU_TONE_996;                               \
+			} else {                                                  \
+				y--;                                              \
+			}                                                         \
+		}                                                                 \
+	}
+
+/** radiotap_body.flags */
+#define RADIOTAP_FLAGS_DURING_CFG 0x01
+#define RADIOTAP_FLAGS_SHORT_PREAMBLE 0x02
+#define RADIOTAP_FLAGS_WEP_ENCRYPTION 0x04
+#define RADIOTAP_FLAGS_WITH_FRAGMENT 0x08
+#define RADIOTAP_FLAGS_INCLUDE_FCS 0x10
+#define RADIOTAP_FLAGS_PAD_BTW_HEADER_PAYLOAD 0x20
+#define RADIOTAP_FLAGS_FAILED_FCS_CHECK 0x40
+#define RADIOTAP_FLAGS_USE_SGI_HT 0x80
+struct radiotap_body {
+	/** timestamp */
+	t_u64 timestamp;
+	/** flags */
+	t_u8 flags;
+	/** rate for LG pkt, RATE flag will be present, it shows datarate in
+	 * 500Kbps. For HT/VHT pkt, RATE flag will not be present, it is not
+	 * used. */
+	t_u8 rate;
+	/** channel */
+	struct channel_field channel;
+	/** antenna_signal */
+	t_s8 antenna_signal;
+	/** antenna_noise */
+	t_s8 antenna_noise;
+	/** antenna */
+	t_u8 antenna;
+	/** union for HT/VHT pkt */
+	union {
+		/** mcs field */
+		struct mcs_field mcs;
+		/** vht field */
+		struct vht_field vht;
+		/** he field */
+		struct he_field he;
+	} u;
+} __packed;
+
+struct radiotap_header {
+	struct ieee80211_radiotap_header hdr;
+	struct radiotap_body body;
+} __packed;
+
+/** Roam offload config parameters */
+typedef struct woal_priv_fw_roam_offload_cfg {
+	/* User set passphrase*/
+	t_u8 userset_passphrase;
+	/* BSSID for fw roaming/auto_reconnect*/
+	t_u8 bssid[MLAN_MAC_ADDR_LENGTH];
+	/* Retry_count for fw roaming/auto_reconnect*/
+	t_u8 retry_count;
+	/* Condition to trigger roaming
+	 * Bit0 : RSSI low trigger
+	 * Bit1 : Pre-beacon lost trigger
+	 * Bit2 : Link Lost trigger
+	 * Bit3 : Deauth by ext-AP trigger
+	 * Bit4 ~ Bit15 : Reserved
+	 * value 0 : no trigger
+	 * value 0xff : invalid
+	 */
+	t_u16 trigger_condition;
+	/* SSID List(White list)*/
+	mlan_ds_misc_ssid_list ssid_list;
+	/* Black list(BSSID list)*/
+	mlan_ds_misc_roam_offload_aplist black_list;
+
+	/* RSSI paramters set flag*/
+	t_u8 rssi_param_set_flag;
+	/* MAX_RSSI for fw roaming*/
+	t_u8 max_rssi;
+	/*  MIN_RSSI for fw roaming*/
+	t_u8 min_rssi;
+	/*  Step_RSSI for fw roaming*/
+	t_u8 step_rssi;
+
+	/* BAND and RSSI_HYSTERESIS set flag*/
+	t_u8 band_rssi_flag;
+	mlan_ds_misc_band_rssi band_rssi;
+
+	/* BGSCAN params set flag*/
+	t_u8 bgscan_set_flag;
+	mlan_ds_misc_bgscan_cfg bgscan_cfg;
+
+	/* EES mode params set flag*/
+	t_u8 ees_param_set_flag;
+	mlan_ds_misc_ees_cfg ees_cfg;
+
+	/* Beacon miss threshold*/
+	t_u8 bcn_miss_threshold;
+
+	/* Beacon miss threshold*/
+	t_u8 pre_bcn_miss_threshold;
+
+	/* scan repeat count*/
+	t_u16 repeat_count;
+} woal_roam_offload_cfg;
+#ifdef STA_CFG80211
+int woal_set_clear_pmk(moal_private *priv, t_u8 action);
+#endif
+int woal_config_fw_roaming(moal_private *priv, t_u8 cfg_mode,
+			   woal_roam_offload_cfg *roam_offload_cfg);
+int woal_enable_fw_roaming(moal_private *priv, int data);
+
 #define GTK_REKEY_OFFLOAD_DISABLE 0
 #define GTK_REKEY_OFFLOAD_ENABLE 1
 #define GTK_REKEY_OFFLOAD_SUSPEND 2
 
+/** Monitor Band Channel Config */
+typedef struct _netmon_band_chan_cfg {
+	t_u32 band;
+	t_u32 channel;
+	t_u32 chan_bandwidth;
+} netmon_band_chan_cfg;
+
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+typedef struct _monitor_iface {
+	/* The priv data of interface on which the monitor iface is based */
+	moal_private *priv;
+	struct wireless_dev wdev;
+	int radiotap_enabled;
+	/* The net_device on which the monitor iface is based. */
+	struct net_device *base_ndev;
+	struct net_device *mon_ndev;
+	char ifname[IFNAMSIZ];
+	int flag;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	struct cfg80211_chan_def chandef;
+#endif
+	/** Netmon Band Channel Config */
+	netmon_band_chan_cfg band_chan_cfg;
+	/** Monitor device statistics structure */
+	struct net_device_stats stats;
+} monitor_iface;
+#endif
+
 #define MAX_KEEP_ALIVE_ID 4
+#define MAX_KEEP_ALIVE_RX_ID 4
 
 /** Operation data structure for MOAL bus interfaces */
 typedef struct _moal_if_ops {
@@ -1518,14 +2316,13 @@ enum ext_mod_params {
 #endif
 	EXT_REQ_FW_NOWAIT,
 	EXT_FW_SERIAL,
+	EXT_PM_KEEP_POWER,
 #ifdef SDIO
 	EXT_INTMODE,
 #ifdef SDIO_SUSPEND_RESUME
-	EXT_PM_KEEP_POWER,
 	EXT_SHUTDOWN_HS,
 #endif
 #endif
-	EXT_CNTRY_TXPWR,
 #if defined(USB)
 	EXT_SKIP_FWDNLD,
 #endif
@@ -1542,16 +2339,22 @@ enum ext_mod_params {
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	EXT_DFS_OFFLOAD,
 #endif
+	EXT_CFG80211_DRCS,
 	EXT_DISABLE_REGD_BY_DRIVER,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	EXT_COUNTRY_IE_IGNORE,
 	EXT_BEACON_HINTS,
 #endif
+	EXT_ROAMOFFLOAD_IN_HS,
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	EXT_HOST_MLME,
 #endif
 #endif
+	EXT_TX_WORK,
+	EXT_TX_SKB_CLONE,
+	EXT_PMQOS,
+	EXT_CHAN_TRACK,
 	EXT_MAX_PARAM,
 };
 
@@ -1562,11 +2365,20 @@ typedef struct _moal_mod_para {
 	t_u8 flag;
 	char *fw_name;
 	int fw_reload;
+	int auto_fw_reload;
 	char *mac_addr;
 #ifdef MFG_CMD_SUPPORT
 	int mfg_mode;
 #endif /* MFG_CMD_SUPPORT */
+	int rf_test_mode;
+	char *hw_name;
 	int drv_mode;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	int mon_filter;
+#endif
+#ifdef DEBUG_LEVEL1
+	int drvdbg;
+#endif
 #ifdef STA_SUPPORT
 	int max_sta_bss;
 	char *sta_name;
@@ -1575,6 +2387,7 @@ typedef struct _moal_mod_para {
 	int max_uap_bss;
 	char *uap_name;
 	int uap_max_sta;
+	int wacp_mode;
 #endif /* UAP_SUPPORT */
 #ifdef WIFI_DIRECT_SUPPORT
 	int max_wfd_bss;
@@ -1584,10 +2397,14 @@ typedef struct _moal_mod_para {
 #endif
 #endif /* WIFI_DIRECT_SUPPORT */
 	int auto_ds;
+	int net_rx;
+	int amsdu_deaggr;
+	int ext_scan;
 	int ps_mode;
 	int p2a_scan;
 	/** scan chan gap */
 	int scan_chan_gap;
+	int sched_scan;
 	int max_tx_buf;
 #if defined(SDIO)
 	int gpiopin;
@@ -1602,6 +2419,7 @@ typedef struct _moal_mod_para {
 	char *init_cfg;
 	char *cal_data_cfg;
 	char *txpwrlimit_cfg;
+	int cntry_txpwr;
 	char *init_hostcmd_cfg;
 	char *band_steer_cfg;
 	int cfg80211_wext;
@@ -1613,18 +2431,13 @@ typedef struct _moal_mod_para {
 #endif
 #ifdef PCIE
 	int pcie_int_mode;
+	int ring_size;
 #endif /* PCIE */
 #ifdef ANDROID_KERNEL
 	int wakelock_timeout;
 #endif
 	unsigned int dev_cap_mask;
-#if defined(SD8997) || defined(PCIE8997) || defined(USB8997) ||                \
-	defined(SD8977) || defined(SD8987) || defined(SD9098) ||               \
-	defined(USB9098) || defined(PCIE9098) || defined(SD9097) ||            \
-	defined(USB9097) || defined(PCIE9097) || defined(SD8978) ||            \
-	defined(USB8978)
 	int pmic;
-#endif
 	int antcfg;
 	unsigned int uap_oper_ctrl;
 	int hs_wake_interval;
@@ -1636,10 +2449,94 @@ typedef struct _moal_mod_para {
 	int gtk_rekey_offload;
 	t_u16 multi_dtim;
 	t_u16 inact_tmo;
+	int drcs_chantime_mode;
 	char *reg_alpha2;
 	int dfs53cfg;
+	t_u8 mcs32;
+
+#if defined(CONFIG_RPS)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	/* rps module param */
+	int rps;
+#endif
+#endif
+	int keep_previous_scan;
+	int auto_11ax;
+	/** hs_auto_arp setting */
+	int hs_auto_arp;
 } moal_mod_para;
 
+void woal_tp_acnt_timer_func(void *context);
+void woal_set_tp_state(moal_private *priv);
+#define MAX_TP_ACCOUNT_DROP_POINT_NUM 5
+#define RX_DROP_P1 (MAX_TP_ACCOUNT_DROP_POINT_NUM)
+#define RX_DROP_P2 (MAX_TP_ACCOUNT_DROP_POINT_NUM + 1)
+#define RX_DROP_P3 (MAX_TP_ACCOUNT_DROP_POINT_NUM + 2)
+#define RX_DROP_P4 (MAX_TP_ACCOUNT_DROP_POINT_NUM + 3)
+#define RX_DROP_P5 (MAX_TP_ACCOUNT_DROP_POINT_NUM + 4)
+#define TXRX_MAX_SAMPLE 50
+#define RX_TIME_PKT (MAX_TP_ACCOUNT_DROP_POINT_NUM + 5)
+#define TX_TIME_PKT (MAX_TP_ACCOUNT_DROP_POINT_NUM + 6)
+
+typedef struct _moal_tp_acnt_t {
+	/* TX accounting */
+	unsigned long tx_packets[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_packets_last[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_packets_rate[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_bytes[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_bytes_last[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_bytes_rate[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long tx_amsdu_cnt;
+	unsigned long tx_amsdu_cnt_last;
+	unsigned long tx_amsdu_cnt_rate;
+	unsigned long tx_amsdu_pkt_cnt;
+	unsigned long tx_amsdu_pkt_cnt_last;
+	unsigned long tx_amsdu_pkt_cnt_rate;
+	unsigned long tx_intr_cnt;
+	unsigned long tx_intr_last;
+	unsigned long tx_intr_rate;
+	unsigned long tx_pending;
+	unsigned long tx_xmit_skb_realloc_cnt;
+	unsigned long tx_stop_queue_cnt;
+	unsigned long tx_delay_driver[TXRX_MAX_SAMPLE];
+	/* drop_point1 to drop_point3 time */
+	unsigned long tx_delay1_driver[TXRX_MAX_SAMPLE];
+
+	/** RX accounting */
+	unsigned long rx_packets[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_packets_last[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_packets_rate[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_bytes[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_bytes_last[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_bytes_rate[MAX_TP_ACCOUNT_DROP_POINT_NUM];
+	unsigned long rx_amsdu_cnt;
+	unsigned long rx_amsdu_cnt_last;
+	unsigned long rx_amsdu_cnt_rate;
+	unsigned long rx_amsdu_pkt_cnt;
+	unsigned long rx_amsdu_pkt_cnt_last;
+	unsigned long rx_amsdu_pkt_cnt_rate;
+	unsigned long rx_intr_cnt;
+	unsigned long rx_intr_last;
+	unsigned long rx_intr_rate;
+	unsigned long rx_pending;
+	unsigned long rx_paused_cnt;
+	unsigned long rx_rdptr_full_cnt;
+	unsigned long rx_delay1_driver[TXRX_MAX_SAMPLE];
+	unsigned long rx_delay2_driver[TXRX_MAX_SAMPLE];
+	unsigned long rx_delay_kernel[TXRX_MAX_SAMPLE];
+	unsigned long rx_amsdu_delay[TXRX_MAX_SAMPLE];
+	unsigned long rx_amsdu_copy_delay[TXRX_MAX_SAMPLE];
+	t_u8 rx_amsdu_index;
+	t_u8 rx_index;
+	t_u8 tx_index;
+	/* TP account mode 0-disable 1-enable */
+	unsigned int on;
+	/* drop point */
+	unsigned int drop_point;
+	/* periodic timer */
+	moal_drv_timer timer;
+} moal_tp_acnt_t;
+
 /** Handle data structure for MOAL */
 struct _moal_handle {
 	/** MLAN adapter structure */
@@ -1651,6 +2548,11 @@ struct _moal_handle {
 	/** Bss attr */
 	moal_drv_mode drv_mode;
 
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+	/** Monitor interface */
+	monitor_iface *mon_if;
+#endif
+
 	/** set mac address flag */
 	t_u8 set_mac_addr;
 	/** MAC address */
@@ -1690,8 +2592,27 @@ struct _moal_handle {
 	BOOLEAN surprise_removed;
 	/** Firmware release number */
 	t_u32 fw_release_number;
+	/** Firmware Hotfix version */
+	t_u8 fw_hotfix_version;
+	/** Firmware support bands */
+	t_u16 fw_bands;
 	/** ECSA support */
 	t_u8 fw_ecsa_enable;
+	/** FW ROAMING support */
+	t_u8 fw_roam_enable;
+	/** FW ROAMING capability in fw */
+	t_u8 fw_roaming_support;
+	/** Retry count for auto reconnect based on FW ROAMING*/
+	t_u16 auto_reconnect_retry_count;
+	/** The SSID for auto reconnect FW ROAMING*/
+	mlan_802_11_ssid auto_reconnect_ssid;
+	/** The BSSID for auto reconnect FW ROAMING*/
+	mlan_802_11_mac_addr auto_reconnect_bssid;
+	/** The parameters for FW  ROAMING*/
+	woal_roam_offload_cfg fw_roam_params;
+	/** The keys for FW  ROAMING*/
+	mlan_ds_passphrase ssid_passphrase[MAX_SEC_SSID_NUM];
+
 	/** Getlog support */
 	t_u8 fw_getlog_enable;
 	/** Init wait queue token */
@@ -1718,6 +2639,12 @@ struct _moal_handle {
 	wait_queue_head_t hs_activate_wait_q __ATTRIB_ALIGN__;
 	/** auto_arp and ipv6 offload enable/disable flag */
 	t_u8 hs_auto_arp;
+#ifdef IMX_SUPPORT
+	/** wakeup irq number */
+	int irq_oob_wakeup;
+	/** wakeup notify flag */
+	bool wake_by_wifi;
+#endif /* IMX_SUPPORT */
 	/** Card pointer */
 	t_void *card;
 	/** Rx pending in MLAN */
@@ -1756,6 +2683,10 @@ struct _moal_handle {
 	/** Bitmap for re-association on/off */
 	t_u8 reassoc_on;
 #endif /* REASSOCIATION */
+	/** RTT capability */
+	wifi_rtt_capabilities rtt_capa;
+	/** RTT config */
+	wifi_rtt_config_params_t rtt_params;
 	/** Driver workqueue */
 	struct workqueue_struct *workqueue;
 	/** main work */
@@ -1778,14 +2709,26 @@ struct _moal_handle {
 	spinlock_t evt_lock;
 	/** event queue */
 	struct list_head evt_queue;
+	/** tx workqueue */
+	struct workqueue_struct *tx_workqueue;
+	/** tx work */
+	struct work_struct tx_work;
 	/** remain on channel flag */
 	t_u8 remain_on_channel;
 	/** bss index for remain on channel */
 	t_u8 remain_bss_index;
+	/** wifi hal enabled flag */
+	t_u8 wifi_hal_flag;
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 	struct wiphy *wiphy;
 	/** Country code for regulatory domain */
 	t_u8 country_code[COUNTRY_CODE_LEN];
+	/** dfs_region */
+	t_u8 dfs_region;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	/** regulatory work */
+	struct work_struct regulatory_work;
+#endif
 	/** band */
 	enum ieee80211_band band;
 	/** first scan done flag */
@@ -1870,6 +2813,8 @@ struct _moal_handle {
 #endif
 	/** cac period length, valid only when dfs testing is enabled */
 	long cac_period_jiffies;
+	/** cac restart*/
+	t_u8 cac_restart;
 	/** handle index - for multiple card supports */
 	t_u8 handle_idx;
 #if defined(USB)
@@ -1891,9 +2836,17 @@ struct _moal_handle {
 	struct semaphore async_sem;
 	/** scan channel gap */
 	t_u16 scan_chan_gap;
+	/** flag to check if specific scan time set by scancfg */
+	t_u8 user_scan_cfg;
 #ifdef STA_CFG80211
 	/** CFG80211 scan request description */
 	struct cfg80211_scan_request *scan_request;
+	/** fake scan flag */
+	u8 fake_scan_complete;
+	/** Scan timeout work*/
+	struct delayed_work scan_timeout_work;
+	/** scan timeout time */
+	t_u32 scan_timeout;
 #endif
 #endif
 	/** main state */
@@ -1904,14 +2857,27 @@ struct _moal_handle {
 	t_u8 driver_state;
 	/** ioctl timeout */
 	t_u8 ioctl_timeout;
+	/** Pointer of fw dump buffer */
+	t_u8 *drv_dump_buf;
+	/** drv dump len */
+	t_u32 drv_dump_len;
 	/** FW dump state */
 	t_u8 fw_dump;
 	/** event fw dump */
 	t_u8 event_fw_dump;
+	/** Re-association timer set flag */
+	BOOLEAN is_fw_dump_timer_set;
+	/** Re-association timer */
+	moal_drv_timer fw_dump_timer __ATTRIB_ALIGN__;
 	/** fw dump buffer total len */
 	t_u64 fw_dump_len;
+	/** fw dump status for each chip, useful in multichip drive */
+	BOOLEAN fw_dump_status;
+	/** Pointer of fw dump buffer */
+	t_u8 *fw_dump_buf;
 	/** FW dump full name */
 	t_u8 firmware_dump_file[128];
+
 #ifdef SDIO
 	/** cmd52 function */
 	t_u8 cmd52_func;
@@ -1940,7 +2906,7 @@ struct _moal_handle {
 	t_s8 driver_version[MLAN_MAX_VER_STR_LEN];
 	char *fwdump_fname;
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 	struct wakeup_source ws;
 #else
 	struct wake_lock wake_lock;
@@ -1950,7 +2916,13 @@ struct _moal_handle {
 	/* feature_control */
 	t_u32 feature_control;
 	struct notifier_block woal_notifier;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	struct notifier_block woal_inet6_notifier;
+#endif
+#endif
 	mlan_ds_misc_keep_alive keep_alive[MAX_KEEP_ALIVE_ID];
+	mlan_ds_misc_keep_alive_rx keep_alive_rx[MAX_KEEP_ALIVE_RX_ID];
 	struct net_device napi_dev;
 	struct napi_struct napi_rx;
 	/* bus interface operations */
@@ -1987,6 +2959,17 @@ struct _moal_handle {
 	t_u8 rf_test_mode;
 	/** pointer to rf test mode data struct */
 	struct rf_test_mode_data *rf_data;
+	/** TP accounting parameters */
+	moal_tp_acnt_t tp_acnt;
+	BOOLEAN is_tp_acnt_timer_set;
+
+	t_u8 request_pm;
+#ifdef IMX_SUPPORT
+//#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
+	struct pm_qos_request woal_pm_qos_req;
+//#endif
+#endif
+	t_u32 ips_ctrl;
 };
 
 /**
@@ -2432,6 +3415,18 @@ static inline moal_private *woal_get_vir_priv_bss_type(moal_handle *handle,
 }
 
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
+/** get any cfg80211 priv */
+static inline moal_private *woal_get_priv_with_wdev(moal_handle *handle)
+{
+	int i;
+	for (i = 0; i < MIN(handle->priv_num, MLAN_MAX_BSS_NUM); i++) {
+		if (handle->priv[i]) {
+			if (handle->priv[i]->wdev)
+				return handle->priv[i];
+		}
+	}
+	return NULL;
+}
 #endif
 
 static inline void woal_get_monotonic_time(wifi_timeval *tv)
@@ -2570,7 +3565,7 @@ pmlan_ioctl_req woal_alloc_mlan_ioctl_req(int size);
 /** Free buffer */
 void woal_free_mlan_buffer(moal_handle *handle, pmlan_buffer pmbuf);
 /** Get private structure of a BSS by index */
-moal_private *woal_bss_index_to_priv(moal_handle *handle, t_u8 bss_index);
+moal_private *woal_bss_index_to_priv(moal_handle *handle, t_u32 bss_index);
 /* Functions in init module */
 /** init module parameters */
 mlan_status woal_init_module_param(moal_handle *handle);
@@ -2584,6 +3579,7 @@ mlan_status woal_init_sw(moal_handle *handle);
 void woal_update_firmware_name(moal_handle *handle);
 /** cancel all works in the queue */
 void woal_terminate_workqueue(moal_handle *handle);
+void woal_flush_workqueue(moal_handle *handle);
 /** initializes firmware */
 mlan_status woal_init_fw(moal_handle *handle);
 /** frees the structure of moal_handle */
@@ -2634,6 +3630,7 @@ mlan_status woal_broadcast_event(moal_private *priv, t_u8 *payload, t_u32 len);
 mlan_status woal_switch_drv_mode(moal_handle *handle, t_u32 mode);
 #endif
 
+int woal_check_media_connected(t_void *pmoal);
 /** check if any interface is up */
 t_u8 woal_is_any_interface_active(moal_handle *handle);
 /** Get version */
@@ -2649,7 +3646,7 @@ int woal_reg_rx_mgmt_ind(moal_private *priv, t_u16 action,
 			 t_u32 *pmgmt_subtype_mask, t_u8 wait_option);
 #ifdef DEBUG_LEVEL1
 /** Set driver debug bit masks */
-int woal_set_drvdbg(moal_private *priv, t_u32 drvdbg);
+int woal_set_drvdbg(moal_private *priv, t_u32 drv_dbg);
 #endif
 
 mlan_status woal_set_get_tx_bf_cap(moal_private *priv, t_u16 action,
@@ -2671,7 +3668,7 @@ mlan_status woal_set_get_gen_ie(moal_private *priv, t_u32 action, t_u8 *ie,
 #ifdef CONFIG_PROC_FS
 mlan_status woal_request_soft_reset(moal_handle *handle);
 #endif
-void woal_request_fw_reload(moal_handle *phandle, t_u8 mode);
+int woal_request_fw_reload(moal_handle *phandle, t_u8 mode);
 
 /** Get debug information */
 mlan_status woal_get_debug_info(moal_private *priv, t_u8 wait_option,
@@ -2709,12 +3706,25 @@ int woal_enable_hs(moal_private *priv);
 /** Get wakeup reason */
 mlan_status woal_get_wakeup_reason(moal_private *priv,
 				   mlan_ds_hs_wakeup_reason *wakeup_reason);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-void woal_create_dump_dir(moal_handle *phandle, char *dir_buf, int buf_size);
-#endif
-mlan_status woal_save_dump_info_to_file(char *dir_name, char *file_name,
-					t_u8 *buf, t_u32 buf_len);
-void woal_dump_drv_info(moal_handle *phandle, t_u8 *dir_name);
+int woal_process_proc_hssetpara(moal_handle *handle, t_u8 *buf);
+#define FW_DUMP_INFO_LEN 0x280000
+/** mem dump header */
+typedef struct {
+	/** seq number */
+	t_u16 seq_num;
+	/** resvered */
+	t_u16 reserved;
+	/** type */
+	t_u16 type;
+	/** len */
+	t_u16 len;
+	/** start addr */
+	t_u32 start_addr;
+} mem_dump_header;
+int woal_save_dump_info_to_buf(moal_handle *phandle, t_u8 *src, t_u32 len,
+			       t_u32 type);
+void woal_append_end_block(moal_handle *phandle);
+t_u8 *woal_dump_drv_info(moal_handle *phandle, t_u32 *dump_len);
 
 #define FW_DUMP_TYPE_ENDED 0x002
 #define FW_DUMP_TYPE_MEM_ITCM 0x004
@@ -2732,13 +3742,8 @@ void woal_dump_firmware_info_v3(moal_handle *phandle);
 #endif /* SDIO_MMC */
 /* Store the FW dumps received from events in a file */
 void woal_store_firmware_dump(moal_handle *phandle, pmlan_event pmevent);
+void woal_send_fw_dump_complete_event(moal_private *priv);
 
-#if defined(PCIE)
-void woal_store_ssu_dump(moal_handle *phandle, pmlan_event pmevent);
-#endif /* SSU_SUPPORT */
-
-/** save hostcmd response to file */
-t_void woal_save_host_cmdresp(moal_handle *phandle, mlan_cmdresp_event *pevent);
 int woal_pre_warmreset(moal_private *priv);
 int woal_warmreset(moal_private *priv);
 
@@ -2764,6 +3769,10 @@ void woal_ioctl_get_info_resp(moal_private *priv, mlan_ds_get_info *info);
 mlan_status woal_get_assoc_rsp(moal_private *priv,
 			       mlan_ds_misc_assoc_rsp *assoc_rsp,
 			       t_u8 wait_option);
+mlan_status woal_get_assoc_req(moal_private *priv,
+			       mlan_ds_misc_assoc_req *assoc_req,
+			       t_u8 wait_option);
+
 /** Get signal information */
 mlan_status woal_get_signal_info(moal_private *priv, t_u8 wait_option,
 				 mlan_ds_get_signal *signal);
@@ -2859,7 +3868,7 @@ mlan_status woal_set_wapi_enable(moal_private *priv, t_u8 wait_option,
 /** Initialize priv */
 void woal_init_priv(moal_private *priv, t_u8 wait_option);
 /** Reset interface(s) */
-int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf);
+mlan_status woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf);
 #define TLV_TYPE_MGMT_IE (0x169)
 #define MGMT_MASK_ASSOC_REQ 0x01
 #define MGMT_MASK_REASSOC_REQ 0x04
@@ -2871,6 +3880,8 @@ int woal_reset_intf(moal_private *priv, t_u8 wait_option, int all_intf);
 #define MGMT_MASK_ASSOC_RESP_QOS_MAP 0x4000
 #define MGMT_MASK_BEACON_WPS_P2P 0x8000
 #define MLAN_CUSTOM_IE_DELETE_MASK 0x0
+#define MLAN_CUSTOM_IE_NEW_MASK 0x8000
+
 /** common ioctl for uap, station */
 int woal_custom_ie_ioctl(struct net_device *dev, struct ifreq *req);
 #ifdef UAP_SUPPORT
@@ -2882,6 +3893,8 @@ int woal_priv_get_nonglobal_operclass_by_bw_channel(moal_private *priv,
 int woal_send_host_packet(struct net_device *dev, struct ifreq *req);
 /** Private command ID to pass mgmt frame */
 #define WOAL_MGMT_FRAME_TX_IOCTL (SIOCDEVPRIVATE + 12)
+/** common ioctl for TDLS */
+int woal_tdls_config_ioctl(struct net_device *dev, struct ifreq *req);
 
 int woal_get_bss_type(struct net_device *dev, struct ifreq *req);
 #if defined(STA_WEXT) || defined(UAP_WEXT)
@@ -2955,9 +3968,15 @@ int woal_reassociation_thread(void *data);
 void woal_reassoc_timer_func(void *context);
 #endif /* REASSOCIATION */
 
+void woal_fw_dump_timer_func(void *context);
+
 t_void woal_main_work_queue(struct work_struct *work);
 t_void woal_rx_work_queue(struct work_struct *work);
 t_void woal_evt_work_queue(struct work_struct *work);
+t_void woal_mclist_work_queue(struct work_struct *work);
+#ifdef STA_CFG80211
+t_void woal_scan_timeout_handler(struct work_struct *work);
+#endif
 
 netdev_tx_t woal_hard_start_xmit(struct sk_buff *skb, struct net_device *dev);
 #ifdef STA_SUPPORT
@@ -2967,11 +3986,17 @@ mlan_status woal_init_sta_dev(struct net_device *dev, moal_private *priv);
 mlan_status woal_init_uap_dev(struct net_device *dev, moal_private *priv);
 #endif
 mlan_status woal_update_drv_tbl(moal_handle *handle, int drv_mode_local);
+void woal_fill_mlan_buffer(moal_private *priv, mlan_buffer *pmbuf,
+			   struct sk_buff *skb);
 moal_private *woal_add_interface(moal_handle *handle, t_u8 bss_num,
 				 t_u8 bss_type);
+void woal_clean_up(moal_handle *handle);
 void woal_remove_interface(moal_handle *handle, t_u8 bss_index);
 void woal_set_multicast_list(struct net_device *dev);
 mlan_status woal_request_fw(moal_handle *handle);
+mlan_status woal_ioctl_aggr_prio_tbl(moal_private *priv, t_u32 action,
+				     mlan_ds_11n_aggr_prio_tbl *aggr_prio_tbl);
+
 int woal_11h_channel_check_ioctl(moal_private *priv, t_u8 wait_option);
 void woal_cancel_cac_block(moal_private *priv);
 void woal_moal_debug_info(moal_private *priv, moal_handle *handle, u8 flag);
@@ -3028,6 +4053,9 @@ void woal_clear_conn_params(moal_private *priv);
 #endif
 
 void woal_flush_tcp_sess_queue(moal_private *priv);
+#ifdef STA_CFG80211
+void woal_flush_tdls_list(moal_private *priv);
+#endif
 void wlan_scan_create_brief_table_entry(t_u8 **ppbuffer,
 					BSSDescriptor_t *pbss_desc);
 int wlan_get_scan_table_ret_entry(BSSDescriptor_t *pbss_desc, t_u8 **ppbuffer,
@@ -3040,12 +4068,20 @@ void woal_flush_tx_stat_queue(moal_private *priv);
 struct tx_status_info *woal_get_tx_info(moal_private *priv, t_u8 tx_seq_num);
 void woal_remove_tx_info(moal_private *priv, t_u8 tx_seq_num);
 
+void woal_flush_mcast_list(moal_private *priv);
+t_void woal_add_mcast_node(moal_private *priv, t_u8 *mcast_addr);
+void woal_remove_mcast_node(moal_private *priv, t_u8 *mcast_addr);
+t_u8 woal_find_mcast_node_tx(moal_private *priv, struct sk_buff *skb);
+
 mlan_status woal_request_country_power_table(moal_private *priv, char *region);
-#ifdef RX_PACKET_COALESCE
-mlan_status woal_rx_pkt_coalesce_cfg(moal_private *priv, t_u16 *enable,
-				     t_u8 wait_option, t_u8 action);
+mlan_status woal_mc_policy_cfg(moal_private *priv, t_u16 *enable,
+			       t_u8 wait_option, t_u8 action);
+#ifdef UAP_SUPPORT
+void woal_check_mc_connection(moal_private *priv, t_u8 wait_option,
+			      t_u8 new_channel);
 #endif
 mlan_status woal_set_low_pwr_mode(moal_handle *handle, t_u8 wait_option);
+mlan_status woal_set_chan_track_mode(moal_handle *handle, t_u8 wait_option);
 int woal_hexval(char chr);
 mlan_status woal_pmic_configure(moal_handle *handle, t_u8 wait_option);
 mlan_status woal_set_user_antcfg(moal_handle *handle, t_u8 wait_option);
@@ -3056,12 +4092,19 @@ void woal_hist_data_add(moal_private *priv, t_u16 rx_rate, t_s8 snr, t_s8 nflr,
 			t_u8 antenna);
 mlan_status woal_set_hotspotcfg(moal_private *priv, t_u8 wait_option,
 				t_u32 hotspotcfg);
+
+#if defined(STA_CFG80211)
+mlan_status woal_multi_ap_cfg(moal_private *priv, t_u8 wait_option, t_u8 flag);
+#endif
+
 mlan_status woal_set_get_wowlan_config(moal_private *priv, t_u16 action,
 				       t_u8 wait_option,
 				       mlan_ds_misc_mef_flt_cfg *mefcfg);
 mlan_status woal_set_auto_arp_ext(moal_handle *handle, t_u8 enable);
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
-mlan_status woal_do_flr(moal_handle *handle, bool prepare);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+mlan_status woal_set_net_monitor(moal_private *priv, t_u8 wait_option,
+				 t_u8 enable, t_u8 filter,
+				 netmon_band_chan_cfg *band_chan_cfg);
 #endif
 mlan_status woal_delba_all(moal_private *priv, t_u8 wait_option);
 #ifdef STA_CFG80211
@@ -3080,8 +4123,43 @@ int woal_priv_save_cloud_keep_alive_params(
 	moal_private *priv, t_u8 mkeep_alive_id, t_u8 enable, t_u16 ether_type,
 	t_u8 *ip_pkt, t_u16 ip_pkt_len, t_u8 *src_mac, t_u8 *dst_mac,
 	t_u32 period_msec, t_u32 retry_interval, t_u8 retry_cnt);
+int woal_start_mkeep_alive_rx(moal_private *priv, t_u8 mkeep_alive_id,
+			      t_u8 *ip_pkt, t_u16 ip_pkt_len, t_u8 *src_mac,
+			      t_u8 *dst_mac);
+int woal_stop_mkeep_alive_rx(moal_private *priv, t_u8 mkeep_alive_id,
+			     t_u8 reset, t_u8 *ip_pkt, t_u8 *pkt_len);
+int woal_priv_save_cloud_keep_alive_params_rx(moal_private *priv,
+					      t_u8 mkeep_alive_id, t_u8 enable,
+					      t_u16 ether_type, t_u8 *ip_pkt,
+					      t_u16 ip_pkt_len, t_u8 *src_mac,
+					      t_u8 *dst_mac);
+void woal_channel_info_to_bandcfg(moal_private *priv,
+				  wifi_channel_info *ch_info,
+				  Band_Config_t *bandcfg);
+void woal_bandcfg_to_channel_info(moal_private *priv, Band_Config_t *bandcfg,
+				  t_u8 channel, wifi_channel_info *ch_info);
+mlan_status woal_config_rtt(moal_private *priv, t_u8 wait_option,
+			    wifi_rtt_config_params_t *rtt_params);
+mlan_status woal_cancel_rtt(moal_private *priv, t_u8 wait_option,
+			    t_u32 addr_num, t_u8 addr[][MLAN_MAC_ADDR_LENGTH]);
+mlan_status woal_rtt_responder_cfg(moal_private *priv, t_u8 wait_option,
+				   mlan_rtt_responder *rtt_rsp_cfg);
+#ifdef UAP_SUPPORT
+mlan_status woal_set_wacp_mode(moal_private *priv, t_u8 wait_option);
+#endif
 mlan_status woal_init_aggr_ctrl(moal_handle *handle, t_u8 wait_option);
 
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+monitor_iface *woal_prepare_mon_if(moal_private *priv, const char *name,
+				   unsigned char name_assign_type);
+#endif
+
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if KERNEL_VERSION(3, 14, 0) <= CFG80211_VERSION_CODE
+void woal_cfg80211_vendor_event_fw_dump(moal_private *priv);
+#endif
+#endif
+
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 mlan_status woal_set_rekey_data(moal_private *priv,
@@ -3093,5 +4171,13 @@ mlan_status woal_set_rekey_data(moal_private *priv,
 mlan_status woal_vdll_req_fw(moal_handle *handle);
 
 void woal_ioctl_get_misc_conf(moal_private *priv, mlan_ds_misc_cfg *info);
-t_u8 woal_get_second_channel_offset(int chan);
+t_u8 woal_get_second_channel_offset(moal_private *priv, int chan);
+
+#ifdef IMX_SUPPORT
+void woal_regist_oob_wakeup_irq(moal_handle *handle);
+void woal_unregist_oob_wakeup_irq(moal_handle *handle);
+void woal_disable_oob_wakeup_irq(moal_handle *handle);
+void woal_enable_oob_wakeup_irq(moal_handle *handle);
+irqreturn_t woal_oob_wakeup_irq_handler(int irq, void *priv);
+#endif /* IMX_SUPPORT */
 #endif /* _MOAL_MAIN_H */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.c
old mode 100644
new mode 100755
index 95364ff20..e7d60e1eb
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.c
@@ -4,7 +4,7 @@
  *  related functions.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -28,42 +28,42 @@ Change log:
 
 #include <linux/firmware.h>
 
-#include "moal_pcie.h"
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-#include <linux/pm_qos.h>
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#include "moal_cfg80211.h"
 #endif
 
+#include "moal_pcie.h"
+
 #if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
+#ifdef IMX_SUPPORT
 #include <linux/busfreq-imx.h>
 #endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+#include <net/addrconf.h>
+#endif
+#endif
+
 /********************************************************
 			Local Variables
 ********************************************************/
 #define DRV_NAME "NXP mdriver PCIe"
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-static struct pm_qos_request woal_pcie_pm_qos_req;
-#endif
-#endif
-
 /* PCIE resume handler */
 static int woal_pcie_resume(struct pci_dev *pdev);
 static void woal_pcie_reg_dbg(moal_handle *phandle);
 static void woal_pcie_unregister_dev(moal_handle *handle);
 static void woal_pcie_cleanup(pcie_service_card *card);
 static mlan_status woal_pcie_init(pcie_service_card *card);
-extern int pcie_int_mode;
-extern struct semaphore AddRemoveCardSem;
-extern moal_handle **m_handle;
 
 /** WLAN IDs */
 static const struct pci_device_id wlan_ids[] = {
 #ifdef PCIE8897
 	{
-		PCIE_VENDOR_ID_NXP,
-		PCIE_DEVICE_ID_NXP_88W8897P,
+		PCIE_VENDOR_ID_MRVL,
+		PCIE_DEVICE_ID_88W8897P,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
@@ -72,16 +72,16 @@ static const struct pci_device_id wlan_ids[] = {
 #endif
 #ifdef PCIE8997
 	{
-		PCIE_VENDOR_ID_NXP,
-		PCIE_DEVICE_ID_NXP_88W8997P,
+		PCIE_VENDOR_ID_MRVL,
+		PCIE_DEVICE_ID_88W8997P,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
 		0,
 	},
 	{
-		PCIE_VENDOR_ID_V2_NXP,
-		PCIE_DEVICE_ID_NXP_88W8997P,
+		PCIE_VENDOR_ID_V2_MRVL,
+		PCIE_DEVICE_ID_88W8997P,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
@@ -90,8 +90,8 @@ static const struct pci_device_id wlan_ids[] = {
 #endif
 #ifdef PCIE9097
 	{
-		PCIE_VENDOR_ID_V2_NXP,
-		PCIE_DEVICE_ID_NXP_88W9097,
+		PCIE_VENDOR_ID_V2_MRVL,
+		PCIE_DEVICE_ID_88W9097,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
@@ -100,22 +100,49 @@ static const struct pci_device_id wlan_ids[] = {
 #endif
 #ifdef PCIE9098
 	{
-		PCIE_VENDOR_ID_V2_NXP,
-		PCIE_DEVICE_ID_NXP_88W9098P_FN0,
+		PCIE_VENDOR_ID_V2_MRVL,
+		PCIE_DEVICE_ID_88W9098P_FN0,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
 		0,
 	},
 	{
-		PCIE_VENDOR_ID_V2_NXP,
-		PCIE_DEVICE_ID_NXP_88W9098P_FN1,
+		PCIE_VENDOR_ID_V2_MRVL,
+		PCIE_DEVICE_ID_88W9098P_FN1,
 		PCI_ANY_ID,
 		PCI_ANY_ID,
 		0,
 		0,
 	},
 #endif
+	{
+		PCIE_VENDOR_ID_NXP,
+		PCIE_DEVICE_ID_88WAW693_FN0,
+		PCI_ANY_ID,
+		PCI_ANY_ID,
+		0,
+		0,
+	},
+	{
+		PCIE_VENDOR_ID_NXP,
+		PCIE_DEVICE_ID_88WAW693_FN1,
+		PCI_ANY_ID,
+		PCI_ANY_ID,
+		0,
+		0,
+	},
+#ifdef PCIEIW62X
+	{
+		PCIE_VENDOR_ID_NXP,
+		PCIE_DEVICE_ID_88WIW62X,
+		PCI_ANY_ID,
+		PCI_ANY_ID,
+		0,
+		0,
+	},
+#endif
+
 	{},
 };
 /* moal interface ops */
@@ -128,7 +155,10 @@ static moal_if_ops pcie_ops;
 /********************************************************
 			Local Functions
 ********************************************************/
+
 static mlan_status woal_pcie_preinit(struct pci_dev *pdev);
+static rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag,
+					   t_u8 resetflag);
 
 /**  @brief This function updates the card types
  *
@@ -144,7 +174,7 @@ static t_u16 woal_update_card_type(t_void *card)
 
 	/* Update card type */
 #ifdef PCIE8897
-	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_NXP_88W8897P) {
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88W8897P) {
 		card_type = CARD_TYPE_PCIE8897;
 		moal_memcpy_ext(NULL, driver_version, CARD_PCIE8897,
 				strlen(CARD_PCIE8897), strlen(driver_version));
@@ -157,7 +187,7 @@ static t_u16 woal_update_card_type(t_void *card)
 	}
 #endif
 #ifdef PCIE8997
-	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_NXP_88W8997P) {
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88W8997P) {
 		card_type = CARD_TYPE_PCIE8997;
 		moal_memcpy_ext(NULL, driver_version, CARD_PCIE8997,
 				strlen(CARD_PCIE8997), strlen(driver_version));
@@ -170,7 +200,7 @@ static t_u16 woal_update_card_type(t_void *card)
 	}
 #endif
 #ifdef PCIE9097
-	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_NXP_88W9097) {
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88W9097) {
 		card_type = CARD_TYPE_PCIE9097;
 		moal_memcpy_ext(NULL, driver_version, CARD_PCIE9097,
 				strlen(CARD_PCIE9097), strlen(driver_version));
@@ -183,8 +213,8 @@ static t_u16 woal_update_card_type(t_void *card)
 	}
 #endif
 #ifdef PCIE9098
-	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN0 ||
-	    cardp_pcie->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN1) {
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88W9098P_FN0 ||
+	    cardp_pcie->dev->device == PCIE_DEVICE_ID_88W9098P_FN1) {
 		card_type = CARD_TYPE_PCIE9098;
 		moal_memcpy_ext(NULL, driver_version, CARD_PCIE9098,
 				strlen(CARD_PCIE9098), strlen(driver_version));
@@ -196,6 +226,32 @@ static t_u16 woal_update_card_type(t_void *card)
 					strlen(KERN_VERSION));
 	}
 #endif
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88WAW693_FN0 ||
+	    cardp_pcie->dev->device == PCIE_DEVICE_ID_88WAW693_FN1) {
+		card_type = CARD_TYPE_PCIEAW693;
+		moal_memcpy_ext(NULL, driver_version, CARD_PCIEAW693,
+				strlen(CARD_PCIEAW693), strlen(driver_version));
+		moal_memcpy_ext(NULL,
+				driver_version + strlen(INTF_CARDTYPE) +
+					strlen(KERN_VERSION),
+				V17, strlen(V17),
+				strlen(driver_version) - strlen(INTF_CARDTYPE) -
+					strlen(KERN_VERSION));
+	}
+#ifdef PCIEIW62X
+	if (cardp_pcie->dev->device == PCIE_DEVICE_ID_88WIW62X) {
+		card_type = CARD_TYPE_PCIEIW62X;
+		moal_memcpy_ext(NULL, driver_version, CARD_PCIEIW62X,
+				strlen(CARD_PCIEIW62X), strlen(driver_version));
+		moal_memcpy_ext(NULL,
+				driver_version + strlen(INTF_CARDTYPE) +
+					strlen(KERN_VERSION),
+				V18, strlen(V18),
+				strlen(driver_version) - strlen(INTF_CARDTYPE) -
+					strlen(KERN_VERSION));
+	}
+#endif
+
 	return card_type;
 }
 
@@ -206,6 +262,7 @@ static t_u16 woal_update_card_type(t_void *card)
  * @param handle    A pointer to moal_handle structure
  * @param prepare   True :- its a pre FLR call from the kernel
  *		    False :- its a post FLR call from the kernel
+ * @param flr       True: call from FLR
  *
  * Note: This function is mix of woal_switch_drv_mode() and
  * remove_card(). Idea is to cleanup the software only without
@@ -214,14 +271,14 @@ static t_u16 woal_update_card_type(t_void *card)
  *
  * @return        MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_do_flr(moal_handle *handle, bool prepare)
+static mlan_status woal_do_flr(moal_handle *handle, bool prepare, bool flr_flag)
 {
 	unsigned int i;
 	int index = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	moal_private *priv = NULL;
 	pcie_service_card *card = NULL;
-	int fw_serial_bkp;
+	int fw_serial_bkp = 0;
 
 	ENTER();
 
@@ -241,6 +298,8 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 
 	if (!IS_PCIE8997(handle->card_type) &&
 	    !IS_PCIE9097(handle->card_type) &&
+	    !IS_PCIEIW62X(handle->card_type) &&
+	    !IS_PCIEAW693(handle->card_type) &&
 	    !IS_PCIE9098(handle->card_type)) {
 		LEAVE();
 		return status;
@@ -255,6 +314,7 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 	/* Reset all interfaces */
 	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
 	woal_reset_intf(priv, MOAL_IOCTL_WAIT, MTRUE);
+	woal_clean_up(handle);
 
 	/* Shutdown firmware */
 	handle->init_wait_q_woken = MFALSE;
@@ -274,6 +334,21 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 		       atomic_read(&handle->ioctl_pending));
 	}
 
+	unregister_inetaddr_notifier(&handle->woal_notifier);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
+#if IS_ENABLED(CONFIG_IPV6)
+	unregister_inet6addr_notifier(&handle->woal_inet6_notifier);
+#endif
+#endif
+
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
+	/* Remove virtual interface */
+	woal_remove_virtual_interface(handle);
+#endif
+#endif
+#endif
 	/* Remove interface */
 	for (i = 0; i < handle->priv_num; i++)
 		woal_remove_interface(handle, i);
@@ -310,20 +385,21 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 		goto err_init_fw;
 	}
 
-#ifdef PCIE9098
-	if (card->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN1)
+	if ((card->dev->device == PCIE_DEVICE_ID_88W9098P_FN1) ||
+	    (card->dev->device == PCIE_DEVICE_ID_88WAW693_FN1))
 		mlan_set_int_mode(handle->pmlan_adapter, pcie_int_mode, 1);
 	else
-#endif
 		/* Update pcie_int_mode in mlan adapter */
 		mlan_set_int_mode(handle->pmlan_adapter,
 				  handle->params.pcie_int_mode, 0);
 
 	/* Init FW and HW */
 	/* Load wlan only binary */
-	fw_serial_bkp = moal_extflg_isset(handle, EXT_FW_SERIAL);
-	moal_extflg_clear(handle, EXT_FW_SERIAL);
-	woal_update_firmware_name(handle);
+	if (flr_flag) {
+		fw_serial_bkp = moal_extflg_isset(handle, EXT_FW_SERIAL);
+		moal_extflg_clear(handle, EXT_FW_SERIAL);
+		woal_update_firmware_name(handle);
+	}
 	if (woal_init_fw(handle)) {
 		PRINTM(MFATAL, "Firmware Init Failed\n");
 		woal_pcie_reg_dbg(handle);
@@ -331,8 +407,10 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 			moal_extflg_set(handle, EXT_FW_SERIAL);
 		goto err_init_fw;
 	}
-	if (fw_serial_bkp)
+	if (flr_flag && fw_serial_bkp)
 		moal_extflg_set(handle, EXT_FW_SERIAL);
+	if (IS_PCIE9098(handle->card_type))
+		handle->event_fw_dump = MTRUE;
 exit:
 	MOAL_REL_SEMAPHORE(&AddRemoveCardSem);
 
@@ -351,7 +429,7 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
 						 handle->init_wait_q_woken);
 	}
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 	wakeup_source_trash(&handle->ws);
 #else
 	wake_lock_destroy(&handle->wake_lock);
@@ -395,7 +473,7 @@ mlan_status woal_do_flr(moal_handle *handle, bool prepare)
  *
  *  @return         error code
  */
-int woal_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
+static int woal_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	pcie_service_card *card = NULL;
 	t_u16 card_type = 0;
@@ -428,7 +506,11 @@ int woal_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		ret = MLAN_STATUS_FAILURE;
 		goto err;
 	}
-	woal_pcie_init(card);
+	if (MLAN_STATUS_SUCCESS != woal_pcie_init(card)) {
+		PRINTM(MERROR, "woal_pcie_init failed\n");
+		ret = -EFAULT;
+		goto err;
+	}
 
 	if (woal_add_card(card, &card->dev->dev, &pcie_ops, card_type) ==
 	    NULL) {
@@ -438,6 +520,10 @@ int woal_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto err;
 	}
 
+#ifdef IMX_SUPPORT
+	woal_regist_oob_wakeup_irq(card->handle);
+#endif /* IMX_SUPPORT */
+
 	LEAVE();
 	return ret;
 err:
@@ -476,6 +562,10 @@ static void woal_pcie_remove(struct pci_dev *dev)
 		return;
 	}
 	handle->surprise_removed = MTRUE;
+
+#ifdef IMX_SUPPORT
+	woal_unregist_oob_wakeup_irq(card->handle);
+#endif /* IMX_SUPPORT */
 	woal_remove_card(card);
 	woal_pcie_cleanup(card);
 	kfree(card);
@@ -484,6 +574,44 @@ static void woal_pcie_remove(struct pci_dev *dev)
 	return;
 }
 
+/**
+ *  @brief This function handles PCIE driver remove
+ *
+ *  @param pdev     A pointer to pci_dev structure
+ *
+ *  @return         error code
+ */
+static void woal_pcie_shutdown(struct pci_dev *dev)
+{
+	pcie_service_card *card;
+	moal_handle *handle;
+
+	ENTER();
+	PRINTM(MCMND, "<--- Enter woal_pcie_shutdown --->\n");
+
+	card = pci_get_drvdata(dev);
+	if (!card) {
+		PRINTM(MINFO, "PCIE card removed from slot\n");
+		LEAVE();
+		return;
+	}
+	handle = card->handle;
+	if (handle->second_mac)
+		goto done;
+	if (IS_PCIE9098(handle->card_type) || IS_PCIEIW62X(handle->card_type) ||
+	    IS_PCIEAW693(handle->card_type) || IS_PCIE9097(handle->card_type)) {
+		if (RDWR_STATUS_FAILURE !=
+		    woal_pcie_rdwr_firmware(handle, 0, 1))
+			PRINTM(MMSG, "wlan: start in-bound IR...\n");
+	}
+done:
+	handle->surprise_removed = MTRUE;
+	pci_disable_device(dev);
+	PRINTM(MCMND, "<--- Leave woal_pcie_shutdown --->\n");
+	LEAVE();
+	return;
+}
+
 /**
  *  @brief Handle suspend
  *
@@ -496,13 +624,14 @@ static int woal_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
 {
 	pcie_service_card *cardp;
 	moal_handle *handle = NULL;
+	moal_handle *ref_handle = NULL;
 	int i;
 	int ret = MLAN_STATUS_SUCCESS;
 	int hs_actived;
 	mlan_ds_ps_info pm_info;
+	int keep_power = 0;
 
 	ENTER();
-	PRINTM(MCMND, "<--- Enter woal_pcie_suspend --->\n");
 	if (pdev) {
 		cardp = (pcie_service_card *)pci_get_drvdata(pdev);
 		if (!cardp || !cardp->handle) {
@@ -516,6 +645,10 @@ static int woal_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
 	}
 
 	handle = cardp->handle;
+	if (handle->second_mac)
+		PRINTM(MCMND, "<--- Enter woal_pcie_suspend# --->\n");
+	else
+		PRINTM(MCMND, "<--- Enter woal_pcie_suspend --->\n");
 	if (handle->is_suspended == MTRUE) {
 		PRINTM(MWARN, "Device already suspended\n");
 		LEAVE();
@@ -554,27 +687,43 @@ static int woal_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
 
 	for (i = 0; i < handle->priv_num; i++)
 		netif_device_detach(handle->priv[i]->netdev);
-
-	/* Enable Host Sleep */
-	hs_actived = woal_enable_hs(woal_get_priv(handle, MLAN_BSS_ROLE_ANY));
-	if (hs_actived == MTRUE) {
-		/* Indicate device suspended */
+	if (moal_extflg_isset(handle, EXT_PM_KEEP_POWER))
+		keep_power = MTRUE;
+	else
+		keep_power = MFALSE;
+
+	if (keep_power) {
+		/* Enable Host Sleep */
+		hs_actived = woal_enable_hs(
+			woal_get_priv(handle, MLAN_BSS_ROLE_ANY));
+		if (hs_actived == MTRUE) {
+			/* Indicate device suspended */
+			handle->is_suspended = MTRUE;
+		} else {
+			PRINTM(MMSG, "HS not actived, suspend fail!");
+			handle->suspend_fail = MTRUE;
+			for (i = 0; i < handle->priv_num; i++)
+				netif_device_attach(handle->priv[i]->netdev);
+			ret = -EBUSY;
+			goto done;
+		}
+	}
+	woal_flush_workqueue(handle);
+	if (!keep_power) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+		woal_do_flr(handle, true, false);
+#endif
+		handle->surprise_removed = MTRUE;
 		handle->is_suspended = MTRUE;
-	} else {
-		PRINTM(MMSG, "HS not actived, suspend fail!");
-		handle->suspend_fail = MTRUE;
-		for (i = 0; i < handle->priv_num; i++)
-			netif_device_attach(handle->priv[i]->netdev);
-		ret = -EBUSY;
-		goto done;
 	}
-	flush_workqueue(handle->workqueue);
-	flush_workqueue(handle->evt_workqueue);
-	if (handle->rx_workqueue)
-		flush_workqueue(handle->rx_workqueue);
+#ifdef IMX_SUPPORT
+	woal_enable_oob_wakeup_irq(handle);
+#endif /* IMX_SUPPORT */
 	pci_enable_wake(pdev, pci_choose_state(pdev, state), 1);
 	pci_save_state(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	ref_handle = (moal_handle *)handle->pref_mac;
+	if (ref_handle && ref_handle->is_suspended)
+		pci_set_power_state(pdev, pci_choose_state(pdev, state));
 done:
 	PRINTM(MCMND, "<--- Leave woal_pcie_suspend --->\n");
 	LEAVE();
@@ -591,15 +740,14 @@ static int woal_pcie_suspend(struct pci_dev *pdev, pm_message_t state)
 static int woal_pcie_resume(struct pci_dev *pdev)
 {
 	moal_handle *handle;
-	pcie_service_card *card;
+	pcie_service_card *cardp;
+	int keep_power = 0;
 	int i;
 
 	ENTER();
-
-	PRINTM(MCMND, "<--- Enter woal_pcie_resume --->\n");
 	if (pdev) {
-		card = (pcie_service_card *)pci_get_drvdata(pdev);
-		if (!card || !card->handle) {
+		cardp = (pcie_service_card *)pci_get_drvdata(pdev);
+		if (!cardp || !cardp->handle) {
 			PRINTM(MERROR, "Card or handle is not valid\n");
 			LEAVE();
 			return MLAN_STATUS_SUCCESS;
@@ -609,29 +757,45 @@ static int woal_pcie_resume(struct pci_dev *pdev)
 		LEAVE();
 		return -ENOSYS;
 	}
-	pci_set_power_state(pdev, PCI_D0);
-	pci_restore_state(pdev);
-	pci_enable_wake(pdev, PCI_D0, 0);
-
-	handle = card->handle;
-
+	handle = cardp->handle;
+	if (handle->second_mac)
+		PRINTM(MCMND, "<--- Enter woal_pcie_resume# --->\n");
+	else
+		PRINTM(MCMND, "<--- Enter woal_pcie_resume --->\n");
 	if (handle->is_suspended == MFALSE) {
 		PRINTM(MWARN, "Device already resumed\n");
 		goto done;
 	}
-
 	handle->is_suspended = MFALSE;
 
-	if (woal_check_driver_status(handle)) {
-		PRINTM(MERROR, "Resuem, device is in hang state\n");
-		LEAVE();
-		return MLAN_STATUS_SUCCESS;
-	}
-	for (i = 0; i < handle->priv_num; i++)
-		netif_device_attach(handle->priv[i]->netdev);
+	if (moal_extflg_isset(handle, EXT_PM_KEEP_POWER))
+		keep_power = MTRUE;
+	else
+		keep_power = MFALSE;
 
-	woal_cancel_hs(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), MOAL_NO_WAIT);
+	pci_set_power_state(pdev, PCI_D0);
+	pci_restore_state(pdev);
+	pci_enable_wake(pdev, PCI_D0, 0);
+	if (!keep_power) {
+		handle->surprise_removed = MFALSE;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+		woal_do_flr(handle, false, false);
+#endif
+	} else {
+		if (woal_check_driver_status(handle)) {
+			PRINTM(MERROR, "Resuem, device is in hang state\n");
+			LEAVE();
+			return MLAN_STATUS_SUCCESS;
+		}
+		for (i = 0; i < handle->priv_num; i++)
+			netif_device_attach(handle->priv[i]->netdev);
 
+		woal_cancel_hs(woal_get_priv(handle, MLAN_BSS_ROLE_ANY),
+			       MOAL_NO_WAIT);
+#ifdef IMX_SUPPORT
+		woal_disable_oob_wakeup_irq(handle);
+#endif /* IMX_SUPPORT */
+	}
 done:
 	PRINTM(MCMND, "<--- Leave woal_pcie_resume --->\n");
 	LEAVE();
@@ -687,10 +851,10 @@ static void woal_pcie_reset_prepare(struct pci_dev *pdev)
 		}
 	}
 	handle->surprise_removed = MTRUE;
-	woal_do_flr(handle, true);
+	woal_do_flr(handle, true, true);
 	if (ref_handle) {
 		ref_handle->surprise_removed = MTRUE;
-		woal_do_flr(ref_handle, true);
+		woal_do_flr(ref_handle, true, true);
 	}
 
 	LEAVE();
@@ -739,16 +903,16 @@ static void woal_pcie_reset_done(struct pci_dev *pdev)
 		}
 	}
 	handle->surprise_removed = MFALSE;
-	woal_do_flr(handle, false);
+	woal_do_flr(handle, false, true);
 	if (ref_handle) {
 		ref_handle->surprise_removed = MFALSE;
-		woal_do_flr(ref_handle, false);
+		woal_do_flr(ref_handle, false, true);
 	}
 
 	LEAVE();
 }
 #else
-void woal_pcie_reset_notify(struct pci_dev *pdev, bool prepare)
+static void woal_pcie_reset_notify(struct pci_dev *pdev, bool prepare)
 {
 	pcie_service_card *card;
 	moal_handle *handle;
@@ -791,10 +955,10 @@ void woal_pcie_reset_notify(struct pci_dev *pdev, bool prepare)
 		 * Note. FW might not be healthy.
 		 */
 		handle->surprise_removed = MTRUE;
-		woal_do_flr(handle, prepare);
+		woal_do_flr(handle, prepare, true);
 		if (ref_handle) {
 			ref_handle->surprise_removed = MTRUE;
-			woal_do_flr(ref_handle, prepare);
+			woal_do_flr(ref_handle, prepare, true);
 		}
 	} else {
 		/* Kernel stores and restores PCIe function context before and
@@ -803,10 +967,10 @@ void woal_pcie_reset_notify(struct pci_dev *pdev, bool prepare)
 		 * Reconfigure the sw and fw including fw redownload
 		 */
 		handle->surprise_removed = MFALSE;
-		woal_do_flr(handle, prepare);
+		woal_do_flr(handle, prepare, true);
 		if (ref_handle) {
 			ref_handle->surprise_removed = MFALSE;
-			woal_do_flr(ref_handle, prepare);
+			woal_do_flr(ref_handle, prepare, true);
 		}
 	}
 	LEAVE();
@@ -833,6 +997,7 @@ static struct pci_driver REFDATA wlan_pcie = {
 	.id_table = wlan_ids,
 	.probe = woal_pcie_probe,
 	.remove = woal_pcie_remove,
+	.shutdown = woal_pcie_shutdown,
 #ifdef CONFIG_PM
 	/* Power Management Hooks */
 	.suspend = woal_pcie_suspend,
@@ -897,8 +1062,9 @@ static mlan_status woal_pcie_read_reg(moal_handle *handle, t_u32 reg,
  *
  *  @return    		MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_pcie_write_data_sync(moal_handle *handle, mlan_buffer *pmbuf,
-				      t_u32 port, t_u32 timeout)
+static mlan_status woal_pcie_write_data_sync(moal_handle *handle,
+					     mlan_buffer *pmbuf, t_u32 port,
+					     t_u32 timeout)
 {
 	return MLAN_STATUS_SUCCESS;
 }
@@ -913,8 +1079,9 @@ mlan_status woal_pcie_write_data_sync(moal_handle *handle, mlan_buffer *pmbuf,
  *
  *  @return    		MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_pcie_read_data_sync(moal_handle *handle, mlan_buffer *pmbuf,
-				     t_u32 port, t_u32 timeout)
+static mlan_status woal_pcie_read_data_sync(moal_handle *handle,
+					    mlan_buffer *pmbuf, t_u32 port,
+					    t_u32 timeout)
 {
 	return MLAN_STATUS_SUCCESS;
 }
@@ -953,9 +1120,16 @@ static irqreturn_t woal_pcie_interrupt(int irq, void *dev_id)
 	}
 	PRINTM(MINFO, "*** IN PCIE IRQ ***\n");
 	handle->main_state = MOAL_RECV_INT;
-	PRINTM(MINTR, "*\n");
+	if (handle->second_mac)
+		PRINTM(MINTR, "**\n");
+	else
+		PRINTM(MINTR, "*\n");
 
 	ret = mlan_interrupt(0xffff, handle->pmlan_adapter);
+	if (handle->is_suspended) {
+		PRINTM(MINTR, "Receive interrupt in hs_suspended\n");
+		goto exit;
+	}
 	queue_work(handle->workqueue, &handle->main_work);
 
 exit:
@@ -1006,7 +1180,10 @@ static irqreturn_t woal_pcie_msix_interrupt(int irq, void *dev_id)
 	}
 	PRINTM(MINFO, "*** IN PCIE IRQ ***\n");
 	handle->main_state = MOAL_RECV_INT;
-	PRINTM(MINTR, "*\n");
+	if (handle->second_mac)
+		PRINTM(MINTR, "**\n");
+	else
+		PRINTM(MINTR, "*\n");
 	ret = mlan_interrupt(ctx->msg_id, handle->pmlan_adapter);
 	queue_work(handle->workqueue, &handle->main_work);
 
@@ -1028,20 +1205,32 @@ static mlan_status woal_pcie_preinit(struct pci_dev *pdev)
 {
 	int ret;
 
+	if (pdev->multifunction)
+		device_disable_async_suspend(&pdev->dev);
+
 	ret = pci_enable_device(pdev);
+
 	if (ret)
 		goto err_enable_dev;
 
 	pci_set_master(pdev);
 
 	PRINTM(MINFO, "Try set_consistent_dma_mask(32)\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	ret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+#else
 	ret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+#endif
 	if (ret) {
 		PRINTM(MERROR, "set_dma_mask(32) failed\n");
 		goto err_set_dma_mask;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+#else
 	ret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+#endif
 	if (ret) {
 		PRINTM(MERROR, "set_consistent_dma_mask(64) failed\n");
 		goto err_set_dma_mask;
@@ -1062,7 +1251,7 @@ static mlan_status woal_pcie_preinit(struct pci_dev *pdev)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_pcie_init(pcie_service_card *card)
+static mlan_status woal_pcie_init(pcie_service_card *card)
 {
 	struct pci_dev *pdev = NULL;
 	int ret;
@@ -1077,13 +1266,21 @@ mlan_status woal_pcie_init(pcie_service_card *card)
 	pci_set_master(pdev);
 
 	PRINTM(MINFO, "Try set_consistent_dma_mask(32)\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	ret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+#else
 	ret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+#endif
 	if (ret) {
 		PRINTM(MERROR, "set_dma_mask(32) failed\n");
 		goto err_set_dma_mask;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+#else
 	ret = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+#endif
 	if (ret) {
 		PRINTM(MERROR, "set_consistent_dma_mask(64) failed\n");
 		goto err_set_dma_mask;
@@ -1111,7 +1308,7 @@ mlan_status woal_pcie_init(pcie_service_card *card)
 		goto err_iomap2;
 	}
 
-	PRINTM(MINFO,
+	PRINTM(MMSG,
 	       "PCI memory map Virt0: %p PCI memory map Virt2: "
 	       "%p\n",
 	       card->pci_mmap, card->pci_mmap1);
@@ -1231,7 +1428,6 @@ static mlan_status woal_pcie_register_dev(moal_handle *handle)
 				  "mrvl_pcie", pdev);
 		if (ret) {
 			PRINTM(MFATAL, "request_irq failed: ret=%d\n", ret);
-			handle->card = NULL;
 			ret = MLAN_STATUS_FAILURE;
 			goto done;
 		}
@@ -1240,17 +1436,15 @@ static mlan_status woal_pcie_register_dev(moal_handle *handle)
 
 	default:
 		PRINTM(MFATAL, "pcie_int_mode %d failed\n", pcie_int_mode);
-		handle->card = NULL;
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
 		break;
 	}
 
-#ifdef PCIE9098
-	if (card->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN1)
+	if ((card->dev->device == PCIE_DEVICE_ID_88W9098P_FN1) ||
+	    (card->dev->device == PCIE_DEVICE_ID_88WAW693_FN1))
 		mlan_set_int_mode(handle->pmlan_adapter, pcie_int_mode, 1);
 	else
-#endif
 		mlan_set_int_mode(handle->pmlan_adapter, pcie_int_mode, 0);
 
 done:
@@ -1265,7 +1459,7 @@ static mlan_status woal_pcie_register_dev(moal_handle *handle)
  *
  *  @return         N/A
  */
-void woal_pcie_cleanup(pcie_service_card *card)
+static void woal_pcie_cleanup(pcie_service_card *card)
 {
 	struct pci_dev *pdev = NULL;
 	pdev = card->dev;
@@ -1348,23 +1542,9 @@ mlan_status woal_pcie_bus_register(void)
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	ENTER();
 
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-	pm_qos_add_request(&woal_pcie_pm_qos_req, PM_QOS_CPU_DMA_LATENCY, 0);
-#endif
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
-	request_bus_freq(BUS_FREQ_HIGH);
-#endif
 	/* API registers the NXP PCIE driver */
 	if (pci_register_driver(&wlan_pcie)) {
 		PRINTM(MFATAL, "PCIE Driver Registration Failed \n");
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-		pm_qos_remove_request(&woal_pcie_pm_qos_req);
-#endif
-#endif
 		ret = MLAN_STATUS_FAILURE;
 	}
 
@@ -1381,38 +1561,26 @@ void woal_pcie_bus_unregister(void)
 {
 	ENTER();
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
-	release_bus_freq(BUS_FREQ_HIGH);
-#endif
 	/* PCIE Driver Unregistration */
 	pci_unregister_driver(&wlan_pcie);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35)
-	pm_qos_remove_request(&woal_pcie_pm_qos_req);
-#endif
-#endif
 
 	LEAVE();
 }
 
-#if defined(PCIE9098) || defined(PCIE9097)
 #define PCIE9098_DUMP_CTRL_REG 0x1C94
 #define PCIE9098_DUMP_START_REG 0x1C98
 #define PCIE9098_DUMP_END_REG 0x1C9F
-#endif
 #if defined(PCIE8897) || defined(PCIE8997)
 #define DEBUG_DUMP_CTRL_REG 0xCF4
 #define DEBUG_DUMP_START_REG 0xCF8
 #define DEBUG_DUMP_END_REG 0xCFF
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 #define PCIE9098_SCRATCH_12_REG 0x1C90
 #define PCIE9098_SCRATCH_14_REG 0x1C98
 #define PCIE9098_SCRATCH_15_REG 0x1C9C
 #define PCIE9098_DUMP_REG_START 0x1C20
 #define PCIE9098_DUMP_REG_END 0x1C9C
-#endif
 
 #if defined(PCIE8997) || defined(PCIE8897)
 #define PCIE_SCRATCH_12_REG 0x0CF0;
@@ -1429,7 +1597,7 @@ void woal_pcie_bus_unregister(void)
  *
  *  @return         The length of this log
  */
-int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
+static int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 {
 	char *drv_ptr = (char *)buffer;
 	t_u32 reg = 0, value = 0;
@@ -1442,11 +1610,9 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 	t_u32 dump_end_reg = 0;
 	t_u32 scratch_14_reg = 0;
 	t_u32 scratch_15_reg = 0;
-#if defined(PCIE9098) || defined(PCIE9097)
 	/* Tx/Rx/Event AMDA start address */
 	t_u32 adma_reg_table[] = {0x10000, 0x10800, 0x10880, 0x11000, 0x11080};
 	t_u8 j;
-#endif
 	ENTER();
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MTRUE);
 	drv_ptr += sprintf(drv_ptr,
@@ -1470,8 +1636,9 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		reg = PCIE9098_SCRATCH_12_REG;
 		dump_start_reg = PCIE9098_DUMP_REG_START;
@@ -1479,7 +1646,6 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 		scratch_14_reg = PCIE9098_SCRATCH_14_REG;
 		scratch_15_reg = PCIE9098_SCRATCH_15_REG;
 	}
-#endif
 
 	woal_pcie_read_reg(phandle, reg, &value);
 	drv_ptr += sprintf(drv_ptr, "reg:0x%x value=0x%x\n", reg, value);
@@ -1513,8 +1679,9 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 		}
 		i++;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		drv_ptr += sprintf(
 			drv_ptr,
@@ -1535,6 +1702,8 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 		drv_ptr += sprintf(drv_ptr, "%s\n", buf);
 	}
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		drv_ptr += sprintf(drv_ptr,
 				   "ADMA Tx/Rx/Event/Cmd/CmdResp registers:\n");
@@ -1561,7 +1730,6 @@ int woal_pcie_dump_reg_info(moal_handle *phandle, t_u8 *buffer)
 			drv_ptr += sprintf(drv_ptr, "%s\n", buf);
 		}
 	}
-#endif
 	drv_ptr += sprintf(drv_ptr,
 			   "-----------PCIe Registers dump End-----------\n");
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
@@ -1588,11 +1756,9 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 	t_u32 dump_end_reg = 0;
 	t_u32 scratch_14_reg = 0;
 	t_u32 scratch_15_reg = 0;
-#if defined(PCIE9098) || defined(PCIE9097)
 	/* Tx/Rx/Event AMDA start address */
 	t_u32 adma_reg_table[] = {0x10000, 0x10800, 0x10880, 0x11000, 0x11080};
 	t_u8 j;
-#endif
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MTRUE);
 	PRINTM(MMSG, "Config Space Registers:\n");
 	for (i = 0; i < ARRAY_SIZE(config_reg_table); i++) {
@@ -1612,8 +1778,9 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		reg = PCIE9098_SCRATCH_12_REG;
 		dump_start_reg = PCIE9098_DUMP_START_REG;
@@ -1621,7 +1788,6 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 		scratch_14_reg = PCIE9098_SCRATCH_14_REG;
 		scratch_15_reg = PCIE9098_SCRATCH_15_REG;
 	}
-#endif
 	woal_pcie_read_reg(phandle, reg, &value);
 	PRINTM(MERROR, "reg:0x%x value=0x%x\n", reg, value);
 	for (i = 0; i < 2; i++) {
@@ -1650,8 +1816,9 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 		}
 		i++;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		PRINTM(MMSG, "PCIE registers from offset 0x1c20 to 0x1c9c:\n");
 		memset(buf, 0, sizeof(buf));
@@ -1670,6 +1837,8 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 		PRINTM(MMSG, "%s\n", buf);
 	}
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		PRINTM(MMSG, "ADMA Tx/Rx/Event/Cmd/CmdResp registers:\n");
 		for (j = 0; j < ARRAY_SIZE(adma_reg_table); j++) {
@@ -1693,7 +1862,6 @@ static void woal_pcie_reg_dbg(moal_handle *phandle)
 			PRINTM(MMSG, "%s\n", buf);
 		}
 	}
-#endif
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
 }
 
@@ -1712,8 +1880,6 @@ typedef enum {
 } dumped_mem_type;
 
 #define MAX_NAME_LEN 8
-#define MAX_FULL_NAME_LEN 32
-t_u8 *name_prefix = "/data/file_";
 
 typedef struct {
 	t_u8 mem_name[MAX_NAME_LEN];
@@ -1723,16 +1889,10 @@ typedef struct {
 	t_u8 type;
 } memory_type_mapping;
 
-typedef enum {
-	RDWR_STATUS_SUCCESS = 0,
-	RDWR_STATUS_FAILURE = 1,
-	RDWR_STATUS_DONE = 2
-} rdwr_status;
-
 #ifdef PCIE8897
 #define DEBUG_HOST_READY_8897 0xEE
 #define DEBUG_MEMDUMP_FINISH_8897 0xFE
-memory_type_mapping mem_type_mapping_tbl_8897[] = {
+static memory_type_mapping mem_type_mapping_tbl_8897[] = {
 	{"ITCM", NULL, NULL, 0xF0, FW_DUMP_TYPE_MEM_ITCM},
 	{"DTCM", NULL, NULL, 0xF1, FW_DUMP_TYPE_MEM_DTCM},
 	{"SQRAM", NULL, NULL, 0xF2, FW_DUMP_TYPE_MEM_SQRAM},
@@ -1744,17 +1904,12 @@ memory_type_mapping mem_type_mapping_tbl_8897[] = {
 };
 #endif
 
-#if defined(PCIE8997) || defined(PCIE9098) || defined(PCIE9097)
 #define DEBUG_HOST_READY_8997 0xCC
 #define DEBUG_HOST_EVENT_READY 0xAA
-#define DEBUG_MEMDUMP_FINISH_8997 0xDD
-memory_type_mapping mem_type_mapping_tbl_8997 = {"DUMP", NULL, NULL, 0xDD,
-						 0x00};
+#define DEBUG_HOST_RESET_READY 0x99
+static memory_type_mapping mem_type_mapping_tbl_8997 = {"DUMP", NULL, NULL,
+							0xDD, 0x00};
 
-#endif
-
-#if defined(PCIE8897) || defined(PCIE8997) || defined(PCIE9098) ||             \
-	defined(PCIE9097)
 /**
  *  @brief This function reads data by 8 bit from card register
  *
@@ -1764,7 +1919,8 @@ memory_type_mapping mem_type_mapping_tbl_8997 = {"DUMP", NULL, NULL, 0xDD,
  *
  *  @return    		MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_read_reg_eight_bit(moal_handle *handle, t_u32 reg, t_u8 *data)
+static mlan_status woal_read_reg_eight_bit(moal_handle *handle, t_u32 reg,
+					   t_u8 *data)
 {
 	pcie_service_card *card = (pcie_service_card *)handle->card;
 	*data = ioread8(card->pci_mmap1 + reg);
@@ -1776,10 +1932,12 @@ mlan_status woal_read_reg_eight_bit(moal_handle *handle, t_u32 reg, t_u8 *data)
  *
  *  @param phandle   A pointer to moal_handle
  *  @param doneflag  done flag
+ *  @param resetflag reset flag;
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
+static rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag,
+					   t_u8 resetflag)
 {
 	int ret = 0;
 	int tries = 0;
@@ -1801,32 +1959,44 @@ rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 	}
 #endif
 
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		if (phandle->event_fw_dump)
 			debug_host_ready = DEBUG_HOST_EVENT_READY;
 		else
 			debug_host_ready = DEBUG_HOST_READY_8997;
+		if (resetflag)
+			debug_host_ready = DEBUG_HOST_RESET_READY;
 		dump_ctrl_reg = PCIE9098_DUMP_CTRL_REG;
 	}
-#endif
 
 	ret = woal_pcie_write_reg(phandle, dump_ctrl_reg, debug_host_ready);
 	if (ret) {
-		PRINTM(MERROR, "PCIE Write ERR\n");
+		PRINTM(MERROR, "PCIE Write ERR, reg=0x%x debug_reay=0x%x\n",
+		       dump_ctrl_reg, debug_host_ready);
 		return RDWR_STATUS_FAILURE;
 	}
+	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
+	    IS_PCIE9097(phandle->card_type)) {
+		if (phandle->event_fw_dump || resetflag)
+			return RDWR_STATUS_SUCCESS;
+	}
 	ret = woal_pcie_read_reg(phandle, dump_ctrl_reg, &reg_data);
 	if (ret) {
-		PRINTM(MERROR, "PCIE Read DEBUG_DUMP_CTRL_REG fail\n");
+		PRINTM(MERROR, "PCIE Read DEBUG_DUMP_CTRL_REG 0x%x fail\n",
+		       dump_ctrl_reg);
 		return RDWR_STATUS_FAILURE;
 	}
 	for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
 		ret = woal_read_reg_eight_bit(phandle, dump_ctrl_reg,
 					      &ctrl_data);
 		if (ret) {
-			PRINTM(MERROR, "PCIE READ ERR\n");
+			PRINTM(MERROR, "PCIE READ reg 0x%x 8bit ERR\n",
+			       dump_ctrl_reg);
 			return RDWR_STATUS_FAILURE;
 		}
 		if (ctrl_data == DEBUG_FW_DONE)
@@ -1834,7 +2004,9 @@ rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 		if (doneflag && ctrl_data == doneflag)
 			return RDWR_STATUS_DONE;
 		if (ctrl_data != debug_host_ready) {
-			PRINTM(MMSG, "The ctrl reg was changed, try again!\n");
+			PRINTM(MMSG,
+			       "The ctrl reg was changed, ctrl_data=0x%x, host_ready:0x%x try again!\n",
+			       ctrl_data, debug_host_ready);
 			ret = woal_pcie_write_reg(phandle, dump_ctrl_reg,
 						  debug_host_ready);
 			if (ret) {
@@ -1849,12 +2021,12 @@ rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 #endif
 	}
 	if (ctrl_data == debug_host_ready) {
-		PRINTM(MERROR, "Fail to pull ctrl_data\n");
+		PRINTM(MERROR, "Fail to pull ctrl_data=0x%x host_ready=0x%x\n",
+		       ctrl_data, debug_host_ready);
 		return RDWR_STATUS_FAILURE;
 	}
 	return RDWR_STATUS_SUCCESS;
 }
-#endif
 
 #ifdef PCIE8897
 /**
@@ -1864,7 +2036,7 @@ rdwr_status woal_pcie_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
  *
  *  @return         N/A
  */
-void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
+static void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 {
 	int ret = 0;
 	unsigned int reg, reg_start, reg_end;
@@ -1876,8 +2048,8 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 	rdwr_status stat;
 	t_u8 i = 0;
 	t_u8 read_reg = 0;
-	t_u32 memory_size = 0, DEBUG_MEMDUMP_FINISH;
-	t_u8 path_name[64], file_name[32], firmware_dump_file[128];
+	t_u32 memory_size = 0;
+	t_u32 memdump_finsh = 0;
 	t_u8 *end_ptr = NULL;
 	memory_type_mapping *mem_type_mapping_tbl = mem_type_mapping_tbl_8897;
 
@@ -1885,22 +2057,24 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 		PRINTM(MERROR, "Could not dump firmwware info\n");
 		return;
 	}
-	DEBUG_MEMDUMP_FINISH = DEBUG_MEMDUMP_FINISH_8897;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-	/** Create dump directory*/
-	woal_create_dump_dir(phandle, path_name, sizeof(path_name));
-#else
-	memset(path_name, 0, sizeof(path_name));
-	strcpy(path_name, "/data");
-#endif
-	PRINTM(MMSG, "Directory name is %s\n", path_name);
-	woal_dump_drv_info(phandle, path_name);
+	if (!phandle->fw_dump_buf) {
+		ret = moal_vmalloc(phandle, FW_DUMP_INFO_LEN,
+				   &(phandle->fw_dump_buf));
+		if (ret != MLAN_STATUS_SUCCESS || !phandle->fw_dump_buf) {
+			PRINTM(MERROR, "Failed to vmalloc fw dump bufffer\n");
+			return;
+		}
+	} else {
+		memset(phandle->fw_dump_buf, 0x00, FW_DUMP_INFO_LEN);
+	}
+	phandle->fw_dump_len = 0;
 	/* start dump fw memory	*/
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "====PCIE DEBUG MODE OUTPUT START: %u.%06u ====\n", sec,
 	       usec);
 	/* read the number of the memories which will dump */
-	if (RDWR_STATUS_FAILURE == woal_pcie_rdwr_firmware(phandle, doneflag))
+	if (RDWR_STATUS_FAILURE ==
+	    woal_pcie_rdwr_firmware(phandle, doneflag, 0))
 		goto done;
 	reg = DEBUG_DUMP_START_REG;
 	ret = woal_read_reg_eight_bit(phandle, reg, &dump_num);
@@ -1914,7 +2088,7 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 	     idx < dump_num && idx < ARRAY_SIZE(mem_type_mapping_tbl_8897);
 	     idx++) {
 		if (RDWR_STATUS_FAILURE ==
-		    woal_pcie_rdwr_firmware(phandle, doneflag))
+		    woal_pcie_rdwr_firmware(phandle, doneflag, 0))
 			goto done;
 		memory_size = 0;
 		reg = DEBUG_DUMP_START_REG;
@@ -1930,7 +2104,7 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 		if (memory_size == 0) {
 			PRINTM(MMSG, "Firmware Dump Finished!\n");
 			ret = woal_pcie_write_reg(phandle, DEBUG_DUMP_CTRL_REG,
-						  DEBUG_MEMDUMP_FINISH);
+						  memdump_finsh);
 			if (ret) {
 				PRINTM(MERROR,
 				       "PCIE Write MEMDUMP_FINISH ERR\n");
@@ -1958,7 +2132,7 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 		PRINTM(MMSG, "Start %s output %u.%06u, please wait...\n",
 		       mem_type_mapping_tbl[idx].mem_name, sec, usec);
 		do {
-			stat = woal_pcie_rdwr_firmware(phandle, doneflag);
+			stat = woal_pcie_rdwr_firmware(phandle, doneflag, 0);
 			if (RDWR_STATUS_FAILURE == stat)
 				goto done;
 
@@ -1983,17 +2157,11 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 				       (unsigned int)(dbg_ptr -
 						      mem_type_mapping_tbl[idx]
 							      .mem_Ptr));
-				memset(file_name, 0, sizeof(file_name));
-				sprintf(file_name, "%s%s", "file_pcie_",
-					mem_type_mapping_tbl[idx].mem_name);
-				if (MLAN_STATUS_SUCCESS !=
-				    woal_save_dump_info_to_file(
-					    path_name, file_name,
-					    mem_type_mapping_tbl[idx].mem_Ptr,
-					    memory_size))
-					PRINTM(MMSG,
-					       "Can't save dump file %s in %s\n",
-					       file_name, path_name);
+				woal_save_dump_info_to_buf(
+					phandle,
+					mem_type_mapping_tbl[idx].mem_Ptr,
+					memory_size,
+					mem_type_mapping_tbl[idx].type);
 				moal_vfree(phandle,
 					   mem_type_mapping_tbl[idx].mem_Ptr);
 				mem_type_mapping_tbl[idx].mem_Ptr = NULL;
@@ -2001,15 +2169,11 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 			}
 		} while (1);
 	}
+	woal_append_end_block(phandle);
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "====PCIE DEBUG MODE OUTPUT END: %u.%06u ====\n", sec,
 	       usec);
 	/* end dump fw memory */
-	memset(firmware_dump_file, 0, sizeof(firmware_dump_file));
-	sprintf(firmware_dump_file, "%s/%s", path_name, file_name);
-	moal_memcpy_ext(phandle, phandle->firmware_dump_file,
-			firmware_dump_file, sizeof(firmware_dump_file),
-			sizeof(phandle->firmware_dump_file));
 done:
 	for (idx = 0;
 	     idx < dump_num && idx < ARRAY_SIZE(mem_type_mapping_tbl_8897);
@@ -2024,7 +2188,6 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
 }
 #endif
 
-#if defined(PCIE8997) || defined(PCIE9098) || defined(PCIE9097)
 /**
  *  @brief This function dump firmware memory to file
  *
@@ -2032,7 +2195,7 @@ void woal_pcie_dump_fw_info_v1(moal_handle *phandle)
  *
  *  @return         N/A
  */
-void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
+static void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 {
 	int ret = 0;
 	unsigned int reg, reg_start, reg_end;
@@ -2043,8 +2206,6 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 	t_u8 doneflag = 0;
 	rdwr_status stat;
 	t_u32 memory_size = 0;
-	t_u8 path_name[64], file_name[32], firmware_dump_file[128];
-	moal_handle *ref_handle;
 	t_u8 *end_ptr = NULL;
 	memory_type_mapping *mem_type_mapping_tbl = &mem_type_mapping_tbl_8997;
 	t_u32 dump_start_reg = 0;
@@ -2054,46 +2215,35 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 		PRINTM(MERROR, "Could not dump firmwware info\n");
 		return;
 	}
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		if (phandle->event_fw_dump) {
 			if (RDWR_STATUS_FAILURE !=
-			    woal_pcie_rdwr_firmware(phandle, doneflag))
+			    woal_pcie_rdwr_firmware(phandle, doneflag, 0)) {
 				PRINTM(MMSG,
 				       "====PCIE FW DUMP EVENT MODE START ====\n");
-			phandle->event_fw_dump = MFALSE;
-			return;
+				return;
+			}
 		}
 	}
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-	/** Create dump directory*/
-	woal_create_dump_dir(phandle, path_name, sizeof(path_name));
-#else
-	memset(path_name, 0, sizeof(path_name));
-	strcpy(path_name, "/data");
-#endif
-	PRINTM(MMSG, "Create DUMP directory success:dir_name=%s\n", path_name);
-	ref_handle = (moal_handle *)phandle->pref_mac;
-	if (ref_handle)
-		woal_dump_drv_info(ref_handle, path_name);
-	woal_dump_drv_info(phandle, path_name);
 
 	/* start dump fw memory	*/
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "====PCIE DEBUG MODE OUTPUT START: %u.%06u ====\n", sec,
 	       usec);
 	/* read the number of the memories which will dump */
-	if (RDWR_STATUS_FAILURE == woal_pcie_rdwr_firmware(phandle, doneflag))
+	if (RDWR_STATUS_FAILURE ==
+	    woal_pcie_rdwr_firmware(phandle, doneflag, 0))
 		goto done;
-#if defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIEAW693(phandle->card_type) ||
 	    IS_PCIE9097(phandle->card_type)) {
 		dump_start_reg = PCIE9098_DUMP_START_REG;
 		dump_end_reg = PCIE9098_DUMP_END_REG;
 	}
-#endif
 #ifdef PCIE8997
 	if (IS_PCIE8997(phandle->card_type)) {
 		dump_start_reg = DEBUG_DUMP_START_REG;
@@ -2123,7 +2273,7 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 	PRINTM(MMSG, "Start %s output %u.%06u, please wait...\n",
 	       mem_type_mapping_tbl->mem_name, sec, usec);
 	do {
-		stat = woal_pcie_rdwr_firmware(phandle, doneflag);
+		stat = woal_pcie_rdwr_firmware(phandle, doneflag, 0);
 		if (RDWR_STATUS_FAILURE == stat)
 			goto done;
 
@@ -2163,26 +2313,27 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 			}
 		}
 		if (RDWR_STATUS_DONE == stat) {
+#ifdef MLAN_64BIT
 			PRINTM(MMSG,
 			       "%s done:"
-#ifdef MLAN_64BIT
 			       "size = 0x%lx\n",
+			       mem_type_mapping_tbl->mem_name,
+			       dbg_ptr - mem_type_mapping_tbl->mem_Ptr);
 #else
+			PRINTM(MMSG,
+			       "%s done:"
 			       "size = 0x%x\n",
-#endif
 			       mem_type_mapping_tbl->mem_name,
 			       dbg_ptr - mem_type_mapping_tbl->mem_Ptr);
-			memset(file_name, 0, sizeof(file_name));
-			sprintf(file_name, "%s%s", "file_pcie_",
-				mem_type_mapping_tbl->mem_name);
-			if (MLAN_STATUS_SUCCESS !=
-			    woal_save_dump_info_to_file(
-				    path_name, file_name,
-				    mem_type_mapping_tbl->mem_Ptr,
-				    dbg_ptr - mem_type_mapping_tbl->mem_Ptr))
-				PRINTM(MMSG, "Can't save dump file %s in %s\n",
-				       file_name, path_name);
-			moal_vfree(phandle, mem_type_mapping_tbl->mem_Ptr);
+#endif
+			if (phandle->fw_dump_buf) {
+				moal_vfree(phandle, phandle->fw_dump_buf);
+				phandle->fw_dump_buf = NULL;
+				phandle->fw_dump_len = 0;
+			}
+			phandle->fw_dump_buf = mem_type_mapping_tbl->mem_Ptr;
+			phandle->fw_dump_len =
+				dbg_ptr - mem_type_mapping_tbl->mem_Ptr;
 			mem_type_mapping_tbl->mem_Ptr = NULL;
 			break;
 		}
@@ -2191,11 +2342,6 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 	PRINTM(MMSG, "====PCIE DEBUG MODE OUTPUT END: %u.%06u ====\n", sec,
 	       usec);
 	/* end dump fw memory */
-	memset(firmware_dump_file, 0, sizeof(firmware_dump_file));
-	sprintf(firmware_dump_file, "%s/%s", path_name, file_name);
-	moal_memcpy_ext(phandle, phandle->firmware_dump_file,
-			firmware_dump_file, sizeof(firmware_dump_file),
-			sizeof(phandle->firmware_dump_file));
 done:
 	if (mem_type_mapping_tbl->mem_Ptr) {
 		moal_vfree(phandle, mem_type_mapping_tbl->mem_Ptr);
@@ -2204,7 +2350,6 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
 
 	return;
 }
-#endif
 
 /**
  *  @brief This function check if this is second mac
@@ -2215,50 +2360,65 @@ void woal_pcie_dump_fw_info_v2(moal_handle *phandle)
  */
 static t_u8 woal_pcie_is_second_mac(moal_handle *handle)
 {
-#ifdef PCIE9098
 	pcie_service_card *card = (pcie_service_card *)handle->card;
-	if (card->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN1)
+	if ((card->dev->device == PCIE_DEVICE_ID_88W9098P_FN1) ||
+	    (card->dev->device == PCIE_DEVICE_ID_88WAW693_FN1))
 		return MTRUE;
-#endif
 	return MFALSE;
 }
 
-void woal_pcie_dump_fw_info(moal_handle *phandle)
+static void woal_pcie_dump_fw_info(moal_handle *phandle)
 {
+	if (phandle->fw_dump_buf) {
+		PRINTM(MERROR, "FW dump already exist\n");
+		return;
+	}
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MTRUE);
 	phandle->fw_dump = MTRUE;
 #ifdef PCIE8897
 	if (IS_PCIE8897(phandle->card_type))
 		woal_pcie_dump_fw_info_v1(phandle);
 #endif
-#if defined(PCIE8997) || defined(PCIE9098) || defined(PCIE9097)
 	if (IS_PCIE8997(phandle->card_type) ||
-	    IS_PCIE9098(phandle->card_type) || IS_PCIE9097(phandle->card_type))
+	    IS_PCIEAW693(phandle->card_type) ||
+	    IS_PCIEIW62X(phandle->card_type) ||
+	    IS_PCIE9098(phandle->card_type) ||
+	    IS_PCIE9097(phandle->card_type)) {
 		woal_pcie_dump_fw_info_v2(phandle);
-#endif
+		if (phandle->event_fw_dump) {
+			phandle->event_fw_dump = MFALSE;
+			queue_work(phandle->workqueue, &phandle->main_work);
+			phandle->is_fw_dump_timer_set = MTRUE;
+			woal_mod_timer(&phandle->fw_dump_timer, MOAL_TIMER_5S);
+			return;
+		}
+	}
 	phandle->fw_dump = MFALSE;
+	if (!phandle->priv_num)
+		return;
+	woal_send_fw_dump_complete_event(
+		woal_get_priv(phandle, MLAN_BSS_ROLE_ANY));
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
 	queue_work(phandle->workqueue, &phandle->main_work);
+	woal_process_hang(phandle);
 }
 
 static mlan_status woal_pcie_get_fw_name(moal_handle *handle)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-#ifdef PCIE9098
 	pcie_service_card *card = (pcie_service_card *)handle->card;
 	moal_handle *ref_handle = NULL;
-#endif
 
-#if defined(PCIE8997) || defined(PCIE9098) || defined(PCIE9097)
 	t_u32 rev_id_reg = handle->card_info->rev_id_reg;
 	t_u32 revision_id = 0;
-#endif
 
-#if defined(PCIE8997) || defined(PCIE9098) || defined(PCIE9097)
 	t_u32 host_strap_reg = handle->card_info->host_strap_reg;
 	t_u32 magic_reg = handle->card_info->magic_reg;
 	t_u32 strap = 0;
 	t_u32 magic = 0;
+#ifdef PCIEIW62X
+	t_u32 boot_mode_reg = handle->card_info->boot_mode_reg;
+	t_u32 boot_mode;
 #endif
 
 	ENTER();
@@ -2307,7 +2467,7 @@ static mlan_status woal_pcie_get_fw_name(moal_handle *handle)
 #endif
 #ifdef PCIE9098
 	if (IS_PCIE9098(handle->card_type)) {
-		if (card->dev->device == PCIE_DEVICE_ID_NXP_88W9098P_FN0) {
+		if (card->dev->device == PCIE_DEVICE_ID_88W9098P_FN0) {
 			woal_pcie_read_reg(handle, rev_id_reg, &revision_id);
 			woal_pcie_read_reg(handle, host_strap_reg, &strap);
 			woal_pcie_read_reg(handle, magic_reg, &magic);
@@ -2411,6 +2571,58 @@ static mlan_status woal_pcie_get_fw_name(moal_handle *handle)
 			break;
 		}
 	}
+#endif
+	if (IS_PCIEAW693(handle->card_type)) {
+		if (card->dev->device == PCIE_DEVICE_ID_88WAW693_FN0) {
+			woal_pcie_read_reg(handle, rev_id_reg, &revision_id);
+			woal_pcie_read_reg(handle, host_strap_reg, &strap);
+			woal_pcie_read_reg(handle, magic_reg, &magic);
+			revision_id &= 0xff;
+			strap &= 0x7;
+			magic &= 0xff;
+			PRINTM(MCMND,
+			       "magic=0x%x, strap=0x%x, revision_id=0x%x\n",
+			       magic, strap, revision_id);
+			if (magic == CHIP_MAGIC_VALUE) {
+				if (strap == CARD_TYPE_PCIE_UART)
+					strcpy(handle->card_info->fw_name,
+					       PCIEUARTAW693_DEFAULT_COMBO_FW_NAME);
+				else
+					strcpy(handle->card_info->fw_name,
+					       PCIEAW693_DEFAULT_COMBO_FW_NAME);
+			}
+		} else {
+			ref_handle = (moal_handle *)handle->pref_mac;
+			if (ref_handle) {
+				strcpy(handle->card_info->fw_name,
+				       ref_handle->card_info->fw_name);
+				strcpy(handle->card_info->fw_name_wlan,
+				       ref_handle->card_info->fw_name_wlan);
+			}
+		}
+	}
+#ifdef PCIEIW62X
+	if (IS_PCIEIW62X(handle->card_type)) {
+		woal_pcie_read_reg(handle, rev_id_reg, &revision_id);
+		woal_pcie_read_reg(handle, host_strap_reg, &strap);
+		woal_pcie_read_reg(handle, magic_reg, &magic);
+		woal_pcie_read_reg(handle, boot_mode_reg, &boot_mode);
+		revision_id &= 0xff;
+		strap &= 0x7;
+		magic &= 0xff;
+		boot_mode &= 0x03;
+		PRINTM(MCMND,
+		       "magic=0x%x boot_mode=0x%x, strap=0x%x, revision_id=0x%x\n",
+		       magic, boot_mode, strap, revision_id);
+		if (boot_mode == 0x03)
+			PRINTM(MMSG, "wlan: PCIE-IW62X in secure-boot mode\n");
+		if (strap == CARD_TYPE_PCIE_UART)
+			strcpy(handle->card_info->fw_name,
+			       PCIEUARTIW62X_DEFAULT_COMBO_FW_NAME);
+		else
+			strcpy(handle->card_info->fw_name,
+			       PCIEUSBIW62X_DEFAULT_COMBO_FW_NAME);
+	}
 #endif
 done:
 	PRINTM(MCMND, "combo fw:%s wlan fw:%s \n", handle->card_info->fw_name,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.h
old mode 100644
new mode 100755
index ae22f4d01..006fc5d1f
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_pcie.h
@@ -4,7 +4,7 @@
  *  driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2014-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -29,29 +29,39 @@ Change log:
 #ifndef _MOAL_PCIE_H_
 #define _MOAL_PCIE_H_
 
-#define PCIE_VENDOR_ID_NXP (0x11ab)
-#define PCIE_VENDOR_ID_V2_NXP (0x1b4b)
+#define PCIE_VENDOR_ID_MRVL (0x11ab)
+#define PCIE_VENDOR_ID_V2_MRVL (0x1b4b)
+#define PCIE_VENDOR_ID_NXP (0x1131)
+
 #ifdef PCIE8997
 /** PCIE device ID for 8997 card */
-#define PCIE_DEVICE_ID_NXP_88W8997P (0x2b42)
+#define PCIE_DEVICE_ID_88W8997P (0x2b42)
 #endif
 #ifdef PCIE8897
 /** PCIE device ID for 8897 card */
-#define PCIE_DEVICE_ID_NXP_88W8897P (0x2b38)
+#define PCIE_DEVICE_ID_88W8897P (0x2b38)
 #endif
 
 #ifdef PCIE9097
 /** PCIE device ID for 9097 card */
-#define PCIE_DEVICE_ID_NXP_88W9097 (0x2b56)
+#define PCIE_DEVICE_ID_88W9097 (0x2b56)
 #endif
 
-#ifdef PCIE9098
 /** PCIE device ID for 9098 card FN0 */
-#define PCIE_DEVICE_ID_NXP_88W9098P_FN0 (0x2b43)
+#define PCIE_DEVICE_ID_88W9098P_FN0 (0x2b43)
 /** PCIE device ID for 9098 card FN1 */
-#define PCIE_DEVICE_ID_NXP_88W9098P_FN1 (0x2b44)
+#define PCIE_DEVICE_ID_88W9098P_FN1 (0x2b44)
+
+#ifdef PCIEIW62X
+/** PCIE device ID for IW62X card FN0 */
+#define PCIE_DEVICE_ID_88WIW62X (0x3000)
 #endif
 
+/** PCIE device ID for AW693 card FN0 */
+#define PCIE_DEVICE_ID_88WAW693_FN0 (0x3003)
+/** PCIE device ID for AW693 card FN1 */
+#define PCIE_DEVICE_ID_88WAW693_FN1 (0x3004)
+
 #include <linux/version.h>
 #include <linux/pci.h>
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 17, 0)
@@ -77,6 +87,10 @@ Change log:
 #define PCIE8897_DEFAULT_WLAN_FW_NAME "nxp/pcie8897_wlan.bin"
 #endif /* PCIE8897*/
 
+#define PCIEUARTAW693_DEFAULT_COMBO_FW_NAME "nxp/pcieuartAW693_combo.bin"
+#define PCIEAW693_DEFAULT_COMBO_FW_NAME "nxp/pcieAW693_wlan.bin"
+#define PCIEAW693_DEFAULT_WLAN_FW_NAME "nxp/pcieAW693_wlan.bin"
+
 #ifdef PCIE9098
 #define PCIE9098_Z1Z2 0x00
 #define PCIE9098_A0 0x01
@@ -97,20 +111,23 @@ Change log:
 #define PCIE9097_A0 0x00
 #define PCIE9097_B0 0x01
 #define PCIE9097_B1 0x02
-#define PCIE9097_DEFAULT_COMBO_FW_NAME "nxp/pcieusb9097_combo.bin"
-#define PCIEUART9097_DEFAULT_COMBO_FW_NAME "nxp/pcieuart9097_combo.bin"
-#define PCIEUSB9097_DEFAULT_COMBO_FW_NAME "nxp/pcieusb9097_combo.bin"
-#define PCIEUART9097_COMBO_V1_FW_NAME "nxp/pcieuart9097_combo_v1.bin"
-#define PCIEUSB9097_COMBO_V1_FW_NAME "nxp/pcieusb9097_combo_v1.bin"
-#define PCIE9097_DEFAULT_WLAN_FW_NAME "nxp/pcie9097_wlan.bin"
-#define PCIE9097_WLAN_V1_FW_NAME "nxp/pcie9097_wlan_v1.bin"
+#define PCIE9097_DEFAULT_COMBO_FW_NAME "nxp/pcieusbiw620_combo.bin"
+#define PCIEUART9097_DEFAULT_COMBO_FW_NAME "nxp/pcieuartiw620_combo.bin"
+#define PCIEUSB9097_DEFAULT_COMBO_FW_NAME "nxp/pcieusbiw620_combo.bin"
+#define PCIEUART9097_COMBO_V1_FW_NAME "nxp/pcieuartiw620_combo_v1.bin"
+#define PCIEUSB9097_COMBO_V1_FW_NAME "nxp/pcieusbiw620_combo_v1.bin"
+#define PCIE9097_DEFAULT_WLAN_FW_NAME "nxp/pcieiw620_wlan.bin"
+#define PCIE9097_WLAN_V1_FW_NAME "nxp/pcieiw620_wlan_v1.bin"
 #endif /* PCIE9097 */
 
-#if defined(PCIE9098) || defined(PCIE9097)
+#ifdef PCIEIW62X
+#define PCIEIW62X_DEFAULT_COMBO_FW_NAME "nxp/pcieusbiw62x_combo.bin"
+#define PCIEUARTIW62X_DEFAULT_COMBO_FW_NAME "nxp/pcieuartiw62x_combo.bin"
+#define PCIEUSBIW62X_DEFAULT_COMBO_FW_NAME "nxp/pcieusbiw62x_combo.bin"
+#define PCIEIW62X_DEFAULT_WLAN_FW_NAME "nxp/pcieiw62x_wlan.bin"
+#endif /* PCIEIW62X */
+
 #define PCIE_NUM_MSIX_VECTORS 32
-#else
-#define PCIE_NUM_MSIX_VECTORS 4
-#endif
 
 typedef struct _msix_context {
 	/** pci_dev structure pointer */
@@ -139,4 +156,5 @@ typedef struct _pcie_service_card {
 mlan_status woal_pcie_bus_register(void);
 /** Unregister from bus driver function */
 void woal_pcie_bus_unregister(void);
+
 #endif /* _MOAL_PCIE_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.c
old mode 100644
new mode 100755
index 8397ab666..ce182abbb
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.c
@@ -3,7 +3,7 @@
  * @brief This file contains standard ioctl functions
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -515,7 +515,7 @@ static int woal_deep_sleep_ioctl(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_11n_htcap_cfg(moal_private *priv, struct iwreq *wrq)
 {
-	int data[2], copy_len;
+	int data[2] = {0}, copy_len;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
 	int ret = 0;
@@ -586,7 +586,7 @@ static int woal_11n_htcap_cfg(moal_private *priv, struct iwreq *wrq)
 			ret = -EFAULT;
 			goto done;
 		}
-		if (cfg_11n->param.htcap_cfg.htcap != data[0]) {
+		if ((int)cfg_11n->param.htcap_cfg.htcap != data[0]) {
 			data_length = 2;
 			data[1] = cfg_11n->param.htcap_cfg.htcap;
 			PRINTM(MINFO, "GET: htcapinfo for 2.4GHz:0x%x\n",
@@ -691,7 +691,7 @@ static int woal_11n_amsdu_aggr_ctrl(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_11n_tx_cfg(moal_private *priv, struct iwreq *wrq)
 {
-	int data[2], copy_len;
+	int data[2] = {0}, copy_len;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
 	int ret = 0;
@@ -794,7 +794,7 @@ static int woal_11n_tx_cfg(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_11n_prio_tbl(moal_private *priv, struct iwreq *wrq)
 {
-	int data[MAX_NUM_TID * 2], i, j, copy_len;
+	int data[MAX_NUM_TID * 2] = {0}, i, j, copy_len;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
 	int ret = 0;
@@ -803,7 +803,7 @@ static int woal_11n_prio_tbl(moal_private *priv, struct iwreq *wrq)
 
 	ENTER();
 
-	if ((wrq->u.data.pointer == NULL)) {
+	if (wrq->u.data.pointer == NULL) {
 		LEAVE();
 		return -EINVAL;
 	}
@@ -886,7 +886,7 @@ static int woal_11n_prio_tbl(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_addba_reject(moal_private *priv, struct iwreq *wrq)
 {
-	int data[MAX_NUM_TID], ret = 0, i, copy_len;
+	int data[MAX_NUM_TID] = {0}, ret = 0, i, copy_len;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
 	int data_length = wrq->u.data.length;
@@ -968,7 +968,7 @@ static int woal_addba_reject(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_addba_para_updt(moal_private *priv, struct iwreq *wrq)
 {
-	int data[5], ret = 0, copy_len;
+	int data[5] = {0}, ret = 0, copy_len;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
 	int data_length = wrq->u.data.length;
@@ -1157,10 +1157,12 @@ static int woal_hs_cfg(moal_private *priv, struct iwreq *wrq,
 	}
 
 	/* HS config is blocked if HS is already activated */
-	if (data_length &&
-	    (data[0] != HOST_SLEEP_CFG_CANCEL || invoke_hostcmd == MFALSE)) {
+	if (data_length && (data[0] != (int)HOST_SLEEP_CFG_CANCEL ||
+			    invoke_hostcmd == MFALSE)) {
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info))
+			PRINTM(MINFO, "Fail to get bss_info\n");
 		if (bss_info.is_hs_configured) {
 			PRINTM(MERROR, "HS already configured\n");
 			ret = -EFAULT;
@@ -1170,8 +1172,11 @@ static int woal_hs_cfg(moal_private *priv, struct iwreq *wrq,
 
 	/* Do a GET first if some arguments are not provided */
 	if (data_length >= 1 && data_length < 3) {
-		woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
-				       &hscfg);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
+					   &hscfg)) {
+			PRINTM(MERROR, "Unable to get HS params\n");
+		}
 	}
 
 	if (data_length)
@@ -1792,6 +1797,144 @@ static int woal_mem_read_write(moal_private *priv, struct iwreq *wrq)
 	return ret;
 }
 
+/**
+ *  @brief Set/Get network monitor configurations
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param wrq          A pointer to iwreq structure
+ *
+ *  @return             0 --success, otherwise fail
+ */
+static int woal_net_monitor_ioctl(moal_private *priv, struct iwreq *wrq)
+{
+	int user_data_len = wrq->u.data.length;
+	int data[5] = {0}, copy_len;
+	int ret = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_net_monitor *net_mon = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	copy_len = MIN(sizeof(data), sizeof(int) * user_data_len);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	net_mon = (mlan_ds_misc_net_monitor *)&misc->param.net_mon;
+	misc->sub_command = MLAN_OID_MISC_NET_MONITOR;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+
+	if (!user_data_len) {
+		req->action = MLAN_ACT_GET;
+	} else if (user_data_len == 1 || user_data_len == 4 ||
+		   user_data_len == 5) {
+		if (copy_from_user(data, wrq->u.data.pointer, copy_len)) {
+			PRINTM(MERROR, "Copy from user failed\n");
+			ret = -EFAULT;
+			goto done;
+		}
+		if (data[0] != MTRUE && data[0] != MFALSE) {
+			PRINTM(MERROR,
+			       "NET_MON: Activity should be enable(=1)/disable(=0)\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		net_mon->enable_net_mon = data[0];
+		if (data[0] == MTRUE) {
+			int i;
+			if (user_data_len != 4 && user_data_len != 5) {
+				PRINTM(MERROR,
+				       "NET_MON: Invalid number of args!\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			/* Supported filter flags */
+			if (!data[1] || data[1] & ~(MLAN_NETMON_DATA |
+						    MLAN_NETMON_MANAGEMENT |
+						    MLAN_NETMON_CONTROL)) {
+				PRINTM(MERROR,
+				       "NET_MON: Invalid filter flag\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			/* Supported bands */
+			for (i = 0; i < (int)sizeof(SupportedInfraBand); i++)
+				if (data[2] == SupportedInfraBand[i])
+					break;
+			if (i == sizeof(SupportedInfraBand)) {
+				PRINTM(MERROR, "NET_MON: Invalid band\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			/* Supported channel */
+			if (data[3] < 1 || data[3] > MLAN_MAX_CHANNEL) {
+				PRINTM(MERROR,
+				       "NET_MON: Invalid channel number\n");
+				ret = -EINVAL;
+				goto done;
+			}
+			if (user_data_len == 5) {
+				/* Secondary channel offset */
+				if (!(data[2] & (BAND_GN | BAND_AN))) {
+					PRINTM(MERROR,
+					       "No 11n in band, can not set "
+					       "secondary channel offset\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				if ((data[4] != CHANNEL_BW_20MHZ) &&
+				    (data[4] != CHANNEL_BW_40MHZ_ABOVE) &&
+				    (data[4] != CHANNEL_BW_40MHZ_BELOW) &&
+				    (data[4] != CHANNEL_BW_80MHZ)) {
+					PRINTM(MERROR,
+					       "Invalid secondary channel bandwidth, "
+					       "only allowed 0, 1, 3 or 4\n");
+					ret = -EINVAL;
+					goto done;
+				}
+				net_mon->chan_bandwidth = data[4];
+			}
+			net_mon->filter_flag = data[1];
+			net_mon->band = data[2];
+			net_mon->channel = data[3];
+		}
+		req->action = MLAN_ACT_SET;
+	} else {
+		PRINTM(MERROR, "NET_MON: Invalid number of args!\n");
+		ret = -EINVAL;
+		goto done;
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+
+	data[0] = net_mon->enable_net_mon;
+	data[1] = net_mon->filter_flag;
+	data[2] = net_mon->band;
+	data[3] = net_mon->channel;
+	data[4] = net_mon->chan_bandwidth;
+	wrq->u.data.length = 5;
+	if (copy_to_user(wrq->u.data.pointer, data,
+			 sizeof(int) * wrq->u.data.length)) {
+		PRINTM(MERROR, "Copy to user failed\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Get LOG
  *
@@ -1825,130 +1968,144 @@ static int woal_get_log(moal_private *priv, struct iwreq *wrq)
 	}
 
 	if (wrq->u.data.pointer) {
-		sprintf(buf,
-			"\n"
-			"mcasttxframe     %u\n"
-			"failed           %u\n"
-			"retry            %u\n"
-			"multiretry       %u\n"
-			"framedup         %u\n"
-			"rtssuccess       %u\n"
-			"rtsfailure       %u\n"
-			"ackfailure       %u\n"
-			"rxfrag           %u\n"
-			"mcastrxframe     %u\n"
-			"fcserror         %u\n"
-			"txframe          %u\n"
-			"wepicverrcnt-1   %u\n"
-			"wepicverrcnt-2   %u\n"
-			"wepicverrcnt-3   %u\n"
-			"wepicverrcnt-4   %u\n"
-			"beacon_rcnt      %u\n"
-			"beacon_mcnt      %u\n",
-			stats.mcast_tx_frame, stats.failed, stats.retry,
-			stats.multi_retry, stats.frame_dup, stats.rts_success,
-			stats.rts_failure, stats.ack_failure, stats.rx_frag,
-			stats.mcast_rx_frame, stats.fcs_error, stats.tx_frame,
-			stats.wep_icv_error[0], stats.wep_icv_error[1],
-			stats.wep_icv_error[2], stats.wep_icv_error[3],
-			stats.bcn_rcv_cnt, stats.bcn_miss_cnt);
+		snprintf(buf, GETLOG_BUFSIZE,
+			 "\n"
+			 "mcasttxframe     %u\n"
+			 "failed           %u\n"
+			 "retry            %u\n"
+			 "multiretry       %u\n"
+			 "framedup         %u\n"
+			 "rtssuccess       %u\n"
+			 "rtsfailure       %u\n"
+			 "ackfailure       %u\n"
+			 "rxfrag           %u\n"
+			 "mcastrxframe     %u\n"
+			 "fcserror         %u\n"
+			 "txframe          %u\n"
+			 "wepicverrcnt-1   %u\n"
+			 "wepicverrcnt-2   %u\n"
+			 "wepicverrcnt-3   %u\n"
+			 "wepicverrcnt-4   %u\n"
+			 "beacon_rcnt      %u\n"
+			 "beacon_mcnt      %u\n",
+			 stats.mcast_tx_frame, stats.failed, stats.retry,
+			 stats.multi_retry, stats.frame_dup, stats.rts_success,
+			 stats.rts_failure, stats.ack_failure, stats.rx_frag,
+			 stats.mcast_rx_frame, stats.fcs_error, stats.tx_frame,
+			 stats.wep_icv_error[0], stats.wep_icv_error[1],
+			 stats.wep_icv_error[2], stats.wep_icv_error[3],
+			 stats.bcn_rcv_cnt, stats.bcn_miss_cnt);
 		if (priv->phandle->fw_getlog_enable) {
-			sprintf(buf + strlen(buf), "tx_frag_cnt       %u\n",
-				stats.tx_frag_cnt);
-			sprintf(buf + strlen(buf), "qos_tx_frag_cnt        ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "tx_frag_cnt       %u\n", stats.tx_frag_cnt);
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "qos_tx_frag_cnt        ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_tx_frag_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_tx_frag_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_failed_cnt         ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_failed_cnt         ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_failed_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_failed_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_retry_cnt          ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_retry_cnt          ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_retry_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_retry_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_multi_retry_cnt    ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_multi_retry_cnt    ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_multi_retry_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_multi_retry_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_frm_dup_cnt        ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_frm_dup_cnt        ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_frm_dup_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_frm_dup_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_rts_suc_cnt        ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_rts_suc_cnt        ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_rts_suc_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_rts_suc_cnt[i]);
 			}
-			sprintf(buf + strlen(buf),
-				"\nqos_rts_failure_cnt        ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_rts_failure_cnt        ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_rts_failure_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_rts_failure_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_ack_failure_cnt    ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_ack_failure_cnt    ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_ack_failure_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_ack_failure_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_rx_frag_cnt        ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_rx_frag_cnt        ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_rx_frag_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_rx_frag_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_tx_frm_cnt         ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_tx_frm_cnt         ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_tx_frm_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_tx_frm_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_discarded_frm_cnt  ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_discarded_frm_cnt  ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_discarded_frm_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_discarded_frm_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_mpdus_rx_cnt       ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_mpdus_rx_cnt       ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_mpdus_rx_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_mpdus_rx_cnt[i]);
 			}
-			sprintf(buf + strlen(buf), "\nqos_retries_rx_cnt     ");
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nqos_retries_rx_cnt     ");
 			for (i = 0; i < 8; i++) {
-				sprintf(buf + strlen(buf), "%u ",
-					stats.qos_retries_rx_cnt[i]);
+				snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+					 "%u ", stats.qos_retries_rx_cnt[i]);
 			}
-			sprintf(buf + strlen(buf),
-				"\nmgmt_ccmp_replays      %u\n"
-				"tx_amsdu_cnt           %u\n"
-				"failed_amsdu_cnt       %u\n"
-				"retry_amsdu_cnt        %u\n"
-				"multi_retry_amsdu_cnt  %u\n"
-				"tx_octets_in_amsdu_cnt %llu\n"
-				"amsdu_ack_failure_cnt  %u\n"
-				"rx_amsdu_cnt           %u\n"
-				"rx_octets_in_amsdu_cnt %llu\n"
-				"tx_ampdu_cnt           %u\n"
-				"tx_mpdus_in_ampdu_cnt  %u\n"
-				"tx_octets_in_ampdu_cnt %llu\n"
-				"ampdu_rx_cnt           %u\n"
-				"mpdu_in_rx_ampdu_cnt   %u\n"
-				"rx_octets_in_ampdu_cnt %llu\n"
-				"ampdu_delimiter_crc_error_cnt      %u\n",
-				stats.mgmt_ccmp_replays, stats.tx_amsdu_cnt,
-				stats.failed_amsdu_cnt, stats.retry_amsdu_cnt,
-				stats.multi_retry_amsdu_cnt,
-				stats.tx_octets_in_amsdu_cnt,
-				stats.amsdu_ack_failure_cnt, stats.rx_amsdu_cnt,
-				stats.rx_octets_in_amsdu_cnt,
-				stats.tx_ampdu_cnt, stats.tx_mpdus_in_ampdu_cnt,
-				stats.tx_octets_in_ampdu_cnt,
-				stats.ampdu_rx_cnt, stats.mpdu_in_rx_ampdu_cnt,
-				stats.rx_octets_in_ampdu_cnt,
-				stats.ampdu_delimiter_crc_error_cnt);
+			snprintf(buf + strlen(buf), GETLOG_BUFSIZE,
+				 "\nmgmt_ccmp_replays      %u\n"
+				 "tx_amsdu_cnt           %u\n"
+				 "failed_amsdu_cnt       %u\n"
+				 "retry_amsdu_cnt        %u\n"
+				 "multi_retry_amsdu_cnt  %u\n"
+				 "tx_octets_in_amsdu_cnt %llu\n"
+				 "amsdu_ack_failure_cnt  %u\n"
+				 "rx_amsdu_cnt           %u\n"
+				 "rx_octets_in_amsdu_cnt %llu\n"
+				 "tx_ampdu_cnt           %u\n"
+				 "tx_mpdus_in_ampdu_cnt  %u\n"
+				 "tx_octets_in_ampdu_cnt %llu\n"
+				 "ampdu_rx_cnt           %u\n"
+				 "mpdu_in_rx_ampdu_cnt   %u\n"
+				 "rx_octets_in_ampdu_cnt %llu\n"
+				 "ampdu_delimiter_crc_error_cnt      %u\n",
+				 stats.mgmt_ccmp_replays, stats.tx_amsdu_cnt,
+				 stats.failed_amsdu_cnt, stats.retry_amsdu_cnt,
+				 stats.multi_retry_amsdu_cnt,
+				 stats.tx_octets_in_amsdu_cnt,
+				 stats.amsdu_ack_failure_cnt,
+				 stats.rx_amsdu_cnt,
+				 stats.rx_octets_in_amsdu_cnt,
+				 stats.tx_ampdu_cnt,
+				 stats.tx_mpdus_in_ampdu_cnt,
+				 stats.tx_octets_in_ampdu_cnt,
+				 stats.ampdu_rx_cnt, stats.mpdu_in_rx_ampdu_cnt,
+				 stats.rx_octets_in_ampdu_cnt,
+				 stats.ampdu_delimiter_crc_error_cnt);
 		}
 		wrq->u.data.length = MIN(GETLOG_BUFSIZE - 1, strlen(buf) + 1);
 		if (copy_to_user(wrq->u.data.pointer, buf,
@@ -2026,8 +2183,9 @@ static int woal_tx_power_cfg(moal_private *priv, struct iwreq *wrq)
 	ENTER();
 
 	memset(&bss_info, 0, sizeof(bss_info));
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
-
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info))
+		PRINTM(MINFO, "Fail to get bss_info\n");
 	memset(data, 0, sizeof(data));
 	user_data_len = wrq->u.data.length;
 	copy_len = MIN(sizeof(data), sizeof(int) * user_data_len);
@@ -2171,7 +2329,7 @@ static int woal_tx_power_cfg(moal_private *priv, struct iwreq *wrq)
 		i = 0;
 		power_ext_len = 0;
 		ptr = power_data;
-		while ((i < pcfg->param.power_ext.num_pwr_grp) &&
+		while ((i < (int)pcfg->param.power_ext.num_pwr_grp) &&
 		       ((power_ext_len + 5) < MAX_POWER_TABLE_SIZE)) {
 			pwr_grp = &pcfg->param.power_ext.power_group[i];
 			if (pwr_grp->rate_format == MLAN_RATE_FORMAT_HT) {
@@ -2548,7 +2706,9 @@ static int woal_set_get_radio(moal_private *priv, struct iwreq *wrq)
 			ret = -EFAULT;
 	} else {
 		/* Get radio status */
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info))
+			PRINTM(MINFO, "Fail to get bss_info\n");
 		wrq->u.data.length = 1;
 		if (copy_to_user(wrq->u.data.pointer, &bss_info.radio_on,
 				 sizeof(bss_info.radio_on))) {
@@ -3565,7 +3725,7 @@ static int woal_passphrase(moal_private *priv, struct iwreq *wrq)
 		ret = -EOPNOTSUPP;
 		goto done;
 	}
-	if (!data_length || data_length >= sizeof(buf) - 1) {
+	if (!data_length || data_length >= (int)sizeof(buf) - 1) {
 		PRINTM(MERROR,
 		       "Argument missing or too long for setpassphrase\n");
 		ret = -EINVAL;
@@ -3687,33 +3847,35 @@ static int woal_passphrase(moal_private *priv, struct iwreq *wrq)
 	if (action == 0) {
 		memset(buf, 0, sizeof(buf));
 		if (sec->param.passphrase.ssid.ssid_len) {
-			len += sprintf(buf + len, "ssid:");
+			len += snprintf(buf + len, sizeof(buf), "ssid:");
 			moal_memcpy_ext(priv->phandle, buf + len,
 					sec->param.passphrase.ssid.ssid,
 					sec->param.passphrase.ssid.ssid_len,
 					sizeof(buf) - len);
 			len += sec->param.passphrase.ssid.ssid_len;
-			len += sprintf(buf + len, " ");
+			len += snprintf(buf + len, sizeof(buf), " ");
 		}
 		if (memcmp(&sec->param.passphrase.bssid, zero_mac,
 			   sizeof(zero_mac))) {
 			mac = (t_u8 *)&sec->param.passphrase.bssid;
-			len += sprintf(buf + len, "bssid:");
+			len += snprintf(buf + len, sizeof(buf), "bssid:");
 			for (i = 0; i < ETH_ALEN - 1; ++i)
-				len += sprintf(buf + len, "%02x:", mac[i]);
-			len += sprintf(buf + len, "%02x ", mac[i]);
+				len += snprintf(buf + len, sizeof(buf),
+						"%02x:", mac[i]);
+			len += snprintf(buf + len, sizeof(buf), "%02x ",
+					mac[i]);
 		}
 		if (sec->param.passphrase.psk_type == MLAN_PSK_PMK) {
-			len += sprintf(buf + len, "psk:");
+			len += snprintf(buf + len, sizeof(buf), "psk:");
 			for (i = 0; i < MLAN_MAX_KEY_LENGTH; ++i)
-				len += sprintf(
-					buf + len, "%02x",
+				len += snprintf(
+					buf + len, sizeof(buf), "%02x",
 					sec->param.passphrase.psk.pmk.pmk[i]);
-			len += sprintf(buf + len, "\n");
+			len += snprintf(buf + len, sizeof(buf), "\n");
 		}
 		if (sec->param.passphrase.psk_type == MLAN_PSK_PASSPHRASE) {
-			len += sprintf(
-				buf + len, "passphrase:%s\n",
+			len += snprintf(
+				buf + len, sizeof(buf), "passphrase:%s\n",
 				sec->param.passphrase.psk.passphrase.passphrase);
 		}
 		if (wrq->u.data.pointer) {
@@ -3833,11 +3995,11 @@ static int woal_get_key_ioctl(moal_private *priv, struct iwreq *wrq)
 		goto done;
 	}
 	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "PTK: ");
+		snprintf((char *)tmp, sizeof(key_ascii), "\n%s", "PTK: ");
 		tmp += 5;
 		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
+			tmp += snprintf((char *)tmp, sizeof(key_ascii), "%02x",
+					sec->param.encrypt_key.key_material[i]);
 	}
 
 	/* Get Multicase Key */
@@ -3854,11 +4016,11 @@ static int woal_get_key_ioctl(moal_private *priv, struct iwreq *wrq)
 		goto done;
 	}
 	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "GTK: ");
+		snprintf((char *)tmp, sizeof(key_ascii), "\n%s", "GTK: ");
 		tmp += 5;
 		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
+			tmp += snprintf((char *)tmp, sizeof(key_ascii), "%02x",
+					sec->param.encrypt_key.key_material[i]);
 	}
 
 	/* Get IGTK Key */
@@ -3875,11 +4037,11 @@ static int woal_get_key_ioctl(moal_private *priv, struct iwreq *wrq)
 		goto done;
 	}
 	if (sec->param.encrypt_key.key_len) {
-		sprintf((char *)tmp, "\n%s", "IGTK: ");
+		snprintf((char *)tmp, sizeof(key_ascii), "\n%s", "IGTK: ");
 		tmp += 6;
 		for (i = 0; i < sec->param.encrypt_key.key_len; i++)
-			tmp += sprintf((char *)tmp, "%02x",
-				       sec->param.encrypt_key.key_material[i]);
+			tmp += snprintf((char *)tmp, sizeof(key_ascii), "%02x",
+					sec->param.encrypt_key.key_material[i]);
 	}
 
 	wrq->u.data.length = sizeof(key_ascii) + 1;
@@ -3898,6 +4060,57 @@ static int woal_get_key_ioctl(moal_private *priv, struct iwreq *wrq)
 	return ret;
 }
 
+/**
+ *  @brief arpfilter ioctl function
+ *
+ *  @param priv     A pointer to moal_private structure
+ *  @param wrq      A pointer to iwreq structure
+ *  @return         0 --success, otherwise fail
+ */
+static int woal_arp_filter(moal_private *priv, struct iwreq *wrq)
+{
+	int ret = 0;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ioctl_req *req = NULL;
+	int data_length = wrq->u.data.length, copy_len;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	copy_len = MIN(sizeof(misc->param.gen_ie.ie_data),
+		       sizeof(int) * data_length);
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_GEN_IE;
+	req->req_id = MLAN_IOCTL_MISC_CFG;
+	req->action = MLAN_ACT_SET;
+	misc->param.gen_ie.type = MLAN_IE_TYPE_ARP_FILTER;
+	misc->param.gen_ie.len = data_length;
+
+	/* get the whole command from user */
+	if (copy_from_user(misc->param.gen_ie.ie_data, wrq->u.data.pointer,
+			   copy_len)) {
+		PRINTM(MERROR, "copy from user failed\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Set/get IP address
  *
@@ -4061,7 +4274,6 @@ static int woal_tx_bf_cap_ioctl(moal_private *priv, struct iwreq *wrq)
 #define SNR_THRESHOLD_PARAM 4
 #define SOUND_INTVL_PARAM 5
 #define BF_MODE_PARAM 6
-#define MAX_TX_BF_GLOBAL_ARGS 6
 #define BF_CFG_ACT_GET 0
 #define BF_CFG_ACT_SET 1
 
@@ -4103,7 +4315,7 @@ static int woal_tx_bf_cfg_ioctl(moal_private *priv, struct iwreq *wrq)
 	char_count = data_length - 1;
 	memset(buf, 0, sizeof(buf));
 	if (char_count) {
-		if (data_length > sizeof(buf)) {
+		if (data_length > (int)sizeof(buf)) {
 			PRINTM(MERROR, "Too many arguments\n");
 			ret = -EINVAL;
 			goto done;
@@ -4147,7 +4359,7 @@ static int woal_tx_bf_cfg_ioctl(moal_private *priv, struct iwreq *wrq)
 						*token = '\0';
 						str = token + 1;
 					}
-					woal_atoi(&tmp_val, pos);
+					(void)woal_atoi(&tmp_val, pos);
 					switch (i) {
 					case BF_ENABLE_PARAM:
 						bf_global->bf_enbl =
@@ -4244,11 +4456,11 @@ static int woal_tx_bf_cfg_ioctl(moal_private *priv, struct iwreq *wrq)
 				bf_cfg.action = BF_CFG_ACT_GET;
 			} else {
 				woal_mac2u8(tx_bf_peer->peer_mac, &buf[2]);
-				woal_atoi(&tmp_val, &buf[20]);
+				(void)woal_atoi(&tmp_val, &buf[20]);
 				tx_bf_peer->bf_enbl = (t_u8)tmp_val;
-				woal_atoi(&tmp_val, &buf[22]);
+				(void)woal_atoi(&tmp_val, &buf[22]);
 				tx_bf_peer->sounding_enbl = (t_u8)tmp_val;
-				woal_atoi(&tmp_val, &buf[24]);
+				(void)woal_atoi(&tmp_val, &buf[24]);
 				tx_bf_peer->fb_type = (t_u8)tmp_val;
 				action = MLAN_ACT_SET;
 				bf_cfg.action = BF_CFG_ACT_SET;
@@ -4303,73 +4515,89 @@ static int woal_tx_bf_cfg_ioctl(moal_private *priv, struct iwreq *wrq)
 		memset(buf, 0, sizeof(buf));
 		switch (bf_action) {
 		case BF_GLOBAL_CONFIGURATION:
-			data_length += sprintf(buf + data_length, "%d ",
-					       (int)bf_global->bf_enbl);
-			data_length += sprintf(buf + data_length, "%d ",
-					       (int)bf_global->sounding_enbl);
-			data_length += sprintf(buf + data_length, "%d ",
-					       (int)bf_global->fb_type);
-			data_length += sprintf(buf + data_length, "%d ",
-					       (int)bf_global->snr_threshold);
 			data_length +=
-				sprintf(buf + data_length, "%d ",
-					(int)bf_global->sounding_interval);
-			data_length += sprintf(buf + data_length, "%d ",
-					       (int)bf_global->bf_mode);
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ", (int)bf_global->bf_enbl);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ", (int)bf_global->sounding_enbl);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ", (int)bf_global->fb_type);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ", (int)bf_global->snr_threshold);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ",
+					 (int)bf_global->sounding_interval);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d ", (int)bf_global->bf_mode);
 			break;
 		case SET_GET_BF_PERIODICITY:
-			data_length += sprintf(buf + data_length,
-					       "%02x:%02x:%02x:%02x:%02x:%02x",
-					       bf_periodicity->peer_mac[0],
-					       bf_periodicity->peer_mac[1],
-					       bf_periodicity->peer_mac[2],
-					       bf_periodicity->peer_mac[3],
-					       bf_periodicity->peer_mac[4],
-					       bf_periodicity->peer_mac[5]);
-			data_length += sprintf(buf + data_length, "%c", ' ');
-			data_length += sprintf(buf + data_length, "%d",
-					       bf_periodicity->interval);
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%02x:%02x:%02x:%02x:%02x:%02x",
+					 bf_periodicity->peer_mac[0],
+					 bf_periodicity->peer_mac[1],
+					 bf_periodicity->peer_mac[2],
+					 bf_periodicity->peer_mac[3],
+					 bf_periodicity->peer_mac[4],
+					 bf_periodicity->peer_mac[5]);
+			data_length += snprintf(buf + data_length,
+						MAX_IN_OUT_CHAR, "%c", ' ');
+			data_length +=
+				snprintf(buf + data_length, MAX_IN_OUT_CHAR,
+					 "%d", bf_periodicity->interval);
 			break;
 		case TX_BF_FOR_PEER_ENBL:
-			for (i = 0; i < bf_cfg.no_of_peers; i++) {
-				data_length +=
-					sprintf(buf + data_length,
-						"%02x:%02x:%02x:%02x:%02x:%02x",
-						tx_bf_peer->peer_mac[0],
-						tx_bf_peer->peer_mac[1],
-						tx_bf_peer->peer_mac[2],
-						tx_bf_peer->peer_mac[3],
-						tx_bf_peer->peer_mac[4],
-						tx_bf_peer->peer_mac[5]);
+			for (i = 0; i < (int)bf_cfg.no_of_peers; i++) {
+				data_length += snprintf(
+					buf + data_length, MAX_IN_OUT_CHAR,
+					"%02x:%02x:%02x:%02x:%02x:%02x",
+					tx_bf_peer->peer_mac[0],
+					tx_bf_peer->peer_mac[1],
+					tx_bf_peer->peer_mac[2],
+					tx_bf_peer->peer_mac[3],
+					tx_bf_peer->peer_mac[4],
+					tx_bf_peer->peer_mac[5]);
 				data_length +=
-					sprintf(buf + data_length, "%c", ' ');
-				data_length += sprintf(buf + data_length, "%d;",
-						       tx_bf_peer->bf_enbl);
+					snprintf(buf + data_length,
+						 MAX_IN_OUT_CHAR, "%c", ' ');
+				data_length += snprintf(buf + data_length,
+							MAX_IN_OUT_CHAR, "%d;",
+							tx_bf_peer->bf_enbl);
 				data_length +=
-					sprintf(buf + data_length, "%d;",
-						tx_bf_peer->sounding_enbl);
-				data_length += sprintf(buf + data_length, "%d ",
-						       tx_bf_peer->fb_type);
+					snprintf(buf + data_length,
+						 MAX_IN_OUT_CHAR, "%d;",
+						 tx_bf_peer->sounding_enbl);
+				data_length += snprintf(buf + data_length,
+							MAX_IN_OUT_CHAR, "%d ",
+							tx_bf_peer->fb_type);
 				tx_bf_peer++;
 			}
 			break;
 		case SET_SNR_THR_PEER:
-			for (i = 0; i < bf_cfg.no_of_peers; i++) {
+			for (i = 0; i < (int)bf_cfg.no_of_peers; i++) {
+				data_length += snprintf(
+					buf + data_length, MAX_IN_OUT_CHAR,
+					"%02x:%02x:%02x:%02x:%02x:%02x",
+					bf_snr->peer_mac[0],
+					bf_snr->peer_mac[1],
+					bf_snr->peer_mac[2],
+					bf_snr->peer_mac[3],
+					bf_snr->peer_mac[4],
+					bf_snr->peer_mac[5]);
 				data_length +=
-					sprintf(buf + data_length,
-						"%02x:%02x:%02x:%02x:%02x:%02x",
-						bf_snr->peer_mac[0],
-						bf_snr->peer_mac[1],
-						bf_snr->peer_mac[2],
-						bf_snr->peer_mac[3],
-						bf_snr->peer_mac[4],
-						bf_snr->peer_mac[5]);
+					snprintf(buf + data_length,
+						 MAX_IN_OUT_CHAR, "%c", ';');
+				data_length += snprintf(buf + data_length,
+							MAX_IN_OUT_CHAR, "%d",
+							bf_snr->snr);
 				data_length +=
-					sprintf(buf + data_length, "%c", ';');
-				data_length += sprintf(buf + data_length, "%d",
-						       bf_snr->snr);
-				data_length +=
-					sprintf(buf + data_length, "%c", ' ');
+					snprintf(buf + data_length,
+						 MAX_IN_OUT_CHAR, "%c", ' ');
 				bf_snr++;
 			}
 			break;
@@ -4415,10 +4643,12 @@ static int moal_ret_get_scan_table_ioctl(struct iwreq *wrq,
 	num_scans_done = 0;
 	ret_code = MLAN_STATUS_SUCCESS;
 
-	prsp_info = (wlan_ioctl_get_scan_table_info *)wrq->u.data.pointer;
+	prsp_info =
+		(wlan_ioctl_get_scan_table_info __force *)wrq->u.data.pointer;
 	pcurrent = (t_u8 *)prsp_info->scan_table_entry_buf;
 
-	pbuffer_end = wrq->u.data.pointer + wrq->u.data.length - 1;
+	pbuffer_end =
+		(t_u8 __force *)wrq->u.data.pointer + wrq->u.data.length - 1;
 	space_left = pbuffer_end - pcurrent;
 	scan_table = (BSSDescriptor_t *)(scan_resp->pscan_table);
 
@@ -4459,7 +4689,7 @@ static int moal_ret_get_scan_table_ioctl(struct iwreq *wrq,
 	}
 
 	prsp_info->scan_number = num_scans_done;
-	ret_len = pcurrent - (t_u8 *)wrq->u.data.pointer;
+	ret_len = pcurrent - (t_u8 __force *)wrq->u.data.pointer;
 
 	wrq->u.data.length = ret_len;
 
@@ -4482,7 +4712,6 @@ static int moal_ret_get_scan_table_ioctl(struct iwreq *wrq,
 static mlan_status woal_get_scan_table_ioctl(moal_private *priv,
 					     struct iwreq *wrq)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_scan *scan = NULL;
 	int scan_start = 0;
@@ -4493,7 +4722,7 @@ static mlan_status woal_get_scan_table_ioctl(moal_private *priv,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_scan));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -4506,7 +4735,6 @@ static mlan_status woal_get_scan_table_ioctl(moal_private *priv,
 	if (copy_from_user(&scan_start, wrq->u.data.pointer,
 			   sizeof(scan_start))) {
 		PRINTM(MERROR, "copy from user failed\n");
-		ret = -EFAULT;
 		goto done;
 	}
 	if (scan_start > 0)
@@ -4537,17 +4765,27 @@ static mlan_status woal_get_scan_table_ioctl(moal_private *priv,
 static int woal_set_user_scan_ext_ioctl(moal_private *priv, struct iwreq *wrq)
 {
 	int ret = 0;
-	wlan_user_scan_cfg scan_req;
+	wlan_user_scan_cfg *scan_req;
 	ENTER();
-	memset(&scan_req, 0x00, sizeof(scan_req));
-	if (copy_from_user(&scan_req, wrq->u.data.pointer,
-			   MIN(wrq->u.data.length, sizeof(scan_req)))) {
+	scan_req = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+	memset(scan_req, 0x00, sizeof(wlan_user_scan_cfg));
+	if (copy_from_user(scan_req, wrq->u.data.pointer,
+			   MIN(wrq->u.data.length,
+			       sizeof(wlan_user_scan_cfg)))) {
 		PRINTM(MINFO, "Copy from user failed\n");
+		kfree(scan_req);
 		LEAVE();
 		return -EFAULT;
 	}
-	if (MLAN_STATUS_FAILURE == woal_do_scan(priv, &scan_req))
+	if (MLAN_STATUS_FAILURE == woal_do_scan(priv, scan_req))
 		ret = -EFAULT;
+	kfree(scan_req);
 	LEAVE();
 	return ret;
 }
@@ -4760,7 +4998,7 @@ static int woal_cmd52rdwr_ioctl(moal_private *priv, struct iwreq *wrq)
 static int woal_cmd53rdwr_ioctl(moal_private *priv, struct iwreq *wrq)
 {
 	t_u8 *buf = NULL;
-	t_u8 rw, func, mode;
+	t_u8 rw, mode;
 	t_u16 blklen = 0, blknum = 0;
 	int reg = 0, pattern_len = 0, pos = 0, ret = MLAN_STATUS_SUCCESS;
 	t_u32 total_len = 0;
@@ -4792,7 +5030,6 @@ static int woal_cmd53rdwr_ioctl(moal_private *priv, struct iwreq *wrq)
 	}
 
 	rw = buf[0]; /* read/write (0/1) */
-	func = buf[1]; /* func (0/1/2) */
 	reg = buf[5]; /* address */
 	reg = (reg << 8) + buf[4];
 	reg = (reg << 8) + buf[3];
@@ -4812,8 +5049,8 @@ static int woal_cmd53rdwr_ioctl(moal_private *priv, struct iwreq *wrq)
 		goto done;
 	}
 	PRINTM(MINFO,
-	       "CMD53 read/write, func = %d, addr = %#x, mode = %d, block size = %d, block(byte) number = %d\n",
-	       func, reg, mode, blklen, blknum);
+	       "CMD53 read/write, addr = %#x, mode = %d, block size = %d, block(byte) number = %d\n",
+	       reg, mode, blklen, blknum);
 
 	if (!rw) {
 		sdio_claim_host(
@@ -4835,12 +5072,12 @@ static int woal_cmd53rdwr_ioctl(moal_private *priv, struct iwreq *wrq)
 		wrq->u.data.length = total_len;
 	} else {
 		pattern_len = wrq->u.data.length - 11;
-		if (pattern_len > total_len)
+		if (pattern_len > (int)total_len)
 			pattern_len = total_len;
 		memset(data, 0, WOAL_2K_BYTES);
 
 		/* Copy/duplicate the pattern to data buffer */
-		for (pos = 0; pos < total_len; pos++)
+		for (pos = 0; pos < (int)total_len; pos++)
 			data[pos] = buf[11 + (pos % pattern_len)];
 
 		sdio_claim_host(
@@ -5898,7 +6135,7 @@ static int woal_dfs_testing(moal_private *priv, struct iwreq *wrq)
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_11h_cfg *ds_11hcfg = NULL;
 	int ret = 0;
-	int data[4], copy_len;
+	int data[4] = {0}, copy_len;
 	int data_length = wrq->u.data.length;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	ENTER();
@@ -5924,8 +6161,8 @@ static int woal_dfs_testing(moal_private *priv, struct iwreq *wrq)
 			ret = -EFAULT;
 			goto done;
 		}
-		if ((unsigned)data[0] > 0xFFFF) {
-			PRINTM(MERROR, "The maximum user CAC is 65535 msec.\n");
+		if ((unsigned)data[0] > 1800) {
+			PRINTM(MERROR, "The maximum user CAC is 1800 sec.\n");
 			ret = -EINVAL;
 			goto done;
 		}
@@ -5947,7 +6184,7 @@ static int woal_dfs_testing(moal_private *priv, struct iwreq *wrq)
 		ds_11hcfg->param.dfs_testing.usr_no_chan_change =
 			data[2] ? 1 : 0;
 		ds_11hcfg->param.dfs_testing.usr_fixed_new_chan = (t_u8)data[3];
-		priv->phandle->cac_period_jiffies = (t_u16)data[0] * HZ / 1000;
+		priv->phandle->cac_period_jiffies = (t_u16)data[0] * HZ;
 		req->action = MLAN_ACT_SET;
 	} else {
 		PRINTM(MERROR, "Invalid number of args!\n");
@@ -6061,7 +6298,7 @@ static int woal_mgmt_frame_passthru_ctrl(moal_private *priv, struct iwreq *wrq)
 static int woal_cfp_code(moal_private *priv, struct iwreq *wrq)
 {
 	int ret = 0;
-	int data[2], copy_len;
+	int data[2] = {0}, copy_len;
 	int data_length = wrq->u.data.length;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_misc_cfg *misc_cfg = NULL;
@@ -6235,7 +6472,7 @@ static int woal_set_get_tx_rx_ant(moal_private *priv, struct iwreq *wrq)
  */
 static int woal_ind_rst_ioctl(moal_private *priv, struct iwreq *wrq)
 {
-	int data[2], data_length = wrq->u.data.length, copy_len;
+	int data[2] = {0}, data_length = wrq->u.data.length, copy_len;
 	int ret = 0;
 	mlan_ds_misc_cfg *misc = NULL;
 	mlan_ioctl_req *req = NULL;
@@ -6529,6 +6766,9 @@ int woal_wext_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 		case WOAL_SLEEP_PARAMS:
 			ret = woal_sleep_params_ioctl(priv, wrq);
 			break;
+		case WOAL_NET_MONITOR:
+			ret = woal_net_monitor_ioctl(priv, wrq);
+			break;
 		case WOAL_DFS_TESTING:
 			ret = woal_dfs_testing(priv, wrq);
 			break;
@@ -6636,6 +6876,9 @@ int woal_wext_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 	case WOAL_HOST_CMD:
 		ret = woal_host_command(priv, wrq);
 		break;
+	case WOAL_ARP_FILTER:
+		ret = woal_arp_filter(priv, wrq);
+		break;
 	case WOAL_SET_INTS_GET_CHARS:
 		switch ((int)wrq->u.data.flags) {
 		case WOAL_READ_EEPROM:
@@ -6716,7 +6959,6 @@ int woal_wext_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 mlan_status woal_get_data_rates(moal_private *priv, t_u8 wait_option,
 				moal_802_11_rates *m_rates)
 {
-	int ret = 0;
 	mlan_ds_rate *rate = NULL;
 	mlan_ioctl_req *req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -6725,7 +6967,7 @@ mlan_status woal_get_data_rates(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_rate));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
@@ -6763,7 +7005,6 @@ mlan_status woal_get_data_rates(moal_private *priv, t_u8 wait_option,
 mlan_status woal_get_channel_list(moal_private *priv, t_u8 wait_option,
 				  mlan_chan_list *chan_list)
 {
-	int ret = 0;
 	mlan_ds_bss *bss = NULL;
 	mlan_ioctl_req *req = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -6772,7 +7013,7 @@ mlan_status woal_get_channel_list(moal_private *priv, t_u8 wait_option,
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto done;
 	}
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.h
old mode 100644
new mode 100755
index 22355f738..c35ef67e0
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_priv.h
@@ -4,7 +4,7 @@
  * @brief This file contains definition for extended private IOCTL call.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -130,6 +130,8 @@ Change log:
 #define WOAL_ADDBA_REJECT 27
 /** Private command ID to set/get sleep parameters */
 #define WOAL_SLEEP_PARAMS 28
+/** Private command ID to set/get network monitor */
+#define WOAL_NET_MONITOR 30
 /** Private command ID to set/get TX BF capabilities */
 #define WOAL_TX_BF_CAP 31
 /** Private command ID to set/get dfs testing settings */
@@ -235,6 +237,9 @@ Change log:
 /** Private command ID for hostcmd */
 #define WOAL_HOST_CMD (WOAL_IOCTL + 17)
 
+/** Private command ID for arpfilter */
+#define WOAL_ARP_FILTER (WOAL_IOCTL + 19)
+
 /** Private command ID to set ints and get chars */
 #define WOAL_SET_INTS_GET_CHARS (WOAL_IOCTL + 21)
 /** Private command ID to read EEPROM data */
@@ -276,200 +281,6 @@ Change log:
 #define WOAL_FROYO_STOP (WOAL_IOCTL + 30)
 #endif
 
-/**
- * iwpriv ioctl handlers
- */
-static const struct iw_priv_args woal_private_args[] = {
-	{WOAL_SETONEINT_GETWORDCHAR, IW_PRIV_TYPE_INT | 1,
-	 IW_PRIV_TYPE_CHAR | 128, ""},
-	{WOAL_VERSION, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
-	 "version"},
-	{WOAL_VEREXT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128, "verext"},
-	{WOAL_SETNONE_GETNONE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, ""},
-	{WOAL_WARMRESET, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "warmreset"},
-#ifdef CONFIG_USB_SUSPEND
-	{WOAL_USB_SUSPEND, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "usbsuspend"},
-	{WOAL_USB_RESUME, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "usbresume"},
-#endif /* CONFIG_USB_SUSPEND */
-	{WOAL_SETONEINT_GETONEINT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 ""},
-	{WOAL_SET_GET_TXRATE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "txratecfg"},
-	{WOAL_SET_GET_REGIONCODE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "regioncode"},
-	{WOAL_SET_RADIO, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "radioctrl"},
-	{WOAL_WMM_ENABLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "wmmcfg"},
-	{WOAL_11D_ENABLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "11dcfg"},
-	{WOAL_11D_CLR_CHAN_TABLE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
-	 "11dclrtbl"},
-	{WOAL_SET_GET_QOS_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "qoscfg"},
-#ifndef OPCHAN
-	{WOAL_SET_GET_WWS_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "wwscfg"},
-#endif
-#if defined(REASSOCIATION)
-	{WOAL_SET_GET_REASSOC, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "reassoctrl"},
-#endif
-	{WOAL_TXBUF_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "txbufcfg"},
-	{WOAL_SLEEP_PD, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "sleeppd"},
-	{WOAL_AUTH_TYPE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "authtype"},
-	{WOAL_PORT_CTRL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "port_ctrl"},
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
-	{WOAL_SET_GET_BSS_ROLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "bssrole"},
-#endif
-#endif
-	{WOAL_SET_GET_11H_LOCAL_PWR_CONSTRAINT, IW_PRIV_TYPE_INT | 1,
-	 IW_PRIV_TYPE_INT | 1, "powercons"},
-	{WOAL_HT_STREAM_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "htstreamcfg"},
-	{WOAL_MAC_CONTROL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "macctrl"},
-	{WOAL_THERMAL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "thermal"},
-	{WOAL_CFG_HOTSPOT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "hotspotcfg"},
-	{WOAL_SET_GET_SIXTEEN_INT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 ""},
-	{WOAL_TX_POWERCFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "txpowercfg"},
-#ifdef DEBUG_LEVEL1
-	{WOAL_DRV_DBG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "drvdbg"},
-#endif
-	{WOAL_BEACON_INTERVAL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "bcninterval"},
-	{WOAL_SIGNAL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "getsignal"},
-	{
-		WOAL_DEEP_SLEEP,
-		IW_PRIV_TYPE_INT | 16,
-		IW_PRIV_TYPE_INT | 16,
-		"deepsleep",
-	},
-	{WOAL_11N_TX_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "httxcfg"},
-	{WOAL_11N_HTCAP_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "htcapinfo"},
-	{WOAL_PRIO_TBL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "aggrpriotbl"},
-	{WOAL_11N_AMSDU_AGGR_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "amsduaggrctrl"},
-	{WOAL_ADDBA_UPDT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "addbapara"},
-	{WOAL_ADDBA_REJECT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "addbareject"},
-	{WOAL_TX_BF_CAP, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "httxbfcap"},
-	{WOAL_HS_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "hscfg"},
-	{WOAL_HS_SETPARA, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "hssetpara"},
-	{WOAL_REG_READ_WRITE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "regrdwr"},
-	{WOAL_BAND_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "bandcfg"},
-	{WOAL_INACTIVITY_TIMEOUT_EXT, IW_PRIV_TYPE_INT | 16,
-	 IW_PRIV_TYPE_INT | 16, "inactivityto"},
-#ifdef SDIO
-	{WOAL_SDIO_CLOCK, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "sdioclock"},
-	{WOAL_CMD_52RDWR, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "sdcmd52rw"},
-#endif
-	{WOAL_SCAN_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "scancfg"},
-	{WOAL_PS_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "pscfg"},
-	{WOAL_MEM_READ_WRITE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "memrdwr"},
-#ifdef SDIO
-	{WOAL_SDIO_MPA_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "mpactrl"},
-#endif
-	{WOAL_SLEEP_PARAMS, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "sleepparams"},
-	{WOAL_DFS_TESTING, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "dfstesting"},
-	{WOAL_MGMT_FRAME_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "mgmtframectrl"},
-	{WOAL_CFP_CODE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "cfpcode"},
-	{WOAL_SET_GET_TX_RX_ANT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "antcfg"},
-	{WOAL_IND_RST_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
-	 "indrstcfg"},
-	{WOALGETLOG, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | GETLOG_BUFSIZE,
-	 "getlog"},
-	{WOAL_SETADDR_GETNONE, IW_PRIV_TYPE_ADDR | 1, IW_PRIV_TYPE_NONE, ""},
-	{WOAL_DEAUTH, IW_PRIV_TYPE_ADDR | 1, IW_PRIV_TYPE_NONE, "deauth"},
-	{WOAL_SET_GET_256_CHAR, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, ""},
-	{WOAL_PASSPHRASE, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "passphrase"},
-	{WOAL_GET_KEY, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "getkey"},
-	{WOAL_ASSOCIATE, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "associate"},
-	{WOAL_WMM_QUEUE_STATUS, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, "qstatus"},
-	{WOAL_WMM_TS_STATUS, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "ts_status"},
-	{WOAL_IP_ADDRESS, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "ipaddr"},
-	{WOAL_TX_BF_CFG, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "httxbfcfg"},
-	{WOAL_SETNONE_GETTWELVE_CHAR, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | 12,
-	 ""},
-	{WOAL_WPS_SESSION, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | 12,
-	 "wpssession"},
-	{WOAL_SETNONE_GET_FOUR_INT, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4,
-	 ""},
-	{WOAL_DATA_RATE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4,
-	 "getdatarate"},
-	{WOAL_ESUPP_MODE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4, "esuppmode"},
-	{WOAL_SET_GET_64_INT, IW_PRIV_TYPE_INT | 64, IW_PRIV_TYPE_INT | 64, ""},
-	{WOAL_ECL_SYS_CLOCK, IW_PRIV_TYPE_INT | 64, IW_PRIV_TYPE_INT | 64,
-	 "sysclock"},
-	{WOAL_HOST_CMD, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_BYTE | 2047,
-	 "hostcmd"},
-	{WOAL_SET_INTS_GET_CHARS, IW_PRIV_TYPE_INT | 16,
-	 IW_PRIV_TYPE_BYTE | 256, ""},
-	{WOAL_READ_EEPROM, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_BYTE | 256,
-	 "rdeeprom"},
-	{WOAL_SET_GET_2K_BYTES, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, ""},
-#if defined(SDIO)
-	{WOAL_CMD_53RDWR, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "sdcmd53rw"},
-#endif
-	{WOAL_SET_USER_SCAN, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "setuserscan"},
-	{WOAL_GET_SCAN_TABLE, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "getscantable"},
-	{WOAL_SET_USER_SCAN_EXT, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "setuserscanext"},
-	{WOAL_WMM_ADDTS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "addts"},
-	{WOAL_WMM_DELTS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "delts"},
-	{WOAL_WMM_QUEUE_CONFIG, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "qconfig"},
-	{WOAL_WMM_QUEUE_STATS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "qstats"},
-	{WOAL_BYPASSED_PACKET, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
-	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "pb_bypass"},
-#ifdef UAP_WEXT
-	{WOAL_FROYO_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "START"},
-	{WOAL_FROYO_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "STOP"},
-	{WOAL_FROYO_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, "WL_FW_RELOAD"},
-#endif
-};
-
 /** moal_802_11_rates  */
 typedef struct _moal_802_11_rates {
 	/** Num of rates */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_proc.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_proc.c
old mode 100644
new mode 100755
index 1d1898c32..93f970876
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_proc.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_proc.c
@@ -3,7 +3,7 @@
  * @brief This file contains functions for proc file.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -29,6 +29,10 @@ Change log:
 #ifdef UAP_SUPPORT
 #include "moal_uap.h"
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#include "moal_cfg80211.h"
+#include "moal_cfg80211_util.h"
+#endif
 #ifdef SDIO
 #include "moal_sdio.h"
 #endif
@@ -41,7 +45,7 @@ Change log:
 #define MWLAN_PROC "mwlan"
 #define WLAN_PROC "adapter%d"
 /** Proc mwlan directory entry */
-struct proc_dir_entry *proc_mwlan;
+static struct proc_dir_entry *proc_mwlan;
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 #define PROC_DIR NULL
@@ -60,6 +64,9 @@ static char *szModes[] = {
 };
 #endif
 
+mlan_status parse_arguments(t_u8 *pos, int *data, int datalen,
+			    int *user_data_len);
+
 /********************************************************
 		Global Variables
 ********************************************************/
@@ -81,6 +88,7 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 	struct net_device *netdev = (struct net_device *)sfp->private;
 	char fmt[MLAN_MAX_VER_STR_LEN];
 	moal_private *priv = (moal_private *)netdev_priv(netdev);
+	mlan_fw_info fw_info;
 #ifdef STA_SUPPORT
 	int i = 0;
 	moal_handle *handle = NULL;
@@ -105,6 +113,8 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 		t_u8 c[4];
 	} ver;
 
+	fw_info.uuid_lo = fw_info.uuid_hi = 0x0ULL;
+
 	ENTER();
 
 	if (priv == NULL)
@@ -154,6 +164,11 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 	ver.l = handle->fw_release_number;
 	seq_printf(sfp, "firmware_major_version=%u.%u.%u\n", ver.c[2], ver.c[1],
 		   ver.c[0]);
+
+	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
+	if (fw_info.uuid_lo || fw_info.uuid_hi)
+		seq_printf(sfp, "uuid = %llx%llx\n", fw_info.uuid_lo,
+			   fw_info.uuid_hi);
 #ifdef WIFI_DIRECT_SUPPORT
 	if (priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT) {
 		if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA)
@@ -220,7 +235,7 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 	seq_printf(sfp, "carrier %s\n",
 		   ((netif_carrier_ok(priv->netdev)) ? "on" : "off"));
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
-	for (i = 0; i < netdev->num_tx_queues; i++) {
+	for (i = 0; i < (int)netdev->num_tx_queues; i++) {
 		seq_printf(sfp, "tx queue %d:  %s\n", i,
 			   ((netif_tx_queue_stopped(
 				    netdev_get_tx_queue(netdev, 0))) ?
@@ -270,6 +285,86 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 			   ustats.rsna_4way_hshk_failures);
 	}
 #endif /* UAP_SUPPORT */
+	seq_printf(sfp, "=== tp_acnt.on:%d drop_point:%d ===\n",
+		   handle->tp_acnt.on, handle->tp_acnt.drop_point);
+	seq_printf(sfp, "====Tx accounting====\n");
+	for (i = 0; i < MAX_TP_ACCOUNT_DROP_POINT_NUM; i++) {
+		seq_printf(sfp, "[%d] Tx packets     : %lu\n", i,
+			   handle->tp_acnt.tx_packets[i]);
+		seq_printf(sfp, "[%d] Tx packets last: %lu\n", i,
+			   handle->tp_acnt.tx_packets_last[i]);
+		seq_printf(sfp, "[%d] Tx packets rate: %lu\n", i,
+			   handle->tp_acnt.tx_packets_rate[i]);
+		seq_printf(sfp, "[%d] Tx bytes       : %lu\n", i,
+			   handle->tp_acnt.tx_bytes[i]);
+		seq_printf(sfp, "[%d] Tx bytes last  : %lu\n", i,
+			   handle->tp_acnt.tx_bytes_last[i]);
+		seq_printf(sfp, "[%d] Tx bytes rate  : %luMbps\n", i,
+			   handle->tp_acnt.tx_bytes_rate[i] * 8 / 1024 / 1024);
+	}
+	seq_printf(sfp, "Tx amsdu cnt		: %lu\n",
+		   handle->tp_acnt.tx_amsdu_cnt);
+	seq_printf(sfp, "Tx amsdu cnt last	: %lu\n",
+		   handle->tp_acnt.tx_amsdu_cnt_last);
+	seq_printf(sfp, "Tx amsdu cnt rate	: %lu\n",
+		   handle->tp_acnt.tx_amsdu_cnt_rate);
+	seq_printf(sfp, "Tx amsdu pkt cnt	: %lu\n",
+		   handle->tp_acnt.tx_amsdu_pkt_cnt);
+	seq_printf(sfp, "Tx amsdu pkt cnt last : %lu\n",
+		   handle->tp_acnt.tx_amsdu_pkt_cnt_last);
+	seq_printf(sfp, "Tx amsdu pkt cnt rate : %lu\n",
+		   handle->tp_acnt.tx_amsdu_pkt_cnt_rate);
+	seq_printf(sfp, "Tx intr cnt    		: %lu\n",
+		   handle->tp_acnt.tx_intr_cnt);
+	seq_printf(sfp, "Tx intr last        : %lu\n",
+		   handle->tp_acnt.tx_intr_last);
+	seq_printf(sfp, "Tx intr rate        : %lu\n",
+		   handle->tp_acnt.tx_intr_rate);
+	seq_printf(sfp, "Tx pending          : %lu\n",
+		   handle->tp_acnt.tx_pending);
+	seq_printf(sfp, "Tx xmit skb realloc : %lu\n",
+		   handle->tp_acnt.tx_xmit_skb_realloc_cnt);
+	seq_printf(sfp, "Tx stop queue cnt : %lu\n",
+		   handle->tp_acnt.tx_stop_queue_cnt);
+	seq_printf(sfp, "====Rx accounting====\n");
+	for (i = 0; i < MAX_TP_ACCOUNT_DROP_POINT_NUM; i++) {
+		seq_printf(sfp, "[%d] Rx packets     : %lu\n", i,
+			   handle->tp_acnt.rx_packets[i]);
+		seq_printf(sfp, "[%d] Rx packets last: %lu\n", i,
+			   handle->tp_acnt.rx_packets_last[i]);
+		seq_printf(sfp, "[%d] Rx packets rate: %lu\n", i,
+			   handle->tp_acnt.rx_packets_rate[i]);
+		seq_printf(sfp, "[%d] Rx bytes       : %lu\n", i,
+			   handle->tp_acnt.rx_bytes[i]);
+		seq_printf(sfp, "[%d] Rx bytes last  : %lu\n", i,
+			   handle->tp_acnt.rx_bytes_last[i]);
+		seq_printf(sfp, "[%d] Rx bytes rate  : %luMbps\n", i,
+			   handle->tp_acnt.rx_bytes_rate[i] * 8 / 1024 / 1024);
+	}
+	seq_printf(sfp, "Rx amsdu cnt		 : %lu\n",
+		   handle->tp_acnt.rx_amsdu_cnt);
+	seq_printf(sfp, "Rx amsdu cnt last	 : %lu\n",
+		   handle->tp_acnt.rx_amsdu_cnt_last);
+	seq_printf(sfp, "Rx amsdu cnt rate	 : %lu\n",
+		   handle->tp_acnt.rx_amsdu_cnt_rate);
+	seq_printf(sfp, "Rx amsdu pkt cnt	 : %lu\n",
+		   handle->tp_acnt.rx_amsdu_pkt_cnt);
+	seq_printf(sfp, "Rx amsdu pkt cnt last : %lu\n",
+		   handle->tp_acnt.rx_amsdu_pkt_cnt_last);
+	seq_printf(sfp, "Rx amsdu pkt cnt rate : %lu\n",
+		   handle->tp_acnt.rx_amsdu_pkt_cnt_rate);
+	seq_printf(sfp, "Rx intr cnt    	 : %lu\n",
+		   handle->tp_acnt.rx_intr_cnt);
+	seq_printf(sfp, "Rx intr last        : %lu\n",
+		   handle->tp_acnt.rx_intr_last);
+	seq_printf(sfp, "Rx intr rate        : %lu\n",
+		   handle->tp_acnt.rx_intr_rate);
+	seq_printf(sfp, "Rx pending          : %lu\n",
+		   handle->tp_acnt.rx_pending);
+	seq_printf(sfp, "Rx pause            : %lu\n",
+		   handle->tp_acnt.rx_paused_cnt);
+	seq_printf(sfp, "Rx rdptr full cnt   : %lu\n",
+		   handle->tp_acnt.rx_rdptr_full_cnt);
 exit:
 	LEAVE();
 	MODULE_PUT;
@@ -278,7 +373,9 @@ static int woal_info_proc_read(struct seq_file *sfp, void *data)
 
 static int woal_info_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_info_proc_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_info_proc_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_info_proc_read, PDE(inode)->data);
@@ -319,6 +416,7 @@ static int parse_cmd52_string(const char *buffer, size_t len, int *func,
 {
 	int ret = MLAN_STATUS_SUCCESS;
 	char *string = NULL;
+	char *tmp;
 	char *pos = NULL;
 	gfp_t flag;
 
@@ -330,6 +428,7 @@ static int parse_cmd52_string(const char *buffer, size_t len, int *func,
 
 	moal_memcpy_ext(NULL, string, buffer + strlen("sdcmd52rw="),
 			len - strlen("sdcmd52rw="), CMD52_STR_LEN - 1);
+	tmp = string;
 	string = strstrip(string);
 
 	*func = -1;
@@ -350,12 +449,140 @@ static int parse_cmd52_string(const char *buffer, size_t len, int *func,
 	pos = strsep(&string, " \t");
 	if (pos)
 		*val = woal_string_to_number(pos);
-	kfree(string);
+	kfree(tmp);
 	LEAVE();
 	return ret;
 }
 #endif
 
+void woal_priv_get_tx_rx_ant(struct seq_file *sfp, moal_private *priv)
+{
+	int ret = 0;
+	int data[4] = {0};
+	mlan_ds_radio_cfg *radio = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (sfp == NULL) {
+		PRINTM(MERROR, "Sequence file pointer null\n");
+		LEAVE();
+		return;
+	}
+
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_radio_cfg));
+	if (req == NULL) {
+		PRINTM(MERROR, "Memory allocation failure \n");
+		LEAVE();
+		return;
+	}
+	radio = (mlan_ds_radio_cfg *)req->pbuf;
+	radio->sub_command = MLAN_OID_ANT_CFG;
+	req->req_id = MLAN_IOCTL_RADIO_CFG;
+	req->action = MLAN_ACT_GET;
+
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status == MLAN_STATUS_FAILURE) {
+		PRINTM(MERROR, "Failed to send IOCTL request to firmware\n");
+		kfree(req);
+		LEAVE();
+		return;
+	}
+	if (priv->phandle->feature_control & FEATURE_CTRL_STREAM_2X2) {
+		data[0] = radio->param.ant_cfg.tx_antenna;
+		data[1] = radio->param.ant_cfg.rx_antenna;
+		if (data[0] && data[1])
+			ret = sizeof(int) * 2;
+		else
+			ret = sizeof(int) * 1;
+		if (ret == sizeof(int) * 1)
+			seq_printf(sfp, "antcfg=0x%x\n", data[0]);
+		else if (ret == sizeof(int) * 2)
+			seq_printf(sfp, "antcfg=0x%x 0x%x\n", data[0], data[1]);
+
+	} else {
+		if (radio->param.ant_cfg_1x1.antenna == 0xffff) {
+			seq_printf(
+				sfp, "antcfg=0x%x %d %d\n",
+				(int)radio->param.ant_cfg_1x1.antenna,
+				(int)radio->param.ant_cfg_1x1.evaluate_time,
+				(int)radio->param.ant_cfg_1x1.current_antenna);
+		} else {
+			seq_printf(sfp, "antcfg=0x%x\n",
+				   (int)radio->param.ant_cfg_1x1.antenna);
+		}
+	}
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return;
+}
+
+mlan_status woal_priv_set_tx_rx_ant(moal_handle *handle, char *line)
+{
+	moal_private *priv = NULL;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_radio_cfg *radio = NULL;
+	mlan_status status;
+	int data[5] = {0};
+	int user_data_len = 0;
+
+	ENTER();
+	memset((char *)data, 0, sizeof(data));
+	parse_arguments(line, data, ARRAY_SIZE(data), &user_data_len);
+
+	if (user_data_len > 2) {
+		PRINTM(MERROR, "Invalid number of args!\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+	if (!priv) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Allocate an IOCTL request buffer */
+	req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
+		sizeof(mlan_ds_radio_cfg));
+	if (req == NULL) {
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
+	/* Fill request buffer */
+	radio = (mlan_ds_radio_cfg *)req->pbuf;
+	radio->sub_command = MLAN_OID_ANT_CFG;
+	req->req_id = MLAN_IOCTL_RADIO_CFG;
+	req->action = MLAN_ACT_SET;
+
+	if (handle->feature_control & FEATURE_CTRL_STREAM_2X2) {
+		radio->param.ant_cfg.tx_antenna = data[0];
+		radio->param.ant_cfg.rx_antenna = data[0];
+		if (user_data_len == 2)
+			radio->param.ant_cfg.rx_antenna = data[1];
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+		if (IS_CARD9098(priv->phandle->card_type) ||
+		    IS_CARD9097(priv->phandle->card_type) ||
+		    IS_CARDIW62X(priv->phandle->card_type)) {
+			woal_cfg80211_notify_antcfg(priv, priv->phandle->wiphy,
+						    radio);
+		}
+#endif
+	} else
+		radio->param.ant_cfg_1x1.antenna = data[0];
+	if (user_data_len == 2)
+		radio->param.ant_cfg_1x1.evaluate_time = data[1];
+	/* Send IOCTL request to MLAN */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return status;
+}
+
 /**
  *  @brief config proc write function
  *
@@ -369,8 +596,9 @@ static int parse_cmd52_string(const char *buffer, size_t len, int *func,
 static ssize_t woal_config_write(struct file *f, const char __user *buf,
 				 size_t count, loff_t *off)
 {
-	char databuf[101];
+	char databuf[200];
 	char *line = NULL;
+	int ret = 0;
 	t_u32 config_data = 0;
 	struct seq_file *sfp = f->private_data;
 	moal_handle *handle = (moal_handle *)sfp->private;
@@ -432,23 +660,23 @@ static ssize_t woal_config_write(struct file *f, const char __user *buf,
 	}
 #endif /* SD */
 	if (!strncmp(databuf, "debug_dump", strlen("debug_dump"))) {
+		PRINTM(MERROR, "Recevie debug_dump command\n");
+#ifdef USB
+		if (!IS_USB(handle->card_type))
+#endif
+			handle->driver_status = MTRUE;
 		ref_handle = (moal_handle *)handle->pref_mac;
 		if (ref_handle) {
 			priv = woal_get_priv(ref_handle, MLAN_BSS_ROLE_ANY);
 			if (priv) {
-#ifdef DEBUG_LEVEL1
-				drvdbg &= ~MFW_D;
-#endif
+				handle->fw_dump_status = MTRUE;
 				woal_mlan_debug_info(priv);
 				woal_moal_debug_info(priv, NULL, MFALSE);
 			}
 		}
 		priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
 		if (priv) {
-			PRINTM(MERROR, "Recevie debug_dump command\n");
-#ifdef DEBUG_LEVEL1
-			drvdbg &= ~MFW_D;
-#endif
+			handle->fw_dump_status = MTRUE;
 			woal_mlan_debug_info(priv);
 			woal_moal_debug_info(priv, NULL, MFALSE);
 			handle->ops.dump_fw_info(handle);
@@ -480,7 +708,39 @@ static ssize_t woal_config_write(struct file *f, const char __user *buf,
 			config_data = FW_RELOAD_SDIO_INBAND_RESET;
 #endif
 		PRINTM(MMSG, "Request fw_reload=%d\n", config_data);
-		woal_request_fw_reload(handle, config_data);
+		ret = woal_request_fw_reload(handle, config_data);
+	}
+	if (!strncmp(databuf, "drop_point=", strlen("drop_point="))) {
+		line += strlen("drop_point") + 1;
+		config_data = (t_u32)woal_string_to_number(line);
+		if (config_data) {
+			handle->tp_acnt.on = 1;
+			handle->tp_acnt.drop_point = config_data;
+			if (handle->is_tp_acnt_timer_set == MFALSE) {
+				woal_initialize_timer(&handle->tp_acnt.timer,
+						      woal_tp_acnt_timer_func,
+						      handle);
+				handle->is_tp_acnt_timer_set = MTRUE;
+				woal_mod_timer(&handle->tp_acnt.timer, 1000);
+			}
+		} else {
+			if (handle->is_tp_acnt_timer_set) {
+				woal_cancel_timer(&handle->tp_acnt.timer);
+				handle->is_tp_acnt_timer_set = MFALSE;
+			}
+			memset((void *)&handle->tp_acnt, 0,
+			       sizeof(moal_tp_acnt_t));
+		}
+		priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+		if (priv)
+			woal_set_tp_state(priv);
+		PRINTM(MMSG, "on=%d drop_point=%d\n", handle->tp_acnt.on,
+		       handle->tp_acnt.drop_point);
+	}
+	if (!strncmp(databuf, "hssetpara=", strlen("hssetpara="))) {
+		line += strlen("hssetpara") + 1;
+		PRINTM(MCMND, "hssetpara=%s\n", line);
+		woal_process_proc_hssetpara(handle, line);
 	}
 	if (!strncmp(databuf, "rf_test_mode", strlen("rf_test_mode"))) {
 		line += strlen("rf_test_mode") + 1;
@@ -501,6 +761,11 @@ static ssize_t woal_config_write(struct file *f, const char __user *buf,
 		config_data = (t_u32)woal_string_to_number(line);
 		cmd = MFG_CMD_RX_ANT;
 	}
+	if (!strncmp(databuf, "radio_mode", strlen("radio_mode"))) {
+		line += strlen("radio_mode") + 1;
+		config_data = (t_u32)woal_string_to_number(line);
+		cmd = MFG_CMD_RADIO_MODE_CFG;
+	}
 	if (!strncmp(databuf, "channel", strlen("channel"))) {
 		line += strlen("channel") + 1;
 		config_data = (t_u32)woal_string_to_number(line);
@@ -527,7 +792,12 @@ static ssize_t woal_config_write(struct file *f, const char __user *buf,
 	if (!strncmp(databuf, "tx_continuous=", strlen("tx_continuous=")) &&
 	    count > strlen("tx_continuous="))
 		cmd = MFG_CMD_TX_CONT;
-
+	if (!strncmp(databuf, "he_tb_tx=", strlen("he_tb_tx=")) &&
+	    count > strlen("he_tb_tx="))
+		cmd = MFG_CMD_CONFIG_MAC_HE_TB_TX;
+	if (!strncmp(databuf, "trigger_frame=", strlen("trigger_frame=")) &&
+	    count > strlen("trigger_frame="))
+		cmd = MFG_CMD_CONFIG_TRIGGER_FRAME;
 	if (cmd && handle->rf_test_mode &&
 	    (woal_process_rf_test_mode_cmd(
 		     handle, cmd, (const char *)databuf, (size_t)count,
@@ -536,8 +806,18 @@ static ssize_t woal_config_write(struct file *f, const char __user *buf,
 	}
 	if (cmd && !handle->rf_test_mode)
 		PRINTM(MERROR, "RF test mode is disabled\n");
+
+	if (!strncmp(databuf, "antcfg", strlen("antcfg"))) {
+		line += strlen("antcfg") + 1;
+		if (woal_priv_set_tx_rx_ant(handle, line) !=
+		    MLAN_STATUS_SUCCESS)
+			PRINTM(MERROR, "Could not set Antenna Diversity!!\n");
+	}
+
 	MODULE_PUT;
 	LEAVE();
+	if (ret < 0)
+		return ret;
 	return (int)count;
 }
 
@@ -553,6 +833,8 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 {
 	moal_handle *handle = (moal_handle *)sfp->private;
 	int i;
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+	mlan_ds_hs_cfg hscfg;
 
 	ENTER();
 
@@ -564,6 +846,13 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 	seq_printf(sfp, "hardware_status=%d\n", (int)handle->hardware_status);
 	seq_printf(sfp, "netlink_num=%d\n", (int)handle->netlink_num);
 	seq_printf(sfp, "drv_mode=%d\n", (int)handle->params.drv_mode);
+	if (priv) {
+		memset(&hscfg, 0, sizeof(mlan_ds_hs_cfg));
+		(void)woal_set_get_hs_params(priv, MLAN_ACT_GET,
+					     MOAL_IOCTL_WAIT, &hscfg);
+		seq_printf(sfp, "hssetpara=%d,0x%x,%d,%d\n", hscfg.conditions,
+			   hscfg.gpio, hscfg.gap, hscfg.hs_wake_interval);
+	}
 #ifdef SDIO
 	if (IS_SD(handle->card_type)) {
 		seq_printf(sfp, "sdcmd52rw=%d 0x%0x 0x%02X\n",
@@ -582,6 +871,16 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 				   handle->rf_data->channel);
 		else
 			seq_printf(sfp, "channel=\n");
+		if (handle->rf_data->radio_mode[0])
+			seq_printf(sfp, "radio_mode[0]=%u\n",
+				   handle->rf_data->radio_mode[0]);
+		else
+			seq_printf(sfp, "radio_mode[0]=\n");
+		if (handle->rf_data->radio_mode[1])
+			seq_printf(sfp, "radio_mode[1]=%u\n",
+				   handle->rf_data->radio_mode[1]);
+		else
+			seq_printf(sfp, "radio_mode[1]=\n");
 		seq_printf(sfp, "total rx pkt count=%u\n",
 			   handle->rf_data->rx_tot_pkt_count);
 		seq_printf(sfp, "rx multicast/broadcast pkt count=%u\n",
@@ -619,6 +918,9 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 			for (i = 3; i < 13; i++)
 				seq_printf(sfp, " %u",
 					   handle->rf_data->tx_frame_data[i]);
+			for (i = 13; i < 20; i++)
+				seq_printf(sfp, " %d",
+					   handle->rf_data->tx_frame_data[i]);
 			seq_printf(sfp, " %02x:%02x:%02x:%02x:%02x:%02x",
 				   handle->rf_data->bssid[0],
 				   handle->rf_data->bssid[1],
@@ -628,7 +930,122 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 				   handle->rf_data->bssid[5]);
 		}
 		seq_printf(sfp, "\n");
+		seq_printf(sfp, "he_tb_tx=%u", handle->rf_data->he_tb_tx[0]);
+		if (handle->rf_data->he_tb_tx[0] == MTRUE) {
+			seq_printf(sfp, " %u", handle->rf_data->he_tb_tx[1]);
+			seq_printf(sfp, " %u", handle->rf_data->he_tb_tx[2]);
+			seq_printf(sfp, " %u", handle->rf_data->he_tb_tx[3]);
+			seq_printf(sfp, " %d",
+				   handle->rf_data->he_tb_tx_power[0]);
+		}
+		seq_printf(sfp, "\n");
+		seq_printf(sfp, "trigger_frame=%u",
+			   handle->rf_data->mfg_tx_trigger_config.enable_tx);
+		if (handle->rf_data->mfg_tx_trigger_config.enable_tx == MTRUE) {
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .standalone_hetb);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config.frmCtl
+					   .type);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config.frmCtl
+					   .sub_type);
+			seq_printf(
+				sfp, " %u",
+				handle->rf_data->mfg_tx_trigger_config.duration);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.trigger_type);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ul_len);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.more_tf);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.cs_required);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ul_bw);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ltf_type);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ltf_mode);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ltf_symbol);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ul_stbc);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ldpc_ess);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.ap_tx_pwr);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.pre_fec_pad_fct);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.pe_disambig);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.spatial_reuse);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.doppler);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_common_field.he_sig2);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.aid12);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.ru_alloc_reg);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.ru_alloc);
+			seq_printf(
+				sfp, " %u",
+				handle->rf_data->mfg_tx_trigger_config
+					.trig_user_info_field.ul_coding_type);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.ul_mcs);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.ul_dcm);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .trig_user_info_field.ss_alloc);
+			seq_printf(
+				sfp, " %u",
+				handle->rf_data->mfg_tx_trigger_config
+					.trig_user_info_field.ul_target_rssi);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .basic_trig_user_info.mpdu_mu_sf);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .basic_trig_user_info.tid_al);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .basic_trig_user_info.ac_pl);
+			seq_printf(sfp, " %u",
+				   handle->rf_data->mfg_tx_trigger_config
+					   .basic_trig_user_info.pref_ac);
+		}
+		seq_printf(sfp, "\n");
 	}
+	// Read current antcfg configuration
+	woal_priv_get_tx_rx_ant(sfp, priv);
+
 	MODULE_PUT;
 	LEAVE();
 	return 0;
@@ -636,7 +1053,9 @@ static int woal_config_read(struct seq_file *sfp, void *data)
 
 static int woal_config_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_config_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_config_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_config_read, PDE(inode)->data);
@@ -662,6 +1081,160 @@ static const struct file_operations config_proc_fops = {
 };
 #endif
 
+static int woal_drv_dump_read(struct seq_file *sfp, void *data)
+{
+	moal_handle *handle = (moal_handle *)sfp->private;
+	int ret = 0;
+
+	ENTER();
+
+	if (MODULE_GET == 0) {
+		LEAVE();
+		return 0;
+	}
+
+	if (!handle) {
+		PRINTM(MERROR, "handle is NULL!\n");
+		LEAVE();
+		return 0;
+	}
+	if (!handle->drv_dump_buf || !handle->drv_dump_len)
+		handle->drv_dump_buf =
+			woal_dump_drv_info(handle, &handle->drv_dump_len);
+	if (!handle->drv_dump_buf || !handle->drv_dump_len) {
+		PRINTM(MERROR,
+		       "driver dump buffer is NULL or total length is zero\n");
+		goto done;
+	}
+	if (sfp->size < handle->drv_dump_len) {
+		PRINTM(MERROR,
+		       "drv dump size too big, size=%d, drv_dump_len=%d\n",
+		       (int)sfp->size, handle->drv_dump_len);
+		sfp->count = sfp->size;
+		ret = 0;
+		MODULE_PUT;
+		return ret;
+	}
+	memset(sfp->buf, 0x00, sfp->size);
+	sfp->count = handle->drv_dump_len;
+	moal_memcpy_ext(handle, sfp->buf, handle->drv_dump_buf,
+			handle->drv_dump_len, sfp->size);
+done:
+	moal_vfree(handle, handle->drv_dump_buf);
+	handle->drv_dump_len = 0;
+	handle->drv_dump_buf = NULL;
+	MODULE_PUT;
+	LEAVE();
+	return 0;
+}
+
+static int woal_drv_dump_proc_open(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_drv_dump_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	return single_open(file, woal_drv_dump_read, PDE_DATA(inode));
+#else
+	return single_open(file, woal_drv_dump_read, PDE(inode)->data);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static const struct proc_ops drv_dump_fops = {
+	.proc_open = woal_drv_dump_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+#else
+static const struct file_operations drv_dump_fops = {
+	.owner = THIS_MODULE,
+	.open = woal_drv_dump_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
+static int woal_fw_dump_read(struct seq_file *sfp, void *data)
+{
+	moal_handle *handle = (moal_handle *)sfp->private;
+	int ret = 0;
+
+	ENTER();
+
+	if (MODULE_GET == 0) {
+		LEAVE();
+		return 0;
+	}
+
+	if (!handle) {
+		PRINTM(MERROR, "handle is null!\n");
+		goto done;
+	}
+
+	if (handle->fw_dump == MTRUE) {
+		PRINTM(MERROR, "fw dump is in progress\n");
+		goto done;
+	}
+
+	if (!handle->fw_dump_buf || !handle->fw_dump_len) {
+		PRINTM(MERROR,
+		       "fw dump buffer is NULL or total length is zero\n");
+		goto done;
+	}
+
+	if (sfp->size < handle->fw_dump_len) {
+		PRINTM(MERROR,
+		       "fw dump size too big, size=%d, fw_dump_len=%ld\n",
+		       (int)sfp->size, (long int)handle->fw_dump_len);
+		sfp->count = sfp->size;
+		ret = 0;
+		MODULE_PUT;
+		return ret;
+	}
+
+	sfp->count = handle->fw_dump_len;
+	moal_memcpy_ext(handle, sfp->buf, handle->fw_dump_buf,
+			handle->fw_dump_len, sfp->size);
+	moal_vfree(handle, handle->fw_dump_buf);
+	handle->fw_dump_buf = NULL;
+	handle->fw_dump_len = 0;
+
+done:
+	MODULE_PUT;
+	LEAVE();
+	return 0;
+}
+
+static int woal_fw_dump_proc_open(struct inode *inode, struct file *file)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_fw_dump_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+	return single_open(file, woal_fw_dump_read, PDE_DATA(inode));
+#else
+	return single_open(file, woal_fw_dump_read, PDE(inode)->data);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+static const struct proc_ops fw_dump_fops = {
+	.proc_open = woal_fw_dump_proc_open,
+	.proc_read = seq_read,
+	.proc_lseek = seq_lseek,
+	.proc_release = single_release,
+};
+#else
+static const struct file_operations fw_dump_fops = {
+	.owner = THIS_MODULE,
+	.open = woal_fw_dump_proc_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+#endif
+
 /**
  *  @brief wifi status proc read function
  *
@@ -688,7 +1261,9 @@ static int woal_wifi_status_read(struct seq_file *sfp, void *data)
 
 static int woal_wifi_status_proc_open(struct inode *inode, struct file *file)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	return single_open(file, woal_wifi_status_read, pde_data(inode));
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 	return single_open(file, woal_wifi_status_read, PDE_DATA(inode));
 #else
 	return single_open(file, woal_wifi_status_read, PDE(inode)->data);
@@ -738,7 +1313,7 @@ int woal_string_to_number(char *s)
 	} else
 		base = 10;
 
-	for (s = s; *s; s++) {
+	for (; *s; s++) {
 		if ((*s >= '0') && (*s <= '9'))
 			r = (r * base) + (*s - '0');
 		else if ((*s >= 'A') && (*s <= 'F'))
@@ -773,7 +1348,7 @@ mlan_status woal_root_proc_init(void)
 	}
 
 	/* create /proc/mwlan/wifi_status */
-	proc_create_data(STATUS_PROC, 0644, proc_mwlan, &wifi_status_proc_fops,
+	proc_create_data(STATUS_PROC, 0666, proc_mwlan, &wifi_status_proc_fops,
 			 NULL);
 
 	LEAVE();
@@ -812,6 +1387,8 @@ void woal_proc_init(moal_handle *handle)
 	struct proc_dir_entry *pde = proc_mwlan;
 #endif
 	char config_proc_dir[20];
+	char drv_dump_dir[20];
+	char fw_dump_dir[20];
 
 	ENTER();
 
@@ -853,9 +1430,9 @@ void woal_proc_init(moal_handle *handle)
 		goto done;
 	}
 
-	strcpy(config_proc_dir, "config");
+	strncpy(config_proc_dir, "config", sizeof(config_proc_dir));
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
-	r = proc_create_data(config_proc_dir, 0644, handle->proc_wlan,
+	r = proc_create_data(config_proc_dir, 0666, handle->proc_wlan,
 			     &config_proc_fops, handle);
 #else
 	r = create_proc_entry(config_proc_dir, 0644, handle->proc_wlan);
@@ -867,6 +1444,34 @@ void woal_proc_init(moal_handle *handle)
 	if (!r)
 		PRINTM(MERROR, "Fail to create proc config\n");
 
+	strncpy(drv_dump_dir, "drv_dump", sizeof(drv_dump_dir));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	r = proc_create_data(drv_dump_dir, 0644, handle->proc_wlan,
+			     &drv_dump_fops, handle);
+#else
+	r = create_proc_entry(drv_dump_dir, 0644, handle->proc_wlan);
+	if (r) {
+		r->data = handle;
+		r->proc_fops = &drv_dump_fops;
+	}
+#endif
+	if (!r)
+		PRINTM(MERROR, "Failed to create proc drv dump\n");
+
+	strncpy(fw_dump_dir, "fw_dump", sizeof(fw_dump_dir));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+	r = proc_create_data(fw_dump_dir, 0644, handle->proc_wlan,
+			     &fw_dump_fops, handle);
+#else
+	r = create_proc_entry(fw_dump_dir, 0644, handle->proc_wlan);
+	if (r) {
+		r->data = handle;
+		r->proc_fops = &fw_dump_fops;
+	}
+#endif
+	if (!r)
+		PRINTM(MERROR, "Failed to create proc fw dump\n");
+
 done:
 	LEAVE();
 }
@@ -881,13 +1486,19 @@ void woal_proc_init(moal_handle *handle)
 void woal_proc_exit(moal_handle *handle)
 {
 	char config_proc_dir[20];
+	char drv_dump_dir[20];
+	char fw_dump_dir[20];
 
 	ENTER();
 
 	PRINTM(MINFO, "Remove Proc Interface %s\n", handle->proc_wlan_name);
 	if (handle->proc_wlan) {
-		strcpy(config_proc_dir, "config");
+		strncpy(config_proc_dir, "config", sizeof(config_proc_dir));
 		remove_proc_entry(config_proc_dir, handle->proc_wlan);
+		strncpy(drv_dump_dir, "drv_dump", sizeof(drv_dump_dir));
+		remove_proc_entry(drv_dump_dir, handle->proc_wlan);
+		strncpy(fw_dump_dir, "fw_dump", sizeof(fw_dump_dir));
+		remove_proc_entry(fw_dump_dir, handle->proc_wlan);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 		/* Remove only if we are the only instance using this */
@@ -905,6 +1516,16 @@ void woal_proc_exit(moal_handle *handle)
 		}
 #endif
 	}
+	if (handle->fw_dump_buf) {
+		moal_vfree(handle, handle->fw_dump_buf);
+		handle->fw_dump_buf = NULL;
+		handle->fw_dump_len = 0;
+	}
+	if (handle->drv_dump_buf) {
+		moal_vfree(handle, handle->drv_dump_buf);
+		handle->drv_dump_len = 0;
+		handle->drv_dump_buf = NULL;
+	}
 	LEAVE();
 }
 
@@ -928,8 +1549,8 @@ void woal_create_proc_entry(moal_private *priv)
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 	if (!priv->proc_entry) {
 		memset(proc_dir_name, 0, sizeof(proc_dir_name));
-		strncpy(proc_dir_name, priv->phandle->proc_wlan_name,
-			sizeof(proc_dir_name) - 2);
+		memcpy(proc_dir_name, priv->phandle->proc_wlan_name,
+		       sizeof(proc_dir_name) - 2);
 		proc_dir_name[strlen(proc_dir_name)] = '/';
 
 		if (strlen(dev->name) >
@@ -939,7 +1560,7 @@ void woal_create_proc_entry(moal_private *priv)
 			LEAVE();
 			return;
 		}
-		strcat(proc_dir_name, dev->name);
+		strncat(proc_dir_name, dev->name, sizeof(proc_dir_name) - 1);
 		/* Try to create adapterX/dev_name directory first under
 		 * /proc/mwlan/ */
 		priv->proc_entry = proc_mkdir(proc_dir_name, proc_mwlan);
@@ -978,7 +1599,7 @@ void woal_create_proc_entry(moal_private *priv)
 		atomic_inc(&(priv->phandle->proc_wlan->count));
 #endif /* < 3.10.0 */
 #endif /* < 2.6.26 */
-		strcpy(priv->proc_entry_name, dev->name);
+		strncpy(priv->proc_entry_name, dev->name, IFNAMSIZ);
 		if (priv->proc_entry) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
 			r = proc_create_data("info", 0, priv->proc_entry,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio.h
old mode 100644
new mode 100755
index 1453dbb6e..550d56bee
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio.h
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -73,6 +73,10 @@ Change log:
 #define SD8887_WLAN_A0_FW_NAME "nxp/sd8887_wlan.bin"
 #endif /* SD8887_MULTI_FW */
 
+#ifdef SD8801
+#define SD8801_DEFAULT_WLAN_FW_NAME "nxp/sd8801_uapsta.bin"
+#endif /* SD8801 */
+
 /** Default firmware name */
 #ifdef SD8887
 #define SD8887_DEFAULT_COMBO_FW_NAME "nxp/sd8887_uapsta_a2.bin"
@@ -104,10 +108,10 @@ Change log:
 #endif /* SD8897 */
 
 #ifdef SD8978
-#define SD8978_DEFAULT_COMBO_FW_NAME "nxp/sdsd8978_combo.bin"
-#define SDUART8978_DEFAULT_COMBO_FW_NAME "nxp/sduart8978_combo.bin"
-#define SDSD8978_DEFAULT_COMBO_FW_NAME "nxp/sdsd8978_combo.bin"
-#define SD8978_DEFAULT_WLAN_FW_NAME "nxp/sd8978_wlan.bin"
+#define SD8978_DEFAULT_COMBO_FW_NAME "nxp/sdsdiw416_combo.bin"
+#define SDUART8978_DEFAULT_COMBO_FW_NAME "nxp/sduartiw416_combo.bin"
+#define SDSD8978_DEFAULT_COMBO_FW_NAME "nxp/sdsdiw416_combo.bin"
+#define SD8978_DEFAULT_WLAN_FW_NAME "nxp/sdiw416_wlan.bin"
 #endif /* SD8978 */
 
 #ifdef SD9098
@@ -127,14 +131,42 @@ Change log:
 #ifdef SD9097
 #define SD9097_B0 0x01
 #define SD9097_B1 0x02
-#define SD9097_DEFAULT_COMBO_FW_NAME "nxp/sdsd9097_combo_v1.bin"
+#define SD9097_DEFAULT_COMBO_FW_NAME "nxp/sdsdiw620_combo_v1.bin"
 
-#define SD9097_DEFAULT_WLAN_FW_NAME "nxp/sd9097_wlan_v1.bin"
-#define SDUART9097_COMBO_V1_FW_NAME "nxp/sduart9097_combo_v1.bin"
-#define SDSD9097_COMBO_V1_FW_NAME "nxp/sdsd9097_combo_v1.bin"
-#define SD9097_WLAN_V1_FW_NAME "nxp/sd9097_wlan_v1.bin"
+#define SD9097_DEFAULT_WLAN_FW_NAME "nxp/sdiw620_wlan_v1.bin"
+#define SDUART9097_COMBO_V1_FW_NAME "nxp/sduartiw620_combo_v1.bin"
+#define SDSD9097_COMBO_V1_FW_NAME "nxp/sdsdiw620_combo_v1.bin"
+#define SD9097_WLAN_V1_FW_NAME "nxp/sdiw620_wlan_v1.bin"
 #endif /* SD9097 */
 
+#ifdef SDIW62X
+#define SDIW62X_DEFAULT_COMBO_FW_NAME "nxp/sdsd_iw62x.bin"
+#define SDUARTIW62X_COMBO_FW_NAME "nxp/sduart_iw62x.bin"
+#define SDSDIW62X_COMBO_FW_NAME "sdsd_iw62x.bin"
+#define SDIW62X_DEFAULT_WLAN_FW_NAME "nxp/sd_iw62x.bin"
+#endif /* SDIW62X */
+
+#define SDAW693_DEFAULT_COMBO_FW_NAME "nxp/sdsd_aw693.bin"
+#define SDUARTAW693_COMBO_FW_NAME "nxp/sduart_aw693.bin"
+#define SDSDAW693_COMBO_FW_NAME "sdsd_aw693.bin"
+#define SDAW693_DEFAULT_WLAN_FW_NAME "nxp/sd_aw693.bin"
+
+#ifdef SD9177
+#define SD9177_A0 0x00
+#define SD9177_A1 0x01
+#define SD9177_DEFAULT_COMBO_FW_NAME "nxp/sdsd_nw61x.bin"
+#define SD9177_DEFAULT_COMBO_V1_FW_NAME "nxp/sduart_nw61x_v1.bin"
+#define SDUART9177_DEFAULT_COMBO_FW_NAME "nxp/sduart_nw61x.bin"
+#define SDSD9177_DEFAULT_COMBO_FW_NAME "nxp/sdsd_nw61x.bin"
+#define SD9177_DEFAULT_WLAN_FW_NAME "nxp/sd_w61x.bin"
+#define SDUART9177_DEFAULT_COMBO_V1_FW_NAME "nxp/sduart_nw61x_v1.bin"
+#define SDSD9177_DEFAULT_COMBO_V1_FW_NAME "nxp/sdsd_nw61x_v1.bin"
+#define SD9177_DEFAULT_WLAN_V1_FW_NAME "nxp/sd_w61x_v1.bin"
+#define SDUART9177_DEFAULT_RFTM_COMBO_V1_FW_NAME "nxp/sduart_nw61x_rftm_v1.bin"
+#define SDSD9177_DEFAULT_RFTM_COMBO_V1_FW_NAME "nxp/sdsd_nw61x_rftm_v1.bin"
+#define SD9177_DEFAULT_RFTM_WLAN_V1_FW_NAME "nxp/sd_w61x_rftm_v1.bin"
+#endif /* SD9177 */
+
 /********************************************************
 		Global Functions
 ********************************************************/
@@ -167,6 +199,7 @@ struct sdio_mmc_card {
 	/** saved host clock value */
 	unsigned int host_clock;
 };
+void woal_sdio_reset_hw(moal_handle *handle);
 #endif /* SDIO_MMC */
 
 /** cmd52 read write */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio_mmc.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio_mmc.c
old mode 100644
new mode 100755
index 4312b452f..9bd634e86
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio_mmc.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sdio_mmc.c
@@ -4,7 +4,7 @@
  *  related functions.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -31,7 +31,8 @@ Change log:
 #include "moal_sdio.h"
 
 /** define nxp vendor id */
-#define NXP_VENDOR_ID 0x02df
+#define NXP_VENDOR_ID 0x0471
+#define MRVL_VENDOR_ID 0x02df
 
 /********************************************************
 		Local Variables
@@ -46,6 +47,10 @@ static moal_if_ops sdiommc_ops;
 /** Device ID for SD8887 */
 #define SD_DEVICE_ID_8887 (0x9135)
 #endif
+#ifdef SD8801
+/** Device ID for SD8801 FN1 */
+#define SD_DEVICE_ID_8801 (0x9139)
+#endif
 #ifdef SD8897
 /** Device ID for SD8897 */
 #define SD_DEVICE_ID_8897 (0x912d)
@@ -66,6 +71,10 @@ static moal_if_ops sdiommc_ops;
 /** Device ID for SD8987 */
 #define SD_DEVICE_ID_8987 (0x9149)
 #endif
+/** Device ID for SDAW693 */
+#define SD_DEVICE_ID_AW693_FN1 (0x0211)
+/** Device ID for SDAW693 */
+#define SD_DEVICE_ID_AW693_FN2 (0x0212)
 #ifdef SD9098
 /** Device ID for SD9098 */
 #define SD_DEVICE_ID_9098_FN1 (0x914D)
@@ -76,37 +85,52 @@ static moal_if_ops sdiommc_ops;
 /** Device ID for SD9097 */
 #define SD_DEVICE_ID_9097 (0x9155)
 #endif
-/** Device ID any */
-#ifndef SD_DEVICE_ANY
-#define SD_DEVICE_ANY (0xffff)
-#endif /* SD_DEVICE_ANY */
+#ifdef SD9177
+/** Device ID for SD9177 */
+#define SD_DEVICE_ID_9177 (0x0205)
+#endif
+#ifdef SDIW62X
+/** Device ID for SDIW62X */
+#define SD_DEVICE_ID_IW62X (0x020D)
+#endif
 
 /** WLAN IDs */
 static const struct sdio_device_id wlan_ids[] = {
 #ifdef SD8887
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8887)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8887)},
+#endif
+#ifdef SD8801
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8801)},
 #endif
 #ifdef SD8897
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8897)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8897)},
 #endif
 #ifdef SD8977
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8977)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8977)},
 #endif
 #ifdef SD8978
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8978)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8978)},
 #endif
 #ifdef SD8997
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8997)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8997)},
 #endif
 #ifdef SD8987
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_8987)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_8987)},
 #endif
+	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_AW693_FN1)},
+	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_AW693_FN2)},
 #ifdef SD9098
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_9098_FN1)},
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_9098_FN2)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_9098_FN1)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_9098_FN2)},
 #endif
 #ifdef SD9097
-	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_9097)},
+	{SDIO_DEVICE(MRVL_VENDOR_ID, SD_DEVICE_ID_9097)},
+#endif
+#ifdef SD9177
+	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_9177)},
+#endif
+#ifdef SDIW62X
+	{SDIO_DEVICE(NXP_VENDOR_ID, SD_DEVICE_ID_IW62X)},
 #endif
 	{},
 };
@@ -165,13 +189,13 @@ static struct sdio_driver REFDATA wlan_sdio = {
 		Local Functions
 ********************************************************/
 static void woal_sdiommc_dump_fw_info(moal_handle *phandle);
-
+#if 0
 /**  @brief This function dump the sdio register
  *
  *  @param handle   A Pointer to the moal_handle structure
  *  @return         N/A
  */
-void woal_dump_sdio_reg(moal_handle *handle)
+static void woal_dump_sdio_reg(moal_handle *handle)
 {
 	int ret = 0;
 	t_u8 data, i;
@@ -210,6 +234,7 @@ void woal_dump_sdio_reg(moal_handle *handle)
 	}
 	return;
 }
+#endif
 /********************************************************
 		Global Functions
 ********************************************************/
@@ -286,6 +311,21 @@ static t_u16 woal_update_card_type(t_void *card)
 				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
 	}
 #endif
+#ifdef SD8801
+	if (cardp_sd->func->device == SD_DEVICE_ID_8801) {
+		card_type = CARD_TYPE_SD8801;
+		moal_memcpy_ext(NULL, driver_version, CARD_SD8801,
+				strlen(CARD_SD8801), strlen(driver_version));
+		moal_memcpy_ext(
+			NULL,
+			driver_version + strlen(INTF_CARDTYPE) +
+				strlen(KERN_VERSION),
+			V14, strlen(V14),
+			strlen(driver_version) -
+				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
+	}
+#endif
+
 #ifdef SD8897
 	if (cardp_sd->func->device == SD_DEVICE_ID_8897) {
 		card_type = CARD_TYPE_SD8897;
@@ -317,8 +357,8 @@ static t_u16 woal_update_card_type(t_void *card)
 #ifdef SD8978
 	if (cardp_sd->func->device == SD_DEVICE_ID_8978) {
 		card_type = CARD_TYPE_SD8978;
-		moal_memcpy_ext(NULL, driver_version, CARD_SD8978,
-				strlen(CARD_SD8978), strlen(driver_version));
+		moal_memcpy_ext(NULL, driver_version, "SDIW416",
+				strlen("SDIW416"), strlen(driver_version));
 		moal_memcpy_ext(
 			NULL,
 			driver_version + strlen(INTF_CARDTYPE) +
@@ -356,6 +396,33 @@ static t_u16 woal_update_card_type(t_void *card)
 				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
 	}
 #endif
+#ifdef SDIW62X
+	if (cardp_sd->func->device == SD_DEVICE_ID_IW62X) {
+		card_type = CARD_TYPE_SDIW62X;
+		moal_memcpy_ext(NULL, driver_version, CARD_SDIW62X,
+				strlen(CARD_SDIW62X), strlen(driver_version));
+		moal_memcpy_ext(
+			NULL,
+			driver_version + strlen(INTF_CARDTYPE) +
+				strlen(KERN_VERSION),
+			V18, strlen(V18),
+			strlen(driver_version) -
+				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
+	}
+#endif
+	if (cardp_sd->func->device == SD_DEVICE_ID_AW693_FN1 ||
+	    cardp_sd->func->device == SD_DEVICE_ID_AW693_FN2) {
+		card_type = CARD_TYPE_SDAW693;
+		moal_memcpy_ext(NULL, driver_version, CARD_SDAW693,
+				strlen(CARD_SDAW693), strlen(driver_version));
+		moal_memcpy_ext(
+			NULL,
+			driver_version + strlen(INTF_CARDTYPE) +
+				strlen(KERN_VERSION),
+			V17, strlen(V17),
+			strlen(driver_version) -
+				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
+	}
 #ifdef SD9097
 	if (cardp_sd->func->device == SD_DEVICE_ID_9097) {
 		card_type = CARD_TYPE_SD9097;
@@ -384,6 +451,20 @@ static t_u16 woal_update_card_type(t_void *card)
 			strlen(driver_version) -
 				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
 	}
+#endif
+#ifdef SD9177
+	if (cardp_sd->func->device == SD_DEVICE_ID_9177) {
+		card_type = CARD_TYPE_SD9177;
+		moal_memcpy_ext(NULL, driver_version, CARD_SD9177,
+				strlen(CARD_SD9177), strlen(driver_version));
+		moal_memcpy_ext(
+			NULL,
+			driver_version + strlen(INTF_CARDTYPE) +
+				strlen(KERN_VERSION),
+			V18, strlen(V18),
+			strlen(driver_version) -
+				(strlen(INTF_CARDTYPE) + strlen(KERN_VERSION)));
+	}
 #endif
 	return card_type;
 }
@@ -450,11 +531,15 @@ int woal_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)
 
 	if (NULL ==
 	    woal_add_card(card, &card->func->dev, &sdiommc_ops, card_type)) {
-		PRINTM(MERROR, "woal_add_card failed\n");
+		PRINTM(MMSG, "woal_add_card failed\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto err;
 	}
 
+#ifdef IMX_SUPPORT
+	woal_regist_oob_wakeup_irq(card->handle);
+#endif /* IMX_SUPPORT */
+
 	LEAVE();
 	return ret;
 err:
@@ -482,6 +567,9 @@ void woal_sdio_remove(struct sdio_func *func)
 		PRINTM(MINFO, "SDIO func=%d\n", func->num);
 		card = sdio_get_drvdata(func);
 		if (card) {
+#ifdef IMX_SUPPORT
+			woal_unregist_oob_wakeup_irq(card->handle);
+#endif /* IMX_SUPPORT */
 			woal_remove_card(card);
 			kfree(card);
 		}
@@ -510,10 +598,6 @@ void woal_wlan_is_suspended(moal_handle *handle)
 }
 #endif
 
-#define SHUTDOWN_HOST_SLEEP_DEF_GAP 100
-#define SHUTDOWN_HOST_SLEEP_DEF_GPIO 0x3
-#define SHUTDOWN_HOST_SLEEP_DEF_COND 0x0
-
 /**  @brief This function handles client driver shutdown
  *
  *  @param dev      A pointer to device structure
@@ -525,7 +609,6 @@ void woal_sdio_shutdown(struct device *dev)
 	moal_handle *handle = NULL;
 	struct sdio_mmc_card *cardp;
 	mlan_ds_ps_info pm_info;
-	int timeout = 0;
 	int i, retry_num = 8;
 
 	ENTER();
@@ -562,7 +645,7 @@ void woal_sdio_shutdown(struct device *dev)
 		}
 		woal_enable_hs(woal_get_priv(handle, MLAN_BSS_ROLE_ANY));
 
-		timeout = wait_event_interruptible_timeout(
+		wait_event_interruptible_timeout(
 			handle->hs_activate_wait_q,
 			handle->hs_activate_wait_q_woken, HS_ACTIVE_TIMEOUT);
 		if (handle->hs_activated == MTRUE)
@@ -683,6 +766,15 @@ int woal_sdio_suspend(struct device *dev)
 		handle->suspend_notify_req = MFALSE;
 #endif
 		if (hs_actived) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 3, 4)
+			if (pm_flags & MMC_PM_WAKE_SDIO_IRQ) {
+				ret = sdio_set_host_pm_flags(
+					func, MMC_PM_WAKE_SDIO_IRQ);
+				PRINTM(MCMND,
+				       "suspend with MMC_PM_WAKE_SDIO_IRQ ret=%d\n",
+				       ret);
+			}
+#endif
 #ifdef MMC_PM_SKIP_RESUME_PROBE
 			PRINTM(MCMND,
 			       "suspend with MMC_PM_KEEP_POWER and MMC_PM_SKIP_RESUME_PROBE\n");
@@ -705,6 +797,9 @@ int woal_sdio_suspend(struct device *dev)
 
 	/* Indicate device suspended */
 	handle->is_suspended = MTRUE;
+#ifdef IMX_SUPPORT
+	woal_enable_oob_wakeup_irq(handle);
+#endif /* IMX_SUPPORT */
 done:
 	PRINTM(MCMND, "<--- Leave woal_sdio_suspend --->\n");
 	LEAVE();
@@ -753,6 +848,9 @@ int woal_sdio_resume(struct device *dev)
 
 	/* Disable Host Sleep */
 	woal_cancel_hs(woal_get_priv(handle, MLAN_BSS_ROLE_ANY), MOAL_NO_WAIT);
+#ifdef IMX_SUPPORT
+	woal_disable_oob_wakeup_irq(handle);
+#endif /* IMX_SUPPORT */
 	PRINTM(MCMND, "<--- Leave woal_sdio_resume --->\n");
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -812,7 +910,7 @@ static mlan_status woal_sdiommc_read_reg(moal_handle *handle, t_u32 reg,
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_sdio_writeb(moal_handle *handle, t_u32 reg, t_u8 data)
+static mlan_status woal_sdio_writeb(moal_handle *handle, t_u32 reg, t_u8 data)
 {
 	mlan_status ret = MLAN_STATUS_FAILURE;
 	sdio_claim_host(((struct sdio_mmc_card *)handle->card)->func);
@@ -831,7 +929,7 @@ mlan_status woal_sdio_writeb(moal_handle *handle, t_u32 reg, t_u8 data)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_sdio_readb(moal_handle *handle, t_u32 reg, t_u8 *data)
+static mlan_status woal_sdio_readb(moal_handle *handle, t_u32 reg, t_u8 *data)
 {
 	mlan_status ret = MLAN_STATUS_FAILURE;
 	t_u8 val;
@@ -853,7 +951,8 @@ mlan_status woal_sdio_readb(moal_handle *handle, t_u32 reg, t_u8 *data)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_sdio_f0_readb(moal_handle *handle, t_u32 reg, t_u8 *data)
+static mlan_status woal_sdio_f0_readb(moal_handle *handle, t_u32 reg,
+				      t_u8 *data)
 {
 	mlan_status ret = MLAN_STATUS_FAILURE;
 	t_u8 val;
@@ -876,8 +975,8 @@ mlan_status woal_sdio_f0_readb(moal_handle *handle, t_u32 reg, t_u8 *data)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_sdio_rw_mb(moal_handle *handle, pmlan_buffer pmbuf_list,
-			    t_u32 port, t_u8 write)
+static mlan_status woal_sdio_rw_mb(moal_handle *handle, pmlan_buffer pmbuf_list,
+				   t_u32 port, t_u8 write)
 {
 	struct scatterlist sg_list[SDIO_MP_AGGR_DEF_PKT_LIMIT_MAX];
 	int num_sg = pmbuf_list->use_count;
@@ -1096,10 +1195,21 @@ static void woal_sdiommc_unregister_dev(moal_handle *handle)
 	ENTER();
 	if (handle->card) {
 		struct sdio_mmc_card *card = handle->card;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+		struct sdio_func *func = card->func;
+#endif
 		/* Release the SDIO IRQ */
 		sdio_claim_host(card->func);
 		sdio_release_irq(card->func);
 		sdio_disable_func(card->func);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+		if (handle->driver_status)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+			mmc_hw_reset(func->card);
+#else
+			mmc_hw_reset(func->card->host);
+#endif
+#endif
 		sdio_release_host(card->func);
 
 		sdio_set_drvdata(card->func, NULL);
@@ -1255,8 +1365,11 @@ int woal_sdio_read_write_cmd52(moal_handle *handle, int func, int reg, int val)
  */
 static t_u8 woal_sdiommc_is_second_mac(moal_handle *handle)
 {
-#ifdef SD9098
 	struct sdio_mmc_card *card = (struct sdio_mmc_card *)handle->card;
+
+	if (card->func->device == SD_DEVICE_ID_AW693_FN2)
+		return MTRUE;
+#ifdef SD9098
 	if (card->func->device == SD_DEVICE_ID_9098_FN2)
 		return MTRUE;
 #endif
@@ -1272,24 +1385,23 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 	t_u32 revision_id = 0;
 	t_u32 rev_id_reg = handle->card_info->rev_id_reg;
 
-#if defined(SD8987) || defined(SD8997) || defined(SD9098) ||                   \
-	defined(SD9097) || defined(SD8978)
 	t_u32 magic_reg = handle->card_info->magic_reg;
 	t_u32 magic = 0;
 	t_u32 host_strap_reg = handle->card_info->host_strap_reg;
 	t_u32 strap = 0;
-#endif
 
 	ENTER();
 
 	if (handle->params.fw_name)
 		goto done;
+#ifdef SD8801
+	if (IS_SD8801(handle->card_type))
+		goto done;
+#endif
 	/** Revision ID register */
 	woal_sdiommc_read_reg(handle, rev_id_reg, &revision_id);
 	PRINTM(MCMND, "revision_id=0x%x\n", revision_id);
 
-#if defined(SD8987) || defined(SD8997) || defined(SD9098) ||                   \
-	defined(SD9097) || defined(SD8978)
 	/** Revision ID register */
 	woal_sdiommc_read_reg(handle, magic_reg, &magic);
 	/** Revision ID register */
@@ -1298,24 +1410,26 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 	magic &= 0xFF;
 	/* 1 = SDSD, 0 --SD UART */
 	PRINTM(MCMND, "magic=0x%x strap=0x%x\n", magic, strap);
-#endif
 #if defined(SD8977)
 	if (IS_SD8977(handle->card_type)) {
 		switch (revision_id) {
 		case SD8977_V0:
-			strcpy(handle->card_info->fw_name, SD8977_V0_FW_NAME);
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD8977_WLAN_V0_FW_NAME);
+			strncpy(handle->card_info->fw_name, SD8977_V0_FW_NAME,
+				FW_NAMW_MAX_LEN);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD8977_WLAN_V0_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		case SD8977_V1:
-			strcpy(handle->card_info->fw_name, SD8977_V1_FW_NAME);
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD8977_WLAN_V1_FW_NAME);
+			strncpy(handle->card_info->fw_name, SD8977_V1_FW_NAME,
+				FW_NAMW_MAX_LEN);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD8977_WLAN_V1_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		case SD8977_V2:
-			strcpy(handle->card_info->fw_name, SD8977_V2_FW_NAME);
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD8977_WLAN_V2_FW_NAME);
+			strncpy(handle->card_info->fw_name, SD8977_V2_FW_NAME,
+				FW_NAMW_MAX_LEN);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD8977_WLAN_V2_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		default:
 			break;
@@ -1327,14 +1441,16 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 		/* Check revision ID */
 		switch (revision_id) {
 		case SD8887_A0:
-			strcpy(handle->card_info->fw_name, SD8887_A0_FW_NAME);
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD8887_WLAN_A0_FW_NAME);
+			strncpy(handle->card_info->fw_name, SD8887_A0_FW_NAME,
+				FW_NAMW_MAX_LEN);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD8887_WLAN_A0_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		case SD8887_A2:
-			strcpy(handle->card_info->fw_name, SD8887_A2_FW_NAME);
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD8887_WLAN_A2_FW_NAME);
+			strncpy(handle->card_info->fw_name, SD8887_A2_FW_NAME,
+				FW_NAMW_MAX_LEN);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD8887_WLAN_A2_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		default:
 			break;
@@ -1346,11 +1462,13 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 	if (IS_SD8997(handle->card_type)) {
 		if (magic == CHIP_MAGIC_VALUE) {
 			if (strap == CARD_TYPE_SD_UART)
-				strcpy(handle->card_info->fw_name,
-				       SDUART8997_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDUART8997_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 			else
-				strcpy(handle->card_info->fw_name,
-				       SDSD8997_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDSD8997_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 		}
 	}
 #endif
@@ -1359,11 +1477,13 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 	if (IS_SD8987(handle->card_type)) {
 		if (magic == CHIP_MAGIC_VALUE) {
 			if (strap == CARD_TYPE_SD_UART)
-				strcpy(handle->card_info->fw_name,
-				       SDUART8987_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDUART8987_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 			else
-				strcpy(handle->card_info->fw_name,
-				       SDSD8987_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDSD8987_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 		}
 	}
 #endif
@@ -1372,11 +1492,13 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 	if (IS_SD8978(handle->card_type)) {
 		if (magic == CHIP_MAGIC_VALUE) {
 			if (strap == CARD_TYPE_SD_UART)
-				strcpy(handle->card_info->fw_name,
-				       SDUART8978_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDUART8978_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 			else
-				strcpy(handle->card_info->fw_name,
-				       SDSD8978_DEFAULT_COMBO_FW_NAME);
+				strncpy(handle->card_info->fw_name,
+					SDSD8978_DEFAULT_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
 		}
 	}
 #endif
@@ -1388,28 +1510,32 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 		case SD9098_Z1Z2:
 			if (magic == CHIP_MAGIC_VALUE) {
 				if (strap == CARD_TYPE_SD_UART)
-					strcpy(handle->card_info->fw_name,
-					       SDUART9098_DEFAULT_COMBO_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDUART9098_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       SDSD9098_DEFAULT_COMBO_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDSD9098_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD9098_DEFAULT_WLAN_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD9098_DEFAULT_WLAN_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		case SD9098_A0:
 		case SD9098_A1:
 		case SD9098_A2:
 			if (magic == CHIP_MAGIC_VALUE) {
 				if (strap == CARD_TYPE_SD_UART)
-					strcpy(handle->card_info->fw_name,
-					       SDUART9098_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDUART9098_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       SDSD9098_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDSD9098_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD9098_WLAN_V1_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD9098_WLAN_V1_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		default:
 			break;
@@ -1423,14 +1549,100 @@ static mlan_status woal_sdiommc_get_fw_name(moal_handle *handle)
 		case SD9097_B1:
 			if (magic == CHIP_MAGIC_VALUE) {
 				if (strap == CARD_TYPE_SD_UART)
-					strcpy(handle->card_info->fw_name,
-					       SDUART9097_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDUART9097_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       SDSD9097_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						SDSD9097_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       SD9097_WLAN_V1_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				SD9097_WLAN_V1_FW_NAME, FW_NAMW_MAX_LEN);
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	if (IS_SDAW693(handle->card_type)) {
+		if (magic == CHIP_MAGIC_VALUE) {
+			if (strap == CARD_TYPE_SD_UART)
+				strncpy(handle->card_info->fw_name,
+					SDUARTAW693_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
+			else
+				strncpy(handle->card_info->fw_name,
+					SDSDAW693_COMBO_FW_NAME,
+					FW_NAMW_MAX_LEN);
+		}
+	}
+
+#ifdef SDIW62X
+	if (IS_SDIW62X(handle->card_type)) {
+		magic &= 0x03;
+		if (magic == 0x03)
+			PRINTM(MMSG, "wlan: SDIW62X in secure-boot mode\n");
+		if (strap == CARD_TYPE_SD_UART)
+			strncpy(handle->card_info->fw_name,
+				SDUARTIW62X_COMBO_FW_NAME, FW_NAMW_MAX_LEN);
+		else
+			strncpy(handle->card_info->fw_name,
+				SDSDIW62X_COMBO_FW_NAME, FW_NAMW_MAX_LEN);
+	}
+#endif
+
+#ifdef SD9177
+	if (IS_SD9177(handle->card_type)) {
+		switch (revision_id) {
+		case SD9177_A0:
+			if (magic == CHIP_MAGIC_VALUE) {
+				if (strap == CARD_TYPE_SD9177_UART)
+					strncpy(handle->card_info->fw_name,
+						SDUART9177_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
+				else
+					strncpy(handle->card_info->fw_name,
+						SDSD9177_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
+			}
+			strncpy(handle->card_info->fw_name_wlan,
+				SD9177_DEFAULT_WLAN_FW_NAME, FW_NAMW_MAX_LEN);
+			break;
+		case SD9177_A1:
+			if (magic == CHIP_MAGIC_VALUE) {
+				if (strap == CARD_TYPE_SD9177_UART) {
+					if (handle->params.rf_test_mode)
+						strncpy(handle->card_info
+								->fw_name,
+							SDUART9177_DEFAULT_RFTM_COMBO_V1_FW_NAME,
+							FW_NAMW_MAX_LEN);
+					else
+						strncpy(handle->card_info
+								->fw_name,
+							SDUART9177_DEFAULT_COMBO_V1_FW_NAME,
+							FW_NAMW_MAX_LEN);
+				} else {
+					if (handle->params.rf_test_mode)
+						strncpy(handle->card_info
+								->fw_name,
+							SDSD9177_DEFAULT_RFTM_COMBO_V1_FW_NAME,
+							FW_NAMW_MAX_LEN);
+					else
+						strncpy(handle->card_info
+								->fw_name,
+							SDSD9177_DEFAULT_COMBO_V1_FW_NAME,
+							FW_NAMW_MAX_LEN);
+				}
+			}
+			if (handle->params.rf_test_mode)
+				strncpy(handle->card_info->fw_name,
+					SD9177_DEFAULT_RFTM_WLAN_V1_FW_NAME,
+					FW_NAMW_MAX_LEN);
+			else
+				strncpy(handle->card_info->fw_name_wlan,
+					SD9177_DEFAULT_WLAN_V1_FW_NAME,
+					FW_NAMW_MAX_LEN);
 			break;
 		default:
 			break;
@@ -1467,7 +1679,6 @@ typedef enum {
 } dumped_mem_type;
 
 #define MAX_NAME_LEN 8
-#define MAX_FULL_NAME_LEN 32
 
 typedef struct {
 	t_u8 mem_name[MAX_NAME_LEN];
@@ -1477,7 +1688,7 @@ typedef struct {
 	t_u8 type;
 } memory_type_mapping;
 
-memory_type_mapping mem_type_mapping_tbl[] = {
+static memory_type_mapping mem_type_mapping_tbl[] = {
 	{"ITCM", NULL, NULL, 0xF0, FW_DUMP_TYPE_MEM_ITCM},
 	{"DTCM", NULL, NULL, 0xF1, FW_DUMP_TYPE_MEM_DTCM},
 	{"SQRAM", NULL, NULL, 0xF2, FW_DUMP_TYPE_MEM_SQRAM},
@@ -1494,15 +1705,8 @@ memory_type_mapping mem_type_mapping_tbl[] = {
 	{"EXT13", NULL, NULL, 0xFD, 0},
 	{"EXTLAST", NULL, NULL, 0xFE, 0},
 };
-memory_type_mapping mem_type_mapping_tbl_8977_8997 = {"DUMP", NULL, NULL, 0xDD,
-						      0};
-
-typedef enum {
-	RDWR_STATUS_SUCCESS = 0,
-	RDWR_STATUS_FAILURE = 1,
-	RDWR_STATUS_DONE = 2
-} rdwr_status;
-
+static memory_type_mapping mem_type_mapping_tbl_8977_8997 = {"DUMP", NULL, NULL,
+							     0xDD, 0};
 /**
  *  @brief This function read/write firmware via cmd52
  *
@@ -1511,7 +1715,7 @@ typedef enum {
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-rdwr_status woal_cmd52_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
+static rdwr_status woal_cmd52_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 {
 	int ret = 0;
 	int tries = 0;
@@ -1519,11 +1723,23 @@ rdwr_status woal_cmd52_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 	t_u8 dbg_dump_ctrl_reg = phandle->card_info->dump_fw_ctrl_reg;
 	t_u8 debug_host_ready = phandle->card_info->dump_fw_host_ready;
 
+#ifdef SD9177
+	if (IS_SD9177(phandle->card_type)) {
+		if (phandle->event_fw_dump)
+			debug_host_ready = 0xAA;
+	}
+#endif
 	ret = woal_sdio_writeb(phandle, dbg_dump_ctrl_reg, debug_host_ready);
 	if (ret) {
 		PRINTM(MERROR, "SDIO Write ERR\n");
 		return RDWR_STATUS_FAILURE;
 	}
+#ifdef SD9177
+	if (IS_SD9177(phandle->card_type)) {
+		if (phandle->event_fw_dump)
+			return RDWR_STATUS_SUCCESS;
+	}
+#endif
 	for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
 		ret = woal_sdio_readb(phandle, dbg_dump_ctrl_reg, &ctrl_data);
 		if (ret) {
@@ -1546,13 +1762,229 @@ rdwr_status woal_cmd52_rdwr_firmware(moal_handle *phandle, t_u8 doneflag)
 		}
 		udelay(100);
 	}
-	if (ctrl_data == debug_host_ready) {
+	if (ctrl_data == debug_host_ready || tries == MAX_POLL_TRIES) {
 		PRINTM(MERROR, "Fail to pull ctrl_data\n");
 		return RDWR_STATUS_FAILURE;
 	}
 	return RDWR_STATUS_SUCCESS;
 }
 
+#ifdef SD8801
+#define DEBUG_HOST_READY 0xEE
+#define DEBUG_FW_DONE 0xFF
+#define DEBUG_MEMDUMP_FINISH 0xFE
+#define MAX_POLL_TRIES 100
+#define DEBUG_ITCM_DONE 0xaa
+#define DEBUG_DTCM_DONE 0xbb
+#define DEBUG_SQRAM_DONE 0xcc
+
+#define DEBUG_DUMP_CTRL_REG 0x63
+#define DEBUG_DUMP_FIRST_REG 0x62
+#define DEBUG_DUMP_START_REG 0x64
+#define DEBUG_DUMP_END_REG 0x6a
+#define ITCM_SIZE 0x60000
+#define SQRAM_SIZE 0x33500
+#define DTCM_SIZE 0x14000
+
+/**
+ *  @brief This function dump firmware memory to file
+ *
+ *  @param phandle   A pointer to moal_handle
+ *
+ *  @return         N/A
+ */
+void woal_dump_firmware_info(moal_handle *phandle)
+{
+	int ret = 0;
+	unsigned int reg, reg_start, reg_end;
+	t_u8 *ITCM_Ptr = NULL;
+	t_u8 *DTCM_Ptr = NULL;
+	t_u8 *SQRAM_Ptr = NULL;
+	t_u8 *dbg_ptr = NULL;
+	t_u32 sec, usec;
+	t_u8 ctrl_data = 0;
+	t_u32 dtcm_size = DTCM_SIZE;
+	t_u32 sqram_size = SQRAM_SIZE;
+	t_u8 *end_ptr = NULL;
+	int tries;
+
+	if (!phandle) {
+		PRINTM(MERROR, "Could not dump firmwware info\n");
+		return;
+	}
+	if (!phandle->fw_dump_buf) {
+		ret = moal_vmalloc(phandle, FW_DUMP_INFO_LEN,
+				   &(phandle->fw_dump_buf));
+		if (ret != MLAN_STATUS_SUCCESS || !phandle->fw_dump_buf) {
+			PRINTM(MERROR, "Failed to vmalloc fw dump bufffer\n");
+			return;
+		}
+	} else {
+		memset(phandle->fw_dump_buf, 0x00, FW_DUMP_INFO_LEN);
+	}
+	phandle->fw_dump_len = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+	sdio_claim_host(((struct sdio_mmc_card *)phandle->card)->func);
+#endif
+	/* start dump fw memory	*/
+	moal_get_system_time(phandle, &sec, &usec);
+	PRINTM(MMSG, "==== DEBUG MODE OUTPUT START: %u.%06u ====\n", sec, usec);
+	ret = moal_vmalloc(phandle, ITCM_SIZE + 1, (t_u8 **)&ITCM_Ptr);
+	if ((ret != MLAN_STATUS_SUCCESS) || !ITCM_Ptr) {
+		PRINTM(MERROR, "Error: vmalloc ITCM buffer failed!!!\n");
+		goto done;
+	}
+
+	PRINTM(MMSG, "DTCM_SIZE=0x%x\n", dtcm_size);
+	ret = moal_vmalloc(phandle, dtcm_size + 1, (t_u8 **)&DTCM_Ptr);
+	if ((ret != MLAN_STATUS_SUCCESS) || !DTCM_Ptr) {
+		PRINTM(MERROR, "Error: vmalloc DTCM buffer failed!!!\n");
+		goto done;
+	}
+	ret = moal_vmalloc(phandle, sqram_size + 1, (t_u8 **)&SQRAM_Ptr);
+	if ((ret != MLAN_STATUS_SUCCESS) || !SQRAM_Ptr) {
+		PRINTM(MERROR, "Error: vmalloc SQRAM buffer failed!!!\n");
+		goto done;
+	}
+	dbg_ptr = ITCM_Ptr;
+	end_ptr = ITCM_Ptr + ITCM_SIZE;
+	moal_get_system_time(phandle, &sec, &usec);
+	PRINTM(MMSG, "Start ITCM output %u.%06u, please wait...\n", sec, usec);
+	reg_start = DEBUG_DUMP_START_REG;
+	reg_end = DEBUG_DUMP_END_REG;
+	do {
+		ret = woal_sdio_writeb(phandle, DEBUG_DUMP_CTRL_REG,
+				       DEBUG_HOST_READY);
+		if (ret) {
+			PRINTM(MERROR, "SDIO Write ERR\n");
+			goto done;
+		}
+		for (tries = 0; tries < MAX_POLL_TRIES; tries++) {
+			ret = woal_sdio_readb(phandle, DEBUG_DUMP_CTRL_REG,
+					      &ctrl_data);
+			if (ret) {
+				PRINTM(MERROR, "SDIO READ ERR\n");
+				goto done;
+			}
+			if ((ctrl_data == DEBUG_FW_DONE) ||
+			    (ctrl_data == DEBUG_ITCM_DONE) ||
+			    (ctrl_data == DEBUG_DTCM_DONE) ||
+			    (ctrl_data == DEBUG_SQRAM_DONE))
+				break;
+			if (ctrl_data != DEBUG_HOST_READY) {
+				ret = woal_sdio_writeb(phandle,
+						       DEBUG_DUMP_CTRL_REG,
+						       DEBUG_HOST_READY);
+				if (ret) {
+					PRINTM(MERROR, "SDIO Write ERR\n");
+					goto done;
+				}
+			}
+			udelay(100);
+		}
+		if (ctrl_data == DEBUG_HOST_READY) {
+			PRINTM(MERROR, "Fail to pull ctrl_data\n");
+			goto done;
+		}
+		reg = DEBUG_DUMP_FIRST_REG;
+		ret = woal_sdio_readb(phandle, reg, dbg_ptr);
+		if (ret) {
+			PRINTM(MMSG, "SDIO READ ERR\n");
+			goto done;
+		}
+		if (dbg_ptr < end_ptr)
+			dbg_ptr++;
+		else {
+			PRINTM(MINFO, "pre-allocced buf is not enough\n");
+			goto done;
+		}
+		for (reg = reg_start; reg <= reg_end; reg++) {
+			ret = woal_sdio_readb(phandle, reg, dbg_ptr);
+			if (ret) {
+				PRINTM(MMSG, "SDIO READ ERR\n");
+				goto done;
+			}
+			if (dbg_ptr < end_ptr)
+				dbg_ptr++;
+			else
+				PRINTM(MINFO,
+				       "pre-allocced buf is not enough\n");
+		}
+		switch (ctrl_data) {
+		case DEBUG_ITCM_DONE:
+#ifdef MLAN_64BIT
+			PRINTM(MMSG, "ITCM done: size=0x%lx\n",
+			       dbg_ptr - ITCM_Ptr);
+#else
+			PRINTM(MMSG, "ITCM done: size=0x%x\n",
+			       dbg_ptr - ITCM_Ptr);
+#endif
+			woal_save_dump_info_to_buf(phandle, ITCM_Ptr, ITCM_SIZE,
+						   FW_DUMP_TYPE_MEM_ITCM);
+			dbg_ptr = DTCM_Ptr;
+			end_ptr = DTCM_Ptr + dtcm_size;
+			moal_get_system_time(phandle, &sec, &usec);
+			PRINTM(MMSG,
+			       "Start DTCM output %u.%06u, please wait...\n",
+			       sec, usec);
+			break;
+		case DEBUG_DTCM_DONE:
+#ifdef MLAN_64BIT
+			PRINTM(MMSG, "DTCM done: size=0x%lx\n",
+			       dbg_ptr - DTCM_Ptr);
+#else
+			PRINTM(MMSG, "DTCM done: size=0x%x\n",
+			       dbg_ptr - DTCM_Ptr);
+#endif
+			woal_save_dump_info_to_buf(phandle, ITCM_Ptr, dtcm_size,
+						   FW_DUMP_TYPE_MEM_DTCM);
+			dbg_ptr = SQRAM_Ptr;
+			end_ptr = SQRAM_Ptr + sqram_size;
+			moal_get_system_time(phandle, &sec, &usec);
+			PRINTM(MMSG,
+			       "Start SQRAM output %u.%06u, please wait...\n",
+			       sec, usec);
+			break;
+		case DEBUG_SQRAM_DONE:
+#ifdef MLAN_64BIT
+			PRINTM(MMSG, "SQRAM done: size=0x%lx\n",
+			       dbg_ptr - SQRAM_Ptr);
+#else
+			PRINTM(MMSG, "SQRAM done: size=0x%x\n",
+			       dbg_ptr - SQRAM_Ptr);
+#endif
+			woal_save_dump_info_to_buf(phandle, SQRAM_Ptr,
+						   sqram_size,
+						   FW_DUMP_TYPE_MEM_SQRAM);
+			PRINTM(MMSG, "End output!\n");
+			break;
+		default:
+			break;
+		}
+	} while (ctrl_data != DEBUG_SQRAM_DONE);
+
+	woal_append_end_block(phandle);
+	PRINTM(MMSG,
+	       "The output ITCM/DTCM/SQRAM have been saved to files successfully!\n");
+	moal_get_system_time(phandle, &sec, &usec);
+	PRINTM(MMSG, "==== DEBUG MODE OUTPUT END: %u.%06u ====\n", sec, usec);
+	/* end dump fw memory */
+done:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 32)
+	sdio_release_host(((struct sdio_mmc_card *)phandle->card)->func);
+#endif
+	if (ITCM_Ptr)
+		moal_vfree(phandle, ITCM_Ptr);
+	if (DTCM_Ptr)
+		moal_vfree(phandle, DTCM_Ptr);
+	if (SQRAM_Ptr)
+		moal_vfree(phandle, SQRAM_Ptr);
+	PRINTM(MMSG, "==== DEBUG MODE END ====\n");
+	return;
+}
+#endif
+
 /**
  *  @brief This function dump firmware memory to file
  *
@@ -1573,7 +2005,6 @@ void woal_dump_firmware_info_v2(moal_handle *phandle)
 	t_u8 i = 0;
 	t_u8 read_reg = 0;
 	t_u32 memory_size = 0;
-	t_u8 path_name[64], file_name[32], firmware_dump_file[128];
 	t_u8 *end_ptr = NULL;
 	t_u8 dbg_dump_start_reg = 0;
 	t_u8 dbg_dump_end_reg = 0;
@@ -1588,16 +2019,17 @@ void woal_dump_firmware_info_v2(moal_handle *phandle)
 	dbg_dump_end_reg = phandle->card_info->dump_fw_end_reg;
 	dbg_dump_ctrl_reg = phandle->card_info->dump_fw_ctrl_reg;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-	/** Create dump directort*/
-	woal_create_dump_dir(phandle, path_name, sizeof(path_name));
-#else
-	memset(path_name, 0, sizeof(path_name));
-	strcpy(path_name, "/data");
-#endif
-	PRINTM(MMSG, "Directory name is %s\n", path_name);
-
-	woal_dump_drv_info(phandle, path_name);
+	if (!phandle->fw_dump_buf) {
+		ret = moal_vmalloc(phandle, FW_DUMP_INFO_LEN,
+				   &(phandle->fw_dump_buf));
+		if (ret != MLAN_STATUS_SUCCESS || !phandle->fw_dump_buf) {
+			PRINTM(MERROR, "Failed to vmalloc fw dump bufffer\n");
+			return;
+		}
+	} else {
+		memset(phandle->fw_dump_buf, 0x00, FW_DUMP_INFO_LEN);
+	}
+	phandle->fw_dump_len = 0;
 
 	/* start dump fw memory */
 	moal_get_system_time(phandle, &sec, &usec);
@@ -1673,31 +2105,30 @@ void woal_dump_firmware_info_v2(moal_handle *phandle)
 				if (dbg_ptr < end_ptr)
 					dbg_ptr++;
 				else
-					PRINTM(MMSG,
+					PRINTM(MINFO,
 					       "pre-allocced buf is not enough\n");
 			}
 			if (RDWR_STATUS_DONE == stat) {
+#ifdef MLAN_64BIT
 				PRINTM(MMSG,
 				       "%s done:"
-#ifdef MLAN_64BIT
 				       "size = 0x%lx\n",
+				       mem_type_mapping_tbl[idx].mem_name,
+				       dbg_ptr - mem_type_mapping_tbl[idx]
+							 .mem_Ptr);
 #else
+				PRINTM(MMSG,
+				       "%s done:"
 				       "size = 0x%x\n",
-#endif
 				       mem_type_mapping_tbl[idx].mem_name,
 				       dbg_ptr - mem_type_mapping_tbl[idx]
 							 .mem_Ptr);
-				memset(file_name, 0, sizeof(file_name));
-				sprintf(file_name, "%s%s", "file_sdio_",
-					mem_type_mapping_tbl[idx].mem_name);
-				if (MLAN_STATUS_SUCCESS !=
-				    woal_save_dump_info_to_file(
-					    path_name, file_name,
-					    mem_type_mapping_tbl[idx].mem_Ptr,
-					    memory_size))
-					PRINTM(MERROR,
-					       "Can't save dump file %s in %s\n",
-					       file_name, path_name);
+#endif
+				woal_save_dump_info_to_buf(
+					phandle,
+					mem_type_mapping_tbl[idx].mem_Ptr,
+					memory_size,
+					mem_type_mapping_tbl[idx].type);
 				moal_vfree(phandle,
 					   mem_type_mapping_tbl[idx].mem_Ptr);
 				mem_type_mapping_tbl[idx].mem_Ptr = NULL;
@@ -1705,14 +2136,10 @@ void woal_dump_firmware_info_v2(moal_handle *phandle)
 			}
 		} while (1);
 	}
+	woal_append_end_block(phandle);
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "==== DEBUG MODE OUTPUT END: %u.%06u ====\n", sec, usec);
 	/* end dump fw memory */
-	memset(firmware_dump_file, 0, sizeof(firmware_dump_file));
-	sprintf(firmware_dump_file, "%s/%s", path_name, file_name);
-	moal_memcpy_ext(phandle, phandle->firmware_dump_file,
-			firmware_dump_file, sizeof(firmware_dump_file),
-			sizeof(phandle->firmware_dump_file));
 done:
 	for (idx = 0; idx < dump_num; idx++) {
 		if (mem_type_mapping_tbl[idx].mem_Ptr) {
@@ -1743,8 +2170,6 @@ void woal_dump_firmware_info_v3(moal_handle *phandle)
 	t_u8 doneflag = 0;
 	rdwr_status stat;
 	t_u32 memory_size = 0;
-	t_u8 path_name[64], file_name[32], firmware_dump_file[128];
-	moal_handle *ref_handle;
 	t_u8 *end_ptr = NULL;
 	t_u8 dbg_dump_start_reg = 0;
 	t_u8 dbg_dump_end_reg = 0;
@@ -1755,23 +2180,22 @@ void woal_dump_firmware_info_v3(moal_handle *phandle)
 		PRINTM(MERROR, "Could not dump firmwware info\n");
 		return;
 	}
+#ifdef SD9177
+	if (IS_SD9177(phandle->card_type)) {
+		if (phandle->event_fw_dump) {
+			if (RDWR_STATUS_FAILURE !=
+			    woal_cmd52_rdwr_firmware(phandle, doneflag)) {
+				PRINTM(MMSG,
+				       "====SDIO FW DUMP EVENT MODE START ====\n");
+				return;
+			}
+		}
+	}
+#endif
 
 	dbg_dump_start_reg = phandle->card_info->dump_fw_start_reg;
 	dbg_dump_end_reg = phandle->card_info->dump_fw_end_reg;
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
-	/** Create dump directort*/
-	woal_create_dump_dir(phandle, path_name, sizeof(path_name));
-#else
-	memset(path_name, 0, sizeof(path_name));
-	strcpy(path_name, "/data");
-#endif
-	PRINTM(MMSG, "Directory name is %s\n", path_name);
-	ref_handle = (moal_handle *)phandle->pref_mac;
-	if (ref_handle)
-		woal_dump_drv_info(ref_handle, path_name);
-	woal_dump_drv_info(phandle, path_name);
-
 	/* start dump fw memory */
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "==== DEBUG MODE OUTPUT START: %u.%06u ====\n", sec, usec);
@@ -1827,53 +2251,57 @@ void woal_dump_firmware_info_v3(moal_handle *phandle)
 			}
 			dbg_ptr++;
 			if (dbg_ptr >= end_ptr) {
-				PRINTM(MMSG,
+				PRINTM(MINFO,
 				       "pre-allocced buf is not enough\n");
+
 				ret = moal_vmalloc(phandle,
-						   memory_size + 0x4000 + 1,
+						   memory_size + 0x2000 + 1,
 						   (t_u8 **)&temp_Ptr);
 				if ((ret != MLAN_STATUS_SUCCESS) || !temp_Ptr) {
 					PRINTM(MERROR,
 					       "Error: vmalloc  buffer failed!!!\n");
 					goto done;
 				}
+
 				moal_memcpy_ext(phandle, temp_Ptr,
 						pmem_type_mapping_tbl->mem_Ptr,
 						memory_size,
-						memory_size + 0x4000);
+						memory_size + 0x2000);
 				moal_vfree(phandle,
 					   pmem_type_mapping_tbl->mem_Ptr);
 				pmem_type_mapping_tbl->mem_Ptr = temp_Ptr;
 				temp_Ptr = NULL;
 				dbg_ptr = pmem_type_mapping_tbl->mem_Ptr +
 					  memory_size;
-				memory_size += 0x4000;
+
+				memory_size += 0x2000;
 				end_ptr = pmem_type_mapping_tbl->mem_Ptr +
 					  memory_size;
 			}
 		}
 		if (RDWR_STATUS_DONE == stat) {
+#ifdef MLAN_64BIT
 			PRINTM(MMSG,
 			       "%s done:"
-#ifdef MLAN_64BIT
 			       "size = 0x%lx\n",
+			       pmem_type_mapping_tbl->mem_name,
+			       dbg_ptr - pmem_type_mapping_tbl->mem_Ptr);
 #else
+			PRINTM(MMSG,
+			       "%s done:"
 			       "size = 0x%x\n",
-#endif
 			       pmem_type_mapping_tbl->mem_name,
 			       dbg_ptr - pmem_type_mapping_tbl->mem_Ptr);
-			memset(file_name, 0, sizeof(file_name));
-			sprintf(file_name, "%s%s", "file_sdio_",
-				pmem_type_mapping_tbl->mem_name);
-			if (MLAN_STATUS_SUCCESS !=
-			    woal_save_dump_info_to_file(
-				    path_name, file_name,
-				    pmem_type_mapping_tbl->mem_Ptr,
-				    dbg_ptr - pmem_type_mapping_tbl->mem_Ptr))
-				PRINTM(MERROR,
-				       "Can't save dump file %s in %s\n",
-				       file_name, path_name);
-			moal_vfree(phandle, pmem_type_mapping_tbl->mem_Ptr);
+
+#endif
+			if (phandle->fw_dump_buf) {
+				moal_vfree(phandle, phandle->fw_dump_buf);
+				phandle->fw_dump_buf = NULL;
+				phandle->fw_dump_len = 0;
+			}
+			phandle->fw_dump_buf = pmem_type_mapping_tbl->mem_Ptr;
+			phandle->fw_dump_len =
+				dbg_ptr - pmem_type_mapping_tbl->mem_Ptr;
 			pmem_type_mapping_tbl->mem_Ptr = NULL;
 			break;
 		}
@@ -1881,11 +2309,6 @@ void woal_dump_firmware_info_v3(moal_handle *phandle)
 	moal_get_system_time(phandle, &sec, &usec);
 	PRINTM(MMSG, "==== DEBUG MODE OUTPUT END: %u.%06u ====\n", sec, usec);
 	/* end dump fw memory */
-	memset(firmware_dump_file, 0, sizeof(firmware_dump_file));
-	sprintf(firmware_dump_file, "%s/%s", path_name, file_name);
-	moal_memcpy_ext(phandle, phandle->firmware_dump_file,
-			firmware_dump_file, sizeof(firmware_dump_file),
-			sizeof(phandle->firmware_dump_file));
 done:
 	if (pmem_type_mapping_tbl->mem_Ptr) {
 		moal_vfree(phandle, pmem_type_mapping_tbl->mem_Ptr);
@@ -1941,21 +2364,25 @@ static void woal_sdiommc_reg_dbg(moal_handle *phandle)
 			reg_end = scratch_reg + 10;
 		}
 		if (loop != 2)
-			ptr += sprintf(ptr, "SDIO Func%d (%#x-%#x): ", func,
-				       reg_start, reg_end);
+			ptr += snprintf(ptr, sizeof(buf),
+					"SDIO Func%d (%#x-%#x): ", func,
+					reg_start, reg_end);
 		else
-			ptr += sprintf(ptr, "SDIO Func%d: ", func);
+			ptr += snprintf(ptr, sizeof(buf),
+					"SDIO Func%d: ", func);
 		for (reg = reg_start; reg <= reg_end;) {
 			if (func == 0)
 				ret = woal_sdio_f0_readb(phandle, reg, &data);
 			else
 				ret = woal_sdio_readb(phandle, reg, &data);
 			if (loop == 2)
-				ptr += sprintf(ptr, "(%#x) ", reg);
+				ptr += snprintf(ptr, sizeof(buf), "(%#x) ",
+						reg);
 			if (!ret)
-				ptr += sprintf(ptr, "%02x ", data);
+				ptr += snprintf(ptr, sizeof(buf), "%02x ",
+						data);
 			else {
-				ptr += sprintf(ptr, "ERR");
+				ptr += snprintf(ptr, sizeof(buf), "ERR");
 				break;
 			}
 			if (loop == 2 && reg < reg_end)
@@ -1981,16 +2408,40 @@ static void woal_sdiommc_dump_fw_info(moal_handle *phandle)
 		PRINTM(MERROR, "Could not dump firmwware info\n");
 		return;
 	}
+	if (phandle->fw_dump_buf) {
+		PRINTM(MERROR, "FW dump already exist\n");
+		return;
+	}
+	/** cancel all pending commands */
+	mlan_ioctl(phandle->pmlan_adapter, NULL);
+
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MTRUE);
 	phandle->fw_dump = MTRUE;
 	if (phandle->card_info->dump_fw_info == DUMP_FW_SDIO_V2) {
 		woal_dump_firmware_info_v2(phandle);
 	} else if (phandle->card_info->dump_fw_info == DUMP_FW_SDIO_V3) {
 		woal_dump_firmware_info_v3(phandle);
+		if (phandle->event_fw_dump) {
+			phandle->event_fw_dump = MFALSE;
+			queue_work(phandle->workqueue, &phandle->main_work);
+			phandle->is_fw_dump_timer_set = MTRUE;
+			woal_mod_timer(&phandle->fw_dump_timer, MOAL_TIMER_5S);
+			return;
+		}
 	}
+#ifdef SD8801
+	else {
+		woal_dump_firmware_info(phandle);
+	}
+#endif
 	phandle->fw_dump = MFALSE;
+	if (!phandle->priv_num)
+		return;
+	woal_send_fw_dump_complete_event(
+		woal_get_priv(phandle, MLAN_BSS_ROLE_ANY));
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
 	queue_work(phandle->workqueue, &phandle->main_work);
+	woal_process_hang(phandle);
 	return;
 }
 
@@ -2027,7 +2478,8 @@ static int woal_sdiommc_dump_reg_info(moal_handle *phandle, t_u8 *drv_buf)
 
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MTRUE);
 
-	drv_ptr += sprintf(drv_ptr, "--------sdio_reg_debug_info---------\n");
+	drv_ptr += snprintf(drv_ptr, MAX_BUF_LEN,
+			    "--------sdio_reg_debug_info---------\n");
 	for (loop = 0; loop < 5; loop++) {
 		memset(buf, 0, sizeof(buf));
 		ptr = buf;
@@ -2057,10 +2509,12 @@ static int woal_sdiommc_dump_reg_info(moal_handle *phandle, t_u8 *drv_buf)
 			reg_end = scratch_reg + 10;
 		}
 		if (loop != 2)
-			ptr += sprintf(ptr, "SDIO Func%d (%#x-%#x): ", func,
-				       reg_start, reg_end);
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"SDIO Func%d (%#x-%#x): ", func,
+					reg_start, reg_end);
 		else
-			ptr += sprintf(ptr, "SDIO Func%d: ", func);
+			ptr += snprintf(ptr, MAX_BUF_LEN,
+					"SDIO Func%d: ", func);
 		for (reg = reg_start; reg <= reg_end;) {
 			if (func == 0)
 				ret = woal_sdio_f0_readb(phandle, reg, &data);
@@ -2068,11 +2522,13 @@ static int woal_sdiommc_dump_reg_info(moal_handle *phandle, t_u8 *drv_buf)
 				ret = woal_sdio_readb(phandle, reg, &data);
 
 			if (loop == 2)
-				ptr += sprintf(ptr, "(%#x) ", reg);
+				ptr += snprintf(ptr, MAX_BUF_LEN, "(%#x) ",
+						reg);
 			if (!ret)
-				ptr += sprintf(ptr, "%02x ", data);
+				ptr += snprintf(ptr, MAX_BUF_LEN, "%02x ",
+						data);
 			else {
-				ptr += sprintf(ptr, "ERR");
+				ptr += snprintf(ptr, MAX_BUF_LEN, "ERR");
 				break;
 			}
 			if (loop == 2 && reg < reg_end)
@@ -2080,17 +2536,63 @@ static int woal_sdiommc_dump_reg_info(moal_handle *phandle, t_u8 *drv_buf)
 			else
 				reg++;
 		}
-		drv_ptr += sprintf(drv_ptr, "%s\n", buf);
+		drv_ptr += snprintf(drv_ptr, MAX_BUF_LEN, "%s\n", buf);
 	}
 
-	drv_ptr +=
-		sprintf(drv_ptr, "--------sdio_reg_debug_info End---------\n");
+	drv_ptr += snprintf(drv_ptr, MAX_BUF_LEN,
+			    "--------sdio_reg_debug_info End---------\n");
 	mlan_pm_wakeup_card(phandle->pmlan_adapter, MFALSE);
 
 	LEAVE();
 	return drv_ptr - (char *)drv_buf;
 }
 
+/**
+ *  @brief This function reset sdio through sdio bus driver
+ *
+ *  @param phandle   A pointer to moal_handle
+ *
+ *  @return          N/A
+ */
+void woal_sdio_reset_hw(moal_handle *handle)
+{
+	struct sdio_mmc_card *card = handle->card;
+	struct sdio_func *func = card->func;
+	ENTER();
+	sdio_claim_host(func);
+	sdio_release_irq(card->func);
+	sdio_disable_func(card->func);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	mmc_hw_reset(func->card);
+#else
+	mmc_hw_reset(func->card->host);
+#endif
+#endif
+
+#ifdef MMC_QUIRK_BLKSZ_FOR_BYTE_MODE
+	/* The byte mode patch is available in kernel MMC driver
+	 * which fixes one issue in MP-A transfer.
+	 * bit1: use func->cur_blksize for byte mode
+	 */
+	func->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+	/* wait for chip fully wake up */
+	if (!func->enable_timeout)
+		func->enable_timeout = 200;
+#endif
+	sdio_enable_func(func);
+	sdio_claim_irq(func, woal_sdio_interrupt);
+	sdio_set_block_size(card->func, MLAN_SDIO_BLOCK_SIZE);
+	sdio_release_host(func);
+	LEAVE();
+	return;
+}
+
 static moal_if_ops sdiommc_ops = {
 	.register_dev = woal_sdiommc_register_dev,
 	.unregister_dev = woal_sdiommc_unregister_dev,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.c
old mode 100644
new mode 100755
index 2effd85a4..72d71c9e5
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.c
@@ -3,7 +3,7 @@
  * @brief This file contains the callback functions registered to MLAN
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -44,6 +44,17 @@ Change log:
 #endif
 #include <asm/div64.h>
 
+#if defined(PCIE) || defined(SDIO)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
+#ifdef IMX_SUPPORT
+#include <linux/busfreq-imx.h>
+#endif
+#endif
+
+#include <linux/etherdevice.h>
+
+#endif /*defined(PCIE) || defined(SDIO)*/
+
 /********************************************************
 		Local Variables
 ********************************************************/
@@ -71,7 +82,7 @@ extern int wifi_status;
 /**
  *  @brief Alloc a buffer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param size     The size of the buffer to be allocated
  *  @param flag     The type of the buffer to be allocated
  *  @param ppbuf    Pointer to a buffer location to store buffer pointer
@@ -79,12 +90,15 @@ extern int wifi_status;
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_malloc(t_void *pmoal_handle, t_u32 size, t_u32 flag,
-			t_u8 **ppbuf)
+mlan_status moal_malloc(t_void *pmoal, t_u32 size, t_u32 flag, t_u8 **ppbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
-	t_u32 mem_flag =
-		(in_interrupt() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	moal_handle *handle = (moal_handle *)pmoal;
+	gfp_t mem_flag = (in_interrupt() || in_atomic() || irqs_disabled()) ?
+				 GFP_ATOMIC :
+				 GFP_KERNEL;
+
+	if (flag & MLAN_MEM_FLAG_ATOMIC)
+		mem_flag = GFP_ATOMIC;
 
 #ifdef USB
 	if (!IS_USB(handle->card_type))
@@ -107,14 +121,14 @@ mlan_status moal_malloc(t_void *pmoal_handle, t_u32 size, t_u32 flag,
 /**
  *  @brief Free a buffer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pbuf     Pointer to the buffer to be freed
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_mfree(t_void *pmoal_handle, t_u8 *pbuf)
+mlan_status moal_mfree(t_void *pmoal, t_u8 *pbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 
 	if (!pbuf)
 		return MLAN_STATUS_FAILURE;
@@ -126,16 +140,16 @@ mlan_status moal_mfree(t_void *pmoal_handle, t_u8 *pbuf)
 /**
  *  @brief Alloc a vitual-address-continuous buffer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param size     The size of the buffer to be allocated
  *  @param ppbuf    Pointer to a buffer location to store buffer pointer
  * allocated
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_vmalloc(t_void *pmoal_handle, t_u32 size, t_u8 **ppbuf)
+mlan_status moal_vmalloc(t_void *pmoal, t_u32 size, t_u8 **ppbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 
 	*ppbuf = vmalloc(size);
 	if (*ppbuf == NULL) {
@@ -151,14 +165,14 @@ mlan_status moal_vmalloc(t_void *pmoal_handle, t_u32 size, t_u8 **ppbuf)
 /**
  *  @brief Free a buffer allocated by vmalloc
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pbuf     Pointer to the buffer to be freed
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_vfree(t_void *pmoal_handle, t_u8 *pbuf)
+mlan_status moal_vfree(t_void *pmoal, t_u8 *pbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 
 	if (!pbuf)
 		return MLAN_STATUS_FAILURE;
@@ -171,7 +185,7 @@ mlan_status moal_vfree(t_void *pmoal_handle, t_u8 *pbuf)
 /**
  *  @brief Alloc a consistent block of memory
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param size         The size of the buffer to be allocated
  *  @param ppbuf        Pointer to a buffer location to store memory allocated
  *  @param pbuf_pa      Pointer to a buffer location to store physical address
@@ -179,20 +193,31 @@ mlan_status moal_vfree(t_void *pmoal_handle, t_u8 *pbuf)
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_malloc_consistent(t_void *pmoal_handle, t_u32 size,
-				   t_u8 **ppbuf, t_pu64 pbuf_pa)
+mlan_status moal_malloc_consistent(t_void *pmoal, t_u32 size, t_u8 **ppbuf,
+				   t_pu64 pbuf_pa)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	pcie_service_card *card = (pcie_service_card *)handle->card;
+	dma_addr_t dma;
 	*pbuf_pa = 0;
+
+	if (!card)
+		return MLAN_STATUS_FAILURE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	*ppbuf = (t_u8 *)dma_alloc_coherent(&card->dev->dev, size,
+					    (dma_addr_t *)&dma, GFP_KERNEL);
+#else
 	*ppbuf = (t_u8 *)pci_alloc_consistent(card->dev, size,
-					      (dma_addr_t *)pbuf_pa);
+					      (dma_addr_t *)&dma);
+#endif
 	if (*ppbuf == NULL) {
 		PRINTM(MERROR,
 		       "%s: allocate consistent memory (%d bytes) failed!\n",
 		       __func__, (int)size);
 		return MLAN_STATUS_FAILURE;
 	}
+	*pbuf_pa = (t_u64)dma;
 	atomic_inc(&handle->malloc_cons_count);
 
 	return MLAN_STATUS_SUCCESS;
@@ -201,23 +226,27 @@ mlan_status moal_malloc_consistent(t_void *pmoal_handle, t_u32 size,
 /**
  *  @brief Free a consistent block of memory
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param size         Size of them memory to be freed
  *  @param pbuf         Pointer to the memory to be freed
  *  @param buf_pa       Physical address of the memory to be freed
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_mfree_consistent(t_void *pmoal_handle, t_u32 size, t_u8 *pbuf,
+mlan_status moal_mfree_consistent(t_void *pmoal, t_u32 size, t_u8 *pbuf,
 				  t_u64 buf_pa)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	pcie_service_card *card = handle->card;
 
-	if (!pbuf)
+	if (!pbuf || !card)
 		return MLAN_STATUS_FAILURE;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dma_free_coherent(&card->dev->dev, size, pbuf, buf_pa);
+#else
 	pci_free_consistent(card->dev, size, pbuf, buf_pa);
+#endif
 	atomic_dec(&handle->malloc_cons_count);
 	return MLAN_STATUS_SUCCESS;
 }
@@ -225,7 +254,7 @@ mlan_status moal_mfree_consistent(t_void *pmoal_handle, t_u32 size, t_u8 *pbuf,
 /**
  *  @brief Map a block of memory to device
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pbuf         Pointer to the buffer to be mapped
  *  @param pbuf_pa      Pointer to store the physical address of buffer
  *  @param size         Size of the buffer to be mapped
@@ -233,22 +262,29 @@ mlan_status moal_mfree_consistent(t_void *pmoal_handle, t_u32 size, t_u8 *pbuf,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_map_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 *pbuf_pa,
+mlan_status moal_map_memory(t_void *pmoal, t_u8 *pbuf, t_u64 *pbuf_pa,
 			    t_u32 size, t_u32 flag)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	pcie_service_card *card = (pcie_service_card *)handle->card;
 
 	dma_addr_t dma;
 
-	/* Init memory to device */
+	if (!card)
+		return MLAN_STATUS_FAILURE;
+
+		/* Init memory to device */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dma = dma_map_single(&card->dev->dev, pbuf, size, flag);
+	if (dma_mapping_error(&card->dev->dev, dma)) {
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
 	dma = pci_map_single(card->dev, pbuf, size, flag);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
 	if (pci_dma_mapping_error(card->dev, dma)) {
 #else
+	dma = pci_map_single(card->dev, pbuf, size, flag);
 	if (pci_dma_mapping_error(dma)) {
 #endif
-		PRINTM(MERROR, "Tx ring: failed to pci_map_single\n");
+		PRINTM(MERROR, "Tx ring: failed to dma_map_single\n");
 		return MLAN_STATUS_FAILURE;
 	}
 
@@ -259,7 +295,7 @@ mlan_status moal_map_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 *pbuf_pa,
 /**
  *  @brief Unmap a block of memory from device
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pbuf         Pointer to the buffer to unmap
  *  @param buf_pa       Physical address of buffer to unmap
  *  @param size         Size of the buffer to unmap
@@ -267,13 +303,20 @@ mlan_status moal_map_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 *pbuf_pa,
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_unmap_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 buf_pa,
+mlan_status moal_unmap_memory(t_void *pmoal, t_u8 *pbuf, t_u64 buf_pa,
 			      t_u32 size, t_u32 flag)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	pcie_service_card *card = (pcie_service_card *)handle->card;
 
+	if (!card)
+		return MLAN_STATUS_FAILURE;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	dma_unmap_single(&card->dev->dev, buf_pa, size, flag);
+#else
 	pci_unmap_single(card->dev, buf_pa, size, flag);
+#endif
 
 	return MLAN_STATUS_SUCCESS;
 }
@@ -282,14 +325,14 @@ mlan_status moal_unmap_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 buf_pa,
 /**
  *  @brief Fill memory with constant byte
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmem     Pointer to the memory area
  *  @param byte     A constant byte
  *  @param num      Number of bytes to fill
  *
  *  @return         Pointer to the memory area
  */
-t_void *moal_memset(t_void *pmoal_handle, t_void *pmem, t_u8 byte, t_u32 num)
+t_void *moal_memset(t_void *pmoal, t_void *pmem, t_u8 byte, t_u32 num)
 {
 	t_void *p = pmem;
 
@@ -302,15 +345,14 @@ t_void *moal_memset(t_void *pmoal_handle, t_void *pmem, t_u8 byte, t_u32 num)
 /**
  *  @brief Copy memory from one area to another
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pdest    Pointer to the dest memory
  *  @param psrc     Pointer to the src memory
  *  @param num      Number of bytes to move
  *
  *  @return         Pointer to the dest memory
  */
-t_void *moal_memcpy(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
-		    t_u32 num)
+t_void *moal_memcpy(t_void *pmoal, t_void *pdest, const t_void *psrc, t_u32 num)
 {
 	t_void *p = pdest;
 
@@ -323,7 +365,7 @@ t_void *moal_memcpy(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
 /**
  *  @brief Copy memory from one area to another
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pdest    Pointer to the dest memory
  *  @param psrc     Pointer to the src memory
  *  @param num      Number of bytes to move
@@ -331,7 +373,7 @@ t_void *moal_memcpy(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
  *
  *  @return         Pointer to the dest memory
  */
-t_void *moal_memcpy_ext(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
+t_void *moal_memcpy_ext(t_void *pmoal, t_void *pdest, const t_void *psrc,
 			t_u32 num, t_u32 dest_size)
 {
 	t_void *p = pdest;
@@ -344,14 +386,14 @@ t_void *moal_memcpy_ext(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
 /**
  *  @brief Move memory from one area to another
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pdest    Pointer to the dest memory
  *  @param psrc     Pointer to the src memory
  *  @param num      Number of bytes to move
  *
  *  @return         Pointer to the dest memory
  */
-t_void *moal_memmove(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
+t_void *moal_memmove(t_void *pmoal, t_void *pdest, const t_void *psrc,
 		     t_u32 num)
 {
 	t_void *p = pdest;
@@ -365,15 +407,15 @@ t_void *moal_memmove(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
 /**
  *  @brief Compare two memory areas
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmem1    Pointer to the first memory
  *  @param pmem2    Pointer to the second memory
  *  @param num      Number of bytes to compare
  *
  *  @return         Compare result returns by memcmp
  */
-t_s32 moal_memcmp(t_void *pmoal_handle, const t_void *pmem1,
-		  const t_void *pmem2, t_u32 num)
+t_s32 moal_memcmp(t_void *pmoal, const t_void *pmem1, const t_void *pmem2,
+		  t_u32 num)
 {
 	t_s32 result;
 
@@ -385,12 +427,12 @@ t_s32 moal_memcmp(t_void *pmoal_handle, const t_void *pmem1,
 /**
  *  @brief Delay function
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param delay  delay in micro-second
  *
  *  @return       N/A
  */
-t_void moal_udelay(t_void *pmoal_handle, t_u32 delay)
+t_void moal_udelay(t_void *pmoal, t_u32 delay)
 {
 	if (delay >= 1000)
 		msleep(delay / 1000);
@@ -405,13 +447,13 @@ t_void moal_udelay(t_void *pmoal_handle, t_u32 delay)
 /**
  *  @brief  usleep_range function
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param min_delay  minimal delay in micro-second
  *  @param max_delay  delay in micro-second
  *
  *  @return       N/A
  */
-t_void moal_usleep_range(t_void *pmoal_handle, t_u32 min_delay, t_u32 max_delay)
+t_void moal_usleep_range(t_void *pmoal, t_u32 min_delay, t_u32 max_delay)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
 	usleep_range(min_delay, max_delay);
@@ -420,14 +462,13 @@ t_void moal_usleep_range(t_void *pmoal_handle, t_u32 min_delay, t_u32 max_delay)
 /**
  *  @brief Retrieves the current system time
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param psec     Pointer to buf for the seconds of system time
  *  @param pusec    Pointer to buf the micro seconds of system time
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_get_system_time(t_void *pmoal_handle, t_u32 *psec,
-				 t_u32 *pusec)
+mlan_status moal_get_system_time(t_void *pmoal, t_u32 *psec, t_u32 *pusec)
 {
 	wifi_timeval t;
 
@@ -441,12 +482,12 @@ mlan_status moal_get_system_time(t_void *pmoal_handle, t_u32 *psec,
 /**
  *  @brief Retrieves the current boot time
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pnsec     Pointer to buf for the Nanoseconds of boot time
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_get_boot_ktime(t_void *pmoal_handle, t_u64 *pnsec)
+mlan_status moal_get_boot_ktime(t_void *pmoal, t_u64 *pnsec)
 {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
 	ktime_t time;
@@ -460,20 +501,21 @@ mlan_status moal_get_boot_ktime(t_void *pmoal_handle, t_u64 *pnsec)
 /**
  *  @brief Initializes the timer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pptimer      Pointer to the timer
  *  @param callback     Pointer to callback function
  *  @param pcontext     Pointer to context
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_init_timer(t_void *pmoal_handle, t_void **pptimer,
+mlan_status moal_init_timer(t_void *pmoal, t_void **pptimer,
 			    IN t_void (*callback)(t_void *pcontext),
 			    t_void *pcontext)
 {
 	moal_drv_timer *timer = NULL;
-	t_u32 mem_flag =
-		(in_interrupt() || irqs_disabled()) ? GFP_ATOMIC : GFP_KERNEL;
+	gfp_t mem_flag = (in_interrupt() || in_atomic() || irqs_disabled()) ?
+				 GFP_ATOMIC :
+				 GFP_KERNEL;
 
 	timer = kmalloc(sizeof(moal_drv_timer), mem_flag);
 	if (timer == NULL)
@@ -487,12 +529,12 @@ mlan_status moal_init_timer(t_void *pmoal_handle, t_void **pptimer,
 /**
  *  @brief Free the timer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param ptimer   Pointer to the timer
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_free_timer(t_void *pmoal_handle, t_void *ptimer)
+mlan_status moal_free_timer(t_void *pmoal, t_void *ptimer)
 {
 	moal_drv_timer *timer = (moal_drv_timer *)ptimer;
 
@@ -512,15 +554,15 @@ mlan_status moal_free_timer(t_void *pmoal_handle, t_void *ptimer)
 /**
  *  @brief Start the timer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param ptimer       Pointer to the timer
  *  @param periodic     Periodic timer
  *  @param msec         Timer value in milliseconds
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_start_timer(t_void *pmoal_handle, t_void *ptimer,
-			     t_u8 periodic, t_u32 msec)
+mlan_status moal_start_timer(t_void *pmoal, t_void *ptimer, t_u8 periodic,
+			     t_u32 msec)
 {
 	if (!ptimer)
 		return MLAN_STATUS_FAILURE;
@@ -534,12 +576,12 @@ mlan_status moal_start_timer(t_void *pmoal_handle, t_void *ptimer,
 /**
  *  @brief Stop the timer
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param ptimer   Pointer to the timer
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_stop_timer(t_void *pmoal_handle, t_void *ptimer)
+mlan_status moal_stop_timer(t_void *pmoal, t_void *ptimer)
 {
 	if (!ptimer)
 		return MLAN_STATUS_FAILURE;
@@ -551,14 +593,14 @@ mlan_status moal_stop_timer(t_void *pmoal_handle, t_void *ptimer)
 /**
  *  @brief Initializes the lock
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pplock   Pointer to the lock
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_init_lock(t_void *pmoal_handle, t_void **pplock)
+mlan_status moal_init_lock(t_void *pmoal, t_void **pplock)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	moal_lock *mlock = NULL;
 
 	mlock = kmalloc(sizeof(moal_lock), GFP_ATOMIC);
@@ -575,14 +617,14 @@ mlan_status moal_init_lock(t_void *pmoal_handle, t_void **pplock)
 /**
  *  @brief Free the lock
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param plock    Lock
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_free_lock(t_void *pmoal_handle, t_void *plock)
+mlan_status moal_free_lock(t_void *pmoal, t_void *plock)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	moal_lock *mlock = plock;
 
 	kfree(mlock);
@@ -595,60 +637,199 @@ mlan_status moal_free_lock(t_void *pmoal_handle, t_void *plock)
 /**
  *  @brief Request a spin lock
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param plock    Pointer to the lock
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_spin_lock(t_void *pmoal_handle, t_void *plock)
+mlan_status moal_spin_lock(t_void *pmoal, t_void *plock)
+	__acquires(&plock->lock)
 {
 	moal_lock *mlock = plock;
 	unsigned long flags = 0;
-
-	if (mlock) {
-		spin_lock_irqsave(&mlock->lock, flags);
-		mlock->flags = flags;
-		return MLAN_STATUS_SUCCESS;
-	} else {
-		return MLAN_STATUS_FAILURE;
-	}
+	spin_lock_irqsave(&mlock->lock, flags);
+	mlock->flags = flags;
+	return MLAN_STATUS_SUCCESS;
 }
 
 /**
  *  @brief Request a spin_unlock
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param plock    Pointer to the lock
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_spin_unlock(t_void *pmoal_handle, t_void *plock)
+mlan_status moal_spin_unlock(t_void *pmoal, t_void *plock)
+	__releases(&plock->lock)
 {
 	moal_lock *mlock = (moal_lock *)plock;
+	spin_unlock_irqrestore(&mlock->lock, mlock->flags);
+	return MLAN_STATUS_SUCCESS;
+}
 
-	if (mlock) {
-		spin_unlock_irqrestore(&mlock->lock, mlock->flags);
+/**
+ *  @brief  This function collects AMSDU TP statistics.
+ *
+ *  @param pmoal Pointer to the MOAL context
+ *  @param amsdu_process_delay          amsdu process time
+ *  @param amsdu_copy_delay             amsdu copy time
+ *
+ *  @return         N/A
+ */
+void moal_amsdu_tp_accounting(t_void *pmoal, t_s32 amsdu_process_delay,
+			      t_s32 amsdu_copy_delay)
+{
+	moal_handle *handle = (moal_handle *)pmoal;
+	handle->tp_acnt.rx_amsdu_delay[handle->tp_acnt.rx_amsdu_index] =
+		amsdu_process_delay;
+	handle->tp_acnt.rx_amsdu_copy_delay[handle->tp_acnt.rx_amsdu_index] =
+		amsdu_copy_delay;
+	handle->tp_acnt.rx_amsdu_index++;
+	if (handle->tp_acnt.rx_amsdu_index >= TXRX_MAX_SAMPLE)
+		handle->tp_acnt.rx_amsdu_index = 0;
+}
 
-		return MLAN_STATUS_SUCCESS;
-	} else {
-		return MLAN_STATUS_FAILURE;
+/**
+ *  @brief  This function collects TP statistics.
+ *
+ *  @param pmoal Pointer to the MOAL context
+ *  @param buf          pointer to the buffer of a packet
+ *  @param drop_point   Drop pointer user set
+ *
+ *  @return         N/A
+ */
+void moal_tp_accounting(t_void *pmoal, void *buf, t_u32 drop_point)
+{
+	struct sk_buff *skb = NULL;
+	moal_handle *handle = (moal_handle *)pmoal;
+	pmlan_buffer pmbuf = (pmlan_buffer)buf;
+	t_s32 delay;
+	wifi_timeval t;
+
+	if (drop_point < MAX_TP_ACCOUNT_DROP_POINT_NUM) {
+		if (drop_point == 4 || drop_point == 3) {
+			handle->tp_acnt.tx_bytes[drop_point] += pmbuf->data_len;
+		} else {
+			skb = (struct sk_buff *)buf;
+			handle->tp_acnt.tx_bytes[drop_point] += skb->len;
+		}
+		handle->tp_acnt.tx_packets[drop_point]++;
+		if (drop_point == 3) {
+			woal_get_monotonic_time(&t);
+			pmbuf->extra_ts_sec = t.time_sec;
+			pmbuf->extra_ts_usec = t.time_usec;
+		}
+	} else if (drop_point <= RX_DROP_P5) {
+		t_u16 rx_len = 0;
+		if (drop_point == RX_DROP_P1 || drop_point == RX_DROP_P2)
+			rx_len = pmbuf->data_len -
+				 *((t_u16 *)(pmbuf->pbuf + pmbuf->data_offset) +
+				   2); // remove rx_pkt_offset
+		else if (drop_point == RX_DROP_P3) // aggr pkt
+			rx_len = pmbuf->data_len;
+		else if (drop_point == RX_DROP_P4) { // before to kernel
+			skb = (struct sk_buff *)buf;
+			rx_len = skb->len;
+		}
+		handle->tp_acnt
+			.rx_bytes[drop_point - MAX_TP_ACCOUNT_DROP_POINT_NUM] +=
+			rx_len;
+		handle->tp_acnt.rx_packets[drop_point -
+					   MAX_TP_ACCOUNT_DROP_POINT_NUM]++;
+	} else if (drop_point == RX_TIME_PKT) {
+		woal_get_monotonic_time(&t);
+		/* deque - pcie receive */
+		delay = (t_s32)(pmbuf->extra_ts_sec - pmbuf->in_ts_sec) *
+			1000000;
+		delay += (t_s32)(pmbuf->extra_ts_usec - pmbuf->in_ts_usec);
+		handle->tp_acnt.rx_delay1_driver[handle->tp_acnt.rx_index] =
+			delay;
+		/* before netif_rx - deque */
+		delay = (t_s32)(pmbuf->out_ts_sec - pmbuf->extra_ts_sec) *
+			1000000;
+		delay += (t_s32)(pmbuf->out_ts_usec - pmbuf->extra_ts_usec);
+		handle->tp_acnt.rx_delay2_driver[handle->tp_acnt.rx_index] =
+			delay;
+		/* netif_rx to netif_rx return */
+		delay = (t_s32)(t.time_sec - pmbuf->out_ts_sec) * 1000000;
+		delay += (t_s32)(t.time_usec - pmbuf->out_ts_usec);
+		handle->tp_acnt.rx_delay_kernel[handle->tp_acnt.rx_index] =
+			delay;
+		handle->tp_acnt.rx_index++;
+		if (handle->tp_acnt.rx_index >= TXRX_MAX_SAMPLE)
+			handle->tp_acnt.rx_index = 0;
+	} else if (drop_point == TX_TIME_PKT) {
+		delay = (t_s32)(pmbuf->extra_ts_sec - pmbuf->in_ts_sec) *
+			1000000;
+		delay += (t_s32)(pmbuf->extra_ts_usec - pmbuf->in_ts_usec);
+		handle->tp_acnt.tx_delay1_driver[handle->tp_acnt.tx_index] =
+			delay;
+
+		delay = (t_s32)(pmbuf->out_ts_sec - pmbuf->in_ts_sec) * 1000000;
+		delay += (t_s32)(pmbuf->out_ts_usec - pmbuf->in_ts_usec);
+		handle->tp_acnt.tx_delay_driver[handle->tp_acnt.tx_index] =
+			delay;
+
+		handle->tp_acnt.tx_index++;
+		if (handle->tp_acnt.tx_index >= TXRX_MAX_SAMPLE)
+			handle->tp_acnt.tx_index = 0;
+	}
+}
+
+void moal_tp_accounting_rx_param(t_void *pmoal, unsigned int type,
+				 unsigned int rsvd1)
+{
+	moal_handle *phandle = (moal_handle *)pmoal;
+	switch (type) {
+	case 0: // Rx interrupt
+		phandle->tp_acnt.rx_intr_cnt++;
+		break;
+	case 1: // rx_pkts_queued
+		phandle->tp_acnt.rx_pending = rsvd1;
+		break;
+	case 2: // paused
+		phandle->tp_acnt.rx_paused_cnt++;
+		break;
+	case 3: // tx interrupt count
+		phandle->tp_acnt.tx_intr_cnt++;
+		break;
+	case 4: // rx amsdu count
+		phandle->tp_acnt.rx_amsdu_cnt++;
+		phandle->tp_acnt.rx_amsdu_pkt_cnt += rsvd1;
+		break;
+	case 5: // tx amsdu count
+		phandle->tp_acnt.tx_amsdu_cnt++;
+		phandle->tp_acnt.tx_amsdu_pkt_cnt += rsvd1;
+		break;
+	case 6: // rxbd rdptr full count
+		phandle->tp_acnt.rx_rdptr_full_cnt++;
+		break;
+	case 7: // tx hard xmit skb realloc count
+		phandle->tp_acnt.tx_xmit_skb_realloc_cnt++;
+		break;
+	case 8: // tx stop queue count
+		phandle->tp_acnt.tx_stop_queue_cnt++;
+		break;
+
+	default:
+		break;
 	}
 }
 
 /**
  *  @brief This function reads one block of firmware data from MOAL
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param offset       Offset from where the data will be copied
  *  @param len          Length to be copied
  *  @param pbuf         Buffer where the data will be copied
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_get_fw_data(t_void *pmoal_handle, t_u32 offset, t_u32 len,
-			     t_u8 *pbuf)
+mlan_status moal_get_fw_data(t_void *pmoal, t_u32 offset, t_u32 len, t_u8 *pbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 
 	if (!pbuf || !len || !handle->firmware)
 		return MLAN_STATUS_FAILURE;
@@ -665,15 +846,15 @@ mlan_status moal_get_fw_data(t_void *pmoal_handle, t_u32 offset, t_u32 len,
 /**
  *  @brief This function get vdll data from moal
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param len          Length to be copied
  *  @param pbuf         Buffer where the data will be copied
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_get_vdll_data(t_void *pmoal_handle, t_u32 len, t_u8 *pbuf)
+mlan_status moal_get_vdll_data(t_void *pmoal, t_u32 len, t_u8 *pbuf)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	mlan_status status = MLAN_STATUS_FAILURE;
 	t_u32 offset = 0;
 	t_u8 req_fw = MFALSE;
@@ -706,18 +887,75 @@ mlan_status moal_get_vdll_data(t_void *pmoal_handle, t_u32 len, t_u8 *pbuf)
  *  @brief This function is called when MLAN completes the initialization
  * firmware.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param status   The status code for mlan_init_fw request
  *  @param phw      pointer to mlan_hw_info
  *  @param ptbl     pointer to mplan_bss_tbl
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_get_hw_spec_complete(t_void *pmoal_handle, mlan_status status,
+mlan_status moal_get_hw_spec_complete(t_void *pmoal, mlan_status status,
 				      mlan_hw_info *phw, pmlan_bss_tbl ptbl)
 {
+	moal_handle *handle = (moal_handle *)pmoal;
+	int i;
+	t_u32 drv_mode = handle->params.drv_mode;
+
 	ENTER();
 	if (status == MLAN_STATUS_SUCCESS) {
 		PRINTM(MCMND, "Get Hw Spec done, fw_cap=0x%x\n", phw->fw_cap);
+#ifdef PCIE9098
+		/** Special/Temporary handling to manage the driver version
+		 * string to identify Seahawk/AW690 (skyhawk based) based on
+		 * fw_cap_ext value set by Fw */
+		if (phw->fw_cap_ext & MBIT(31) &&
+		    IS_PCIE9098(handle->card_type)) {
+			moal_memcpy_ext(handle, driver_version, CARD_PCIEAW690,
+					strlen(CARD_PCIEAW690),
+					strlen(driver_version));
+			moal_memcpy_ext(handle,
+					driver_version + strlen(INTF_CARDTYPE) +
+						strlen(KERN_VERSION),
+					V17, strlen(V17),
+					strlen(driver_version) -
+						strlen(INTF_CARDTYPE) -
+						strlen(KERN_VERSION));
+			moal_memcpy_ext(handle, handle->driver_version,
+					driver_version, strlen(driver_version),
+					MLAN_MAX_VER_STR_LEN - 1);
+		}
+#endif
+		/** FW should only enable DFS on one mac */
+		if (!(phw->fw_cap & FW_CAPINFO_ZERO_DFS))
+			handle->params.drv_mode &= ~DRV_MODE_DFS;
+
+		if (!(phw->fw_cap & FW_CAPINFO_80211BGA))
+			handle->params.drv_mode &= ~DRV_MODE_WLAN;
+		if (!handle->params.drv_mode ||
+		    MLAN_STATUS_SUCCESS !=
+			    woal_update_drv_tbl(handle,
+						handle->params.drv_mode)) {
+			PRINTM(MERROR,
+			       "Get_hw_spec_complete: Fail to update drv_tbl\n");
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+		memset(ptbl, 0, sizeof(mlan_bss_tbl));
+		for (i = 0; i < handle->drv_mode.intf_num; i++) {
+			ptbl->bss_attr[i].bss_type =
+				handle->drv_mode.bss_attr[i].bss_type;
+			ptbl->bss_attr[i].frame_type =
+				handle->drv_mode.bss_attr[i].frame_type;
+			ptbl->bss_attr[i].active =
+				handle->drv_mode.bss_attr[i].active;
+			ptbl->bss_attr[i].bss_priority =
+				handle->drv_mode.bss_attr[i].bss_priority;
+			ptbl->bss_attr[i].bss_num =
+				handle->drv_mode.bss_attr[i].bss_num;
+			ptbl->bss_attr[i].bss_virtual =
+				handle->drv_mode.bss_attr[i].bss_virtual;
+		}
+		PRINTM(MCMND, "org_drv_mode=0x%x drv_mode=0x%x\n", drv_mode,
+		       handle->params.drv_mode);
 	}
 	LEAVE();
 	return MLAN_STATUS_SUCCESS;
@@ -727,14 +965,14 @@ mlan_status moal_get_hw_spec_complete(t_void *pmoal_handle, mlan_status status,
  *  @brief This function is called when MLAN completes the initialization
  * firmware.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param status   The status code for mlan_init_fw request
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_init_fw_complete(t_void *pmoal_handle, mlan_status status)
+mlan_status moal_init_fw_complete(t_void *pmoal, mlan_status status)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	ENTER();
 	if (status == MLAN_STATUS_SUCCESS)
 		handle->hardware_status = HardwareStatusReady;
@@ -747,14 +985,14 @@ mlan_status moal_init_fw_complete(t_void *pmoal_handle, mlan_status status)
 /**
  *  @brief This function is called when MLAN shutdown firmware is completed.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param status   The status code for mlan_shutdown request
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_shutdown_fw_complete(t_void *pmoal_handle, mlan_status status)
+mlan_status moal_shutdown_fw_complete(t_void *pmoal, mlan_status status)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	ENTER();
 	handle->hardware_status = HardwareStatusNotReady;
 	handle->init_wait_q_woken = MTRUE;
@@ -766,16 +1004,16 @@ mlan_status moal_shutdown_fw_complete(t_void *pmoal_handle, mlan_status status)
 /**
  *  @brief This function is called when an MLAN IOCTL is completed.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pioctl_req	pointer to structure mlan_ioctl_req
  *  @param status   The status code for mlan_ioctl request
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_ioctl_complete(t_void *pmoal_handle,
-				pmlan_ioctl_req pioctl_req, mlan_status status)
+mlan_status moal_ioctl_complete(t_void *pmoal, pmlan_ioctl_req pioctl_req,
+				mlan_status status)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	moal_private *priv = NULL;
 	wait_queue *wait;
 	unsigned long flags = 0;
@@ -796,7 +1034,7 @@ mlan_status moal_ioctl_complete(t_void *pmoal_handle,
 	}
 
 	if (status != MLAN_STATUS_SUCCESS && status != MLAN_STATUS_COMPLETE)
-		PRINTM(MERROR,
+		PRINTM(MIOCTL,
 		       "IOCTL failed: %p id=0x%x, sub_id=0x%x action=%d, status_code=0x%x\n",
 		       pioctl_req, pioctl_req->req_id,
 		       (*(t_u32 *)pioctl_req->pbuf), (int)pioctl_req->action,
@@ -839,16 +1077,16 @@ mlan_status moal_ioctl_complete(t_void *pmoal_handle,
 /**
  *  @brief This function allocates mlan_buffer.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param size     allocation size requested
  *  @param pmbuf    pointer to pointer to the allocated buffer
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_alloc_mlan_buffer(t_void *pmoal_handle, t_u32 size,
+mlan_status moal_alloc_mlan_buffer(t_void *pmoal, t_u32 size,
 				   pmlan_buffer *pmbuf)
 {
-	*pmbuf = woal_alloc_mlan_buffer((moal_handle *)pmoal_handle, size);
+	*pmbuf = woal_alloc_mlan_buffer((moal_handle *)pmoal, size);
 	if (NULL == *pmbuf)
 		return MLAN_STATUS_FAILURE;
 	return MLAN_STATUS_SUCCESS;
@@ -857,33 +1095,33 @@ mlan_status moal_alloc_mlan_buffer(t_void *pmoal_handle, t_u32 size,
 /**
  *  @brief This function frees mlan_buffer.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    pointer to buffer to be freed
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_free_mlan_buffer(t_void *pmoal_handle, pmlan_buffer pmbuf)
+mlan_status moal_free_mlan_buffer(t_void *pmoal, pmlan_buffer pmbuf)
 {
 	if (!pmbuf)
 		return MLAN_STATUS_FAILURE;
-	woal_free_mlan_buffer((moal_handle *)pmoal_handle, pmbuf);
+	woal_free_mlan_buffer((moal_handle *)pmoal, pmbuf);
 	return MLAN_STATUS_SUCCESS;
 }
 
 /**
  *  @brief This function is called when MLAN complete send data packet.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *  @param status   The status code for mlan_send_packet request
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_send_packet_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
+mlan_status moal_send_packet_complete(t_void *pmoal, pmlan_buffer pmbuf,
 				      mlan_status status)
 {
 	moal_private *priv = NULL;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	struct sk_buff *skb = NULL;
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 	t_u32 index = 0;
@@ -896,7 +1134,7 @@ mlan_status moal_send_packet_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
 		goto done;
 	}
 	if (pmbuf) {
-		priv = woal_bss_index_to_priv(pmoal_handle, pmbuf->bss_index);
+		priv = woal_bss_index_to_priv(pmoal, pmbuf->bss_index);
 		skb = (struct sk_buff *)pmbuf->pdesc;
 		if (priv) {
 			woal_set_trans_start(priv->netdev);
@@ -904,38 +1142,50 @@ mlan_status moal_send_packet_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
 				if (status == MLAN_STATUS_SUCCESS) {
 					priv->stats.tx_packets++;
 					priv->stats.tx_bytes += skb->len;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 					woal_packet_fate_monitor(
 						priv, PACKET_TYPE_TX,
 						TX_PKT_FATE_SENT,
 						FRAME_TYPE_ETHERNET_II, 0, 0,
 						skb->data, skb->data_len);
+#endif
 #endif
 				} else {
 					priv->stats.tx_errors++;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 					woal_packet_fate_monitor(
 						priv, PACKET_TYPE_TX,
 						TX_PKT_FATE_DRV_DROP_OTHER,
 						FRAME_TYPE_ETHERNET_II, 0, 0,
 						skb->data, skb->data_len);
+#endif
 #endif
 				}
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
 				index = skb_get_queue_mapping(skb);
-				atomic_dec(&handle->tx_pending);
-				if (atomic_dec_return(
-					    &priv->wmm_tx_pending[index]) ==
-				    LOW_TX_PENDING) {
-					struct netdev_queue *txq =
-						netdev_get_tx_queue(
-							priv->netdev, index);
-					if (netif_tx_queue_stopped(txq)) {
-						netif_tx_wake_queue(txq);
-						PRINTM(MINFO,
-						       "Wakeup Kernel Queue:%d\n",
-						       index);
+				if (index < 4) {
+					atomic_dec(&handle->tx_pending);
+					if (atomic_dec_return(
+						    &priv->wmm_tx_pending[index]) ==
+					    LOW_TX_PENDING) {
+						struct netdev_queue *txq =
+							netdev_get_tx_queue(
+								priv->netdev,
+								index);
+						if (netif_tx_queue_stopped(
+							    txq)) {
+							netif_tx_wake_queue(
+								txq);
+							PRINTM(MINFO,
+							       "Wakeup Kernel Queue:%d\n",
+							       index);
+						}
 					}
+				} else {
+					PRINTM(MERROR,
+					       "Invalid queue index for skb\n");
 				}
 #else /*#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)*/
 				if (atomic_dec_return(&handle->tx_pending) <
@@ -1002,18 +1252,18 @@ mlan_status moal_send_packet_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
  *  @brief This function is called when MLAN complete receiving
  *         data/event/command
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *  @param port     Port number for receive
  *  @param status   The status code for mlan_receive request
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_recv_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
-			       t_u32 port, mlan_status status)
+mlan_status moal_recv_complete(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+			       mlan_status status)
 {
 	moal_private *priv = NULL;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	struct usb_card_rec *cardp = (struct usb_card_rec *)handle->card;
 	ENTER();
 
@@ -1032,13 +1282,13 @@ mlan_status moal_recv_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
 		else {
 			woal_free_mlan_buffer(handle, pmbuf);
 			if ((atomic_read(&handle->rx_pending) <
-			     LOW_RX_PENDING) &&
+			     USB_LOW_RX_PENDING) &&
 			    atomic_read(&cardp->rx_data_urb_pending) <
 				    MVUSB_RX_DATA_URB)
 				woal_usb_submit_rx_data_urbs(handle);
 		}
 	} else if (port == cardp->rx_data_ep) {
-		if ((atomic_read(&handle->rx_pending) < LOW_RX_PENDING) &&
+		if ((atomic_read(&handle->rx_pending) < USB_LOW_RX_PENDING) &&
 		    atomic_read(&cardp->rx_data_urb_pending) <
 			    MVUSB_RX_DATA_URB)
 			woal_usb_submit_rx_data_urbs(handle);
@@ -1050,17 +1300,16 @@ mlan_status moal_recv_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
 /**
  *  @brief This function write a command/data packet to card.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *  @param port     Port number for sent
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE or
  * MLAN_STATUS_PENDING or MLAN_STATUS_RESOURCE
  */
-mlan_status moal_write_data_async(t_void *pmoal_handle, pmlan_buffer pmbuf,
-				  t_u32 port)
+mlan_status moal_write_data_async(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	ENTER();
 	if (handle->is_suspended == MTRUE) {
@@ -1069,8 +1318,7 @@ mlan_status moal_write_data_async(t_void *pmoal_handle, pmlan_buffer pmbuf,
 		LEAVE();
 		return MLAN_STATUS_FAILURE;
 	}
-	ret = woal_write_data_async((moal_handle *)pmoal_handle, pmbuf,
-				    (t_u8)port);
+	ret = woal_write_data_async((moal_handle *)pmoal, pmbuf, (t_u8)port);
 	LEAVE();
 	return ret;
 }
@@ -1080,17 +1328,17 @@ mlan_status moal_write_data_async(t_void *pmoal_handle, pmlan_buffer pmbuf,
  *  @brief This function write a command/data packet to card.
  *         This function blocks the call until it finishes
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *  @param port     Port number for sent
  *  @param timeout  Timeout value in milliseconds (if 0 the wait is forever)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_write_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
-				 t_u32 port, t_u32 timeout)
+mlan_status moal_write_data_sync(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+				 t_u32 timeout)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	return handle->ops.write_data_sync(handle, pmbuf, port, timeout);
 }
 
@@ -1098,17 +1346,17 @@ mlan_status moal_write_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
  *  @brief This function read data packet/event/command from card.
  *         This function blocks the call until it finish
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *  @param port     Port number for read
  *  @param timeout  Timeout value in milliseconds (if 0 the wait is forever)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_read_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
-				t_u32 port, t_u32 timeout)
+mlan_status moal_read_data_sync(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+				t_u32 timeout)
 {
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	return handle->ops.read_data_sync(handle, pmbuf, port, timeout);
 }
 
@@ -1116,16 +1364,16 @@ mlan_status moal_read_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
 /**
  *  @brief This function writes data into card register.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param reg          register offset
  *  @param data         value
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_write_reg(t_void *pmoal_handle, t_u32 reg, t_u32 data)
+mlan_status moal_write_reg(t_void *pmoal, t_u32 reg, t_u32 data)
 {
 	int ret = MLAN_STATUS_FAILURE;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	if (handle->ops.write_reg)
 		ret = handle->ops.write_reg(handle, reg, data);
 	return ret;
@@ -1134,16 +1382,16 @@ mlan_status moal_write_reg(t_void *pmoal_handle, t_u32 reg, t_u32 data)
 /**
  *  @brief This function reads data from card register.
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param reg          register offset
  *  @param data         value
  *
  *  @return             MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_read_reg(t_void *pmoal_handle, t_u32 reg, t_u32 *data)
+mlan_status moal_read_reg(t_void *pmoal, t_u32 reg, t_u32 *data)
 {
 	int ret = MLAN_STATUS_FAILURE;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	if (handle->ops.read_reg)
 		ret = handle->ops.read_reg(handle, reg, data);
 	return ret;
@@ -1151,20 +1399,713 @@ mlan_status moal_read_reg(t_void *pmoal_handle, t_u32 reg, t_u32 *data)
 
 #endif /* SDIO || PCIE */
 
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+
+#define DOT11_MAX_PRIORITY 8
+#define IEEE80211_RADIOTAP_HE 23
+
+t_u8 ru_signal[16][9] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08},
+			 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x07},
+			 {0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x07},
+			 {0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0xff, 0x01, 0x06},
+			 {0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x07},
+			 {0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0xff, 0x01, 0x06},
+			 {0x00, 0x00, 0xff, 0x01, 0xff, 0x01, 0x00, 0x00, 0x06},
+			 {0x00, 0x00, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0x05},
+			 {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
+			 {0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0xff, 0x01, 0x06},
+			 {0xff, 0x01, 0x00, 0x00, 0xff, 0x01, 0x00, 0x00, 0x06},
+			 {0xff, 0x01, 0x00, 0x00, 0xff, 0x01, 0xff, 0x01, 0x05},
+			 {0xff, 0x01, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x06},
+			 {0xff, 0x01, 0xff, 0x01, 0x00, 0x00, 0xff, 0x01, 0x05},
+			 {0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0x00, 0x00, 0x05},
+			 {0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01,
+			  0x04}};
+
+t_u8 ru_signal_106[14][9] = {
+	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00},
+	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00},
+	{0xff, 0x01, 0xff, 0x01, 0xff, 0xff, 0xff, 0x02, 0x03},
+	{0xff, 0xff, 0xff, 0x02, 0xff, 0x01, 0xff, 0x01, 0x03},
+	{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x02, 0x05},
+	{0x00, 0x00, 0xff, 0x01, 0xff, 0xff, 0xff, 0x02, 0x04},
+	{0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0xff, 0x02, 0x04},
+	{0xff, 0x01, 0xff, 0x01, 0xff, 0xff, 0xff, 0x02, 0x03},
+	{0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x05},
+	{0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0xff, 0x01, 0x04},
+	{0xff, 0xff, 0xff, 0x02, 0xff, 0x01, 0x00, 0x00, 0x04},
+	{0xff, 0xff, 0xff, 0x02, 0xff, 0x01, 0xff, 0x01, 0x03},
+	{0xff, 0xff, 0xff, 0x02, 0xff, 0xff, 0xff, 0x02, 0x02},
+	{0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0x04}};
+
+t_u8 ru_signal_52[9] = {0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0xff, 0x01, 0x04};
+/**
+ *  @brief This function uploads the packet to the network stack monitor
+ * interface
+ *
+ *  @param handle Pointer to the MOAL context
+ *  @param pmbuf    Pointer to mlan_buffer
+ *
+ *  @return  MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING/MLAN_STATUS_FAILURE
+ */
+static mlan_status moal_recv_packet_to_mon_if(moal_handle *handle,
+					      pmlan_buffer pmbuf)
+{
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	struct sk_buff *skb = NULL;
+	struct radiotap_header *rth = NULL;
+	radiotap_info rt_info = {};
+	t_u8 format = 0;
+	t_u8 mcs = 0;
+	t_u8 nss = 0;
+	t_u8 bw = 0;
+	t_u8 gi = 0;
+	t_u8 ldpc = 0;
+	t_u8 chan_num;
+	t_u8 band = 0;
+	struct ieee80211_hdr *dot11_hdr = NULL;
+	t_u8 *payload = NULL;
+	t_u32 vht_sig1 = 0;
+	t_u32 vht_sig2 = 0;
+	t_u32 he_sig1 = 0;
+	t_u32 he_sig2 = 0;
+	t_u32 usr_idx = 0;
+	t_u32 out = 0;
+	t_u32 tone = 0;
+	t_u8 dcm = 0;
+	ENTER();
+	if (!pmbuf->pdesc) {
+		LEAVE();
+		return status;
+	}
+
+	skb = (struct sk_buff *)pmbuf->pdesc;
+
+	if ((handle->mon_if) && netif_running(handle->mon_if->mon_ndev)) {
+		if (handle->mon_if->radiotap_enabled) {
+			if (skb_headroom(skb) < sizeof(*rth)) {
+				PRINTM(MERROR,
+				       "%s No space to add Radio TAP header\n",
+				       __func__);
+				status = MLAN_STATUS_FAILURE;
+				handle->mon_if->stats.rx_dropped++;
+				goto done;
+			}
+			dot11_hdr =
+				(struct ieee80211_hdr *)(pmbuf->pbuf +
+							 pmbuf->data_offset);
+			moal_memcpy_ext(handle, &rt_info,
+					pmbuf->pbuf + pmbuf->data_offset -
+						sizeof(rt_info),
+					sizeof(rt_info), sizeof(rt_info));
+			ldpc = (rt_info.rate_info.rate_info & 0x20) >> 5;
+			format = (rt_info.rate_info.rate_info & 0x18) >> 3;
+			bw = (rt_info.rate_info.rate_info & 0x06) >> 1;
+			dcm = rt_info.rate_info.dcm;
+			if (format == MLAN_RATE_FORMAT_HE)
+				gi = (rt_info.rate_info.rate_info & 0xC0) >> 6;
+			else
+
+				gi = rt_info.rate_info.rate_info & 0x01;
+			mcs = rt_info.rate_info.mcs_index;
+			nss = rt_info.rate_info.nss_index;
+
+			skb_push(skb, sizeof(*rth));
+			rth = (struct radiotap_header *)skb->data;
+			memset(skb->data, 0, sizeof(*rth));
+			rth->hdr.it_version = PKTHDR_RADIOTAP_VERSION;
+			rth->hdr.it_pad = 0;
+			rth->hdr.it_len = cpu_to_le16(sizeof(*rth));
+			rth->hdr.it_present = cpu_to_le32(
+				(1 << IEEE80211_RADIOTAP_TSFT) |
+				(1 << IEEE80211_RADIOTAP_FLAGS) |
+				(1 << IEEE80211_RADIOTAP_CHANNEL) |
+				(1 << IEEE80211_RADIOTAP_DBM_ANTSIGNAL) |
+				(1 << IEEE80211_RADIOTAP_DBM_ANTNOISE) |
+				(1 << IEEE80211_RADIOTAP_ANTENNA));
+			/** Timstamp */
+			rth->body.timestamp = woal_cpu_to_le64(jiffies);
+			/** Flags */
+			rth->body.flags = (rt_info.extra_info.flags &
+					   ~(RADIOTAP_FLAGS_USE_SGI_HT |
+					     RADIOTAP_FLAGS_WITH_FRAGMENT |
+					     RADIOTAP_FLAGS_WEP_ENCRYPTION |
+					     RADIOTAP_FLAGS_FAILED_FCS_CHECK));
+			/** reverse fail fcs, 1 means pass FCS in FW, but means
+			 * fail FCS in radiotap */
+			rth->body.flags |= (~rt_info.extra_info.flags) &
+					   RADIOTAP_FLAGS_FAILED_FCS_CHECK;
+			if ((format == MLAN_RATE_FORMAT_HT) && (gi == 1))
+				rth->body.flags |= RADIOTAP_FLAGS_USE_SGI_HT;
+			if (ieee80211_is_mgmt(dot11_hdr->frame_control) ||
+			    ieee80211_is_data(dot11_hdr->frame_control)) {
+				if ((ieee80211_has_morefrags(
+					    dot11_hdr->frame_control)) ||
+				    (!ieee80211_is_first_frag(
+					    dot11_hdr->seq_ctrl))) {
+					rth->body.flags |=
+						RADIOTAP_FLAGS_WITH_FRAGMENT;
+				}
+			}
+			if (ieee80211_is_data(dot11_hdr->frame_control) &&
+			    ieee80211_has_protected(dot11_hdr->frame_control)) {
+				payload = (t_u8 *)dot11_hdr +
+					  ieee80211_hdrlen(
+						  dot11_hdr->frame_control);
+				if (!(*(payload + 3) & 0x20)) /** ExtIV bit
+								 shall be 0 for
+								 WEP frame */
+					rth->body.flags |=
+						RADIOTAP_FLAGS_WEP_ENCRYPTION;
+			}
+			/** Rate, t_u8 only apply for LG mode */
+			if (format == MLAN_RATE_FORMAT_LG) {
+				rth->hdr.it_present |= cpu_to_le32(
+					1 << IEEE80211_RADIOTAP_RATE);
+				rth->body.rate = rt_info.rate_info.bitrate;
+			}
+			/** Channel */
+			rth->body.channel.flags = 0;
+			if (rt_info.chan_num &&
+			    (handle->mon_if->band_chan_cfg.channel !=
+			     rt_info.chan_num))
+				handle->mon_if->band_chan_cfg.channel =
+					rt_info.chan_num;
+			chan_num = handle->mon_if->band_chan_cfg.channel;
+
+			band = (chan_num <= 14) ? IEEE80211_BAND_2GHZ :
+						  IEEE80211_BAND_5GHZ;
+			/** update the band, if different in the Rx frame */
+			if (handle->mon_if->band_chan_cfg.band != band)
+				handle->mon_if->band_chan_cfg.band = band;
+
+			rth->body.channel.frequency = woal_cpu_to_le16(
+				ieee80211_channel_to_frequency(chan_num, band));
+			rth->body.channel.flags |=
+				woal_cpu_to_le16((band == IEEE80211_BAND_2GHZ) ?
+							 CHANNEL_FLAGS_2GHZ :
+							 CHANNEL_FLAGS_5GHZ);
+			if (rth->body.channel.flags &
+			    woal_cpu_to_le16(CHANNEL_FLAGS_2GHZ))
+				rth->body.channel.flags |= woal_cpu_to_le16(
+					CHANNEL_FLAGS_DYNAMIC_CCK_OFDM);
+			else
+				rth->body.channel.flags |=
+					woal_cpu_to_le16(CHANNEL_FLAGS_OFDM);
+			if (handle->mon_if->chandef.chan &&
+			    (handle->mon_if->chandef.chan->flags &
+			     (IEEE80211_CHAN_PASSIVE_SCAN |
+			      IEEE80211_CHAN_RADAR)))
+				rth->body.channel.flags |= woal_cpu_to_le16(
+					CHANNEL_FLAGS_ONLY_PASSIVSCAN_ALLOW);
+			/** Antenna */
+			rth->body.antenna_signal = -(rt_info.nf - rt_info.snr);
+			rth->body.antenna_noise = -rt_info.nf;
+			/* Convert FW antenna value to radiotap spec */
+			rth->body.antenna = (t_u16)rt_info.antenna >> 1;
+			/** MCS */
+			if (format == MLAN_RATE_FORMAT_HT) {
+				rth->hdr.it_present |= cpu_to_le32(
+					1 << IEEE80211_RADIOTAP_MCS);
+				rth->body.u.mcs.known =
+					rt_info.extra_info.mcs_known;
+				rth->body.u.mcs.flags =
+					rt_info.extra_info.mcs_flags;
+				/** MCS mcs */
+				rth->body.u.mcs.known |=
+					MCS_KNOWN_MCS_INDEX_KNOWN;
+				rth->body.u.mcs.mcs =
+					rt_info.rate_info.mcs_index;
+				/** MCS bw */
+				rth->body.u.mcs.known |= MCS_KNOWN_BANDWIDTH;
+				rth->body.u.mcs.flags &= ~(0x03); /** Clear,
+								     20MHz as
+								     default */
+				if (bw == 1)
+					rth->body.u.mcs.flags |= RX_BW_40;
+				/** MCS gi */
+				rth->body.u.mcs.known |=
+					MCS_KNOWN_GUARD_INTERVAL;
+				rth->body.u.mcs.flags &= ~(1 << 2);
+				if (gi)
+					rth->body.u.mcs.flags |= gi << 2;
+				/** MCS FEC */
+				rth->body.u.mcs.known |= MCS_KNOWN_FEC_TYPE;
+				rth->body.u.mcs.flags &= ~(1 << 4);
+				if (ldpc)
+					rth->body.u.mcs.flags |= ldpc << 4;
+			}
+			/** VHT */
+			if (format == MLAN_RATE_FORMAT_VHT) {
+				vht_sig1 = rt_info.extra_info.vht_he_sig1;
+				vht_sig2 = rt_info.extra_info.vht_he_sig2;
+				/** Present Flag */
+				rth->hdr.it_present |= cpu_to_le32(
+					1 << IEEE80211_RADIOTAP_VHT);
+				/** STBC */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_STBC);
+				if (vht_sig1 & MBIT(3))
+					rth->body.u.vht.flags |= VHT_FLAG_STBC;
+				/** TXOP_PS_NA */
+				/** TODO: Not support now */
+				/** GI */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_GI);
+				if (vht_sig2 & MBIT(0))
+					rth->body.u.vht.flags |= VHT_FLAG_SGI;
+				/** SGI NSYM DIS */
+				rth->body.u.vht.known |= woal_cpu_to_le16(
+					VHT_KNOWN_SGI_NSYM_DIS);
+				if (vht_sig2 & MBIT(1))
+					rth->body.u.vht.flags |=
+						VHT_FLAG_SGI_NSYM_M10_9;
+				/** LDPC_EXTRA_OFDM_SYM */
+				/** TODO: Not support now */
+				/** BEAMFORMED */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_BEAMFORMED);
+				if (vht_sig2 & MBIT(8))
+					rth->body.u.vht.flags |=
+						VHT_FLAG_BEAMFORMED;
+				/** BANDWIDTH */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_BANDWIDTH);
+				if (bw == 1)
+					rth->body.u.vht.bandwidth = RX_BW_40;
+				else if (bw == 2)
+					rth->body.u.vht.bandwidth = RX_BW_80;
+				/** GROUP_ID */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_GROUP_ID);
+				rth->body.u.vht.group_id =
+					(vht_sig1 & (0x3F0)) >> 4;
+				/** PARTIAL_AID */
+				/** TODO: Not support now */
+				/** mcs_nss */
+				rth->body.u.vht.mcs_nss[0] = vht_sig2 & (0xF0);
+				/* Convert FW NSS value to radiotap spec */
+				rth->body.u.vht.mcs_nss[0] |=
+					((vht_sig1 & (0x1C00)) >> 10) + 1;
+				/** gi */
+				rth->body.u.vht.known |=
+					woal_cpu_to_le16(VHT_KNOWN_GI);
+				if (gi)
+					rth->body.u.vht.flags |= VHT_FLAG_SGI;
+				/** coding */
+				if (vht_sig2 & MBIT(2))
+					rth->body.u.vht.coding |=
+						VHT_CODING_LDPC_USER0;
+			}
+			if (format == MLAN_RATE_FORMAT_HE) {
+				he_sig1 = rt_info.extra_info.vht_he_sig1;
+				he_sig2 = rt_info.extra_info.vht_he_sig2;
+				usr_idx = rt_info.extra_info.user_idx;
+				rth->hdr.it_present |=
+					cpu_to_le32(1 << IEEE80211_RADIOTAP_HE);
+				rth->body.u.he.data1 |= (HE_CODING_KNOWN);
+				if (ldpc)
+					rth->body.u.he.data3 |=
+						HE_CODING_LDPC_USER0;
+				rth->body.u.he.data1 |= (HE_BW_KNOWN);
+				if (he_sig1)
+					rth->body.u.he.data1 |= (HE_MU_DATA);
+				if (bw == 1) {
+					rth->body.u.he.data5 |= RX_HE_BW_40;
+					if (he_sig2) {
+						MLAN_DECODE_RU_SIGNALING_CH1(
+							out, he_sig1, he_sig2);
+						MLAN_DECODE_RU_TONE(
+							out, usr_idx, tone);
+						if (!tone) {
+							MLAN_DECODE_RU_SIGNALING_CH3(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (tone != 0) {
+							rth->body.u.he.data5 &=
+								~RX_HE_BW_40;
+							rth->body.u.he.data5 |=
+								tone;
+						}
+					}
+				} else if (bw == 2) {
+					rth->body.u.he.data5 |= RX_HE_BW_80;
+					if (he_sig2) {
+						MLAN_DECODE_RU_SIGNALING_CH1(
+							out, he_sig1, he_sig2);
+						MLAN_DECODE_RU_TONE(
+							out, usr_idx, tone);
+						if (!tone) {
+							MLAN_DECODE_RU_SIGNALING_CH2(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (!tone) {
+							if ((he_sig2 &
+							     MLAN_80_CENTER_RU) &&
+							    !usr_idx) {
+								tone = RU_TONE_26;
+							} else {
+								usr_idx--;
+							}
+						}
+						if (!tone) {
+							MLAN_DECODE_RU_SIGNALING_CH3(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (!tone) {
+							MLAN_DECODE_RU_SIGNALING_CH4(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (tone != 0) {
+							rth->body.u.he.data5 &=
+								~RX_HE_BW_80;
+							rth->body.u.he.data5 |=
+								tone;
+						}
+					}
+				} else if (bw == 3) {
+					rth->body.u.he.data5 |= RX_HE_BW_160;
+					if (he_sig2) {
+						MLAN_DECODE_RU_SIGNALING_CH1(
+							out, he_sig1, he_sig2);
+						MLAN_DECODE_RU_TONE(
+							out, usr_idx, tone);
+						if (!tone) {
+							MLAN_DECODE_RU_SIGNALING_CH2(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (!tone) {
+							if ((he_sig2 &
+							     MLAN_160_CENTER_RU) &&
+							    !usr_idx) {
+								tone = RU_TONE_26;
+							} else {
+								usr_idx--;
+							}
+						}
+						if (!tone) {
+							MLAN_DECODING_160_RU_CH3(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (!tone) {
+							MLAN_DECODING_160_RU_CH3(
+								out, he_sig1,
+								he_sig2);
+							MLAN_DECODE_RU_TONE(
+								out, usr_idx,
+								tone);
+						}
+						if (tone != 0) {
+							rth->body.u.he.data5 &=
+								~RX_HE_BW_160;
+							rth->body.u.he.data5 |=
+								tone;
+						}
+					}
+				} else {
+					if (he_sig2) {
+						MLAN_DECODE_RU_SIGNALING_CH1(
+							out, he_sig1, he_sig2);
+						MLAN_DECODE_RU_TONE(
+							out, usr_idx, tone);
+						if (tone) {
+							rth->body.u.he.data5 |=
+								tone;
+						}
+					}
+				}
+
+				rth->body.u.he.data2 |= (HE_DATA_GI_KNOWN);
+				rth->body.u.he.data5 |= ((gi & 3) << 4);
+				rth->body.u.he.data1 |= (HE_MCS_KNOWN);
+
+				rth->body.u.he.data3 |= (mcs << 8);
+				rth->body.u.he.data6 |= nss;
+				rth->body.u.he.data1 |= (HE_DCM_KNOWN);
+				rth->body.u.he.data1 =
+					cpu_to_le16(rth->body.u.he.data1);
+				rth->body.u.he.data5 |= (dcm << 12);
+				rth->body.u.he.data5 =
+					cpu_to_le16(rth->body.u.he.data5);
+				rth->body.u.he.data3 =
+					cpu_to_le16(rth->body.u.he.data3);
+			}
+		}
+		skb_set_mac_header(skb, 0);
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+		skb->pkt_type = PACKET_OTHERHOST;
+		skb->protocol = htons(ETH_P_802_2);
+		memset(skb->cb, 0, sizeof(skb->cb));
+		skb->dev = handle->mon_if->mon_ndev;
+
+		handle->mon_if->stats.rx_bytes += skb->len;
+		handle->mon_if->stats.rx_packets++;
+
+		if (in_interrupt())
+			netif_rx(skb);
+		else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+			netif_rx(skb);
+#else
+			netif_rx_ni(skb);
+#endif
+
+		status = MLAN_STATUS_PENDING;
+	}
+
+done:
+
+	LEAVE();
+	return status;
+}
+#endif
+#endif
+
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+/**
+ *  @brief This function get binded net_device from station list
+ *
+ *  @param priv Pointer to structure moal_private
+ *  @param aid    station aid from mlan
+ *
+ *  @return    binded net_device pointer or NULL if not found
+ */
+struct net_device *moal_get_netdev_from_stalist(moal_private *priv, t_u16 aid)
+{
+	station_node *sta_node = NULL;
+
+	ENTER();
+	sta_node = priv->vlan_sta_list[(aid - 1) % MAX_STA_COUNT];
+	if (sta_node) {
+		LEAVE();
+		return sta_node->netdev;
+	}
+	LEAVE();
+	return NULL;
+}
+#endif
+#endif
+
+/**
+ *  @brief This function uploads amsdu packet to the network stack
+ *
+ *  @param pmoal Pointer to the MOAL context
+ *  @param pmbuf    Pointer to the mlan buffer structure
+ *
+ *  @return         MLAN_STATUS_PENDING or MLAN_STATUS_FAILURE
+ */
+mlan_status moal_recv_amsdu_packet(t_void *pmoal, pmlan_buffer pmbuf)
+{
+	mlan_status status = MLAN_STATUS_FAILURE;
+	struct sk_buff *skb = NULL;
+	struct sk_buff *frame = NULL;
+	int remaining;
+	const struct ethhdr *eth;
+	u8 dst[ETH_ALEN], src[ETH_ALEN];
+	moal_handle *handle = (moal_handle *)pmoal;
+	moal_private *priv = NULL;
+	struct net_device *netdev = NULL;
+	u8 *payload;
+	mlan_buffer mbuf;
+	t_u8 drop = 0;
+	t_u8 rfc1042_eth_hdr[MLAN_MAC_ADDR_LENGTH] = {0xaa, 0xaa, 0x03,
+						      0x00, 0x00, 0x00};
+
+	wifi_timeval t1, t2;
+	t_s32 delay;
+	t_u32 in_ts_sec = 0;
+	t_u32 in_ts_usec = 0;
+
+	ENTER();
+	if (!pmbuf) {
+		PRINTM(MERROR, "%s: pmbuf is null\n", __func__);
+		goto done;
+	}
+
+	memset(&mbuf, 0, sizeof(mlan_buffer));
+	mbuf.bss_index = pmbuf->bss_index;
+
+	priv = woal_bss_index_to_priv(pmoal, pmbuf->bss_index);
+	if (priv == NULL) {
+		PRINTM(MERROR, "%s: priv is null\n", __func__);
+		goto done;
+	}
+	netdev = priv->netdev;
+	skb = (struct sk_buff *)pmbuf->pdesc;
+	if (!skb)
+		goto done;
+
+	skb_reserve(skb, pmbuf->data_offset);
+	if (skb_tailroom(skb) < (int)pmbuf->data_len) {
+		PRINTM(MERROR, "skb overflow: tail room=%d, data_len=%d\n",
+		       skb_tailroom(skb), pmbuf->data_len);
+		goto done;
+	}
+	skb_put(skb, pmbuf->data_len);
+
+	// rx_trace 8
+	if (handle->tp_acnt.on) {
+		moal_tp_accounting(pmoal, skb, RX_DROP_P4);
+		woal_get_monotonic_time(&t1);
+		in_ts_sec = t1.time_sec;
+		in_ts_usec = t1.time_usec;
+		if (pmbuf->in_ts_sec) {
+			pmbuf->out_ts_sec = t1.time_sec;
+			pmbuf->out_ts_usec = t1.time_usec;
+		}
+	}
+	if (handle->tp_acnt.drop_point == RX_DROP_P4) {
+		status = MLAN_STATUS_PENDING;
+		dev_kfree_skb(skb);
+		goto done;
+	}
+
+	while (skb != frame) {
+		__be16 len;
+		u8 padding;
+		unsigned int subframe_len;
+		eth = (struct ethhdr *)skb->data;
+		len = ntohs(eth->h_proto);
+		subframe_len = sizeof(struct ethhdr) + len;
+		remaining = skb->len;
+
+		if (subframe_len > remaining) {
+			PRINTM(MERROR,
+			       "Error in len: remaining = %d, subframe_len = %d\n",
+			       remaining, subframe_len);
+			break;
+		}
+		memcpy(dst, eth->h_dest, ETH_ALEN);
+		memcpy(src, eth->h_source, ETH_ALEN);
+
+		padding = (4 - subframe_len) & 0x3;
+
+		skb_pull(skb, sizeof(struct ethhdr));
+
+		if (remaining <= (subframe_len + padding)) {
+			frame = skb;
+			status = MLAN_STATUS_PENDING;
+		} else {
+			frame = skb_clone(skb, GFP_ATOMIC);
+			if (!frame) {
+				PRINTM(MERROR,
+				       " AMSDU RECV:skb_clone returned NULL\n");
+				break;
+			}
+
+			skb_trim(frame, len);
+			eth = (struct ethhdr *)skb_pull(skb, len + padding);
+			if (!eth) {
+				PRINTM(MERROR, "Invalid amsdu packet\n");
+				break;
+			}
+		}
+		skb_reset_network_header(frame);
+		frame->dev = netdev;
+		frame->priority = skb->priority;
+		payload = frame->data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+		if (ether_addr_equal(payload, rfc1042_eth_hdr)) {
+#else
+		if (!memcmp(payload, rfc1042_eth_hdr,
+			    sizeof(rfc1042_eth_hdr))) {
+#endif
+			/* Remove RFC1042 */
+			skb_pull(frame, 6);
+			memcpy(skb_push(frame, ETH_ALEN), src, ETH_ALEN);
+			memcpy(skb_push(frame, ETH_ALEN), dst, ETH_ALEN);
+		} else {
+			memcpy(skb_push(frame, sizeof(__be16)), &len,
+			       sizeof(__be16));
+			memcpy(skb_push(frame, ETH_ALEN), src, ETH_ALEN);
+			memcpy(skb_push(frame, ETH_ALEN), dst, ETH_ALEN);
+		}
+		mbuf.pbuf = frame->data;
+		mbuf.data_len = frame->len;
+		mlan_process_deaggr_pkt(handle->pmlan_adapter, &mbuf, &drop);
+		if (drop) {
+			dev_kfree_skb(frame);
+			continue;
+		}
+		frame->protocol = eth_type_trans(frame, netdev);
+		frame->ip_summed = CHECKSUM_NONE;
+		if (in_interrupt())
+			netif_rx(frame);
+		else {
+			if (atomic_read(&handle->rx_pending) >
+			    MAX_RX_PENDING_THRHLD)
+				netif_rx(frame);
+			else {
+				if (handle->params.net_rx == MTRUE) {
+					local_bh_disable();
+					netif_receive_skb(frame);
+					local_bh_enable();
+				} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+					netif_rx(frame);
+#else
+					netif_rx_ni(frame);
+#endif
+				}
+			}
+		}
+	}
+	if (handle->tp_acnt.on) {
+		if (pmbuf->in_ts_sec)
+			moal_tp_accounting(handle, pmbuf, RX_TIME_PKT);
+
+		woal_get_monotonic_time(&t2);
+		delay = (t_s32)(t2.time_sec - in_ts_sec) * 1000000;
+		delay += (t_s32)(t2.time_usec - in_ts_usec);
+		moal_amsdu_tp_accounting(pmoal, delay, 0);
+	}
+done:
+	if (status == MLAN_STATUS_PENDING)
+		atomic_dec(&handle->mbufalloc_count);
+	LEAVE();
+	return status;
+}
+
 /**
  *  @brief This function uploads the packet to the network stack
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmbuf    Pointer to the mlan buffer structure
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
+mlan_status moal_recv_packet(t_void *pmoal, pmlan_buffer pmbuf)
 {
 	mlan_status status = MLAN_STATUS_SUCCESS;
 	moal_private *priv = NULL;
 	struct sk_buff *skb = NULL;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 #if defined(USB) || defined(PCIE)
 	t_u32 max_rx_data_size = MLAN_RX_DATA_BUF_SIZE;
 #endif
@@ -1172,6 +2113,12 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 	t_u8 rx_info_flag = MFALSE;
 	int j;
 	struct ethhdr *ethh = NULL;
+	struct net_device *netdev = NULL;
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+	t_u16 aid = 0;
+#endif
+#endif
 
 	ENTER();
 	if (pmbuf) {
@@ -1198,12 +2145,12 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 #endif
 #endif
 
-		priv = woal_bss_index_to_priv(pmoal_handle, pmbuf->bss_index);
+		priv = woal_bss_index_to_priv(pmoal, pmbuf->bss_index);
 		skb = (struct sk_buff *)pmbuf->pdesc;
 		if (priv) {
 			if (skb) {
 				skb_reserve(skb, pmbuf->data_offset);
-				if (skb_tailroom(skb) < pmbuf->data_len) {
+				if (skb_tailroom(skb) < (int)pmbuf->data_len) {
 					PRINTM(MERROR,
 					       "skb overflow: tail room=%d, data_len=%d\n",
 					       skb_tailroom(skb),
@@ -1213,6 +2160,18 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 					goto done;
 				}
 				skb_put(skb, pmbuf->data_len);
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+				if (pmbuf->flags & MLAN_BUF_FLAG_NET_MONITOR) {
+					status = moal_recv_packet_to_mon_if(
+						pmoal, pmbuf);
+					if (status == MLAN_STATUS_PENDING)
+						atomic_dec(
+							&handle->mbufalloc_count);
+					goto done;
+				}
+#endif
+#endif
 				pmbuf->pdesc = NULL;
 				pmbuf->pbuf = NULL;
 				pmbuf->data_offset = pmbuf->data_len = 0;
@@ -1223,6 +2182,20 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 			} else {
 				PRINTM(MERROR, "%s without skb attach!!!\n",
 				       __func__);
+#if defined(STA_CFG80211) && defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+				/** drop the packet without skb in
+				 * monitor mode */
+				if (pmbuf->flags & MLAN_BUF_FLAG_NET_MONITOR) {
+					PRINTM(MINFO,
+					       "%s Drop packet without skb\n",
+					       __func__);
+					status = MLAN_STATUS_FAILURE;
+					priv->stats.rx_dropped++;
+					goto done;
+				}
+#endif
+#endif
 				skb = dev_alloc_skb(pmbuf->data_len +
 						    MLAN_NET_IP_ALIGN);
 				if (!skb) {
@@ -1230,6 +2203,7 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 					       __func__);
 					status = MLAN_STATUS_FAILURE;
 					priv->stats.rx_dropped++;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 					woal_packet_fate_monitor(
 						priv, PACKET_TYPE_RX,
@@ -1238,6 +2212,7 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 						(t_u8 *)(pmbuf->pbuf +
 							 pmbuf->data_offset),
 						pmbuf->data_len);
+#endif
 #endif
 					goto done;
 				}
@@ -1250,14 +2225,37 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 				skb_put(skb, pmbuf->data_len);
 			}
 			ethh = (struct ethhdr *)(skb->data);
-			if (ntohs(ethh->h_proto) == ETH_P_PAE)
+			if (ntohs(ethh->h_proto) == ETH_P_PAE) {
 				PRINTM(MEVENT,
 				       "wlan: %s Rx EAPOL pkt from " MACSTR
 				       "\n",
 				       priv->netdev->name,
 				       MAC2STR(ethh->h_source));
-			skb->dev = priv->netdev;
-			skb->protocol = eth_type_trans(skb, priv->netdev);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+				priv->deauth_evt_cnt = 0;
+#endif
+			}
+#ifdef UAP_SUPPORT
+#if defined(UAP_CFG80211) || defined(STA_CFG80211)
+			if (pmbuf->flags & MLAN_BUF_FLAG_EASYMESH) {
+				aid = (pmbuf->priority & 0xFF000000) >> 24;
+				if (!priv->vlan_sta_list[(aid - 1) %
+							 MAX_STA_COUNT]
+					     ->is_valid) {
+					status = MLAN_STATUS_FAILURE;
+					priv->stats.rx_dropped++;
+					goto done;
+				}
+				if (aid != 0)
+					netdev = moal_get_netdev_from_stalist(
+						priv, aid);
+			}
+#endif
+#endif
+			if (!netdev)
+				netdev = priv->netdev;
+			skb->dev = netdev;
+			skb->protocol = eth_type_trans(skb, netdev);
 			skb->ip_summed = CHECKSUM_NONE;
 
 #if defined(USB) || defined(PCIE)
@@ -1296,6 +2294,7 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 						(skb->len - max_rx_data_size);
 			}
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 			if (!woal_filter_packet(priv, skb->data, skb->len, 0)) {
 				PRINTM(MEVENT, "drop filtered packet %s\n",
@@ -1310,15 +2309,18 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 				dev_kfree_skb(skb);
 				goto done;
 			}
+#endif
 #endif
 			priv->stats.rx_bytes += skb->len;
 			priv->stats.rx_packets++;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 			woal_packet_fate_monitor(priv, PACKET_TYPE_RX,
 						 RX_PKT_FATE_SUCCESS,
 						 FRAME_TYPE_ETHERNET_II, 0, 0,
 						 skb->data, skb->len);
 #endif
+#endif
 #ifdef ANDROID_KERNEL
 			if (handle->params.wakelock_timeout) {
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
@@ -1337,13 +2339,14 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 			if (priv->rx_protocols.protocol_num) {
 				for (j = 0; j < priv->rx_protocols.protocol_num;
 				     j++) {
-					if (htons(skb->protocol) ==
+					if (htons((__force t_u16)
+							  skb->protocol) ==
 					    priv->rx_protocols.protocols[j])
 						rx_info_flag = MTRUE;
 				}
 			}
 			if (rx_info_flag &&
-			    (skb_tailroom(skb) > sizeof(rxcontrol))) {
+			    (skb_tailroom(skb) > (int)sizeof(rxcontrol))) {
 				memset(&rxcontrol, 0, sizeof(dot11_rxcontrol));
 				rxcontrol.datarate = pmbuf->u.rx_info.data_rate;
 				rxcontrol.channel = pmbuf->u.rx_info.channel;
@@ -1357,15 +2360,43 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 						sizeof(dot11_rxcontrol),
 						sizeof(dot11_rxcontrol));
 			}
-
-			if (in_interrupt())
+			// rx_trace 8
+			if (priv->phandle->tp_acnt.on) {
+				wifi_timeval t;
+				moal_tp_accounting(handle, skb, RX_DROP_P4);
+				if (pmbuf && pmbuf->in_ts_sec) {
+					woal_get_monotonic_time(&t);
+					pmbuf->out_ts_sec = t.time_sec;
+					pmbuf->out_ts_usec = t.time_usec;
+				}
+			}
+			if (priv->phandle->tp_acnt.drop_point == RX_DROP_P4) {
+				status = MLAN_STATUS_PENDING;
+				dev_kfree_skb(skb);
+			} else if (in_interrupt())
 				netif_rx(skb);
 			else {
 				if (atomic_read(&handle->rx_pending) >
 				    MAX_RX_PENDING_THRHLD)
 					netif_rx(skb);
-				else
-					netif_rx_ni(skb);
+				else {
+					if (handle->params.net_rx == MTRUE) {
+						local_bh_disable();
+						netif_receive_skb(skb);
+						local_bh_enable();
+					} else {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+						netif_rx(skb);
+#else
+						netif_rx_ni(skb);
+#endif
+					}
+				}
+			}
+			if (priv->phandle->tp_acnt.on) {
+				if (pmbuf && pmbuf->in_ts_sec)
+					moal_tp_accounting(handle, pmbuf,
+							   RX_TIME_PKT);
 			}
 		}
 	}
@@ -1374,15 +2405,171 @@ mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf)
 	return status;
 }
 
+#if defined(PCIE) || defined(SDIO)
+void woal_request_busfreq_pmqos_add(t_void *handle)
+{
+	moal_handle *pmhandle = (moal_handle *)handle;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
+#ifdef IMX_SUPPORT
+	if (IS_PCIE(pmhandle->card_type)) {
+		request_bus_freq(BUS_FREQ_HIGH);
+	}
+#endif
+#endif
+	if (moal_extflg_isset(pmhandle, EXT_PMQOS)) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#ifdef IMX_SUPPORT
+		if (!pm_qos_request_active(&pmhandle->woal_pm_qos_req))
+			pm_qos_add_request(&pmhandle->woal_pm_qos_req,
+					   PM_QOS_CPU_DMA_LATENCY, 0);
+		else
+			PRINTM(MERROR, "PM-QOS request already active\n");
+#endif
+#endif
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
+#ifdef IMX_SUPPORT
+		if (!cpu_latency_qos_request_active(&pmhandle->woal_pm_qos_req))
+			cpu_latency_qos_add_request(&pmhandle->woal_pm_qos_req,
+						    0);
+		else
+			PRINTM(MERROR, "PM-QOS request already active\n");
+#endif
+#endif
+	}
+	return;
+}
+
+void woal_release_busfreq_pmqos_remove(t_void *handle)
+{
+	moal_handle *pmhandle = (moal_handle *)handle;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 4, 70)
+#ifdef IMX_SUPPORT
+	if (IS_PCIE(pmhandle->card_type)) {
+		release_bus_freq(BUS_FREQ_HIGH);
+	}
+#endif
+#endif
+
+	if (moal_extflg_isset(pmhandle, EXT_PMQOS)) {
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(5, 6, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+#ifdef IMX_SUPPORT
+		if (pm_qos_request_active(&pmhandle->woal_pm_qos_req))
+			pm_qos_remove_request(&pmhandle->woal_pm_qos_req);
+		else
+			PRINTM(MERROR, "PM-QOS request already removed\n");
+#endif
+#endif
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
+#ifdef IMX_SUPPORT
+		if (cpu_latency_qos_request_active(&pmhandle->woal_pm_qos_req))
+			cpu_latency_qos_remove_request(
+				&pmhandle->woal_pm_qos_req);
+		else
+			PRINTM(MERROR, "PM-QOS request already removed\n");
+#endif
+#endif
+	}
+	return;
+}
+#endif /*defined(PCIE) || defined(SDIO)*/
+
+/**
+ *  @brief This function checks media_connected state for
+ *  BSS types UAP/STA/P2P_GO/GC
+ *
+ *  @param pmoal Pointer to the MOAL context
+ *
+ */
+int woal_check_media_connected(t_void *pmoal)
+{
+	int i;
+	moal_handle *pmhandle = (moal_handle *)pmoal;
+	moal_private *pmpriv = NULL;
+	for (i = 0; i < pmhandle->priv_num; i++) {
+		pmpriv = pmhandle->priv[i];
+		if (!pmpriv)
+			continue;
+		if (pmpriv->media_connected == MTRUE) {
+			return MTRUE;
+		}
+	}
+	return MFALSE;
+}
+
+/**
+ *  @brief This function checks connect and disconnect
+ *  events for BSS types UAP/STA/P2P_GO/GC
+ *
+ *  @param pmoal Pointer to the MOAL context
+ *
+ */
+void moal_connection_status_check_pmqos(t_void *pmoal)
+{
+	moal_handle *pmhandle = (moal_handle *)pmoal;
+	if ((woal_check_media_connected(pmoal) == MTRUE)) {
+		if (pmhandle->request_pm == MFALSE) {
+			pmhandle->request_pm = MTRUE;
+#if defined(PCIE) || defined(SDIO)
+			woal_request_busfreq_pmqos_add(pmhandle);
+#endif
+		}
+	} else {
+		if (pmhandle->request_pm == MTRUE) {
+			pmhandle->request_pm = MFALSE;
+#if defined(PCIE) || defined(SDIO)
+			woal_release_busfreq_pmqos_remove(pmhandle);
+#endif
+		}
+	}
+}
+
+#ifdef UAP_SUPPORT
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+/**
+ * @brief   Handle RX MGMT PKT event
+ *
+ * @param priv          A pointer moal_private structure
+ * @param pkt        A pointer to pkt
+ * @param len        length of pkt
+ *
+ * @return          N/A
+ */
+static void woal_rx_mgmt_pkt_event(moal_private *priv, t_u8 *pkt, t_u16 len)
+{
+	struct woal_event *evt;
+	unsigned long flags;
+	moal_handle *handle = priv->phandle;
+
+	evt = kzalloc(sizeof(struct woal_event), GFP_ATOMIC);
+	if (evt) {
+		evt->priv = priv;
+		evt->type = WOAL_EVENT_RX_MGMT_PKT;
+		evt->evt.event_len = len;
+		moal_memcpy_ext(priv->phandle, evt->evt.event_buf, pkt,
+				evt->evt.event_len, sizeof(evt->evt.event_buf));
+		INIT_LIST_HEAD(&evt->link);
+		spin_lock_irqsave(&handle->evt_lock, flags);
+		list_add_tail(&evt->link, &handle->evt_queue);
+		spin_unlock_irqrestore(&handle->evt_lock, flags);
+		queue_work(handle->evt_workqueue, &handle->evt_work);
+	}
+}
+#endif
+#endif
+#endif
+
 /**
  *  @brief This function handles event receive
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param pmevent  Pointer to the mlan event structure
  *
  *  @return         MLAN_STATUS_SUCCESS
  */
-mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
+mlan_status moal_recv_event(t_void *pmoal, pmlan_event pmevent)
 {
 #ifdef STA_SUPPORT
 	int custom_len = 0;
@@ -1402,21 +2589,66 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif
 #endif
 	mlan_ds_ps_info pm_info;
+	moal_handle *handle = (moal_handle *)pmoal;
+	moal_handle *ref_handle = NULL;
+
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	t_u8 enable = 1;
+#endif
+	t_u8 *req_ie = NULL;
+	t_u16 ie_len = 0;
+	apinfo *pinfo = NULL, *req_tlv = NULL;
+	MrvlIEtypesHeader_t *tlv = NULL;
+	t_u16 tlv_type = 0, tlv_len = 0, tlv_buf_left = 0;
+#endif
+#ifdef STA_CFG80211
 	t_u8 hw_test;
+#endif
 	int cfg80211_wext;
 
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	struct cfg80211_roam_info *roam_info = NULL;
+#endif
+#endif
+	t_u16 csi_len;
 #ifdef STA_CFG80211
 	t_u8 channel_status;
 	moal_private *remain_priv = NULL;
 #endif
 #if defined(UAP_CFG80211) || defined(STA_CFG80211)
-	pchan_band_info pchan_info = NULL;
+	chan_band_info *pchan_info = NULL;
 #endif
 	t_u8 radar_detected;
+	t_u8 bandwidth;
+	t_u8 event_buf[64];
+	t_u8 radar_chan;
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	moal_private *cfg_priv = NULL;
+#endif
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#ifdef UAP_CFG80211
+	unsigned long wait_time, wait_time_ms, timeout;
+#endif
+#endif
 
+	t_u8 auto_fw_dump = MFALSE;
 	ENTER();
 	if (pmevent->event_id == MLAN_EVENT_ID_FW_DUMP_INFO) {
-		woal_store_firmware_dump(pmoal_handle, pmevent);
+		if (!handle->is_fw_dump_timer_set) {
+			PRINTM(MMSG, "FW trigger fw dump\n");
+			handle->is_fw_dump_timer_set = MTRUE;
+			woal_mod_timer(&handle->fw_dump_timer, MOAL_TIMER_5S);
+		}
+		woal_store_firmware_dump(pmoal, pmevent);
+		handle->driver_status = MTRUE;
+		wifi_status = WIFI_STATUS_FW_DUMP;
+		ref_handle = (moal_handle *)handle->pref_mac;
+		if (ref_handle)
+			ref_handle->driver_status = MTRUE;
 		goto done;
 	}
 	if ((pmevent->event_id != MLAN_EVENT_ID_DRV_DEFER_RX_WORK) &&
@@ -1425,16 +2657,13 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		PRINTM(MEVENT, "event id:0x%x\n", pmevent->event_id);
 #if defined(PCIE)
 	if (pmevent->event_id == MLAN_EVENT_ID_SSU_DUMP_FILE) {
-		woal_store_ssu_dump(pmoal_handle, pmevent);
 		goto done;
 	}
 #endif /* SSU_SUPPORT */
 	if (pmevent->event_id == MLAN_EVENT_ID_STORE_HOST_CMD_RESP) {
-		woal_save_host_cmdresp((moal_handle *)pmoal_handle,
-				       (mlan_cmdresp_event *)pmevent);
 		goto done;
 	}
-	priv = woal_bss_index_to_priv(pmoal_handle, pmevent->bss_index);
+	priv = woal_bss_index_to_priv(pmoal, pmevent->bss_index);
 	if (priv == NULL) {
 		PRINTM(MERROR, "%s: priv is null\n", __func__);
 		goto done;
@@ -1445,7 +2674,9 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 	}
 
 	cfg80211_wext = priv->phandle->params.cfg80211_wext;
-	hw_test = moal_extflg_isset(pmoal_handle, EXT_HW_TEST);
+#ifdef STA_CFG80211
+	hw_test = moal_extflg_isset(pmoal, EXT_HW_TEST);
+#endif
 	switch (pmevent->event_id) {
 #ifdef STA_SUPPORT
 	case MLAN_EVENT_ID_FW_ADHOC_LINK_SENSED:
@@ -1483,7 +2714,11 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			memset(wrqu.ap_addr.sa_data, 0x00, ETH_ALEN);
 			moal_memcpy_ext(priv->phandle, wrqu.ap_addr.sa_data,
 					pmevent->event_buf, ETH_ALEN,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+					sizeof(wrqu.ap_addr.sa_data_min));
+#else
 					sizeof(wrqu.ap_addr.sa_data));
+#endif
 			wrqu.ap_addr.sa_family = ARPHRD_ETHER;
 			wireless_send_event(priv->netdev, SIOCGIWAP, &wrqu,
 					    NULL);
@@ -1493,9 +2728,11 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		if (IS_STA_CFG80211(cfg80211_wext)) {
 			moal_memcpy_ext(priv->phandle, priv->cfg_bssid,
 					pmevent->event_buf, ETH_ALEN, ETH_ALEN);
-			woal_set_scan_time(priv, ACTIVE_SCAN_CHAN_TIME,
-					   PASSIVE_SCAN_CHAN_TIME,
-					   MIN_SPECIFIC_SCAN_CHAN_TIME);
+
+			if (!priv->phandle->user_scan_cfg)
+				woal_set_scan_time(priv, ACTIVE_SCAN_CHAN_TIME,
+						   PASSIVE_SCAN_CHAN_TIME,
+						   MIN_SPECIFIC_SCAN_CHAN_TIME);
 		}
 #endif
 		custom_len = strlen(CUS_EVT_AP_CONNECTED);
@@ -1511,7 +2748,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		if (!netif_carrier_ok(priv->netdev))
 			netif_carrier_on(priv->netdev);
 		woal_wake_queue(priv->netdev);
-
+		moal_connection_status_check_pmqos(pmoal);
 		break;
 
 	case MLAN_EVENT_ID_DRV_ASSOC_SUCC_LOGGER:
@@ -1528,6 +2765,12 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 	case MLAN_EVENT_ID_DRV_SCAN_REPORT:
 		PRINTM(MINFO, "Scan report\n");
 
+		if (priv->phandle->scan_pending_on_block == MTRUE) {
+			priv->phandle->scan_pending_on_block = MFALSE;
+			priv->phandle->scan_priv = NULL;
+			MOAL_REL_SEMAPHORE(&priv->phandle->async_sem);
+		}
+
 		if (priv->report_scan_result) {
 			priv->report_scan_result = MFALSE;
 #ifdef STA_CFG80211
@@ -1540,16 +2783,21 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					if (!priv->phandle->first_scan_done) {
 						priv->phandle->first_scan_done =
 							MTRUE;
-						woal_set_scan_time(
-							priv,
-							ACTIVE_SCAN_CHAN_TIME,
-							PASSIVE_SCAN_CHAN_TIME,
-							SPECIFIC_SCAN_CHAN_TIME);
+						if (!priv->phandle
+							     ->user_scan_cfg)
+							woal_set_scan_time(
+								priv,
+								ACTIVE_SCAN_CHAN_TIME,
+								PASSIVE_SCAN_CHAN_TIME,
+								SPECIFIC_SCAN_CHAN_TIME);
 					}
 					spin_lock_irqsave(
 						&priv->phandle->scan_req_lock,
 						flags);
 					if (priv->phandle->scan_request) {
+						cancel_delayed_work(
+							&priv->phandle
+								 ->scan_timeout_work);
 						woal_cfg80211_scan_done(
 							priv->phandle
 								->scan_request,
@@ -1597,11 +2845,6 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			priv->phandle->scan_time_start.time_usec = 0;
 		}
 
-		if (priv->phandle->scan_pending_on_block == MTRUE) {
-			priv->phandle->scan_pending_on_block = MFALSE;
-			priv->phandle->scan_priv = NULL;
-			MOAL_REL_SEMAPHORE(&priv->phandle->async_sem);
-		}
 		break;
 
 	case MLAN_EVENT_ID_DRV_OBSS_SCAN_PARAM:
@@ -1620,7 +2863,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext)) {
 			memset(&wrqu, 0, sizeof(union iwreq_data));
-			wrqu.data.pointer = pmevent->event_buf;
+			wrqu.data.pointer = (t_u8 __user *)pmevent->event_buf;
 			wrqu.data.length = pmevent->event_len +
 					   strlen(CUS_EVT_OBSS_SCAN_PARAM) + 1;
 			wireless_send_event(priv->netdev, IWEVCUSTOM, &wrqu,
@@ -1643,7 +2886,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext)) {
 			memset(&wrqu, 0, sizeof(union iwreq_data));
-			wrqu.data.pointer = pmevent->event_buf;
+			wrqu.data.pointer = (t_u8 __user *)pmevent->event_buf;
 			wrqu.data.length = pmevent->event_len +
 					   strlen(CUS_EVT_BW_CHANGED) + 1;
 			wireless_send_event(priv->netdev, IWEVCUSTOM, &wrqu,
@@ -1653,8 +2896,9 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		break;
 
 	case MLAN_EVENT_ID_FW_DISCONNECTED:
-		woal_send_disconnect_to_system(priv,
-					       (t_u16)*pmevent->event_buf);
+		if (priv->media_connected)
+			woal_send_disconnect_to_system(
+				priv, (t_u16)*pmevent->event_buf);
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		priv->auth_flag = 0;
@@ -1671,15 +2915,25 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif
 #ifdef REASSOCIATION
 		if (priv->reassoc_on == MTRUE) {
-			PRINTM(MINFO, "Reassoc: trigger the timer\n");
-			priv->reassoc_required = MTRUE;
-			priv->phandle->is_reassoc_timer_set = MTRUE;
-			woal_mod_timer(&priv->phandle->reassoc_timer,
-				       REASSOC_TIMER_DEFAULT);
+			if (priv->auto_assoc_priv.auto_assoc_type_on &
+			    (0x1 << (AUTO_ASSOC_TYPE_DRV_RECONN - 1))) {
+				PRINTM(MINFO,
+				       " auto assoc: trigger driver auto re-connect\n");
+				priv->auto_assoc_priv.auto_assoc_trigger_flag =
+					AUTO_ASSOC_TYPE_DRV_RECONN;
+				priv->auto_assoc_priv.drv_reconnect.status =
+					MTRUE;
+				PRINTM(MINFO, "Reassoc: trigger the timer\n");
+				priv->reassoc_required = MTRUE;
+				priv->phandle->is_reassoc_timer_set = MTRUE;
+				woal_mod_timer(&priv->phandle->reassoc_timer,
+					       REASSOC_TIMER_DEFAULT);
+			}
 		} else {
 			priv->rate_index = AUTO_RATE;
 		}
 #endif /* REASSOCIATION */
+		moal_connection_status_check_pmqos(pmoal);
 		break;
 
 	case MLAN_EVENT_ID_FW_MIC_ERR_UNI:
@@ -1859,6 +3113,9 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext))
 			woal_send_iwevcustom_event(priv, CUS_EVT_PORT_RELEASE);
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+		priv->deauth_evt_cnt = 0;
 #endif
 		woal_broadcast_event(priv, CUS_EVT_PORT_RELEASE,
 				     strlen(CUS_EVT_PORT_RELEASE));
@@ -1873,14 +3130,37 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
 		if (IS_STA_CFG80211(cfg80211_wext)) {
 			struct cfg80211_bss *bss = NULL;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+			bss = cfg80211_get_bss(priv->wdev->wiphy, NULL,
+					       priv->cfg_bssid, NULL, 0,
+					       IEEE80211_BSS_TYPE_ESS,
+					       IEEE80211_PRIVACY_ANY);
+
+#else
 			bss = cfg80211_get_bss(priv->wdev->wiphy, NULL,
 					       priv->cfg_bssid, NULL, 0,
 					       WLAN_CAPABILITY_ESS,
 					       WLAN_CAPABILITY_ESS);
-			if (bss)
+#endif
+			if (bss) {
 				cfg80211_unlink_bss(priv->wdev->wiphy, bss);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+				cfg80211_put_bss(priv->wdev->wiphy, bss);
+#else
+				cfg80211_put_bss(bss);
+#endif
+			}
 			if (!hw_test && priv->roaming_enabled)
 				woal_config_bgscan_and_rssi(priv, MFALSE);
+			else {
+				cfg80211_cqm_rssi_notify(
+					priv->netdev,
+					NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+					0,
+#endif
+					GFP_KERNEL);
+			}
 			priv->last_event |= EVENT_PRE_BCN_LOST;
 		}
 #endif
@@ -1956,19 +3236,18 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		break;
 	case MLAN_EVENT_ID_DRV_DBG_DUMP:
 		priv->phandle->driver_status = MTRUE;
-		woal_moal_debug_info(priv, NULL, MFALSE);
-		woal_broadcast_event(priv, CUS_EVT_DRIVER_HANG,
-				     strlen(CUS_EVT_DRIVER_HANG));
-#ifdef STA_CFG80211
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-		if (IS_STA_OR_UAP_CFG80211(cfg80211_wext))
-			woal_cfg80211_vendor_event(priv, event_hang,
-						   CUS_EVT_DRIVER_HANG,
-						   strlen(CUS_EVT_DRIVER_HANG));
-#endif
+		ref_handle = (moal_handle *)priv->phandle->pref_mac;
+		if (ref_handle)
+			ref_handle->driver_status = MTRUE;
+#ifdef DEBUG_LEVEL1
+		if (drvdbg & MFW_D)
+			auto_fw_dump = MTRUE;
 #endif
-		woal_process_hang(priv->phandle);
-		wifi_status = 2;
+
+		woal_moal_debug_info(priv, NULL, MFALSE);
+		if (!auto_fw_dump && !handle->fw_dump)
+			woal_process_hang(priv->phandle);
+		wifi_status = WIFI_STATUS_WIFI_HANG;
 		break;
 	case MLAN_EVENT_ID_DRV_WIFI_STATUS:
 		wifi_status = *(t_u16 *)(pmevent->event_buf + sizeof(t_u32));
@@ -2005,7 +3284,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			) {
 				priv->roaming_required = MTRUE;
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 				__pm_wakeup_event(&priv->phandle->ws,
 						  ROAMING_WAKE_LOCK_TIMEOUT);
 #else
@@ -2015,8 +3294,22 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 						ROAMING_WAKE_LOCK_TIMEOUT));
 #endif
 #endif
+#ifdef REASSOCIATION
 				wake_up_interruptible(
 					&priv->phandle->reassoc_thread.wait_q);
+#endif
+			} else {
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
+				if (priv->mrvl_rssi_low) {
+					cfg80211_cqm_rssi_notify(
+						priv->netdev,
+						NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+						0,
+#endif
+						GFP_KERNEL);
+				}
+#endif
 			}
 		}
 #endif
@@ -2039,14 +3332,10 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			    !priv->phandle->cfg80211_suspend) {
 				woal_inform_bss_from_scan_result(priv, NULL,
 								 MOAL_NO_WAIT);
-				cfg80211_sched_scan_results(priv->wdev->wiphy
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
-							    ,
-							    priv->bg_scan_reqid
-#endif
-				);
+				PRINTM(MMSG,
+				       "wlan: Report sched_scan result\n");
+				woal_report_sched_scan_result(priv);
 				priv->last_event = 0;
-				woal_bgscan_stop_event(priv);
 				PRINTM(MEVENT,
 				       "Reporting Sched_Scan results\n");
 			}
@@ -2058,11 +3347,70 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 
 	case MLAN_EVENT_ID_FW_CHANNEL_REPORT_RDY:
 		radar_detected = pmevent->event_buf[0];
+		bandwidth = pmevent->event_buf[2];
+#ifdef UAP_SUPPORT
+		if (priv->chan_rpt_req.chanNum && priv->chan_rpt_pending) {
+			radar_chan = pmevent->event_buf[1];
+			if (radar_detected) {
+				snprintf(event_buf, sizeof(event_buf) - 1,
+					 "%s %d", CUS_EVT_RADAR_DETECTED,
+					 radar_chan);
+				woal_broadcast_event(priv, event_buf,
+						     strlen(event_buf));
+			} else {
+				snprintf(event_buf, sizeof(event_buf) - 1,
+					 "%s %d", CUS_EVT_CAC_FINISHED,
+					 priv->chan_rpt_req.chanNum);
+				woal_broadcast_event(priv, event_buf,
+						     strlen(event_buf));
+			}
+			if (priv->bss_type == MLAN_BSS_TYPE_DFS)
+				woal_chan_event(priv, WOAL_EVENT_CHAN_RPT,
+						priv->chan_rpt_req.chanNum,
+						radar_detected);
+		}
+#endif
 
 #ifdef UAP_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 		if (!IS_STA_OR_UAP_CFG80211(cfg80211_wext))
 			break;
+		if (priv->chan_rpt_req.chanNum && priv->chan_rpt_pending) {
+			priv->chan_rpt_pending = MFALSE;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+			if (priv->radar_background) {
+				PRINTM(MEVENT,
+				       "%s radar found when background CAC \n",
+				       radar_detected ? "" : "No");
+				if (radar_detected)
+					cfg80211_background_radar_event(
+						priv->phandle->wiphy,
+						&priv->radar_background_chan,
+						GFP_ATOMIC);
+				break;
+			}
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			cfg_priv = woal_get_priv_with_wdev(priv->phandle);
+			if (cfg_priv) {
+				if (radar_detected)
+					woal_update_channels_dfs_state(
+						cfg_priv,
+						priv->chan_rpt_req.chanNum,
+						priv->chan_rpt_req.bandcfg
+							.chanWidth,
+						DFS_UNAVAILABLE);
+				else
+					woal_update_channels_dfs_state(
+						cfg_priv,
+						priv->chan_rpt_req.chanNum,
+						priv->chan_rpt_req.bandcfg
+							.chanWidth,
+						DFS_AVAILABLE);
+			}
+#endif
+			break;
+		}
 
 		if (priv->phandle->is_cac_timer_set) {
 			PRINTM(MEVENT, "%s radar found when CAC \n",
@@ -2086,6 +3434,34 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					&priv->phandle->dfs_channel,
 					GFP_KERNEL);
 			} else {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+				if (!priv->user_cac_period_msec) {
+					// host and device timer isn't sync,add
+					// delay to avoid kernel warning
+					// WARN_ON(!time_after_eq(jiffies,
+					// timeout)); mdelay(100); Using
+					// optimized delay
+					timeout =
+						(priv->wdev->cac_start_time +
+						 msecs_to_jiffies(
+							 priv->wdev
+								 ->cac_time_ms));
+					if (!time_after_eq(jiffies, timeout)) {
+						/* Exact time to make host and
+						 * device timer in sync */
+						wait_time = timeout - jiffies;
+						wait_time_ms =
+							jiffies_to_msecs(
+								wait_time) +
+							3;
+						PRINTM(MEVENT,
+						       "Waiting for %ld ms for syncing\n",
+						       wait_time_ms);
+						mdelay(wait_time_ms);
+					}
+				}
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 				cfg80211_cac_event(priv->netdev,
 						   &priv->phandle->dfs_channel,
@@ -2105,11 +3481,55 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif /* UAP_CFG80211 */
 		break;
 	case MLAN_EVENT_ID_FW_RADAR_DETECTED:
+		radar_chan = pmevent->event_buf[0];
+		bandwidth = pmevent->event_buf[1];
+		snprintf(event_buf, sizeof(event_buf) - 1, "%s %d",
+			 CUS_EVT_RADAR_DETECTED, radar_chan);
+		woal_broadcast_event(priv, event_buf, strlen(event_buf));
+		PRINTM(MEVENT, "%s: Radar detected on channel %d\n",
+		       priv->netdev->name, radar_chan);
+#ifdef UAP_SUPPORT
+		if (priv->chan_rpt_req.chanNum && priv->chan_rpt_pending) {
+			woal_11h_cancel_chan_report_ioctl(priv, MOAL_NO_WAIT);
+			priv->chan_rpt_pending = MFALSE;
+		}
+#endif
 
 #ifdef UAP_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 		if (!IS_STA_OR_UAP_CFG80211(cfg80211_wext))
 			break;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+		if (priv->radar_background) {
+			cfg80211_background_radar_event(
+				priv->phandle->wiphy,
+				&priv->radar_background_chan, GFP_ATOMIC);
+			break;
+		}
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		cfg_priv = woal_get_priv_with_wdev(priv->phandle);
+		if (cfg_priv)
+			woal_update_channels_dfs_state(cfg_priv, radar_chan,
+						       bandwidth,
+						       DFS_UNAVAILABLE);
+#endif
+#ifdef UAP_SUPPORT
+		if (priv->bss_started &&
+		    ((priv->target_chan && (priv->target_chan != radar_chan)) ||
+		     priv->backup_chan)) {
+			PRINTM(MEVENT, "Move to target or backup chan %d %d\n",
+			       priv->target_chan, priv->backup_chan);
+			woal_move_to_next_channel(priv);
+			priv->target_chan = 0;
+			break;
+		}
+		if (priv->bss_type == MLAN_BSS_TYPE_DFS) {
+			woal_chan_event(priv, WOAL_EVENT_RADAR,
+					priv->chan_rpt_req.chanNum, MTRUE);
+			break;
+		}
+#endif
 		if (priv->phandle->is_cac_timer_set) {
 			if (priv->bss_index == priv->phandle->cac_bss_index) {
 				PRINTM(MEVENT, "radar detected during CAC \n");
@@ -2143,7 +3563,6 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 				       " Radar event for incorrect inferface \n");
 			}
 		} else {
-			PRINTM(MEVENT, "radar detected during BSS active \n");
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 			if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD))
 				woal_cfg80211_dfs_vendor_event(
@@ -2175,11 +3594,25 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 	case MLAN_EVENT_ID_FW_CHAN_SWITCH_COMPLETE:
 #if defined(UAP_CFG80211) || defined(STA_CFG80211)
 		pchan_info = (chan_band_info *)pmevent->event_buf;
+#ifdef UAP_SUPPORT
+		if (priv->bss_role == MLAN_BSS_ROLE_UAP) {
+			if (priv->uap_tx_blocked) {
+				if (!netif_carrier_ok(priv->netdev))
+					netif_carrier_on(priv->netdev);
+				woal_start_queue(priv->netdev);
+				priv->uap_tx_blocked = MFALSE;
+			}
+			priv->phandle->chsw_wait_q_woken = MTRUE;
+			wake_up_interruptible(&priv->phandle->chsw_wait_q);
+		}
+#endif
+		snprintf(event_buf, sizeof(event_buf) - 1, "%s %d",
+			 CUS_EVT_CHAN_SWITCH_COMPLETE, pchan_info->channel);
+		woal_broadcast_event(priv, event_buf, strlen(event_buf));
 		if (IS_STA_OR_UAP_CFG80211(cfg80211_wext)) {
 			PRINTM(MMSG,
 			       "CSA/ECSA: Switch to new channel %d complete!\n",
 			       pchan_info->channel);
-			priv->channel = pchan_info->channel;
 #ifdef UAP_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 			if (priv->csa_chan.chan &&
@@ -2193,13 +3626,27 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			}
 #endif
 #endif
+			if (priv->channel == pchan_info->channel)
+				break;
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+			woal_update_uap_channel_dfs_state(priv);
+#endif
+#endif
+			priv->channel = pchan_info->channel;
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 			if (MFALSE
 #ifdef UAP_CFG80211
 			    || priv->uap_host_based
 #endif
 #ifdef STA_CFG80211
-			    || priv->sme_current.ssid_len
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			    || priv->wdev->connected
+#else
+			    || priv->wdev->current_bss
+#endif
 #endif
 			) {
 				PRINTM(MEVENT,
@@ -2210,22 +3657,10 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 				       pchan_info->bandcfg.chanBand,
 				       pchan_info->bandcfg.chanWidth,
 				       pchan_info->bandcfg.chan2Offset);
-				woal_cfg80211_notify_channel(priv, pchan_info);
+				woal_channel_switch_event(priv, pchan_info);
 			}
 #endif
 		}
-#endif
-#ifdef UAP_SUPPORT
-		if (priv->bss_role == MLAN_BSS_ROLE_UAP) {
-			if (priv->uap_tx_blocked) {
-				if (!netif_carrier_ok(priv->netdev))
-					netif_carrier_on(priv->netdev);
-				woal_start_queue(priv->netdev);
-				priv->uap_tx_blocked = MFALSE;
-			}
-			priv->phandle->chsw_wait_q_woken = MTRUE;
-			wake_up_interruptible(&priv->phandle->chsw_wait_q);
-		}
 #endif
 		break;
 	case MLAN_EVENT_ID_FW_STOP_TX:
@@ -2242,8 +3677,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		/* simulate HSCFG_CANCEL command */
 		woal_cancel_hs(priv, MOAL_NO_WAIT);
 #ifdef STA_SUPPORT
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_STA);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_STA);
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext) && pmpriv)
 			woal_send_iwevcustom_event(pmpriv, CUS_EVT_HS_WAKEUP);
@@ -2253,8 +3687,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					     strlen(CUS_EVT_HS_WAKEUP));
 #endif /*STA_SUPPORT */
 #ifdef UAP_SUPPORT
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_UAP);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_UAP);
 		if (pmpriv) {
 			pmevent->event_id = UAP_EVENT_ID_HS_WAKEUP;
 			woal_broadcast_event(pmpriv, (t_u8 *)&pmevent->event_id,
@@ -2264,8 +3697,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		break;
 	case MLAN_EVENT_ID_DRV_HS_ACTIVATED:
 #ifdef STA_SUPPORT
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_STA);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_STA);
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext) && pmpriv)
 			woal_send_iwevcustom_event(pmpriv,
@@ -2276,8 +3708,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					     strlen(CUS_EVT_HS_ACTIVATED));
 #endif /* STA_SUPPORT */
 #if defined(UAP_SUPPORT)
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_UAP);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_UAP);
 		if (pmpriv) {
 			pmevent->event_id = UAP_EVENT_ID_DRV_HS_ACTIVATED;
 			woal_broadcast_event(pmpriv, (t_u8 *)&pmevent->event_id,
@@ -2299,8 +3730,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		break;
 	case MLAN_EVENT_ID_DRV_HS_DEACTIVATED:
 #ifdef STA_SUPPORT
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_STA);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_STA);
 #ifdef STA_WEXT
 		if (IS_STA_WEXT(cfg80211_wext) && pmpriv)
 			woal_send_iwevcustom_event(pmpriv,
@@ -2311,8 +3741,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					     strlen(CUS_EVT_HS_DEACTIVATED));
 #endif /* STA_SUPPORT */
 #if defined(UAP_SUPPORT)
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_UAP);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_UAP);
 		if (pmpriv) {
 			pmevent->event_id = UAP_EVENT_ID_DRV_HS_DEACTIVATED;
 			woal_broadcast_event(pmpriv, (t_u8 *)&pmevent->event_id,
@@ -2331,18 +3760,25 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		woal_start_queue(priv->netdev);
 		moal_memcpy_ext(priv->phandle, priv->current_addr,
 				pmevent->event_buf + 6, ETH_ALEN, ETH_ALEN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+		eth_hw_addr_set(priv->netdev, priv->current_addr);
+#else
 		moal_memcpy_ext(priv->phandle, priv->netdev->dev_addr,
 				priv->current_addr, ETH_ALEN, ETH_ALEN);
+#endif
 		woal_broadcast_event(priv, pmevent->event_buf,
 				     pmevent->event_len);
 #ifdef STA_SUPPORT
 #ifdef STA_CFG80211
-		pmpriv = woal_get_priv((moal_handle *)pmoal_handle,
-				       MLAN_BSS_ROLE_STA);
-		if (IS_STA_CFG80211(cfg80211_wext) && pmpriv)
-			woal_set_scan_time(pmpriv, ACTIVE_SCAN_CHAN_TIME,
-					   PASSIVE_SCAN_CHAN_TIME,
-					   MIN_SPECIFIC_SCAN_CHAN_TIME);
+		pmpriv = woal_get_priv((moal_handle *)pmoal, MLAN_BSS_ROLE_STA);
+		if (IS_STA_CFG80211(cfg80211_wext) && pmpriv) {
+			if (!priv->phandle->user_scan_cfg) {
+				woal_set_scan_time(pmpriv,
+						   ACTIVE_SCAN_CHAN_TIME,
+						   PASSIVE_SCAN_CHAN_TIME,
+						   MIN_SPECIFIC_SCAN_CHAN_TIME);
+			}
+		}
 #endif
 #endif
 #ifdef UAP_CFG80211
@@ -2351,7 +3787,15 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			PRINTM(MMSG,
 			       "Channel Under Nop: notify cfg80211 new channel=%d\n",
 			       priv->channel);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+			cfg80211_ch_switch_notify(priv->netdev, &priv->chan, 0,
+						  0);
+#elif ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) ||                  \
+       IMX_ANDROID_13 || IMX_ANDROID_12_BACKPORT)
+			cfg80211_ch_switch_notify(priv->netdev, &priv->chan, 0);
+#else
 			cfg80211_ch_switch_notify(priv->netdev, &priv->chan);
+#endif
 			priv->chan_under_nop = MFALSE;
 		}
 #endif
@@ -2361,8 +3805,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 	case MLAN_EVENT_ID_DRV_UAP_CHAN_INFO:
 #ifdef UAP_CFG80211
 		if (IS_UAP_CFG80211(cfg80211_wext)) {
-			chan_band_info *pchan_info =
-				(chan_band_info *)pmevent->event_buf;
+			pchan_info = (chan_band_info *)pmevent->event_buf;
 			PRINTM(MEVENT,
 			       "UAP: 11n=%d, chan=%d, center_chan=%d, band=%d, width=%d, 2Offset=%d\n",
 			       pchan_info->is_11n_enabled, pchan_info->channel,
@@ -2384,11 +3827,13 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 		woal_wake_queue(priv->netdev);
 		woal_broadcast_event(priv, pmevent->event_buf,
 				     pmevent->event_len);
+		moal_connection_status_check_pmqos(pmoal);
 		break;
 	case MLAN_EVENT_ID_UAP_FW_BSS_IDLE:
 		priv->media_connected = MFALSE;
 		woal_broadcast_event(priv, pmevent->event_buf,
 				     pmevent->event_len);
+		moal_connection_status_check_pmqos(pmoal);
 		break;
 	case MLAN_EVENT_ID_UAP_FW_MIC_COUNTERMEASURES: {
 		t_u16 status = 0;
@@ -2414,12 +3859,23 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 			PRINTM(MEVENT,
 			       "FW_REMAIN_ON_CHANNEL_EXPIRED cookie = %#llx\n",
 			       priv->phandle->cookie);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 			if (priv->host_mlme &&
 			    (priv->auth_flag & HOST_MLME_AUTH_PENDING)) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+				if (priv->assoc_bss) {
+					PRINTM(MEVENT,
+					       "wlan: HostMlme auth timeout\n");
+					cfg80211_auth_timeout(
+						priv->netdev,
+						priv->assoc_bss->bssid);
+				}
+#endif
 				priv->auth_flag = 0;
 				priv->host_mlme = MFALSE;
 				priv->auth_alg = 0xFFFF;
 			}
+#endif
 			priv->phandle->remain_on_channel = MFALSE;
 			if (priv->phandle->cookie &&
 			    !priv->phandle->is_remain_timer_set) {
@@ -2444,40 +3900,44 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 	case MLAN_EVENT_ID_UAP_FW_STA_CONNECT:
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 		if (IS_STA_OR_UAP_CFG80211(cfg80211_wext)) {
-			struct station_info sinfo = {0};
+			struct station_info *sinfo = NULL;
 			t_u8 addr[ETH_ALEN];
-
-			sinfo.filled = 0;
-			sinfo.generation = 0;
-			/* copy the station mac address */
-			memset(addr, 0xFF, ETH_ALEN);
-			moal_memcpy_ext(priv->phandle, addr, pmevent->event_buf,
-					ETH_ALEN, ETH_ALEN);
-			/** these field add in kernel 3.2, but some
-			 * kernel do have the pacth to support it,
-			 * like T3T and pxa978T 3.0.31 JB, these
-			 * patch are needed to support
-			 * wpa_supplicant 2.x */
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 31)
-			if (pmevent->event_len > ETH_ALEN) {
+			sinfo = kzalloc(sizeof(struct station_info),
+					GFP_ATOMIC);
+			if (sinfo) {
+				sinfo->filled = 0;
+				sinfo->generation = 0;
+				/* copy the station mac address */
+				memset(addr, 0xFF, ETH_ALEN);
+				moal_memcpy_ext(priv->phandle, addr,
+						pmevent->event_buf, ETH_ALEN,
+						ETH_ALEN);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+				if (pmevent->event_len > ETH_ALEN) {
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 0, 0)
-				/* set station info filled flag */
-				sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
+					/* set station info filled flag */
+					sinfo->filled |=
+						STATION_INFO_ASSOC_REQ_IES;
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
-				sinfo.pertid = NULL;
-#endif
-				/* get the assoc request ies and length */
-				sinfo.assoc_req_ies =
-					(const t_u8 *)(pmevent->event_buf +
-						       ETH_ALEN);
-				sinfo.assoc_req_ies_len =
-					pmevent->event_len - ETH_ALEN;
-			}
+					sinfo->pertid = NULL;
+#endif
+					/* get the assoc request ies and length
+					 */
+					sinfo->assoc_req_ies =
+						(const t_u8
+							 *)(pmevent->event_buf +
+							    ETH_ALEN);
+					sinfo->assoc_req_ies_len =
+						pmevent->event_len - ETH_ALEN;
+				}
 #endif /* KERNEL_VERSION */
-			if (priv->netdev && priv->wdev)
-				cfg80211_new_sta(priv->netdev, (t_u8 *)addr,
-						 &sinfo, GFP_KERNEL);
+				if (priv->netdev && priv->wdev)
+					cfg80211_new_sta(priv->netdev,
+							 (t_u8 *)addr, sinfo,
+							 GFP_KERNEL);
+				kfree(sinfo);
+			}
 		}
 #endif /* UAP_CFG80211 */
 		memmove((pmevent->event_buf + strlen(CUS_EVT_STA_CONNECTED) +
@@ -2494,7 +3954,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #ifdef UAP_WEXT
 		if (IS_UAP_WEXT(cfg80211_wext)) {
 			memset(&wrqu, 0, sizeof(union iwreq_data));
-			wrqu.data.pointer = pmevent->event_buf;
+			wrqu.data.pointer = (t_u8 __user *)pmevent->event_buf;
 			if ((pmevent->event_len +
 			     strlen(CUS_EVT_STA_CONNECTED) + 1) > IW_CUSTOM_MAX)
 				wrqu.data.length =
@@ -2550,7 +4010,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #ifdef UAP_WEXT
 		if (IS_UAP_WEXT(cfg80211_wext)) {
 			memset(&wrqu, 0, sizeof(union iwreq_data));
-			wrqu.data.pointer = pmevent->event_buf;
+			wrqu.data.pointer = (t_u8 __user *)pmevent->event_buf;
 			wrqu.data.length = pmevent->event_len +
 					   strlen(CUS_EVT_STA_DISCONNECTED) + 1;
 			wireless_send_event(priv->netdev, IWEVCUSTOM, &wrqu,
@@ -2630,6 +4090,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 						    ((struct ieee80211_mgmt *)
 							     pkt)
 							    ->frame_control)) {
+						priv->auth_tx_cnt = 0;
 						PRINTM(MEVENT,
 						       "HostMlme %s: Received auth frame type = 0x%x\n",
 						       priv->netdev->name,
@@ -2665,6 +4126,37 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 						PRINTM(MEVENT,
 						       "HostMlme %s: Receive deauth/disassociate\n",
 						       priv->netdev->name);
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+						if (!priv->wdev->connected) {
+#else
+						if (!priv->wdev->current_bss) {
+#endif
+							PRINTM(MEVENT,
+							       "HostMlme: Drop deauth/disassociate, current_bss = null\n");
+							break;
+						}
+
+						if (ieee80211_is_deauth(
+							    ((struct ieee80211_mgmt
+								      *)pkt)
+								    ->frame_control)) {
+							/* subtype 12 deauth
+							 * packet */
+							priv->deauth_evt_cnt++;
+#define MAX_DEAUTH_COUNTER 5
+							if (priv->deauth_evt_cnt >=
+							    MAX_DEAUTH_COUNTER) {
+								if (woal_reset_wifi(
+									    priv->phandle,
+									    priv->deauth_evt_cnt,
+									    "EAPOL timeout") ==
+								    MLAN_STATUS_SUCCESS) {
+									priv->deauth_evt_cnt =
+										0;
+								}
+							}
+						}
 						priv->cfg_disconnect = MTRUE;
 						woal_mgmt_frame_register(
 							priv,
@@ -2674,23 +4166,19 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 							priv,
 							IEEE80211_STYPE_DISASSOC,
 							MFALSE);
+						woal_send_disconnect_to_system(
+							priv,
+							DEF_DEAUTH_REASON_CODE);
 						priv->host_mlme = MFALSE;
 						priv->auth_flag = 0;
 						priv->auth_alg = 0xFFFF;
-						if (!priv->wdev->current_bss) {
-							PRINTM(MEVENT,
-							       "HostMlme: Drop deauth/disassociate, we already disconnected\n");
-							break;
-						}
 					}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
-					mutex_lock(&priv->wdev->mtx);
-					cfg80211_rx_mlme_mgmt(
-						priv->netdev, pkt,
+					woal_rx_mgmt_pkt_event(
+						priv, pkt,
 						pmevent->event_len -
 							sizeof(pmevent->event_id) -
 							MLAN_MAC_ADDR_LENGTH);
-					mutex_unlock(&priv->wdev->mtx);
 #else
 					if (ieee80211_is_deauth(
 						    ((struct ieee80211_mgmt *)
@@ -2756,6 +4244,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 						MLAN_MAC_ADDR_LENGTH,
 					GFP_ATOMIC);
 #endif
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 				woal_packet_fate_monitor(
 					priv, PACKET_TYPE_RX,
@@ -2766,6 +4255,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					pmevent->event_len -
 						sizeof(pmevent->event_id) -
 						MLAN_MAC_ADDR_LENGTH);
+#endif
 #endif
 			}
 #endif /* KERNEL_VERSION */
@@ -2854,6 +4344,21 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif
 		}
 		break;
+	case MLAN_EVENT_ID_DRV_TDLS_TEARDOWN_REQ:
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+#ifdef STA_CFG80211
+		if (IS_STA_CFG80211(cfg80211_wext)) {
+			tdls_tear_down_event *tdls_event =
+				(tdls_tear_down_event *)pmevent->event_buf;
+			cfg80211_tdls_oper_request(priv->netdev,
+						   tdls_event->peer_mac_addr,
+						   NL80211_TDLS_TEARDOWN,
+						   tdls_event->reason_code,
+						   GFP_KERNEL);
+		}
+#endif
+#endif
+		break;
 	case MLAN_EVENT_ID_FW_TX_STATUS: {
 #if defined(STA_CFG80211) || defined(UAP_CFG80211)
 		unsigned long flag;
@@ -2882,10 +4387,13 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 					priv->phandle->priv
 						[priv->phandle->remain_bss_index];
 				if (remain_priv) {
-					woal_cfg80211_remain_on_channel_cfg(
-						remain_priv, MOAL_NO_WAIT,
-						MTRUE, &channel_status, NULL, 0,
-						0);
+					if (woal_cfg80211_remain_on_channel_cfg(
+						    remain_priv, MOAL_NO_WAIT,
+						    MTRUE, &channel_status,
+						    NULL, 0, 0))
+						PRINTM(MERROR,
+						       "remain_on_channel: Failed to cancel\n");
+
 					priv->phandle->remain_on_channel =
 						MFALSE;
 				}
@@ -2908,6 +4416,7 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif
 #endif
 			}
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 			woal_packet_fate_monitor(priv, PACKET_TYPE_TX,
 						 ack ? TX_PKT_FATE_ACKED :
@@ -2915,14 +4424,18 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 						 FRAME_TYPE_80211_MGMT, 0, 0,
 						 skb->data, skb->len);
 #endif
+#endif
 #endif
 			dev_kfree_skb_any(skb);
 			kfree(tx_info);
-		} else
+		} else {
 			spin_unlock_irqrestore(&priv->tx_stat_lock, flag);
+		}
 #endif
 	} break;
 	case MLAN_EVENT_ID_DRV_FT_RESPONSE:
+		if (priv->phandle->fw_roam_enable)
+			break;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 10, 0)
 #ifdef STA_CFG80211
 		if (IS_STA_CFG80211(cfg80211_wext)) {
@@ -2961,6 +4474,124 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 #endif
 #endif
 		break;
+	case MLAN_EVENT_ID_FW_ROAM_OFFLOAD_RESULT:
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		woal_cfg80211_vendor_event(priv, event_set_key_mgmt_offload,
+					   &enable, sizeof(enable));
+#endif
+		moal_memcpy_ext(priv->phandle, priv->cfg_bssid,
+				pmevent->event_buf, ETH_ALEN, ETH_ALEN);
+		tlv = (MrvlIEtypesHeader_t *)((t_u8 *)pmevent->event_buf +
+					      MLAN_MAC_ADDR_LENGTH);
+		tlv_buf_left = pmevent->event_len - MLAN_MAC_ADDR_LENGTH;
+		while (tlv_buf_left >= sizeof(MrvlIEtypesHeader_t)) {
+			tlv_type = woal_le16_to_cpu(tlv->type);
+			tlv_len = woal_le16_to_cpu(tlv->len);
+
+			if (tlv_buf_left <
+			    (tlv_len + sizeof(MrvlIEtypesHeader_t))) {
+				PRINTM(MERROR,
+				       "Error processing firmware roam success TLVs, bytes left < TLV length\n");
+				break;
+			}
+
+			switch (tlv_type) {
+			case TLV_TYPE_APINFO:
+				pinfo = (apinfo *)tlv;
+				break;
+			case TLV_TYPE_ASSOC_REQ_IE:
+				req_tlv = (apinfo *)tlv;
+				break;
+			default:
+				break;
+			}
+			tlv_buf_left -= tlv_len + sizeof(MrvlIEtypesHeader_t);
+			tlv = (MrvlIEtypesHeader_t
+				       *)((t_u8 *)tlv + tlv_len +
+					  sizeof(MrvlIEtypesHeader_t));
+		}
+		if (!pinfo) {
+			PRINTM(MERROR,
+			       "ERROR:AP info in roaming event buffer is NULL\n");
+			goto done;
+		}
+		if (req_tlv) {
+			req_ie = req_tlv->rsp_ie;
+			ie_len = req_tlv->header.len;
+		}
+		woal_inform_bss_from_scan_result(priv, NULL, MOAL_NO_WAIT);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+		roam_info =
+			kzalloc(sizeof(struct cfg80211_roam_info), GFP_ATOMIC);
+		if (roam_info) {
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)) || IMX_ANDROID_13 ||   \
+     IMX_ANDROID_12_BACKPORT)
+			roam_info->links[0].bssid = priv->cfg_bssid;
+#else
+			roam_info->bssid = priv->cfg_bssid;
+#endif
+			roam_info->req_ie = req_ie;
+			roam_info->req_ie_len = ie_len;
+			roam_info->resp_ie = pinfo->rsp_ie;
+			roam_info->resp_ie_len = pinfo->header.len;
+			cfg80211_roamed(priv->netdev, roam_info, GFP_KERNEL);
+			kfree(roam_info);
+		}
+#else
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+		cfg80211_roamed(priv->netdev, NULL, priv->cfg_bssid, req_ie,
+				ie_len, pinfo->rsp_ie, pinfo->header.len,
+				GFP_KERNEL);
+#else
+		cfg80211_roamed(priv->netdev, priv->cfg_bssid, req_ie, ie_len,
+				pinfo->rsp_ie, pinfo->header.len, GFP_KERNEL);
+#endif
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		woal_roam_ap_info(priv, pmevent->event_buf, pmevent->event_len);
+#endif
+#endif
+		PRINTM(MMSG, "FW Roamed to bssid " MACSTR " successfully\n",
+		       MAC2STR(pmevent->event_buf));
+		break;
+	case MLAN_EVENT_ID_DRV_RTT_RESULT:
+		DBG_HEXDUMP(MEVT_D, "RTT result", pmevent->event_buf,
+			    pmevent->event_len);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#ifdef STA_CFG80211
+		if (IS_STA_CFG80211(cfg80211_wext))
+			woal_cfg80211_event_rtt_result(priv, pmevent->event_buf,
+						       pmevent->event_len);
+#endif
+#endif
+		break;
+	case MLAN_EVENT_ID_CSI:
+		DBG_HEXDUMP(MEVT_D, "CSI dump", pmevent->event_buf,
+			    pmevent->event_len);
+#ifdef STA_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		if (priv->csi_enable)
+			woal_cfg80211_event_csi_dump(priv, pmevent->event_buf,
+						     pmevent->event_len);
+#endif
+#endif
+		/* Send Netlink event */
+		custom_len = strlen(CUS_EVT_CSI) + sizeof(priv->csi_seq);
+		csi_len = pmevent->event_len;
+		memmove(pmevent->event_buf + custom_len, pmevent->event_buf,
+			csi_len);
+		moal_memcpy_ext(priv->phandle, pmevent->event_buf, CUS_EVT_CSI,
+				strlen(CUS_EVT_CSI), strlen(CUS_EVT_CSI));
+		moal_memcpy_ext(priv->phandle,
+				pmevent->event_buf + strlen(CUS_EVT_CSI),
+				(t_u8 *)(&(priv->csi_seq)),
+				sizeof(priv->csi_seq), sizeof(priv->csi_seq));
+		woal_broadcast_event(priv, pmevent->event_buf,
+				     custom_len + csi_len);
+		priv->csi_seq++;
+		break;
 	default:
 		break;
 	}
@@ -2972,13 +4603,14 @@ mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent)
 /**
  *  @brief This function prints the debug message in mlan
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param level    debug level
  *  @param pformat  point to string format buf
  *
  *  @return         N/A
  */
-t_void moal_print(t_void *pmoal_handle, t_u32 level, char *pformat, IN...)
+__attribute__((format(printf, 3, 4))) t_void
+moal_print(t_void *pmoal, t_u32 level, char *pformat, IN...)
 {
 #ifdef DEBUG_LEVEL1
 	va_list args;
@@ -3024,16 +4656,16 @@ t_void moal_print(t_void *pmoal_handle, t_u32 level, char *pformat, IN...)
 /**
  *  @brief This function prints the network interface name
  *
- *  @param pmoal_handle Pointer to the MOAL context
+ *  @param pmoal Pointer to the MOAL context
  *  @param bss_index    BSS index
  *  @param level        debug level
  *
  *  @return            N/A
  */
-t_void moal_print_netintf(t_void *pmoal_handle, t_u32 bss_index, t_u32 level)
+t_void moal_print_netintf(t_void *pmoal, t_u32 bss_index, t_u32 level)
 {
 #ifdef DEBUG_LEVEL1
-	moal_handle *phandle = (moal_handle *)pmoal_handle;
+	moal_handle *phandle = (moal_handle *)pmoal;
 
 	if (phandle) {
 		if ((bss_index < MLAN_MAX_BSS_NUM) &&
@@ -3050,12 +4682,12 @@ t_void moal_print_netintf(t_void *pmoal_handle, t_u32 bss_index, t_u32 level)
 /**
  *  @brief This function asserts the existence of the passed argument
  *
- *  @param pmoal_handle     A pointer to moal_private structure
+ *  @param pmoal     A pointer to moal_private structure
  *  @param cond             Condition to check
  *
  *  @return                 N/A
  */
-t_void moal_assert(t_void *pmoal_handle, t_u32 cond)
+t_void moal_assert(t_void *pmoal, t_u32 cond)
 {
 	if (!cond) {
 		panic("Assert failed: Panic!");
@@ -3065,7 +4697,7 @@ t_void moal_assert(t_void *pmoal_handle, t_u32 cond)
 /**
  *  @brief This function save the histogram data
  *
- *  @param pmoal_handle     A pointer to moal_private structure
+ *  @param pmoal     A pointer to moal_private structure
  *  @param bss_index        BSS index
  *  @param rx_rate          rx rate index
  *  @param snr              snr
@@ -3074,17 +4706,48 @@ t_void moal_assert(t_void *pmoal_handle, t_u32 cond)
  *
  *  @return                 N/A
  */
-t_void moal_hist_data_add(t_void *pmoal_handle, t_u32 bss_index, t_u16 rx_rate,
+t_void moal_hist_data_add(t_void *pmoal, t_u32 bss_index, t_u16 rx_rate,
 			  t_s8 snr, t_s8 nflr, t_u8 antenna)
 {
 	moal_private *priv = NULL;
-	priv = woal_bss_index_to_priv(pmoal_handle, bss_index);
+	priv = woal_bss_index_to_priv(pmoal, bss_index);
 	if (priv && antenna >= priv->phandle->card_info->histogram_table_num)
 		antenna = 0;
 	if (priv && priv->hist_data[antenna])
 		woal_hist_data_add(priv, rx_rate, snr, nflr, antenna);
 }
 
+/**
+ *  @brief This function update the peer signal
+ *
+ *  @param pmoal     A pointer to moal_private structure
+ *  @param bss_index        BSS index
+ *  @param peer_addr        peer address
+ *  @param snr              snr
+ *  @param nflr             noise floor
+ *
+ *  @return                 N/A
+ */
+t_void moal_updata_peer_signal(t_void *pmoal, t_u32 bss_index, t_u8 *peer_addr,
+			       t_s8 snr, t_s8 nflr)
+{
+	moal_private *priv = NULL;
+	struct tdls_peer *peer = NULL;
+	unsigned long flags;
+	priv = woal_bss_index_to_priv(pmoal, bss_index);
+	if (priv && priv->enable_auto_tdls) {
+		spin_lock_irqsave(&priv->tdls_lock, flags);
+		list_for_each_entry (peer, &priv->tdls_list, link) {
+			if (!memcmp(peer->peer_addr, peer_addr, ETH_ALEN)) {
+				peer->rssi = nflr - snr;
+				peer->rssi_jiffies = jiffies;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	}
+}
+
 /**
  *  @brief Performs division of 64-bit num with base
  *  @brief do_div does two things
@@ -3107,14 +4770,14 @@ t_u64 moal_do_div(t_u64 num, t_u32 base)
 /**
  *  @brief Performs wait event
  *
- *  @param pmoal_handle   t_void
+ *  @param pmoal   t_void
  *  @param bss_index      index of priv
  *  @return      MLAN_STATUS_SUCCESS
  */
-mlan_status moal_wait_hostcmd_complete(t_void *pmoal_handle, t_u32 bss_index)
+mlan_status moal_wait_hostcmd_complete(t_void *pmoal, t_u32 bss_index)
 {
 	mlan_status status = MLAN_STATUS_SUCCESS;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	moal_private *priv = woal_bss_index_to_priv(handle, bss_index);
 	long time_left = 0;
 
@@ -3143,14 +4806,14 @@ mlan_status moal_wait_hostcmd_complete(t_void *pmoal_handle, t_u32 bss_index)
 /**
  *  @brief wake up esa wait_q
  *
- *  @param pmoal_handle   t_void
+ *  @param pmoal   t_void
  *  @param bss_index      index of priv
  *  @return      MLAN_STATUS_SUCCESS
  */
-mlan_status moal_notify_hostcmd_complete(t_void *pmoal_handle, t_u32 bss_index)
+mlan_status moal_notify_hostcmd_complete(t_void *pmoal, t_u32 bss_index)
 {
 	mlan_status status = MLAN_STATUS_SUCCESS;
-	moal_handle *handle = (moal_handle *)pmoal_handle;
+	moal_handle *handle = (moal_handle *)pmoal;
 	moal_private *priv = woal_bss_index_to_priv(handle, bss_index);
 
 	ENTER();
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.h
old mode 100644
new mode 100755
index e692a0830..c7f947ee7
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_shim.h
@@ -4,7 +4,7 @@
  * functions defined in moal module
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -28,93 +28,106 @@
 #ifndef _MOAL_H
 #define _MOAL_H
 
-mlan_status moal_get_fw_data(t_void *pmoal_handle, t_u32 offset, t_u32 len,
+mlan_status moal_get_fw_data(t_void *pmoal, t_u32 offset, t_u32 len,
 			     t_u8 *pbuf);
-mlan_status moal_get_vdll_data(t_void *pmoal_handle, t_u32 len, t_u8 *pbuf);
-mlan_status moal_get_hw_spec_complete(t_void *pmoal_handle, mlan_status status,
+mlan_status moal_get_vdll_data(t_void *pmoal, t_u32 len, t_u8 *pbuf);
+mlan_status moal_get_hw_spec_complete(t_void *pmoal, mlan_status status,
 				      mlan_hw_info *phw, pmlan_bss_tbl ptbl);
-mlan_status moal_init_fw_complete(t_void *pmoal_handle, mlan_status status);
-mlan_status moal_shutdown_fw_complete(t_void *pmoal_handle, mlan_status status);
-mlan_status moal_ioctl_complete(t_void *pmoal_handle,
-				pmlan_ioctl_req pioctl_req, mlan_status status);
-mlan_status moal_alloc_mlan_buffer(t_void *pmoal_handle, t_u32 size,
+mlan_status moal_init_fw_complete(t_void *pmoal, mlan_status status);
+mlan_status moal_shutdown_fw_complete(t_void *pmoal, mlan_status status);
+mlan_status moal_ioctl_complete(t_void *pmoal, pmlan_ioctl_req pioctl_req,
+				mlan_status status);
+mlan_status moal_alloc_mlan_buffer(t_void *pmoal, t_u32 size,
 				   pmlan_buffer *pmbuf);
-mlan_status moal_free_mlan_buffer(t_void *pmoal_handle, pmlan_buffer pmbuf);
-mlan_status moal_send_packet_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
+mlan_status moal_free_mlan_buffer(t_void *pmoal, pmlan_buffer pmbuf);
+mlan_status moal_send_packet_complete(t_void *pmoal, pmlan_buffer pmbuf,
 				      mlan_status status);
 #ifdef USB
-mlan_status moal_recv_complete(t_void *pmoal_handle, pmlan_buffer pmbuf,
-			       t_u32 port, mlan_status status);
-mlan_status moal_write_data_async(t_void *pmoal_handle, pmlan_buffer pmbuf,
+mlan_status moal_recv_complete(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+			       mlan_status status);
+mlan_status moal_write_data_async(t_void *pmoal, pmlan_buffer pmbuf,
 				  t_u32 port);
 #endif
 
 #if defined(SDIO) || defined(PCIE)
 /** moal_write_reg */
-mlan_status moal_write_reg(t_void *pmoal_handle, t_u32 reg, t_u32 data);
+mlan_status moal_write_reg(t_void *pmoal, t_u32 reg, t_u32 data);
 /** moal_read_reg */
-mlan_status moal_read_reg(t_void *pmoal_handle, t_u32 reg, t_u32 *data);
+mlan_status moal_read_reg(t_void *pmoal, t_u32 reg, t_u32 *data);
 #endif /* SDIO || PCIE */
-mlan_status moal_write_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
-				 t_u32 port, t_u32 timeout);
-mlan_status moal_read_data_sync(t_void *pmoal_handle, pmlan_buffer pmbuf,
-				t_u32 port, t_u32 timeout);
-mlan_status moal_recv_packet(t_void *pmoal_handle, pmlan_buffer pmbuf);
-mlan_status moal_recv_event(t_void *pmoal_handle, pmlan_event pmevent);
-mlan_status moal_malloc(t_void *pmoal_handle, t_u32 size, t_u32 flag,
-			t_u8 **ppbuf);
-mlan_status moal_mfree(t_void *pmoal_handle, t_u8 *pbuf);
-mlan_status moal_vmalloc(t_void *pmoal_handle, t_u32 size, t_u8 **ppbuf);
-mlan_status moal_vfree(t_void *pmoal_handle, t_u8 *pbuf);
+mlan_status moal_write_data_sync(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+				 t_u32 timeout);
+mlan_status moal_read_data_sync(t_void *pmoal, pmlan_buffer pmbuf, t_u32 port,
+				t_u32 timeout);
+mlan_status moal_recv_amsdu_packet(t_void *pmoal, pmlan_buffer pmbuf);
+mlan_status moal_recv_packet(t_void *pmoal, pmlan_buffer pmbuf);
+mlan_status moal_recv_event(t_void *pmoal, pmlan_event pmevent);
+mlan_status moal_malloc(t_void *pmoal, t_u32 size, t_u32 flag, t_u8 **ppbuf);
+mlan_status moal_mfree(t_void *pmoal, t_u8 *pbuf);
+mlan_status moal_vmalloc(t_void *pmoal, t_u32 size, t_u8 **ppbuf);
+mlan_status moal_vfree(t_void *pmoal, t_u8 *pbuf);
 #ifdef PCIE
-mlan_status moal_malloc_consistent(t_void *pmoal_handle, t_u32 size,
-				   t_u8 **ppbuf, t_pu64 pbuf_pa);
-mlan_status moal_mfree_consistent(t_void *pmoal_handle, t_u32 size, t_u8 *pbuf,
+mlan_status moal_malloc_consistent(t_void *pmoal, t_u32 size, t_u8 **ppbuf,
+				   t_pu64 pbuf_pa);
+mlan_status moal_mfree_consistent(t_void *pmoal, t_u32 size, t_u8 *pbuf,
 				  t_u64 buf_pa);
-mlan_status moal_map_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 *pbuf_pa,
+mlan_status moal_map_memory(t_void *pmoal, t_u8 *pbuf, t_u64 *pbuf_pa,
 			    t_u32 size, t_u32 flag);
-mlan_status moal_unmap_memory(t_void *pmoal_handle, t_u8 *pbuf, t_u64 buf_pa,
+mlan_status moal_unmap_memory(t_void *pmoal, t_u8 *pbuf, t_u64 buf_pa,
 			      t_u32 size, t_u32 flag);
 #endif /* PCIE */
-t_void *moal_memset(t_void *pmoal_handle, t_void *pmem, t_u8 byte, t_u32 num);
-t_void *moal_memcpy(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
+t_void *moal_memset(t_void *pmoal, t_void *pmem, t_u8 byte, t_u32 num);
+t_void *moal_memcpy(t_void *pmoal, t_void *pdest, const t_void *psrc,
 		    t_u32 num);
-t_void *moal_memcpy_ext(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
+t_void *moal_memcpy_ext(t_void *pmoal, t_void *pdest, const t_void *psrc,
 			t_u32 num, t_u32 dest_size);
 
-t_void *moal_memmove(t_void *pmoal_handle, t_void *pdest, const t_void *psrc,
+t_void *moal_memmove(t_void *pmoal, t_void *pdest, const t_void *psrc,
 		     t_u32 num);
-t_s32 moal_memcmp(t_void *pmoal_handle, const t_void *pmem1,
-		  const t_void *pmem2, t_u32 num);
+t_s32 moal_memcmp(t_void *pmoal, const t_void *pmem1, const t_void *pmem2,
+		  t_u32 num);
 /** moal_udelay */
-t_void moal_udelay(t_void *pmoal_handle, t_u32 udelay);
-t_void moal_usleep_range(t_void *pmoal_handle, t_u32 min_delay,
-			 t_u32 max_delay);
-mlan_status moal_get_boot_ktime(t_void *pmoal_handle, t_u64 *pnsec);
-mlan_status moal_get_system_time(t_void *pmoal_handle, t_u32 *psec,
-				 t_u32 *pusec);
-mlan_status moal_init_lock(t_void *pmoal_handle, t_void **pplock);
-mlan_status moal_free_lock(t_void *pmoal_handle, t_void *plock);
-mlan_status moal_spin_lock(t_void *pmoal_handle, t_void *plock);
-mlan_status moal_spin_unlock(t_void *pmoal_handle, t_void *plock);
+t_void moal_udelay(t_void *pmoal, t_u32 udelay);
+t_void moal_usleep_range(t_void *pmoal, t_u32 min_delay, t_u32 max_delay);
+mlan_status moal_get_boot_ktime(t_void *pmoal, t_u64 *pnsec);
+mlan_status moal_get_system_time(t_void *pmoal, t_u32 *psec, t_u32 *pusec);
+mlan_status moal_init_lock(t_void *pmoal, t_void **pplock);
+mlan_status moal_free_lock(t_void *pmoal, t_void *plock);
+mlan_status moal_spin_lock(t_void *pmoal, t_void *plock);
+mlan_status moal_spin_unlock(t_void *pmoal, t_void *plock);
 #if defined(DRV_EMBEDDED_AUTHENTICATOR) || defined(DRV_EMBEDDED_SUPPLICANT)
-mlan_status moal_wait_hostcmd_complete(t_void *pmoal_handle, t_u32 bss_index);
-mlan_status moal_notify_hostcmd_complete(t_void *pmoal_handle, t_u32 bss_index);
+mlan_status moal_wait_hostcmd_complete(t_void *pmoal, t_u32 bss_index);
+mlan_status moal_notify_hostcmd_complete(t_void *pmoal, t_u32 bss_index);
 #endif
-t_void moal_print(t_void *pmoal_handle, t_u32 level, char *pformat, IN...);
-t_void moal_print_netintf(t_void *pmoal_handle, t_u32 bss_index, t_u32 level);
-t_void moal_assert(t_void *pmoal_handle, t_u32 cond);
-t_void moal_hist_data_add(t_void *pmoal_handle, t_u32 bss_index, t_u16 rx_rate,
+t_void moal_print(t_void *pmoal, t_u32 level, char *pformat, IN...);
+t_void moal_print_netintf(t_void *pmoal, t_u32 bss_index, t_u32 level);
+t_void moal_assert(t_void *pmoal, t_u32 cond);
+t_void moal_hist_data_add(t_void *pmoal, t_u32 bss_index, t_u16 rx_rate,
 			  t_s8 snr, t_s8 nflr, t_u8 antenna);
 
+t_void moal_updata_peer_signal(t_void *pmoal, t_u32 bss_index, t_u8 *peer_addr,
+			       t_s8 snr, t_s8 nflr);
 t_u64 moal_do_div(t_u64 num, t_u32 base);
 
-mlan_status moal_init_timer(t_void *pmoal_handle, t_void **pptimer,
+mlan_status moal_init_timer(t_void *pmoal, t_void **pptimer,
 			    IN t_void (*callback)(t_void *pcontext),
 			    t_void *pcontext);
-mlan_status moal_free_timer(t_void *pmoal_handle, t_void *ptimer);
-mlan_status moal_start_timer(t_void *pmoal_handle, t_void *ptimer,
-			     t_u8 periodic, t_u32 msec);
-mlan_status moal_stop_timer(t_void *pmoal_handle, t_void *ptimer);
+mlan_status moal_free_timer(t_void *pmoal, t_void *ptimer);
+mlan_status moal_start_timer(t_void *pmoal, t_void *ptimer, t_u8 periodic,
+			     t_u32 msec);
+mlan_status moal_stop_timer(t_void *pmoal, t_void *ptimer);
+void moal_tp_accounting(t_void *pmoal, void *buf, t_u32 drop_point);
+void moal_tp_accounting_rx_param(t_void *pmoal, unsigned int type,
+				 unsigned int rsvd1);
+void moal_amsdu_tp_accounting(t_void *pmoal, t_s32 amsdu_process_delay,
+			      t_s32 amsdu_copy_delay);
+
+void moal_connection_status_check_pmqos(t_void *pmoal);
+#if defined(PCIE) || defined(SDIO)
+/* pmqos busfreq add request handler*/
+void woal_request_busfreq_pmqos_add(t_void *pmhandle);
+/* pmqos busfreq remove handler*/
+void woal_release_busfreq_pmqos_remove(t_void *pmhandle);
+#endif
 
 #endif /*_MOAL_H */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.c
old mode 100644
new mode 100755
index 72f70404d..3a2e8bd84
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.c
@@ -3,7 +3,7 @@
  * @brief This file contains the functions for STA CFG80211.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2023 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -35,12 +35,12 @@ extern int fw_region;
 #endif
 #endif
 /* Supported crypto cipher suits to be advertised to cfg80211 */
-const u32 cfg80211_cipher_suites[] = {
+static const u32 cfg80211_cipher_suites[] = {
 	WLAN_CIPHER_SUITE_WEP40,	WLAN_CIPHER_SUITE_WEP104,
 	WLAN_CIPHER_SUITE_TKIP,		WLAN_CIPHER_SUITE_CCMP,
 	WLAN_CIPHER_SUITE_SMS4,		WLAN_CIPHER_SUITE_AES_CMAC,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-	WLAN_CIPHER_SUITE_BIP_GMAC_256,
+	WLAN_CIPHER_SUITE_BIP_GMAC_128, WLAN_CIPHER_SUITE_BIP_GMAC_256,
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 	WLAN_CIPHER_SUITE_GCMP,
@@ -53,6 +53,12 @@ const u32 cfg80211_cipher_suites[] = {
 #endif
 };
 
+#ifdef UAP_SUPPORT
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+static int woal_cfg80211_set_monitor_channel(struct wiphy *wiphy,
+					     struct cfg80211_chan_def *chandef);
+#endif
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 static void
 #else
@@ -97,6 +103,10 @@ static int woal_cfg80211_dump_survey(struct wiphy *wiphy,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static int woal_cfg80211_get_channel(struct wiphy *wiphy,
 				     struct wireless_dev *wdev,
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+				     unsigned int link_id,
+#endif
 				     struct cfg80211_chan_def *chandef);
 #endif
 static int woal_cfg80211_set_power_mgmt(struct wiphy *wiphy,
@@ -186,6 +196,40 @@ int woal_cfg80211_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
 static void woal_cfg80211_set_wakeup(struct wiphy *wiphy, bool enabled);
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+void woal_check_auto_tdls(struct wiphy *wiphy, struct net_device *dev);
+int woal_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+			    const u8 *peer,
+#else
+			    u8 *peer,
+#endif
+			    enum nl80211_tdls_operation oper);
+int woal_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+			    const u8 *peer,
+#else
+			    u8 *peer,
+#endif
+			    u8 action_code, u8 dialog_token, u16 status_code,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+			    u32 peer_capability,
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+			    bool initiator,
+#endif
+			    const u8 *extra_ies, size_t extra_ies_len);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+static int woal_cfg80211_tdls_channel_switch(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     const u8 *addr, u8 oper_class,
+					     struct cfg80211_chan_def *chandef);
+
+void woal_cfg80211_tdls_cancel_channel_switch(struct wiphy *wiphy,
+					      struct net_device *dev,
+					      const u8 *addr);
+#endif
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 static int woal_cfg80211_change_station(struct wiphy *wiphy,
 					struct net_device *dev,
@@ -226,6 +270,7 @@ static int woal_cfg80211_add_station(struct wiphy *wiphy,
 #endif
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 static int woal_cfg80211_deauthenticate(struct wiphy *wiphy,
 					struct net_device *dev,
 					struct cfg80211_deauth_request *req);
@@ -233,6 +278,14 @@ static int woal_cfg80211_deauthenticate(struct wiphy *wiphy,
 static int woal_cfg80211_disassociate(struct wiphy *wiphy,
 				      struct net_device *dev,
 				      struct cfg80211_disassoc_request *req);
+#endif
+
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+int woal_cfg80211_set_radar_background(struct wiphy *wiphy,
+				       struct cfg80211_chan_def *chandef);
+#endif
+#endif
 
 /** cfg80211 operations */
 static struct cfg80211_ops woal_cfg80211_ops = {
@@ -243,8 +296,10 @@ static struct cfg80211_ops woal_cfg80211_ops = {
 #endif
 	.connect = woal_cfg80211_connect,
 	.disconnect = woal_cfg80211_disconnect,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 	.deauth = woal_cfg80211_deauthenticate,
 	.disassoc = woal_cfg80211_disassociate,
+#endif
 	.get_station = woal_cfg80211_get_station,
 	.dump_station = woal_cfg80211_dump_station,
 	.dump_survey = woal_cfg80211_dump_survey,
@@ -261,6 +316,10 @@ static struct cfg80211_ops woal_cfg80211_ops = {
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 30)
 	.set_default_mgmt_key = woal_cfg80211_set_default_mgmt_key,
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	.set_default_beacon_key = woal_cfg80211_set_default_beacon_key,
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 1, 0)
 	.set_rekey_data = woal_cfg80211_set_rekey_data,
 #endif
@@ -291,6 +350,14 @@ static struct cfg80211_ops woal_cfg80211_ops = {
 #if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 35)
 	.set_cqm_rssi_config = woal_cfg80211_set_cqm_rssi_config,
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	.tdls_oper = woal_cfg80211_tdls_oper,
+	.tdls_mgmt = woal_cfg80211_tdls_mgmt,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	.tdls_channel_switch = woal_cfg80211_tdls_channel_switch,
+	.tdls_cancel_channel_switch = woal_cfg80211_tdls_cancel_channel_switch,
+#endif
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 	.change_station = woal_cfg80211_change_station,
 #endif
@@ -349,6 +416,11 @@ static struct cfg80211_ops woal_cfg80211_ops = {
 	.cancel_remain_on_channel = woal_cfg80211_cancel_remain_on_channel,
 #endif
 
+#ifdef UAP_SUPPORT
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	.set_monitor_channel = woal_cfg80211_set_monitor_channel,
+#endif
+#endif
 #ifdef CONFIG_NL80211_TESTMODE
 	.testmode_cmd = woal_testmode_cmd,
 #endif
@@ -376,6 +448,8 @@ static const struct ieee80211_regdomain mrvl_regdom = {
 		/* IEEE 802.11a, channel 100..165 */
 		REG_RULE(5470 - 10, 5850 + 10, 80, 6, 20, 0),
 	}};
+
+#define AUTH_TX_DEFAULT_WAIT_TIME 2400
 /********************************************************
 				Local Variables
 ********************************************************/
@@ -436,7 +510,7 @@ static const struct ieee80211_txrx_stypes
 // clang-format on
 #endif
 
-#if CFG80211_VERSION_CODE > KERNEL_VERSION(3, 0, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
 /**
  * NOTE: types in all the sets must be equals to the
  * initial value of wiphy->interface_modes
@@ -445,7 +519,7 @@ static const struct ieee80211_iface_limit cfg80211_ap_sta_limits[] = {
 	{.max = 4,
 	 .types = MBIT(NL80211_IFTYPE_STATION)
 #ifdef UAP_CFG80211
-		  | MBIT(NL80211_IFTYPE_AP)
+		  | MBIT(NL80211_IFTYPE_AP) | MBIT(NL80211_IFTYPE_MONITOR)
 #endif
 #ifdef WIFI_DIRECT_SUPPORT
 #if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
@@ -509,6 +583,104 @@ static const struct wiphy_coalesce_support coalesce_support = {
 /********************************************************
 				Local Functions
 ********************************************************/
+#ifdef UAP_SUPPORT
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+static int woal_cfg80211_set_monitor_channel(struct wiphy *wiphy,
+					     struct cfg80211_chan_def *chandef)
+{
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+	moal_private *priv =
+		(moal_private *)woal_get_priv(handle, MLAN_BSS_ROLE_STA);
+	netmon_band_chan_cfg band_chan_cfg;
+	t_u32 bandwidth = 0;
+	int ret = -EFAULT;
+
+	ENTER();
+
+	if (!priv) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (handle->mon_if) {
+		if (cfg80211_chandef_identical(&handle->mon_if->chandef,
+					       chandef)) {
+			ret = 0;
+			goto done;
+		}
+		if (woal_is_any_interface_active(handle)) {
+			PRINTM(MERROR,
+			       "Cannot change monitor channel for an active"
+			       " interface\n");
+			goto done;
+		}
+		memset(&band_chan_cfg, 0x00, sizeof(band_chan_cfg));
+		/* Set channel */
+		band_chan_cfg.channel = ieee80211_frequency_to_channel(
+			chandef->chan->center_freq);
+		/* Set band */
+		if (chandef->chan->band == IEEE80211_BAND_2GHZ)
+			band_chan_cfg.band |= (BAND_B | BAND_G);
+		if (chandef->chan->band == IEEE80211_BAND_5GHZ)
+			band_chan_cfg.band |= BAND_A;
+		if (chandef->chan->band == IEEE80211_BAND_2GHZ)
+			band_chan_cfg.band |= BAND_GN;
+		if (chandef->chan->band == IEEE80211_BAND_5GHZ)
+			band_chan_cfg.band |= BAND_AN;
+		if (chandef->chan->band == IEEE80211_BAND_2GHZ)
+			band_chan_cfg.band |= BAND_GAC;
+		if (chandef->chan->band == IEEE80211_BAND_5GHZ)
+			band_chan_cfg.band |= BAND_AAC;
+		/* Set bandwidth */
+		if (chandef->width == NL80211_CHAN_WIDTH_20)
+			bandwidth = CHANNEL_BW_20MHZ;
+		else if (chandef->width == NL80211_CHAN_WIDTH_40)
+			bandwidth = chandef->center_freq1 >
+						    chandef->chan->center_freq ?
+					    CHANNEL_BW_40MHZ_ABOVE :
+					    CHANNEL_BW_40MHZ_BELOW;
+		else if (chandef->width == NL80211_CHAN_WIDTH_80)
+			bandwidth = CHANNEL_BW_80MHZ;
+		band_chan_cfg.chan_bandwidth = bandwidth;
+
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_net_monitor(priv, MOAL_IOCTL_WAIT, MTRUE,
+					 handle->mon_if->flag,
+					 &band_chan_cfg)) {
+			PRINTM(MERROR, "%s: woal_set_net_monitor fail\n",
+			       __func__);
+			ret = -EFAULT;
+			goto done;
+		}
+
+		moal_memcpy_ext(priv->phandle, &handle->mon_if->band_chan_cfg,
+				&band_chan_cfg,
+				sizeof(handle->mon_if->band_chan_cfg),
+				sizeof(handle->mon_if->band_chan_cfg));
+		handle->mon_if->chandef = *chandef;
+
+		if (handle->mon_if->chandef.chan)
+			PRINTM(MINFO,
+			       "set_monitor_channel+++ chan[band=%d center_freq=%d hw_value=%d] width=%d center_freq1=%d center_freq2=%d\n",
+			       handle->mon_if->chandef.chan->band,
+			       handle->mon_if->chandef.chan->center_freq,
+			       handle->mon_if->chandef.chan->hw_value,
+			       handle->mon_if->chandef.width,
+			       handle->mon_if->chandef.center_freq1,
+			       handle->mon_if->chandef.center_freq2);
+		PRINTM(MINFO,
+		       "set_monitor_channel+++ band=%x channel=%d bandwidth=%d\n",
+		       handle->mon_if->band_chan_cfg.band,
+		       handle->mon_if->band_chan_cfg.channel,
+		       handle->mon_if->band_chan_cfg.chan_bandwidth);
+		ret = 0;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+#endif
+#endif
 
 /**
  *  @brief This function check cfg80211 special region code.
@@ -723,8 +895,8 @@ static int woal_wps_cfg(moal_private *priv, int enable)
  *
  * @return                  0 -- success, otherwise fail
  */
-static int woal_cfg80211_assoc_ies_cfg(moal_private *priv, t_u8 *ie, int ie_len,
-				       t_u8 wait_option)
+static int woal_cfg80211_assoc_ies_cfg(moal_private *priv, t_u8 *ie,
+				       size_t ie_len, t_u8 wait_option)
 {
 	int bytes_left = ie_len;
 	t_u8 *pcurrent_ptr = ie;
@@ -736,13 +908,16 @@ static int woal_cfg80211_assoc_ies_cfg(moal_private *priv, t_u8 *ie, int ie_len,
 	t_u8 wps_oui[] = {0x00, 0x50, 0xf2, 0x04};
 	t_u8 hs20_oui[] = {0x50, 0x6f, 0x9a, 0x10};
 
+	t_u8 multiap_oui[] = {0x50, 0x6f, 0x9a, 0x1b};
+	t_u8 multiap_flag = 0;
+
 	while (bytes_left >= 2) {
 		element_id = (IEEEtypes_ElementId_e)(*((t_u8 *)pcurrent_ptr));
 		element_len = *((t_u8 *)pcurrent_ptr + 1);
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 		if (bytes_left < total_ie_len) {
-			PRINTM(MERROR,
-			       "InterpretIE: Error in processing IE, bytes left < IE length\n");
+			//PRINTM(MINFO,
+			//       "InterpretIE: Error in processing IE, bytes left < IE length\n");
 			bytes_left = 0;
 			continue;
 		}
@@ -764,8 +939,30 @@ static int woal_cfg80211_assoc_ies_cfg(moal_private *priv, t_u8 *ie, int ie_len,
 				    sizeof(pvendor_ie->vend_hdr.oui)) &&
 			    (pvendor_ie->vend_hdr.oui_type == wps_oui[3])) {
 				PRINTM(MIOCTL, "Enable WPS session\n");
-				woal_wps_cfg(priv, MTRUE);
+				if (woal_wps_cfg(priv, MTRUE)) {
+					PRINTM(MERROR,
+					       "%s: Enable WPS session failed\n",
+					       __func__);
+					ret = -EFAULT;
+					goto done;
+				}
+			}
+
+			if (!memcmp(pvendor_ie->vend_hdr.oui, multiap_oui,
+				    sizeof(pvendor_ie->vend_hdr.oui)) &&
+			    (pvendor_ie->vend_hdr.oui_type == multiap_oui[3])) {
+				multiap_flag = pvendor_ie->data[0];
+				if (MLAN_STATUS_SUCCESS !=
+				    woal_multi_ap_cfg(priv, wait_option,
+						      multiap_flag)) {
+					PRINTM(MERROR,
+					       "%s: failed to configure multi ap\n",
+					       __func__);
+					ret = -EFAULT;
+					goto done;
+				}
 			}
+
 			if (!memcmp(pvendor_ie->vend_hdr.oui, hs20_oui,
 				    sizeof(pvendor_ie->vend_hdr.oui)) &&
 			    (pvendor_ie->vend_hdr.oui_type == hs20_oui[3])) {
@@ -1020,16 +1217,9 @@ static mlan_status woal_send_domain_info_cmd_fw(moal_private *priv,
 		goto done;
 	}
 
-	if (MTRUE ==
-	    is_cfg80211_special_region_code(priv->phandle->country_code)) {
-		PRINTM(MIOCTL,
-		       "skip region code config, cfg80211 special region code: %s\n",
-		       priv->phandle->country_code);
-		goto done;
-	}
-	PRINTM(MIOCTL, "Send domain info: country=%c%c band=%d\n",
+	PRINTM(MCMD_D, "Send domain info: country=%c%c band=%d dfs_region=%d\n",
 	       priv->phandle->country_code[0], priv->phandle->country_code[1],
-	       band);
+	       band, priv->phandle->dfs_region);
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11d_cfg));
 	if (req == NULL) {
@@ -1040,12 +1230,18 @@ static mlan_status woal_send_domain_info_cmd_fw(moal_private *priv,
 	cfg_11d->sub_command = MLAN_OID_11D_DOMAIN_INFO_EXT;
 	req->req_id = MLAN_IOCTL_11D_CFG;
 	req->action = MLAN_ACT_SET;
-
-	/* Set country code */
-	cfg_11d->param.domain_info.country_code[0] =
-		priv->phandle->country_code[0];
-	cfg_11d->param.domain_info.country_code[1] =
-		priv->phandle->country_code[1];
+	cfg_11d->param.domain_info.dfs_region = priv->phandle->dfs_region;
+	if (is_cfg80211_special_region_code(priv->phandle->country_code)) {
+		/* Set country code */
+		cfg_11d->param.domain_info.country_code[0] = 'W';
+		cfg_11d->param.domain_info.country_code[1] = 'W';
+	} else {
+		/* Set country code */
+		cfg_11d->param.domain_info.country_code[0] =
+			priv->phandle->country_code[0];
+		cfg_11d->param.domain_info.country_code[1] =
+			priv->phandle->country_code[1];
+	}
 	cfg_11d->param.domain_info.country_code[2] = ' ';
 	cfg_11d->param.domain_info.band = band;
 
@@ -1206,26 +1402,25 @@ int woal_set_rf_channel(moal_private *priv, struct ieee80211_channel *chan,
  *  @return                     MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING --
  * success, otherwise fail
  */
-mlan_status woal_set_ewpa_mode(moal_private *priv, t_u8 wait_option,
-			       mlan_ssid_bssid *ssid_bssid)
+static mlan_status woal_set_ewpa_mode(moal_private *priv, t_u8 wait_option,
+				      mlan_ssid_bssid *ssid_bssid)
 {
-	int ret = 0;
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_sec_cfg *sec = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 
-	if (!priv->phandle->card_info->embedded_supp) {
-		ret = -EOPNOTSUPP;
+	if (!priv->phandle->card_info->embedded_supp)
 		goto error;
-	}
+
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_sec_cfg));
 	if (req == NULL) {
-		ret = -ENOMEM;
+		status = MLAN_STATUS_FAILURE;
 		goto error;
 	}
+
 	/* Fill request buffer */
 	sec = (mlan_ds_sec_cfg *)req->pbuf;
 	sec->sub_command = MLAN_OID_SEC_CFG_PASSPHRASE;
@@ -1297,6 +1492,35 @@ static int woal_cfg80211_set_auth(moal_private *priv, int encrypt_mode,
 	return ret;
 }
 
+/**
+ * @brief Reset the wifi
+ *
+ * @param handle        A pointer to moal_handle structure
+ * @param cnt           wifi reset count
+ * @param reason        wifi reset reason
+ *
+ * @return              MLAN_STATUS_SUCCESS or MLAN_STATUS_PENDING
+ */
+mlan_status woal_reset_wifi(moal_handle *handle, t_u8 cnt, char *reason)
+{
+	static wifi_timeval reset_time;
+	wifi_timeval ts;
+	t_u64 diff;
+
+#define MAX_WIFI_RESET_INTERVAL 15 * 60 * 1000000 // 15 minute
+	woal_get_monotonic_time(&ts);
+	diff = (t_u64)(timeval_to_usec(ts) - timeval_to_usec(reset_time));
+	PRINTM(MERROR, "WiFi Reset diff %lld\n", diff);
+	if (reset_time.time_sec == 0 || diff >= MAX_WIFI_RESET_INTERVAL) {
+		reset_time = ts;
+		PRINTM(MERROR, "WiFi Reset due to %s cnt %d\n", reason, cnt);
+		/* Do wifi independent reset */
+		woal_process_hang(handle);
+		return MLAN_STATUS_SUCCESS;
+	}
+	return MLAN_STATUS_PENDING;
+}
+
 /**
  * @brief Informs the CFG802.11 subsystem of a new BSS connection.
  *
@@ -1350,7 +1574,7 @@ mlan_status woal_inform_bss_from_scan_result(moal_private *priv,
 
 	if (scan_resp.num_in_scan_table) {
 		scan_table = (BSSDescriptor_t *)scan_resp.pscan_table;
-		for (i = 0; i < scan_resp.num_in_scan_table; i++) {
+		for (i = 0; i < (int)scan_resp.num_in_scan_table; i++) {
 			if (ssid_bssid) {
 				/* Inform specific BSS only */
 				if (memcmp(ssid_bssid->ssid.ssid,
@@ -1535,8 +1759,10 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
+	rcu_read_lock();
 	country_ie = (u8 *)ieee80211_bss_get_ie(bss, WLAN_EID_COUNTRY);
 	if (!country_ie) {
+		rcu_read_unlock();
 		PRINTM(MIOCTL, "No country IE found!\n");
 		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
 		LEAVE();
@@ -1545,6 +1771,7 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 
 	country_ie_len = country_ie[1];
 	if (country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN) {
+		rcu_read_unlock();
 		PRINTM(MIOCTL, "Wrong Country IE length!\n");
 		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
 		LEAVE();
@@ -1554,6 +1781,7 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 	priv->phandle->country_code[1] = country_ie[3];
 	priv->phandle->country_code[2] = ' ';
 	if (is_cfg80211_special_region_code(priv->phandle->country_code)) {
+		rcu_read_unlock();
 		PRINTM(MIOCTL, "Skip special region code in CountryIE");
 		LEAVE();
 		return 0;
@@ -1565,6 +1793,7 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11d_cfg));
 	if (req == NULL) {
+		rcu_read_unlock();
 		PRINTM(MERROR, "Fail to allocate mlan_ds_11d_cfg buffer\n");
 		ret = MLAN_STATUS_FAILURE;
 		goto done;
@@ -1575,6 +1804,7 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 	req->req_id = MLAN_IOCTL_11D_CFG;
 	req->action = MLAN_ACT_SET;
 
+	cfg_11d->param.domain_info.dfs_region = NXP_DFS_UNKNOWN;
 	/* Set country code */
 	cfg_11d->param.domain_info.country_code[0] =
 		priv->phandle->country_code[0];
@@ -1599,6 +1829,8 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
 	PRINTM(MCMND, "11D: Country IE: %c%c band=%d no_of_sub_band=%d\n",
 	       country_ie[2], country_ie[3], priv->phandle->band,
 	       cfg_11d->param.domain_info.no_of_sub_band);
+	rcu_read_unlock();
+
 	/* Send domain info command to FW */
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
@@ -1622,13 +1854,14 @@ static int woal_process_country_ie(moal_private *priv, struct cfg80211_bss *bss)
  *
  * @return                0 -- success, otherwise fail
  */
-int woal_cfg80211_connect_scan(moal_private *priv,
-			       struct cfg80211_connect_params *conn_param,
-			       t_u8 wait_option)
+static int
+woal_cfg80211_connect_scan(moal_private *priv,
+			   struct cfg80211_connect_params *conn_param,
+			   t_u8 wait_option)
 {
 	moal_handle *handle = priv->phandle;
 	int ret = 0;
-	wlan_user_scan_cfg scan_req;
+	wlan_user_scan_cfg *scan_req;
 	enum ieee80211_band band;
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_channel *ch;
@@ -1647,25 +1880,35 @@ int woal_cfg80211_connect_scan(moal_private *priv,
 		return -EBUSY;
 	}
 #endif /* REASSOCIATION */
+	scan_req = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
 	priv->report_scan_result = MTRUE;
-	memset(&scan_req, 0x00, sizeof(scan_req));
-	moal_memcpy_ext(priv->phandle, scan_req.ssid_list[0].ssid,
+	memset(scan_req, 0x00, sizeof(wlan_user_scan_cfg));
+	moal_memcpy_ext(priv->phandle, scan_req->ssid_list[0].ssid,
 			conn_param->ssid, conn_param->ssid_len,
-			sizeof(scan_req.ssid_list[0].ssid));
-	scan_req.ssid_list[0].max_len = 0;
+			sizeof(scan_req->ssid_list[0].ssid));
+	scan_req->ssid_list[0].max_len = 0;
 	if (conn_param->channel) {
-		scan_req.chan_list[0].chan_number =
+		scan_req->chan_list[0].chan_number =
 			conn_param->channel->hw_value;
-		scan_req.chan_list[0].radio_type = conn_param->channel->band;
+		scan_req->chan_list[0].radio_type =
+			woal_ieee_band_to_radio_type(conn_param->channel->band);
 		if (conn_param->channel->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-			scan_req.chan_list[0].scan_type =
+			scan_req->chan_list[0].scan_type =
 				MLAN_SCAN_TYPE_PASSIVE;
 		else if (conn_param->channel->flags & IEEE80211_CHAN_RADAR)
-			scan_req.chan_list[0].scan_type =
+			scan_req->chan_list[0].scan_type =
 				MLAN_SCAN_TYPE_PASSIVE_TO_ACTIVE;
 		else
-			scan_req.chan_list[0].scan_type = MLAN_SCAN_TYPE_ACTIVE;
-		scan_req.chan_list[0].scan_time = 0;
+			scan_req->chan_list[0].scan_type =
+				MLAN_SCAN_TYPE_ACTIVE;
+		scan_req->chan_list[0].scan_time = 0;
 	} else {
 		for (band = 0; (band < IEEE80211_NUM_BANDS); band++) {
 			if (!priv->wdev->wiphy->bands[band])
@@ -1675,25 +1918,27 @@ int woal_cfg80211_connect_scan(moal_private *priv,
 				ch = &sband->channels[i];
 				if (ch->flags & IEEE80211_CHAN_DISABLED)
 					continue;
-				scan_req.chan_list[chan_idx].radio_type = band;
+				scan_req->chan_list[chan_idx].radio_type =
+					woal_ieee_band_to_radio_type(band);
 				if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
-					scan_req.chan_list[chan_idx].scan_type =
+					scan_req->chan_list[chan_idx].scan_type =
 						MLAN_SCAN_TYPE_PASSIVE;
 				else if (ch->flags & IEEE80211_CHAN_RADAR)
-					scan_req.chan_list[chan_idx].scan_type =
+					scan_req->chan_list[chan_idx].scan_type =
 						MLAN_SCAN_TYPE_PASSIVE_TO_ACTIVE;
 				else
-					scan_req.chan_list[chan_idx].scan_type =
+					scan_req->chan_list[chan_idx].scan_type =
 						MLAN_SCAN_TYPE_ACTIVE;
-				scan_req.chan_list[chan_idx].chan_number =
+				scan_req->chan_list[chan_idx].chan_number =
 					(u32)ch->hw_value;
 				chan_idx++;
 			}
 		}
 	}
-	moal_memcpy_ext(priv->phandle, scan_req.random_mac, priv->random_mac,
-			ETH_ALEN, sizeof(scan_req.random_mac));
-	ret = woal_request_userscan(priv, wait_option, &scan_req);
+	moal_memcpy_ext(priv->phandle, scan_req->random_mac, priv->random_mac,
+			ETH_ALEN, sizeof(scan_req->random_mac));
+	ret = woal_request_userscan(priv, wait_option, scan_req);
+	kfree(scan_req);
 #ifdef REASSOCIATION
 	MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
 #endif
@@ -1708,12 +1953,13 @@ int woal_cfg80211_connect_scan(moal_private *priv,
  * @param priv            A pointer to moal_private
  * @param req             A pointer to cfg80211_assoc_request structure
  */
-void woal_save_assoc_params(moal_private *priv,
-			    struct cfg80211_assoc_request *req,
-			    mlan_ssid_bssid *ssid_bssid)
+static void woal_save_assoc_params(moal_private *priv,
+				   struct cfg80211_assoc_request *req,
+				   mlan_ssid_bssid *ssid_bssid)
 {
 	ENTER();
 
+	priv->assoc_bss = req->bss;
 	if (req->bss->channel) {
 		priv->sme_current.channel = &priv->conn_chan;
 		moal_memcpy_ext(priv->phandle, priv->sme_current.channel,
@@ -1726,7 +1972,7 @@ void woal_save_assoc_params(moal_private *priv,
 			req->bss->bssid, MLAN_MAC_ADDR_LENGTH,
 			MLAN_MAC_ADDR_LENGTH);
 	if (req->ie && req->ie_len) {
-		priv->sme_current.ie = kzalloc(req->ie_len, GFP_KERNEL);
+		priv->sme_current.ie = kzalloc(req->ie_len, GFP_ATOMIC);
 		priv->sme_current.ie_len = req->ie_len;
 		moal_memcpy_ext(priv->phandle, (void *)priv->sme_current.ie,
 				req->ie, req->ie_len, priv->sme_current.ie_len);
@@ -1751,6 +1997,7 @@ void woal_save_assoc_params(moal_private *priv,
 #endif
 	if (ssid_bssid && ssid_bssid->ssid.ssid_len) {
 		priv->sme_current.ssid = priv->conn_ssid;
+		priv->sme_current.ssid_len = ssid_bssid->ssid.ssid_len;
 		memset(priv->conn_ssid, 0, MLAN_MAX_SSID_LENGTH);
 		moal_memcpy_ext(priv->phandle, (void *)priv->sme_current.ssid,
 				ssid_bssid->ssid.ssid,
@@ -1758,6 +2005,10 @@ void woal_save_assoc_params(moal_private *priv,
 				sizeof(priv->conn_ssid));
 		priv->conn_ssid_len = ssid_bssid->ssid.ssid_len;
 	}
+	if (priv->sinfo)
+		memset(priv->sinfo, 0, sizeof(struct station_info));
+	else
+		priv->sinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);
 	LEAVE();
 }
 
@@ -1767,11 +2018,12 @@ void woal_save_assoc_params(moal_private *priv,
  * @param priv            A pointer to moal_private
  * @param req             A pointer to struct cfg80211_auth_request
  */
-void woal_save_auth_params(moal_private *priv,
-			   struct cfg80211_auth_request *req)
+static void woal_save_auth_params(moal_private *priv,
+				  struct cfg80211_auth_request *req)
 {
 	ENTER();
 	woal_clear_conn_params(priv);
+	priv->assoc_bss = req->bss;
 	priv->sme_current.auth_type = req->auth_type;
 	priv->sme_current.key_idx = req->key_idx;
 	priv->sme_current.key_len = req->key_len;
@@ -1784,6 +2036,114 @@ void woal_save_auth_params(moal_private *priv,
 	LEAVE();
 }
 
+/**
+ * @brief Request scan based on auth_request parameter
+ *
+ * @param priv            A pointer to moal_private structure
+ * @param req             A pointer to cfg80211_auth_request
+ * @param wait_option     wait option
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_cfg80211_auth_scan(moal_private *priv,
+				   struct cfg80211_auth_request *req,
+				   t_u8 wait_option)
+{
+	moal_handle *handle = priv->phandle;
+	int ret = 0;
+	wlan_user_scan_cfg *scan_req;
+	enum ieee80211_band band;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	int chan_idx = 0, i;
+	const u8 *ssid;
+
+	ENTER();
+	if (handle->scan_pending_on_block == MTRUE) {
+		PRINTM(MINFO, "scan already in processing...\n");
+		LEAVE();
+		return ret;
+	}
+#ifdef REASSOCIATION
+	if (MOAL_ACQ_SEMAPHORE_BLOCK(&handle->reassoc_sem)) {
+		PRINTM(MERROR, "Acquire semaphore error, woal_do_combo_scan\n");
+		LEAVE();
+		return -EBUSY;
+	}
+#endif /* REASSOCIATION */
+	scan_req = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	priv->report_scan_result = MTRUE;
+	memset(scan_req, 0x00, sizeof(wlan_user_scan_cfg));
+	rcu_read_lock();
+	ssid = ieee80211_bss_get_ie(req->bss, WLAN_EID_SSID);
+	if (ssid) {
+		moal_memcpy_ext(priv->phandle, scan_req->ssid_list[0].ssid,
+				ssid + 2, ssid[1],
+				sizeof(scan_req->ssid_list[0].ssid));
+		scan_req->ssid_list[0].max_len = 0;
+	}
+	rcu_read_unlock();
+	moal_memcpy_ext(priv->phandle, scan_req->specific_bssid,
+			req->bss->bssid, ETH_ALEN, ETH_ALEN);
+	if (req->bss->channel) {
+		scan_req->chan_list[0].chan_number =
+			req->bss->channel->hw_value;
+		scan_req->chan_list[0].radio_type =
+			woal_ieee_band_to_radio_type(req->bss->channel->band);
+		if (req->bss->channel->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+			scan_req->chan_list[0].scan_type =
+				MLAN_SCAN_TYPE_PASSIVE;
+		else if (req->bss->channel->flags & IEEE80211_CHAN_RADAR)
+			scan_req->chan_list[0].scan_type =
+				MLAN_SCAN_TYPE_PASSIVE_TO_ACTIVE;
+		else
+			scan_req->chan_list[0].scan_type =
+				MLAN_SCAN_TYPE_ACTIVE;
+		scan_req->chan_list[0].scan_time = 0;
+	} else {
+		for (band = 0; (band < IEEE80211_NUM_BANDS); band++) {
+			if (!priv->wdev->wiphy->bands[band])
+				continue;
+			sband = priv->wdev->wiphy->bands[band];
+			for (i = 0; (i < sband->n_channels); i++) {
+				ch = &sband->channels[i];
+				if (ch->flags & IEEE80211_CHAN_DISABLED)
+					continue;
+				scan_req->chan_list[chan_idx].radio_type =
+					woal_ieee_band_to_radio_type(band);
+				if (ch->flags & IEEE80211_CHAN_PASSIVE_SCAN)
+					scan_req->chan_list[chan_idx].scan_type =
+						MLAN_SCAN_TYPE_PASSIVE;
+				else if (ch->flags & IEEE80211_CHAN_RADAR)
+					scan_req->chan_list[chan_idx].scan_type =
+						MLAN_SCAN_TYPE_PASSIVE_TO_ACTIVE;
+				else
+					scan_req->chan_list[chan_idx].scan_type =
+						MLAN_SCAN_TYPE_ACTIVE;
+				scan_req->chan_list[chan_idx].chan_number =
+					(u32)ch->hw_value;
+				chan_idx++;
+			}
+		}
+	}
+	moal_memcpy_ext(priv->phandle, scan_req->random_mac, priv->random_mac,
+			ETH_ALEN, sizeof(scan_req->random_mac));
+	ret = woal_request_userscan(priv, wait_option, scan_req);
+	kfree(scan_req);
+#ifdef REASSOCIATION
+	MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
+#endif
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief This function is authentication handler when host MLME
  *          enable.
@@ -1807,20 +2167,33 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 	pmlan_buffer pmbuf = NULL;
 	t_u32 pkt_type, tx_control;
 	t_u16 packet_len = 0, auth_alg;
+	t_u16 pkt_len;
 	t_u8 addr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 	int ret = 0;
 
 	t_u8 trans = 1, status_code = 0;
 	t_u8 *varptr = NULL;
-	mlan_ssid_bssid *ssid_bssid;
 	moal_handle *handle = priv->phandle;
+	mlan_ssid_bssid *ssid_bssid;
 	int i;
 
 	ENTER();
 
+#ifdef REASSOCIATION
+	// disable reassoc_on
+	handle->reassoc_on &= ~MBIT(priv->bss_index);
+	priv->reassoc_on = MFALSE;
+	priv->reassoc_required = MFALSE;
+	if (!handle->reassoc_on && handle->is_reassoc_timer_set == MTRUE) {
+		woal_cancel_timer(&handle->reassoc_timer);
+		handle->is_reassoc_timer_set = MFALSE;
+	}
+#endif
+
 	priv->cfg_disconnect = MFALSE;
 #ifdef UAP_CFG80211
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
+		PRINTM(MERROR, "ERR: Role is AP\n");
 		LEAVE();
 		return -EFAULT;
 	}
@@ -1837,6 +2210,9 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		return -EINVAL;
 	}
 
+	/** cancel pending scan */
+	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
+
 	ssid_bssid = kzalloc(sizeof(mlan_ssid_bssid), GFP_ATOMIC);
 	if (!ssid_bssid) {
 		PRINTM(MERROR, "Fail to allocate ssid_bssid buffer\n");
@@ -1860,10 +2236,14 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		}
 	}
 	if (MLAN_STATUS_SUCCESS != woal_find_bssid(priv, req->bss->bssid)) {
-		PRINTM(MMSG, "bssid not find in scan list\n");
-		kfree(ssid_bssid);
-		LEAVE();
-		return -EFAULT;
+		woal_cfg80211_auth_scan(priv, req, MOAL_IOCTL_WAIT);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_find_bssid(priv, req->bss->bssid)) {
+			PRINTM(MMSG, "bssid not find in scan list\n");
+			kfree(ssid_bssid);
+			LEAVE();
+			return -EFAULT;
+		}
 	}
 	kfree(ssid_bssid);
 
@@ -1873,10 +2253,6 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		LEAVE();
 		return -EBUSY;
 	}
-
-	/** cancel pending scan */
-	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
-
 #ifdef WIFI_DIRECT_SUPPORT
 	if (priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT &&
 	    (priv->wdev->iftype == NL80211_IFTYPE_STATION ||
@@ -1938,6 +2314,7 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 				  KEY_INDEX_CLEAR_ALL, NULL, 1,
 				  MOAL_IOCTL_WAIT)) {
 		/* Disable keys and clear all previous security settings */
+		PRINTM(MERROR, "Fail to clear previous keys\n");
 		ret = -EFAULT;
 		goto done;
 	}
@@ -1967,6 +2344,7 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		goto done;
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_set_auth_mode(priv, MOAL_IOCTL_WAIT, auth_alg)) {
+		PRINTM(MERROR, "Fail to set auth mode\n");
 		ret = -EFAULT;
 		goto done;
 	}
@@ -1979,6 +2357,8 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_cfg80211_set_wep_keys(priv, req->key, req->key_len,
 					       req->key_idx, MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "Fail to set wep key idx %d\n",
+			       req->key_idx);
 			ret = -EFAULT;
 			goto done;
 		}
@@ -1986,12 +2366,13 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_cfg80211_set_wep_keys(priv, NULL, 0, req->key_idx,
 					       MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "Fail to enable wep key idx %d\n",
+			       req->key_idx);
 			ret = -EFAULT;
 			goto done;
 		}
 	}
 
-#define AUTH_TX_DEFAULT_WAIT_TIME 1200
 	if (priv->auth_flag == 0) {
 		if (woal_cfg80211_remain_on_channel_cfg(
 			    priv, MOAL_IOCTL_WAIT, MFALSE, (t_u8 *)&status,
@@ -2028,7 +2409,7 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 	memset(mgmt, 0, MGMT_HEADER_LEN);
 	/**Authentication Frame: Frame Control*/
 	mgmt->frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
+		woal_cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
 	/**Authentication Frame: Destination Address*/
 	moal_memcpy_ext(priv->phandle, mgmt->da, req->bss->bssid, ETH_ALEN,
 			sizeof(mgmt->da));
@@ -2073,15 +2454,16 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 	}
 #endif
 	/*Add packet len*/
+	pkt_len = woal_cpu_to_le16(packet_len);
 	moal_memcpy_ext(priv->phandle,
 			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE,
-			&packet_len, sizeof(packet_len), sizeof(packet_len));
+			&pkt_len, sizeof(pkt_len), sizeof(pkt_len));
 
 	/**Authentication Frame: Authentication Alg*/
-	mgmt->u.auth.auth_alg = cpu_to_le16(auth_alg);
-	mgmt->u.auth.auth_transaction = trans;
+	mgmt->u.auth.auth_alg = woal_cpu_to_le16(auth_alg);
+	mgmt->u.auth.auth_transaction = woal_cpu_to_le16(trans);
 	/**Authentication Frame: Status code*/
-	mgmt->u.auth.status_code = status_code;
+	mgmt->u.auth.status_code = woal_cpu_to_le16(status_code);
 
 	if (req->ie && req->ie_len) {
 		if (!varptr) {
@@ -2098,20 +2480,28 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 
 	priv->host_mlme = MTRUE;
 	priv->auth_flag = HOST_MLME_AUTH_PENDING;
-	priv->auth_alg = cpu_to_le16(auth_alg);
+	priv->auth_alg = woal_cpu_to_le16(auth_alg);
 
-	PRINTM(MCMND, "wlan: HostMlme %s send auth to bssid " MACSTR "\n",
+	PRINTM(MMSG, "wlan: HostMlme %s send auth to bssid " MACSTR "\n",
 	       dev->name, MAC2STR(req->bss->bssid));
 	DBG_HEXDUMP(MDAT_D, "Auth:", pmbuf->pbuf + pmbuf->data_offset,
 		    pmbuf->data_len);
-	if (priv->bss_type == MLAN_BSS_TYPE_STA)
-		woal_save_auth_params(priv, req);
+	woal_save_auth_params(priv, req);
 	status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
 
 	switch (status) {
 	case MLAN_STATUS_PENDING:
 		atomic_inc(&priv->phandle->tx_pending);
 		queue_work(priv->phandle->workqueue, &priv->phandle->main_work);
+#define MAX_AUTH_COUNTER 5
+		priv->auth_tx_cnt++;
+		if (priv->auth_tx_cnt >= MAX_AUTH_COUNTER) {
+			if (woal_reset_wifi(priv->phandle, priv->auth_tx_cnt,
+					    "auth timeout") ==
+			    MLAN_STATUS_SUCCESS) {
+				priv->auth_tx_cnt = 0;
+			}
+		}
 		break;
 	case MLAN_STATUS_SUCCESS:
 		woal_free_mlan_buffer(priv->phandle, pmbuf);
@@ -2123,15 +2513,19 @@ static int woal_cfg80211_authenticate(struct wiphy *wiphy,
 		priv->auth_flag = 0;
 		priv->auth_alg = 0xFFFF;
 		ret = -EFAULT;
+		PRINTM(MERROR, "Fail to send packet status=%d\n", status);
 		break;
 	}
 done:
 	if (ret) {
 		woal_mgmt_frame_register(priv, IEEE80211_STYPE_AUTH, MFALSE);
 		if (priv->phandle->remain_on_channel) {
-			woal_cfg80211_remain_on_channel_cfg(
-				priv, MOAL_IOCTL_WAIT, MTRUE, (t_u8 *)&status,
-				NULL, 0, 0);
+			if (woal_cfg80211_remain_on_channel_cfg(
+				    priv, MOAL_IOCTL_WAIT, MTRUE,
+				    (t_u8 *)&status, NULL, 0, 0)) {
+				PRINTM(MERROR,
+				       "Fail to cancel remain on channel\n");
+			}
 			priv->phandle->remain_on_channel = MFALSE;
 		}
 	}
@@ -2160,9 +2554,12 @@ void woal_host_mlme_work_queue(struct work_struct *work)
 						 MFALSE);
 
 			if (priv->phandle->remain_on_channel) {
-				woal_cfg80211_remain_on_channel_cfg(
-					priv, MOAL_IOCTL_WAIT, MTRUE,
-					(t_u8 *)&status, NULL, 0, 0);
+				if (woal_cfg80211_remain_on_channel_cfg(
+					    priv, MOAL_IOCTL_WAIT, MTRUE,
+					    (t_u8 *)&status, NULL, 0, 0)) {
+					PRINTM(MERROR,
+					       "failed to cancel remain on channel\n");
+				}
 				priv->phandle->remain_on_channel = MFALSE;
 			}
 			PRINTM(MCMND, "wlan: HostMlme %s auth success\n",
@@ -2176,104 +2573,122 @@ void woal_host_mlme_work_queue(struct work_struct *work)
  * case
  *
  *  @param priv  	pointer to moal_private
- *  @param assoc_rsp	pointer to mlan_ds_misc_assoc_rsp
+ *  @param assoc_info	pointer to mlan_ds_assoc_info
  *
  *  @return        N/A
  */
 void woal_host_mlme_process_assoc_resp(moal_private *priv,
-				       mlan_ds_misc_assoc_rsp *assoc_rsp)
+				       mlan_ds_assoc_info *assoc_info)
 {
 	struct cfg80211_bss *bss = NULL;
 	unsigned long flags;
+	u8 *assoc_req_buf = NULL;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	struct cfg80211_rx_assoc_resp resp = {
+		.uapsd_queues = -1,
+	};
+#endif
 
 	if (priv) {
 		if (priv->auth_flag & HOST_MLME_ASSOC_DONE) {
 			priv->auth_flag = 0;
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-			bss = cfg80211_get_bss(
-				priv->wdev->wiphy, NULL, priv->conn_bssid,
-				priv->conn_ssid, priv->conn_ssid_len,
-				IEEE80211_BSS_TYPE_ESS, IEEE80211_PRIVACY_ANY);
-#else
-			bss = cfg80211_get_bss(
-				priv->wdev->wiphy, NULL, priv->conn_bssid,
-				priv->conn_ssid, priv->conn_ssid_len,
-				WLAN_CAPABILITY_ESS, WLAN_CAPABILITY_ESS);
-#endif
+			bss = priv->assoc_bss;
 			if (!bss) {
-				PRINTM(MERROR, "HostMlme %s:Fail to get bss\n",
+				PRINTM(MERROR,
+				       "HostMlme %s:assoc_bss is null\n",
 				       priv->netdev->name);
 				return;
 			}
 
-			if (assoc_rsp->assoc_resp_len) {
+			if (assoc_info->assoc_resp_len) {
 				PRINTM(MCMND,
 				       "HostMlme: %s assoc_resp_len=%d, frame_control=0x%x\n",
 				       priv->netdev->name,
-				       assoc_rsp->assoc_resp_len,
+				       assoc_info->assoc_resp_len,
 				       ((struct ieee80211_mgmt *)
-						assoc_rsp->assoc_resp_buf)
+						assoc_info->assoc_resp_buf)
 					       ->frame_control);
 				if (ieee80211_is_assoc_resp(
 					    ((struct ieee80211_mgmt *)
-						     assoc_rsp->assoc_resp_buf)
+						     assoc_info->assoc_resp_buf)
 						    ->frame_control) ||
 				    ieee80211_is_reassoc_resp(
 					    ((struct ieee80211_mgmt *)
-						     assoc_rsp->assoc_resp_buf)
+						     assoc_info->assoc_resp_buf)
 						    ->frame_control)) {
 					spin_lock_irqsave(&priv->connect_lock,
 							  flags);
 					if (le16_to_cpu(
 						    ((struct ieee80211_mgmt
-							      *)assoc_rsp
+							      *)assoc_info
 							     ->assoc_resp_buf)
 							    ->u.assoc_resp
 							    .status_code) !=
 					    WLAN_STATUS_SUCCESS) {
 						memset(priv->cfg_bssid, 0,
 						       ETH_ALEN);
-						if (priv->bss_type ==
-						    MLAN_BSS_TYPE_STA)
-							woal_clear_conn_params(
-								priv);
+						woal_clear_conn_params(priv);
+					} else {
+						priv->cfg_disconnect = MFALSE;
 					}
 					spin_unlock_irqrestore(
 						&priv->connect_lock, flags);
-
+					/*Populate Assoc req buf only if len is
+					 * non zero . i.e. we received assoc req
+					 * buffer from fw.*/
+					if (assoc_info->assoc_req_len)
+						assoc_req_buf =
+							assoc_info
+								->assoc_req_buf;
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+					resp.links[0].bss = bss;
+					resp.buf = assoc_info->assoc_resp_buf;
+					resp.len = assoc_info->assoc_resp_len;
+					resp.req_ies = assoc_req_buf;
+					resp.req_ies_len =
+						assoc_info->assoc_req_len;
+					mutex_lock(&priv->wdev->mtx);
+					cfg80211_rx_assoc_resp(priv->netdev,
+							       &resp);
+					mutex_unlock(&priv->wdev->mtx);
+#else
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 1, 0)
+					mutex_lock(&priv->wdev->mtx);
 					cfg80211_rx_assoc_resp(
 						priv->netdev, bss,
-						assoc_rsp->assoc_resp_buf,
-						assoc_rsp->assoc_resp_len, -1,
-						NULL, 0);
+						assoc_info->assoc_resp_buf,
+						assoc_info->assoc_resp_len, -1,
+						assoc_req_buf,
+						assoc_info->assoc_req_len);
+					mutex_unlock(&priv->wdev->mtx);
 #else
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+					mutex_lock(&priv->wdev->mtx);
 					cfg80211_rx_assoc_resp(
 						priv->netdev, bss,
-						assoc_rsp->assoc_resp_buf,
-						assoc_rsp->assoc_resp_len, -1);
+						assoc_info->assoc_resp_buf,
+						assoc_info->assoc_resp_len, -1);
+					mutex_unlock(&priv->wdev->mtx);
 #else
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+					mutex_lock(&priv->wdev->mtx);
 					cfg80211_rx_assoc_resp(
 						priv->netdev, bss,
-						assoc_rsp->assoc_resp_buf,
-						assoc_rsp->assoc_resp_len);
+						assoc_info->assoc_resp_buf,
+						assoc_info->assoc_resp_len);
+					mutex_unlock(&priv->wdev->mtx);
 #else
 					cfg80211_send_rx_assoc(
 						priv->netdev, bss,
-						assoc_rsp->assoc_resp_buf,
-						assoc_rsp->assoc_resp_len);
+						assoc_info->assoc_resp_buf,
+						assoc_info->assoc_resp_len);
+#endif
 #endif
 #endif
 #endif
 				}
 			}
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
-			cfg80211_put_bss(priv->wdev->wiphy, bss);
-#else
-			cfg80211_put_bss(bss);
-#endif
 		}
 	}
 }
@@ -2287,20 +2702,31 @@ void woal_host_mlme_process_assoc_resp(moal_private *priv,
  * @return          N/A
  */
 
-void woal_assoc_resp_event(moal_private *priv,
-			   mlan_ds_misc_assoc_rsp *passoc_rsp)
+static void woal_assoc_resp_event(moal_private *priv,
+				  mlan_ds_misc_assoc_rsp *passoc_rsp)
 {
 	struct woal_event *evt;
 	unsigned long flags;
 	moal_handle *handle = priv->phandle;
+	mlan_ds_misc_assoc_req assoc_req;
+	memset(&assoc_req, 0, sizeof(mlan_ds_misc_assoc_req));
+	woal_get_assoc_req(priv, &assoc_req, MOAL_IOCTL_WAIT);
 
 	evt = kzalloc(sizeof(struct woal_event), GFP_ATOMIC);
 	if (evt) {
 		evt->priv = priv;
 		evt->type = WOAL_EVENT_ASSOC_RESP;
-		moal_memcpy_ext(priv->phandle, &evt->assoc_resp, passoc_rsp,
-				sizeof(mlan_ds_misc_assoc_rsp),
-				sizeof(mlan_ds_misc_assoc_rsp));
+		moal_memcpy_ext(priv->phandle, evt->assoc_info.assoc_resp_buf,
+				passoc_rsp->assoc_resp_buf,
+				passoc_rsp->assoc_resp_len, ASSOC_RSP_BUF_SIZE);
+		evt->assoc_info.assoc_resp_len =
+			MIN(passoc_rsp->assoc_resp_len, ASSOC_RSP_BUF_SIZE);
+		moal_memcpy_ext(priv->phandle, evt->assoc_info.assoc_req_buf,
+				assoc_req.assoc_req_buf,
+				assoc_req.assoc_req_len, ASSOC_RSP_BUF_SIZE);
+		evt->assoc_info.assoc_req_len =
+			MIN(assoc_req.assoc_req_len, ASSOC_RSP_BUF_SIZE);
+
 		INIT_LIST_HEAD(&evt->link);
 		spin_lock_irqsave(&handle->evt_lock, flags);
 		list_add_tail(&evt->link, &handle->evt_queue);
@@ -2327,7 +2753,7 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 {
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	int ret = 0;
-	mlan_ssid_bssid ssid_bssid;
+	mlan_ssid_bssid *ssid_bssid = NULL;
 	unsigned long flags;
 	const u8 *ssid_ie;
 	int wpa_enabled = 0, group_enc_mode = 0, pairwise_enc_mode = 0;
@@ -2336,6 +2762,12 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 
 	ENTER();
 
+	ssid_bssid = kmalloc(sizeof(mlan_ssid_bssid), GFP_KERNEL);
+	if (!ssid_bssid) {
+		LEAVE();
+		return -EFAULT;
+	}
+
 	if (priv->auth_alg == WLAN_AUTH_SAE) {
 		priv->auth_flag = HOST_MLME_AUTH_DONE;
 
@@ -2357,35 +2789,42 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 	}
 
 	if (priv->auth_flag && !(priv->auth_flag & HOST_MLME_AUTH_DONE)) {
+		kfree(ssid_bssid);
 		LEAVE();
 		return -EBUSY;
 	}
 
+	/** cancel pending scan */
+	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
+
 	priv->cfg_connect = MTRUE;
 	priv->assoc_status = 0;
 	priv->auth_alg = 0xFFFF;
 
-	memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+	memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+	rcu_read_lock();
 	ssid_ie = ieee80211_bss_get_ie(req->bss, WLAN_EID_SSID);
-	moal_memcpy_ext(priv->phandle, ssid_bssid.bssid, req->bss->bssid,
-			ETH_ALEN, sizeof(ssid_bssid.bssid));
+	moal_memcpy_ext(priv->phandle, ssid_bssid->bssid, req->bss->bssid,
+			ETH_ALEN, sizeof(ssid_bssid->bssid));
 
 	if (!ssid_ie) {
+		rcu_read_unlock();
 		ret = -EINVAL;
 		goto done;
 	}
 
-	moal_memcpy_ext(priv->phandle, ssid_bssid.ssid.ssid, ssid_ie + 2,
-			ssid_ie[1], sizeof(ssid_bssid.ssid.ssid));
-	ssid_bssid.ssid.ssid_len = ssid_ie[1];
+	moal_memcpy_ext(priv->phandle, ssid_bssid->ssid.ssid, ssid_ie + 2,
+			ssid_ie[1], sizeof(ssid_bssid->ssid.ssid));
+	ssid_bssid->ssid.ssid_len = ssid_ie[1];
+	rcu_read_unlock();
 
-	if (ssid_bssid.ssid.ssid_len > MW_ESSID_MAX_SIZE) {
+	if (ssid_bssid->ssid.ssid_len > MW_ESSID_MAX_SIZE) {
 		PRINTM(MERROR, "Invalid SSID - aborting\n");
 		ret = -EINVAL;
 		goto done;
 	}
 
-	if (!ssid_bssid.ssid.ssid_len || ssid_bssid.ssid.ssid[0] < 0x20) {
+	if (!ssid_bssid->ssid.ssid_len || ssid_bssid->ssid.ssid[0] < 0x20) {
 		PRINTM(MERROR, "Invalid SSID - aborting\n");
 		ret = -EINVAL;
 		goto done;
@@ -2446,18 +2885,23 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 		if (ret)
 			goto done;
 	}
-	ssid_bssid.host_mlme = priv->host_mlme;
+	ssid_bssid->host_mlme = priv->host_mlme;
 
 	if (req->bss->channel) {
-		ssid_bssid.channel_flags = req->bss->channel->flags;
-		ssid_bssid.channel_flags |= CHAN_FLAGS_MAX;
+		ssid_bssid->channel_flags = req->bss->channel->flags;
+		ssid_bssid->channel_flags |= CHAN_FLAGS_MAX;
 		PRINTM(MCMND, "channel flags=0x%x\n", req->bss->channel->flags);
 	}
+	if (req->prev_bssid) {
+		moal_memcpy_ext(priv->phandle, ssid_bssid->prev_bssid,
+				req->prev_bssid, ETH_ALEN,
+				sizeof(ssid_bssid->prev_bssid));
+	}
 
 	PRINTM(MCMND, "wlan: HostMlme %s send assoicate to bssid " MACSTR "\n",
 	       priv->netdev->name, MAC2STR(req->bss->bssid));
 	if (MLAN_STATUS_SUCCESS !=
-	    woal_bss_start(priv, MOAL_IOCTL_WAIT_TIMEOUT, &ssid_bssid)) {
+	    woal_bss_start(priv, MOAL_IOCTL_WAIT_TIMEOUT, ssid_bssid)) {
 		PRINTM(MERROR, "HostMlme %s: bss_start Fails\n",
 		       priv->netdev->name);
 		priv->host_mlme = MFALSE;
@@ -2469,14 +2913,15 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 
 	if (!ret) {
 		priv->rssi_low = DEFAULT_RSSI_LOW_THRESHOLD;
-		if (priv->bss_type == MLAN_BSS_TYPE_STA
-#ifdef WIFI_DIRECT_SUPPORT
-		    || priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT
-#endif
-		)
-			woal_save_assoc_params(priv, req, &ssid_bssid);
+
+		woal_save_assoc_params(priv, req, ssid_bssid);
+
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+			PRINTM(MERROR,
+			       "woal_get_bss_info Fails to get bss info\n");
+		}
 		priv->channel = bss_info.bss_chan;
 	}
 
@@ -2493,19 +2938,18 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 		       "wlan: HostMlme %s Failed to connect to bssid " MACSTR
 		       "\n",
 		       priv->netdev->name, MAC2STR(req->bss->bssid));
-		if (ssid_bssid.assoc_rsp.assoc_resp_len &&
-		    ssid_bssid.assoc_rsp.assoc_resp_len >
+		if (ssid_bssid->assoc_rsp.assoc_resp_len &&
+		    ssid_bssid->assoc_rsp.assoc_resp_len >
 			    sizeof(IEEEtypes_MgmtHdr_t)) {
 			// save the connection param when send assoc_resp to
 			// kernel
-			woal_save_assoc_params(priv, req, &ssid_bssid);
+			woal_save_assoc_params(priv, req, ssid_bssid);
 			ret = 0;
 		} else {
-			ssid_bssid.assoc_rsp.assoc_resp_len = 0;
+			ssid_bssid->assoc_rsp.assoc_resp_len = 0;
 			ret = -EFAULT;
 			memset(priv->cfg_bssid, 0, ETH_ALEN);
-			if (priv->bss_type == MLAN_BSS_TYPE_STA)
-				woal_clear_conn_params(priv);
+			woal_clear_conn_params(priv);
 		}
 		priv->host_mlme = MFALSE;
 		priv->auth_flag = 0;
@@ -2514,11 +2958,11 @@ static int woal_cfg80211_associate(struct wiphy *wiphy, struct net_device *dev,
 	/*Association Response should also be send when ret is non-zero.
 	  We also need to return success when we have association response
 	  available*/
-	if (ssid_bssid.assoc_rsp.assoc_resp_len) {
+	if (ssid_bssid->assoc_rsp.assoc_resp_len) {
 		priv->auth_flag |= HOST_MLME_ASSOC_DONE;
-		woal_assoc_resp_event(priv, &ssid_bssid.assoc_rsp);
+		woal_assoc_resp_event(priv, &ssid_bssid->assoc_rsp);
 	}
-
+	kfree(ssid_bssid);
 	LEAVE();
 	return ret;
 }
@@ -2540,7 +2984,7 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 	struct cfg80211_ibss_params *ibss_param = NULL;
 	struct cfg80211_connect_params *conn_param = NULL;
 	mlan_802_11_ssid req_ssid;
-	mlan_ssid_bssid ssid_bssid;
+	mlan_ssid_bssid *ssid_bssid = NULL;
 	mlan_ioctl_req *req = NULL;
 	int ret = 0;
 	t_u32 auth_type = 0, mode;
@@ -2551,13 +2995,10 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 	t_u8 *ssid, ssid_len = 0, *bssid;
 	t_u8 *ie = NULL;
 	int ie_len = 0;
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
-	struct cfg80211_chan_def *chan_def = NULL;
-#endif
 	struct ieee80211_channel *channel = NULL;
 	t_u16 beacon_interval = 0;
 	bool privacy;
-	struct cfg80211_bss *bss = NULL;
+	struct cfg80211_bss *pub = NULL;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
@@ -2566,6 +3007,11 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 		LEAVE();
 		return -EFAULT;
 	}
+	ssid_bssid = kmalloc(sizeof(mlan_ssid_bssid), GFP_KERNEL);
+	if (!ssid_bssid) {
+		LEAVE();
+		return -EFAULT;
+	}
 
 	mode = woal_nl80211_iftype_to_mode(priv->wdev->iftype);
 
@@ -2577,7 +3023,6 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
 		channel = ibss_param->channel;
 #else
-		chan_def = &ibss_param->chandef;
 		channel = ibss_param->chandef.chan;
 #endif
 		if (channel)
@@ -2601,15 +3046,15 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 		ie_len = conn_param->ie_len;
 		privacy = conn_param->privacy;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
-		bss = cfg80211_get_bss(priv->wdev->wiphy, channel, bssid, ssid,
+		pub = cfg80211_get_bss(priv->wdev->wiphy, channel, bssid, ssid,
 				       ssid_len, IEEE80211_BSS_TYPE_ESS,
 				       IEEE80211_PRIVACY_ANY);
 #else
-		bss = cfg80211_get_bss(priv->wdev->wiphy, channel, bssid, ssid,
+		pub = cfg80211_get_bss(priv->wdev->wiphy, channel, bssid, ssid,
 				       ssid_len, WLAN_CAPABILITY_ESS,
 				       WLAN_CAPABILITY_ESS);
 #endif
-		if (bss) {
+		if (pub) {
 			if ((!priv->phandle->params.reg_alpha2 ||
 			     strncmp(priv->phandle->params.reg_alpha2, "99",
 				     strlen("99")))
@@ -2618,11 +3063,11 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 						   EXT_COUNTRY_IE_IGNORE))
 #endif
 			)
-				woal_process_country_ie(priv, bss);
+				woal_process_country_ie(priv, pub);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
-			cfg80211_put_bss(priv->wdev->wiphy, bss);
+			cfg80211_put_bss(priv->wdev->wiphy, pub);
 #else
-			cfg80211_put_bss(bss);
+			cfg80211_put_bss(pub);
 #endif
 		} else
 			woal_send_domain_info_cmd_fw(priv, wait_option);
@@ -2658,7 +3103,7 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 	}
 
 	memset(&req_ssid, 0, sizeof(mlan_802_11_ssid));
-	memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+	memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
 
 	req_ssid.ssid_len = ssid_len;
 	if (ssid_len > MW_ESSID_MAX_SIZE) {
@@ -2677,7 +3122,7 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 
 	if (priv->phandle->card_info->embedded_supp)
 		if (MLAN_STATUS_SUCCESS !=
-		    woal_set_ewpa_mode(priv, wait_option, &ssid_bssid)) {
+		    woal_set_ewpa_mode(priv, wait_option, ssid_bssid)) {
 			ret = -EFAULT;
 			goto done;
 		}
@@ -2836,13 +3281,13 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 				goto done;
 		}
 	}
-	moal_memcpy_ext(priv->phandle, &ssid_bssid.ssid, &req_ssid,
-			sizeof(mlan_802_11_ssid), sizeof(ssid_bssid.ssid));
+	moal_memcpy_ext(priv->phandle, &ssid_bssid->ssid, &req_ssid,
+			sizeof(mlan_802_11_ssid), sizeof(ssid_bssid->ssid));
 	if (bssid)
-		moal_memcpy_ext(priv->phandle, &ssid_bssid.bssid, bssid,
-				ETH_ALEN, sizeof(ssid_bssid.bssid));
+		moal_memcpy_ext(priv->phandle, &ssid_bssid->bssid, bssid,
+				ETH_ALEN, sizeof(ssid_bssid->bssid));
 	if (MLAN_STATUS_SUCCESS !=
-	    woal_find_essid(priv, &ssid_bssid, wait_option)) {
+	    woal_find_essid(priv, ssid_bssid, wait_option)) {
 		/* Do specific SSID scanning */
 		if (mode != MLAN_BSS_MODE_IBSS)
 			ret = woal_cfg80211_connect_scan(priv, conn_param,
@@ -2862,38 +3307,46 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 
 	if (mode != MLAN_BSS_MODE_IBSS) {
 		if (MLAN_STATUS_SUCCESS !=
-		    woal_find_best_network(priv, wait_option, &ssid_bssid)) {
+		    woal_find_best_network(priv, wait_option, ssid_bssid)) {
 			ret = -EFAULT;
 			goto done;
 		}
 		/* Inform the BSS information to kernel, otherwise
 		 * kernel will give a panic after successful assoc */
 		if (MLAN_STATUS_SUCCESS !=
-		    woal_inform_bss_from_scan_result(priv, &ssid_bssid,
+		    woal_inform_bss_from_scan_result(priv, ssid_bssid,
 						     wait_option)) {
 			ret = -EFAULT;
 			goto done;
 		}
 	} else if (MLAN_STATUS_SUCCESS !=
-		   woal_find_best_network(priv, wait_option, &ssid_bssid))
+		   woal_find_best_network(priv, wait_option, ssid_bssid))
 		/* Adhoc start, Check the channel command */
 		woal_11h_channel_check_ioctl(priv, wait_option);
 
 	PRINTM(MINFO, "Trying to associate to %s and bssid " MACSTR "\n",
-	       (char *)req_ssid.ssid, MAC2STR(ssid_bssid.bssid));
+	       (char *)req_ssid.ssid, MAC2STR(ssid_bssid->bssid));
 
 	/* Zero SSID implies use BSSID to connect */
 	if (bssid)
-		memset(&ssid_bssid.ssid, 0, sizeof(mlan_802_11_ssid));
+		memset(&ssid_bssid->ssid, 0, sizeof(mlan_802_11_ssid));
 	else /* Connect to BSS by ESSID */
-		memset(&ssid_bssid.bssid, 0, MLAN_MAC_ADDR_LENGTH);
+		memset(&ssid_bssid->bssid, 0, MLAN_MAC_ADDR_LENGTH);
 	if (channel) {
-		ssid_bssid.channel_flags = channel->flags;
-		ssid_bssid.channel_flags |= CHAN_FLAGS_MAX;
+		ssid_bssid->channel_flags = channel->flags;
+		ssid_bssid->channel_flags |= CHAN_FLAGS_MAX;
 		PRINTM(MCMND, "channel flags=0x%x\n", channel->flags);
 	}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (conn_param && conn_param->prev_bssid) {
+		moal_memcpy_ext(priv->phandle, ssid_bssid->prev_bssid,
+				conn_param->prev_bssid, ETH_ALEN,
+				sizeof(ssid_bssid->prev_bssid));
+	}
+#endif
+
 	if (MLAN_STATUS_SUCCESS !=
-	    woal_bss_start(priv, MOAL_IOCTL_WAIT_TIMEOUT, &ssid_bssid)) {
+	    woal_bss_start(priv, MOAL_IOCTL_WAIT_TIMEOUT, ssid_bssid)) {
 		ret = -EFAULT;
 		goto done;
 	}
@@ -2908,13 +3361,15 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
 			goto done;
 		}
 	} else if (assoc_rsp) {
-		moal_memcpy_ext(priv->phandle, assoc_rsp, &ssid_bssid.assoc_rsp,
+		moal_memcpy_ext(priv->phandle, assoc_rsp,
+				&ssid_bssid->assoc_rsp,
 				sizeof(mlan_ds_misc_assoc_rsp),
 				sizeof(mlan_ds_misc_assoc_rsp));
 		PRINTM(MCMND, "assoc_rsp ie len=%d\n",
 		       assoc_rsp->assoc_resp_len);
 	}
 done:
+	kfree(ssid_bssid);
 	if (ret) {
 		/* clear the encryption mode */
 		if (MLAN_STATUS_SUCCESS !=
@@ -2946,8 +3401,8 @@ int woal_cfg80211_assoc(moal_private *priv, void *sme, t_u8 wait_option,
  *
  * @return                0 -- success, otherwise fail
  */
-void woal_cfg80211_fill_rate_info(moal_private *priv,
-				  struct station_info *sinfo)
+static void woal_cfg80211_fill_rate_info(moal_private *priv,
+					 struct station_info *sinfo)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ioctl_req *req = NULL;
@@ -3028,8 +3483,11 @@ void woal_cfg80211_fill_rate_info(moal_private *priv,
 		sinfo->txrate.mcs = rate->param.data_rate.tx_mcs_index;
 	} else {
 		/* Bit rate is in 500 kb/s units. Convert it to 100kb/s units */
-		sinfo->txrate.legacy =
-			Rates[rate->param.data_rate.tx_data_rate] * 5;
+		if (rate->param.data_rate.tx_data_rate < 12) {
+			sinfo->txrate.legacy =
+				Rates[rate->param.data_rate.tx_data_rate] * 5;
+		} else
+			sinfo->txrate.legacy = Rates[0] * 5;
 	}
 	// Fill Rx rate
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
@@ -3072,8 +3530,11 @@ void woal_cfg80211_fill_rate_info(moal_private *priv,
 		sinfo->rxrate.mcs = rate->param.data_rate.rx_mcs_index;
 	} else {
 		/* Bit rate is in 500 kb/s units. Convert it to 100kb/s units */
-		sinfo->rxrate.legacy =
-			Rates[rate->param.data_rate.rx_data_rate] * 5;
+		if (rate->param.data_rate.rx_data_rate < 12) {
+			sinfo->rxrate.legacy =
+				Rates[rate->param.data_rate.rx_data_rate] * 5;
+		} else
+			sinfo->rxrate.legacy = 0;
 	}
 #endif
 done:
@@ -3102,6 +3563,15 @@ static mlan_status woal_cfg80211_dump_station_info(moal_private *priv,
 #endif
 
 	ENTER();
+
+	if (priv->phandle->scan_pending_on_block) {
+		if (priv->sinfo)
+			moal_memcpy_ext(priv->phandle, sinfo, priv->sinfo,
+					sizeof(struct station_info),
+					sizeof(struct station_info));
+		LEAVE();
+		return ret;
+	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
 	sinfo->filled = MBIT(NL80211_STA_INFO_RX_BYTES) |
 			MBIT(NL80211_STA_INFO_TX_BYTES) |
@@ -3177,6 +3647,11 @@ static mlan_status woal_cfg80211_dump_station_info(moal_private *priv,
 	sinfo->bss_param.dtim_period = dtim_period;
 #endif
 	woal_cfg80211_fill_rate_info(priv, sinfo);
+	if (priv->sinfo)
+		moal_memcpy_ext(priv->phandle, priv->sinfo, sinfo,
+				sizeof(struct station_info),
+				sizeof(struct station_info));
+
 done:
 	LEAVE();
 	return ret;
@@ -3185,40 +3660,6 @@ static mlan_status woal_cfg80211_dump_station_info(moal_private *priv,
 /********************************************************
 				Global Functions
 ********************************************************/
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-/**
- * @brief Set all radar channel's dfs_state
- *
- * @param wiphy           A pointer to wiphy structure
- *
- * @return                N/A
- */
-void woal_update_radar_chans_dfs_state(struct wiphy *wiphy)
-{
-	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
-	enum ieee80211_band band;
-	struct ieee80211_supported_band *sband;
-	int i;
-	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
-		sband = wiphy->bands[band];
-		if (!sband)
-			continue;
-		for (i = 0; i < sband->n_channels; i++) {
-			if (sband->channels[i].flags & IEEE80211_CHAN_RADAR) {
-				if (moal_extflg_isset(handle, EXT_DFS_OFFLOAD))
-					sband->channels[i].dfs_state =
-						NL80211_DFS_AVAILABLE;
-				else
-					sband->channels[i].dfs_state =
-						NL80211_DFS_USABLE;
-			}
-		}
-	}
-	PRINTM(MCMND, "Set radar dfs_state: dfs_offload=%d\n",
-	       moal_extflg_isset(handle, EXT_DFS_OFFLOAD));
-}
-#endif
-
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
 
 /**
@@ -3240,8 +3681,9 @@ static int compare(const void *lhs, const void *rhs)
 
 	return 0;
 }
+
 /**
- *  @brief This function update channel region config
+ *  @brief This function get channel reg_rule flags
  *
  *  @param buf              Buffer containing channel region config
  *  @param num_chan         Length of buffer
@@ -3249,8 +3691,82 @@ static int compare(const void *lhs, const void *rhs)
  *
  *  @return                 N/A
  */
+t_u32 woal_get_chan_rule_flags(mlan_ds_custom_reg_domain *custom_reg,
+			       t_u8 channel)
+{
+	t_u16 num_chan = 0;
+	t_u32 flags = 0;
+	int idx;
+	t_u16 chflags;
+
+	num_chan = custom_reg->num_bg_chan;
+	num_chan += custom_reg->num_a_chan;
+	for (idx = 0; idx < num_chan; idx++) {
+		chflags = custom_reg->cfp_tbl[idx].dynamic.flags;
+		if (chflags & NXP_CHANNEL_DISABLED)
+			continue;
+		if (custom_reg->cfp_tbl[idx].channel == channel) {
+			if (chflags & NXP_CHANNEL_PASSIVE)
+				flags |= NL80211_RRF_NO_IR;
+			if (chflags & NXP_CHANNEL_DFS)
+				flags |= NL80211_RRF_DFS;
+			if (chflags & NXP_CHANNEL_NO_OFDM)
+				flags |= NL80211_RRF_NO_OFDM;
+			break;
+		}
+	}
+	return flags;
+}
+
+/**
+ *  @brief This function update the beaconng flags of channel
+ *
+ *  @param custom_reg       pointer to mlan_ds_custom_reg_domain
+ *
+ *  @return                 pointer to ieee80211_regdomain
+ */
+
+static void
+woal_reg_apply_beaconing_flags(struct wiphy *wiphy,
+			       mlan_ds_custom_reg_domain *custom_reg)
+{
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *ch;
+	int band, i;
+	t_u32 rule_flags = 0;
+
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		for (i = 0; i < sband->n_channels; i++) {
+			ch = &sband->channels[i];
+
+			if (ch->flags &
+			    (IEEE80211_CHAN_DISABLED | IEEE80211_CHAN_RADAR))
+				continue;
+
+			rule_flags = woal_get_chan_rule_flags(custom_reg,
+							      ch->hw_value);
+
+			if (!(rule_flags & NL80211_RRF_NO_IR))
+				ch->flags &= ~IEEE80211_CHAN_NO_IR;
+		}
+	}
+}
+
+/**
+ *  @brief This function create the custom regdomain
+ *
+ *  @param priv       pointer to moal_private
+ *  @param custom_reg       pointer to mlan_ds_custom_reg_domain
+ *
+ *  @return                 pointer to ieee80211_regdomain
+ */
 static struct ieee80211_regdomain *
-create_custom_regdomain(mlan_ds_custom_reg_domain *custom_reg)
+create_custom_regdomain(moal_private *priv,
+			mlan_ds_custom_reg_domain *custom_reg)
 {
 	struct ieee80211_reg_rule *rule;
 	bool new_rule;
@@ -3276,65 +3792,6 @@ create_custom_regdomain(mlan_ds_custom_reg_domain *custom_reg)
 	if (!regd) {
 		return NULL;
 	}
-#define NXP_CHANNEL_TMP_NOHT40 MBIT(15)
-	/* preprocess 2.4G 40MHz support */
-	for (idx = 0; idx < num_chan; idx++) {
-		chan = custom_reg->cfp_tbl[idx].channel;
-		if (!chan) {
-			if (regd)
-				kfree(regd);
-			return NULL;
-		}
-
-		if (chan > 14)
-			continue;
-
-		chflags = custom_reg->cfp_tbl[idx].dynamic.flags;
-
-		if (chflags & NXP_CHANNEL_DISABLED)
-			continue;
-
-		/* duplicate a temp flag */
-		if (chflags & NXP_CHANNEL_NOHT40)
-			chflags |= NXP_CHANNEL_TMP_NOHT40;
-	}
-	for (idx = 0; idx < num_chan; idx++) {
-		chan = custom_reg->cfp_tbl[idx].channel;
-		if (!chan) {
-			if (regd)
-				kfree(regd);
-			return NULL;
-		}
-
-		if (chan > 14)
-			continue;
-
-		chflags = custom_reg->cfp_tbl[idx].dynamic.flags;
-
-		if (chflags & NXP_CHANNEL_DISABLED)
-			continue;
-
-		/* 40 MHz band of one center channel will spread to upper and
-		 * lower 2 channels */
-		/* Mark HT40 flag for all channels of this 40 MHz band */
-		if (!(chflags & NXP_CHANNEL_TMP_NOHT40)) {
-			if (idx >= 2)
-				custom_reg->cfp_tbl[idx - 2].dynamic.flags &=
-					~NXP_CHANNEL_NOHT40;
-			if (idx >= 1)
-				custom_reg->cfp_tbl[idx - 1].dynamic.flags &=
-					~NXP_CHANNEL_NOHT40;
-			if (idx < (num_chan - 1))
-				custom_reg->cfp_tbl[idx + 1].dynamic.flags &=
-					~NXP_CHANNEL_NOHT40;
-			if (idx < (num_chan - 2))
-				custom_reg->cfp_tbl[idx + 2].dynamic.flags &=
-					~NXP_CHANNEL_NOHT40;
-		} else {
-			custom_reg->cfp_tbl[idx].dynamic.flags &=
-				~NXP_CHANNEL_TMP_NOHT40;
-		}
-	}
 	for (idx = 0; idx < num_chan; idx++) {
 		enum ieee80211_band band;
 
@@ -3389,10 +3846,8 @@ create_custom_regdomain(mlan_ds_custom_reg_domain *custom_reg)
 		rule->power_rule.max_eirp = DBM_TO_MBM(19);
 		rule->flags = 0;
 
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 		if (chflags & NXP_CHANNEL_PASSIVE)
 			rule->flags |= NL80211_RRF_NO_IR;
-#endif
 		if (chflags & NXP_CHANNEL_DFS)
 			rule->flags |= NL80211_RRF_DFS;
 		if (chflags & NXP_CHANNEL_NO_OFDM)
@@ -3411,9 +3866,25 @@ create_custom_regdomain(mlan_ds_custom_reg_domain *custom_reg)
 		regd->alpha2[0] = custom_reg->region.country_code[0];
 		regd->alpha2[1] = custom_reg->region.country_code[1];
 	}
-	PRINTM(MCMND, "create_custom_regdomain: %c%c rules=%d\n",
-	       regd->alpha2[0], regd->alpha2[1], valid_rules);
-	for (idx = 0; idx < regd->n_reg_rules; idx++) {
+
+	switch (custom_reg->region.dfs_region) {
+	case 1:
+		regd->dfs_region = NL80211_DFS_FCC;
+		break;
+	case 2:
+		regd->dfs_region = NL80211_DFS_ETSI;
+		break;
+	case 3:
+		regd->dfs_region = NL80211_DFS_JP;
+		break;
+	default:
+		regd->dfs_region = NL80211_DFS_UNSET;
+		break;
+	}
+	priv->phandle->dfs_region = regd->dfs_region;
+	PRINTM(MCMND, "create_custom_regdomain: %c%c rules=%d dfs_region=%d\n",
+	       regd->alpha2[0], regd->alpha2[1], valid_rules, regd->dfs_region);
+	for (idx = 0; idx < (int)regd->n_reg_rules; idx++) {
 		rule = &regd->reg_rules[idx];
 		freq_range = &rule->freq_range;
 		PRINTM(MCMND,
@@ -3423,6 +3894,10 @@ create_custom_regdomain(mlan_ds_custom_reg_domain *custom_reg)
 		       freq_range->end_freq_khz - freq_range->start_freq_khz,
 		       freq_range->max_bandwidth_khz);
 	}
+	if (!regd->n_reg_rules) {
+		kfree(regd);
+		regd = NULL;
+	}
 	return regd;
 }
 
@@ -3475,18 +3950,22 @@ static int woal_update_custom_regdomain(moal_private *priv, struct wiphy *wiphy)
 		country_code[0] = priv->phandle->country_code[0];
 		country_code[1] = priv->phandle->country_code[1];
 	}
+	if (misc->param.custom_reg_domain.region.country_code[0] == '\0' ||
+	    misc->param.custom_reg_domain.region.country_code[1] == '\0') {
+		PRINTM(MCMND, "FW country code not valid\n");
+		ret = -EFAULT;
+		goto done;
+	}
 	if (misc->param.custom_reg_domain.region.country_code[0] !=
 		    country_code[0] ||
 	    misc->param.custom_reg_domain.region.country_code[1] !=
 		    country_code[1]) {
-		PRINTM(MERROR, "country code %c%c not match %c%c\n",
+		PRINTM(MCMND, "FW country code %c%c not match %c%c\n",
 		       misc->param.custom_reg_domain.region.country_code[0],
 		       misc->param.custom_reg_domain.region.country_code[1],
 		       country_code[0], country_code[1]);
-		ret = -EFAULT;
-		goto done;
 	}
-	regd = create_custom_regdomain(&misc->param.custom_reg_domain);
+	regd = create_custom_regdomain(priv, &misc->param.custom_reg_domain);
 	if (regd) {
 		PRINTM(MMSG, "call regulatory_set_wiphy_regd %c%c",
 		       misc->param.custom_reg_domain.region.country_code[0],
@@ -3494,8 +3973,17 @@ static int woal_update_custom_regdomain(moal_private *priv, struct wiphy *wiphy)
 		wiphy->regulatory_flags &=
 			~(REGULATORY_STRICT_REG | REGULATORY_CUSTOM_REG);
 		wiphy->regulatory_flags |= REGULATORY_WIPHY_SELF_MANAGED;
-		regulatory_set_wiphy_regd(wiphy, regd);
+		rtnl_lock();
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+		ret = regulatory_set_wiphy_regd_sync(wiphy, regd);
+#else
+		ret = regulatory_set_wiphy_regd_sync_rtnl(wiphy, regd);
+#endif
+		rtnl_unlock();
 		kfree(regd);
+		if (!ret)
+			woal_reg_apply_beaconing_flags(
+				wiphy, &misc->param.custom_reg_domain);
 	}
 done:
 	if (status != MLAN_STATUS_PENDING)
@@ -3503,6 +3991,34 @@ static int woal_update_custom_regdomain(moal_private *priv, struct wiphy *wiphy)
 	LEAVE();
 	return ret;
 }
+
+/**
+ *  @brief This workqueue handles create customer regulatory
+ * case
+ *
+ *  @param work    A pointer to work_struct
+ *
+ *  @return        N/A
+ */
+void woal_regulatory_work_queue(struct work_struct *work)
+{
+	moal_handle *handle = container_of(work, moal_handle, regulatory_work);
+	struct wiphy *wiphy = handle->wiphy;
+	moal_private *priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
+	enum ieee80211_band band;
+
+	if (priv && wiphy) {
+		woal_update_custom_regdomain(priv, wiphy);
+		band = priv->phandle->band;
+		priv->phandle->band = IEEE80211_BAND_2GHZ;
+		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		if (priv->phandle->fw_bands & BAND_A) {
+			priv->phandle->band = IEEE80211_BAND_5GHZ;
+			woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		}
+		priv->phandle->band = band;
+	}
+}
 #endif
 
 /**
@@ -3528,7 +4044,12 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
 	int ret = 0;
 #endif
+	t_u8 load_power_table = MFALSE;
 	mlan_fw_info fw_info;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	char *reg_alpha2 = NULL;
+#endif
+	t_u8 dfs_region = NXP_DFS_UNKNOWN;
 
 	ENTER();
 
@@ -3542,11 +4063,20 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
 		return;
 #endif
 	}
-
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
+	dfs_region = request->dfs_region;
+#endif
 	PRINTM(MCMND,
 	       "cfg80211 regulatory domain callback "
-	       "%c%c initiator=%d\n",
-	       request->alpha2[0], request->alpha2[1], request->initiator);
+	       "%c%c initiator=%d dfs_region=%d\n",
+	       request->alpha2[0], request->alpha2[1], request->initiator,
+	       dfs_region);
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	if (!(wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED))
+#endif
+		handle->dfs_region = dfs_region;
+
 	memset(&fw_info, 0, sizeof(mlan_fw_info));
 	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
 	if (fw_info.force_reg) {
@@ -3560,17 +4090,13 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
 #endif
 	}
 
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	if (moal_extflg_isset(handle, EXT_DFS_OFFLOAD))
-		woal_update_radar_chans_dfs_state(wiphy);
-#endif
 	memset(region, 0, sizeof(region));
 	moal_memcpy_ext(priv->phandle, region, request->alpha2,
 			sizeof(request->alpha2), sizeof(region));
 	region[2] = ' ';
 	if ((handle->country_code[0] != request->alpha2[0]) ||
 	    (handle->country_code[1] != request->alpha2[1])) {
-		if (moal_extflg_isset(handle, EXT_CNTRY_TXPWR)) {
+		if (handle->params.cntry_txpwr) {
 			t_u8 country_code[COUNTRY_CODE_LEN];
 			handle->country_code[0] = request->alpha2[0];
 			handle->country_code[1] = request->alpha2[1];
@@ -3592,30 +4118,47 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
 				return;
 #endif
 			}
+			load_power_table = MTRUE;
 		}
 	}
-	if (MTRUE != is_cfg80211_special_region_code(region)) {
-		if (!moal_extflg_isset(handle, EXT_CNTRY_TXPWR)) {
-			handle->country_code[0] = request->alpha2[0];
-			handle->country_code[1] = request->alpha2[1];
-			handle->country_code[2] = ' ';
+	if (!handle->params.cntry_txpwr) {
+		handle->country_code[0] = request->alpha2[0];
+		handle->country_code[1] = request->alpha2[1];
+		handle->country_code[2] = ' ';
+		if (MTRUE != is_cfg80211_special_region_code(region)) {
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_region_code(priv, handle->country_code))
+				PRINTM(MERROR, "Set country code failed!\n");
 		}
-		if (MLAN_STATUS_SUCCESS !=
-		    woal_set_region_code(priv, handle->country_code))
-			PRINTM(MERROR, "Set country code failed!\n");
 	}
 	switch (request->initiator) {
 	case NL80211_REGDOM_SET_BY_DRIVER:
 		PRINTM(MCMND, "Regulatory domain BY_DRIVER\n");
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		reg_alpha2 = priv->phandle->params.reg_alpha2;
+		if ((handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE) &&
+		    !handle->params.txpwrlimit_cfg && load_power_table &&
+		    reg_alpha2 && woal_is_valid_alpha2(reg_alpha2))
+			queue_work(handle->evt_workqueue,
+				   &handle->regulatory_work);
+#endif
 		break;
 	case NL80211_REGDOM_SET_BY_CORE:
 		PRINTM(MCMND, "Regulatory domain BY_CORE\n");
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		if (handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE &&
+		    load_power_table && !handle->params.txpwrlimit_cfg)
+			queue_work(handle->evt_workqueue,
+				   &handle->regulatory_work);
+#endif
 		break;
 	case NL80211_REGDOM_SET_BY_USER:
 		PRINTM(MCMND, "Regulatory domain BY_USER\n");
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-		if (fw_region && moal_extflg_isset(handle, EXT_CNTRY_TXPWR))
-			woal_update_custom_regdomain(priv, wiphy);
+		if (handle->params.cntry_txpwr == CNTRY_RGPOWER_MODE &&
+		    load_power_table && !handle->params.txpwrlimit_cfg)
+			queue_work(handle->evt_workqueue,
+				   &handle->regulatory_work);
 #endif
 		break;
 	case NL80211_REGDOM_SET_BY_COUNTRY_IE:
@@ -3623,13 +4166,17 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
 		break;
 	}
 	if (priv->wdev && priv->wdev->wiphy &&
-	    (request->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE) &&
-	    (MTRUE != is_cfg80211_special_region_code(region))) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+	    !(wiphy->regulatory_flags & REGULATORY_WIPHY_SELF_MANAGED) &&
+#endif
+	    (request->initiator != NL80211_REGDOM_SET_BY_COUNTRY_IE)) {
 		band = priv->phandle->band;
 		priv->phandle->band = IEEE80211_BAND_2GHZ;
 		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
-		priv->phandle->band = IEEE80211_BAND_5GHZ;
-		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		if (priv->phandle->fw_bands & BAND_A) {
+			priv->phandle->band = IEEE80211_BAND_5GHZ;
+			woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		}
 		priv->phandle->band = band;
 	}
 
@@ -3649,8 +4196,8 @@ woal_cfg80211_reg_notifier(struct wiphy *wiphy,
  *
  * @return         0 --success, otherwise fail
  */
-mlan_status woal_role_switch(moal_private *priv, t_u8 wait_option,
-			     t_u8 bss_role)
+static mlan_status woal_role_switch(moal_private *priv, t_u8 wait_option,
+				    t_u8 bss_role)
 {
 	int ret = 0;
 	mlan_ds_bss *bss = NULL;
@@ -3739,7 +4286,8 @@ static int woal_setget_bandcfg(moal_private *priv, t_u8 action,
  *
  *  @return                     MLAN_STATUS_SUCCESS -- success, otherwise fail
  */
-mlan_status woal_uap_scan(moal_private *priv, wlan_user_scan_cfg *scan_cfg)
+static mlan_status woal_uap_scan(moal_private *priv,
+				 wlan_user_scan_cfg *scan_cfg)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	moal_handle *handle = priv->phandle;
@@ -3749,6 +4297,9 @@ mlan_status woal_uap_scan(moal_private *priv, wlan_user_scan_cfg *scan_cfg)
 	mlan_ds_band_cfg bandcfg;
 	u8 band_change = MFALSE;
 	ENTER();
+	memset(&org_bandcfg, 0, sizeof(mlan_ds_band_cfg));
+	memset(&bandcfg, 0, sizeof(mlan_ds_band_cfg));
+
 	if (priv->bss_index > 0)
 		tmp_priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
 	else
@@ -3758,13 +4309,33 @@ mlan_status woal_uap_scan(moal_private *priv, wlan_user_scan_cfg *scan_cfg)
 		return MLAN_STATUS_FAILURE;
 	}
 	role = GET_BSS_ROLE(tmp_priv);
-	if (role == MLAN_BSS_ROLE_UAP)
-		woal_role_switch(tmp_priv, MOAL_IOCTL_WAIT, MLAN_BSS_ROLE_STA);
+	if (role == MLAN_BSS_ROLE_UAP) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_role_switch(tmp_priv, MOAL_IOCTL_WAIT,
+				     MLAN_BSS_ROLE_STA)) {
+			PRINTM(MERROR, "role switch from uap to sta fail\n");
+			LEAVE();
+			return MLAN_STATUS_FAILURE;
+		}
+	}
 	if (tmp_priv != priv) {
-		woal_setget_bandcfg(priv, MLAN_ACT_GET, &bandcfg);
-		woal_setget_bandcfg(tmp_priv, MLAN_ACT_GET, &org_bandcfg);
+		if (woal_setget_bandcfg(priv, MLAN_ACT_GET, &bandcfg)) {
+			PRINTM(MERROR, "get bandcfg fail\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
+		if (woal_setget_bandcfg(tmp_priv, MLAN_ACT_GET, &org_bandcfg)) {
+			PRINTM(MERROR, "get bandcfg fail\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto done;
+		}
 		if (bandcfg.config_bands != org_bandcfg.config_bands) {
-			woal_setget_bandcfg(tmp_priv, MLAN_ACT_SET, &bandcfg);
+			if (woal_setget_bandcfg(tmp_priv, MLAN_ACT_SET,
+						&bandcfg)) {
+				PRINTM(MERROR, "set bandcfg fail\n");
+				ret = MLAN_STATUS_FAILURE;
+				goto done;
+			}
 			band_change = MTRUE;
 		}
 	}
@@ -3781,16 +4352,26 @@ mlan_status woal_uap_scan(moal_private *priv, wlan_user_scan_cfg *scan_cfg)
 	MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
 #endif
 done:
-	if (role == MLAN_BSS_ROLE_UAP)
-		woal_role_switch(tmp_priv, MOAL_IOCTL_WAIT, MLAN_BSS_ROLE_UAP);
-	if (band_change)
-		woal_setget_bandcfg(tmp_priv, MLAN_ACT_SET, &org_bandcfg);
+	if (role == MLAN_BSS_ROLE_UAP) {
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_role_switch(tmp_priv, MOAL_IOCTL_WAIT,
+				     MLAN_BSS_ROLE_UAP)) {
+			PRINTM(MERROR, "role switch back to uap fail\n");
+			ret = MLAN_STATUS_FAILURE;
+		}
+	}
+	if (band_change) {
+		if (woal_setget_bandcfg(tmp_priv, MLAN_ACT_SET, &org_bandcfg)) {
+			PRINTM(MERROR, "restore bandcfg fail\n");
+			ret = MLAN_STATUS_FAILURE;
+		}
+	}
 	LEAVE();
 	return ret;
 }
 #endif
 
-static int woal_find_wps_ie_in_probereq(const t_u8 *ie, int len)
+static int woal_find_wps_ie_in_probereq(const t_u8 *ie, size_t len)
 {
 	int left_len = len;
 	const t_u8 *pos = ie;
@@ -3818,6 +4399,9 @@ static int woal_find_wps_ie_in_probereq(const t_u8 *ie, int len)
 	return MFALSE;
 }
 
+#ifdef UAP_CFG80211
+/** scan result expired value */
+#define SCAN_RESULT_EXPIRTED 1
 /**
  *  @brief check if the scan result expired
  *
@@ -3826,45 +4410,62 @@ static int woal_find_wps_ie_in_probereq(const t_u8 *ie, int len)
  *
  *  @return             MTRUE/MFALSE;
  */
-t_u8 woal_is_scan_result_expired(moal_private *priv)
+static t_u8 woal_is_uap_scan_result_expired(moal_private *priv)
 {
 	mlan_scan_resp scan_resp;
 	wifi_timeval t;
 	ENTER();
-	// Don't block ACS scan
-	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
+
+	memset(&scan_resp, 0, sizeof(scan_resp));
+
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_scan_table(priv, MOAL_IOCTL_WAIT, &scan_resp)) {
 		LEAVE();
 		return MTRUE;
 	}
-	// Don't block scan when non any interface active
-	if (!woal_is_any_interface_active(priv->phandle)) {
+	if (!scan_resp.num_in_scan_table) {
 		LEAVE();
 		return MTRUE;
 	}
-#if defined(WIFI_DIRECT_SUPPORT)
-#if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
-	// Do not skip p2p interface connect scan
-	if (priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT) {
+	woal_get_monotonic_time(&t);
+	if (t.time_sec > (scan_resp.age_in_secs + SCAN_RESULT_EXPIRTED)) {
 		LEAVE();
 		return MTRUE;
 	}
-#endif
+	LEAVE();
+	return MFALSE;
+}
 #endif
 
+/**
+ *  @brief check if the scan result ageout
+ *
+ *  @param priv         A pointer to moal_private
+ *
+ *
+ *  @return             MTRUE/MFALSE;
+ */
+t_u8 wlan_check_scan_table_ageout(moal_private *priv)
+{
+	mlan_scan_resp scan_resp;
+	wifi_timeval t;
+	ENTER();
+	memset(&scan_resp, 0, sizeof(scan_resp));
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_get_scan_table(priv, MOAL_IOCTL_WAIT, &scan_resp)) {
 		LEAVE();
-		return MTRUE;
+		return MFALSE;
 	}
 	woal_get_monotonic_time(&t);
-/** scan result expired value */
-#define SCAN_RESULT_EXPIRTED 1
-	if (t.time_sec > (scan_resp.age_in_secs + SCAN_RESULT_EXPIRTED)) {
+#define CFG80211_SCAN_RESULT_AGEOUT 10
+	if (t.time_sec >
+	    (scan_resp.age_in_secs + CFG80211_SCAN_RESULT_AGEOUT)) {
 		LEAVE();
-		return MTRUE;
+		return MFALSE;
 	}
+	PRINTM(MCMND, "Scan: Keep Previous result\n");
 	LEAVE();
-	return MFALSE;
+	return MTRUE;
 }
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
@@ -3915,6 +4516,12 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 	ENTER();
 
 	PRINTM(MINFO, "Received scan request on %s\n", dev->name);
+	if (priv->phandle->driver_status) {
+		PRINTM(MERROR,
+		       "Block woal_cfg80211_scan in abnormal driver state\n");
+		LEAVE();
+		return -EFAULT;
+	}
 	if (priv->phandle->scan_pending_on_block == MTRUE) {
 		PRINTM(MCMND, "scan already in processing...\n");
 		LEAVE();
@@ -3940,10 +4547,15 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 #endif
 #endif
 #endif
-	if (priv->fake_scan_complete || !woal_is_scan_result_expired(priv)) {
-		PRINTM(MEVENT,
-		       "scan result not expired or fake scan complete flag is on\n");
-		return -EAGAIN;
+	cancel_delayed_work(&priv->phandle->scan_timeout_work);
+	priv->phandle->fake_scan_complete = priv->fake_scan_complete;
+	if (priv->fake_scan_complete) {
+		PRINTM(MEVENT, "fake scan complete flag is on\n");
+		priv->phandle->scan_request = request;
+		queue_delayed_work(priv->phandle->evt_workqueue,
+				   &priv->phandle->scan_timeout_work,
+				   msecs_to_jiffies(1000));
+		return ret;
 	}
 	memset(&bss_info, 0, sizeof(bss_info));
 	if (MLAN_STATUS_SUCCESS ==
@@ -3972,6 +4584,11 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 		       priv->phandle->scan_time_start.time_usec);
 	}
 	scan_req = kmalloc(sizeof(wlan_user_scan_cfg), GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Failed to alloc memory for scan_req\n");
+		LEAVE();
+		return -ENOMEM;
+	}
 	memset(scan_req, 0x00, sizeof(wlan_user_scan_cfg));
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
 	if (!is_broadcast_ether_addr(request->bssid)) {
@@ -3983,16 +4600,15 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 	}
 #endif
 
-	if (priv->phandle->scan_request->n_channels <= 38)
-		scan_req->ext_scan_type = EXT_SCAN_ENHANCE;
-
 	memset(&scan_cfg, 0, sizeof(mlan_scan_cfg));
+	if (MLAN_STATUS_SUCCESS != woal_get_scan_config(priv, &scan_cfg)) {
+		PRINTM(MERROR, "Fail to get scan request IE\n");
+	}
 #ifdef WIFI_DIRECT_SUPPORT
 	if (priv->phandle->miracast_mode)
 		scan_req->scan_chan_gap = priv->phandle->scan_chan_gap;
 	else {
 #endif
-		woal_get_scan_config(priv, &scan_cfg);
 		if (scan_cfg.scan_chan_gap)
 			scan_req->scan_chan_gap = scan_cfg.scan_chan_gap;
 		else if (woal_is_any_interface_active(priv->phandle))
@@ -4006,6 +4622,10 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 	if (scan_req->scan_chan_gap && priv->phandle->pref_mac)
 		scan_req->scan_chan_gap |= GAP_FLAG_OPTIONAL;
 
+	scan_req->scan_cfg_only = MTRUE;
+	if (scan_cfg.ext_scan == 3)
+		scan_req->ext_scan_type = EXT_SCAN_ENHANCE;
+
 	for (i = 0; i < priv->phandle->scan_request->n_ssids; i++) {
 		moal_memcpy_ext(priv->phandle, scan_req->ssid_list[i].ssid,
 				priv->phandle->scan_request->ssids[i].ssid,
@@ -4026,12 +4646,13 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 	}
 #endif
 #endif
-	for (i = 0; i < MIN(WLAN_USER_SCAN_CHAN_MAX,
-			    priv->phandle->scan_request->n_channels);
+	for (i = 0; i < (int)MIN(WLAN_USER_SCAN_CHAN_MAX,
+				 priv->phandle->scan_request->n_channels);
 	     i++) {
 		chan = priv->phandle->scan_request->channels[i];
 		scan_req->chan_list[i].chan_number = chan->hw_value;
-		scan_req->chan_list[i].radio_type = chan->band;
+		scan_req->chan_list[i].radio_type =
+			woal_ieee_band_to_radio_type(chan->band);
 		if ((chan->flags & IEEE80211_CHAN_PASSIVE_SCAN) ||
 		    !priv->phandle->scan_request->n_ssids)
 			scan_req->chan_list[i].scan_type =
@@ -4042,6 +4663,8 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 		else
 			scan_req->chan_list[i].scan_type =
 				MLAN_SCAN_TYPE_ACTIVE;
+		PRINTM(MCMD_D, "cfg80211_scan: chan=%d chan->flag=0x%x\n",
+		       chan->hw_value, chan->flags);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 		scan_req->chan_list[i].scan_time =
 			priv->phandle->scan_request->duration;
@@ -4067,14 +4690,21 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 				scan_req->chan_list[i].scan_time =
 					INIT_PASSIVE_SCAN_CHAN_TIME;
 			else
-				scan_req->chan_list[i].scan_time =
-					MIN_SPECIFIC_SCAN_CHAN_TIME;
+				scan_req->chan_list[i].scan_time = MIN(
+					MIN_SPECIFIC_SCAN_CHAN_TIME,
+					scan_cfg.scan_time.specific_scan_time);
 		}
 #endif
 #ifdef UAP_CFG80211
-		if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP)
-			scan_req->chan_list[i].scan_time =
-				MIN_SPECIFIC_SCAN_CHAN_TIME;
+		if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
+			if (!woal_is_uap_scan_result_expired(priv))
+				scan_req->chan_list[i].scan_time =
+					MIN_SPECIFIC_SCAN_CHAN_TIME;
+
+			else
+				scan_req->chan_list[i].scan_time =
+					PASSIVE_SCAN_CHAN_TIME;
+		}
 #endif
 	}
 	if (priv->phandle->scan_request->ie &&
@@ -4098,11 +4728,17 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 		}
 	} else {
 		/** Clear SCAN IE in Firmware */
-		if (priv->probereq_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK)
-			woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0,
-						    NULL, 0, NULL, 0,
-						    MGMT_MASK_PROBE_REQ,
-						    MOAL_IOCTL_WAIT);
+		if (priv->probereq_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK) {
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_cfg80211_mgmt_frame_ie(
+				    priv, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+				    MGMT_MASK_PROBE_REQ, MOAL_IOCTL_WAIT)) {
+				PRINTM(MERROR,
+				       "Fail to clear scan request IE\n");
+				ret = -EFAULT;
+				goto done;
+			}
+		}
 	}
 #ifdef UAP_CFG80211
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
@@ -4137,6 +4773,10 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 
 	PRINTM(MCMND, "wlan:random_mac " MACSTR "\n",
 	       MAC2STR(scan_req->random_mac));
+	if (priv->phandle->params.keep_previous_scan)
+		scan_req->keep_previous_scan =
+			wlan_check_scan_table_ageout(priv);
+
 	if (MLAN_STATUS_SUCCESS != woal_do_scan(priv, scan_req)) {
 		PRINTM(MERROR, "woal_do_scan fails!\n");
 		ret = -EAGAIN;
@@ -4149,8 +4789,13 @@ static int woal_cfg80211_scan(struct wiphy *wiphy, struct net_device *dev,
 		priv->phandle->scan_request = NULL;
 		priv->phandle->scan_priv = NULL;
 		spin_unlock_irqrestore(&priv->phandle->scan_req_lock, flags);
-	} else
+	} else {
 		PRINTM(MMSG, "wlan: %s START SCAN\n", dev->name);
+		queue_delayed_work(
+			priv->phandle->evt_workqueue,
+			&priv->phandle->scan_timeout_work,
+			msecs_to_jiffies(priv->phandle->scan_timeout));
+	}
 	kfree(scan_req);
 	LEAVE();
 	return ret;
@@ -4186,6 +4831,7 @@ static int woal_send_ft_action_requst(moal_private *priv, t_u8 *ie, t_u8 len,
 	t_u32 pkt_type;
 	t_u32 tx_control;
 	t_u16 packet_len = 0;
+	t_u16 pkt_len = 0;
 	t_u8 addr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 	int ret = 0;
 
@@ -4217,15 +4863,16 @@ static int woal_send_ft_action_requst(moal_private *priv, t_u8 *ie, t_u8 len,
 			pmbuf->pbuf + pmbuf->data_offset + sizeof(pkt_type),
 			&tx_control, sizeof(tx_control), sizeof(tx_control));
 	/*Add packet len*/
+	pkt_len = woal_cpu_to_le16(packet_len);
 	moal_memcpy_ext(priv->phandle,
 			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE,
-			&packet_len, sizeof(packet_len), sizeof(packet_len));
+			&pkt_len, sizeof(pkt_len), sizeof(pkt_len));
 
 	mgmt = (IEEE80211_MGMT *)(pmbuf->pbuf + pmbuf->data_offset +
 				  HEADER_SIZE + sizeof(packet_len));
 	memset(mgmt, 0, MGMT_HEADER_LEN);
 	mgmt->frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION);
+		woal_cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION);
 	moal_memcpy_ext(priv->phandle, mgmt->da, bssid, ETH_ALEN,
 			sizeof(mgmt->da));
 	moal_memcpy_ext(priv->phandle, mgmt->sa, priv->current_addr, ETH_ALEN,
@@ -4293,6 +4940,7 @@ static int woal_send_ft_auth_requst(moal_private *priv, t_u8 *ie, t_u8 len,
 	t_u32 pkt_type;
 	t_u32 tx_control;
 	t_u16 packet_len = 0;
+	t_u16 pkt_len;
 	t_u8 addr[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 	int ret = 0;
 
@@ -4323,15 +4971,16 @@ static int woal_send_ft_auth_requst(moal_private *priv, t_u8 *ie, t_u8 len,
 			pmbuf->pbuf + pmbuf->data_offset + sizeof(pkt_type),
 			&tx_control, sizeof(tx_control), sizeof(tx_control));
 	/*Add packet len*/
+	pkt_len = woal_cpu_to_le16(packet_len);
 	moal_memcpy_ext(priv->phandle,
 			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE,
-			&packet_len, sizeof(packet_len), sizeof(packet_len));
+			&pkt_len, sizeof(pkt_len), sizeof(pkt_len));
 
 	mgmt = (IEEE80211_MGMT *)(pmbuf->pbuf + pmbuf->data_offset +
 				  HEADER_SIZE + sizeof(packet_len));
 	memset(mgmt, 0, MGMT_HEADER_LEN);
 	mgmt->frame_control =
-		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
+		woal_cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
 	moal_memcpy_ext(priv->phandle, mgmt->da, bssid, ETH_ALEN,
 			sizeof(mgmt->da));
 	moal_memcpy_ext(priv->phandle, mgmt->sa, priv->current_addr, ETH_ALEN,
@@ -4341,9 +4990,9 @@ static int woal_send_ft_auth_requst(moal_private *priv, t_u8 *ie, t_u8 len,
 	moal_memcpy_ext(priv->phandle, mgmt->addr4, addr, ETH_ALEN,
 			sizeof(mgmt->addr4));
 
-	mgmt->u.auth.auth_alg = cpu_to_le16(WLAN_AUTH_FT);
-	mgmt->u.auth.auth_transaction = cpu_to_le16(1);
-	mgmt->u.auth.status_code = cpu_to_le16(0);
+	mgmt->u.auth.auth_alg = woal_cpu_to_le16(WLAN_AUTH_FT);
+	mgmt->u.auth.auth_transaction = woal_cpu_to_le16(1);
+	mgmt->u.auth.status_code = woal_cpu_to_le16(0);
 	if (ie && len)
 		moal_memcpy_ext(priv->phandle, (t_u8 *)(&mgmt->u.auth.variable),
 				ie, len, len);
@@ -4408,9 +5057,11 @@ static int woal_connect_ft_over_air(moal_private *priv, t_u8 *bssid,
 	woal_mgmt_frame_register(priv, IEEE80211_STYPE_AUTH, MTRUE);
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
-#define AUTH_TX_DEFAULT_WAIT_TIME 1200
-	woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MFALSE, &status,
-					    chan, 0, AUTH_TX_DEFAULT_WAIT_TIME);
+	if (woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MFALSE,
+						&status, chan, 0,
+						AUTH_TX_DEFAULT_WAIT_TIME)) {
+		PRINTM(MERROR, "Failed remain on channel config\n");
+	}
 #endif
 
 	/*construct auth request and send out*/
@@ -4440,8 +5091,10 @@ static int woal_connect_ft_over_air(moal_private *priv, t_u8 *bssid,
 	}
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
-	woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MTRUE, &status,
-					    NULL, 0, 0);
+	if (woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MTRUE,
+						&status, NULL, 0, 0)) {
+		PRINTM(MERROR, "Failed to cancel remain on channel\n");
+	}
 #endif
 
 	woal_mgmt_frame_register(priv, IEEE80211_STYPE_AUTH, MFALSE);
@@ -4473,8 +5126,12 @@ static int woal_connect_ft_over_ds(moal_private *priv, t_u8 *bssid,
 
 	if (priv->media_connected) {
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
-		woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MFALSE,
-						    &status, pchan, 0, 1200);
+		if (woal_cfg80211_remain_on_channel_cfg(priv, wait_option,
+							MFALSE, &status, pchan,
+							0, 1200)) {
+			PRINTM(MERROR,
+			       "Failed to configure remain on channel\n");
+		}
 #endif
 		/*construct ft action request and send out*/
 		woal_send_ft_action_requst(priv, priv->ft_ie, priv->ft_ie_len,
@@ -4489,8 +5146,12 @@ static int woal_connect_ft_over_ds(moal_private *priv, t_u8 *bssid,
 			/*go over air, as current AP may be unreachable */
 			PRINTM(MMSG, "wlan: go over air\n");
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
-			woal_cfg80211_remain_on_channel_cfg(
-				priv, wait_option, MTRUE, &status, NULL, 0, 0);
+			if (woal_cfg80211_remain_on_channel_cfg(
+				    priv, wait_option, MTRUE, &status, NULL, 0,
+				    0)) {
+				PRINTM(MERROR,
+				       "Failed to cancel remain on channel\n");
+			}
 #endif
 			woal_connect_ft_over_air(priv, bssid, pchan);
 			LEAVE();
@@ -4502,8 +5163,10 @@ static int woal_connect_ft_over_ds(moal_private *priv, t_u8 *bssid,
 					sizeof(priv->target_ap_bssid));
 		}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
-		woal_cfg80211_remain_on_channel_cfg(priv, wait_option, MTRUE,
-						    &status, NULL, 0, 0);
+		if (woal_cfg80211_remain_on_channel_cfg(
+			    priv, wait_option, MTRUE, &status, NULL, 0, 0)) {
+			PRINTM(MERROR, "Failed to cancel remain on channel\n");
+		}
 #endif
 	}
 
@@ -4571,7 +5234,9 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	unsigned long flags;
 	mlan_ds_misc_assoc_rsp *assoc_rsp = NULL;
 	IEEEtypes_AssocRsp_t *passoc_rsp = NULL;
-	mlan_ssid_bssid ssid_bssid;
+	mlan_ds_misc_assoc_req assoc_req;
+
+	mlan_ssid_bssid *ssid_bssid = NULL;
 	moal_handle *handle = priv->phandle;
 	int i;
 
@@ -4597,22 +5262,28 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		LEAVE();
 		return -EINVAL;
 	}
-	memset(&ssid_bssid, 0, sizeof(ssid_bssid));
-	moal_memcpy_ext(priv->phandle, &ssid_bssid.ssid.ssid, sme->ssid,
-			sme->ssid_len, sizeof(ssid_bssid.ssid.ssid));
-	ssid_bssid.ssid.ssid_len = sme->ssid_len;
+	ssid_bssid = kmalloc(sizeof(mlan_ssid_bssid), GFP_KERNEL);
+	if (!ssid_bssid) {
+		LEAVE();
+		return -EFAULT;
+	}
+	memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+	moal_memcpy_ext(priv->phandle, &ssid_bssid->ssid.ssid, sme->ssid,
+			sme->ssid_len, sizeof(ssid_bssid->ssid.ssid));
+	ssid_bssid->ssid.ssid_len = sme->ssid_len;
 	if (sme->bssid)
-		moal_memcpy_ext(priv->phandle, &ssid_bssid.bssid, sme->bssid,
-				ETH_ALEN, sizeof(ssid_bssid.bssid));
+		moal_memcpy_ext(priv->phandle, &ssid_bssid->bssid, sme->bssid,
+				ETH_ALEN, sizeof(ssid_bssid->bssid));
 	/* Not allowed to connect to the same AP which is already connected
 		with other interface */
 	for (i = 0; i < handle->priv_num; i++) {
 		if (handle->priv[i] != priv &&
-		    MTRUE == woal_is_connected(handle->priv[i], &ssid_bssid)) {
+		    MTRUE == woal_is_connected(handle->priv[i], ssid_bssid)) {
 			PRINTM(MMSG,
 			       "wlan: already connected with other interface, bssid " MACSTR
 			       "\n",
 			       MAC2STR(handle->priv[i]->cfg_bssid));
+			kfree(ssid_bssid);
 			LEAVE();
 			return -EINVAL;
 		}
@@ -4640,6 +5311,7 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 			       "Init p2p client for wpa_supplicant failed.\n");
 			ret = -EFAULT;
 
+			kfree(ssid_bssid);
 			LEAVE();
 			return ret;
 		}
@@ -4655,17 +5327,20 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	    !(priv->ft_cap & MBIT(0))) {
 		/** get current bss info */
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+			PRINTM(MERROR, "Fail to get bss info\n");
+		}
 		/** get target bss info */
 		if (MLAN_STATUS_SUCCESS !=
-		    woal_find_essid(priv, &ssid_bssid, MOAL_IOCTL_WAIT)) {
+		    woal_find_essid(priv, ssid_bssid, MOAL_IOCTL_WAIT)) {
 			ret = woal_cfg80211_connect_scan(priv, sme,
 							 MOAL_IOCTL_WAIT);
 			if (!ret) {
 				if (MLAN_STATUS_SUCCESS !=
 				    woal_find_best_network(priv,
 							   MOAL_IOCTL_WAIT,
-							   &ssid_bssid)) {
+							   ssid_bssid)) {
 					PRINTM(MERROR,
 					       "can't find targe AP \n");
 					// LEAVE();
@@ -4673,9 +5348,10 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 				}
 			}
 		}
-		if (bss_info.mdid == ssid_bssid.ft_md &&
-		    bss_info.ft_cap == ssid_bssid.ft_cap) {
-			ret = woal_start_ft_roaming(priv, &ssid_bssid);
+		if (bss_info.mdid == ssid_bssid->ft_md &&
+		    bss_info.ft_cap == ssid_bssid->ft_cap) {
+			ret = woal_start_ft_roaming(priv, ssid_bssid);
+			kfree(ssid_bssid);
 			LEAVE();
 			return 0;
 		}
@@ -4689,6 +5365,7 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	if (!assoc_rsp) {
 		PRINTM(MERROR, "Failed to allocate memory for assoc_rsp\n");
 		ret = -ENOMEM;
+		kfree(ssid_bssid);
 		LEAVE();
 		return ret;
 	}
@@ -4700,17 +5377,18 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 	if (!ret) {
 		passoc_rsp = (IEEEtypes_AssocRsp_t *)assoc_rsp->assoc_resp_buf;
 		priv->rssi_low = DEFAULT_RSSI_LOW_THRESHOLD;
-		if (priv->bss_type == MLAN_BSS_TYPE_STA)
-			woal_save_conn_params(priv, sme);
+		woal_save_conn_params(priv, sme);
 		memset(&bss_info, 0, sizeof(bss_info));
 		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
 		priv->channel = bss_info.bss_chan;
-		if (!ssid_bssid.ft_md) {
+		if (!ssid_bssid->ft_md) {
 			priv->ft_ie_len = 0;
 			priv->ft_pre_connect = MFALSE;
 			priv->ft_md = 0;
 			priv->ft_cap = 0;
 		}
+		memset(&assoc_req, 0, sizeof(mlan_ds_misc_assoc_req));
+		woal_get_assoc_req(priv, &assoc_req, MOAL_IOCTL_WAIT);
 	}
 	spin_lock_irqsave(&priv->connect_lock, flags);
 	priv->cfg_connect = MFALSE;
@@ -4719,11 +5397,11 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 		       "wlan: Connected to bssid " MACSTR " successfully\n",
 		       MAC2STR(priv->cfg_bssid));
 		spin_unlock_irqrestore(&priv->connect_lock, flags);
-		cfg80211_connect_result(priv->netdev, priv->cfg_bssid, NULL, 0,
-					passoc_rsp->ie_buffer,
-					assoc_rsp->assoc_resp_len -
-						ASSOC_RESP_FIXED_SIZE,
-					WLAN_STATUS_SUCCESS, GFP_KERNEL);
+		cfg80211_connect_result(
+			priv->netdev, priv->cfg_bssid, assoc_req.assoc_req_buf,
+			assoc_req.assoc_req_len, passoc_rsp->ie_buffer,
+			assoc_rsp->assoc_resp_len - ASSOC_RESP_FIXED_SIZE,
+			WLAN_STATUS_SUCCESS, GFP_KERNEL);
 	} else {
 		PRINTM(MINFO, "wlan: Failed to connect to bssid " MACSTR "\n",
 		       MAC2STR(priv->cfg_bssid));
@@ -4733,7 +5411,7 @@ static int woal_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,
 					NULL, 0, woal_get_assoc_status(priv),
 					GFP_KERNEL);
 	}
-
+	kfree(ssid_bssid);
 	kfree(assoc_rsp);
 	assoc_rsp = NULL;
 	LEAVE();
@@ -4828,16 +5506,15 @@ static int woal_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		return -EFAULT;
 	}
 
-	if (priv->cfg_disconnect) {
-		PRINTM(MERROR, "Disassociation already in progress\n");
-		LEAVE();
-		return 0;
-	}
-
 	if (priv->media_connected == MFALSE) {
 		PRINTM(MMSG, " Already disconnected\n");
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+		if (priv->wdev->connected &&
+#else
 		if (priv->wdev->current_bss &&
+#endif
 		    (priv->wdev->iftype == NL80211_IFTYPE_STATION ||
 		     priv->wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)) {
 			priv->cfg_disconnect = MTRUE;
@@ -4852,6 +5529,14 @@ static int woal_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 		return 0;
 	}
 
+	if (priv->cfg_disconnect) {
+		PRINTM(MERROR, "Disassociation already in progress\n");
+		LEAVE();
+		return 0;
+	}
+
+	/** cancel pending scan */
+	woal_cancel_scan(priv, MOAL_IOCTL_WAIT);
 	priv->cfg_disconnect = MTRUE;
 	if (woal_disconnect(priv, MOAL_IOCTL_WAIT_TIMEOUT, priv->cfg_bssid,
 			    reason_code) != MLAN_STATUS_SUCCESS) {
@@ -4871,14 +5556,14 @@ static int woal_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *dev,
 #endif
 
 	memset(priv->cfg_bssid, 0, ETH_ALEN);
-	if (priv->bss_type == MLAN_BSS_TYPE_STA)
-		woal_clear_conn_params(priv);
+	woal_clear_conn_params(priv);
 	priv->channel = 0;
 
 	LEAVE();
 	return 0;
 }
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 /**
  *  @brief This function is deauthentication handler when host MLME
  *          enable.
@@ -4898,8 +5583,8 @@ static int woal_cfg80211_deauthenticate(struct wiphy *wiphy,
 					struct cfg80211_deauth_request *req)
 {
 	int ret = 0;
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	if (priv->host_mlme) {
 		priv->host_mlme = MFALSE;
 		priv->auth_flag = 0;
@@ -4916,6 +5601,8 @@ static int woal_cfg80211_deauthenticate(struct wiphy *wiphy,
 	    priv->wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)
 		cfg80211_disconnected(priv->netdev, 0, NULL, 0, GFP_KERNEL);
 #endif
+	if (priv->media_connected)
+		woal_send_disconnect_to_system(priv, DEF_DEAUTH_REASON_CODE);
 	return ret;
 }
 
@@ -4937,8 +5624,8 @@ static int woal_cfg80211_disassociate(struct wiphy *wiphy,
 				      struct cfg80211_disassoc_request *req)
 {
 	int ret = 0;
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	if (priv->host_mlme) {
 		priv->host_mlme = MFALSE;
 		priv->auth_flag = 0;
@@ -4955,8 +5642,12 @@ static int woal_cfg80211_disassociate(struct wiphy *wiphy,
 	    priv->wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)
 		cfg80211_disconnected(priv->netdev, 0, NULL, 0, GFP_KERNEL);
 #endif
+	if (priv->media_connected)
+		woal_send_disconnect_to_system(priv, DEF_DEAUTH_REASON_CODE);
+
 	return ret;
 }
+#endif
 
 /**
  * @brief Request the driver to get the station information
@@ -5000,6 +5691,7 @@ static int woal_cfg80211_get_station(struct wiphy *wiphy,
 		ret = -EFAULT;
 	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	woal_check_auto_tdls(wiphy, dev);
 #endif
 	LEAVE();
 	return ret;
@@ -5060,7 +5752,7 @@ static int woal_cfg80211_dump_station(struct wiphy *wiphy,
  *
  *  @return         IEEE band type
  */
-t_u8 woal_bandcfg_to_ieee_band(Band_Config_t bandcfg)
+static t_u8 woal_bandcfg_to_ieee_band(Band_Config_t bandcfg)
 {
 	t_u8 ret_radio_type = 0;
 
@@ -5109,11 +5801,11 @@ static int woal_cfg80211_dump_survey(struct wiphy *wiphy,
 		goto done;
 	}
 	pchan_stats = (ChanStatistics_t *)scan_resp.pchan_stats;
-	if (idx > scan_resp.num_in_chan_stats || idx < 0) {
+	if (idx > (int)scan_resp.num_in_chan_stats || idx < 0) {
 		ret = -EFAULT;
 		goto done;
 	}
-	if (idx == scan_resp.num_in_chan_stats ||
+	if (idx == (int)scan_resp.num_in_chan_stats ||
 	    !pchan_stats[idx].cca_scan_duration)
 		goto done;
 	ret = 0;
@@ -5148,13 +5840,31 @@ static int woal_cfg80211_dump_survey(struct wiphy *wiphy,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 static int woal_cfg80211_get_channel(struct wiphy *wiphy,
 				     struct wireless_dev *wdev,
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+				     unsigned int link_id,
+#endif
 				     struct cfg80211_chan_def *chandef)
 {
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(wdev->netdev);
 	chan_band_info channel;
+#ifdef UAP_SUPPORT
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+#endif
 
 	memset(&channel, 0x00, sizeof(channel));
 
+#ifdef UAP_SUPPORT
+	if (wdev->iftype == NL80211_IFTYPE_MONITOR) {
+		if ((handle->mon_if) &&
+		    (handle->mon_if->mon_ndev == wdev->netdev)) {
+			*chandef = handle->mon_if->chandef;
+			return 0;
+		}
+		return -EFAULT;
+	}
+#endif
+
 #ifdef UAP_SUPPORT
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_UAP) {
 		if (priv->bss_started == MTRUE) {
@@ -5328,6 +6038,7 @@ static int woal_cfg80211_set_tx_power(struct wiphy *wiphy,
 	mlan_power_cfg_t power_cfg;
 
 	ENTER();
+	memset(&power_cfg, 0, sizeof(power_cfg));
 
 	priv = woal_get_priv(handle, MLAN_BSS_ROLE_ANY);
 	if (!priv) {
@@ -5364,6 +6075,7 @@ static int woal_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
 					     struct net_device *dev,
 					     s32 rssi_thold, u32 rssi_hyst)
 {
+	int ret = 0;
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	ENTER();
 	priv->cqm_rssi_thold = rssi_thold;
@@ -5372,9 +6084,12 @@ static int woal_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
 
 	PRINTM(MIOCTL, "rssi_thold=%d rssi_hyst=%d\n", (int)rssi_thold,
 	       (int)rssi_hyst);
-	woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_set_rssi_threshold(priv, 0, MOAL_IOCTL_WAIT)) {
+		PRINTM(MERROR, "Fail to set rssi thresold.\n");
+	}
 	LEAVE();
-	return 0;
+	return ret;
 }
 #endif
 
@@ -5422,10 +6137,8 @@ int woal_cfg80211_remain_on_channel_cfg(moal_private *priv, t_u8 wait_option,
 			return -EBUSY;
 		}
 #endif
-		if (chan->band == IEEE80211_BAND_2GHZ)
-			chan_cfg.bandcfg.chanBand = BAND_2GHZ;
-		else if (chan->band == IEEE80211_BAND_5GHZ)
-			chan_cfg.bandcfg.chanBand = BAND_5GHZ;
+		chan_cfg.bandcfg.chanBand =
+			woal_ieee_band_to_radio_type(chan->band);
 		switch (channel_type) {
 		case CHAN_HT40MINUS:
 			chan_cfg.bandcfg.chan2Offset = SEC_CHAN_BELOW;
@@ -5645,7 +6358,11 @@ woal_cfg80211_remain_on_channel(struct wiphy *wiphy, struct net_device *dev,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 8, 0)
 	*cookie = (u64)random32() | 1;
 #else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 1, 0)
 	*cookie = (u64)prandom_u32() | 1;
+#else
+	*cookie = (u64)get_random_u32() | 1;
+#endif
 #endif
 	priv->phandle->remain_on_channel = MTRUE;
 	priv->phandle->remain_bss_index = priv->bss_index;
@@ -5781,13 +6498,13 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 		return -EINVAL;
 	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
-	PRINTM(MIOCTL,
-	       "%s sched scan: n_ssids=%d n_match_sets=%d n_channels=%d interval=%d ie_len=%d\n",
+	PRINTM(MCMND,
+	       "%s sched scan: n_ssids=%d n_match_sets=%d n_channels=%d interval=%d iterations=%d ie_len=%d\n",
 	       priv->netdev->name, request->n_ssids, request->n_match_sets,
 	       request->n_channels, request->scan_plans[0].interval,
-	       (int)request->ie_len);
+	       request->scan_plans[0].iterations, (int)request->ie_len);
 #else
-	PRINTM(MIOCTL,
+	PRINTM(MCMND,
 	       "%s sched scan: n_ssids=%d n_match_sets=%d n_channels=%d interval=%d ie_len=%d\n",
 	       priv->netdev->name, request->n_ssids, request->n_match_sets,
 	       request->n_channels, request->interval, (int)request->ie_len);
@@ -5805,10 +6522,12 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 	/** Add broadcast scan, when n_match_sets = 0 */
 	if (!request->n_match_sets)
 		priv->scan_cfg.ssid_list[0].max_len = 0xff;
-	for (i = 0; i < MIN(WLAN_BG_SCAN_CHAN_MAX, request->n_channels); i++) {
+	for (i = 0; i < (int)MIN(WLAN_USER_SCAN_CHAN_MAX, request->n_channels);
+	     i++) {
 		chan = request->channels[i];
 		priv->scan_cfg.chan_list[i].chan_number = chan->hw_value;
-		priv->scan_cfg.chan_list[i].radio_type = chan->band;
+		priv->scan_cfg.chan_list[i].radio_type =
+			woal_ieee_band_to_radio_type(chan->band);
 		if (chan->flags &
 		    (IEEE80211_CHAN_PASSIVE_SCAN | IEEE80211_CHAN_RADAR))
 			priv->scan_cfg.chan_list[i].scan_type =
@@ -5816,6 +6535,8 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 		else
 			priv->scan_cfg.chan_list[i].scan_type =
 				MLAN_SCAN_TYPE_ACTIVE;
+		PRINTM(MCMD_D, "cfg80211_sched_scan: chan=%d chan->flag=0x%x\n",
+		       chan->hw_value, chan->flags);
 		priv->scan_cfg.chan_list[i].scan_time = 0;
 #ifdef WIFI_DIRECT_SUPPORT
 		if (priv->phandle->miracast_mode)
@@ -5824,7 +6545,7 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 #endif
 	}
 	priv->scan_cfg.chan_per_scan =
-		MIN(WLAN_BG_SCAN_CHAN_MAX, request->n_channels);
+		MIN(WLAN_USER_SCAN_CHAN_MAX, request->n_channels);
 
 	/** set scan request IES */
 	if (request->ie && request->ie_len) {
@@ -5839,47 +6560,57 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 		}
 	} else {
 		/** Clear SCAN IE in Firmware */
-		if (priv->probereq_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK)
-			woal_cfg80211_mgmt_frame_ie(priv, NULL, 0, NULL, 0,
-						    NULL, 0, NULL, 0,
-						    MGMT_MASK_PROBE_REQ,
-						    MOAL_IOCTL_WAIT);
+		if (priv->probereq_index != MLAN_CUSTOM_IE_AUTO_IDX_MASK) {
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_cfg80211_mgmt_frame_ie(
+				    priv, NULL, 0, NULL, 0, NULL, 0, NULL, 0,
+				    MGMT_MASK_PROBE_REQ, MOAL_IOCTL_WAIT)) {
+				PRINTM(MERROR, "Fail to clear sched scan IE\n");
+				ret = -EFAULT;
+				goto done;
+			}
+		}
 	}
 
 	/* Interval between scan cycles in milliseconds,supplicant set to 10
 	 * second */
 	/* We want to use 30 second for per scan cycle */
 	priv->scan_cfg.scan_interval = MIN_BGSCAN_INTERVAL;
+	priv->scan_cfg.repeat_count = 0;
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
-	if (request->scan_plans[0].interval * 1000 > MIN_BGSCAN_INTERVAL)
+	/* interval in seconds */
+	if (request->scan_plans[0].interval)
 		priv->scan_cfg.scan_interval =
 			request->scan_plans[0].interval * 1000;
+	priv->scan_cfg.repeat_count = request->scan_plans[0].iterations;
 	if (request->n_scan_plans >= 2) {
 		priv->scan_cfg.config_ees = MTRUE;
 		priv->scan_cfg.ees_mode =
 			MBIT(EES_MODE_HIGH) | MBIT(EES_MODE_MID);
+		/*High scan interval in milliseconds*/
 		priv->scan_cfg.high_period =
 			request->scan_plans[0].interval * 1000;
 		priv->scan_cfg.high_period_count =
 			request->scan_plans[0].iterations;
+		/*Mid scan interval in seconds*/
 		priv->scan_cfg.mid_period = request->scan_plans[1].interval;
-		if (request->scan_plans[1].iterations == 0)
-			priv->scan_cfg.mid_period_count = DEF_REPEAT_COUNT;
-		else
-			priv->scan_cfg.mid_period_count =
-				request->scan_plans[1].iterations;
+		priv->scan_cfg.mid_period_count =
+			request->scan_plans[1].iterations;
 		if (request->n_scan_plans == 3) {
 			priv->scan_cfg.ees_mode |= MBIT(EES_MODE_LOW);
+			/*low scan interval in seconds*/
 			priv->scan_cfg.low_period =
 				request->scan_plans[2].interval;
-			priv->scan_cfg.low_period_count = DEF_REPEAT_COUNT;
+			priv->scan_cfg.low_period_count =
+				request->scan_plans[2].iterations;
 		}
 	}
 #else
-	if (request->interval > MIN_BGSCAN_INTERVAL)
+	/* interval in miliseconds */
+	if (request->interval)
 		priv->scan_cfg.scan_interval = request->interval;
 #endif
-	priv->scan_cfg.repeat_count = DEF_REPEAT_COUNT;
 	priv->scan_cfg.report_condition =
 		BG_SCAN_SSID_MATCH | BG_SCAN_WAIT_ALL_CHAN_DONE;
 	priv->scan_cfg.bss_type = MLAN_BSS_MODE_INFRA;
@@ -5913,6 +6644,7 @@ int woal_cfg80211_sched_scan_start(struct wiphy *wiphy, struct net_device *dev,
 	       MAC2STR(priv->scan_cfg.random_mac));
 	if (MLAN_STATUS_SUCCESS ==
 	    woal_request_bgscan(priv, MOAL_IOCTL_WAIT, &priv->scan_cfg)) {
+		PRINTM(MMSG, "wlan: sched scan start\n");
 		priv->sched_scanning = MTRUE;
 		priv->bg_scan_start = MTRUE;
 		priv->bg_scan_reported = MFALSE;
@@ -5943,7 +6675,7 @@ int woal_cfg80211_sched_scan_stop(struct wiphy *wiphy, struct net_device *dev
 {
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	ENTER();
-	PRINTM(MIOCTL, "sched scan stop\n");
+	PRINTM(MMSG, "wlan: sched scan stop\n");
 	priv->sched_scanning = MFALSE;
 	woal_stop_bg_scan(priv, MOAL_NO_WAIT);
 	priv->bg_scan_start = MFALSE;
@@ -5987,16 +6719,12 @@ int woal_cfg80211_resume(struct wiphy *wiphy)
 					woal_inform_bss_from_scan_result(
 						handle->priv[i], NULL,
 						MOAL_IOCTL_WAIT);
-					cfg80211_sched_scan_results(
-						handle->priv[i]->wdev->wiphy
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
-						,
-						0
+#if KERNEL_VERSION(3, 2, 0) <= CFG80211_VERSION_CODE
+					woal_report_sched_scan_result(
+						handle->priv[i]);
 #endif
-					);
-					woal_bgscan_stop_event(handle->priv[i]);
 					handle->priv[i]->last_event = 0;
-					PRINTM(MIOCTL,
+					PRINTM(MCMND,
 					       "Report sched scan result in cfg80211 resume\n");
 				}
 				if (!moal_extflg_isset(handle, EXT_HW_TEST) &&
@@ -6004,7 +6732,7 @@ int woal_cfg80211_resume(struct wiphy *wiphy)
 					handle->priv[i]->roaming_required =
 						MTRUE;
 #ifdef ANDROID_KERNEL
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
 					__pm_wakeup_event(
 						&handle->ws,
 						ROAMING_WAKE_LOCK_TIMEOUT);
@@ -6015,15 +6743,21 @@ int woal_cfg80211_resume(struct wiphy *wiphy)
 							ROAMING_WAKE_LOCK_TIMEOUT));
 #endif
 #endif
+#ifdef REASSOCIATION
 					wake_up_interruptible(
 						&handle->reassoc_thread.wait_q);
+#endif
 				}
 			}
 		}
 	}
 
-	woal_get_wakeup_reason(priv, &wakeup_reason);
-
+	memset((t_u8 *)&wakeup_reason, 0, sizeof(wakeup_reason));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_wakeup_reason(priv, &wakeup_reason)) {
+		PRINTM(MERROR, "%s: get_wakeup_reason failed \n", __func__);
+		goto done;
+	}
 #ifdef STA_CFG80211
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 	if (IS_STA_CFG80211(priv->phandle->params.cfg80211_wext))
@@ -6080,6 +6814,8 @@ int woal_cfg80211_resume(struct wiphy *wiphy)
 
 done:
 	handle->cfg80211_suspend = MFALSE;
+	queue_work(handle->rx_workqueue, &handle->rx_work);
+
 	PRINTM(MCMND, "<--- Leave woal_cfg80211_resume --->\n");
 	return 0;
 }
@@ -6293,58 +7029,1570 @@ int woal_cfg80211_suspend(struct wiphy *wiphy, struct cfg80211_wowlan *wow)
 		filt_num++;
 	}
 
-	mef_entry->filter_num = filt_num;
+	mef_entry->filter_num = filt_num;
+
+	if (!mef_cfg.criteria)
+		mef_cfg.criteria = CRITERIA_BROADCAST | CRITERIA_UNICAST |
+				   CRITERIA_MULTICAST;
+
+	status = woal_set_get_wowlan_config(priv, MLAN_ACT_SET, MOAL_IOCTL_WAIT,
+					    &mef_cfg);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR, "woal_set_get_wowlan_config fail!\n");
+		ret = -EFAULT;
+		goto done;
+	}
+
+	memset(&hscfg, 0, sizeof(mlan_ds_hs_cfg));
+	status = woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
+					&hscfg);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR,
+		       "Fail to get HS parameter in woal_cfg80211_suspend: 0x%x 0x%x 0x%x\n",
+		       hscfg.conditions, hscfg.gap, hscfg.gpio);
+		ret = -EFAULT;
+		goto done;
+	}
+	hscfg.is_invoke_hostcmd = MFALSE;
+	if (wow->n_patterns || wow->magic_pkt)
+		hscfg.conditions = 0;
+	status = woal_set_get_hs_params(priv, MLAN_ACT_SET, MOAL_IOCTL_WAIT,
+					&hscfg);
+	if (status != MLAN_STATUS_SUCCESS) {
+		PRINTM(MERROR,
+		       "Fail to set HS parameter in woal_cfg80211_suspend: 0x%x 0x%x 0x%x\n",
+		       hscfg.conditions, hscfg.gap, hscfg.gpio);
+		ret = -EFAULT;
+		goto done;
+	}
+
+done:
+	PRINTM(MCMND, "<--- Leave woal_cfg80211_suspend --->\n");
+	return ret;
+}
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
+static void woal_cfg80211_set_wakeup(struct wiphy *wiphy, bool enabled)
+{
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+
+	device_set_wakeup_enable(handle->hotplug_device, enabled);
+}
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+/**
+ *  @brief TDLS operation ioctl handler
+ *
+ *  @param priv     A pointer to moal_private structure
+ *  @param peer     A pointer to peer mac
+ *  @apram action   action for TDLS
+ *  @return         0 --success, otherwise fail
+ */
+static int woal_tdls_oper(moal_private *priv, u8 *peer, t_u8 action)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_OPER;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_SET;
+	misc->param.tdls_oper.tdls_action = action;
+	moal_memcpy_ext(priv->phandle, misc->param.tdls_oper.peer_mac, peer,
+			ETH_ALEN, sizeof(misc->param.tdls_oper.peer_mac));
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief TDLS operation ioctl handler
+ *
+ *  @param priv         A pointer to moal_private structure
+ *  @param peer         A pointer to peer mac
+ *  @param tdls_ies     A pointer to mlan_ds_misc_tdls_ies structure
+ *  @param flags        TDLS ie flags
+ *
+ *  @return         0 --success, otherwise fail
+ */
+static int woal_tdls_get_ies(moal_private *priv, u8 *peer,
+			     mlan_ds_misc_tdls_ies *tdls_ies, t_u16 flags)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_GET_TDLS_IES;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_GET;
+	misc->param.tdls_ies.flags = flags;
+	moal_memcpy_ext(priv->phandle, misc->param.tdls_ies.peer_mac, peer,
+			ETH_ALEN, sizeof(misc->param.tdls_ies.peer_mac));
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (tdls_ies)
+		moal_memcpy_ext(priv->phandle, tdls_ies, &misc->param.tdls_ies,
+				sizeof(mlan_ds_misc_tdls_ies),
+				sizeof(mlan_ds_misc_tdls_ies));
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief append tdls ext_capability
+ *
+ * @param skb                   A pointer to sk_buff structure
+ *
+ * @return                      N/A
+ */
+static void woal_tdls_add_ext_capab(moal_private *priv, struct sk_buff *skb,
+				    mlan_ds_misc_tdls_ies *tdls_ies)
+{
+	u8 *pos = NULL;
+	if (tdls_ies->ext_cap[0] == WLAN_EID_EXT_CAPABILITY) {
+		pos = (void *)skb_put(skb, sizeof(IEEEtypes_ExtCap_t));
+		moal_memcpy_ext(priv->phandle, pos, tdls_ies->ext_cap,
+				sizeof(IEEEtypes_ExtCap_t),
+				sizeof(IEEEtypes_ExtCap_t));
+	} else {
+		PRINTM(MERROR, "Fail to append tdls ext_capability\n");
+	}
+}
+
+/**
+ * @brief append supported rates
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param skb                   A pointer to sk_buff structure
+ * @param band                  AP's band
+ *
+ * @return                      N/A
+ */
+static void woal_add_supported_rates_ie(moal_private *priv, struct sk_buff *skb,
+					enum ieee80211_band band)
+{
+	t_u8 basic_rates[] = {0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24};
+	t_u8 basic_rates_5G[] = {0x0c, 0x12, 0x18, 0x24,
+				 0x30, 0x48, 0x60, 0x6c};
+	t_u8 *pos;
+	t_u8 rate_num = 0;
+	if (band == IEEE80211_BAND_2GHZ)
+		rate_num = sizeof(basic_rates);
+	else
+		rate_num = sizeof(basic_rates_5G);
+
+	if (skb_tailroom(skb) < rate_num + 2)
+		return;
+
+	pos = skb_put(skb, rate_num + 2);
+	*pos++ = WLAN_EID_SUPP_RATES;
+	*pos++ = rate_num;
+	if (band == IEEE80211_BAND_2GHZ)
+		moal_memcpy_ext(priv->phandle, pos, basic_rates, rate_num,
+				rate_num);
+	else
+		moal_memcpy_ext(priv->phandle, pos, basic_rates_5G, rate_num,
+				rate_num);
+	return;
+}
+
+/**
+ * @brief append ext_supported rates
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param skb                   A pointer to sk_buff structure
+ * @param band                  AP's band
+ *
+ * @return                      N/A
+ */
+static void woal_add_ext_supported_rates_ie(moal_private *priv,
+					    struct sk_buff *skb,
+					    enum ieee80211_band band)
+{
+	t_u8 ext_rates[] = {0x0c, 0x12, 0x18, 0x60};
+	t_u8 *pos;
+	t_u8 rate_num = sizeof(ext_rates);
+
+	if (band != IEEE80211_BAND_2GHZ)
+		return;
+
+	if (skb_tailroom(skb) < rate_num + 2)
+		return;
+
+	pos = skb_put(skb, rate_num + 2);
+	*pos++ = WLAN_EID_EXT_SUPP_RATES;
+	*pos++ = rate_num;
+	moal_memcpy_ext(priv->phandle, pos, ext_rates, rate_num, rate_num);
+	return;
+}
+
+/**
+ * @brief append wmm ie
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param skb                   A pointer to sk_buff structure
+ * @param wmm_type         WMM_TYPE_INFO/WMM_TYPE_PARAMETER
+ * @param pQosInfo           A pointer to qos info
+ *
+ * @return                      N/A
+ */
+static void woal_add_wmm_ie(moal_private *priv, struct sk_buff *skb,
+			    t_u8 wmm_type, t_u8 *pQosInfo)
+{
+	t_u8 wmmInfoElement[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01};
+	t_u8 wmmParamElement[] = {0x00, 0x50, 0xf2, 0x02, 0x01, 0x01};
+	t_u8 ac_vi[] = {0x42, 0x43, 0x5e, 0x00};
+	t_u8 ac_vo[] = {0x62, 0x32, 0x2f, 0x00};
+	t_u8 ac_be[] = {0x03, 0xa4, 0x00, 0x00};
+	t_u8 ac_bk[] = {0x27, 0xa4, 0x00, 0x00};
+	t_u8 qosInfo = 0x0;
+	t_u8 reserved = 0;
+	t_u8 wmm_id = 221;
+	t_u8 wmmParamIe_len = 25;
+	t_u8 wmmInfoIe_len = 7;
+	t_u8 len = 0;
+	t_u8 *pos;
+
+	qosInfo = (pQosInfo == NULL) ? 0xf : (*pQosInfo);
+	/*wmm parameter*/
+	if (wmm_type == WMM_TYPE_PARAMETER) {
+		if (skb_tailroom(skb) < (wmmParamIe_len + 2))
+			return;
+		pos = skb_put(skb, wmmParamIe_len + 2);
+		len = wmmParamIe_len;
+	} else {
+		if (skb_tailroom(skb) < (wmmInfoIe_len + 2))
+			return;
+		pos = skb_put(skb, wmmInfoIe_len + 2);
+		len = wmmInfoIe_len;
+	}
+
+	*pos++ = wmm_id;
+	*pos++ = len;
+	/*wmm parameter*/
+	if (wmm_type == WMM_TYPE_PARAMETER) {
+		moal_memcpy_ext(priv->phandle, pos, wmmParamElement,
+				sizeof(wmmParamElement),
+				sizeof(wmmParamElement));
+		pos += sizeof(wmmParamElement);
+	} else {
+		moal_memcpy_ext(priv->phandle, pos, wmmInfoElement,
+				sizeof(wmmInfoElement), sizeof(wmmInfoElement));
+		pos += sizeof(wmmInfoElement);
+	}
+	*pos++ = qosInfo;
+	/*wmm parameter*/
+	if (wmm_type == WMM_TYPE_PARAMETER) {
+		*pos++ = reserved;
+		moal_memcpy_ext(priv->phandle, pos, ac_be, sizeof(ac_be),
+				sizeof(ac_be));
+		pos += sizeof(ac_be);
+		moal_memcpy_ext(priv->phandle, pos, ac_bk, sizeof(ac_bk),
+				sizeof(ac_bk));
+		pos += sizeof(ac_bk);
+		moal_memcpy_ext(priv->phandle, pos, ac_vi, sizeof(ac_vi),
+				sizeof(ac_vi));
+		pos += sizeof(ac_vi);
+		moal_memcpy_ext(priv->phandle, pos, ac_vo, sizeof(ac_vo),
+				sizeof(ac_vo));
+	}
+	return;
+}
+
+/**
+ * @brief update tdls peer status
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param peer_addr             A point to peer mac address
+ * @param link_status           link status
+ *
+ * @return                      N/A
+ */
+static t_void woal_updata_peer_status(moal_private *priv, t_u8 *peer_addr,
+				      tdlsStatus_e link_status)
+{
+	struct tdls_peer *peer = NULL;
+	unsigned long flags;
+	if (priv && priv->enable_auto_tdls) {
+		spin_lock_irqsave(&priv->tdls_lock, flags);
+		list_for_each_entry (peer, &priv->tdls_list, link) {
+			if (!memcmp(peer->peer_addr, peer_addr, ETH_ALEN)) {
+				if ((link_status == TDLS_NOT_SETUP) &&
+				    (peer->link_status ==
+				     TDLS_SETUP_INPROGRESS))
+					peer->num_failure++;
+				else if (link_status == TDLS_SETUP_COMPLETE)
+					peer->num_failure = 0;
+				peer->link_status = link_status;
+				break;
+			}
+		}
+		spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	}
+}
+
+/**
+ * @brief add tdls peer
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param peer                  A point to peer address
+ *
+ * @return                      N/A
+ */
+static t_void woal_add_tdls_peer(moal_private *priv, t_u8 *peer)
+{
+	struct tdls_peer *tdls_peer = NULL;
+	unsigned long flags;
+	t_u8 find_peer = MFALSE;
+	if (priv && priv->enable_auto_tdls) {
+		spin_lock_irqsave(&priv->tdls_lock, flags);
+		list_for_each_entry (tdls_peer, &priv->tdls_list, link) {
+			if (!memcmp(tdls_peer->peer_addr, peer, ETH_ALEN)) {
+				tdls_peer->link_status = TDLS_SETUP_INPROGRESS;
+				tdls_peer->rssi_jiffies = jiffies;
+				find_peer = MTRUE;
+				break;
+			}
+		}
+		if (!find_peer) {
+			/* create new TDLS peer */
+			tdls_peer =
+				kzalloc(sizeof(struct tdls_peer), GFP_ATOMIC);
+			if (tdls_peer) {
+				moal_memcpy_ext(priv->phandle,
+						tdls_peer->peer_addr, peer,
+						ETH_ALEN,
+						sizeof(tdls_peer->peer_addr));
+				tdls_peer->link_status = TDLS_SETUP_INPROGRESS;
+				tdls_peer->rssi_jiffies = jiffies;
+				INIT_LIST_HEAD(&tdls_peer->link);
+				list_add_tail(&tdls_peer->link,
+					      &priv->tdls_list);
+				PRINTM(MCMND,
+				       "Add to TDLS list: peer=" MACSTR "\n",
+				       MAC2STR(peer));
+			}
+		}
+		spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	}
+}
+
+/**
+ * @brief check auto tdls
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ *
+ * @return                      N/A
+ */
+void woal_check_auto_tdls(struct wiphy *wiphy, struct net_device *dev)
+{
+	t_u8 bcast_addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	struct tdls_peer *tdls_peer = NULL;
+	unsigned long flags;
+	t_u8 tdls_discovery = MFALSE;
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+
+	ENTER();
+	if (priv && priv->enable_auto_tdls) {
+		priv->tdls_check_tx = MFALSE;
+		spin_lock_irqsave(&priv->tdls_lock, flags);
+		list_for_each_entry (tdls_peer, &priv->tdls_list, link) {
+			if ((jiffies - tdls_peer->rssi_jiffies) >
+			    TDLS_IDLE_TIME) {
+				tdls_peer->rssi = 0;
+				if (tdls_peer->num_failure <
+				    TDLS_MAX_FAILURE_COUNT)
+					tdls_discovery = MTRUE;
+			}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+			if (tdls_peer->rssi &&
+			    (tdls_peer->rssi >= TDLS_RSSI_LOW_THRESHOLD)) {
+				if (tdls_peer->link_status ==
+				    TDLS_SETUP_COMPLETE) {
+					tdls_peer->link_status = TDLS_TEAR_DOWN;
+					PRINTM(MMSG,
+					       "Wlan: Tear down TDLS link, peer=" MACSTR
+					       " rssi=%d\n",
+					       MAC2STR(tdls_peer->peer_addr),
+					       -tdls_peer->rssi);
+					cfg80211_tdls_oper_request(
+						dev, tdls_peer->peer_addr,
+						NL80211_TDLS_TEARDOWN,
+						TDLS_TEARN_DOWN_REASON_UNSPECIFIC,
+						GFP_ATOMIC);
+				}
+			} else if (tdls_peer->rssi &&
+				   (tdls_peer->rssi <=
+				    TDLS_RSSI_HIGH_THRESHOLD)) {
+				if ((tdls_peer->link_status ==
+				     TDLS_NOT_SETUP) &&
+				    (tdls_peer->num_failure <
+				     TDLS_MAX_FAILURE_COUNT)) {
+					priv->tdls_check_tx = MTRUE;
+					PRINTM(MCMND,
+					       "Wlan: Find TDLS peer=" MACSTR
+					       " rssi=%d\n",
+					       MAC2STR(tdls_peer->peer_addr),
+					       -tdls_peer->rssi);
+				}
+			}
+#endif
+		}
+		spin_unlock_irqrestore(&priv->tdls_lock, flags);
+	}
+	if (tdls_discovery)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+		woal_cfg80211_tdls_mgmt(wiphy, dev, bcast_addr,
+					TDLS_DISCOVERY_REQUEST, 1, 0, 0, 0,
+					NULL, 0);
+#else
+		woal_cfg80211_tdls_mgmt(wiphy, dev, bcast_addr,
+					TDLS_DISCOVERY_REQUEST, 1, 0, 0, NULL,
+					0);
+#endif
+#else
+		woal_cfg80211_tdls_mgmt(wiphy, dev, bcast_addr,
+					TDLS_DISCOVERY_REQUEST, 1, 0, NULL, 0);
+#endif
+	LEAVE();
+}
+
+/**
+ * @brief woal construct tdls data frame
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param skb                   skb buffer
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+static int woal_construct_tdls_data_frame(moal_private *priv, t_u8 *peer,
+					  t_u8 action_code, t_u8 dialog_token,
+					  t_u16 status_code,
+					  struct sk_buff *skb)
+{
+	struct ieee80211_tdls_data *tdata;
+	t_u16 capability;
+	IEEEtypes_HTCap_t *HTcap;
+	IEEEtypes_HTInfo_t *HTInfo;
+	IEEEtypes_2040BSSCo_t *BSSCo;
+	IEEEtypes_VHTCap_t *VHTcap;
+	IEEEtypes_VHTOprat_t *vht_oprat;
+	IEEEtypes_AID_t *AidInfo;
+	IEEEtypes_Header_t *ieee_hdr;
+	t_u8 *skb_data;
+	t_u8 len = 0;
+	IEEEtypes_Generic_t *pSupp_chan = NULL, *pRegulatory_class = NULL;
+	mlan_ds_misc_tdls_ies *tdls_ies = NULL;
+	int ret = 0;
+	mlan_bss_info bss_info;
+	enum ieee80211_band band;
+	mlan_fw_info fw_info;
+	t_u16 setup_flag = 0;
+	t_u16 confirm_flag = 0;
+
+	ENTER();
+
+	memset(&bss_info, 0, sizeof(bss_info));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		PRINTM(MERROR, "Fail to get bss info\n");
+		LEAVE();
+		return -EFAULT;
+	}
+	band = woal_band_cfg_to_ieee_band(bss_info.bss_band);
+	tdls_ies = kzalloc(sizeof(mlan_ds_misc_tdls_ies), GFP_KERNEL);
+	if (!tdls_ies) {
+		PRINTM(MERROR, "Fail to alloc memory for tdls_ies\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	capability = 0x2421;
+
+	memset(&fw_info, 0, sizeof(mlan_fw_info));
+	tdata = (void *)skb_put(skb, offsetof(struct ieee80211_tdls_data, u));
+	moal_memcpy_ext(priv->phandle, tdata->da, peer, ETH_ALEN,
+			sizeof(tdata->da));
+	moal_memcpy_ext(priv->phandle, tdata->sa, priv->current_addr, ETH_ALEN,
+			sizeof(tdata->sa));
+	tdata->ether_type = cpu_to_be16(MLAN_ETHER_PKT_TYPE_TDLS_ACTION);
+	tdata->payload_type = WLAN_TDLS_SNAP_RFTYPE;
+	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
+
+	setup_flag = TDLS_IE_FLAGS_EXTCAP | TDLS_IE_FLAGS_HTCAP |
+		     TDLS_IE_FLAGS_SUPP_CS_IE;
+	confirm_flag = TDLS_IE_FLAGS_EXTCAP | TDLS_IE_FLAGS_HTINFO |
+		       TDLS_IE_FLAGS_QOS_INFO;
+	if (fw_info.fw_bands & BAND_AAC) {
+		setup_flag |= (TDLS_IE_FLAGS_VHTCAP | TDLS_IE_FLAGS_AID);
+		confirm_flag |= TDLS_IE_FLAGS_VHTOPRAT;
+	}
+	if (fw_info.fw_bands & BAND_AAX) {
+		setup_flag |= (TDLS_IE_FLAGS_VHTCAP | TDLS_IE_FLAGS_AID |
+			       TDLS_IE_FLAGS_HECAP);
+		confirm_flag |= (TDLS_IE_FLAGS_VHTOPRAT | TDLS_IE_FLAGS_HEOP);
+	}
+	if (fw_info.fw_bands & BAND_GAX) {
+		setup_flag |= TDLS_IE_FLAGS_HECAP;
+		confirm_flag |= TDLS_IE_FLAGS_HEOP;
+	}
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+		setup_flag |= TDLS_IE_FLAGS_SETUP;
+		if (woal_tdls_get_ies(priv, peer, tdls_ies, setup_flag)) {
+			PRINTM(MERROR, "%s: woal_tdls_get_ies failed \n",
+			       __func__);
+			ret = -EFAULT;
+			goto done;
+		}
+		tdata->category = WLAN_CATEGORY_TDLS;
+		tdata->action_code = WLAN_TDLS_SETUP_REQUEST;
+		skb_put(skb, sizeof(tdata->u.setup_req));
+		tdata->u.setup_req.dialog_token = dialog_token;
+		tdata->u.setup_req.capability = cpu_to_le16(capability);
+		woal_add_supported_rates_ie(priv, skb, band);
+		woal_add_ext_supported_rates_ie(priv, skb, band);
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+		if (woal_tdls_get_ies(priv, peer, tdls_ies, setup_flag)) {
+			PRINTM(MERROR, "%s: woal_tdls_get_ies failed \n",
+			       __func__);
+			ret = -EFAULT;
+			goto done;
+		}
+		tdata->category = WLAN_CATEGORY_TDLS;
+		tdata->action_code = WLAN_TDLS_SETUP_RESPONSE;
+
+		skb_put(skb, sizeof(tdata->u.setup_resp));
+		tdata->u.setup_resp.status_code = cpu_to_le16(status_code);
+		tdata->u.setup_resp.dialog_token = dialog_token;
+		tdata->u.setup_resp.capability = cpu_to_le16(capability);
+
+		woal_add_supported_rates_ie(priv, skb, band);
+		woal_add_ext_supported_rates_ie(priv, skb, band);
+		break;
+	case WLAN_TDLS_SETUP_CONFIRM:
+		if (woal_tdls_get_ies(priv, peer, tdls_ies, confirm_flag)) {
+			PRINTM(MERROR, "%s: woal_tdls_get_ies failed \n",
+			       __func__);
+			ret = -EFAULT;
+			goto done;
+		}
+		tdata->category = WLAN_CATEGORY_TDLS;
+		tdata->action_code = WLAN_TDLS_SETUP_CONFIRM;
+
+		skb_put(skb, sizeof(tdata->u.setup_cfm));
+		tdata->u.setup_cfm.status_code = cpu_to_le16(status_code);
+		tdata->u.setup_cfm.dialog_token = dialog_token;
+
+		break;
+	case WLAN_TDLS_TEARDOWN:
+		tdata->category = WLAN_CATEGORY_TDLS;
+		tdata->action_code = WLAN_TDLS_TEARDOWN;
+
+		skb_put(skb, sizeof(tdata->u.teardown));
+		tdata->u.teardown.reason_code = cpu_to_le16(status_code);
+		break;
+	case WLAN_TDLS_DISCOVERY_REQUEST:
+		tdata->category = WLAN_CATEGORY_TDLS;
+		tdata->action_code = WLAN_TDLS_DISCOVERY_REQUEST;
+
+		skb_put(skb, sizeof(tdata->u.discover_req));
+		tdata->u.discover_req.dialog_token = dialog_token;
+		break;
+	default:
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (action_code == WLAN_TDLS_SETUP_REQUEST ||
+	    action_code == WLAN_TDLS_SETUP_RESPONSE) {
+		/* supported chanel ie*/
+		if (tdls_ies->supp_chan[0] == SUPPORTED_CHANNELS) {
+			pSupp_chan = (void *)skb_put(
+				skb, sizeof(IEEEtypes_Header_t) +
+					     tdls_ies->supp_chan[1]);
+			memset(pSupp_chan, 0,
+			       sizeof(IEEEtypes_Header_t) +
+				       tdls_ies->supp_chan[1]);
+			moal_memcpy_ext(priv->phandle, pSupp_chan,
+					tdls_ies->supp_chan,
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->supp_chan[1],
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->supp_chan[1]);
+		}
+		/* supported regulatory class ie*/
+		if (tdls_ies->regulatory_class[0] == REGULATORY_CLASS) {
+			pRegulatory_class = (void *)skb_put(
+				skb, sizeof(IEEEtypes_Header_t) +
+					     tdls_ies->regulatory_class[1]);
+			memset(pRegulatory_class, 0,
+			       sizeof(IEEEtypes_Header_t) +
+				       tdls_ies->regulatory_class[1]);
+			moal_memcpy_ext(priv->phandle, pRegulatory_class,
+					tdls_ies->regulatory_class,
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->regulatory_class[1],
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->regulatory_class[1]);
+		}
+		woal_tdls_add_ext_capab(priv, skb, tdls_ies);
+	}
+
+	/* TODO we should fill in ht_cap and htinfo with correct value */
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_RESPONSE:
+		/*HT capability*/
+		if (tdls_ies->ht_cap[0] == HT_CAPABILITY) {
+			HTcap = (void *)skb_put(skb, sizeof(IEEEtypes_HTCap_t));
+			memset(HTcap, 0, sizeof(IEEEtypes_HTCap_t));
+			moal_memcpy_ext(priv->phandle, HTcap, tdls_ies->ht_cap,
+					sizeof(IEEEtypes_HTCap_t),
+					sizeof(IEEEtypes_HTCap_t));
+		} else {
+			PRINTM(MIOCTL, "No TDLS HT capability\n");
+		}
+
+		/*20_40_bss_coexist*/
+		BSSCo = (void *)skb_put(skb, sizeof(IEEEtypes_2040BSSCo_t));
+		memset(BSSCo, 0, sizeof(IEEEtypes_2040BSSCo_t));
+		BSSCo->ieee_hdr.element_id = BSSCO_2040;
+		BSSCo->ieee_hdr.len = sizeof(IEEEtypes_2040BSSCo_t) -
+				      sizeof(IEEEtypes_Header_t);
+		BSSCo->bss_co_2040.bss_co_2040_value = 0x01;
+
+		/* VHT capability */
+		if (tdls_ies->vht_cap[0] == VHT_CAPABILITY) {
+			VHTcap = (void *)skb_put(skb,
+						 sizeof(IEEEtypes_VHTCap_t));
+			memset(VHTcap, 0, sizeof(IEEEtypes_VHTCap_t));
+			moal_memcpy_ext(priv->phandle, VHTcap,
+					tdls_ies->vht_cap,
+					sizeof(IEEEtypes_VHTCap_t),
+					sizeof(IEEEtypes_VHTCap_t));
+		} else {
+			PRINTM(MIOCTL, "NO TDLS VHT capability\n");
+		}
+		/* AID info */
+		if (tdls_ies->aid_info[0] == AID_INFO) {
+			AidInfo = (void *)skb_put(skb, sizeof(IEEEtypes_AID_t));
+			memset(AidInfo, 0, sizeof(IEEEtypes_AID_t));
+			moal_memcpy_ext(priv->phandle, AidInfo,
+					tdls_ies->aid_info,
+					sizeof(IEEEtypes_AID_t),
+					sizeof(IEEEtypes_AID_t));
+		} else {
+			PRINTM(MIOCTL, "No TDLS AID info\n");
+		}
+		/* HE capability */
+		if (tdls_ies->he_cap[2] == HE_CAPABILITY) {
+			ieee_hdr = (IEEEtypes_Header_t *)tdls_ies->he_cap;
+			len = sizeof(IEEEtypes_Header_t) + ieee_hdr->len;
+			skb_data = (void *)skb_put(skb, len);
+			memset(skb_data, 0, len);
+			moal_memcpy_ext(priv->phandle, skb_data,
+					tdls_ies->he_cap, len, len);
+		} else {
+			PRINTM(MIOCTL, "NO TDLS HE Capability IE\n");
+		}
+		break;
+	case WLAN_TDLS_SETUP_CONFIRM:
+		/*HT information*/
+		if (tdls_ies->ht_info[0] == HT_OPERATION) {
+			HTInfo = (void *)skb_put(skb,
+						 sizeof(IEEEtypes_HTInfo_t));
+			memset(HTInfo, 0, sizeof(IEEEtypes_HTInfo_t));
+			moal_memcpy_ext(priv->phandle, HTInfo,
+					tdls_ies->ht_info,
+					sizeof(IEEEtypes_HTInfo_t),
+					sizeof(IEEEtypes_HTInfo_t));
+		} else
+			PRINTM(MIOCTL, "No TDLS HT information\n");
+		/** VHT operation */
+		if (tdls_ies->vht_oprat[0] == VHT_OPERATION) {
+			vht_oprat = (void *)skb_put(
+				skb, sizeof(IEEEtypes_VHTOprat_t));
+			memset(vht_oprat, 0, sizeof(IEEEtypes_VHTOprat_t));
+			moal_memcpy_ext(priv->phandle, vht_oprat,
+					tdls_ies->vht_oprat,
+					sizeof(IEEEtypes_VHTOprat_t),
+					sizeof(IEEEtypes_VHTOprat_t));
+		} else
+			PRINTM(MIOCTL, "NO TDLS VHT Operation IE\n");
+		/** HE operation */
+		if (tdls_ies->he_op[2] == HE_OPERATION) {
+			ieee_hdr = (IEEEtypes_Header_t *)tdls_ies->he_op;
+			len = sizeof(IEEEtypes_Header_t) + ieee_hdr->len;
+			skb_data = (void *)skb_put(skb, len);
+			memset(skb_data, 0, len);
+			moal_memcpy_ext(priv->phandle, skb_data,
+					tdls_ies->he_op, len, len);
+		} else
+			PRINTM(MIOCTL, "NO TDLS HE Operation IE\n");
+		break;
+	default:
+		break;
+	}
+
+	if (action_code == WLAN_TDLS_SETUP_REQUEST ||
+	    action_code == WLAN_TDLS_SETUP_RESPONSE) {
+		/*wmm info*/
+		woal_add_wmm_ie(priv, skb, WMM_TYPE_INFO, NULL);
+	} else if (action_code == WLAN_TDLS_SETUP_CONFIRM) {
+		/*wmm parameter*/
+		woal_add_wmm_ie(priv, skb, WMM_TYPE_PARAMETER,
+				&tdls_ies->QosInfo);
+	}
+
+done:
+	kfree(tdls_ies);
+	return ret;
+}
+
+/**
+ * @brief woal construct tdls action frame
+ *
+ * @param priv                  A pointer to moal_private structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param skb                   skb buffer
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+static int woal_construct_tdls_action_frame(moal_private *priv, t_u8 *peer,
+					    t_u8 action_code, t_u8 dialog_token,
+					    t_u16 status_code,
+					    struct sk_buff *skb)
+{
+	struct ieee80211_mgmt *mgmt;
+	t_u8 addr[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
+	t_u16 capability;
+	t_u8 *pos = NULL;
+	mlan_ds_misc_tdls_ies *tdls_ies = NULL;
+	mlan_bss_info bss_info;
+	enum ieee80211_band band;
+	IEEEtypes_Generic_t *pSupp_chan = NULL, *pRegulatory_class = NULL;
+
+	int ret = 0;
+
+	ENTER();
+
+	memset(&bss_info, 0, sizeof(bss_info));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		PRINTM(MERROR, "Fail to get bss info\n");
+		LEAVE();
+		return -EFAULT;
+	}
+	band = woal_band_cfg_to_ieee_band(bss_info.bss_band);
+
+	tdls_ies = kzalloc(sizeof(mlan_ds_misc_tdls_ies), GFP_KERNEL);
+	if (!tdls_ies) {
+		PRINTM(MERROR, "Fail to alloc memory for tdls_ies\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	mgmt = (void *)skb_put(skb, 24);
+	memset(mgmt, 0, 24);
+	moal_memcpy_ext(priv->phandle, mgmt->da, peer, ETH_ALEN,
+			sizeof(mgmt->da));
+	moal_memcpy_ext(priv->phandle, mgmt->sa, priv->current_addr, ETH_ALEN,
+			sizeof(mgmt->sa));
+	moal_memcpy_ext(priv->phandle, mgmt->bssid, priv->cfg_bssid, ETH_ALEN,
+			sizeof(mgmt->bssid));
+
+	mgmt->frame_control =
+		cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_ACTION);
+	/* add address 4*/
+	pos = skb_put(skb, ETH_ALEN);
+
+	capability = 0x2421;
+
+	switch (action_code) {
+	case WLAN_PUB_ACTION_TDLS_DISCOVER_RES:
+		if (woal_tdls_get_ies(priv, peer, tdls_ies,
+				      TDLS_IE_FLAGS_EXTCAP |
+					      TDLS_IE_FLAGS_SUPP_CS_IE)) {
+			PRINTM(MERROR, "%s: woal_tdls_get_ies failed \n",
+			       __func__);
+			if (tdls_ies)
+				kfree(tdls_ies);
+			LEAVE();
+			return -EFAULT;
+		}
+		skb_put(skb, 1 + sizeof(mgmt->u.action.u.tdls_discover_resp));
+		mgmt->u.action.category = WLAN_CATEGORY_PUBLIC;
+		mgmt->u.action.u.tdls_discover_resp.action_code =
+			WLAN_PUB_ACTION_TDLS_DISCOVER_RES;
+		mgmt->u.action.u.tdls_discover_resp.dialog_token = dialog_token;
+		mgmt->u.action.u.tdls_discover_resp.capability =
+			cpu_to_le16(capability);
+		/* move back for addr4 */
+		memmove(pos + ETH_ALEN, &mgmt->u.action,
+			1 + sizeof(mgmt->u.action.u.tdls_discover_resp));
+		/** init address 4 */
+		moal_memcpy_ext(priv->phandle, pos, addr, ETH_ALEN, ETH_ALEN);
+
+		woal_add_supported_rates_ie(priv, skb, band);
+		woal_add_ext_supported_rates_ie(priv, skb, band);
+		woal_tdls_add_ext_capab(priv, skb, tdls_ies);
+		/* supported chanel ie*/
+		if (tdls_ies->supp_chan[0] == SUPPORTED_CHANNELS) {
+			pSupp_chan = (void *)skb_put(
+				skb, sizeof(IEEEtypes_Header_t) +
+					     tdls_ies->supp_chan[1]);
+			memset(pSupp_chan, 0,
+			       sizeof(IEEEtypes_Header_t) +
+				       tdls_ies->supp_chan[1]);
+			moal_memcpy_ext(priv->phandle, pSupp_chan,
+					tdls_ies->supp_chan,
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->supp_chan[1],
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->supp_chan[1]);
+		}
+		/* supported regulatory class ie*/
+		if (tdls_ies->regulatory_class[0] == REGULATORY_CLASS) {
+			pRegulatory_class = (void *)skb_put(
+				skb, sizeof(IEEEtypes_Header_t) +
+					     tdls_ies->regulatory_class[1]);
+			memset(pRegulatory_class, 0,
+			       sizeof(IEEEtypes_Header_t) +
+				       tdls_ies->regulatory_class[1]);
+			moal_memcpy_ext(priv->phandle, pRegulatory_class,
+					tdls_ies->regulatory_class,
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->regulatory_class[1],
+					sizeof(IEEEtypes_Header_t) +
+						tdls_ies->regulatory_class[1]);
+		}
+
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	if (tdls_ies)
+		kfree(tdls_ies);
+	return ret;
+}
+
+/**
+ * @brief woal add tdls link identifier ie
+ *
+ * @param skb                   skb buffer
+ * @param src_addr              source address
+ * @param peer                  peer address
+ * @param bssid                 AP's bssid
+ *
+ * @return                      NA
+ */
+static void woal_tdls_add_link_ie(moal_private *priv, struct sk_buff *skb,
+				  u8 *src_addr, u8 *peer, u8 *bssid)
+{
+	struct ieee80211_tdls_lnkie *lnkid;
+
+	lnkid = (void *)skb_put(skb, sizeof(struct ieee80211_tdls_lnkie));
+
+	lnkid->ie_type = WLAN_EID_LINK_ID;
+	lnkid->ie_len = sizeof(struct ieee80211_tdls_lnkie) - 2;
+
+	moal_memcpy_ext(priv->phandle, lnkid->bssid, bssid, ETH_ALEN,
+			sizeof(lnkid->bssid));
+	moal_memcpy_ext(priv->phandle, lnkid->init_sta, src_addr, ETH_ALEN,
+			sizeof(lnkid->init_sta));
+	moal_memcpy_ext(priv->phandle, lnkid->resp_sta, peer, ETH_ALEN,
+			sizeof(lnkid->resp_sta));
+}
+
+/**
+ * @brief woal send tdls action frame
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param extra_ies              A pointer to extra ie buffer
+ * @param extra_ies_len          etra ie len
+ * @param skb                   skb buffer
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+static int woal_send_tdls_action_frame(struct wiphy *wiphy,
+				       struct net_device *dev, t_u8 *peer,
+				       u8 action_code, t_u8 dialog_token,
+				       t_u16 status_code, const t_u8 *extra_ies,
+				       size_t extra_ies_len)
+{
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	pmlan_buffer pmbuf = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	struct sk_buff *skb = NULL;
+	t_u8 *pos;
+	t_u32 pkt_type;
+	t_u32 tx_control;
+	t_u16 pkt_len;
+	t_u16 packet_len;
+	int ret = 0;
+
+	ENTER();
+
+#define HEADER_SIZE 8 /* pkt_type + tx_control */
+
+	pmbuf = woal_alloc_mlan_buffer(
+		priv->phandle,
+		MLAN_MIN_DATA_HEADER_LEN + HEADER_SIZE + sizeof(pkt_len) +
+			max(sizeof(struct ieee80211_mgmt),
+			    sizeof(struct ieee80211_tdls_data)) +
+			50 + /* supported rates */
+			sizeof(IEEEtypes_ExtCap_t) + /* ext capab */
+			extra_ies_len + sizeof(IEEEtypes_tdls_linkie));
+	if (!pmbuf) {
+		PRINTM(MERROR, "Fail to allocate mlan_buffer\n");
+		ret = -ENOMEM;
+		goto done;
+	}
+
+	skb = (struct sk_buff *)pmbuf->pdesc;
+
+	skb_put(skb, MLAN_MIN_DATA_HEADER_LEN);
+
+	pos = skb_put(skb, HEADER_SIZE + sizeof(pkt_len));
+	pkt_type = MRVL_PKT_TYPE_MGMT_FRAME;
+	tx_control = 0;
+	memset(pos, 0, HEADER_SIZE + sizeof(pkt_len));
+	moal_memcpy_ext(priv->phandle, pos, &pkt_type, sizeof(pkt_type),
+			sizeof(pkt_type));
+	moal_memcpy_ext(priv->phandle, pos + sizeof(pkt_type), &tx_control,
+			sizeof(tx_control), sizeof(tx_control));
+
+	woal_construct_tdls_action_frame(priv, peer, action_code, dialog_token,
+					 status_code, skb);
+
+	if (extra_ies_len)
+		moal_memcpy_ext(priv->phandle, skb_put(skb, extra_ies_len),
+				extra_ies, extra_ies_len, extra_ies_len);
+
+	/* the TDLS link IE is always added last */
+	/* we are the responder */
+	woal_tdls_add_link_ie(priv, skb, peer, priv->current_addr,
+			      priv->cfg_bssid);
+
+	/*
+	 * According to 802.11z: Setup req/resp are sent in AC_BK, otherwise
+	 * we should default to AC_VI.
+	 */
+	skb_set_queue_mapping(skb, WMM_AC_VI);
+	skb->priority = 5;
+
+	pmbuf->data_offset = MLAN_MIN_DATA_HEADER_LEN;
+	pmbuf->data_len = skb->len - pmbuf->data_offset;
+	pmbuf->priority = skb->priority;
+	pmbuf->buf_type = MLAN_BUF_TYPE_RAW_DATA;
+	pmbuf->bss_index = priv->bss_index;
+
+	pkt_len = pmbuf->data_len - HEADER_SIZE - sizeof(pkt_len);
+	packet_len = woal_cpu_to_le16(pkt_len);
+	moal_memcpy_ext(priv->phandle,
+			pmbuf->pbuf + pmbuf->data_offset + HEADER_SIZE,
+			&packet_len, sizeof(packet_len), sizeof(packet_len));
+
+	DBG_HEXDUMP(MDAT_D, "TDLS action:", pmbuf->pbuf + pmbuf->data_offset,
+		    pmbuf->data_len);
+
+	status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
+
+	switch (status) {
+	case MLAN_STATUS_PENDING:
+		atomic_inc(&priv->phandle->tx_pending);
+		queue_work(priv->phandle->workqueue, &priv->phandle->main_work);
+		break;
+	case MLAN_STATUS_SUCCESS:
+		woal_free_mlan_buffer(priv->phandle, pmbuf);
+		break;
+	case MLAN_STATUS_FAILURE:
+	default:
+		woal_free_mlan_buffer(priv->phandle, pmbuf);
+		ret = -EFAULT;
+		break;
+	}
+
+done:
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief woal send tdls data frame
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param extra_ies              A pointer to extra ie buffer
+ * @param extra_ies_len          etra ie len
+ * @param skb                   skb buffer
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+static int woal_send_tdls_data_frame(struct wiphy *wiphy,
+				     struct net_device *dev, t_u8 *peer,
+				     u8 action_code, t_u8 dialog_token,
+				     t_u16 status_code, const t_u8 *extra_ies,
+				     size_t extra_ies_len)
+{
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	pmlan_buffer pmbuf = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	struct sk_buff *skb = NULL;
+	int ret = 0;
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	t_u32 index = 0;
+#endif
+
+	ENTER();
+
+	skb = dev_alloc_skb(
+		priv->extra_tx_head_len + MLAN_MIN_DATA_HEADER_LEN +
+		sizeof(mlan_buffer) +
+		max(sizeof(struct ieee80211_mgmt),
+		    sizeof(struct ieee80211_tdls_data)) +
+		50 + /* supported rates */
+		sizeof(IEEEtypes_ExtCap_t) + /* ext capab */
+		3 + /* Qos Info */
+		sizeof(IEEEtypes_WmmParameter_t) + /*wmm ie*/
+		sizeof(IEEEtypes_HTCap_t) + sizeof(IEEEtypes_2040BSSCo_t) +
+		sizeof(IEEEtypes_HTInfo_t) + sizeof(IEEEtypes_VHTCap_t) +
+		sizeof(IEEEtypes_VHTOprat_t) + sizeof(IEEEtypes_AID_t) +
+		sizeof(IEEEtypes_HECap_t) + sizeof(IEEEtypes_HeOp_t) +
+		extra_ies_len + sizeof(IEEEtypes_tdls_linkie));
+	if (!skb)
+		return -ENOMEM;
+
+	skb_reserve(skb, MLAN_MIN_DATA_HEADER_LEN + sizeof(mlan_buffer) +
+				 priv->extra_tx_head_len);
+
+	woal_construct_tdls_data_frame(priv, peer, action_code, dialog_token,
+				       status_code, skb);
+
+	if (extra_ies_len)
+		moal_memcpy_ext(priv->phandle, skb_put(skb, extra_ies_len),
+				extra_ies, extra_ies_len, extra_ies_len);
+
+	/* the TDLS link IE is always added last */
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_CONFIRM:
+	case WLAN_TDLS_TEARDOWN:
+	case WLAN_TDLS_DISCOVERY_REQUEST:
+		/* we are the initiator */
+		woal_tdls_add_link_ie(priv, skb, priv->current_addr, peer,
+				      priv->cfg_bssid);
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+		/* we are the responder */
+		woal_tdls_add_link_ie(priv, skb, peer, priv->current_addr,
+				      priv->cfg_bssid);
+		break;
+	default:
+		ret = -ENOTSUPP;
+		goto fail;
+	}
+
+	/*
+	 * According to 802.11z: Setup req/resp are sent in AC_BK, otherwise
+	 * we should default to AC_VI.
+	 */
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+	case WLAN_TDLS_SETUP_RESPONSE:
+		skb_set_queue_mapping(skb, WMM_AC_BK);
+		skb->priority = 2;
+		break;
+	default:
+		skb_set_queue_mapping(skb, WMM_AC_VI);
+		skb->priority = 5;
+		break;
+	}
+
+	pmbuf = (mlan_buffer *)skb->head;
+	memset((t_u8 *)pmbuf, 0, sizeof(mlan_buffer));
+	pmbuf->bss_index = priv->bss_index;
+	pmbuf->pdesc = skb;
+	pmbuf->pbuf = skb->head + sizeof(mlan_buffer);
+
+	pmbuf->data_offset = skb->data - (skb->head + sizeof(mlan_buffer));
+	pmbuf->data_len = skb->len;
+	pmbuf->priority = skb->priority;
+	pmbuf->buf_type = MLAN_BUF_TYPE_DATA;
+
+	DBG_HEXDUMP(MDAT_D, "TDLS data:", pmbuf->pbuf + pmbuf->data_offset,
+		    pmbuf->data_len);
+
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+	index = skb_get_queue_mapping(skb);
+#endif
+	status = mlan_send_packet(priv->phandle->pmlan_adapter, pmbuf);
+
+	switch (status) {
+	case MLAN_STATUS_PENDING:
+		atomic_inc(&priv->phandle->tx_pending);
+#if CFG80211_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+		atomic_inc(&priv->wmm_tx_pending[index]);
+#endif
+		queue_work(priv->phandle->workqueue, &priv->phandle->main_work);
+		/*delay 10 ms to guarantee the teardown/confirm frame can be
+		 * sent out before disalbe/enable tdls link if we don't delay
+		 * and return immediately, wpa_supplicant will call
+		 * disalbe/enable tdls link this may cause tdls link
+		 * disabled/enabled before teardown/confirm frame sent out */
+		if (action_code == WLAN_TDLS_TEARDOWN ||
+		    action_code == WLAN_TDLS_SETUP_CONFIRM)
+			woal_sched_timeout(10);
+		break;
+	case MLAN_STATUS_SUCCESS:
+		dev_kfree_skb(skb);
+		break;
+	case MLAN_STATUS_FAILURE:
+	default:
+		dev_kfree_skb(skb);
+		ret = -ENOTSUPP;
+		break;
+	}
+
+	LEAVE();
+	return ret;
+fail:
+	dev_kfree_skb(skb);
+	return ret;
+}
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+/**
+ * @brief Tx TDLS packet
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param peer_capability       peer capability
+ * @param initiator             initiator
+ * @param extra_ies              A pointer to extra ie buffer
+ * @param extra_ies_len          etra ie len
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+int woal_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+			    const t_u8 *peer, u8 action_code, t_u8 dialog_token,
+			    t_u16 status_code, t_u32 peer_capability,
+			    bool initiator, const t_u8 *extra_ies,
+			    size_t extra_ies_len)
+#else
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+/**
+ * @brief Tx TDLS packet
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param peer_capability       peer capability
+ * @param extra_ies              A pointer to extra ie buffer
+ * @param extra_ies_len          etra ie len
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+int woal_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+			    const t_u8 *peer,
+#else
+			    t_u8 *peer,
+#endif
+			    u8 action_code, t_u8 dialog_token,
+			    t_u16 status_code, t_u32 peer_capability,
+			    const t_u8 *extra_ies, size_t extra_ies_len)
+#else
+/**
+ * @brief Tx TDLS packet
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  A pointer to peer mac
+ * @param action_code           tdls action code
+ * @param dialog_token          dialog_token
+ * @param status_code           status_code
+ * @param extra_ies              A pointer to extra ie buffer
+ * @param extra_ies_len          etra ie len
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+int woal_cfg80211_tdls_mgmt(struct wiphy *wiphy, struct net_device *dev,
+			    t_u8 *peer, u8 action_code, t_u8 dialog_token,
+			    t_u16 status_code, const t_u8 *extra_ies,
+			    size_t extra_ies_len)
+#endif
+#endif
+{
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	int ret = 0;
+	mlan_bss_info bss_info;
+
+	ENTER();
+
+	if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS)) {
+		LEAVE();
+		return -ENOTSUPP;
+	}
+	/* make sure we are not in uAP mode and Go mode */
+	if (priv->bss_type != MLAN_BSS_TYPE_STA) {
+		LEAVE();
+		return -ENOTSUPP;
+	}
+
+	/* check if AP prohited TDLS */
+	memset(&bss_info, 0, sizeof(bss_info));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		PRINTM(MERROR, "WLAN, %s: Failed to get bss info.\n", __func__);
+	}
+	if (IS_EXTCAP_TDLS_PROHIBITED(bss_info.ext_cap)) {
+		PRINTM(MMSG, "TDLS is prohibited by AP\n");
+		LEAVE();
+		return -ENOTSUPP;
+	}
+
+	switch (action_code) {
+	case TDLS_SETUP_REQUEST:
+		woal_add_tdls_peer(priv, (t_u8 *)peer);
+		PRINTM(MMSG,
+		       "wlan: Send TDLS Setup Request to " MACSTR
+		       " status_code=%d\n",
+		       MAC2STR(peer), status_code);
+		ret = woal_send_tdls_data_frame(wiphy, dev, (t_u8 *)peer,
+						action_code, dialog_token,
+						status_code, extra_ies,
+						extra_ies_len);
+		break;
+	case TDLS_SETUP_RESPONSE:
+		PRINTM(MMSG,
+		       "wlan: Send TDLS Setup Response to " MACSTR
+		       " status_code=%d\n",
+		       MAC2STR(peer), status_code);
+		ret = woal_send_tdls_data_frame(wiphy, dev, (t_u8 *)peer,
+						action_code, dialog_token,
+						status_code, extra_ies,
+						extra_ies_len);
+		break;
+	case TDLS_SETUP_CONFIRM:
+		PRINTM(MMSG,
+		       "wlan: Send TDLS Confirm to " MACSTR " status_code=%d\n",
+		       MAC2STR(peer), status_code);
+		ret = woal_send_tdls_data_frame(wiphy, dev, (t_u8 *)peer,
+						action_code, dialog_token,
+						status_code, extra_ies,
+						extra_ies_len);
+		break;
+	case TDLS_TEARDOWN:
+		PRINTM(MMSG, "wlan: Send TDLS Tear down to " MACSTR "\n",
+		       MAC2STR(peer));
+		ret = woal_send_tdls_data_frame(wiphy, dev, (t_u8 *)peer,
+						action_code, dialog_token,
+						status_code, extra_ies,
+						extra_ies_len);
+		break;
+	case TDLS_DISCOVERY_REQUEST:
+		PRINTM(MMSG,
+		       "wlan: Send TDLS Discovery Request to " MACSTR "\n",
+		       MAC2STR(peer));
+		ret = woal_send_tdls_data_frame(wiphy, dev, (t_u8 *)peer,
+						action_code, dialog_token,
+						status_code, extra_ies,
+						extra_ies_len);
+		break;
+	case TDLS_DISCOVERY_RESPONSE:
+		PRINTM(MMSG,
+		       "wlan: Send TDLS Discovery Response to " MACSTR "\n",
+		       MAC2STR(peer));
+		ret = woal_send_tdls_action_frame(wiphy, dev, (t_u8 *)peer,
+						  action_code, dialog_token,
+						  status_code, extra_ies,
+						  extra_ies_len);
+		break;
+	default:
+		break;
+	}
+
+	LEAVE();
+	return ret;
+}
+
+/**
+ * @brief cfg80211_tdls_oper handler
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param peer                  tdls peer mac
+ * @param oper                  tdls operation code
+ *
+ * @return                  	0 -- success, otherwise fail
+ */
+int woal_cfg80211_tdls_oper(struct wiphy *wiphy, struct net_device *dev,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 16, 0)
+			    const u8 *peer,
+#else
+			    u8 *peer,
+#endif
+			    enum nl80211_tdls_operation oper)
+{
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	t_u8 action;
+	int ret = 0;
+	t_u8 event_buf[32];
+	int custom_len = 0;
+
+	ENTER();
+
+	if (!(wiphy->flags & WIPHY_FLAG_SUPPORTS_TDLS))
+		return -ENOTSUPP;
+
+	if (!(wiphy->flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP))
+		return -ENOTSUPP;
+	/* make sure we are in managed mode, and associated */
+	if (priv->bss_type != MLAN_BSS_TYPE_STA)
+		return -ENOTSUPP;
+
+	PRINTM(MIOCTL, "wlan: TDLS peer=" MACSTR ", oper=%d\n", MAC2STR(peer),
+	       oper);
+	switch (oper) {
+	case NL80211_TDLS_ENABLE_LINK:
+		/*Configure TDLS link first*/
+		woal_tdls_oper(priv, (u8 *)peer, WLAN_TDLS_CONFIG_LINK);
+		woal_updata_peer_status(priv, (t_u8 *)peer,
+					TDLS_SETUP_COMPLETE);
+		PRINTM(MMSG, "wlan: TDLS_ENABLE_LINK: peer=" MACSTR "\n",
+		       MAC2STR(peer));
+		action = WLAN_TDLS_ENABLE_LINK;
+		memset(event_buf, 0, sizeof(event_buf));
+		custom_len = strlen(CUS_EVT_TDLS_CONNECTED);
+		moal_memcpy_ext(priv->phandle, event_buf,
+				CUS_EVT_TDLS_CONNECTED, custom_len,
+				sizeof(event_buf));
+		moal_memcpy_ext(priv->phandle, event_buf + custom_len, peer,
+				ETH_ALEN, sizeof(event_buf) - custom_len);
+		woal_broadcast_event(priv, event_buf, custom_len + ETH_ALEN);
+		break;
+	case NL80211_TDLS_DISABLE_LINK:
+		woal_updata_peer_status(priv, (t_u8 *)peer, TDLS_NOT_SETUP);
+		PRINTM(MMSG, "wlan: TDLS_DISABLE_LINK: peer=" MACSTR "\n",
+		       MAC2STR(peer));
+		action = WLAN_TDLS_DISABLE_LINK;
+		memset(event_buf, 0, sizeof(event_buf));
+		custom_len = strlen(CUS_EVT_TDLS_TEARDOWN);
+		moal_memcpy_ext(priv->phandle, event_buf, CUS_EVT_TDLS_TEARDOWN,
+				custom_len, sizeof(event_buf));
+		moal_memcpy_ext(priv->phandle, event_buf + custom_len, peer,
+				ETH_ALEN, sizeof(event_buf) - custom_len);
+		woal_broadcast_event(priv, event_buf, custom_len + ETH_ALEN);
+		break;
+	case NL80211_TDLS_TEARDOWN:
+	case NL80211_TDLS_SETUP:
+	case NL80211_TDLS_DISCOVERY_REQ:
+		return 0;
+
+	default:
+		return -ENOTSUPP;
+	}
+	ret = woal_tdls_oper(priv, (u8 *)peer, action);
+
+	LEAVE();
+	return ret;
+}
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+/**
+ * @brief tdls channel switch
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param addr                  A pointer to peer addr
+ * @param oper_class            The operating class
+ * @param chandef               A pointer to cfg80211_chan_def structure
+ *
+ * @return                      0 -- success, otherwise fail
+ */
+static int woal_cfg80211_tdls_channel_switch(struct wiphy *wiphy,
+					     struct net_device *dev,
+					     const u8 *addr, u8 oper_class,
+					     struct cfg80211_chan_def *chandef)
+{
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_tdls_config *tdls_data = NULL;
+	tdls_all_config *tdls_all_cfg = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	mlan_bss_info bss_info;
 
-	if (!mef_cfg.criteria)
-		mef_cfg.criteria = CRITERIA_BROADCAST | CRITERIA_UNICAST |
-				   CRITERIA_MULTICAST;
+	ENTER();
 
-	status = woal_set_get_wowlan_config(priv, MLAN_ACT_SET, MOAL_IOCTL_WAIT,
-					    &mef_cfg);
-	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR, "woal_set_get_wowlan_config fail!\n");
-		ret = -EFAULT;
-		goto done;
+	/* check if AP prohited TDLS channel switch */
+	memset(&bss_info, 0, sizeof(bss_info));
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		PRINTM(MERROR, "WLAN, %s: Failed to get bss info.\n", __func__);
+	}
+	if (IS_EXTCAP_TDLS_CHLSWITCHPROHIB(bss_info.ext_cap)) {
+		PRINTM(MMSG, "TDLS Channel Switching is prohibited by AP\n");
+		LEAVE();
+		return -ENOTSUPP;
 	}
 
-	memset(&hscfg, 0, sizeof(mlan_ds_hs_cfg));
-	status = woal_set_get_hs_params(priv, MLAN_ACT_GET, MOAL_IOCTL_WAIT,
-					&hscfg);
-	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR,
-		       "Fail to get HS parameter in woal_cfg80211_suspend: 0x%x 0x%x 0x%x\n",
-		       hscfg.conditions, hscfg.gap, hscfg.gpio);
-		ret = -EFAULT;
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		ret = -ENOMEM;
 		goto done;
 	}
-	hscfg.is_invoke_hostcmd = MFALSE;
-	if (wow->n_patterns || wow->magic_pkt)
-		hscfg.conditions = 0;
-	status = woal_set_get_hs_params(priv, MLAN_ACT_SET, MOAL_IOCTL_WAIT,
-					&hscfg);
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_OPER;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_SET;
+
+	tdls_data = &misc->param.tdls_config;
+	tdls_data->tdls_action = WLAN_TDLS_INIT_CHAN_SWITCH;
+
+	tdls_all_cfg = (tdls_all_config *)tdls_data->tdls_data;
+	moal_memcpy_ext(priv->phandle,
+			tdls_all_cfg->u.tdls_chan_switch.peer_mac_addr, addr,
+			ETH_ALEN,
+			sizeof(tdls_all_cfg->u.tdls_chan_switch.peer_mac_addr));
+	tdls_all_cfg->u.tdls_chan_switch.primary_channel =
+		chandef->chan->hw_value;
+	tdls_all_cfg->u.tdls_chan_switch.band = chandef->chan->band;
+	tdls_all_cfg->u.tdls_chan_switch.regulatory_class = oper_class;
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_SUCCESS) {
-		PRINTM(MERROR,
-		       "Fail to set HS parameter in woal_cfg80211_suspend: 0x%x 0x%x 0x%x\n",
-		       hscfg.conditions, hscfg.gap, hscfg.gpio);
+		PRINTM(MERROR, "TDLS channel switch request failed.\n");
 		ret = -EFAULT;
 		goto done;
 	}
 
 done:
-	PRINTM(MCMND, "<--- Leave woal_cfg80211_suspend --->\n");
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	LEAVE();
 	return ret;
 }
-#endif
 
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 5, 0)
-static void woal_cfg80211_set_wakeup(struct wiphy *wiphy, bool enabled)
+/**
+ * @brief tdls cancel channel switch
+ *
+ * @param wiphy                 A pointer to wiphy structure
+ * @param dev                   A pointer to net_device structure
+ * @param addr                  A pointer to peer addr
+ *
+ */
+void woal_cfg80211_tdls_cancel_channel_switch(struct wiphy *wiphy,
+					      struct net_device *dev,
+					      const u8 *addr)
 {
-	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_misc_cfg *misc = NULL;
+	mlan_ds_misc_tdls_config *tdls_data = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
 
-	device_set_wakeup_enable(handle->hotplug_device, enabled);
+	ENTER();
+
+	if (!priv || !priv->phandle) {
+		PRINTM(MERROR, "priv or handle is null\n");
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
+	if (ioctl_req == NULL) {
+		status = MLAN_STATUS_FAILURE;
+		goto done;
+	}
+
+	misc = (mlan_ds_misc_cfg *)ioctl_req->pbuf;
+	misc->sub_command = MLAN_OID_MISC_TDLS_CONFIG;
+	ioctl_req->req_id = MLAN_IOCTL_MISC_CFG;
+	ioctl_req->action = MLAN_ACT_SET;
+
+	tdls_data = &misc->param.tdls_config;
+	tdls_data->tdls_action = WLAN_TDLS_STOP_CHAN_SWITCH;
+	moal_memcpy_ext(priv->phandle, tdls_data->tdls_data, addr, ETH_ALEN,
+			sizeof(tdls_data->tdls_data));
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS)
+		goto done;
+
+	PRINTM(MIOCTL, "Tdls channel switch stop!\n");
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
 }
 #endif
-
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 /**
  * @brief change station info
@@ -6366,9 +8614,41 @@ static int woal_cfg80211_change_station(struct wiphy *wiphy,
 					struct station_parameters *params)
 {
 	int ret = 0;
+#ifdef UAP_SUPPORT
+	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
+	moal_private *vlan_priv = NULL;
+	station_node *sta_node = NULL;
+	int i = 0;
+#endif
 
 	ENTER();
-
+#ifdef UAP_SUPPORT
+	/** Bind the station to uap virtual interface and
+	save the station info in moal_private */
+	if (params->vlan) {
+		if (params->vlan->ieee80211_ptr &&
+		    params->vlan->ieee80211_ptr->iftype ==
+			    NL80211_IFTYPE_AP_VLAN) {
+			vlan_priv = (moal_private *)woal_get_netdev_priv(
+				params->vlan);
+			for (i = 0; i < MAX_STA_COUNT; i++) {
+				sta_node = priv->vlan_sta_list[i];
+				if (sta_node &&
+				    !moal_memcmp(priv->phandle,
+						 sta_node->peer_mac, mac,
+						 MLAN_MAC_ADDR_LENGTH)) {
+					PRINTM(MCMND,
+					       "wlan: Easymesh change station aid=%d\n",
+					       sta_node->aid);
+					sta_node->netdev = params->vlan;
+					sta_node->is_valid = MTRUE;
+					vlan_priv->vlan_sta_ptr = sta_node;
+					break;
+				}
+			}
+		}
+	}
+#endif
 	/**do nothing*/
 
 	LEAVE();
@@ -6399,12 +8679,29 @@ static int woal_cfg80211_add_station(struct wiphy *wiphy,
 {
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	int ret = 0;
+	station_node *sta_node = NULL;
 
 	ENTER();
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 #ifdef UAP_SUPPORT
 	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME) &&
 	    (priv->bss_role == MLAN_BSS_ROLE_UAP)) {
+		sta_node = kmalloc(sizeof(station_node), GFP_KERNEL);
+		if (!sta_node) {
+			PRINTM(MERROR,
+			       "Failed to alloc memory for station node\n");
+			LEAVE();
+			return -ENOMEM;
+		}
+		memset(sta_node, 0, sizeof(*sta_node));
+		moal_memcpy_ext(priv->phandle, sta_node->peer_mac, mac,
+				MLAN_MAC_ADDR_LENGTH, ETH_ALEN);
+		sta_node->netdev = dev;
+		sta_node->aid = params->aid;
+		sta_node->is_valid = MFALSE;
+		/** AID should start from 1 to MAX_STA_COUNT */
+		priv->vlan_sta_list[(params->aid - 1) % MAX_STA_COUNT] =
+			sta_node;
 		ret = woal_cfg80211_uap_add_station(wiphy, dev, (u8 *)mac,
 						    params);
 		LEAVE();
@@ -6412,6 +8709,18 @@ static int woal_cfg80211_add_station(struct wiphy *wiphy,
 	}
 #endif
 #endif
+	if (!(params->sta_flags_set & MBIT(NL80211_STA_FLAG_TDLS_PEER)))
+		goto done;
+	/* make sure we are in connected mode */
+	if ((priv->bss_type != MLAN_BSS_TYPE_STA) ||
+	    (priv->media_connected == MFALSE)) {
+		ret = -ENOTSUPP;
+		goto done;
+	}
+	PRINTM(MMSG, "wlan: TDLS add peer station, address =" MACSTR "\n",
+	       MAC2STR(mac));
+	ret = woal_tdls_oper(priv, (u8 *)mac, WLAN_TDLS_CREATE_LINK);
+done:
 	LEAVE();
 	return ret;
 }
@@ -6434,7 +8743,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	IEEEtypes_MobilityDomain_t *md_ie = NULL;
 	int ret = 0;
-	mlan_ds_misc_assoc_rsp assoc_rsp;
+	mlan_ds_misc_assoc_rsp *assoc_rsp = NULL;
 	IEEEtypes_AssocRsp_t *passoc_rsp = NULL;
 	mlan_bss_info bss_info;
 
@@ -6448,15 +8757,21 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 		LEAVE();
 		return ret;
 	}
+	assoc_rsp = kmalloc(sizeof(mlan_ds_misc_assoc_rsp), GFP_KERNEL);
+	if (!assoc_rsp) {
+		LEAVE();
+		return ret;
+	}
 #ifdef MLAN_64BIT
 	PRINTM(MINFO, "==>woal_cfg80211_update_ft_ies %lx \n", ftie->ie_len);
 #else
 	PRINTM(MINFO, "==>woal_cfg80211_update_ft_ies %x \n", ftie->ie_len);
 #endif
 	md_ie = (IEEEtypes_MobilityDomain_t *)woal_parse_ie_tlv(
-		ftie->ie, ftie->ie_len, MOBILITY_DOMAIN);
+		ftie->ie, (int)ftie->ie_len, MOBILITY_DOMAIN);
 	if (!md_ie) {
 		PRINTM(MERROR, "No Mobility domain IE\n");
+		kfree(assoc_rsp);
 		LEAVE();
 		return ret;
 	}
@@ -6473,6 +8788,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 	priv->ft_md = ftie->md;
 
 	if (!priv->ft_pre_connect) {
+		kfree(assoc_rsp);
 		LEAVE();
 		return ret;
 	}
@@ -6480,6 +8796,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 	if (!memcmp(&priv->target_ap_bssid, priv->cfg_bssid,
 		    MLAN_MAC_ADDR_LENGTH)) {
 		PRINTM(MMSG, "This is the same AP, no Fast bss transition\n");
+		kfree(assoc_rsp);
 		priv->ft_pre_connect = MFALSE;
 		priv->ft_ie_len = 0;
 		LEAVE();
@@ -6492,22 +8809,27 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 	moal_memcpy_ext(priv->phandle, (void *)priv->sme_current.bssid,
 			&priv->target_ap_bssid, MLAN_MAC_ADDR_LENGTH,
 			sizeof(priv->conn_bssid));
-	memset(&assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
+	memset(assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
 	ret = woal_cfg80211_assoc(priv, (void *)&priv->sme_current,
-				  MOAL_IOCTL_WAIT, &assoc_rsp);
+				  MOAL_IOCTL_WAIT, assoc_rsp);
 
 	if ((priv->ft_cap & MBIT(0)) || priv->ft_roaming_triggered_by_driver) {
 		if (!ret) {
 			woal_inform_bss_from_scan_result(priv, NULL,
 							 MOAL_IOCTL_WAIT);
 			passoc_rsp = (IEEEtypes_AssocRsp_t *)
-					     assoc_rsp.assoc_resp_buf;
+					     assoc_rsp->assoc_resp_buf;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)) || IMX_ANDROID_13 ||   \
+     IMX_ANDROID_12_BACKPORT)
+			roam_info.links[0].bssid = priv->cfg_bssid;
+#else
 			roam_info.bssid = priv->cfg_bssid;
+#endif
 			roam_info.req_ie = priv->sme_current.ie;
 			roam_info.req_ie_len = priv->sme_current.ie_len;
 			roam_info.resp_ie = passoc_rsp->ie_buffer;
-			roam_info.resp_ie_len = assoc_rsp.assoc_resp_len -
+			roam_info.resp_ie_len = assoc_rsp->assoc_resp_len -
 						ASSOC_RESP_FIXED_SIZE;
 			cfg80211_roamed(priv->netdev, &roam_info, GFP_KERNEL);
 #else
@@ -6516,7 +8838,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 					priv->sme_current.ie,
 					priv->sme_current.ie_len,
 					passoc_rsp->ie_buffer,
-					assoc_rsp.assoc_resp_len -
+					assoc_rsp->assoc_resp_len -
 						ASSOC_RESP_FIXED_SIZE,
 					GFP_KERNEL);
 #else
@@ -6524,7 +8846,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 					priv->sme_current.ie,
 					priv->sme_current.ie_len,
 					passoc_rsp->ie_buffer,
-					assoc_rsp.assoc_resp_len -
+					assoc_rsp->assoc_resp_len -
 						ASSOC_RESP_FIXED_SIZE,
 					GFP_KERNEL);
 #endif
@@ -6551,13 +8873,13 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 
 	} else {
 		if (!ret) {
-			memset(&assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
-			woal_get_assoc_rsp(priv, &assoc_rsp, MOAL_IOCTL_WAIT);
+			memset(assoc_rsp, 0, sizeof(mlan_ds_misc_assoc_rsp));
+			woal_get_assoc_rsp(priv, assoc_rsp, MOAL_IOCTL_WAIT);
 			passoc_rsp = (IEEEtypes_AssocRsp_t *)
-					     assoc_rsp.assoc_resp_buf;
+					     assoc_rsp->assoc_resp_buf;
 			cfg80211_connect_result(priv->netdev, priv->cfg_bssid,
 						NULL, 0, passoc_rsp->ie_buffer,
-						assoc_rsp.assoc_resp_len -
+						assoc_rsp->assoc_resp_len -
 							ASSOC_RESP_FIXED_SIZE,
 						WLAN_STATUS_SUCCESS,
 						GFP_KERNEL);
@@ -6590,7 +8912,7 @@ int woal_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,
 			// priv->ft_ie_len = 0;
 		}
 	}
-
+	kfree(assoc_rsp);
 	priv->ft_pre_connect = MFALSE;
 	LEAVE();
 	return 0;
@@ -6641,6 +8963,10 @@ void woal_save_conn_params(moal_private *priv,
 				sme->key, sme->key_len,
 				sizeof(priv->conn_wep_key));
 	}
+	if (priv->sinfo)
+		memset(priv->sinfo, 0, sizeof(struct station_info));
+	else
+		priv->sinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);
 }
 
 /**
@@ -6655,16 +8981,23 @@ void woal_clear_conn_params(moal_private *priv)
 		kfree(priv->sme_current.ie);
 	memset(&priv->sme_current, 0, sizeof(struct cfg80211_connect_params));
 	priv->roaming_required = MFALSE;
+	priv->assoc_bss = NULL;
+	if (priv->sinfo) {
+		kfree(priv->sinfo);
+		priv->sinfo = NULL;
+	}
 	LEAVE();
 }
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 /**
  * @brief Build new roaming connect ie for okc
  *
  * @param priv            A pointer to moal_private
  * @param entry           A pointer to pmksa_entry
  **/
-int woal_update_okc_roaming_ie(moal_private *priv, struct pmksa_entry *entry)
+static int woal_update_okc_roaming_ie(moal_private *priv,
+				      struct pmksa_entry *entry)
 {
 	struct cfg80211_connect_params *sme = &priv->sme_current;
 	int ret = MLAN_STATUS_SUCCESS;
@@ -6798,6 +9131,7 @@ int woal_update_okc_roaming_ie(moal_private *priv, struct pmksa_entry *entry)
 	LEAVE();
 	return ret;
 }
+#endif
 
 /**
  * @brief Start roaming: driver handle roaming
@@ -6809,10 +9143,10 @@ int woal_update_okc_roaming_ie(moal_private *priv, struct pmksa_entry *entry)
 void woal_start_roaming(moal_private *priv)
 {
 	mlan_ds_get_signal signal;
-	mlan_ssid_bssid ssid_bssid;
+	mlan_ssid_bssid *ssid_bssid = NULL;
 	char rssi_low[10];
 	int ret = 0;
-	mlan_ds_misc_assoc_rsp *assoc_rsp;
+	mlan_ds_misc_assoc_rsp *assoc_rsp = NULL;
 	IEEEtypes_AssocRsp_t *passoc_rsp = NULL;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
 	struct cfg80211_roam_info roam_info = {};
@@ -6824,6 +9158,11 @@ void woal_start_roaming(moal_private *priv)
 		LEAVE();
 		return;
 	}
+	ssid_bssid = kmalloc(sizeof(mlan_ssid_bssid), GFP_KERNEL);
+	if (!ssid_bssid) {
+		LEAVE();
+		return;
+	}
 
 	if (priv->last_event & EVENT_BG_SCAN_REPORT) {
 		woal_inform_bss_from_scan_result(priv, NULL, MOAL_IOCTL_WAIT);
@@ -6831,6 +9170,7 @@ void woal_start_roaming(moal_private *priv)
 	}
 	if (priv->media_connected == MFALSE || !priv->sme_current.ssid_len) {
 		PRINTM(MIOCTL, "Not connected, ignore roaming\n");
+		kfree(ssid_bssid);
 		LEAVE();
 		return;
 	}
@@ -6843,28 +9183,29 @@ void woal_start_roaming(moal_private *priv)
 		ret = -EFAULT;
 		goto done;
 	}
-	memset(&ssid_bssid, 0, sizeof(mlan_ssid_bssid));
-	ssid_bssid.ssid.ssid_len = priv->sme_current.ssid_len;
-	moal_memcpy_ext(priv->phandle, ssid_bssid.ssid.ssid,
+	memset(ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+	ssid_bssid->ssid.ssid_len = priv->sme_current.ssid_len;
+	moal_memcpy_ext(priv->phandle, ssid_bssid->ssid.ssid,
 			priv->sme_current.ssid, priv->sme_current.ssid_len,
-			sizeof(ssid_bssid.ssid.ssid));
+			sizeof(ssid_bssid->ssid.ssid));
 	if (MLAN_STATUS_SUCCESS !=
-	    woal_find_best_network(priv, MOAL_IOCTL_WAIT, &ssid_bssid)) {
+	    woal_find_best_network(priv, MOAL_IOCTL_WAIT, ssid_bssid)) {
 		PRINTM(MIOCTL, "Can not find better network\n");
 		ret = -EFAULT;
 		goto done;
 	}
 	/* check if we found different AP */
-	if (!memcmp(&ssid_bssid.bssid, priv->cfg_bssid, MLAN_MAC_ADDR_LENGTH)) {
+	if (!memcmp(&ssid_bssid->bssid, priv->cfg_bssid,
+		    MLAN_MAC_ADDR_LENGTH)) {
 		PRINTM(MIOCTL, "This is the same AP, no roaming\n");
 		ret = -EFAULT;
 		goto done;
 	}
 	PRINTM(MIOCTL, "Find AP: bssid=" MACSTR ", signal=%d\n",
-	       MAC2STR(ssid_bssid.bssid), ssid_bssid.rssi);
+	       MAC2STR(ssid_bssid->bssid), ssid_bssid->rssi);
 	/* check signal */
 	if (!(priv->last_event & EVENT_PRE_BCN_LOST)) {
-		if ((abs(signal.bcn_rssi_avg) - abs(ssid_bssid.rssi)) <
+		if ((abs(signal.bcn_rssi_avg) - abs(ssid_bssid->rssi)) <
 		    DELTA_RSSI) {
 			PRINTM(MERROR, "New AP's signal is not good too.\n");
 			ret = -EFAULT;
@@ -6872,16 +9213,16 @@ void woal_start_roaming(moal_private *priv)
 		}
 	}
 	/**check if need start FT Roaming*/
-	if (priv->ft_ie_len && (priv->ft_md == ssid_bssid.ft_md) &&
-	    (priv->ft_cap == ssid_bssid.ft_cap)) {
+	if (priv->ft_ie_len && (priv->ft_md == ssid_bssid->ft_md) &&
+	    (priv->ft_cap == ssid_bssid->ft_cap)) {
 		priv->ft_roaming_triggered_by_driver = MTRUE;
-		woal_start_ft_roaming(priv, &ssid_bssid);
+		woal_start_ft_roaming(priv, ssid_bssid);
 		goto done;
 	}
 	/* start roaming to new AP */
 	priv->sme_current.bssid = priv->conn_bssid;
 	moal_memcpy_ext(priv->phandle, (void *)priv->sme_current.bssid,
-			&ssid_bssid.bssid, MLAN_MAC_ADDR_LENGTH,
+			&ssid_bssid->bssid, MLAN_MAC_ADDR_LENGTH,
 			sizeof(priv->conn_bssid));
 
 #ifdef STA_CFG80211
@@ -6952,7 +9293,12 @@ void woal_start_roaming(moal_private *priv)
 		}
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)) || IMX_ANDROID_13 ||   \
+     IMX_ANDROID_12_BACKPORT)
+		roam_info.links[0].bssid = priv->cfg_bssid;
+#else
 		roam_info.bssid = priv->cfg_bssid;
+#endif
 		roam_info.req_ie = ie;
 		roam_info.req_ie_len = ie_len;
 		roam_info.resp_ie = passoc_rsp->ie_buffer;
@@ -6978,15 +9324,18 @@ void woal_start_roaming(moal_private *priv)
 		       MAC2STR(priv->cfg_bssid));
 	} else {
 		PRINTM(MIOCTL, "Roaming to bssid " MACSTR " failed\n",
-		       MAC2STR(ssid_bssid.bssid));
+		       MAC2STR(ssid_bssid->bssid));
 	}
 	kfree(assoc_rsp);
 done:
+	kfree(ssid_bssid);
 	/* config rssi low threshold again */
 	priv->last_event = 0;
 	priv->rssi_low = DEFAULT_RSSI_LOW_THRESHOLD;
-	sprintf(rssi_low, "%d", priv->rssi_low);
-	woal_set_rssi_low_threshold(priv, rssi_low, MOAL_IOCTL_WAIT);
+	snprintf(rssi_low, sizeof(rssi_low), "%d", priv->rssi_low);
+	if (MLAN_STATUS_FAILURE ==
+	    woal_set_rssi_low_threshold(priv, rssi_low, MOAL_IOCTL_WAIT))
+		PRINTM(MERROR, "set_rssi_low_threshold fail\n");
 	LEAVE();
 	return;
 }
@@ -7022,29 +9371,54 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 	ENTER();
 
 	req_len = sizeof(mlan_ds_bss);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	if (params->ext_capab_len)
 		req_len += sizeof(MrvlIEtypesHeader_t) + params->ext_capab_len;
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.supported_rates_len)
+		req_len += sizeof(MrvlIEtypesHeader_t) +
+			   params->link_sta_params.supported_rates_len;
+#else
 	if (params->supported_rates_len)
 		req_len += sizeof(MrvlIEtypesHeader_t) +
 			   params->supported_rates_len;
+#endif
 	if (params->uapsd_queues || params->max_sp)
 		req_len += sizeof(MrvlIEtypesHeader_t) + sizeof(qosinfo);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.ht_capa)
+#else
 	if (params->ht_capa)
+#endif
 		req_len += sizeof(MrvlIEtypesHeader_t) +
 			   sizeof(struct ieee80211_ht_cap);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.vht_capa)
+#else
 	if (params->vht_capa)
+#endif
 		req_len += sizeof(MrvlIEtypesHeader_t) +
 			   sizeof(struct ieee80211_vht_cap);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.opmode_notif_used)
+		req_len += sizeof(MrvlIEtypesHeader_t) + sizeof(u8);
+#else
 	if (params->opmode_notif_used)
 		req_len += sizeof(MrvlIEtypesHeader_t) + sizeof(u8);
 #endif
+#endif
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.he_capa_len)
+		req_len += sizeof(MrvlExtIEtypesHeader_t) +
+			   params->link_sta_params.he_capa_len;
+#else
 	if (params->he_capa_len)
 		req_len += sizeof(MrvlExtIEtypesHeader_t) + params->he_capa_len;
+#endif
 #endif
 	req = woal_alloc_mlan_ioctl_req(req_len);
 	if (req == NULL) {
@@ -7079,7 +9453,7 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 	       params->sta_flags_set, params->listen_interval, params->aid);
 #endif
 	pos = &bss->param.sta_info.tlv[0];
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 	if (params->ext_capab_len) {
 		tlv = (MrvlIEtypes_Data_t *)pos;
 		tlv->header.type = EXT_CAPABILITY;
@@ -7092,12 +9466,25 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 		tlv = (MrvlIEtypes_Data_t *)pos;
 	}
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.supported_rates_len) {
+#else
 	if (params->supported_rates_len) {
+#endif
 		tlv = (MrvlIEtypes_Data_t *)pos;
 		tlv->header.type = SUPPORTED_RATES;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		tlv->header.len = params->link_sta_params.supported_rates_len;
+#else
 		tlv->header.len = params->supported_rates_len;
+#endif
 		moal_memcpy_ext(priv->phandle, tlv->data,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+				params->link_sta_params.supported_rates,
+				tlv->header.len,
+#else
 				params->supported_rates, tlv->header.len,
+#endif
 				tlv->header.len);
 		pos += sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		bss->param.sta_info.tlv_len +=
@@ -7116,34 +9503,61 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 			sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		tlv = (MrvlIEtypes_Data_t *)pos;
 	}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.ht_capa) {
+#else
 	if (params->ht_capa) {
+#endif
 		tlv = (MrvlIEtypes_Data_t *)pos;
 		tlv->header.type = HT_CAPABILITY;
 		tlv->header.len = sizeof(struct ieee80211_ht_cap);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		moal_memcpy_ext(priv->phandle, tlv->data,
+				params->link_sta_params.ht_capa,
+#else
 		moal_memcpy_ext(priv->phandle, tlv->data, params->ht_capa,
+#endif
 				tlv->header.len, tlv->header.len);
 		pos += sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		bss->param.sta_info.tlv_len +=
 			sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		tlv = (MrvlIEtypes_Data_t *)pos;
 	}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.vht_capa) {
+#else
 	if (params->vht_capa) {
+#endif
 		tlv = (MrvlIEtypes_Data_t *)pos;
 		tlv->header.type = VHT_CAPABILITY;
 		tlv->header.len = sizeof(struct ieee80211_vht_cap);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		moal_memcpy_ext(priv->phandle, tlv->data,
+				params->link_sta_params.vht_capa,
+#else
 		moal_memcpy_ext(priv->phandle, tlv->data, params->vht_capa,
+#endif
 				tlv->header.len, tlv->header.len);
 		pos += sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		bss->param.sta_info.tlv_len +=
 			sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		tlv = (MrvlIEtypes_Data_t *)pos;
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.opmode_notif_used) {
+#else
 	if (params->opmode_notif_used) {
+#endif
 		tlv = (MrvlIEtypes_Data_t *)pos;
 		tlv->header.type = OPER_MODE_NTF;
 		tlv->header.len = sizeof(u8);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+		moal_memcpy_ext(priv->phandle, tlv->data,
+				&params->link_sta_params.opmode_notif,
+#else
 		moal_memcpy_ext(priv->phandle, tlv->data, &params->opmode_notif,
+#endif
 				tlv->header.len, tlv->header.len);
 		pos += sizeof(MrvlIEtypesHeader_t) + tlv->header.len;
 		bss->param.sta_info.tlv_len +=
@@ -7151,7 +9565,26 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 		tlv = (MrvlIEtypes_Data_t *)pos;
 	}
 #endif
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
+	if (params->link_sta_params.he_capa_len) {
+		ext_tlv = (MrvlExtIEtypes_Data_t *)pos;
+		ext_tlv->header.type = EXTENSION;
+		ext_tlv->header.len =
+			params->link_sta_params.he_capa_len + sizeof(u8);
+		ext_tlv->header.ext_id = HE_CAPABILITY;
+		moal_memcpy_ext(priv->phandle, ext_tlv->data,
+				(u8 *)params->link_sta_params.he_capa,
+				params->link_sta_params.he_capa_len,
+				params->link_sta_params.he_capa_len);
+		pos += sizeof(MrvlExtIEtypesHeader_t) +
+		       params->link_sta_params.he_capa_len;
+		bss->param.sta_info.tlv_len +=
+			sizeof(MrvlExtIEtypesHeader_t) +
+			params->link_sta_params.he_capa_len;
+		tlv = (MrvlIEtypes_Data_t *)pos;
+	}
+
+#elif CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
 	if (params->he_capa_len) {
 		ext_tlv = (MrvlExtIEtypes_Data_t *)pos;
 		ext_tlv->header.type = EXTENSION;
@@ -7172,6 +9605,16 @@ int woal_cfg80211_uap_add_station(struct wiphy *wiphy, struct net_device *dev,
 	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+#if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME)) {
+		struct station_info *sinfo = NULL;
+		sinfo = kzalloc(sizeof(struct station_info), GFP_KERNEL);
+		if (sinfo) {
+			cfg80211_new_sta(dev, mac, sinfo, GFP_KERNEL);
+			kfree(sinfo);
+		}
+	}
+#endif
 done:
 	LEAVE();
 	return ret;
@@ -7209,14 +9652,15 @@ static int woal_cfg80211_probe_client(struct wiphy *wiphy,
 void woal_host_mlme_disconnect(moal_private *priv, u16 reason_code, u8 *sa)
 {
 	t_u8 broadcast_addr[ETH_ALEN] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};
-	t_u8 frame_buf[26];
+	t_u8 frame_buf[100];
 	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame_buf;
 	ENTER();
 
-	mgmt->frame_control = IEEE80211_STYPE_DEAUTH;
+	memset(frame_buf, 0, sizeof(frame_buf));
+	mgmt->frame_control = (__force __le16)IEEE80211_STYPE_DEAUTH;
 	mgmt->duration = 0;
 	mgmt->seq_ctrl = 0;
-	mgmt->u.deauth.reason_code = reason_code;
+	mgmt->u.deauth.reason_code = (__force __le16)reason_code;
 	if (GET_BSS_ROLE(priv) == MLAN_BSS_ROLE_STA) {
 		moal_memcpy_ext(priv->phandle, mgmt->da, broadcast_addr,
 				ETH_ALEN, sizeof(mgmt->da));
@@ -7240,7 +9684,7 @@ void woal_host_mlme_disconnect(moal_private *priv, u16 reason_code, u8 *sa)
 	}
 
 	if (GET_BSS_ROLE(priv) != MLAN_BSS_ROLE_UAP) {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
 		mutex_lock(&priv->wdev->mtx);
 		cfg80211_rx_mlme_mgmt(priv->netdev, frame_buf, 26);
 		mutex_unlock(&priv->wdev->mtx);
@@ -7298,6 +9742,7 @@ mlan_status woal_register_sta_cfg80211(struct net_device *dev, t_u8 bss_type)
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	struct wireless_dev *wdev = NULL;
 	int psmode = 0;
+	enum ieee80211_band band;
 
 	ENTER();
 
@@ -7335,6 +9780,22 @@ mlan_status woal_register_sta_cfg80211(struct net_device *dev, t_u8 bss_type)
 		else
 			priv->wdev->ps = MFALSE;
 	}
+	if (priv->phandle->country_code[0] && priv->phandle->country_code[1]) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+		if (priv->phandle->params.cntry_txpwr == CNTRY_RGPOWER_MODE &&
+		    !priv->phandle->params.txpwrlimit_cfg)
+			queue_work(priv->phandle->evt_workqueue,
+				   &priv->phandle->regulatory_work);
+#endif
+		band = priv->phandle->band;
+		priv->phandle->band = IEEE80211_BAND_2GHZ;
+		woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		if (priv->phandle->fw_bands & BAND_A) {
+			priv->phandle->band = IEEE80211_BAND_5GHZ;
+			woal_send_domain_info_cmd_fw(priv, MOAL_IOCTL_WAIT);
+		}
+		priv->phandle->band = band;
+	}
 	LEAVE();
 	return ret;
 }
@@ -7343,15 +9804,18 @@ mlan_status woal_register_sta_cfg80211(struct net_device *dev, t_u8 bss_type)
  * @brief Initialize the wiphy
  *
  * @param priv            A pointer to moal_private structure
+ * @param wiphy 		  A pointer to structure wiphy
+ * @param fw_info         A pointer to mlan_fw_info
  * @param wait_option     Wait option
- *
  * @return                MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
+static mlan_status woal_cfg80211_init_wiphy(moal_private *priv,
+					    struct wiphy *wiphy,
+					    mlan_fw_info *fw_info,
+					    t_u8 wait_option)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	int retry_count, rts_thr, frag_thr;
-	struct wiphy *wiphy = NULL;
 	mlan_ioctl_req *req = NULL;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
 	mlan_ds_radio_cfg *radio = NULL;
@@ -7360,11 +9824,13 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 	t_u32 hw_dev_cap;
 #ifdef UAP_SUPPORT
 	pmlan_uap_bss_param sys_cfg = NULL;
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	t_u16 enable = 0;
 #endif
 	int mcs_supp = 0;
 
 	ENTER();
-	wiphy = priv->phandle->wiphy;
 	/* Get 11n tx parameters from MLAN */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11n_cfg));
 	if (req == NULL) {
@@ -7399,11 +9865,15 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 			mcs_supp = priv->phandle->params.antcfg & 0xf;
 			if (mcs_supp != 3 && mcs_supp != 0)
 				cfg_11n->param.supported_mcs_set[1] = 0;
-			cfg_11n->param.supported_mcs_set[4] = 0;
 		}
 		woal_cfg80211_setup_ht_cap(
 			&wiphy->bands[IEEE80211_BAND_2GHZ]->ht_cap, hw_dev_cap,
-			cfg_11n->param.supported_mcs_set);
+			cfg_11n->param.supported_mcs_set,
+			fw_info->hw_mpdu_density);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
+		woal_cfg80211_setup_vht_cap(
+			priv, &wiphy->bands[IEEE80211_BAND_2GHZ]->vht_cap);
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
 		woal_cfg80211_setup_he_cap(priv,
 					   wiphy->bands[IEEE80211_BAND_2GHZ]);
@@ -7419,7 +9889,8 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 		}
 		woal_cfg80211_setup_ht_cap(
 			&wiphy->bands[IEEE80211_BAND_5GHZ]->ht_cap, hw_dev_cap,
-			cfg_11n->param.supported_mcs_set);
+			cfg_11n->param.supported_mcs_set,
+			fw_info->hw_mpdu_density);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 		woal_cfg80211_setup_vht_cap(
 			priv, &wiphy->bands[IEEE80211_BAND_5GHZ]->vht_cap);
@@ -7429,6 +9900,7 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 					   wiphy->bands[IEEE80211_BAND_5GHZ]);
 #endif
 	}
+
 	kfree(req);
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 38)
@@ -7446,8 +9918,18 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 	ret = woal_request_ioctl(priv, req, wait_option);
 	if (ret != MLAN_STATUS_SUCCESS)
 		goto done;
-
-	/* Set available antennas to wiphy */
+		/* Set available antennas to wiphy */
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+	if (priv->phandle->params.drv_mode & DRV_MODE_DFS) {
+		radio->param.ant_cfg.tx_antenna = 0x101;
+		radio->param.ant_cfg.rx_antenna = 0x101;
+	}
+#endif
+	if (IS_CARD9098(priv->phandle->card_type) ||
+	    IS_CARD9097(priv->phandle->card_type) ||
+	    IS_CARDIW62X(priv->phandle->card_type)) {
+		woal_cfg80211_notify_antcfg(priv, wiphy, radio);
+	}
 	wiphy->available_antennas_tx = radio->param.ant_cfg.tx_antenna;
 	wiphy->available_antennas_rx = radio->param.ant_cfg.rx_antenna;
 #endif /* CFG80211_VERSION_CODE */
@@ -7512,6 +9994,17 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
 	if (frag_thr < MLAN_RTS_MIN_VALUE || frag_thr > MLAN_RTS_MAX_VALUE)
 		frag_thr = MLAN_FRAG_RTS_DISABLED;
 	wiphy->frag_threshold = (t_u32)frag_thr;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	/* Enable multi-channel by default if multi-channel is supported */
+	if (cfg80211_iface_comb_ap_sta.num_different_channels > 1) {
+		if (priv->phandle->card_info->drcs &&
+		    moal_extflg_isset(priv->phandle, EXT_CFG80211_DRCS)) {
+			enable = 1;
+			ret = woal_mc_policy_cfg(priv, &enable, wait_option,
+						 MLAN_ACT_SET);
+		}
+	}
+#endif
 
 done:
 	LEAVE();
@@ -7528,7 +10021,7 @@ mlan_status woal_cfg80211_init_wiphy(moal_private *priv, t_u8 wait_option)
  *
  * @return                N/A
  */
-void woal_update_channel_flag(struct wiphy *wiphy, mlan_fw_info *fw_info)
+static void woal_update_channel_flag(struct wiphy *wiphy, mlan_fw_info *fw_info)
 {
 	enum ieee80211_band band;
 	struct ieee80211_supported_band *sband;
@@ -7537,7 +10030,7 @@ void woal_update_channel_flag(struct wiphy *wiphy, mlan_fw_info *fw_info)
 		sband = wiphy->bands[band];
 		if (!sband)
 			continue;
-		if (sband->band & IEEE80211_BAND_5GHZ &&
+		if (sband->band == IEEE80211_BAND_5GHZ &&
 		    fw_info->prohibit_80mhz) {
 			for (i = 0; i < sband->n_channels; i++) {
 				sband->channels[i].flags |=
@@ -7614,8 +10107,10 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 	wiphy->max_scan_ssids = MRVDRV_MAX_SSID_LIST_LENGTH;
 	wiphy->max_scan_ie_len = MAX_IE_SIZE;
 	wiphy->interface_modes = 0;
-	wiphy->interface_modes =
-		MBIT(NL80211_IFTYPE_STATION) | MBIT(NL80211_IFTYPE_AP);
+	wiphy->interface_modes = MBIT(NL80211_IFTYPE_STATION) |
+				 MBIT(NL80211_IFTYPE_AP_VLAN) |
+				 MBIT(NL80211_IFTYPE_AP);
+	wiphy->interface_modes |= MBIT(NL80211_IFTYPE_MONITOR);
 
 #ifdef WIFI_DIRECT_SUPPORT
 #if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
@@ -7633,24 +10128,18 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 	if (!fw_info.fw_bands)
 		fw_info.fw_bands = BAND_B | BAND_G;
 	if (fw_info.fw_bands & BAND_A) {
-		if (priv->phandle->second_mac)
-			wiphy->bands[IEEE80211_BAND_5GHZ] =
-				&mac1_cfg80211_band_5ghz;
-		else
-
-			wiphy->bands[IEEE80211_BAND_5GHZ] = &cfg80211_band_5ghz;
+		wiphy->bands[IEEE80211_BAND_5GHZ] =
+			woal_setup_wiphy_bands(IEEE80211_BAND_5GHZ);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 9, 0)
 		woal_update_channel_flag(wiphy, &fw_info);
 #endif
 		priv->phandle->band = IEEE80211_BAND_5GHZ;
 	}
+
 	/* Supported bands */
 	if (fw_info.fw_bands & (BAND_B | BAND_G | BAND_GN | BAND_GAC)) {
-		if (priv->phandle->second_mac)
-			wiphy->bands[IEEE80211_BAND_2GHZ] =
-				&mac1_cfg80211_band_2ghz;
-		else
-			wiphy->bands[IEEE80211_BAND_2GHZ] = &cfg80211_band_2ghz;
+		wiphy->bands[IEEE80211_BAND_2GHZ] =
+			woal_setup_wiphy_bands(IEEE80211_BAND_2GHZ);
 		/* If 2.4G enable, it will overwrite default to 2.4G*/
 		priv->phandle->band = IEEE80211_BAND_2GHZ;
 	}
@@ -7692,6 +10181,14 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 #endif
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+	if ((moal_extflg_isset(priv->phandle, EXT_CFG80211_DRCS) &&
+	     priv->phandle->card_info->drcs) ||
+	    IS_CARD9098(priv->phandle->card_type)) {
+		cfg80211_iface_comb_ap_sta.num_different_channels = 2;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+		cfg80211_iface_comb_ap_sta.radar_detect_widths = 0;
+#endif
+	}
 	/* Initialize interface combinations */
 	wiphy->iface_combinations = &cfg80211_iface_comb_ap_sta;
 	wiphy->n_iface_combinations = 1;
@@ -7723,28 +10220,59 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 #endif
 		wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
 #endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	if (priv->phandle->params.sched_scan) {
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
-	wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
 #else
-	wiphy->max_sched_scan_reqs = 1;
+		wiphy->max_sched_scan_reqs = 1;
 #endif
-	wiphy->max_sched_scan_ssids = MRVDRV_MAX_SSID_LIST_LENGTH;
-	wiphy->max_sched_scan_ie_len = MAX_IE_SIZE;
-	wiphy->max_match_sets = MRVDRV_MAX_SSID_LIST_LENGTH;
+		wiphy->max_sched_scan_ssids = MRVDRV_MAX_SSID_LIST_LENGTH;
+		wiphy->max_sched_scan_ie_len = MAX_IE_SIZE;
+		wiphy->max_match_sets = MRVDRV_MAX_SSID_LIST_LENGTH;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
-	wiphy->max_sched_scan_plans = 3;
-	wiphy->max_sched_scan_plan_iterations = 100;
+		wiphy->max_sched_scan_plans = 3;
+		wiphy->max_sched_scan_plan_iterations = 100;
+#endif
+	}
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	wiphy->features |= NL80211_FEATURE_TX_POWER_INSERTION;
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 	wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	wiphy->flags |=
+		WIPHY_FLAG_SUPPORTS_TDLS | WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+#define WLAN_EXT_FEATURE_DFS_OFFLOAD 25
+	if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD)) {
+		if (NUM_NL80211_EXT_FEATURES > WLAN_EXT_FEATURE_DFS_OFFLOAD) {
+			PRINTM(MCMND,
+			       "wlan: Set NL80211_EXT_FEATURE_DFS_OFFLOAD\n");
+			wiphy_ext_feature_set(wiphy,
+					      WLAN_EXT_FEATURE_DFS_OFFLOAD);
+		}
+	}
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
+		wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_RRM);
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
 		wiphy->features |= NL80211_FEATURE_SAE;
 #endif
-
+	wiphy->flags |= WIPHY_FLAG_4ADDR_AP;
+	wiphy->flags |= WIPHY_FLAG_4ADDR_STATION;
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	wiphy->features |= NL80211_FEATURE_NEED_OBSS_SCAN;
 #endif
@@ -7768,12 +10296,38 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 	wiphy->features |= NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;
 	wiphy->features |= NL80211_FEATURE_SCHED_SCAN_RANDOM_MAC_ADDR;
 #endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA);
+	wiphy_ext_feature_set(wiphy,
+			      NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED);
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
 	wiphy_ext_feature_set(wiphy, NL80211_EXT_FEATURE_SET_SCAN_DWELL);
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 	if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
 		wiphy->features |= NL80211_FEATURE_SK_TX_STATUS;
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 10, 0)
+	if (fw_info.fw_beacon_prot) {
+		wiphy_ext_feature_set(wiphy,
+				      NL80211_EXT_FEATURE_BEACON_PROTECTION);
+		wiphy_ext_feature_set(
+			wiphy, NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT);
+	}
+#endif
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+	if (priv->phandle->params.drv_mode & DRV_MODE_DFS) {
+		wiphy_ext_feature_set(wiphy,
+				      NL80211_EXT_FEATURE_RADAR_BACKGROUND);
+		woal_cfg80211_ops.set_radar_background =
+			woal_cfg80211_set_radar_background;
+	}
+#endif
 #endif
 	/* Set struct moal_handle pointer in wiphy_priv */
 	wdev_priv = wiphy_priv(wiphy);
@@ -7803,10 +10357,18 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 		PRINTM(MIOCTL, "Follow countryIE provided by AP.\n");
 	}
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	/*REGULATORY_IGNORE_STALE_KICKOFF: the regulatory core will _not_ make
+	 * sure all interfaces on this wiphy reside on allowed channels. If this
+	 * flag is not set, upon a regdomain change, the interfaces are given a
+	 * grace period (currently 60 seconds) to disconnect or move to an
+	 * allowed channel.*/
+	wiphy->regulatory_flags |= REGULATORY_IGNORE_STALE_KICKOFF;
+#endif
 
-	priv->phandle->country_code[0] = '0';
-	priv->phandle->country_code[1] = '0';
-	priv->phandle->country_code[2] = ' ';
+	memset(&priv->phandle->country_code, 0,
+	       sizeof(priv->phandle->country_code));
+	priv->phandle->dfs_region = NXP_DFS_UNKNOWN;
 
 	if (reg_alpha2 && !strncmp(reg_alpha2, "99", strlen("99"))) {
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
@@ -7832,6 +10394,8 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 		(t_u8 *)&priv->extended_capabilities;
 	wiphy->extended_capabilities_len = sizeof(priv->extended_capabilities);
 #endif
+
+	woal_cfg80211_init_wiphy(priv, wiphy, &fw_info, MOAL_IOCTL_WAIT);
 	if (wiphy_register(wiphy) < 0) {
 		PRINTM(MERROR, "Wiphy device registration failed!\n");
 		ret = MLAN_STATUS_FAILURE;
@@ -7839,8 +10403,7 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 	}
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-	if (fw_info.force_reg ||
-	    (fw_region && priv->phandle->params.txpwrlimit_cfg)) {
+	if (fw_info.force_reg) {
 		PRINTM(MCMND, "FW region_code=%d force_reg=%d\n",
 		       fw_info.region_code, fw_info.force_reg);
 		country = region_code_2_string(fw_info.region_code);
@@ -7848,7 +10411,8 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 			moal_memcpy_ext(priv->phandle,
 					priv->phandle->country_code, country, 2,
 					2);
-			woal_update_custom_regdomain(priv, wiphy);
+			queue_work(priv->phandle->evt_workqueue,
+				   &priv->phandle->regulatory_work);
 		}
 	}
 #endif
@@ -7882,12 +10446,12 @@ mlan_status woal_register_cfg80211(moal_private *priv)
 		}
 	}
 	priv->phandle->wiphy = wiphy;
-	woal_cfg80211_init_wiphy(priv, MOAL_IOCTL_WAIT);
-
 	return ret;
 err_wiphy:
-	if (wiphy)
+	if (wiphy) {
+		woal_cfg80211_free_bands(wiphy);
 		wiphy_free(wiphy);
+	}
 	LEAVE();
 	return ret;
 }
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.h
old mode 100644
new mode 100755
index 8080a481c..193c64ee1
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_sta_cfg80211.h
@@ -3,7 +3,7 @@
  * @brief This file contains the STA CFG80211 specific defines.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -28,14 +28,4 @@
 
 mlan_status woal_register_sta_cfg80211(struct net_device *dev, t_u8 bss_type);
 
-mlan_status woal_cfg80211_set_key(moal_private *priv, t_u8 is_enable_wep,
-				  t_u32 cipher, const t_u8 *key, int key_len,
-				  const t_u8 *seq, int seq_len, t_u8 key_index,
-				  const t_u8 *addr, int disable,
-				  t_u8 wait_option);
-
-mlan_status woal_cfg80211_set_wep_keys(moal_private *priv, const t_u8 *key,
-				       int key_len, t_u8 index,
-				       t_u8 wait_option);
-
 #endif /* _MOAL_STA_CFG80211_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c
old mode 100644
new mode 100755
index a1d30c32a..8f46acd16
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.c
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -35,6 +35,9 @@ Change log:
 #if defined(STA_CFG80211) && defined(UAP_CFG80211)
 #include "moal_cfg80211.h"
 #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+#include <linux/compat.h>
+#endif
 
 /********************************************************
 		Local Variables
@@ -58,7 +61,7 @@ static int woal_uap_addba_param(struct net_device *dev, struct ifreq *req)
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
-	addba_param param;
+	uap_addba_param param;
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
@@ -137,7 +140,7 @@ static int woal_uap_aggr_priotbl(struct net_device *dev, struct ifreq *req)
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_11n_cfg *cfg_11n = NULL;
-	aggr_prio_tbl param;
+	uap_aggr_prio_tbl param;
 	int ret = 0;
 	int i = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -281,7 +284,7 @@ static int woal_uap_addba_reject(struct net_device *dev, struct ifreq *req)
 static int woal_uap_get_fw_info(struct net_device *dev, struct ifreq *req)
 {
 	moal_private *priv = (moal_private *)netdev_priv(dev);
-	fw_info fw;
+	uap_fw_info fw;
 	mlan_fw_info fw_info;
 	int ret = 0;
 
@@ -429,7 +432,7 @@ static int woal_uap_band_steer(struct net_device *dev, struct ifreq *req)
 	}
 	DBG_HEXDUMP(MCMD_D, "band_steer_para", (t_u8 *)&param, sizeof(param));
 
-	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_band_steer_cfg));
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
 		LEAVE();
 		return -ENOMEM;
@@ -505,8 +508,7 @@ static int woal_uap_beacon_stuck(struct net_device *dev, struct ifreq *req)
 	DBG_HEXDUMP(MCMD_D, "beacon_stuck_detect_para", (t_u8 *)&param,
 		    sizeof(param));
 
-	ioctl_req = woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_beacon_stuck_param_cfg));
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (ioctl_req == NULL) {
 		LEAVE();
 		return -ENOMEM;
@@ -738,6 +740,40 @@ static int woal_uap_sdcmd52_rw(struct net_device *dev, struct ifreq *req)
 }
 #endif
 
+/**
+ *  @brief enable/disable 11h
+ *
+ *  @param enable      MTRUE/MFALSE
+ *  @return            0 --success, otherwise fail
+ */
+int woal_uap_11h_ctrl(moal_private *priv, t_u32 enable)
+{
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_ds_snmp_mib *snmp = NULL;
+	int ret = 0;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+	ENTER();
+	ioctl_req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_snmp_mib));
+	if (ioctl_req == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+	snmp = (mlan_ds_snmp_mib *)ioctl_req->pbuf;
+	ioctl_req->req_id = MLAN_IOCTL_SNMP_MIB;
+	snmp->sub_command = MLAN_OID_SNMP_MIB_DOT11H;
+	snmp->param.oid_value = enable;
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief configure snmp mib
  *
@@ -800,6 +836,7 @@ static int woal_uap_snmp_mib(struct net_device *dev, struct ifreq *req)
 		snmp->sub_command = MLAN_OID_SNMP_MIB_DOT11H;
 		break;
 	default:
+		ret = -EINVAL;
 		PRINTM(MERROR, "%s: Unsupported SNMP_MIB OID (%d).\n", __func__,
 		       param.oid);
 		goto done;
@@ -855,14 +892,14 @@ static int woal_uap_domain_info(struct net_device *dev, struct ifreq *req)
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_11d_cfg *cfg11d = NULL;
 	domain_info_para param;
-	t_u8 tlv[MAX_DOMAIN_TLV_LEN];
+	t_u8 tlv[MAX_DOMAIN_TLV_LEN + MAX_REG_DOMAIN_TLV_LEN];
 	t_u16 tlv_data_len = 0;
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
 
 	ENTER();
 	memset(&param, 0, sizeof(param));
-	memset(tlv, 0, MAX_DOMAIN_TLV_LEN);
+	memset(tlv, 0, MAX_DOMAIN_TLV_LEN + MAX_REG_DOMAIN_TLV_LEN);
 
 	/* Sanity check */
 	if (req->ifr_data == NULL) {
@@ -880,14 +917,15 @@ static int woal_uap_domain_info(struct net_device *dev, struct ifreq *req)
 	DBG_HEXDUMP(MCMD_D, "domain_info_para", (t_u8 *)&param, sizeof(param));
 	if (param.action) {
 		/* get tlv header */
-		if (copy_from_user(tlv, req->ifr_data + sizeof(param),
+		if (copy_from_user(&tlv[0], req->ifr_data + sizeof(param),
 				   TLV_HEADER_LEN)) {
 			PRINTM(MERROR, "Copy from user failed\n");
 			ret = -EFAULT;
 			goto done;
 		}
 		tlv_data_len = ((t_u16 *)(tlv))[1];
-		if ((TLV_HEADER_LEN + tlv_data_len) > sizeof(tlv)) {
+		tlv_data_len += MAX_REG_DOMAIN_TLV_LEN;
+		if ((TLV_HEADER_LEN + tlv_data_len) > (int)sizeof(tlv)) {
 			PRINTM(MERROR, "TLV buffer is overflowed");
 			ret = -EINVAL;
 			goto done;
@@ -1002,15 +1040,16 @@ static int woal_uap_dfs_testing(struct net_device *dev, struct ifreq *req)
 		/* Set mib value to MLAN */
 		ioctl_req->action = MLAN_ACT_SET;
 		cfg11h->param.dfs_testing.usr_cac_period_msec =
-			param.usr_cac_period;
+			param.usr_cac_period * 1000;
 		cfg11h->param.dfs_testing.usr_nop_period_sec =
 			param.usr_nop_period;
 		cfg11h->param.dfs_testing.usr_no_chan_change =
 			param.no_chan_change;
 		cfg11h->param.dfs_testing.usr_fixed_new_chan =
 			param.fixed_new_chan;
-		priv->phandle->cac_period_jiffies =
-			param.usr_cac_period * HZ / 1000;
+		cfg11h->param.dfs_testing.usr_cac_restart = param.cac_restart;
+		priv->phandle->cac_restart = param.cac_restart;
+		priv->phandle->cac_period_jiffies = param.usr_cac_period * HZ;
 		priv->user_cac_period_msec =
 			cfg11h->param.dfs_testing.usr_cac_period_msec;
 	}
@@ -1022,13 +1061,14 @@ static int woal_uap_dfs_testing(struct net_device *dev, struct ifreq *req)
 
 	if (!param.action) { /* GET */
 		param.usr_cac_period =
-			cfg11h->param.dfs_testing.usr_cac_period_msec;
+			cfg11h->param.dfs_testing.usr_cac_period_msec / 1000;
 		param.usr_nop_period =
 			cfg11h->param.dfs_testing.usr_nop_period_sec;
 		param.no_chan_change =
 			cfg11h->param.dfs_testing.usr_no_chan_change;
 		param.fixed_new_chan =
 			cfg11h->param.dfs_testing.usr_fixed_new_chan;
+		param.cac_restart = cfg11h->param.dfs_testing.usr_cac_restart;
 	}
 	/* Copy to user */
 	if (copy_to_user(req->ifr_data, &param, sizeof(param))) {
@@ -1044,8 +1084,6 @@ static int woal_uap_dfs_testing(struct net_device *dev, struct ifreq *req)
 	return ret;
 }
 
-#ifdef UAP_CFG80211
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 /**
  *  @brief uap channel NOP status check ioctl handler
  *
@@ -1099,8 +1137,6 @@ int woal_uap_get_channel_nop_info(moal_private *priv, t_u8 wait_option,
 	LEAVE();
 	return ret;
 }
-#endif
-#endif
 
 /**
  *  @brief configure channel switch count
@@ -1513,7 +1549,12 @@ static int woal_uap_hs_cfg(struct net_device *dev, struct ifreq *req,
 	    (hs_cfg.conditions != HOST_SLEEP_CFG_CANCEL ||
 	     invoke_hostcmd == MFALSE)) {
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+			PRINTM(MERROR, "ERR: failed in getting bss info\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		if (bss_info.is_hs_configured) {
 			PRINTM(MERROR, "HS already configured\n");
 			ret = -EFAULT;
@@ -1524,8 +1565,12 @@ static int woal_uap_hs_cfg(struct net_device *dev, struct ifreq *req,
 	if (hs_cfg.flags & HS_CFG_FLAG_SET) {
 		action = MLAN_ACT_SET;
 		if (hs_cfg.flags != HS_CFG_FLAG_ALL) {
-			woal_set_get_hs_params(priv, MLAN_ACT_GET,
-					       MOAL_IOCTL_WAIT, &hscfg);
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_get_hs_params(priv, MLAN_ACT_GET,
+						   MOAL_IOCTL_WAIT, &hscfg)) {
+				PRINTM(MERROR,
+				       "Unable to get HS Configuration\n");
+			}
 		}
 		if (hs_cfg.flags & HS_CFG_FLAG_CONDITION)
 			hscfg.conditions = hs_cfg.conditions;
@@ -1880,6 +1925,16 @@ static int woal_uap_antenna_cfg(struct net_device *dev, struct ifreq *req)
 		mreq->action = MLAN_ACT_SET;
 		radio->param.ant_cfg.tx_antenna = antenna_config.tx_mode;
 		radio->param.ant_cfg.rx_antenna = antenna_config.rx_mode;
+#if defined(STA_CFG80211) || defined(UAP_CFG80211)
+		if (IS_CARD9098(priv->phandle->card_type) ||
+		    IS_CARD9097(priv->phandle->card_type) ||
+		    IS_CARDIW62X(priv->phandle->card_type)) {
+			if (IS_STA_CFG80211(
+				    priv->phandle->params.cfg80211_wext))
+				woal_cfg80211_notify_antcfg(
+					priv, priv->phandle->wiphy, radio);
+		}
+#endif
 	}
 
 	status = woal_request_ioctl(priv, mreq, MOAL_IOCTL_WAIT);
@@ -2042,7 +2097,240 @@ static int woal_uap_dfs_repeater(struct net_device *dev, struct ifreq *req)
 }
 
 /**
- * @brief Set/Get skip CAC mode
+ *  @brief Issue MLAN_OID_11H_CHAN_REPORT_REQUEST ioctl to cancel dozer
+ *
+ *  @param priv     Pointer to the moal_private driver data struct
+ *  @param action   MLAN_ACT_SET/MLAN_ACT_GET
+ *  @param
+ *
+ *  @return         0 --success, otherwise fail
+ */
+int woal_11h_chan_dfs_state(moal_private *priv, t_u8 action,
+			    mlan_ds_11h_chan_dfs_state *ch_dfs_state)
+{
+	int ret = 0;
+	mlan_ioctl_req *req = NULL;
+	mlan_ds_11h_cfg *ds_11hcfg = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
+	if (req == NULL) {
+		ret = -ENOMEM;
+		goto done;
+	}
+	ds_11hcfg = (mlan_ds_11h_cfg *)req->pbuf;
+
+	ds_11hcfg->sub_command = MLAN_OID_11H_CHAN_DFS_STATE;
+	req->req_id = MLAN_IOCTL_11H_CFG;
+	req->action = action;
+	moal_memcpy_ext(priv->phandle, &ds_11hcfg->param.ch_dfs_state,
+			ch_dfs_state, sizeof(mlan_ds_11h_chan_dfs_state),
+			sizeof(ds_11hcfg->param.ch_dfs_state));
+	/* Send Channel Check command and wait until the report is ready */
+	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	moal_memcpy_ext(priv->phandle, ch_dfs_state,
+			&ds_11hcfg->param.ch_dfs_state,
+			sizeof(mlan_ds_11h_chan_dfs_state),
+			sizeof(mlan_ds_11h_chan_dfs_state));
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(req);
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief find all bonded channel.
+ *
+ *  @param pri_chan   primary channel
+ *  @param bw         channel bandwidth
+ *  @param ch_dfs_state  a pointer to mlan_ds_11h_chan_dfs_state array
+ *
+ *  @return           number of channel
+ */
+static int woal_uap_get_dfs_chan(t_u8 pri_chan, t_u8 bw,
+				 mlan_ds_11h_chan_dfs_state *ch_dfs_state)
+{
+	int ht40_plus[] = {52, 60, 100, 108, 116, 124, 132, 140};
+	int ht40_minus[] = {56, 64, 104, 112, 120, 128, 136, 144};
+	int vht80_dfs[4][4] = {{52, 56, 60, 64},
+			       {100, 104, 108, 112},
+			       {116, 120, 124, 128},
+			       {132, 136, 140, 144}};
+	t_u8 find = false;
+	int i, j;
+	t_u8 sec_chan = 0;
+	mlan_ds_11h_chan_dfs_state *pos = ch_dfs_state;
+	t_u8 n_chan = 1;
+
+	if (bw == CHAN_BW_20MHZ) {
+		pos->channel = pri_chan;
+	} else if (bw == CHAN_BW_40MHZ) {
+		pos->channel = pri_chan;
+		pos++;
+		for (i = 0; i < (sizeof(ht40_minus) / sizeof(int)); i++) {
+			if (pri_chan == (t_u8)ht40_plus[i]) {
+				sec_chan = pri_chan + 4;
+				n_chan = 2;
+				break;
+			}
+		}
+		for (i = 0; i < (sizeof(ht40_minus) / sizeof(int)); i++) {
+			if (pri_chan == (t_u8)ht40_minus[i]) {
+				sec_chan = pri_chan - 4;
+				n_chan = 2;
+				break;
+			}
+		}
+		pos->channel = sec_chan;
+	} else if (bw == CHAN_BW_80MHZ) {
+		for (i = 0; i < 4; i++) {
+			for (j = 0; j < 4; j++) {
+				if (pri_chan == (t_u8)vht80_dfs[i][j]) {
+					find = true;
+					break;
+				}
+			}
+			if (find)
+				break;
+		}
+		if (find) {
+			n_chan = 4;
+			for (j = 0; j < n_chan; j++) {
+				pos->channel = (t_u8)vht80_dfs[i][j];
+				pos++;
+			}
+		}
+	}
+	return n_chan;
+}
+
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+/**
+ * @brief update channel dfs state in mlan module
+ *
+ * @param channel         given radar channel
+ * @param dfs_state       dfs_state
+ *
+ * @return                N/A
+ */
+void woal_set_channel_dfs_state(t_u8 channel, t_u8 dfs_state)
+{
+	int index;
+	mlan_ds_11h_chan_dfs_state ch_dfs_state;
+	moal_private *priv;
+	memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+	ch_dfs_state.channel = channel;
+	ch_dfs_state.dfs_state = dfs_state;
+	for (index = 0; index < MAX_MLAN_ADAPTER; index++) {
+		if (m_handle[index]) {
+			priv = woal_get_priv(m_handle[index],
+					     MLAN_BSS_ROLE_UAP);
+			if (priv) {
+				if (woal_11h_chan_dfs_state(priv, MLAN_ACT_SET,
+							    &ch_dfs_state))
+					PRINTM(MERROR,
+					       "Set DFS state for chan:%d failed\n",
+					       ch_dfs_state.channel);
+			}
+		}
+	}
+}
+
+/**
+ * @brief update channel dfs state to all wiphy
+ *
+ * @param priv     Pointer to the moal_private driver data struct
+ * @param channel         given radar channel
+ * @param bandwidth       channel's bandwidth
+ * @param dfs_state       dfs_state
+ *
+ * @return                N/A
+ */
+void woal_update_channels_dfs_state(moal_private *priv, t_u8 channel,
+				    t_u8 bandwidth, t_u8 dfs_state)
+{
+	mlan_ds_11h_chan_dfs_state ch_dfs_state[4];
+	int cfg80211_wext = priv->phandle->params.cfg80211_wext;
+	t_u8 n_chan;
+	int i;
+	ENTER();
+	memset(ch_dfs_state, 0, sizeof(ch_dfs_state));
+	n_chan = woal_uap_get_dfs_chan(channel, bandwidth, &ch_dfs_state[0]);
+	if (IS_UAP_CFG80211(cfg80211_wext)) {
+		for (i = 0; i < n_chan; i++) {
+			woal_update_channel_dfs_state(ch_dfs_state[i].channel,
+						      dfs_state);
+		}
+	}
+	for (i = 0; i < n_chan; i++) {
+		woal_set_channel_dfs_state(ch_dfs_state[i].channel, dfs_state);
+	}
+	LEAVE();
+	return;
+}
+
+/**
+ * @brief reset uap channel dfs_state to DFS_USABLE
+ *
+ * @param priv     Pointer to the moal_private driver data struct
+ *
+ * @return                N/A
+ */
+void woal_update_uap_channel_dfs_state(moal_private *priv)
+{
+	mlan_ds_11h_chan_dfs_state ch_dfs_state;
+	t_u8 channel;
+	t_u8 bandwidth;
+	ENTER();
+	if (woal_is_etsi_country(priv->phandle->country_code)) {
+		LEAVE();
+		return;
+	}
+	if (priv->bss_role == MLAN_BSS_ROLE_UAP && priv->bss_started &&
+	    priv->uap_host_based) {
+		channel = priv->chan.chan->hw_value;
+		memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+		ch_dfs_state.channel = channel;
+		if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+					    &ch_dfs_state)) {
+			PRINTM(MERROR, "%s: woal_11h_chan_dfs_state failed \n",
+			       __func__);
+			LEAVE();
+			return;
+		}
+
+		if (ch_dfs_state.dfs_required &&
+		    ch_dfs_state.dfs_state == DFS_AVAILABLE) {
+			switch (priv->chan.width) {
+			case NL80211_CHAN_WIDTH_40:
+				bandwidth = CHAN_BW_40MHZ;
+				break;
+			case NL80211_CHAN_WIDTH_80:
+				bandwidth = CHAN_BW_80MHZ;
+				break;
+			default:
+				bandwidth = CHAN_BW_20MHZ;
+				break;
+			}
+			woal_update_channels_dfs_state(priv, channel, bandwidth,
+						       DFS_USABLE);
+		}
+	}
+	LEAVE();
+}
+#endif
+#endif
+
+/**
+ * @brief skip cac on specific channel
+ * @and Wext
  *
  *  @param dev      A pointer to net_device structure
  *  @param req      A pointer to ifreq structure
@@ -2051,41 +2339,75 @@ static int woal_uap_dfs_repeater(struct net_device *dev, struct ifreq *req)
  */
 static int woal_uap_skip_cac(struct net_device *dev, struct ifreq *req)
 {
-	moal_private *priv = (moal_private *)netdev_priv(dev);
 	int ret = 0;
 	skip_cac_para param;
-
+	moal_private *priv = (moal_private *)netdev_priv(dev);
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	int cfg80211_wext = priv->phandle->params.cfg80211_wext;
+#endif
+#endif
+	dfs_state_t dfs_state;
+	mlan_ds_11h_chan_dfs_state ch_dfs_state[4];
+	t_u8 n_chan;
+	int i = 0;
 	ENTER();
 
 	/* Sanity check */
 	if (req->ifr_data == NULL) {
-		PRINTM(MERROR, "skip_cac() corrupt data\n");
+		PRINTM(MERROR, "skip_dfs_cac() corrupt data\n");
 		ret = -EFAULT;
 		goto done;
 	}
-
 	memset(&param, 0, sizeof(skip_cac_para));
-
 	/* Get user data */
 	if (copy_from_user(&param, req->ifr_data, sizeof(skip_cac_para))) {
 		PRINTM(MERROR, "Copy from user failed\n");
 		ret = -EFAULT;
 		goto done;
 	}
-
-	/* Currently default action is get */
-	if (param.action == 0) {
-		param.skip_cac = (t_u16)priv->skip_cac;
-	} else {
-		priv->skip_cac = param.skip_cac;
+	if (param.skip_cac)
+		dfs_state = DFS_AVAILABLE;
+	else
+		dfs_state = DFS_USABLE;
+	memset(&ch_dfs_state, 0, sizeof(ch_dfs_state));
+	n_chan = woal_uap_get_dfs_chan(param.channel, param.bw,
+				       &ch_dfs_state[0]);
+	for (i = 0; i < n_chan; i++) {
+		if (woal_11h_chan_dfs_state(priv, MLAN_ACT_GET,
+					    &ch_dfs_state[i]))
+			PRINTM(MERROR, "Get DFS state for chan:%d failed\n",
+			       ch_dfs_state[i].channel);
+	}
+	for (i = 0; i < n_chan; i++) {
+		if (param.skip_cac && ch_dfs_state[i].dfs_state == DFS_USABLE)
+			PRINTM(MMSG,
+			       "DFS: Requst skip cac on the channel %d which hasn't do CAC before!\n",
+			       ch_dfs_state[i].channel);
+		ch_dfs_state[i].dfs_state = dfs_state;
+		if (woal_11h_chan_dfs_state(priv, MLAN_ACT_SET,
+					    &ch_dfs_state[i]))
+			PRINTM(MERROR, "Set DFS state for chan:%d failed\n",
+			       ch_dfs_state[i].channel);
+		else
+			PRINTM(MCMND, "DFS: Skip CAC on chan %d %d\n",
+			       ch_dfs_state[i].channel, param.skip_cac);
 	}
-
-	if (copy_to_user(req->ifr_data, &param, sizeof(skip_cac_para))) {
-		PRINTM(MERROR, "Copy to user failed\n");
-		ret = -EFAULT;
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	if (IS_UAP_CFG80211(cfg80211_wext)) {
+		for (i = 0; i < n_chan; i++) {
+			if (param.skip_cac)
+				woal_update_channel_dfs_state(
+					ch_dfs_state[i].channel, DFS_AVAILABLE);
+			else
+				woal_update_channel_dfs_state(
+					ch_dfs_state[i].channel, DFS_USABLE);
+		}
 	}
+#endif
+#endif
 done:
-
 	LEAVE();
 	return ret;
 }
@@ -2466,7 +2788,12 @@ static int woal_uap_radio_ctl(struct net_device *dev, struct ifreq *req)
 	} else {
 		/* Get radio status */
 		memset(&bss_info, 0, sizeof(bss_info));
-		woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+			PRINTM(MERROR, "ERR: failed in getting bss info\n");
+			ret = -EFAULT;
+			goto done;
+		}
 
 		data[1] = bss_info.radio_on;
 		if (copy_to_user(req->ifr_data, data, sizeof(data))) {
@@ -2658,8 +2985,8 @@ static int woal_uap_set_key_ioctl(struct net_device *dev, struct ifreq *req)
  *
  *  @return                     MLAN_STATUS_SUCCESS -- success, otherwise fail
  */
-int woal_set_get_uap_power_mode(moal_private *priv, t_u32 action,
-				mlan_ds_ps_mgmt *ps_mgmt)
+mlan_status woal_set_get_uap_power_mode(moal_private *priv, t_u32 action,
+					mlan_ds_ps_mgmt *ps_mgmt)
 {
 	mlan_ioctl_req *ioctl_req = NULL;
 	mlan_ds_pm_cfg *pm_cfg = NULL;
@@ -2913,7 +3240,8 @@ static int woal_uap_get_sta_list_ioctl(struct net_device *dev,
 
 	/* Allocate an IOCTL request buffer */
 	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_get_info));
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
@@ -3059,8 +3387,10 @@ static mlan_status woal_enable_wapi(moal_private *priv, t_u8 enable)
 		       "Set AP setting failed! status=%d, error_code=0x%x\n",
 		       status, req->status_code);
 	}
-	if (enable)
-		woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_START);
+	if (enable) {
+		if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_START))
+			PRINTM(MERROR, "%s: uap bss start failed \n", __func__);
+	}
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
@@ -3091,7 +3421,11 @@ static int woal_uap_set_wapi_flag_ioctl(moal_private *priv, wapi_msg *msg)
 
 	ENTER();
 
-	woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP);
+	if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP)) {
+		PRINTM(MERROR, "%s: uap bss stop failed \n", __func__);
+		ret = -EFAULT;
+		goto done;
+	}
 
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
@@ -3201,9 +3535,9 @@ static int woal_uap_set_wapi(struct net_device *dev, struct ifreq *req)
  *
  *  @return         MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_uap_get_bss_param(moal_private *priv,
-				   mlan_uap_bss_param *sys_cfg,
-				   t_u8 wait_option)
+static mlan_status woal_uap_get_bss_param(moal_private *priv,
+					  mlan_uap_bss_param *sys_cfg,
+					  t_u8 wait_option)
 {
 	mlan_ds_bss *info = NULL;
 	mlan_ioctl_req *req = NULL;
@@ -3440,10 +3774,12 @@ int woal_uap_set_11ac_status(moal_private *priv, t_u8 action, t_u8 vht20_40,
  *  @param priv     A pointer to moal_private structure
  *  @param action   MLAN_ACT_SET or MLAN_ACT_GET
  *  @param he_cfg   a pointer to mlan_ds_11ax_he_cfg
+ *  @param wait_option  wait_option
  *
  *  @return         0--success, otherwise failure
  */
-int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg)
+int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg,
+		  t_u8 wait_option)
 {
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
@@ -3461,14 +3797,12 @@ int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg)
 	moal_memcpy_ext(priv->phandle, &cfg_11ax->param.he_cfg, he_cfg,
 			sizeof(mlan_ds_11ax_he_cfg),
 			sizeof(mlan_ds_11ax_he_cfg));
-	status = woal_request_ioctl(priv, req, MOAL_IOCTL_WAIT);
-	if (status != MLAN_STATUS_SUCCESS) {
-		ret = -EFAULT;
-		goto done;
+	status = woal_request_ioctl(priv, req, wait_option);
+	if (status == MLAN_STATUS_SUCCESS) {
+		moal_memcpy_ext(priv->phandle, he_cfg, &cfg_11ax->param.he_cfg,
+				sizeof(mlan_ds_11ax_he_cfg),
+				sizeof(mlan_ds_11ax_he_cfg));
 	}
-	moal_memcpy_ext(priv->phandle, he_cfg, &cfg_11ax->param.he_cfg,
-			sizeof(mlan_ds_11ax_he_cfg),
-			sizeof(mlan_ds_11ax_he_cfg));
 done:
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
@@ -3498,7 +3832,7 @@ int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
 	woal_request_get_fw_info(priv, MOAL_IOCTL_WAIT, &fw_info);
 	if ((band == BAND_5GHZ && !(fw_info.fw_bands & BAND_AAX)) ||
 	    (band == BAND_2GHZ && !(fw_info.fw_bands & BAND_GAX))) {
-		PRINTM(MERROR, "fw doesn't support 11ax\n");
+		//PRINTM(MINFO, "fw doesn't support 11ax\n");
 		ret = -EFAULT;
 		goto done;
 	}
@@ -3512,7 +3846,7 @@ int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
 		ret = -EFAULT;
 		goto done;
 	}
-	if (woal_11ax_cfg(priv, MLAN_ACT_GET, &he_cfg)) {
+	if (woal_11ax_cfg(priv, MLAN_ACT_GET, &he_cfg, MOAL_IOCTL_WAIT)) {
 		PRINTM(MERROR, "Fail to get 11ax cfg!\n");
 		ret = -EFAULT;
 		goto done;
@@ -3527,6 +3861,10 @@ int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
 				&hecap_ie->ext_id, he_cfg.he_cap.len,
 				he_cfg.he_cap.len);
 	}
+#define HE_MAC_CAP_TWT_REQ_SUPPORT MBIT(1)
+	/* uap mode clear TWT request bit */
+	he_cfg.he_cap.he_mac_cap[0] &= ~HE_MAC_CAP_TWT_REQ_SUPPORT;
+
 	if (action == MLAN_ACT_DISABLE) {
 		if (he_cfg.he_cap.len &&
 		    (he_cfg.he_cap.ext_id == HE_CAPABILITY)) {
@@ -3538,7 +3876,7 @@ int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
 		}
 	}
 	DBG_HEXDUMP(MCMD_D, "HE_CFG ", (t_u8 *)&he_cfg, sizeof(he_cfg));
-	ret = woal_11ax_cfg(priv, MLAN_ACT_SET, &he_cfg);
+	ret = woal_11ax_cfg(priv, MLAN_ACT_SET, &he_cfg, MOAL_IOCTL_WAIT);
 done:
 	LEAVE();
 	return ret;
@@ -3553,8 +3891,8 @@ int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
  *
  *  @return         0 --success, otherwise fail
  */
-int woal_uap_ap_cfg_parse_data(moal_private *priv, mlan_uap_bss_param *ap_cfg,
-			       char *buf)
+static int woal_uap_ap_cfg_parse_data(moal_private *priv,
+				      mlan_uap_bss_param *ap_cfg, char *buf)
 {
 	int ret = 0, atoi_ret;
 	int set_sec = 0, set_key = 0, set_chan = 0;
@@ -3773,6 +4111,61 @@ int woal_uap_ap_cfg_parse_data(moal_private *priv, mlan_uap_bss_param *ap_cfg,
 	return ret;
 }
 
+#if defined(UAP_CFG80211)
+#if defined(STA_WEXT) || defined(UAP_WEXT)
+/**
+ *  @brief Set/Get multi AP mode
+ *
+ *  @param priv             A pointer to moal_private structure
+ *  @param wrq              A pointer to structure iwreq
+ *
+ *  @return                  0 --success, otherwise fail
+ */
+int woal_uap_set_get_multi_ap_mode(moal_private *priv, struct iwreq *wrq)
+{
+	int ret = 0;
+	int mode = 0;
+
+	ENTER();
+
+	if (wrq->u.data.length) {
+		if (wrq->u.data.length > 1) {
+			PRINTM(MERROR, "Invalid no of arguments!\n");
+			ret = -EINVAL;
+			goto done;
+		}
+		if (copy_from_user(&mode, wrq->u.data.pointer, sizeof(int))) {
+			PRINTM(MERROR, "copy from user failed\n");
+			ret = -EFAULT;
+			goto done;
+		}
+		if (mode == EASY_MESH_MULTI_AP_BSS_MODE_3)
+			/* Supports backhaul and fronthaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_BH_AND_FH_BSS;
+		else if (mode == EASY_MESH_MULTI_AP_BSS_MODE_2)
+			/* Supports backhaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_BH_BSS;
+		else if (mode == EASY_MESH_MULTI_AP_BSS_MODE_1)
+			/* Supports fronthaul BSS */
+			priv->multi_ap_flag = EASY_MESH_MULTI_AP_FH_BSS;
+	} else {
+		if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_BH_AND_FH_BSS)
+			mode = EASY_MESH_MULTI_AP_BSS_MODE_3;
+		else if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_BH_BSS)
+			mode = EASY_MESH_MULTI_AP_BSS_MODE_2;
+		else if (priv->multi_ap_flag == EASY_MESH_MULTI_AP_FH_BSS)
+			mode = EASY_MESH_MULTI_AP_BSS_MODE_1;
+		wrq->u.data.length = 1;
+		if (copy_to_user(wrq->u.data.pointer, &mode, sizeof(int)))
+			ret = -EFAULT;
+	}
+done:
+	LEAVE();
+	return ret;
+}
+#endif
+#endif
+
 /**
  *  @brief Set AP configuration
  *
@@ -3872,8 +4265,9 @@ int woal_uap_set_ap_cfg(moal_private *priv, t_u8 *data, int len)
  *
  *  @return                 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_set_get_ap_scan_channels(moal_private *priv, t_u16 action,
-					  mlan_uap_scan_channels *scan_channels)
+static mlan_status
+woal_set_get_ap_scan_channels(moal_private *priv, t_u16 action,
+			      mlan_uap_scan_channels *scan_channels)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_bss *bss = NULL;
@@ -3968,7 +4362,7 @@ mlan_status woal_set_get_ap_channel(moal_private *priv, t_u16 action,
  *
  *  @return                 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_start_acs_scan(moal_private *priv)
+static mlan_status woal_start_acs_scan(moal_private *priv)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_ds_bss *bss = NULL;
@@ -4011,7 +4405,7 @@ mlan_status woal_start_acs_scan(moal_private *priv)
  *
  *  @return                 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_do_acs_check(moal_private *priv)
+static mlan_status woal_do_acs_check(moal_private *priv)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_uap_bss_param *sys_config = NULL;
@@ -4101,12 +4495,7 @@ int woal_uap_bss_ctrl(moal_private *priv, t_u8 wait_option, int data)
 	ENTER();
 
 	PRINTM(MIOCTL, "ioctl bss ctrl=%d\n", data);
-	if ((data != UAP_BSS_START) && (data != UAP_BSS_STOP) &&
-	    (data != UAP_BSS_RESET)) {
-		PRINTM(MERROR, "Invalid parameter: %d\n", data);
-		ret = -EINVAL;
-		goto done;
-	}
+
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_bss));
 	if (req == NULL) {
 		ret = -ENOMEM;
@@ -4123,7 +4512,9 @@ int woal_uap_bss_ctrl(moal_private *priv, t_u8 wait_option, int data)
 			   || moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD)
 #endif
 		) {
-			woal_do_acs_check(priv);
+			status = woal_do_acs_check(priv);
+			if (status)
+				PRINTM(MMSG, "woal_do_acs_check fails\n");
 			/* about to start bss: issue channel check */
 			status = woal_11h_channel_check_ioctl(priv,
 							      MOAL_IOCTL_WAIT);
@@ -4164,6 +4555,11 @@ int woal_uap_bss_ctrl(moal_private *priv, t_u8 wait_option, int data)
 		bss->sub_command = MLAN_OID_UAP_BSS_RESET;
 		woal_cancel_cac_block(priv);
 		break;
+	default:
+		PRINTM(MMSG, "We don't support this uap_bss_ctrl cmd %d\n",
+		       data);
+		ret = -EFAULT;
+		goto done;
 	}
 	req->req_id = MLAN_IOCTL_BSS;
 	req->action = MLAN_ACT_SET;
@@ -4178,8 +4574,12 @@ int woal_uap_bss_ctrl(moal_private *priv, t_u8 wait_option, int data)
 		woal_stop_queue(priv->netdev);
 		if (netif_carrier_ok(priv->netdev))
 			netif_carrier_off(priv->netdev);
-		if (data == UAP_BSS_RESET)
-			woal_request_set_mac_address(priv, wait_option);
+		if (data == UAP_BSS_RESET) {
+			if (MLAN_STATUS_FAILURE ==
+			    woal_request_set_mac_address(priv, wait_option))
+				PRINTM(MERROR,
+				       "Fail to set mac address after UAP_BSS_RESET\n");
+		}
 		woal_flush_tcp_sess_queue(priv);
 	}
 done:
@@ -4211,10 +4611,23 @@ void woal_uap_set_multicast_list(struct net_device *dev)
  *
  *  @return         0 --success, otherwise fail
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+int woal_uap_do_ioctl(struct net_device *dev, struct ifreq *req,
+		      void __user *data, int cmd)
+#else
 int woal_uap_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
+#endif
 {
 	int ret = 0;
 	ENTER();
+
+#ifdef CONFIG_COMPAT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+	if (in_compat_syscall()) /* not implemented yet */
+		return -EOPNOTSUPP;
+#endif
+#endif
+
 	switch (cmd) {
 	case WOAL_ANDROID_DEF_CMD:
 		/** android default ioctl ID is SIOCDEVPRIVATE + 1 */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h
old mode 100644
new mode 100755
index d8182c156..1c4d25c95
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap.h
@@ -3,7 +3,7 @@
  * @brief This file contains uap driver specific defines etc.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2022 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -28,9 +28,6 @@ Change log:
 #ifndef _MOAL_UAP_H
 #define _MOAL_UAP_H
 
-/** Maximum buffer length for WOAL_UAP_SET_GET_256_CHAR */
-#define MAX_BUF_LEN 256
-
 /** Private command ID to send ioctl */
 #define UAP_IOCTL_CMD (SIOCDEVPRIVATE + 2)
 /** Updating ADDBA variables */
@@ -201,10 +198,14 @@ typedef struct _cac_timer_status {
 typedef struct _skip_cac_para {
 	/** subcmd */
 	t_u32 subcmd;
-	/** Set/Get */
+	/** Set */
 	t_u32 action;
-	/** enable/disable deepsleep*/
+	/** enable/disable skip cac*/
 	t_u16 skip_cac;
+	/** channel */
+	t_u8 channel;
+	/** bandwidth */
+	t_u8 bw;
 } skip_cac_para;
 
 /** radio control command */
@@ -298,7 +299,7 @@ typedef struct _ds_hs_cfg {
 #define UAP_GET_BSS_TYPE (SIOCDEVPRIVATE + 15)
 
 /** addba_param */
-typedef struct _addba_param {
+typedef struct _uap_addba_param {
 	/** subcmd */
 	t_u32 subcmd;
 	/** Set/Get */
@@ -313,10 +314,10 @@ typedef struct _addba_param {
 	t_u8 txamsdu;
 	/** amsdu for ADDBA response */
 	t_u8 rxamsdu;
-} addba_param;
+} uap_addba_param;
 
 /** aggr_prio_tbl */
-typedef struct _aggr_prio_tbl {
+typedef struct _uap_aggr_prio_tbl {
 	/** subcmd */
 	t_u32 subcmd;
 	/** Set/Get */
@@ -325,7 +326,7 @@ typedef struct _aggr_prio_tbl {
 	t_u8 ampdu[MAX_NUM_TID];
 	/** amsdu priority table */
 	t_u8 amsdu[MAX_NUM_TID];
-} aggr_prio_tbl;
+} uap_aggr_prio_tbl;
 
 /** addba_reject parameters */
 typedef struct _addba_reject_para {
@@ -338,7 +339,7 @@ typedef struct _addba_reject_para {
 } addba_reject_para;
 
 /** fw_info */
-typedef struct _fw_info {
+typedef struct _uap_fw_info {
 	/** subcmd */
 	t_u32 subcmd;
 	/** Get */
@@ -353,7 +354,7 @@ typedef struct _fw_info {
 	t_u16 region_code;
 	/** 802.11n device capabilities */
 	t_u32 hw_dot_11n_dev_cap;
-} fw_info;
+} uap_fw_info;
 
 typedef struct _ht_tx_cfg_para_hdr {
 	/** Sub command */
@@ -481,6 +482,8 @@ typedef struct _snmp_mib_para {
 /** Oid for 802.11H enable/disable */
 #define OID_80211H_ENABLE 0x000a
 
+int woal_uap_11h_ctrl(moal_private *priv, t_u32 enable);
+
 /** dfs_testing parameters */
 typedef struct _dfs_testing_param {
 	/** subcmd */
@@ -495,6 +498,8 @@ typedef struct _dfs_testing_param {
 	t_u8 no_chan_change;
 	/** fixed channel to change to on radar */
 	t_u8 fixed_new_chan;
+	/** CAC restart */
+	t_u8 cac_restart;
 } dfs_testing_para;
 
 /** Channel switch count config */
@@ -526,20 +531,41 @@ typedef struct _domain_info_param {
 #define MAX_DOMAIN_TLV_LEN                                                     \
 	(TLV_HEADER_LEN + COUNTRY_CODE_LEN + (SUB_BAND_LEN * MAX_SUB_BANDS))
 
-int woal_set_get_uap_power_mode(moal_private *priv, t_u32 action,
-				mlan_ds_ps_mgmt *ps_mgmt);
+/** DOMAIN_INFO param size of dfs_region */
+#define DFS_REGION_LEN 1
+/** MAX reg domain TLV length*/
+#define MAX_REG_DOMAIN_TLV_LEN (TLV_HEADER_LEN + DFS_REGION_LEN)
+
+/** Get/Set channel DFS state */
+int woal_11h_chan_dfs_state(moal_private *priv, t_u8 action,
+			    mlan_ds_11h_chan_dfs_state *ch_dfs_state);
+#ifdef UAP_CFG80211
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+void woal_update_channels_dfs_state(moal_private *priv, t_u8 channel,
+				    t_u8 bandwidth, t_u8 dfs_state);
+void woal_update_uap_channel_dfs_state(moal_private *priv);
+#endif
+#endif
+
+mlan_status woal_set_get_uap_power_mode(moal_private *priv, t_u32 action,
+					mlan_ds_ps_mgmt *ps_mgmt);
 void woal_uap_set_multicast_list(struct net_device *dev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 15, 0)
+int woal_uap_do_ioctl(struct net_device *dev, struct ifreq *req,
+		      void __user *data, int cmd);
+#else
 int woal_uap_do_ioctl(struct net_device *dev, struct ifreq *req, int cmd);
+#endif
+
 int woal_uap_bss_ctrl(moal_private *priv, t_u8 wait_option, int data);
-#ifdef UAP_CFG80211
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+
 int woal_uap_get_channel_nop_info(moal_private *priv, t_u8 wait_option,
 				  pmlan_ds_11h_chan_nop_info ch_info);
-#endif
-#endif
+
 mlan_status woal_set_get_ap_channel(moal_private *priv, t_u16 action,
 				    t_u8 wait_option,
-				    pchan_band_info uap_channel);
+				    chan_band_info *uap_channel);
 #ifdef CONFIG_PROC_FS
 void woal_uap_get_version(moal_private *priv, char *version, int max_len);
 #endif
@@ -561,9 +587,17 @@ mlan_status woal_set_get_sys_config(moal_private *priv, t_u16 action,
 mlan_status woal_set_get_ap_wmm_para(moal_private *priv, t_u16 action,
 				     wmm_parameter_t *ap_wmm_para);
 int woal_uap_set_ap_cfg(moal_private *priv, t_u8 *data, int len);
+
+#if defined(UAP_CFG80211)
+#if defined(STA_WEXT) || defined(UAP_WEXT)
+int woal_uap_set_get_multi_ap_mode(moal_private *priv, struct iwreq *wrq);
+#endif
+#endif
+
 int woal_uap_set_11ac_status(moal_private *priv, t_u8 action, t_u8 vht20_40,
 			     IEEEtypes_VHTCap_t *vhtcap_ie);
-int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg);
+int woal_11ax_cfg(moal_private *priv, t_u8 action, mlan_ds_11ax_he_cfg *he_cfg,
+		  t_u8 wait_option);
 int woal_uap_set_11ax_status(moal_private *priv, t_u8 action, t_u8 band,
 			     IEEEtypes_HECap_t *hecap_ie);
 int woal_set_uap_ht_tx_cfg(moal_private *priv, Band_Config_t bandcfg,
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.c
old mode 100644
new mode 100755
index f065de430..b0d9837f6
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.c
@@ -3,7 +3,7 @@
  * @brief This file contains the functions for uAP CFG80211.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2023 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -31,6 +31,7 @@
 /********************************************************
 				Global Variables
 ********************************************************/
+extern const struct net_device_ops woal_uap_netdev_ops;
 /********************************************************
 				Local Functions
 ********************************************************/
@@ -83,6 +84,77 @@ static int woal_deauth_station(moal_private *priv, u8 *mac_addr,
 	return ret;
 }
 
+/**
+ * @brief send deauth to station, that has been added and associated
+ *
+ * @param                 A pointer to moal_private
+ * @param mac			        A pointer to station mac address
+ * @param reason_code     ieee deauth reason code
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_deauth_assoc_station(moal_private *priv, u8 *mac_addr,
+				     u16 reason_code)
+{
+	int ret = 0;
+	int i = 0;
+	mlan_ds_get_info *info = NULL;
+	mlan_ioctl_req *ioctl_req = NULL;
+	mlan_status status = MLAN_STATUS_SUCCESS;
+
+	ENTER();
+
+	if (!mac_addr) {
+		LEAVE();
+		return -EINVAL;
+	}
+
+	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
+	if (ioctl_req == NULL) {
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	info = (mlan_ds_get_info *)ioctl_req->pbuf;
+	info->sub_command = MLAN_OID_UAP_STA_LIST;
+	ioctl_req->req_id = MLAN_IOCTL_GET_INFO;
+	ioctl_req->action = MLAN_ACT_GET;
+
+	status = woal_request_ioctl(priv, ioctl_req, MOAL_IOCTL_WAIT);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+		goto done;
+	}
+	if (!info->param.sta_list.sta_count) {
+		PRINTM(MCMND, "wlan: skip deauth to station " MACSTR "\n",
+		       MAC2STR(mac_addr));
+		goto done;
+	}
+
+	for (i = 0; i < info->param.sta_list.sta_count; i++) {
+		if (!memcmp(info->param.sta_list.info[i].mac_address, mac_addr,
+			    ETH_ALEN)) {
+			PRINTM(MMSG, "wlan: deauth station " MACSTR "\n",
+			       MAC2STR(mac_addr));
+			ret = woal_deauth_station(priv, mac_addr, reason_code);
+#if KERNEL_VERSION(3, 8, 0) <= CFG80211_VERSION_CODE
+			if (moal_extflg_isset(priv->phandle, EXT_HOST_MLME))
+				cfg80211_del_sta(priv->netdev, mac_addr,
+						 GFP_KERNEL);
+#endif
+			break;
+		}
+	}
+
+done:
+	if (status != MLAN_STATUS_PENDING)
+		kfree(ioctl_req);
+
+	LEAVE();
+	return ret;
+}
+
 /**
  * @brief send deauth to all station
  *
@@ -108,7 +180,8 @@ static int woal_deauth_all_station(moal_private *priv)
 	PRINTM(MIOCTL, "del all station\n");
 	/* Allocate an IOCTL request buffer */
 	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_get_info));
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
@@ -154,7 +227,7 @@ static t_u8 woal_check_rsn_ie(IEEEtypes_Rsn_t *rsn_ie,
 	int i = 0;
 	wpa_suite_auth_key_mgmt_t *key_mgmt = NULL;
 	left = rsn_ie->len + 2;
-	if (left < sizeof(IEEEtypes_Rsn_t))
+	if (left < (int)sizeof(IEEEtypes_Rsn_t))
 		return MFALSE;
 	sys_config->wpa_cfg.group_cipher = 0;
 	sys_config->wpa_cfg.pairwise_cipher_wpa2 = 0;
@@ -170,7 +243,10 @@ static t_u8 woal_check_rsn_ie(IEEEtypes_Rsn_t *rsn_ie,
 	default:
 		break;
 	}
-	count = le16_to_cpu(rsn_ie->pairwise_cipher.count);
+	count = woal_le16_to_cpu(rsn_ie->pairwise_cipher.count);
+	if (count < 1)
+		return MFALSE;
+
 	for (i = 0; i < count; i++) {
 		switch (rsn_ie->pairwise_cipher.list[i].type) {
 		case WPA_CIPHER_TKIP:
@@ -185,15 +261,15 @@ static t_u8 woal_check_rsn_ie(IEEEtypes_Rsn_t *rsn_ie,
 		}
 	}
 	left -= sizeof(IEEEtypes_Rsn_t) + (count - 1) * sizeof(wpa_suite);
-	if (left < sizeof(wpa_suite_auth_key_mgmt_t))
+	if (left < (int)sizeof(wpa_suite_auth_key_mgmt_t))
 		return MFALSE;
 	key_mgmt =
 		(wpa_suite_auth_key_mgmt_t *)((u8 *)rsn_ie +
 					      sizeof(IEEEtypes_Rsn_t) +
 					      (count - 1) * sizeof(wpa_suite));
-	count = le16_to_cpu(key_mgmt->count);
-	if (left < (sizeof(wpa_suite_auth_key_mgmt_t) +
-		    (count - 1) * sizeof(wpa_suite)))
+	count = woal_le16_to_cpu(key_mgmt->count);
+	if (left < (int)(sizeof(wpa_suite_auth_key_mgmt_t) +
+			 (count - 1) * sizeof(wpa_suite)))
 		return MFALSE;
 	for (i = 0; i < count; i++) {
 		switch (key_mgmt->list[i].type) {
@@ -233,7 +309,7 @@ static t_u8 woal_check_wpa_ie(IEEEtypes_Wpa_t *wpa_ie,
 	int i = 0;
 	wpa_suite_auth_key_mgmt_t *key_mgmt = NULL;
 	left = wpa_ie->len + 2;
-	if (left < sizeof(IEEEtypes_Wpa_t))
+	if (left < (int)sizeof(IEEEtypes_Wpa_t))
 		return MFALSE;
 	sys_config->wpa_cfg.group_cipher = 0;
 	sys_config->wpa_cfg.pairwise_cipher_wpa = 0;
@@ -247,7 +323,10 @@ static t_u8 woal_check_wpa_ie(IEEEtypes_Wpa_t *wpa_ie,
 	default:
 		break;
 	}
-	count = le16_to_cpu(wpa_ie->pairwise_cipher.count);
+	count = woal_le16_to_cpu(wpa_ie->pairwise_cipher.count);
+	if (count < 1)
+		return MFALSE;
+
 	for (i = 0; i < count; i++) {
 		switch (wpa_ie->pairwise_cipher.list[i].type) {
 		case WPA_CIPHER_TKIP:
@@ -262,15 +341,15 @@ static t_u8 woal_check_wpa_ie(IEEEtypes_Wpa_t *wpa_ie,
 		}
 	}
 	left -= sizeof(IEEEtypes_Wpa_t) + (count - 1) * sizeof(wpa_suite);
-	if (left < sizeof(wpa_suite_auth_key_mgmt_t))
+	if (left < (int)sizeof(wpa_suite_auth_key_mgmt_t))
 		return MFALSE;
 	key_mgmt =
 		(wpa_suite_auth_key_mgmt_t *)((u8 *)wpa_ie +
 					      sizeof(IEEEtypes_Wpa_t) +
 					      (count - 1) * sizeof(wpa_suite));
-	count = le16_to_cpu(key_mgmt->count);
-	if (left < (sizeof(wpa_suite_auth_key_mgmt_t) +
-		    (count - 1) * sizeof(wpa_suite)))
+	count = woal_le16_to_cpu(key_mgmt->count);
+	if (left < (int)(sizeof(wpa_suite_auth_key_mgmt_t) +
+			 (count - 1) * sizeof(wpa_suite)))
 		return MFALSE;
 	for (i = 0; i < count; i++) {
 		switch (key_mgmt->list[i].type) {
@@ -312,8 +391,8 @@ static t_u8 woal_find_wpa_ies(const t_u8 *ie, int len,
 		element_len = *((t_u8 *)pcurrent_ptr + 1);
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 		if (bytes_left < total_ie_len) {
-			PRINTM(MERROR,
-			       "InterpretIE: Error in processing IE, bytes left < IE length\n");
+			//PRINTM(MINFO,
+			  //     "InterpretIE: Error in processing IE, bytes left < IE length\n");
 			bytes_left = 0;
 			continue;
 		}
@@ -377,8 +456,8 @@ static t_void woal_set_wmm_ies(moal_private *priv, const t_u8 *ie, int len,
 		element_len = *((t_u8 *)pcurrent_ptr + 1);
 		total_ie_len = element_len + sizeof(IEEEtypes_Header_t);
 		if (bytes_left < total_ie_len) {
-			PRINTM(MERROR,
-			       "InterpretIE: Error in processing IE, bytes left < IE length\n");
+			//PRINTM(MINFO,
+			  //     "InterpretIE: Error in processing IE, bytes left < IE length\n");
 			bytes_left = 0;
 			continue;
 		}
@@ -426,8 +505,8 @@ static t_void woal_set_wmm_ies(moal_private *priv, const t_u8 *ie, int len,
  * @param params          A pointer to cfg80211_ap_settings structure
  * @return                0 -- success, otherwise fail
  */
-t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band,
-				struct cfg80211_ap_settings *params)
+static t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band,
+				       struct cfg80211_ap_settings *params)
 #else
 /**
  * @brief initialize AP or GO bss config
@@ -435,7 +514,7 @@ t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band,
  * @param priv            A pointer to moal private structure
  * @return                0 -- success, otherwise fail
  */
-t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band)
+static t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band)
 #endif
 {
 	mlan_fw_info fw_info;
@@ -478,8 +557,8 @@ t_u8 woal_check_11ac_capability(moal_private *priv, t_u8 band)
  * @param params          A pointer to cfg80211_ap_settings structure
  * @return                0 -- success, otherwise fail
  */
-t_u8 woal_check_11ax_capability(moal_private *priv, t_u8 band,
-				struct cfg80211_ap_settings *params)
+static t_u8 woal_check_11ax_capability(moal_private *priv, t_u8 band,
+				       struct cfg80211_ap_settings *params)
 {
 	mlan_fw_info fw_info;
 	t_u8 enable_11ax = MFALSE;
@@ -506,12 +585,17 @@ t_u8 woal_check_11ax_capability(moal_private *priv, t_u8 band,
 	else
 		enable_11ax = MFALSE;
 #else
+	if (priv->phandle->params.auto_11ax == 0) {
+		PRINTM(MCMND, "auto_11ax is disabled\n");
+		LEAVE();
+		return enable_11ax;
+	}
 	memset(&he_cfg, 0, sizeof(he_cfg));
 	if (band == BAND_5GHZ)
 		he_cfg.band = MBIT(1);
 	else if (band == BAND_2GHZ)
 		he_cfg.band = MBIT(0);
-	if (0 == woal_11ax_cfg(priv, MLAN_ACT_GET, &he_cfg)) {
+	if (0 == woal_11ax_cfg(priv, MLAN_ACT_GET, &he_cfg, MOAL_IOCTL_WAIT)) {
 		if (he_cfg.he_cap.len &&
 		    (he_cfg.he_cap.ext_id == HE_CAPABILITY)) {
 			if (memcmp(he_cfg.he_cap.he_txrx_mcs_support,
@@ -545,7 +629,8 @@ static t_u16 woal_get_htcap_info(const t_u8 *ie, int len)
 		/* hostap has converted ht_cap_info to little endian, here
 		 * conver to host endian */
 		ht_cap_info = woal_le16_to_cpu(htcap_ie->ht_cap.ht_cap_info);
-		PRINTM(MMSG, "Get ht_cap from beacon ies: 0x%x\n", ht_cap_info);
+		PRINTM(MINFO, "Get ht_cap from beacon ies: 0x%x\n",
+		       ht_cap_info);
 	}
 	return ht_cap_info;
 }
@@ -569,26 +654,54 @@ static IEEEtypes_VHTCap_t *woal_get_vhtcap_info(const t_u8 *ie, int len)
 	return vhtcap_ie;
 }
 
+/**
+ * @brief get vht_oper from beacon ie
+ *
+ * @param ie              Pointer to IEs
+ * @param len             Total length of ie
+ *
+ * @return                Pointer to vht_opr ie
+ */
+static IEEEtypes_VHTOprat_t *woal_get_vht_oprat_ie(const t_u8 *ie, int len)
+{
+	IEEEtypes_VHTOprat_t *vht_oprat_ie = NULL;
+	vht_oprat_ie = (IEEEtypes_VHTOprat_t *)woal_parse_ie_tlv(ie, len,
+								 VHT_OPERATION);
+	if (vht_oprat_ie)
+		PRINTM(MMSG,
+		       "Get vht_oprat_ie from beacon ies: chan_width=%d\n",
+		       vht_oprat_ie->chan_width);
+	return vht_oprat_ie;
+}
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 /** Starting Frequency for 11A band */
 #define START_FREQ_11A_BAND 5000 /* in MHz */
 /**
  * @brief convert cfg80211_chan_def to Band_Config
  *
+ * @param priv            A pointer to moal private structure
  * @param bandcfg         A pointer to (Band_Config_t structure
  * @param chandef         A pointer to cfg80211_chan_def structure
  *
  * @return                N/A
  */
-static void woal_convert_chan_to_bandconfig(Band_Config_t *bandcfg,
+static void woal_convert_chan_to_bandconfig(moal_private *priv,
+					    Band_Config_t *bandcfg,
 					    struct cfg80211_chan_def *chandef)
 {
 	ENTER();
-
-	if (chandef->chan->hw_value <= MAX_BG_CHANNEL)
+	memset(bandcfg, 0, sizeof(Band_Config_t));
+	switch (chandef->chan->band) {
+	case NL80211_BAND_2GHZ:
 		bandcfg->chanBand = BAND_2GHZ;
-	else
+		break;
+	case NL80211_BAND_5GHZ:
 		bandcfg->chanBand = BAND_5GHZ;
+		break;
+	default:
+		break;
+	}
 	switch (chandef->width) {
 	case NL80211_CHAN_WIDTH_20_NOHT:
 	case NL80211_CHAN_WIDTH_20:
@@ -602,8 +715,8 @@ static void woal_convert_chan_to_bandconfig(Band_Config_t *bandcfg,
 			bandcfg->chan2Offset = SEC_CHAN_BELOW;
 		break;
 	case NL80211_CHAN_WIDTH_80:
-		bandcfg->chan2Offset =
-			woal_get_second_channel_offset(chandef->chan->hw_value);
+		bandcfg->chan2Offset = woal_get_second_channel_offset(
+			priv, chandef->chan->hw_value);
 		bandcfg->chanWidth = CHAN_BW_80MHZ;
 		break;
 	case NL80211_CHAN_WIDTH_80P80:
@@ -611,10 +724,16 @@ static void woal_convert_chan_to_bandconfig(Band_Config_t *bandcfg,
 	default:
 		break;
 	}
+	PRINTM(MCMND,
+	       "cfg80211 AP: channel=%d, chanBand=0x%x chanWidth=0x%x chan2Offset=0x%x\n",
+	       chandef->chan->hw_value, bandcfg->chanBand, bandcfg->chanWidth,
+	       bandcfg->chan2Offset);
 	LEAVE();
 	return;
 }
+#endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 /**
  * @brief Enable radar detect for DFS channel
  *
@@ -648,7 +767,7 @@ static void woal_enable_dfs_support(moal_private *priv,
 	pchan_rpt_req = &p11h_cfg->param.chan_rpt_req;
 	pchan_rpt_req->startFreq = 5000;
 	pchan_rpt_req->chanNum = (t_u8)chandef->chan->hw_value;
-	woal_convert_chan_to_bandconfig(&pchan_rpt_req->bandcfg, chandef);
+	woal_convert_chan_to_bandconfig(priv, &pchan_rpt_req->bandcfg, chandef);
 	pchan_rpt_req->host_based = MTRUE;
 	pchan_rpt_req->millisec_dwell_time = 0;
 
@@ -683,9 +802,12 @@ static void woal_set_uap_rates(moal_private *priv, mlan_uap_bss_param *bss_cfg,
 	pIEEEtypes_Header_t ext_rate_ie;
 	int var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
 	const u8 *var_pos = head_ie + var_offset;
-	int len = head_len - var_offset;
+	int len = 0;
 	int rate_len = 0;
 
+	if (var_offset > head_len)
+		return;
+	len = head_len - var_offset;
 	rate_ie = (void *)woal_parse_ie_tlv(var_pos, len, WLAN_EID_SUPP_RATES);
 	if (rate_ie) {
 		memset(bss_cfg->rates, 0, sizeof(bss_cfg->rates));
@@ -753,6 +875,7 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	t_u8 enable_11ac = MFALSE;
 	t_u8 vht20_40 = MFALSE;
 	IEEEtypes_VHTCap_t *vhtcap_ie = NULL;
+	IEEEtypes_VHTOprat_t *vhtopr_ie = NULL;
 	IEEEtypes_HECap_t *hecap_ie = NULL;
 	t_u8 enable_11ax = MFALSE;
 	t_u8 *wapi_ie = NULL;
@@ -761,8 +884,10 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	int GoAgeoutTime = priv->phandle->params.GoAgeoutTime;
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
-	mlan_ds_11h_chan_nop_info chan_nop_info;
 	Band_Config_t bandcfg;
+#endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+	mlan_ds_11h_chan_nop_info chan_nop_info;
 #endif
 	ENTER();
 
@@ -772,17 +897,16 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
 	ie = ((struct cfg80211_ap_settings *)params)->beacon.tail;
-	ie_len = ((struct cfg80211_ap_settings *)params)->beacon.tail_len;
+	ie_len = (int)((struct cfg80211_ap_settings *)params)->beacon.tail_len;
 #else
 	ie = ((struct beacon_parameters *)params)->tail;
-	ie_len = ((struct beacon_parameters *)params)->tail_len;
+	ie_len = (int)((struct beacon_parameters *)params)->tail_len;
 #endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
-	wapi_ie = (t_u8 *)woal_parse_ie_tlv(params->beacon.tail,
-					    params->beacon.tail_len, WAPI_IE);
+	wapi_ie =
+		(t_u8 *)woal_parse_ie_tlv(params->beacon.tail, ie_len, WAPI_IE);
 #else
-	wapi_ie = (t_u8 *)woal_parse_ie_tlv(params->tail, params->tail_len,
-					    WAPI_IE);
+	wapi_ie = (t_u8 *)woal_parse_ie_tlv(params->tail, ie_len, WAPI_IE);
 #endif
 	if (wapi_ie) {
 		wapi_ie_len = *(wapi_ie + 1) + 2;
@@ -865,17 +989,21 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 			sizeof(struct cfg80211_chan_def), sizeof(priv->chan));
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+	woal_convert_chan_to_bandconfig(priv, &bandcfg, &params->chandef);
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 	if (priv->phandle->usr_nop_period_sec) {
 		PRINTM(MCMND, "Checking if AP's channel %d is under NOP\n",
 		       priv->channel);
-		woal_convert_chan_to_bandconfig(&bandcfg, &params->chandef);
 		memset(&chan_nop_info, 0, sizeof(chan_nop_info));
 		chan_nop_info.curr_chan = priv->channel;
 		chan_nop_info.chan_width = bandcfg.chanWidth;
 		if (params->chandef.width >= NL80211_CHAN_WIDTH_20)
 			chan_nop_info.new_chan.is_11n_enabled = MTRUE;
 		chan_nop_info.new_chan.bandcfg = bandcfg;
+		chan_nop_info.check_new_chan = MTRUE;
 		woal_uap_get_channel_nop_info(priv, MOAL_IOCTL_WAIT,
 					      &chan_nop_info);
 		if (chan_nop_info.chan_under_nop) {
@@ -891,6 +1019,7 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 #endif
 
 	if (priv->channel) {
+		woal_check_mc_connection(priv, MOAL_IOCTL_WAIT, priv->channel);
 		memset(sys_config->rates, 0, sizeof(sys_config->rates));
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
@@ -914,8 +1043,8 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 		case NL80211_CHAN_WIDTH_80:
 		case NL80211_CHAN_WIDTH_80P80:
 		case NL80211_CHAN_WIDTH_160:
-			chan2Offset =
-				woal_get_second_channel_offset(priv->channel);
+			chan2Offset = woal_get_second_channel_offset(
+				priv, priv->channel);
 			break;
 		default:
 			PRINTM(MWARN, "Unknown channel width: %d\n",
@@ -961,8 +1090,8 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 		} else {
 			sys_config->bandcfg.chanBand = BAND_5GHZ;
 #if CFG80211_VERSION_CODE < KERNEL_VERSION(3, 6, 0)
-			chan2Offset =
-				woal_get_second_channel_offset(priv->channel);
+			chan2Offset = woal_get_second_channel_offset(
+				priv, priv->channel);
 #endif
 
 #ifdef WIFI_DIRECT_SUPPORT
@@ -970,7 +1099,7 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 			/* Force enable 40MHZ on WFD interface */
 			if (priv->bss_type == MLAN_BSS_TYPE_WIFIDIRECT)
 				chan2Offset = woal_get_second_channel_offset(
-					priv->channel);
+					priv, priv->channel);
 #endif
 #endif
 #ifdef WIFI_DIRECT_SUPPORT
@@ -997,6 +1126,11 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 				   params->head_len, params->tail,
 				   params->tail_len);
 #endif
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+		moal_memcpy_ext(priv->phandle, &sys_config->bandcfg, &bandcfg,
+				sizeof(bandcfg), sizeof(bandcfg));
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
 		enable_11ac = woal_check_11ac_capability(
 			priv, sys_config->bandcfg.chanBand, params);
@@ -1025,32 +1159,30 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 		} else {
 			sys_config->bandcfg.chan2Offset = 0;
 		}
-		if (priv->bss_type == MLAN_BSS_TYPE_UAP) {
-			ht_cap = woal_get_htcap_info(ie, ie_len);
-			if (ht_cap) {
-				if (sys_config->bandcfg.chanBand == BAND_2GHZ)
-					sys_config->ht_cap_info =
-						(ht_cap &
-						 (wiphy->bands[IEEE80211_BAND_2GHZ]
-							  ->ht_cap.cap &
-						  0x13ff)) |
-						0x0c;
-				else
-					sys_config->ht_cap_info =
-						(ht_cap &
-						 (wiphy->bands[IEEE80211_BAND_5GHZ]
-							  ->ht_cap.cap &
-						  0x13ff)) |
-						0x0c;
-			}
-			PRINTM(MCMND,
-			       "11n=%d, ht_cap=0x%x, channel=%d, bandcfg:chanBand=0x%x chanWidth=0x%x chan2Offset=0x%x scanMode=0x%x\n",
-			       enable_11n, sys_config->ht_cap_info,
-			       priv->channel, sys_config->bandcfg.chanBand,
-			       sys_config->bandcfg.chanWidth,
-			       sys_config->bandcfg.chan2Offset,
-			       sys_config->bandcfg.scanMode);
+		ht_cap = woal_get_htcap_info(ie, ie_len);
+		if (ht_cap) {
+			if (sys_config->bandcfg.chanBand == BAND_2GHZ)
+				sys_config->ht_cap_info =
+					(ht_cap &
+					 (wiphy->bands[IEEE80211_BAND_2GHZ]
+						  ->ht_cap.cap &
+					  0x13ff)) |
+					0x0c;
+			else
+				sys_config->ht_cap_info =
+					(ht_cap &
+					 (wiphy->bands[IEEE80211_BAND_5GHZ]
+						  ->ht_cap.cap &
+					  0x13ff)) |
+					0x0c;
 		}
+		PRINTM(MCMND,
+		       "11n=%d, ht_cap=0x%x, channel=%d, bandcfg:chanBand=0x%x chanWidth=0x%x chan2Offset=0x%x scanMode=0x%x\n",
+		       enable_11n, sys_config->ht_cap_info, priv->channel,
+		       sys_config->bandcfg.chanBand,
+		       sys_config->bandcfg.chanWidth,
+		       sys_config->bandcfg.chan2Offset,
+		       sys_config->bandcfg.scanMode);
 	}
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
 	if (!params->ssid || !params->ssid_len) {
@@ -1206,7 +1338,7 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	    (priv->cipher == WLAN_CIPHER_SUITE_WEP104)) {
 		sys_config->protocol = PROTOCOL_STATIC_WEP;
 		sys_config->key_mgmt = KEY_MGMT_NONE;
-		sys_config->.wpa_cfg.length = 0;
+		sys_config->wpa_cfg.length = 0;
 		moal_memcpy_ext(priv->phandle, &sys_config->wep_cfg.key0,
 				&priv->uap_wep_key[0], sizeof(wep_key),
 				sizeof(sys_config->wep_cfg.key0));
@@ -1241,32 +1373,55 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 		/*find and set wmm ie*/
 		woal_set_wmm_ies(priv, ie, ie_len, sys_config);
 	}
-	/* If the security mode is configured as WEP or WPA-PSK,
-	 * it will disable 11n automatically, and if configured as
-	 * open(off) or wpa2-psk, it will automatically enable 11n */
-	if ((sys_config->protocol == PROTOCOL_STATIC_WEP) ||
-	    (sys_config->protocol == PROTOCOL_WPA))
+
+	/** If the security mode is configured as WEP or
+	 * WPA/WPA2 with TKIP only, disable 11n*/
+	if (sys_config->protocol == PROTOCOL_STATIC_WEP)
 		enable_11n = MFALSE;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 2, 0)
+	else if (sys_config->protocol & (PROTOCOL_WPA | PROTOCOL_WPA2)) {
+		if ((params->crypto.wpa_versions & NL80211_WPA_VERSION_1) &&
+		    sys_config->wpa_cfg.pairwise_cipher_wpa == CIPHER_TKIP)
+			enable_11n = MFALSE;
+
+		if ((params->crypto.wpa_versions & NL80211_WPA_VERSION_2) &&
+		    sys_config->wpa_cfg.pairwise_cipher_wpa2 == CIPHER_TKIP)
+			enable_11n = MFALSE;
+	}
+#endif
+
 	if (!enable_11n) {
-		woal_set_uap_ht_tx_cfg(priv, sys_config->bandcfg, ht_cap,
-				       MFALSE);
+		if (woal_set_uap_ht_tx_cfg(priv, sys_config->bandcfg, ht_cap,
+					   MFALSE)) {
+			PRINTM(MMSG, "woal_set_uap_ht_tx_cfg fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		woal_uap_set_11n_status(priv, sys_config, MLAN_ACT_DISABLE);
 	} else {
-		woal_set_uap_ht_tx_cfg(priv, sys_config->bandcfg, ht_cap,
-				       MTRUE);
+		if (woal_set_uap_ht_tx_cfg(priv, sys_config->bandcfg, ht_cap,
+					   MTRUE)) {
+			PRINTM(MMSG, "woal_set_uap_ht_tx_cfg fail\n");
+			ret = -EFAULT;
+			goto done;
+		}
 		woal_uap_set_11n_status(priv, sys_config, MLAN_ACT_ENABLE);
 		woal_set_get_tx_bf_cap(priv, MLAN_ACT_GET,
 				       &sys_config->tx_bf_cap);
 	}
 	if (enable_11ac && enable_11n) {
 		vhtcap_ie = woal_get_vhtcap_info(ie, ie_len);
+		vhtopr_ie = woal_get_vht_oprat_ie(ie, ie_len);
+		// Enable VHT80
+		if (vhtopr_ie && vhtopr_ie->chan_width)
+			vht20_40 = 0;
 		woal_uap_set_11ac_status(priv, MLAN_ACT_ENABLE, vht20_40,
 					 vhtcap_ie);
 	} else {
 		woal_uap_set_11ac_status(priv, MLAN_ACT_DISABLE, vht20_40,
 					 NULL);
 	}
-	if (enable_11ax && enable_11n) {
+	if (enable_11ax) {
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 20, 0)
 		hecap_ie = (IEEEtypes_HECap_t *)woal_parse_ext_ie_tlv(
 			ie, ie_len, HE_CAPABILITY);
@@ -1289,12 +1444,30 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	       sys_config->sta_ageout_timer, sys_config->ps_sta_ageout_timer);
 #endif
 
+	if (priv->multi_ap_flag) {
+		sys_config->multi_ap_flag = priv->multi_ap_flag;
+		PRINTM(MINFO, "%s: multi_ap_flag is 0x%x\n", __func__,
+		       sys_config->multi_ap_flag);
+	}
 	if (MLAN_STATUS_SUCCESS != woal_set_get_sys_config(priv, MLAN_ACT_SET,
 							   MOAL_IOCTL_WAIT,
 							   sys_config)) {
 		ret = -EFAULT;
 		goto done;
 	}
+
+	/** Set wacp_mode for uAP/P2P-GO */
+	if (priv->phandle->params.wacp_mode) {
+		PRINTM(MIOCTL, "wacp_mode: %d\n",
+		       priv->phandle->params.wacp_mode);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_set_wacp_mode(priv, MOAL_IOCTL_WAIT)) {
+			PRINTM(MERROR, "Set wacp_mode failed\n");
+			ret = -EFAULT;
+			goto done;
+		}
+	}
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 	woal_enable_dfs_support(priv, &priv->chan);
 #endif
@@ -1304,6 +1477,323 @@ static int woal_cfg80211_beacon_config(moal_private *priv,
 	return ret;
 }
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+/**
+ * @brief Request the driver to add a monitor interface
+ *
+ * @param wiphy             A pointer to wiphy structure
+ * @param name              Virtual interface name
+ * @param name_assign_type  Interface name assignment type
+ * @param flags             Flags for the virtual interface
+ * @param params            A pointer to vif_params structure
+ * @param new_dev           Netdevice to be passed out
+ *
+ * @return                  0 -- success, otherwise fail
+ */
+static int woal_cfg80211_add_mon_if(struct wiphy *wiphy, const char *name,
+				    unsigned char name_assign_type, u32 *flags,
+				    struct vif_params *params,
+				    struct net_device **new_dev)
+#else
+/**
+ * @brief Request the driver to add a monitor interface
+ *
+ * @param wiphy           A pointer to wiphy structure
+ * @param name            Virtual interface name
+ * @param flags           Flags for the virtual interface
+ * @param params          A pointer to vif_params structure
+ * @param new_dev         Netdevice to be passed out
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_cfg80211_add_mon_if(struct wiphy *wiphy,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+				    const
+#endif
+				    char *name,
+				    u32 *flags, struct vif_params *params,
+				    struct net_device **new_dev)
+#endif
+{
+	int ret = 0;
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+	moal_private *priv =
+		(moal_private *)woal_get_priv(handle, MLAN_BSS_ROLE_STA);
+	monitor_iface *mon_if = NULL;
+	struct net_device *ndev = NULL;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	chan_band_info chan_info;
+#endif
+	unsigned char name_assign_type_tmp = 0;
+
+	ENTER();
+
+	ASSERT_RTNL();
+
+	if (handle->mon_if) {
+		PRINTM(MERROR, "%s: monitor interface exist: %s basedev %s\n",
+		       __func__, handle->mon_if->mon_ndev->name,
+		       handle->mon_if->base_ndev->name);
+		ret = -EFAULT;
+		goto fail;
+	}
+	if (!priv) {
+		PRINTM(MERROR, "add_mon_if: priv is NULL\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+	name_assign_type_tmp = name_assign_type;
+#endif
+	mon_if = woal_prepare_mon_if(priv, name, name_assign_type_tmp);
+	if (!mon_if) {
+		PRINTM(MFATAL, "Prepare mon_if fail.\n");
+		goto fail;
+	}
+	ndev = mon_if->mon_ndev;
+	dev_net_set(ndev, wiphy_net(wiphy));
+
+	moal_memcpy_ext(priv->phandle, ndev->perm_addr, wiphy->perm_addr,
+			ETH_ALEN, sizeof(ndev->perm_addr));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
+	eth_hw_addr_set(ndev, ndev->perm_addr);
+#else
+	moal_memcpy_ext(priv->phandle, ndev->dev_addr, ndev->perm_addr,
+			ETH_ALEN, MAX_ADDR_LEN);
+#endif
+	SET_NETDEV_DEV(ndev, wiphy_dev(wiphy));
+	ndev->ieee80211_ptr = &mon_if->wdev;
+	mon_if->wdev.iftype = NL80211_IFTYPE_MONITOR;
+	mon_if->wdev.wiphy = wiphy;
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+	memset(&chan_info, 0x00, sizeof(chan_info));
+	mon_if->band_chan_cfg.channel = 0;
+	if (!woal_is_any_interface_active(handle)) {
+		/* Set default band channel config */
+		mon_if->band_chan_cfg.band = BAND_B | BAND_G;
+		mon_if->band_chan_cfg.band |= BAND_GN;
+		mon_if->band_chan_cfg.channel = 1;
+		mon_if->band_chan_cfg.chan_bandwidth = CHANNEL_BW_20MHZ;
+		memset(&chan_info, 0x00, sizeof(chan_info));
+		chan_info.channel = 1;
+		chan_info.is_11n_enabled = MTRUE;
+	}
+	mon_if->flag = handle->params.mon_filter;
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_set_net_monitor(priv, MOAL_IOCTL_WAIT, MTRUE, mon_if->flag,
+				 &mon_if->band_chan_cfg)) {
+		PRINTM(MERROR, "%s: woal_set_net_monitor fail\n", __func__);
+		ret = -EFAULT;
+		goto fail;
+	}
+	if (woal_is_any_interface_active(handle)) {
+		/* set current band channel config */
+		chan_info.bandcfg.chanBand = mon_if->band_chan_cfg.band;
+		if (mon_if->band_chan_cfg.band &
+		    (BAND_B | BAND_G | BAND_GN | BAND_GAC))
+			chan_info.bandcfg.chanBand = BAND_2GHZ;
+		else
+			/* TODO: Add support for BAND_4GHZ */
+			chan_info.bandcfg.chanBand = BAND_5GHZ;
+		chan_info.bandcfg.chanWidth =
+			mon_if->band_chan_cfg.chan_bandwidth;
+		chan_info.channel = mon_if->band_chan_cfg.channel;
+		chan_info.is_11n_enabled = MTRUE;
+	}
+	if (MLAN_STATUS_FAILURE ==
+	    woal_chandef_create(priv, &mon_if->chandef, &chan_info)) {
+		/* stop monitor mode on error */
+		woal_set_net_monitor(priv, MOAL_IOCTL_WAIT, MFALSE, 0, NULL);
+		ret = -EFAULT;
+		goto fail;
+	}
+#endif
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	ret = cfg80211_register_netdevice(ndev);
+#else
+	ret = register_netdevice(ndev);
+#endif
+
+	if (ret) {
+		PRINTM(MFATAL, "register net_device failed, ret=%d\n", ret);
+		free_netdev(ndev);
+		goto fail;
+	}
+
+	handle->mon_if = mon_if;
+
+	if (new_dev)
+		*new_dev = ndev;
+
+fail:
+	LEAVE();
+	return ret;
+}
+
+/**
+ *  @brief This function setup the multi-ap virtual interface
+ *
+ *  @param dev    A pointer to structure net_device
+ *
+ *  @return       N/A
+ */
+static void woal_vlan_virt_if_setup(struct net_device *dev)
+{
+	ENTER();
+	ether_setup(dev);
+	dev->netdev_ops = &woal_uap_netdev_ops;
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 11, 9)
+	dev->needs_free_netdev = true;
+#else
+	dev->destructor = free_netdev;
+#endif
+	LEAVE();
+}
+
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+/**
+ * @brief Request the driver to add a multi-ap virtual interface
+ *
+ * @param wiphy             A pointer to wiphy structure
+ * @param name              Virtual interface name
+ * @param name_assign_type  Interface name assignment type
+ * @param flags             Flags for the virtual interface
+ * @param params            A pointer to vif_params structure
+ * @param new_dev		    new net_device to return
+ *
+ * @return                  0 -- success, otherwise fail
+ */
+static int woal_cfg80211_add_vlan_vir_if(struct wiphy *wiphy, const char *name,
+					 unsigned char name_assign_type,
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+					 u32 *flags,
+#endif
+					 struct vif_params *params,
+					 struct net_device **new_dev)
+#else
+/**
+ * @brief Request the driver to add a multi-ap virtual interface
+ *
+ * @param wiphy           A pointer to wiphy structure
+ * @param name            Virtual interface name
+ * @param flags           Flags for the virtual interface
+ * @param params          A pointer to vif_params structure
+ * @param new_dev		  new net_device to return
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_cfg80211_add_vlan_vir_if(struct wiphy *wiphy,
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)
+					 const
+#endif
+					 char *name,
+					 u32 *flags, struct vif_params *params,
+					 struct net_device **new_dev)
+#endif
+{
+	int ret = 0;
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+	moal_private *priv =
+		(moal_private *)woal_get_priv(handle, MLAN_BSS_ROLE_UAP);
+	moal_private *new_priv = NULL;
+	struct net_device *ndev = NULL;
+
+	ENTER();
+	ASSERT_RTNL();
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+#ifndef MAX_WMM_QUEUE
+#define MAX_WMM_QUEUE 4
+#endif
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 29)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+	ndev = alloc_netdev_mq(sizeof(moal_private), name, name_assign_type,
+			       woal_vlan_virt_if_setup, 1);
+#else
+	ndev = alloc_netdev_mq(sizeof(moal_private), name, NET_NAME_UNKNOWN,
+			       woal_vlan_virt_if_setup, 1);
+#endif
+#else
+	ndev = alloc_netdev_mq(sizeof(moal_private), name,
+			       woal_vlan_virt_if_setup, 1);
+#endif
+#else
+	ndev = alloc_netdev_mq(sizeof(moal_private), name,
+			       woal_vlan_virt_if_setup);
+#endif
+	if (!ndev) {
+		PRINTM(MFATAL, "Init virtual ethernet device failed\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+	ret = dev_alloc_name(ndev, ndev->name);
+	if (ret < 0) {
+		PRINTM(MFATAL, "Net device alloc name fail.\n");
+		ret = -EFAULT;
+		goto fail;
+	}
+
+	dev_net_set(ndev, wiphy_net(wiphy));
+
+	moal_memcpy_ext(handle, ndev->perm_addr, wiphy->perm_addr, ETH_ALEN,
+			sizeof(ndev->perm_addr));
+	moal_memcpy_ext(handle, ndev->perm_addr, priv->current_addr, ETH_ALEN,
+			sizeof(ndev->perm_addr));
+	moal_memcpy_ext(handle, (t_void *)ndev->dev_addr, ndev->perm_addr,
+			ETH_ALEN, MAX_ADDR_LEN);
+
+	SET_NETDEV_DEV(ndev, wiphy_dev(wiphy));
+	ndev->watchdog_timeo = MRVDRV_DEFAULT_UAP_WATCHDOG_TIMEOUT;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	ndev->needed_headroom += MLAN_MIN_DATA_HEADER_LEN +
+				 sizeof(mlan_buffer) + priv->extra_tx_head_len;
+#else
+	ndev->hard_header_len += MLAN_MIN_DATA_HEADER_LEN +
+				 sizeof(mlan_buffer) + priv->extra_tx_head_len;
+#endif
+
+	ndev->flags |= IFF_BROADCAST | IFF_MULTICAST;
+
+	new_priv = netdev_priv(ndev);
+
+	ndev->ieee80211_ptr = &new_priv->w_dev;
+
+	new_priv->wdev = &new_priv->w_dev;
+	new_priv->netdev = ndev;
+	new_priv->extra_tx_head_len = priv->extra_tx_head_len;
+
+	moal_memcpy_ext(priv->phandle, new_priv->current_addr,
+			priv->current_addr, ETH_ALEN, ETH_ALEN);
+
+	new_priv->phandle = handle;
+	new_priv->wdev->wiphy = handle->wiphy;
+	new_priv->bss_type = MLAN_BSS_TYPE_UAP;
+	new_priv->bss_role = MLAN_BSS_ROLE_UAP;
+	new_priv->bss_index = priv->bss_index;
+	new_priv->parent_priv = priv;
+	new_priv->wdev->iftype = NL80211_IFTYPE_AP_VLAN;
+
+	ndev->ieee80211_ptr->use_4addr = params->use_4addr;
+
+	ret = register_netdevice(ndev);
+	if (ret) {
+		PRINTM(MFATAL, "register net_device failed, ret=%d\n", ret);
+		free_netdev(ndev);
+		goto fail;
+	}
+
+	if (new_dev)
+		*new_dev = ndev;
+fail:
+	LEAVE();
+	return ret;
+}
+
 #ifdef WIFI_DIRECT_SUPPORT
 #if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
 /**
@@ -1338,9 +1828,10 @@ static void woal_virt_if_setup(struct net_device *dev)
  *
  *  @return                 A pointer to the new priv structure
  */
-moal_private *woal_alloc_virt_interface(moal_handle *handle, t_u8 bss_index,
-					unsigned char name_assign_type,
-					t_u8 bss_type, const char *name)
+static moal_private *woal_alloc_virt_interface(moal_handle *handle,
+					       t_u8 bss_index,
+					       unsigned char name_assign_type,
+					       t_u8 bss_type, const char *name)
 #else
 /**
  * @brief This function adds a new interface. It will
@@ -1410,6 +1901,9 @@ moal_private *woal_alloc_virt_interface(moal_handle *handle, t_u8 bss_index,
 
 	INIT_LIST_HEAD(&priv->tx_stat_queue);
 	spin_lock_init(&priv->tx_stat_lock);
+	INIT_LIST_HEAD(&priv->mcast_list);
+	spin_lock_init(&priv->mcast_lock);
+
 	spin_lock_init(&priv->connect_lock);
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
@@ -1441,11 +1935,11 @@ moal_private *woal_alloc_virt_interface(moal_handle *handle, t_u8 bss_index,
  *
  * @return                  0 -- success, otherwise fail
  */
-int woal_cfg80211_add_virt_if(struct wiphy *wiphy, const char *name,
-			      unsigned char name_assign_type,
-			      enum nl80211_iftype type, u32 *flags,
-			      struct vif_params *params,
-			      struct net_device **new_dev)
+static int woal_cfg80211_add_virt_if(struct wiphy *wiphy, const char *name,
+				     unsigned char name_assign_type,
+				     enum nl80211_iftype type, u32 *flags,
+				     struct vif_params *params,
+				     struct net_device **new_dev)
 #else
 /**
  * @brief Request the driver to add a virtual interface
@@ -1545,21 +2039,46 @@ int woal_cfg80211_add_virt_if(struct wiphy *wiphy,
 	new_priv->bss_virtual = MTRUE;
 	new_priv->pa_netdev = priv->netdev;
 
+	/* Create workqueue for main process */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 36)
+	new_priv->mclist_workqueue =
+		alloc_workqueue("MCLIST_WORK_QUEUE",
+				WQ_HIGHPRI | WQ_MEM_RECLAIM | WQ_UNBOUND, 1);
+#else
+	new_priv->mclist_workqueue = create_workqueue("MCLIST_WORK_QUEUE");
+#endif
+	if (!new_priv->mclist_workqueue) {
+		PRINTM(MERROR, "cannot alloc mclist workqueue \n");
+		return -EFAULT;
+	}
+	MLAN_INIT_WORK(&new_priv->mclist_work, woal_mclist_work_queue);
+
 	woal_init_sta_dev(ndev, new_priv);
 
 	/* Initialize priv structure */
 	woal_init_priv(new_priv, MOAL_IOCTL_WAIT);
 	/** Init to GO/CLIENT mode */
-	if (type == NL80211_IFTYPE_P2P_CLIENT)
-		woal_cfg80211_init_p2p_client(new_priv);
-	else if (type == NL80211_IFTYPE_P2P_GO)
-		woal_cfg80211_init_p2p_go(new_priv);
+	if (type == NL80211_IFTYPE_P2P_CLIENT) {
+		if (woal_cfg80211_init_p2p_client(new_priv))
+			PRINTM(MERROR, "%s: Fail to init p2p go", __func__);
+	} else if (type == NL80211_IFTYPE_P2P_GO) {
+		if (woal_cfg80211_init_p2p_go(new_priv))
+			PRINTM(MERROR, "%s: Fail to init p2p client", __func__);
+	}
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+	ret = cfg80211_register_netdevice(ndev);
+#else
 	ret = register_netdevice(ndev);
+#endif
 	if (ret) {
 		handle->priv[new_priv->bss_index] = NULL;
 		handle->priv_num--;
 		if (ndev->reg_state == NETREG_REGISTERED) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+			cfg80211_unregister_netdevice(ndev);
+#else
 			unregister_netdevice(ndev);
+#endif
 			free_netdev(ndev);
 			ndev = NULL;
 		}
@@ -1587,7 +2106,7 @@ int woal_cfg80211_add_virt_if(struct wiphy *wiphy,
  *  @return              MLAN_STATUS_SUCCESS/MLAN_STATUS_PENDING -- success,
  * otherwise fail
  */
-mlan_status woal_bss_remove(moal_private *priv)
+static mlan_status woal_bss_remove(moal_private *priv)
 {
 	mlan_ioctl_req *req = NULL;
 	mlan_ds_bss *bss = NULL;
@@ -1682,6 +2201,7 @@ int woal_cfg80211_del_virt_if(struct wiphy *wiphy, struct net_device *dev)
 		woal_cancel_scan(vir_priv, MOAL_IOCTL_WAIT);
 
 		woal_flush_tx_stat_queue(vir_priv);
+		woal_flush_mcast_list(vir_priv);
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 		/* cancel previous remain on channel to avoid firmware hang */
@@ -1716,7 +2236,11 @@ int woal_cfg80211_del_virt_if(struct wiphy *wiphy, struct net_device *dev)
 			}
 		}
 #endif
-
+		if (vir_priv->mclist_workqueue) {
+			flush_workqueue(vir_priv->mclist_workqueue);
+			destroy_workqueue(vir_priv->mclist_workqueue);
+			vir_priv->mclist_workqueue = NULL;
+		}
 		woal_clear_all_mgmt_ies(vir_priv, MOAL_IOCTL_WAIT);
 		woal_cfg80211_deinit_p2p(vir_priv);
 		woal_bss_remove(vir_priv);
@@ -1736,14 +2260,17 @@ int woal_cfg80211_del_virt_if(struct wiphy *wiphy, struct net_device *dev)
 		vir_priv->phandle->priv[vir_priv->bss_index] = NULL;
 		priv->phandle->priv_num--;
 		if (dev->reg_state == NETREG_REGISTERED)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+			cfg80211_unregister_netdevice(dev);
+#else
 			unregister_netdevice(dev);
+#endif
 	}
 	return ret;
 }
 #endif
 #endif
 
-#if defined(WIFI_DIRECT_SUPPORT)
 /**
  *  @brief This function removes an virtual interface.
  *
@@ -1775,20 +2302,30 @@ void woal_remove_virtual_interface(moal_handle *handle)
 				netif_device_detach(priv->netdev);
 				if (priv->netdev->reg_state ==
 				    NETREG_REGISTERED)
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 12, 0)
+					cfg80211_unregister_netdevice(
+						priv->netdev);
+#else
 					unregister_netdevice(priv->netdev);
+#endif
 				handle->priv[i] = NULL;
 				vir_intf++;
 			}
 		}
 	}
 #endif
+	if (handle->mon_if) {
+		netif_device_detach(handle->mon_if->mon_ndev);
+		if (handle->mon_if->mon_ndev->reg_state == NETREG_REGISTERED)
+			unregister_netdevice(handle->mon_if->mon_ndev);
+		handle->mon_if = NULL;
+	}
 	rtnl_unlock();
 #ifdef WIFI_DIRECT_SUPPORT
 	handle->priv_num -= vir_intf;
 #endif
 	LEAVE();
 }
-#endif
 
 /**
  *  @brief This function check if uap interface is ready
@@ -1901,15 +2438,22 @@ woal_cfg80211_add_virtual_intf(struct wiphy *wiphy, const char *name,
 {
 	struct net_device *ndev = NULL;
 	int ret = 0;
-#if defined(WIFI_DIRECT_SUPPORT)
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
 	u32 *flags = &params->flags;
-#endif
 #endif
 
 	ENTER();
 	PRINTM(MIOCTL, "add virtual intf: %d name: %s\n", type, name);
 	switch (type) {
+	case NL80211_IFTYPE_MONITOR:
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+		ret = woal_cfg80211_add_mon_if(wiphy, name, name_assign_type,
+					       flags, params, &ndev);
+#else
+		ret = woal_cfg80211_add_mon_if(wiphy, name, flags, params,
+					       &ndev);
+#endif
+		break;
 #ifdef WIFI_DIRECT_SUPPORT
 #if CFG80211_VERSION_CODE >= WIFI_DIRECT_KERNEL_VERSION
 	case NL80211_IFTYPE_P2P_CLIENT:
@@ -1932,6 +2476,20 @@ woal_cfg80211_add_virtual_intf(struct wiphy *wiphy, const char *name,
 			ret = -EFAULT;
 		}
 		break;
+	case NL80211_IFTYPE_AP_VLAN:
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(4, 1, 0)
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+		ret = woal_cfg80211_add_vlan_vir_if(
+			wiphy, name, name_assign_type, flags, params, &ndev);
+#else
+		ret = woal_cfg80211_add_vlan_vir_if(
+			wiphy, name, name_assign_type, params, &ndev);
+#endif
+#else
+		ret = woal_cfg80211_add_vlan_vir_if(wiphy, name, flags, params,
+						    &ndev);
+#endif
+		break;
 	default:
 		PRINTM(MWARN, "Not supported if type: %d\n", type);
 		ret = -EFAULT;
@@ -1987,10 +2545,53 @@ int woal_cfg80211_del_virtual_intf(struct wiphy *wiphy,
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 6, 0)
 	struct net_device *dev = wdev->netdev;
 #endif
+
+	moal_private *vlan_priv = NULL;
+	t_u16 aid = 0;
+
 	ENTER();
 
 	PRINTM(MIOCTL, "del virtual intf %s\n", dev->name);
 	ASSERT_RTNL();
+	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_MONITOR) {
+		if ((handle->mon_if) && (handle->mon_if->mon_ndev == dev)) {
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 8, 0)
+			if (MLAN_STATUS_SUCCESS !=
+			    woal_set_net_monitor(handle->mon_if->priv,
+						 MOAL_IOCTL_WAIT, MFALSE, 0,
+						 NULL)) {
+				PRINTM(MERROR,
+				       "%s: woal_set_net_monitor fail\n",
+				       __func__);
+				ret = -EFAULT;
+			}
+#endif
+			handle->mon_if = NULL;
+		}
+		unregister_netdevice(dev);
+		LEAVE();
+		return ret;
+	}
+
+#ifdef UAP_SUPPORT
+	/**
+	 * For multi-ap virtual interface, unregister netdevice
+	 * directly for now. Will add more in the future.
+	 */
+	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP_VLAN) {
+		/* stop network before doing cleanup */
+		if (netif_carrier_ok(dev))
+			netif_carrier_off(dev);
+		vlan_priv = (moal_private *)netdev_priv(dev);
+		aid = vlan_priv->vlan_sta_ptr->aid;
+		PRINTM(MCMND, "wlan: Easymesh del Vlan aid=%d\n", aid);
+		vlan_priv->parent_priv->vlan_sta_list[(aid - 1) % MAX_STA_COUNT]
+			->is_valid = MFALSE;
+		unregister_netdevice(dev);
+		LEAVE();
+		return ret;
+	}
+#endif
 
 	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP) {
 		for (i = 0; i < handle->priv_num; i++) {
@@ -2005,15 +2606,38 @@ int woal_cfg80211_del_virtual_intf(struct wiphy *wiphy,
 			}
 		}
 		if (vir_priv && vir_priv->bss_type == MLAN_BSS_TYPE_UAP) {
-			woal_cfg80211_del_beacon(wiphy, dev);
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			if (woal_cfg80211_del_beacon(wiphy, dev, 0))
+#else
+			if (woal_cfg80211_del_beacon(wiphy, dev))
+#endif
+				PRINTM(MERROR, "%s: del_beacon failed\n",
+				       __func__);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			vir_priv->wdev->links[0].ap.beacon_interval = 0;
+#else
 			vir_priv->wdev->beacon_interval = 0;
+#endif
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			memset(&vir_priv->wdev->links[0].ap.chandef, 0,
+			       sizeof(vir_priv->wdev->links[0].ap.chandef));
+#else
 			memset(&vir_priv->wdev->chandef, 0,
 			       sizeof(vir_priv->wdev->chandef));
 #endif
 #endif
+#endif
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+			vir_priv->wdev->u.ap.ssid_len = 0;
+#else
 			vir_priv->wdev->ssid_len = 0;
+#endif
 			PRINTM(MMSG, "Skip del UAP virtual interface %s",
 			       dev->name);
 		}
@@ -2188,8 +2812,8 @@ int woal_cfg80211_add_beacon(struct wiphy *wiphy, struct net_device *dev,
 		if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD))
 			wait_option = MOAL_NO_WAIT;
 #endif
-		if (MLAN_STATUS_SUCCESS !=
-		    woal_uap_bss_ctrl(priv, wait_option, UAP_BSS_START)) {
+		if (woal_uap_bss_ctrl(priv, wait_option, UAP_BSS_START)) {
+			PRINTM(MERROR, "%s: start uap failed \n", __func__);
 			priv->uap_host_based = MFALSE;
 			ret = -EFAULT;
 			goto done;
@@ -2288,13 +2912,20 @@ int woal_cfg80211_set_beacon(struct wiphy *wiphy, struct net_device *dev,
  *
  * @return                0 -- success, otherwise fail
  */
+#if ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) || IMX_ANDROID_13 ||  \
+     IMX_ANDROID_12_BACKPORT)
+int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev,
+			     unsigned int link_id)
+#else
 int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev)
+#endif
 {
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	int ret = 0;
 #ifdef STA_SUPPORT
 	moal_private *pmpriv = NULL;
 #endif
+	int i;
 
 	ENTER();
 
@@ -2322,7 +2953,9 @@ int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev)
 		woal_cancel_timer(&priv->phandle->cac_timer);
 		priv->phandle->is_cac_timer_set = MFALSE;
 		/* Make sure Chan Report is cancelled */
-		woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT);
+		if (woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR, "%s: cancel chan report failed \n",
+			       __func__);
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
 		cfg80211_cac_event(priv->netdev, &priv->phandle->dfs_channel,
 				   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
@@ -2339,39 +2972,53 @@ int woal_cfg80211_del_beacon(struct wiphy *wiphy, struct net_device *dev)
 #endif
 	/* if the bss is still running, then stop it */
 	if (priv->bss_started == MTRUE) {
-		if (MLAN_STATUS_FAILURE ==
-		    woal_uap_bss_ctrl(priv, MOAL_NO_WAIT, UAP_BSS_STOP)) {
-			ret = -EFAULT;
+		if (woal_uap_bss_ctrl(priv, MOAL_NO_WAIT, UAP_BSS_STOP)) {
+			PRINTM(MERROR, "%s: stop uap failed \n", __func__);
 			goto done;
 		}
-		if (MLAN_STATUS_FAILURE ==
-		    woal_uap_bss_ctrl(priv, MOAL_NO_WAIT, UAP_BSS_RESET)) {
-			ret = -EFAULT;
+		if (woal_uap_bss_ctrl(priv, MOAL_NO_WAIT, UAP_BSS_RESET)) {
+			PRINTM(MERROR, "%s: reset uap failed \n", __func__);
 			goto done;
 		}
 		/* Set WLAN MAC addresses */
 		if (MLAN_STATUS_FAILURE ==
 		    woal_request_set_mac_address(priv, MOAL_NO_WAIT)) {
 			PRINTM(MERROR, "Set MAC address failed\n");
-			ret = -EFAULT;
 			goto done;
 		}
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		woal_cfg80211_setup_uap_he_cap(priv, MOAL_NO_WAIT);
+#endif
 	}
 	woal_clear_all_mgmt_ies(priv, MOAL_NO_WAIT);
 #ifdef STA_SUPPORT
 	if (!woal_is_any_interface_active(priv->phandle)) {
 		pmpriv = woal_get_priv((moal_handle *)priv->phandle,
 				       MLAN_BSS_ROLE_STA);
-		if (pmpriv)
+		if (pmpriv && !priv->phandle->user_scan_cfg) {
 			woal_set_scan_time(pmpriv, ACTIVE_SCAN_CHAN_TIME,
 					   PASSIVE_SCAN_CHAN_TIME,
 					   SPECIFIC_SCAN_CHAN_TIME);
+		}
 	}
 #endif
 
 	priv->cipher = 0;
 	memset(priv->uap_wep_key, 0, sizeof(priv->uap_wep_key));
 	priv->channel = 0;
+#ifdef UAP_SUPPORT
+	priv->multi_ap_flag = 0;
+	/* Clear the whole backhaul station list in moal */
+	for (i = 0; i < MAX_STA_COUNT; i++) {
+		if (priv->vlan_sta_list[i]) {
+			if (priv->vlan_sta_list[i]->is_valid)
+				unregister_netdevice(
+					priv->vlan_sta_list[i]->netdev);
+			kfree(priv->vlan_sta_list[i]);
+		}
+		priv->vlan_sta_list[i] = NULL;
+	}
+#endif
 	PRINTM(MMSG, "wlan: AP stopped\n");
 done:
 	LEAVE();
@@ -2432,21 +3079,29 @@ int woal_cfg80211_change_bss(struct wiphy *wiphy, struct net_device *dev,
 	if (change) {
 		if (priv->bss_started == MTRUE) {
 			bss_started = MTRUE;
-			woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP);
+			if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT,
+					      UAP_BSS_STOP))
+				PRINTM(MERROR, "%s: stop uap failed \n",
+				       __func__);
 		}
+
 		if (params->use_short_preamble == 1)
 			sys_config->preamble_type = 1;
 		else if (params->use_short_preamble == 0)
 			sys_config->preamble_type = 2;
 		else
 			sys_config->preamble_type = 0;
+
 		if (MLAN_STATUS_SUCCESS ==
 		    woal_set_get_sys_config(priv, MLAN_ACT_SET, MOAL_IOCTL_WAIT,
 					    sys_config))
 			ret = 0;
-		if (bss_started)
-			woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT,
-					  UAP_BSS_START);
+		if (bss_started) {
+			if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT,
+					      UAP_BSS_START))
+				PRINTM(MERROR, "%s: start uap failed \n",
+				       __func__);
+		}
 	}
 done:
 	kfree(sys_config);
@@ -2493,52 +3148,41 @@ int woal_cfg80211_del_station(struct wiphy *wiphy, struct net_device *dev,
 	u16 reason_code = REASON_CODE_DEAUTH_LEAVING;
 	moal_private *priv = (moal_private *)woal_get_netdev_priv(dev);
 	ENTER();
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
-	if (priv->phandle->is_cac_timer_set &&
-	    priv->bss_index == priv->phandle->cac_bss_index) {
-		woal_cancel_timer(&priv->phandle->cac_timer);
-		priv->phandle->is_cac_timer_set = MFALSE;
-		/* Make sure Chan Report is cancelled */
-		woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT);
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-		cfg80211_cac_event(priv->netdev, &priv->phandle->dfs_channel,
-				   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
-#else
-		cfg80211_cac_event(priv->netdev, NL80211_RADAR_CAC_ABORTED,
-				   GFP_KERNEL);
-#endif
-		memset(&priv->phandle->dfs_channel, 0,
-		       sizeof(struct cfg80211_chan_def));
-		priv->phandle->cac_bss_index = 0xff;
+
+#ifdef UAP_SUPPORT
+	if ((priv->bss_type == MLAN_BSS_TYPE_UAP) && !priv->bss_started) {
+		woal_cancel_cac(priv);
+		LEAVE();
+		return 0;
 	}
 #endif
-#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-	if (moal_extflg_isset(priv->phandle, EXT_DFS_OFFLOAD))
-		woal_cancel_cac_block(priv);
-#endif
 
 	if (priv->media_connected == MFALSE) {
 		PRINTM(MINFO, "cfg80211: Media not connected!\n");
 		LEAVE();
 		return 0;
 	}
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
 	if (param) {
 		mac_addr = param->mac;
 		reason_code = param->reason_code;
 	}
 #endif
+
 	/** we will not send deauth to p2p interface, it might cause WPS failure
 	 */
-	if (mac_addr) {
-		PRINTM(MMSG, "wlan: deauth station " MACSTR "\n",
-		       MAC2STR(mac_addr));
+	if (mac_addr
 #ifdef WIFI_DIRECT_SUPPORT
-		if (!priv->phandle->is_go_timer_set)
+	    && !priv->phandle->is_go_timer_set
 #endif
-			woal_deauth_station(priv, (u8 *)mac_addr, reason_code);
+	) {
+		if (woal_deauth_assoc_station(priv, (u8 *)mac_addr,
+					      reason_code))
+			PRINTM(MMSG, "wlan: deauth station " MACSTR " failed\n",
+			       MAC2STR(mac_addr));
 	} else {
-		PRINTM(MIOCTL, "del all station\n");
+		PRINTM(MIOCTL, "del station\n");
 	}
 	LEAVE();
 	return 0;
@@ -2579,7 +3223,8 @@ int woal_uap_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 
 	/* Allocate an IOCTL request buffer */
 	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_get_info));
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
@@ -2606,11 +3251,14 @@ int woal_uap_cfg80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 					  BIT(NL80211_STA_INFO_RX_PACKETS) |
 					  BIT(NL80211_STA_INFO_TX_PACKETS) |
 					  BIT(NL80211_STA_INFO_SIGNAL);
-
-			stainfo->rx_bytes = priv->stats.rx_bytes;
-			stainfo->tx_bytes = priv->stats.tx_bytes;
-			stainfo->rx_packets = priv->stats.rx_packets;
-			stainfo->tx_packets = priv->stats.tx_packets;
+			stainfo->rx_bytes =
+				info->param.sta_list.info[i].stats.rx_bytes;
+			stainfo->tx_bytes =
+				info->param.sta_list.info[i].stats.tx_bytes;
+			stainfo->rx_packets =
+				info->param.sta_list.info[i].stats.rx_packets;
+			stainfo->tx_packets =
+				info->param.sta_list.info[i].stats.tx_packets;
 #else
 			stainfo->filled = STATION_INFO_INACTIVE_TIME |
 					  STATION_INFO_SIGNAL;
@@ -2675,7 +3323,8 @@ int woal_uap_cfg80211_dump_station(struct wiphy *wiphy, struct net_device *dev,
 
 	/* Allocate an IOCTL request buffer */
 	ioctl_req = (mlan_ioctl_req *)woal_alloc_mlan_ioctl_req(
-		sizeof(mlan_ds_get_info));
+		sizeof(mlan_ds_get_info) +
+		(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 	if (ioctl_req == NULL) {
 		ret = -ENOMEM;
 		goto done;
@@ -2778,7 +3427,8 @@ int woal_cfg80211_set_mac_acl(struct wiphy *wiphy, struct net_device *dev,
 		sizeof(sys_config->filter.mac_list));
 	if (priv->bss_started == MTRUE) {
 		bss_started = MTRUE;
-		woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP);
+		if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT, UAP_BSS_STOP))
+			PRINTM(MERROR, "%s: stop uap failed \n", __func__);
 	}
 	if (MLAN_STATUS_SUCCESS == woal_set_get_sys_config(priv, MLAN_ACT_SET,
 							   MOAL_IOCTL_WAIT,
@@ -2786,8 +3436,11 @@ int woal_cfg80211_set_mac_acl(struct wiphy *wiphy, struct net_device *dev,
 		ret = 0;
 done:
 	kfree(sys_config);
-	if (bss_started)
-		woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT, UAP_BSS_START);
+	if (bss_started) {
+		if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT,
+				      UAP_BSS_START))
+			PRINTM(MERROR, "%s: start uap failed \n", __func__);
+	}
 	LEAVE();
 	return ret;
 }
@@ -2875,6 +3528,103 @@ int woal_cfg80211_set_txq_params(struct wiphy *wiphy, struct net_device *dev,
 }
 #endif
 
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
+/**
+ * @brief start background radar detection
+ *
+ * @param wiphy           A pointer to wiphy structure
+ * @param chandef         A pointer to cfg80211_chan_def structure
+ * @return                0 -- success, otherwise fail
+ */
+int woal_cfg80211_set_radar_background(struct wiphy *wiphy,
+				       struct cfg80211_chan_def *chandef)
+{
+	u32 cac_time_ms = DEF_CAC_DWELL_TIME;
+	moal_handle *handle = (moal_handle *)woal_get_wiphy_priv(wiphy);
+	moal_private *priv = woal_get_priv_bss_type(handle, MLAN_BSS_TYPE_DFS);
+	mlan_ds_11h_chan_rep_req chan_rpt_req;
+	int ret = 0;
+	mlan_status status;
+	ENTER();
+	if (!priv) {
+		PRINTM(MERROR,
+		       "DFS interface not avalible in set_radar_background\n");
+		return -EFAULT;
+	}
+	if (!chandef) {
+		PRINTM(MMSG, "Stop radar background\n");
+		woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT);
+		priv->chan_rpt_pending = MFALSE;
+		priv->radar_background = MFALSE;
+		memset(&priv->chan_rpt_req, 0,
+		       sizeof(mlan_ds_11h_chan_rep_req));
+		LEAVE();
+		return ret;
+	}
+	if (!(chandef->chan->flags & IEEE80211_CHAN_RADAR)) {
+		PRINTM(MERROR, "Not radar channel in set_radar_background\n");
+		LEAVE();
+		return -EFAULT;
+	}
+	if ((woal_is_etsi_country(priv->phandle->country_code) == MTRUE)) {
+		if (chandef->chan->hw_value == 120 ||
+		    chandef->chan->hw_value == 124 ||
+		    chandef->chan->hw_value == 128) {
+			cac_time_ms = MAX_CAC_DWELL_TIME;
+		}
+		if (chandef->chan->hw_value == 116 &&
+		    ((chandef->width == NL80211_CHAN_WIDTH_40) ||
+		     (chandef->width == NL80211_CHAN_WIDTH_80))) {
+			cac_time_ms = MAX_CAC_DWELL_TIME;
+		}
+	}
+	if (priv->chan_rpt_req.chanNum &&
+	    (priv->chan_rpt_req.chanNum != (t_u8)chandef->chan->hw_value)) {
+		woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT);
+		priv->chan_rpt_pending = MFALSE;
+		memset(&priv->chan_rpt_req, 0,
+		       sizeof(mlan_ds_11h_chan_rep_req));
+	}
+	chan_rpt_req.startFreq = START_FREQ_11A_BAND;
+	chan_rpt_req.chanNum = (t_u8)chandef->chan->hw_value;
+	chan_rpt_req.bandcfg.chanBand = BAND_5GHZ;
+	switch (chandef->width) {
+	case NL80211_CHAN_WIDTH_40:
+		chan_rpt_req.bandcfg.chanWidth = CHAN_BW_40MHZ;
+		break;
+	case NL80211_CHAN_WIDTH_80:
+		chan_rpt_req.bandcfg.chanWidth = CHAN_BW_80MHZ;
+		break;
+	case NL80211_CHAN_WIDTH_20:
+	case NL80211_CHAN_WIDTH_20_NOHT:
+	default:
+		chan_rpt_req.bandcfg.chanWidth = CHAN_BW_20MHZ;
+		break;
+	}
+	chan_rpt_req.millisec_dwell_time = cac_time_ms;
+	chan_rpt_req.host_based = MTRUE;
+	moal_memcpy_ext(priv->phandle, &priv->chan_rpt_req, &chan_rpt_req,
+			sizeof(mlan_ds_11h_chan_rep_req),
+			sizeof(mlan_ds_11h_chan_rep_req));
+	PRINTM(MCMND,
+	       "DFS: Start Background Radar detect on channel=%d, bandwidth=%d, cac time=%d\n",
+	       chan_rpt_req.chanNum, (int)(chan_rpt_req.bandcfg.chanWidth),
+	       chan_rpt_req.millisec_dwell_time);
+	status = woal_do_dfs_cac(priv, &chan_rpt_req);
+	if (status != MLAN_STATUS_SUCCESS) {
+		ret = -EFAULT;
+	} else {
+		priv->chan_rpt_pending = MTRUE;
+		priv->radar_background = MTRUE;
+		moal_memcpy_ext(priv->phandle, &priv->radar_background_chan,
+				chandef, sizeof(struct cfg80211_chan_def),
+				sizeof(struct cfg80211_chan_def));
+	}
+	LEAVE();
+	return ret;
+}
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
 /**
  * @brief cac timer call back function.
@@ -2911,14 +3661,13 @@ void woal_cac_timer_func(void *context)
  *
  * @return           N/A
  */
-void woal_switch_uap_channel(moal_private *priv, t_u8 wait_option)
+static void woal_switch_uap_channel(moal_private *priv, t_u8 wait_option)
 {
 	chan_band_info uap_channel;
 	t_u8 chan2Offset = SEC_CHAN_NONE;
 	ENTER();
 	woal_clear_all_mgmt_ies(priv, MOAL_IOCTL_WAIT);
-	if (MLAN_STATUS_SUCCESS !=
-	    woal_uap_bss_ctrl(priv, wait_option, UAP_BSS_STOP)) {
+	if (woal_uap_bss_ctrl(priv, wait_option, UAP_BSS_STOP)) {
 		PRINTM(MERROR, "%s: stop uap failed \n", __func__);
 		goto done;
 	}
@@ -2951,18 +3700,16 @@ void woal_switch_uap_channel(moal_private *priv, t_u8 wait_option)
 	case NL80211_CHAN_WIDTH_80P80:
 	case NL80211_CHAN_WIDTH_160:
 		uap_channel.bandcfg.chanWidth = CHAN_BW_80MHZ;
-		chan2Offset =
-			woal_get_second_channel_offset(uap_channel.channel);
+		chan2Offset = woal_get_second_channel_offset(
+			priv, uap_channel.channel);
 		break;
 	default:
 		PRINTM(MWARN, "Unknown channel width: %d\n",
 		       priv->csa_chan.width);
 		break;
 	}
-	if (priv->csa_chan.chan->band == IEEE80211_BAND_2GHZ)
-		uap_channel.bandcfg.chanBand = BAND_2GHZ;
-	else if (priv->csa_chan.chan->band == IEEE80211_BAND_5GHZ)
-		uap_channel.bandcfg.chanBand = BAND_5GHZ;
+	uap_channel.bandcfg.chanBand =
+		woal_ieee_band_to_radio_type(priv->csa_chan.chan->band);
 	uap_channel.bandcfg.chan2Offset = chan2Offset;
 	if (MLAN_STATUS_SUCCESS != woal_set_get_ap_channel(priv, MLAN_ACT_SET,
 							   wait_option,
@@ -2970,8 +3717,7 @@ void woal_switch_uap_channel(moal_private *priv, t_u8 wait_option)
 		PRINTM(MERROR, "Fail to set ap channel \n");
 		goto done;
 	}
-	if (MLAN_STATUS_SUCCESS !=
-	    woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT, UAP_BSS_START)) {
+	if (woal_uap_bss_ctrl(priv, MOAL_IOCTL_WAIT_TIMEOUT, UAP_BSS_START)) {
 		PRINTM(MERROR, "%s: start uap failed \n", __func__);
 		goto done;
 	}
@@ -2980,7 +3726,14 @@ void woal_switch_uap_channel(moal_private *priv, t_u8 wait_option)
 	priv->channel = uap_channel.channel;
 	moal_memcpy_ext(priv->phandle, &priv->chan, &priv->csa_chan,
 			sizeof(struct cfg80211_chan_def), sizeof(priv->chan));
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(6, 3, 0)
+	cfg80211_ch_switch_notify(priv->netdev, &priv->chan, 0, 0);
+#elif ((CFG80211_VERSION_CODE >= KERNEL_VERSION(5, 19, 2)) ||                  \
+       IMX_ANDROID_13 || IMX_ANDROID_12_BACKPORT)
+	cfg80211_ch_switch_notify(priv->netdev, &priv->chan, 0);
+#else
 	cfg80211_ch_switch_notify(priv->netdev, &priv->chan);
+#endif
 	if (priv->uap_tx_blocked) {
 		if (!netif_carrier_ok(priv->netdev))
 			netif_carrier_on(priv->netdev);
@@ -3010,6 +3763,38 @@ void woal_csa_work_queue(struct work_struct *work)
 	LEAVE();
 }
 
+#if KERNEL_VERSION(3, 12, 0) <= CFG80211_VERSION_CODE
+/*
+ * @brief  handle WOAL_EVENT_CANCEL_CHANRPT
+ *
+ * @param priv           A pointer moal_private structure
+ *
+ * @return          N/A
+ */
+void woal_process_cancel_chanrpt_event(moal_private *priv)
+{
+	if (priv->phandle->is_cac_timer_set &&
+	    priv->bss_index == priv->phandle->cac_bss_index) {
+		woal_cancel_timer(&priv->phandle->cac_timer);
+		priv->phandle->is_cac_timer_set = MFALSE;
+		/* Make sure Chan Report is cancelled */
+		if (woal_11h_cancel_chan_report_ioctl(priv, MOAL_IOCTL_WAIT))
+			PRINTM(MERROR, "%s: cancel chan report failed \n",
+			       __func__);
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+		cfg80211_cac_event(priv->netdev, &priv->phandle->dfs_channel,
+				   NL80211_RADAR_CAC_ABORTED, GFP_KERNEL);
+#else
+		cfg80211_cac_event(priv->netdev, NL80211_RADAR_CAC_ABORTED,
+				   GFP_KERNEL);
+#endif
+		memset(&priv->phandle->dfs_channel, 0,
+		       sizeof(struct cfg80211_chan_def));
+		priv->phandle->cac_bss_index = 0xff;
+	}
+}
+#endif
+
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
 /**
  * @brief start radar detection
@@ -3020,7 +3805,6 @@ void woal_csa_work_queue(struct work_struct *work)
  * @param cac_time_ms     A cac dwell time
  * @return                0 -- success, otherwise fail
  */
-
 int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 					struct net_device *dev,
 					struct cfg80211_chan_def *chandef,
@@ -3047,7 +3831,9 @@ int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 	mlan_ds_11h_cfg *p11h_cfg = NULL;
 	int ret = 0;
 	mlan_status status = MLAN_STATUS_SUCCESS;
-
+	chan_band_info channel;
+	t_u16 enable = 0;
+	t_u8 event_buf[64] = {0};
 	ENTER();
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
@@ -3069,6 +3855,28 @@ int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 		ret = -EBUSY;
 		goto done;
 	}
+	snprintf(event_buf, sizeof(event_buf) - 1, "%s %d", CUS_EVT_CAC_START,
+		 chandef->chan->hw_value);
+	woal_broadcast_event(priv, event_buf, strlen(event_buf));
+	if (MLAN_STATUS_SUCCESS ==
+	    woal_mc_policy_cfg(priv, &enable, MOAL_IOCTL_WAIT, MLAN_ACT_GET)) {
+		if (enable) {
+			if (MLAN_STATUS_SUCCESS ==
+			    woal_get_active_intf_channel(priv, &channel)) {
+				if (channel.channel !=
+				    chandef->chan->hw_value) {
+					PRINTM(MERROR,
+					       "DFS channel is not allowed when another connection exists on different channel\n");
+					PRINTM(MERROR,
+					       "Another connection's channel=%d, dfs channel=%d\n",
+					       channel.channel,
+					       chandef->chan->hw_value);
+					ret = -EINVAL;
+					goto done;
+				}
+			}
+		}
+	}
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_11h_cfg));
 	if (NULL == req) {
 		ret = -ENOMEM;
@@ -3079,14 +3887,18 @@ int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 	pchan_rpt_req = &p11h_cfg->param.chan_rpt_req;
 	pchan_rpt_req->startFreq = START_FREQ_11A_BAND;
 	pchan_rpt_req->chanNum = (t_u8)chandef->chan->hw_value;
-	woal_convert_chan_to_bandconfig(&pchan_rpt_req->bandcfg, chandef);
+	woal_convert_chan_to_bandconfig(priv, &pchan_rpt_req->bandcfg, chandef);
 	pchan_rpt_req->host_based = MTRUE;
 
 #if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
 	pchan_rpt_req->millisec_dwell_time = cac_time_ms;
 #else
 	pchan_rpt_req->millisec_dwell_time = IEEE80211_DFS_MIN_CAC_TIME_MS;
-
+#endif
+	/* Since kernel doesn't support 600sec cac_timer for channels 120, 124,
+	 * and 128 (weather channels) in ETSI region, overwrite kernel's
+	 * cac_timer.
+	 */
 	if ((woal_is_etsi_country(priv->phandle->country_code) == MTRUE)) {
 		if (chandef->chan->hw_value == 120 ||
 		    chandef->chan->hw_value == 124 ||
@@ -3101,7 +3913,6 @@ int woal_cfg80211_start_radar_detection(struct wiphy *wiphy,
 				IEEE80211_DFS_MIN_CAC_TIME_MS * 10;
 		}
 	}
-#endif
 	if (priv->user_cac_period_msec) {
 		pchan_rpt_req->millisec_dwell_time = priv->user_cac_period_msec;
 		PRINTM(MCMD_D,
@@ -3158,15 +3969,12 @@ int woal_cfg80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 		ret = -EINVAL;
 		goto done;
 	}
-
-	/* TODO: support this case in next version */
 	if (params->radar_required) {
-		PRINTM(MMSG,
-		       " hostapd handle this case by disable and re-enable interface\n");
-		ret = -ENOTSUPP;
-		goto done;
+		PRINTM(MMSG, "switch to DFS channel\n");
+#if CFG80211_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)
+		woal_enable_dfs_support(priv, &params->chandef);
+#endif
 	}
-
 	/* actually hostapd would always choose one diff channel*/
 	if (cfg80211_chandef_identical(&params->chandef, &priv->chan)) {
 		PRINTM(MMSG,
@@ -3246,8 +4054,12 @@ mlan_status woal_register_uap_cfg80211(struct net_device *dev, t_u8 bss_type)
 		return MLAN_STATUS_FAILURE;
 	}
 
-	if (bss_type == MLAN_BSS_TYPE_UAP)
+	if (bss_type == MLAN_BSS_TYPE_UAP) {
 		wdev->iftype = NL80211_IFTYPE_AP;
+#if CFG80211_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+		woal_cfg80211_setup_uap_he_cap(priv, MOAL_IOCTL_WAIT);
+#endif
+	}
 
 	dev_net_set(dev, wiphy_net(wdev->wiphy));
 	dev->ieee80211_ptr = wdev;
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.h
old mode 100644
new mode 100755
index 9f3c47082..7d6c805f4
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_cfg80211.h
@@ -3,7 +3,7 @@
  * @brief This file contains the uAP CFG80211 specific defines.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2011-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.c
old mode 100644
new mode 100755
index 02e3cc232..ab503b2dd
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.c
@@ -3,7 +3,7 @@
  * @brief This file contains standard ioctl functions
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2010-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -102,28 +102,39 @@ int woal_uap_do_priv_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 		case WOAL_WL_FW_RELOAD:
 			break;
 		case WOAL_AP_SET_CFG:
-			ret = woal_uap_set_ap_cfg(priv, wrq->u.data.pointer,
-						  wrq->u.data.length);
+			ret = woal_uap_set_ap_cfg(
+				priv, (t_u8 __force *)wrq->u.data.pointer,
+				wrq->u.data.length);
 			break;
 		default:
 			ret = -EINVAL;
 			break;
 		}
 		break;
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 	case WOAL_UAP_SETONEINT_GETONEINT:
 		switch (wrq->u.data.flags) {
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 		case WOAL_UAP_SET_GET_BSS_ROLE:
 			ret = woal_set_get_bss_role(priv, wrq);
 			break;
+#endif
+#endif
+#if defined(UAP_CFG80211)
+#if defined(STA_WEXT) || defined(UAP_WEXT)
+		case WOAL_UAP_SET_MODE:
+			PRINTM(MINFO,
+			       "%s: setting multi_ap flag through user command\n",
+			       __func__);
+			ret = woal_uap_set_get_multi_ap_mode(priv, wrq);
+			break;
+#endif
+#endif
 		default:
 			ret = -EINVAL;
 			break;
 		}
 		break;
-#endif
-#endif
 	case WOAL_UAP_HOST_CMD:
 		ret = woal_host_command(priv, wrq);
 		break;
@@ -141,7 +152,8 @@ int woal_uap_do_priv_ioctl(struct net_device *dev, struct ifreq *req, int cmd)
 	case WOAL_UAP_FROYO_WL_FW_RELOAD:
 		break;
 	case WOAL_UAP_FROYO_AP_SET_CFG:
-		ret = woal_uap_set_ap_cfg(priv, wrq->u.data.pointer,
+		ret = woal_uap_set_ap_cfg(priv,
+					  (t_u8 __force *)wrq->u.data.pointer,
 					  wrq->u.data.length);
 		break;
 	default:
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.h
old mode 100644
new mode 100755
index d050bac0e..c49d36afb
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_priv.h
@@ -3,7 +3,7 @@
  * @brief This file contains definition for extended private IOCTL call.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2010-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -56,15 +56,20 @@ Change log:
 /** Private command ID to get extended version */
 #define WOAL_UAP_VEREXT 2
 
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 /** Private command ID to set one int/get one int */
 #define WOAL_UAP_SETONEINT_GETONEINT (WOAL_UAP_IOCTL + 5)
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
 /** Private command ID for set/get BSS role */
 #define WOAL_UAP_SET_GET_BSS_ROLE 1
 #endif
 #endif
 
+#if defined(UAP_CFG80211)
+/** Private command ID for set multi-AP BSS mode */
+#define WOAL_UAP_SET_MODE 27
+#endif
+
 /** Private command ID for hostcmd */
 #define WOAL_UAP_HOST_CMD (WOAL_UAP_IOCTL + 17)
 
@@ -82,47 +87,4 @@ Change log:
 /** Private command ID to stop driver */
 #define WOAL_UAP_FROYO_STOP (WOAL_UAP_IOCTL + 30)
 
-/**
- * iwpriv ioctl handlers
- */
-static const struct iw_priv_args woal_uap_priv_args[] = {
-	{WOAL_UAP_SETNONE_GETNONE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, ""},
-	{WOAL_UAP_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "start"},
-	{WOAL_UAP_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "stop"},
-	{WOAL_AP_BSS_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "bssstart"},
-	{WOAL_AP_BSS_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "bssstop"},
-	{WOAL_UAP_SETONEINT_GETWORDCHAR, IW_PRIV_TYPE_INT | 1,
-	 IW_PRIV_TYPE_CHAR | 128, ""},
-	{WOAL_UAP_VERSION, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
-	 "version"},
-	{WOAL_UAP_VEREXT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
-	 "verext"},
-#ifdef WIFI_DIRECT_SUPPORT
-#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
-	{WOAL_UAP_SETONEINT_GETONEINT, IW_PRIV_TYPE_INT | 1,
-	 IW_PRIV_TYPE_INT | 1, ""},
-	{WOAL_UAP_SET_GET_BSS_ROLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
-	 "bssrole"},
-#endif
-#endif
-	{WOAL_UAP_SET_GET_256_CHAR, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, ""},
-	{WOAL_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "fwreload"},
-	{WOAL_AP_SET_CFG, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
-	 "apcfg"},
-	{WOAL_UAP_HOST_CMD, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_BYTE | 2047,
-	 "hostcmd"},
-	{WOAL_UAP_FROYO_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "START"},
-	{WOAL_UAP_FROYO_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "STOP"},
-	{WOAL_UAP_FROYO_AP_BSS_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
-	 "AP_BSS_START"},
-	{WOAL_UAP_FROYO_AP_BSS_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
-	 "AP_BSS_STOP"},
-	{WOAL_UAP_FROYO_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, "WL_FW_RELOAD"},
-	{WOAL_UAP_FROYO_AP_SET_CFG, IW_PRIV_TYPE_CHAR | 256,
-	 IW_PRIV_TYPE_CHAR | 256, "AP_SET_CFG"},
-};
-
 #endif /* _MOAL_UAP_PRIV_H_ */
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_wext.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_wext.c
old mode 100644
new mode 100755
index 51967247f..5fe492660
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_wext.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_uap_wext.c
@@ -3,7 +3,7 @@
  * @brief This file contains wireless extension standard ioctl functions
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2010-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -42,7 +42,7 @@ typedef struct _chan_to_freq_t {
 	t_u8 band;
 } chan_to_freq_t;
 
-const chan_to_freq_t chan_to_freq[] = {
+static const chan_to_freq_t chan_to_freq[] = {
 	{1, 2412, 0},	{2, 2417, 0},	{3, 2422, 0},	{4, 2427, 0},
 	{5, 2432, 0},	{6, 2437, 0},	{7, 2442, 0},	{8, 2447, 0},
 	{9, 2452, 0},	{10, 2457, 0},	{11, 2462, 0},	{12, 2467, 0},
@@ -57,7 +57,55 @@ const chan_to_freq_t chan_to_freq[] = {
 	{116, 5580, 1}, {120, 5600, 1}, {124, 5620, 1}, {128, 5640, 1},
 	{132, 5660, 1}, {136, 5680, 1}, {140, 5700, 1}, {144, 5720, 1},
 	{149, 5745, 1}, {153, 5765, 1}, {157, 5785, 1}, {161, 5805, 1},
-	{165, 5825, 1},
+	{165, 5825, 1}, {169, 5845, 1}, {173, 5865, 1}, {177, 5885, 1},
+};
+
+/**
+ * iwpriv ioctl handlers
+ */
+static const struct iw_priv_args woal_uap_priv_args[] = {
+	{WOAL_UAP_SETNONE_GETNONE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, ""},
+	{WOAL_UAP_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "start"},
+	{WOAL_UAP_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "stop"},
+	{WOAL_AP_BSS_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "bssstart"},
+	{WOAL_AP_BSS_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "bssstop"},
+	{WOAL_UAP_SETONEINT_GETWORDCHAR, IW_PRIV_TYPE_INT | 1,
+	 IW_PRIV_TYPE_CHAR | 128, ""},
+	{WOAL_UAP_VERSION, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
+	 "version"},
+	{WOAL_UAP_VEREXT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
+	 "verext"},
+	{WOAL_UAP_SETONEINT_GETONEINT, IW_PRIV_TYPE_INT | 1,
+	 IW_PRIV_TYPE_INT | 1, ""},
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
+	{WOAL_UAP_SET_GET_BSS_ROLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "bssrole"},
+#endif
+#endif
+
+#if defined(UAP_CFG80211)
+	{WOAL_UAP_SET_MODE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "setmode"},
+#endif
+	{WOAL_UAP_SET_GET_256_CHAR, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, ""},
+	{WOAL_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "fwreload"},
+	{WOAL_AP_SET_CFG, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "apcfg"},
+	{WOAL_UAP_HOST_CMD, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_BYTE | 2047,
+	 "hostcmd"},
+	{WOAL_UAP_FROYO_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "START"},
+	{WOAL_UAP_FROYO_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "STOP"},
+	{WOAL_UAP_FROYO_AP_BSS_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
+	 "AP_BSS_START"},
+	{WOAL_UAP_FROYO_AP_BSS_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
+	 "AP_BSS_STOP"},
+	{WOAL_UAP_FROYO_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, "WL_FW_RELOAD"},
+	{WOAL_UAP_FROYO_AP_SET_CFG, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, "AP_SET_CFG"},
 };
 
 /** Convertion from frequency to channel */
@@ -107,7 +155,7 @@ static int channel_to_frequency(t_u16 channel, t_u8 band)
 	int i = 0;
 
 	ENTER();
-	for (i = 0; i < ARRAY_SIZE(chan_to_freq); i++) {
+	for (i = 0; i < (int)ARRAY_SIZE(chan_to_freq); i++) {
 		if (channel == chan_to_freq[i].channel &&
 		    band == chan_to_freq[i].band) {
 			LEAVE();
@@ -153,7 +201,7 @@ static int woal_get_name(struct net_device *dev, struct iw_request_info *info,
 {
 	char *cwrq = wrqu->name;
 	ENTER();
-	strcpy(cwrq, "IEEE 802.11-DS");
+	strncpy(cwrq, "IEEE 802.11-DS", IFNAMSIZ);
 	LEAVE();
 	return 0;
 }
@@ -180,7 +228,11 @@ static int woal_get_wap(struct net_device *dev, struct iw_request_info *info,
 	if (priv->bss_started)
 		moal_memcpy_ext(priv->phandle, awrq->sa_data,
 				priv->current_addr, MLAN_MAC_ADDR_LENGTH,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+				sizeof(awrq->sa_data_min));
+#else
 				sizeof(awrq->sa_data));
+#endif
 	else
 		memset(awrq->sa_data, 0, MLAN_MAC_ADDR_LENGTH);
 	awrq->sa_family = ARPHRD_ETHER;
@@ -297,10 +349,10 @@ static int woal_set_freq(struct net_device *dev, struct iw_request_info *info,
 		ret = -EINVAL;
 		goto done;
 	}
-	for (i = 0; i < ap_cfg->num_of_chan; i++)
+	for (i = 0; i < (int)ap_cfg->num_of_chan; i++)
 		if (ap_cfg->chan_list[i].chan_number == chan)
 			break;
-	if (i == ap_cfg->num_of_chan) {
+	if (i == (int)ap_cfg->num_of_chan) {
 		PRINTM(MERROR, "Channel %d is not supported\n", chan);
 		ret = -EINVAL;
 		goto done;
@@ -357,7 +409,7 @@ static int woal_get_freq(struct net_device *dev, struct iw_request_info *info,
 		return -EFAULT;
 	}
 
-	band = (ap_cfg->bandcfg.chanBand == BAND_5GHZ);
+	band = (((ap_cfg->bandcfg.chanBand == BAND_5GHZ) ? 1 : 0));
 	fwrq->m = (long)channel_to_frequency(ap_cfg->channel, band);
 	fwrq->i = (long)ap_cfg->channel;
 	fwrq->e = 6;
@@ -692,7 +744,10 @@ static int woal_get_encode(struct net_device *dev, struct iw_request_info *info,
 		moal_memcpy_ext(priv->phandle, extra,
 				ap_cfg->wpa_cfg.passphrase,
 				ap_cfg->wpa_cfg.length, ap_cfg->wpa_cfg.length);
-		dwrq->length = ap_cfg->wpa_cfg.length;
+		if (ap_cfg->wpa_cfg.length)
+			dwrq->length = ap_cfg->wpa_cfg.length;
+		else
+			dwrq->length = 16;
 		dwrq->flags |= 1;
 		dwrq->flags &= ~IW_ENCODE_DISABLED;
 		break;
@@ -1079,7 +1134,8 @@ static int woal_set_mlme(struct net_device *dev, struct iw_request_info *info,
 		if (!memcmp(bc_addr, sta_addr, ETH_ALEN)) {
 			PRINTM(MIOCTL, "Deauth all stations\n");
 			req = woal_alloc_mlan_ioctl_req(
-				sizeof(mlan_ds_get_info));
+				sizeof(mlan_ds_get_info) +
+				(MAX_STA_LIST_IE_SIZE * MAX_NUM_CLIENTS));
 			if (req == NULL) {
 				LEAVE();
 				return -ENOMEM;
@@ -1170,7 +1226,6 @@ static int woal_set_mlme(struct net_device *dev, struct iw_request_info *info,
 static int woal_set_auth(struct net_device *dev, struct iw_request_info *info,
 			 union iwreq_data *wrqu, char *extra)
 {
-	int ret = 0;
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	struct iw_param *vwrq = &wrqu->param;
 	mlan_uap_bss_param *sys_cfg = NULL;
@@ -1325,7 +1380,6 @@ static int woal_set_auth(struct net_device *dev, struct iw_request_info *info,
 							   MOAL_IOCTL_WAIT,
 							   sys_cfg)) {
 		PRINTM(MERROR, "Error setting AP confiruration\n");
-		ret = -EFAULT;
 		goto done;
 	}
 
@@ -1816,14 +1870,14 @@ static const iw_handler woal_private_handler[] = {
 // clang-format off
 /** wlan_handler_def */
 struct iw_handler_def woal_uap_handler_def = {
-	num_standard: ARRAY_SIZE(woal_handler),
-	num_private : ARRAY_SIZE(woal_private_handler),
-	num_private_args : ARRAY_SIZE(woal_uap_priv_args),
-	standard : (iw_handler *)woal_handler,
-	private : (iw_handler *)woal_private_handler,
-	private_args : (struct iw_priv_args *)woal_uap_priv_args,
+	.num_standard = ARRAY_SIZE(woal_handler),
+	.num_private = ARRAY_SIZE(woal_private_handler),
+	.num_private_args = ARRAY_SIZE(woal_uap_priv_args),
+	.standard = (iw_handler *)woal_handler,
+	.private = (iw_handler *)woal_private_handler,
+	.private_args = (struct iw_priv_args *)woal_uap_priv_args,
 #if WIRELESS_EXT > 20
-	get_wireless_stats : woal_get_uap_wireless_stats,
+	.get_wireless_stats = woal_get_uap_wireless_stats,
 #endif
 };
 // clang-format on
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c
old mode 100644
new mode 100755
index 155003f08..16ccf1ace
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.c
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -34,7 +34,8 @@ extern struct semaphore AddRemoveCardSem;
 		Local Variables
 ********************************************************/
 
-#if defined(USB8997) || defined(USB9098) || defined(USB9097) || defined(USB8978)
+#if defined(USB8997) || defined(USB9098) || defined(USB9097) ||                \
+	defined(USB8978) || defined(USBIW62X)
 /** Card-type detection frame response */
 typedef struct {
 	/** 32-bit ACK+WINNER field */
@@ -55,11 +56,15 @@ typedef struct {
 	USB_DEVICE(vid, pid), .driver_info = (t_ptr)name
 
 /** Name of the USB driver */
-const char usbdriver_name[] = "usbxxx";
+static const char usbdriver_name[] = "usbxxx";
 
 /** This structure contains the device signature */
-struct usb_device_id woal_usb_table[] = {
+static struct usb_device_id woal_usb_table[] = {
 /* Enter the device signature inside */
+#ifdef USB8801
+	{NXP_USB_DEVICE(USB8801_VID_1, USB8801_PID_1, "NXP WLAN USB Adapter")},
+	{NXP_USB_DEVICE(USB8801_VID_1, USB8801_PID_2, "NXP WLAN USB Adapter")},
+#endif
 #ifdef USB8897
 	{NXP_USB_DEVICE(USB8897_VID_1, USB8897_PID_1, "NXP WLAN USB Adapter")},
 	{NXP_USB_DEVICE(USB8897_VID_1, USB8897_PID_2, "NXP WLAN USB Adapter")},
@@ -89,14 +94,23 @@ struct usb_device_id woal_usb_table[] = {
 #ifdef USB9097
 	{NXP_USB_DEVICE(USB9097_VID_1, USB9097_PID_1, "NXP WLAN USB Adapter")},
 	{NXP_USB_DEVICE(USB9097_VID_1, USB9097_PID_2, "NXP WLAN USB Adapter")},
+#endif
+#ifdef USBIW62X
+	{NXP_USB_DEVICE(USBIW62X_VID_1, USBIW62X_PID_1,
+			"NXP WLAN USB Adapter")},
+	{NXP_USB_DEVICE(USBIW62X_VID_1, USBIW62X_PID_2,
+			"NXP WLAN USB Adapter")},
 #endif
 	/* Terminating entry */
 	{},
 };
 
 /** This structure contains the device signature */
-struct usb_device_id woal_usb_table_skip_fwdnld[] = {
+static struct usb_device_id woal_usb_table_skip_fwdnld[] = {
 /* Enter the device signature inside */
+#ifdef USB8801
+	{NXP_USB_DEVICE(USB8801_VID_1, USB8801_PID_2, "NXP WLAN USB Adapter")},
+#endif
 #ifdef USB8897
 	{NXP_USB_DEVICE(USB8897_VID_1, USB8897_PID_2, "NXP WLAN USB Adapter")},
 #endif
@@ -113,6 +127,10 @@ struct usb_device_id woal_usb_table_skip_fwdnld[] = {
 #endif
 #ifdef USB9097
 	{NXP_USB_DEVICE(USB9097_VID_1, USB9097_PID_2, "NXP WLAN USB Adapter")},
+#endif
+#ifdef USBIW62X
+	{NXP_USB_DEVICE(USBIW62X_VID_1, USBIW62X_PID_2,
+			"NXP WLAN USB Adapter")},
 #endif
 	/* Terminating entry */
 	{},
@@ -173,9 +191,6 @@ static moal_if_ops usb_ops;
 		Global Variables
 ********************************************************/
 
-extern int skip_fwdnld;
-extern int max_tx_buf;
-
 /********************************************************
 		Local Functions
 ********************************************************/
@@ -262,13 +277,13 @@ static void woal_usb_receive(struct urb *urb)
 		if (status == MLAN_STATUS_PENDING) {
 			queue_work(handle->workqueue, &handle->main_work);
 			/* urb for data_ep is re-submitted now, unless we reach
-			 * HIGH_RX_PENDING */
+			 * USB_HIGH_RX_PENDING */
 			/* urb for cmd_ep will be re-submitted in callback
 			 * moal_recv_complete */
 			if (cardp->rx_cmd_ep == context->ep)
 				goto rx_exit;
 			else if (atomic_read(&handle->rx_pending) >=
-				 HIGH_RX_PENDING) {
+				 USB_HIGH_RX_PENDING) {
 				context->pmbuf = NULL;
 				goto rx_exit;
 			}
@@ -391,6 +406,8 @@ static void woal_usb_tx_complete(struct urb *urb)
 		atomic_dec(&cardp->tx_cmd_urb_pending);
 	else if (context->ep == cardp->tx_data_ep)
 		atomic_dec(&cardp->tx_data_urb_pending);
+	else if (context->ep == cardp->tx_data2_ep)
+		atomic_dec(&cardp->tx_data2_urb_pending);
 
 	queue_work(handle->workqueue, &handle->main_work);
 
@@ -479,23 +496,26 @@ static mlan_status woal_usb_submit_rx_urb(urb_context *ctx, int size)
 		Global Functions
 ********************************************************/
 
-#if defined(USB8997) || defined(USB9098) || defined(USB9097) || defined(USB8978)
+#if defined(USB8997) || defined(USB9098) || defined(USB9097) ||                \
+	defined(USB8978) || defined(USBIW62X)
 /**
  *  @brief  Check chip revision
  *
  *  @param handle        A pointer to moal_handle structure
  *  @param usb_chip_rev  A pointer to usb_chip_rev variable
  *  @param usb_strap     A pointer to usb_strap
+ *  @param boot_mode     A pointer to boot_mode
  *
  *  @return 	   	 MLAN_STATUS_SUCCESS or MLAN_STATUS_FAILURE
  */
-mlan_status woal_check_chip_revision(moal_handle *handle, t_u32 *usb_chip_rev,
-				     t_u32 *usb_strap)
+static mlan_status woal_check_chip_revision(moal_handle *handle,
+					    t_u32 *usb_chip_rev,
+					    t_u32 *usb_strap, t_u32 *boot_mode)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
 	mlan_buffer mbuf;
-	t_u8 *tx_buff = 0;
-	t_u8 *recv_buff = 0;
+	t_u8 *tx_buff = NULL;
+	t_u8 *recv_buff = NULL;
 	usb_ack_pkt ack_pkt;
 	t_u32 extend_ver;
 	t_u8 tx_size = CHIP_REV_TX_BUF_SIZE;
@@ -563,7 +583,7 @@ mlan_status woal_check_chip_revision(moal_handle *handle, t_u32 *usb_chip_rev,
 	ack_pkt.strap = woal_le32_to_cpu(ack_pkt.strap);
 
 	if ((ack_pkt.extend & 0xffff0000) == EXTEND_HDR) {
-		extend_ver = ack_pkt.extend & 0x0000ffff;
+		extend_ver = ack_pkt.extend & 0x000000ff;
 		*usb_chip_rev = ack_pkt.chip_rev & 0x000000ff;
 		if (extend_ver >= EXTEND_V2) {
 			PRINTM(MINFO, "chip_rev=0x%x, strap=0x%x\n",
@@ -571,6 +591,8 @@ mlan_status woal_check_chip_revision(moal_handle *handle, t_u32 *usb_chip_rev,
 			*usb_strap = ack_pkt.strap & 0x7;
 		} else
 			PRINTM(MINFO, "chip_rev=0x%x\n", *usb_chip_rev);
+		if (extend_ver >= EXTEND_V3)
+			*boot_mode = (ack_pkt.extend & 0x0000ff00) >> 8;
 	}
 cleanup:
 	kfree(recv_buff);
@@ -618,6 +640,10 @@ static void woal_usb_unlink_urb(void *card_desc)
 					usb_kill_urb(
 						cardp->tx_data_list[i].urb);
 				}
+				if (cardp->tx_data2_list[i].urb) {
+					usb_kill_urb(
+						cardp->tx_data2_list[i].urb);
+				}
 			}
 		}
 	}
@@ -657,6 +683,10 @@ void woal_usb_free(struct usb_card_rec *cardp)
 			usb_free_urb(cardp->tx_data_list[i].urb);
 			cardp->tx_data_list[i].urb = NULL;
 		}
+		if (cardp->tx_data2_list[i].urb) {
+			usb_free_urb(cardp->tx_data2_list[i].urb);
+			cardp->tx_data2_list[i].urb = NULL;
+		}
 	}
 	/* Free Tx cmd URB */
 	if (cardp->tx_cmd.urb) {
@@ -674,11 +704,27 @@ static t_u16 woal_update_card_type(t_void *card)
 	t_u16 card_type = 0;
 
 	/* Update card type */
+#ifdef USB8801
+	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
+		    (__force __le16)USB8801_PID_1 ||
+	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
+		    (__force __le16)USB8801_PID_2) {
+		card_type = CARD_TYPE_USB8801;
+		moal_memcpy_ext(NULL, driver_version, CARD_USB8801,
+				strlen(CARD_USB8801), strlen(driver_version));
+		moal_memcpy_ext(NULL,
+				driver_version + strlen(INTF_CARDTYPE) +
+					strlen(KERN_VERSION),
+				V14, strlen(V14),
+				strlen(driver_version) - strlen(INTF_CARDTYPE) -
+					strlen(KERN_VERSION));
+	}
+#endif
 #ifdef USB8897
 	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8897_PID_1 ||
+		    (__force __le16)USB8897_PID_1 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8897_PID_2) {
+		    (__force __le16)USB8897_PID_2) {
 		card_type = CARD_TYPE_USB8897;
 		moal_memcpy_ext(NULL, driver_version, CARD_USB8897,
 				strlen(CARD_USB8897), strlen(driver_version));
@@ -692,19 +738,19 @@ static t_u16 woal_update_card_type(t_void *card)
 #endif
 #ifdef USB8997
 	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_1 ||
+		    (__force __le16)USB8997_PID_1 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_2 ||
+		    (__force __le16)USB8997_PID_2 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_3 ||
+		    (__force __le16)USB8997_PID_3 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_4 ||
+		    (__force __le16)USB8997_PID_4 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_5 ||
+		    (__force __le16)USB8997_PID_5 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997_PID_6 ||
+		    (__force __le16)USB8997_PID_6 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8997V2_PID_1) {
+		    (__force __le16)USB8997V2_PID_1) {
 		card_type = CARD_TYPE_USB8997;
 		moal_memcpy_ext(NULL, driver_version, CARD_USB8997,
 				strlen(CARD_USB8997), strlen(driver_version));
@@ -718,12 +764,12 @@ static t_u16 woal_update_card_type(t_void *card)
 #endif
 #ifdef USB8978
 	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8978_PID_1 ||
+		    (__force __le16)USB8978_PID_1 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB8978_PID_2) {
+		    (__force __le16)USB8978_PID_2) {
 		card_type = CARD_TYPE_USB8978;
-		moal_memcpy_ext(NULL, driver_version, CARD_USB8978,
-				strlen(CARD_USB8978), strlen(driver_version));
+		moal_memcpy_ext(NULL, driver_version, "USBIW416",
+				strlen("USBIW416"), strlen(driver_version));
 		moal_memcpy_ext(NULL,
 				driver_version + strlen(INTF_CARDTYPE) +
 					strlen(KERN_VERSION),
@@ -734,9 +780,9 @@ static t_u16 woal_update_card_type(t_void *card)
 #endif
 #ifdef USB9098
 	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB9098_PID_1 ||
+		    (__force __le16)USB9098_PID_1 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB9098_PID_2) {
+		    (__force __le16)USB9098_PID_2) {
 		card_type = CARD_TYPE_USB9098;
 		moal_memcpy_ext(NULL, driver_version, CARD_USB9098,
 				strlen(CARD_USB9098), strlen(driver_version));
@@ -750,9 +796,9 @@ static t_u16 woal_update_card_type(t_void *card)
 #endif
 #ifdef USB9097
 	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB9097_PID_1 ||
+		    (__force __le16)USB9097_PID_1 ||
 	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
-		    USB9097_PID_2) {
+		    (__force __le16)USB9097_PID_2) {
 		card_type = CARD_TYPE_USB9097;
 		moal_memcpy_ext(NULL, driver_version, CARD_USB9097,
 				strlen(CARD_USB9097), strlen(driver_version));
@@ -763,6 +809,22 @@ static t_u16 woal_update_card_type(t_void *card)
 				strlen(driver_version) - strlen(INTF_CARDTYPE) -
 					strlen(KERN_VERSION));
 	}
+#endif
+#ifdef USBIW62X
+	if (woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
+		    (__force __le16)USBIW62X_PID_1 ||
+	    woal_cpu_to_le16(cardp_usb->udev->descriptor.idProduct) ==
+		    (__force __le16)USBIW62X_PID_2) {
+		card_type = CARD_TYPE_USBIW62X;
+		moal_memcpy_ext(NULL, driver_version, CARD_USBIW62X,
+				strlen(CARD_USBIW62X), strlen(driver_version));
+		moal_memcpy_ext(NULL,
+				driver_version + strlen(INTF_CARDTYPE) +
+					strlen(KERN_VERSION),
+				V18, strlen(V18),
+				strlen(driver_version) - strlen(INTF_CARDTYPE) -
+					strlen(KERN_VERSION));
+	}
 #endif
 	return card_type;
 }
@@ -803,31 +865,38 @@ static int woal_usb_probe(struct usb_interface *intf,
 	/* Check probe is for our device */
 	for (i = 0; woal_usb_table[i].idVendor; i++) {
 		if (woal_cpu_to_le16(udev->descriptor.idVendor) ==
-			    woal_usb_table[i].idVendor &&
+			    (__force __le16)woal_usb_table[i].idVendor &&
 		    woal_cpu_to_le16(udev->descriptor.idProduct) ==
-			    woal_usb_table[i].idProduct) {
+			    (__force __le16)woal_usb_table[i].idProduct) {
 			PRINTM(MMSG, "VID/PID = %X/%X, Boot2 version = %X\n",
 			       woal_cpu_to_le16(udev->descriptor.idVendor),
 			       woal_cpu_to_le16(udev->descriptor.idProduct),
 			       woal_cpu_to_le16(udev->descriptor.bcdDevice));
 			switch (woal_cpu_to_le16(udev->descriptor.idProduct)) {
+#ifdef USB8801
+			case (__force __le16)USB8801_PID_1:
+#endif /* USB8801 */
 #ifdef USB8897
-			case USB8897_PID_1:
+			case (__force __le16)USB8897_PID_1:
 #endif /* USB8897 */
 #ifdef USB8997
-			case USB8997_PID_1:
-			case USB8997V2_PID_1:
+			case (__force __le16)USB8997_PID_1:
+			case (__force __le16)USB8997V2_PID_1:
 #endif /* USB8997 */
 #ifdef USB8978
-			case USB8978_PID_1:
-			case USB8978_PID_1_BT:
+			case (__force __le16)USB8978_PID_1:
+			case (__force __le16)USB8978_PID_1_BT:
 #endif /* USB8978 */
 #ifdef USB9098
-			case USB9098_PID_1:
+			case (__force __le16)USB9098_PID_1:
 #endif /* USB9098 */
 #ifdef USB9097
-			case USB9097_PID_1:
+			case (__force __le16)USB9097_PID_1:
 #endif /* USB9097 */
+#ifdef USBIW62X
+			case (__force __le16)USBIW62X_PID_1:
+#endif /* USBIW62X */
+
 				/* If skip FW is set, we must return error so
 				 * the next driver can download the FW */
 				if (skip_fwdnld)
@@ -835,22 +904,29 @@ static int woal_usb_probe(struct usb_interface *intf,
 				else
 					usb_cardp->boot_state = USB_FW_DNLD;
 				break;
+#ifdef USB8801
+			case (__force __le16)USB8801_PID_2:
+#endif /* USB8801 */
 #ifdef USB8897
-			case USB8897_PID_2:
+			case (__force __le16)USB8897_PID_2:
 #endif /* USB8897 */
 #ifdef USB8997
-			case USB8997_PID_2:
+			case (__force __le16)USB8997_PID_2:
 #endif /* USB8997 */
 #ifdef USB8978
-			case USB8978_PID_2:
-			case USB8978_PID_2_BT:
+			case (__force __le16)USB8978_PID_2:
+			case (__force __le16)USB8978_PID_2_BT:
 #endif /* USB8978 */
 #ifdef USB9098
-			case USB9098_PID_2:
+			case (__force __le16)USB9098_PID_2:
 #endif /* USB9098 */
 #ifdef USB9097
-			case USB9097_PID_2:
+			case (__force __le16)USB9097_PID_2:
 #endif /* USB9097 */
+#ifdef USBIW62X
+			case (__force __le16)USBIW62X_PID_2:
+#endif /* USBIW62X */
+
 				usb_cardp->boot_state = USB_FW_READY;
 				break;
 			}
@@ -937,7 +1013,25 @@ static int woal_usb_probe(struct usb_interface *intf,
 					endpoint->bEndpointAddress;
 				atomic_set(&usb_cardp->tx_data_urb_pending, 0);
 				usb_cardp->tx_data_maxpktsize =
-					woal_le16_to_cpu(
+					(__force int)woal_le16_to_cpu(
+						endpoint->wMaxPacketSize);
+			}
+			if (usb_endpoint_is_bulk_out(endpoint) &&
+			    (usb_endpoint_num(endpoint) ==
+				     MLAN_USB_EP_DATA_CH2 ||
+			     usb_endpoint_num(endpoint) ==
+				     MLAN_USB_EP_DATA_CH2_IF2)) {
+				/* We found a bulk out data endpoint */
+				PRINTM(MCMND,
+				       "Bulk OUT2: max packet size = %d, address = %d\n",
+				       woal_le16_to_cpu(
+					       endpoint->wMaxPacketSize),
+				       endpoint->bEndpointAddress);
+				usb_cardp->tx_data2_ep =
+					endpoint->bEndpointAddress;
+				atomic_set(&usb_cardp->tx_data2_urb_pending, 0);
+				usb_cardp->tx_data2_maxpktsize =
+					(__force int)woal_le16_to_cpu(
 						endpoint->wMaxPacketSize);
 			}
 
@@ -961,8 +1055,9 @@ static int woal_usb_probe(struct usb_interface *intf,
 				usb_cardp->tx_cmd_ep =
 					endpoint->bEndpointAddress;
 				atomic_set(&usb_cardp->tx_cmd_urb_pending, 0);
-				usb_cardp->tx_cmd_maxpktsize = woal_le16_to_cpu(
-					endpoint->wMaxPacketSize);
+				usb_cardp->tx_cmd_maxpktsize =
+					(__force int)woal_le16_to_cpu(
+						endpoint->wMaxPacketSize);
 			}
 		}
 
@@ -977,6 +1072,14 @@ static int woal_usb_probe(struct usb_interface *intf,
 				       __FUNCTION__);
 				goto error;
 			}
+			if (!usb_cardp->tx_data2_ep) {
+				PRINTM(MERROR,
+				       "%s: invalid endpoint assignment\n",
+				       __FUNCTION__);
+				PRINTM(MERROR,
+				       "%s: DATA2 endpoint is not enumarated\n",
+				       __FUNCTION__);
+			}
 		}
 
 		usb_cardp->tx_aggr_ctrl.enable = MFALSE;
@@ -1190,6 +1293,9 @@ static int woal_usb_suspend(struct usb_interface *intf, pm_message_t message)
 		if (cardp->tx_data_list[i].urb) {
 			usb_kill_urb(cardp->tx_data_list[i].urb);
 		}
+		if (cardp->tx_data2_list[i].urb) {
+			usb_kill_urb(cardp->tx_data2_list[i].urb);
+		}
 	}
 	/* Unlink Tx cmd URB */
 	if (cardp->tx_cmd.urb) {
@@ -1217,21 +1323,18 @@ static int woal_usb_resume(struct usb_interface *intf)
 	struct usb_card_rec *cardp = usb_get_intfdata(intf);
 	moal_handle *handle = NULL;
 	int i;
-	int ret = 0;
 
 	ENTER();
 
 	PRINTM(MCMND, "<--- Enter woal_usb_resume --->\n");
 	if (!cardp || !cardp->phandle) {
 		PRINTM(MERROR, "Card or adapter structure is not valid\n");
-		ret = 0;
 		goto done;
 	}
 	handle = cardp->phandle;
 
 	if (handle->is_suspended == MFALSE) {
 		PRINTM(MWARN, "Device already resumed\n");
-		ret = 0;
 		goto done;
 	}
 
@@ -1324,6 +1427,15 @@ mlan_status woal_usb_tx_init(moal_handle *handle)
 			ret = MLAN_STATUS_FAILURE;
 			goto init_exit;
 		}
+		cardp->tx_data2_list[i].handle = handle;
+		cardp->tx_data2_list[i].ep = cardp->tx_data2_ep;
+		/* Allocate URB for data */
+		cardp->tx_data2_list[i].urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!cardp->tx_data2_list[i].urb) {
+			PRINTM(MERROR, "Tx data URB allocation failed\n");
+			ret = MLAN_STATUS_FAILURE;
+			goto init_exit;
+		}
 	}
 
 init_exit:
@@ -1452,6 +1564,8 @@ static mlan_status woal_usb_write_data_sync(moal_handle *handle,
 		bulk_out_maxpktsize = cardp->tx_cmd_maxpktsize;
 	else if (ep == cardp->tx_data_ep)
 		bulk_out_maxpktsize = cardp->tx_data_maxpktsize;
+	else if (ep == cardp->tx_data2_ep)
+		bulk_out_maxpktsize = cardp->tx_data2_maxpktsize;
 
 	if (length % bulk_out_maxpktsize == 0)
 		length++;
@@ -1538,6 +1652,11 @@ mlan_status woal_write_data_async(moal_handle *handle, mlan_buffer *pmbuf,
 	    (atomic_read(&cardp->tx_data_urb_pending) >= MVUSB_TX_HIGH_WMARK)) {
 		ret = MLAN_STATUS_RESOURCE;
 		goto tx_ret;
+	} else if ((ep == cardp->tx_data2_ep) &&
+		   (atomic_read(&cardp->tx_data2_urb_pending) >=
+		    MVUSB_TX_HIGH_WMARK)) {
+		ret = MLAN_STATUS_RESOURCE;
+		goto tx_ret;
 	}
 	PRINTM(MINFO, "woal_write_data_async: ep=%d\n", ep);
 
@@ -1550,6 +1669,11 @@ mlan_status woal_write_data_async(moal_handle *handle, mlan_buffer *pmbuf,
 			if (cardp->tx_data_ix >= MVUSB_TX_HIGH_WMARK)
 				cardp->tx_data_ix = 0;
 			context = &cardp->tx_data_list[cardp->tx_data_ix++];
+		} else if (ep == cardp->tx_data2_ep) {
+			bulk_out_maxpktsize = cardp->tx_data2_maxpktsize;
+			if (cardp->tx_data2_ix >= MVUSB_TX_HIGH_WMARK)
+				cardp->tx_data2_ix = 0;
+			context = &cardp->tx_data2_list[cardp->tx_data2_ix++];
 		}
 	}
 
@@ -1591,6 +1715,8 @@ mlan_status woal_write_data_async(moal_handle *handle, mlan_buffer *pmbuf,
 		atomic_inc(&cardp->tx_cmd_urb_pending);
 	else if (ep == cardp->tx_data_ep)
 		atomic_inc(&cardp->tx_data_urb_pending);
+	else if (ep == cardp->tx_data2_ep)
+		atomic_inc(&cardp->tx_data2_urb_pending);
 	if (usb_submit_urb(tx_urb, GFP_ATOMIC)) {
 		/* Submit URB failure */
 		PRINTM(MERROR, "Submit EP %d Tx URB failed: %d\n", ep, ret);
@@ -1603,6 +1729,13 @@ mlan_status woal_write_data_async(moal_handle *handle, mlan_buffer *pmbuf,
 					cardp->tx_data_ix--;
 				else
 					cardp->tx_data_ix = MVUSB_TX_HIGH_WMARK;
+			} else if (ep == cardp->tx_data2_ep) {
+				atomic_dec(&cardp->tx_data2_urb_pending);
+				if (cardp->tx_data2_ix)
+					cardp->tx_data2_ix--;
+				else
+					cardp->tx_data2_ix =
+						MVUSB_TX_HIGH_WMARK;
 			}
 		}
 		ret = MLAN_STATUS_FAILURE;
@@ -1611,6 +1744,10 @@ mlan_status woal_write_data_async(moal_handle *handle, mlan_buffer *pmbuf,
 		    (atomic_read(&cardp->tx_data_urb_pending) ==
 		     MVUSB_TX_HIGH_WMARK))
 			ret = MLAN_STATUS_PRESOURCE;
+		else if (ep == cardp->tx_data2_ep &&
+			 (atomic_read(&cardp->tx_data2_urb_pending) ==
+			  MVUSB_TX_HIGH_WMARK))
+			ret = MLAN_STATUS_PRESOURCE;
 		else
 			ret = MLAN_STATUS_SUCCESS;
 	}
@@ -1862,7 +1999,7 @@ void woal_submit_rx_urb(moal_handle *handle, t_u8 ep)
  *
  *  @return         N/A
  */
-void woal_usb_dump_fw_info(moal_handle *phandle)
+static void woal_usb_dump_fw_info(moal_handle *phandle)
 {
 	moal_private *priv = NULL;
 	mlan_ioctl_req *req = NULL;
@@ -1873,13 +2010,13 @@ void woal_usb_dump_fw_info(moal_handle *phandle)
 
 	priv = woal_get_priv(phandle, MLAN_BSS_ROLE_ANY);
 	if (!priv) {
-		PRINTM(MERROR, "woal_dump_firmware_info get priv is NULL!\n");
+		PRINTM(MERROR, "woal_usb_dump_fw_info: priv is NULL!\n");
 		goto done;
 	}
 	/* Allocate an IOCTL request buffer */
 	req = woal_alloc_mlan_ioctl_req(sizeof(mlan_ds_misc_cfg));
 	if (req == NULL) {
-		PRINTM(MERROR, "woal_dump_firmware_info alloc req fail!\n");
+		PRINTM(MERROR, "woal_usb_dump_fw_info: alloc req fail!\n");
 		goto done;
 	}
 
@@ -1894,6 +2031,8 @@ void woal_usb_dump_fw_info(moal_handle *phandle)
 
 	if (status != MLAN_STATUS_PENDING)
 		kfree(req);
+	phandle->is_fw_dump_timer_set = MTRUE;
+	woal_mod_timer(&phandle->fw_dump_timer, MOAL_TIMER_5S);
 
 done:
 	LEAVE();
@@ -1903,9 +2042,11 @@ void woal_usb_dump_fw_info(moal_handle *phandle)
 static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 {
 	mlan_status ret = MLAN_STATUS_SUCCESS;
-#if defined(USB8997) || defined(USB9098) || defined(USB9097) || defined(USB8978)
+#if defined(USB8997) || defined(USB9098) || defined(USB9097) ||                \
+	defined(USB8978) || defined(USBIW62X)
 	t_u32 revision_id = 0;
 	t_u32 strap = 0;
+	t_u32 boot_mode = 0;
 #endif
 	struct usb_card_rec *cardp = (struct usb_card_rec *)handle->card;
 #if defined(USB9098)
@@ -1917,8 +2058,15 @@ static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 		goto done;
 	if (cardp->boot_state == USB_FW_READY)
 		goto done;
-#if defined(USB8997) || defined(USB9098) || defined(USB9097) || defined(USB8978)
-	ret = woal_check_chip_revision(handle, &revision_id, &strap);
+#ifdef USB8801
+	if (IS_USB8801(handle->card_type))
+		goto done;
+#endif
+
+#if defined(USB8997) || defined(USB9098) || defined(USB9097) ||                \
+	defined(USB8978) || defined(USBIW62X)
+	ret = woal_check_chip_revision(handle, &revision_id, &strap,
+				       &boot_mode);
 	if (ret != MLAN_STATUS_SUCCESS) {
 		PRINTM(MFATAL, "Chip revision check failure!\n");
 		ret = MLAN_STATUS_FAILURE;
@@ -1930,22 +2078,26 @@ static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 #ifdef USB8997
 	if (IS_USB8997(handle->card_type)) {
 		if (strap == CARD_TYPE_USB_UART)
-			strcpy(handle->card_info->fw_name,
-			       USBUART8997_DEFAULT_COMBO_FW_NAME);
+			strncpy(handle->card_info->fw_name,
+				USBUART8997_DEFAULT_COMBO_FW_NAME,
+				FW_NAMW_MAX_LEN);
 		else if (strap != 0)
-			strcpy(handle->card_info->fw_name,
-			       USBUSB8997_DEFAULT_COMBO_FW_NAME);
+			strncpy(handle->card_info->fw_name,
+				USBUSB8997_DEFAULT_COMBO_FW_NAME,
+				FW_NAMW_MAX_LEN);
 	}
 #endif
 
 #ifdef USB8978
 	if (IS_USB8978(handle->card_type)) {
 		if (strap == CARD_TYPE_USB_UART)
-			strcpy(handle->card_info->fw_name,
-			       USBUART8978_DEFAULT_COMBO_FW_NAME);
+			strncpy(handle->card_info->fw_name,
+				USBUART8978_DEFAULT_COMBO_FW_NAME,
+				FW_NAMW_MAX_LEN);
 		else if (strap != 0)
-			strcpy(handle->card_info->fw_name,
-			       USBUSB8978_DEFAULT_COMBO_FW_NAME);
+			strncpy(handle->card_info->fw_name,
+				USBUSB8978_DEFAULT_COMBO_FW_NAME,
+				FW_NAMW_MAX_LEN);
 	}
 #endif
 
@@ -1954,10 +2106,12 @@ static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 		if (cardp->second_mac) {
 			ref_handle = (moal_handle *)handle->pref_mac;
 			if (ref_handle) {
-				strcpy(handle->card_info->fw_name,
-				       ref_handle->card_info->fw_name);
-				strcpy(handle->card_info->fw_name_wlan,
-				       ref_handle->card_info->fw_name_wlan);
+				strncpy(handle->card_info->fw_name,
+					ref_handle->card_info->fw_name,
+					FW_NAMW_MAX_LEN);
+				strncpy(handle->card_info->fw_name_wlan,
+					ref_handle->card_info->fw_name_wlan,
+					FW_NAMW_MAX_LEN);
 			}
 			goto done;
 		}
@@ -1965,28 +2119,32 @@ static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 		case USB9098_Z1Z2:
 			if (strap != 0) {
 				if (strap == CARD_TYPE_USB_UART)
-					strcpy(handle->card_info->fw_name,
-					       USBUART9098_DEFAULT_COMBO_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUART9098_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       USBUSB9098_DEFAULT_COMBO_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUSB9098_DEFAULT_COMBO_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       USB9098_DEFAULT_WLAN_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				USB9098_DEFAULT_WLAN_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		case USB9098_A0:
 		case USB9098_A1:
 		case USB9098_A2:
 			if (strap != 0) {
 				if (strap == CARD_TYPE_USB_UART)
-					strcpy(handle->card_info->fw_name,
-					       USBUART9098_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUART9098_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       USBUSB9098_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUSB9098_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       USB9098_WLAN_V1_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				USB9098_WLAN_V1_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		}
 	}
@@ -1998,18 +2156,33 @@ static mlan_status woal_usb_get_fw_name(moal_handle *handle)
 		case USB9097_B1:
 			if (strap != 0) {
 				if (strap == CARD_TYPE_USB_UART)
-					strcpy(handle->card_info->fw_name,
-					       USBUART9097_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUART9097_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 				else
-					strcpy(handle->card_info->fw_name,
-					       USBUSB9097_COMBO_V1_FW_NAME);
+					strncpy(handle->card_info->fw_name,
+						USBUSB9097_COMBO_V1_FW_NAME,
+						FW_NAMW_MAX_LEN);
 			}
-			strcpy(handle->card_info->fw_name_wlan,
-			       USB9097_WLAN_V1_FW_NAME);
+			strncpy(handle->card_info->fw_name_wlan,
+				USB9097_WLAN_V1_FW_NAME, FW_NAMW_MAX_LEN);
 			break;
 		}
 	}
 #endif
+#ifdef USBIW62X
+	if (IS_USBIW62X(handle->card_type)) {
+		if (boot_mode == 0x03)
+			PRINTM(MMSG, "wlan: USB-IW62X in secure-boot mode\n");
+		if (strap == CARD_TYPE_USB_UART)
+			strncpy(handle->card_info->fw_name,
+				USBUARTIW62X_COMBO_FW_NAME, FW_NAMW_MAX_LEN);
+		else
+			strncpy(handle->card_info->fw_name,
+				USBUSBIW62X_COMBO_FW_NAME, FW_NAMW_MAX_LEN);
+	}
+#endif
+
 done:
 	PRINTM(MCMND, "combo fw:%s wlan fw:%s \n", handle->card_info->fw_name,
 	       handle->card_info->fw_name_wlan);
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h
old mode 100644
new mode 100755
index 7c95c28be..7a033644c
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_usb.h
@@ -4,7 +4,7 @@
  * driver.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -28,6 +28,14 @@ Change Log:
 #ifndef _MOAL_USB_H
 #define _MOAL_USB_H
 
+#ifdef USB8801
+/** USB VID 1 */
+#define USB8801_VID_1 0x1286
+/** USB PID 1 */
+#define USB8801_PID_1 0x2049
+/** USB PID 2 */
+#define USB8801_PID_2 0x204a
+#endif /* USB8801 */
 #ifdef USB8997
 /** USB VID 1 */
 #define USB8997_VID_1 0x1286
@@ -81,6 +89,15 @@ Change Log:
 #define USB9097_PID_2 0x2061
 #endif /* USB9097 */
 
+#ifdef USBIW62X
+/** USB VID 1 */
+#define USBIW62X_VID_1 0x0471
+/** USB PID 1 */
+#define USBIW62X_PID_1 0x020E
+/** USB PID 2 */
+#define USBIW62X_PID_2 0x020F
+#endif /* USBIW62X */
+
 /** Boot state: FW download */
 #define USB_FW_DNLD 1
 /** Boot state: FW ready */
@@ -92,7 +109,8 @@ Change Log:
 /** Number of Rx data URB */
 #define MVUSB_RX_DATA_URB 6
 
-#if defined(USB8997) || defined(USB9098) || defined(USB9097) || defined(USB8978)
+#if defined(USB8997) || defined(USB9098) || defined(USB9097) ||                \
+	defined(USB8978) || defined(USB8801) || defined(USBIW62X)
 /* Transmit buffer size for chip revision check */
 #define CHIP_REV_TX_BUF_SIZE 16
 /* Receive buffer size for chip revision check */
@@ -102,6 +120,10 @@ Change Log:
 #define EXTEND_HDR (0xAB950000)
 #define EXTEND_V1 (0x00000001)
 #define EXTEND_V2 (0x00000002)
+#define EXTEND_V3 (0x00000003)
+#ifdef USB8801
+#define USB8801_DEFAULT_WLAN_FW_NAME "nxp/usb8801_uapsta.bin"
+#endif /* USB8801 */
 
 #endif
 
@@ -115,10 +137,10 @@ Change Log:
 #endif /* USB8997 */
 
 #ifdef USB8978
-#define USB8978_DEFAULT_COMBO_FW_NAME "nxp/usbusb8978_combo.bin"
-#define USB8978_DEFAULT_WLAN_FW_NAME "nxp/usb8978_wlan.bin"
-#define USBUART8978_DEFAULT_COMBO_FW_NAME "nxp/usbuart8978_combo.bin"
-#define USBUSB8978_DEFAULT_COMBO_FW_NAME "nxp/usbusb8978_combo.bin"
+#define USB8978_DEFAULT_COMBO_FW_NAME "nxp/usbusbiw416_combo.bin"
+#define USB8978_DEFAULT_WLAN_FW_NAME "nxp/usbiw416_wlan.bin"
+#define USBUART8978_DEFAULT_COMBO_FW_NAME "nxp/usbuartiw416_combo.bin"
+#define USBUSB8978_DEFAULT_COMBO_FW_NAME "nxp/usbusbiw416_combo.bin"
 #endif /* USB8978 */
 
 #ifdef USB8897
@@ -143,13 +165,20 @@ Change Log:
 #ifdef USB9097
 #define USB9097_B0 0x01
 #define USB9097_B1 0x02
-#define USB9097_DEFAULT_COMBO_FW_NAME "nxp/usbusb9097_combo_v1.bin"
-#define USB9097_DEFAULT_WLAN_FW_NAME "nxp/usb9097_wlan_v1.bin"
-#define USB9097_WLAN_V1_FW_NAME "nxp/usb9097_wlan_v1.bin"
-#define USBUART9097_COMBO_V1_FW_NAME "nxp/usbuart9097_combo_v1.bin"
-#define USBUSB9097_COMBO_V1_FW_NAME "nxp/usbusb9097_combo_v1.bin"
+#define USB9097_DEFAULT_COMBO_FW_NAME "nxp/usbusbiw620_combo_v1.bin"
+#define USB9097_DEFAULT_WLAN_FW_NAME "nxp/usbiw620_wlan_v1.bin"
+#define USB9097_WLAN_V1_FW_NAME "nxp/usbiw620_wlan_v1.bin"
+#define USBUART9097_COMBO_V1_FW_NAME "nxp/usbuartiw620_combo_v1.bin"
+#define USBUSB9097_COMBO_V1_FW_NAME "nxp/usbusbiw620_combo_v1.bin"
 #endif /* USB9097 */
 
+#ifdef USBIW62X
+#define USBIW62X_DEFAULT_COMBO_FW_NAME "nxp/usbusbiw62x_combo.bin"
+#define USBUARTIW62X_COMBO_FW_NAME "nxp/usbuartiw62x_combo.bin"
+#define USBUSBIW62X_COMBO_FW_NAME "nxp/usbusbiw62x_combo.bin"
+#define USBIW62X_DEFAULT_WLAN_FW_NAME "nxp/usbiw62x_wlan.bin"
+#endif /* USBIW62X */
+
 /** urb context */
 typedef struct _urb_context {
 	/** Pointer to moal_handle structure */
@@ -210,11 +239,21 @@ struct usb_card_rec {
 	int tx_data_ix;
 	/** Pre-allocated urb for data */
 	urb_context tx_data_list[MVUSB_TX_HIGH_WMARK];
-	usb_aggr_ctrl tx_aggr_ctrl;
-	usb_aggr_ctrl rx_deaggr_ctrl;
+	usb_aggr_ctrl_cfg tx_aggr_ctrl;
+	usb_aggr_ctrl_cfg rx_deaggr_ctrl;
 	t_u8 resubmit_urbs;
 	/** USB card type */
 	t_u16 card_type;
+	/** Tx data endpoint address */
+	t_u8 tx_data2_ep;
+	/** Tx data endpoint max pkt size */
+	int tx_data2_maxpktsize;
+	/** Tx data2 URB pending count */
+	atomic_t tx_data2_urb_pending;
+	/** Index to point to next data urb to use */
+	int tx_data2_ix;
+	/** Pre-allocated urb for data */
+	urb_context tx_data2_list[MVUSB_TX_HIGH_WMARK];
 	t_u8 second_mac;
 };
 
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.c b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.c
old mode 100644
new mode 100755
index 0072b18a0..f37f4855e
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.c
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.c
@@ -3,7 +3,7 @@
  * @brief This file contains wireless extension standard ioctl functions
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
@@ -33,8 +33,207 @@ Change log:
 	(IW_EV_ADDR_LEN + MLAN_MAX_SSID_LENGTH + IW_EV_UINT_LEN +              \
 	 IW_EV_FREQ_LEN + IW_EV_QUAL_LEN + MLAN_MAX_SSID_LENGTH +              \
 	 IW_EV_PARAM_LEN + 40) /* 40 for WPAIE */
-/** Macro for minimum size of scan buffer */
-#define MIN_ACCEPTED_GET_SCAN_BUF 8000
+
+/********************************************************
+			Local Variables
+********************************************************/
+/**
+ * iwpriv ioctl handlers
+ */
+static const struct iw_priv_args woal_private_args[] = {
+	{WOAL_SETONEINT_GETWORDCHAR, IW_PRIV_TYPE_INT | 1,
+	 IW_PRIV_TYPE_CHAR | 128, ""},
+	{WOAL_VERSION, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128,
+	 "version"},
+	{WOAL_VEREXT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_CHAR | 128, "verext"},
+	{WOAL_SETNONE_GETNONE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, ""},
+	{WOAL_WARMRESET, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "warmreset"},
+#ifdef CONFIG_USB_SUSPEND
+	{WOAL_USB_SUSPEND, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "usbsuspend"},
+	{WOAL_USB_RESUME, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "usbresume"},
+#endif /* CONFIG_USB_SUSPEND */
+	{WOAL_SETONEINT_GETONEINT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 ""},
+	{WOAL_SET_GET_TXRATE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "txratecfg"},
+	{WOAL_SET_GET_REGIONCODE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "regioncode"},
+	{WOAL_SET_RADIO, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "radioctrl"},
+	{WOAL_WMM_ENABLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "wmmcfg"},
+	{WOAL_11D_ENABLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "11dcfg"},
+	{WOAL_11D_CLR_CHAN_TABLE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE,
+	 "11dclrtbl"},
+	{WOAL_SET_GET_QOS_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "qoscfg"},
+#ifndef OPCHAN
+	{WOAL_SET_GET_WWS_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "wwscfg"},
+#endif
+#if defined(REASSOCIATION)
+	{WOAL_SET_GET_REASSOC, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "reassoctrl"},
+#endif
+	{WOAL_TXBUF_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "txbufcfg"},
+	{WOAL_SLEEP_PD, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "sleeppd"},
+	{WOAL_AUTH_TYPE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "authtype"},
+	{WOAL_PORT_CTRL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "port_ctrl"},
+#ifdef WIFI_DIRECT_SUPPORT
+#if defined(STA_SUPPORT) && defined(UAP_SUPPORT)
+	{WOAL_SET_GET_BSS_ROLE, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "bssrole"},
+#endif
+#endif
+	{WOAL_SET_GET_11H_LOCAL_PWR_CONSTRAINT, IW_PRIV_TYPE_INT | 1,
+	 IW_PRIV_TYPE_INT | 1, "powercons"},
+	{WOAL_HT_STREAM_CFG, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "htstreamcfg"},
+	{WOAL_MAC_CONTROL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "macctrl"},
+	{WOAL_THERMAL, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1, "thermal"},
+	{WOAL_CFG_HOTSPOT, IW_PRIV_TYPE_INT | 1, IW_PRIV_TYPE_INT | 1,
+	 "hotspotcfg"},
+	{WOAL_SET_GET_SIXTEEN_INT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 ""},
+	{WOAL_TX_POWERCFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "txpowercfg"},
+#ifdef DEBUG_LEVEL1
+	{WOAL_DRV_DBG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "drvdbg"},
+#endif
+	{WOAL_BEACON_INTERVAL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "bcninterval"},
+	{WOAL_SIGNAL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "getsignal"},
+	{
+		WOAL_DEEP_SLEEP,
+		IW_PRIV_TYPE_INT | 16,
+		IW_PRIV_TYPE_INT | 16,
+		"deepsleep",
+	},
+	{WOAL_11N_TX_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "httxcfg"},
+	{WOAL_11N_HTCAP_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "htcapinfo"},
+	{WOAL_PRIO_TBL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "aggrpriotbl"},
+	{WOAL_11N_AMSDU_AGGR_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "amsduaggrctrl"},
+	{WOAL_ADDBA_UPDT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "addbapara"},
+	{WOAL_ADDBA_REJECT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "addbareject"},
+	{WOAL_TX_BF_CAP, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "httxbfcap"},
+	{WOAL_HS_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "hscfg"},
+	{WOAL_HS_SETPARA, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "hssetpara"},
+	{WOAL_REG_READ_WRITE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "regrdwr"},
+	{WOAL_BAND_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "bandcfg"},
+	{WOAL_INACTIVITY_TIMEOUT_EXT, IW_PRIV_TYPE_INT | 16,
+	 IW_PRIV_TYPE_INT | 16, "inactivityto"},
+#ifdef SDIO
+	{WOAL_SDIO_CLOCK, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "sdioclock"},
+	{WOAL_CMD_52RDWR, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "sdcmd52rw"},
+#endif
+	{WOAL_SCAN_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "scancfg"},
+	{WOAL_PS_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16, "pscfg"},
+	{WOAL_MEM_READ_WRITE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "memrdwr"},
+#ifdef SDIO
+	{WOAL_SDIO_MPA_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "mpactrl"},
+#endif
+	{WOAL_SLEEP_PARAMS, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "sleepparams"},
+	{WOAL_NET_MONITOR, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "netmon"},
+	{WOAL_DFS_TESTING, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "dfstesting"},
+	{WOAL_MGMT_FRAME_CTRL, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "mgmtframectrl"},
+	{WOAL_CFP_CODE, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "cfpcode"},
+	{WOAL_SET_GET_TX_RX_ANT, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "antcfg"},
+	{WOAL_IND_RST_CFG, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_INT | 16,
+	 "indrstcfg"},
+	{WOALGETLOG, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | GETLOG_BUFSIZE,
+	 "getlog"},
+	{WOAL_SETADDR_GETNONE, IW_PRIV_TYPE_ADDR | 1, IW_PRIV_TYPE_NONE, ""},
+	{WOAL_DEAUTH, IW_PRIV_TYPE_ADDR | 1, IW_PRIV_TYPE_NONE, "deauth"},
+	{WOAL_SET_GET_256_CHAR, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, ""},
+	{WOAL_PASSPHRASE, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "passphrase"},
+	{WOAL_GET_KEY, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "getkey"},
+	{WOAL_ASSOCIATE, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "associate"},
+	{WOAL_WMM_QUEUE_STATUS, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, "qstatus"},
+	{WOAL_WMM_TS_STATUS, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "ts_status"},
+	{WOAL_IP_ADDRESS, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "ipaddr"},
+	{WOAL_TX_BF_CFG, IW_PRIV_TYPE_CHAR | 256, IW_PRIV_TYPE_CHAR | 256,
+	 "httxbfcfg"},
+	{WOAL_SETNONE_GETTWELVE_CHAR, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | 12,
+	 ""},
+	{WOAL_WPS_SESSION, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_CHAR | 12,
+	 "wpssession"},
+	{WOAL_SETNONE_GET_FOUR_INT, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4,
+	 ""},
+	{WOAL_DATA_RATE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4,
+	 "getdatarate"},
+	{WOAL_ESUPP_MODE, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | 4, "esuppmode"},
+	{WOAL_SET_GET_64_INT, IW_PRIV_TYPE_INT | 64, IW_PRIV_TYPE_INT | 64, ""},
+	{WOAL_ECL_SYS_CLOCK, IW_PRIV_TYPE_INT | 64, IW_PRIV_TYPE_INT | 64,
+	 "sysclock"},
+	{WOAL_HOST_CMD, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_BYTE | 2047,
+	 "hostcmd"},
+	{WOAL_ARP_FILTER, IW_PRIV_TYPE_BYTE | 2047, IW_PRIV_TYPE_BYTE | 2047,
+	 "arpfilter"},
+	{WOAL_SET_INTS_GET_CHARS, IW_PRIV_TYPE_INT | 16,
+	 IW_PRIV_TYPE_BYTE | 256, ""},
+	{WOAL_READ_EEPROM, IW_PRIV_TYPE_INT | 16, IW_PRIV_TYPE_BYTE | 256,
+	 "rdeeprom"},
+	{WOAL_SET_GET_2K_BYTES, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, ""},
+#if defined(SDIO)
+	{WOAL_CMD_53RDWR, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "sdcmd53rw"},
+#endif
+	{WOAL_SET_USER_SCAN, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "setuserscan"},
+	{WOAL_GET_SCAN_TABLE, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "getscantable"},
+	{WOAL_SET_USER_SCAN_EXT, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "setuserscanext"},
+	{WOAL_WMM_ADDTS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "addts"},
+	{WOAL_WMM_DELTS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "delts"},
+	{WOAL_WMM_QUEUE_CONFIG, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "qconfig"},
+	{WOAL_WMM_QUEUE_STATS, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "qstats"},
+	{WOAL_BYPASSED_PACKET, IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES,
+	 IW_PRIV_TYPE_BYTE | WOAL_2K_BYTES, "pb_bypass"},
+#ifdef UAP_WEXT
+	{WOAL_FROYO_START, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "START"},
+	{WOAL_FROYO_STOP, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_NONE, "STOP"},
+	{WOAL_FROYO_WL_FW_RELOAD, IW_PRIV_TYPE_CHAR | 256,
+	 IW_PRIV_TYPE_CHAR | 256, "WL_FW_RELOAD"},
+#endif
+};
 
 /********************************************************
 			Local Functions
@@ -218,7 +417,7 @@ static int woal_get_name(struct net_device *dev, struct iw_request_info *info,
 {
 	char *cwrq = wrqu->name;
 	ENTER();
-	strcpy(cwrq, "IEEE 802.11-DS");
+	strncpy(cwrq, "IEEE 802.11-DS", IFNAMSIZ);
 	LEAVE();
 	return 0;
 }
@@ -409,15 +608,24 @@ static int woal_get_wap(struct net_device *dev, struct iw_request_info *info,
 
 	memset(&bss_info, 0, sizeof(bss_info));
 
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		ret = -EFAULT;
+		goto done;
+	}
 
 	if (bss_info.media_connected == MTRUE)
 		moal_memcpy_ext(priv->phandle, awrq->sa_data, &bss_info.bssid,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+				MLAN_MAC_ADDR_LENGTH,
+				sizeof(awrq->sa_data_min));
+#else
 				MLAN_MAC_ADDR_LENGTH, sizeof(awrq->sa_data));
+#endif
 	else
 		memset(awrq->sa_data, 0, MLAN_MAC_ADDR_LENGTH);
 	awrq->sa_family = ARPHRD_ETHER;
-
+done:
 	LEAVE();
 	return ret;
 }
@@ -591,30 +799,32 @@ static int woal_get_sens(struct net_device *dev, struct iw_request_info *info,
  *
  *  @param dev                  A pointer to net_device structure
  *  @param info                 A pointer to iw_request_info structure
- *  @param vwrq                 A pointer to iw_param structure
+ *  @param vwrq                 A pointer to iwreq_data structure
  *  @param extra                A pointer to extra data buf
  *
  *  @return                     0 --success, otherwise fail
  */
 static int woal_set_txpow(struct net_device *dev, struct iw_request_info *info,
-			  struct iw_param *vwrq, char *extra)
+			  union iwreq_data *vwrq, char *extra)
 {
 	int ret = 0;
+	struct iw_param *vwrq_ = (struct iw_param *)vwrq;
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_power_cfg_t power_cfg;
 
 	ENTER();
-	if (vwrq->disabled) {
+	memset(&power_cfg, 0, sizeof(mlan_power_cfg_t));
+	if (vwrq_->disabled) {
 		woal_set_radio(priv, 0);
 		goto done;
 	}
 	woal_set_radio(priv, 1);
 
-	if (!vwrq->fixed)
+	if (!vwrq_->fixed)
 		power_cfg.is_power_auto = 1;
 	else {
 		power_cfg.is_power_auto = 0;
-		power_cfg.power_level = vwrq->value;
+		power_cfg.power_level = vwrq_->value;
 	}
 
 	if (MLAN_STATUS_SUCCESS !=
@@ -633,15 +843,16 @@ static int woal_set_txpow(struct net_device *dev, struct iw_request_info *info,
  *
  *  @param dev                  A pointer to net_device structure
  *  @param info                 A pointer to iw_request_info structure
- *  @param vwrq                 A pointer to iw_param structure
+ *  @param vwrq                 A pointer to iwreq_data structure
  *  @param extra                A pointer to extra data buf
  *
  *  @return                     0 --success, otherwise fail
  */
 static int woal_get_txpow(struct net_device *dev, struct iw_request_info *info,
-			  struct iw_param *vwrq, char *extra)
+			  union iwreq_data *vwrq, char *extra)
 {
 	int ret = 0;
+	struct iw_param *vwrq_ = (struct iw_param *)vwrq;
 	moal_private *priv = (moal_private *)netdev_priv(dev);
 	mlan_power_cfg_t power_cfg;
 	mlan_bss_info bss_info;
@@ -650,7 +861,11 @@ static int woal_get_txpow(struct net_device *dev, struct iw_request_info *info,
 
 	memset(&power_cfg, 0, sizeof(mlan_power_cfg_t));
 	memset(&bss_info, 0, sizeof(bss_info));
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		ret = -EFAULT;
+		goto done;
+	}
 
 	if (MLAN_STATUS_SUCCESS !=
 	    woal_set_get_tx_power(priv, MLAN_ACT_GET, &power_cfg)) {
@@ -658,16 +873,16 @@ static int woal_get_txpow(struct net_device *dev, struct iw_request_info *info,
 		goto done;
 	}
 
-	vwrq->value = power_cfg.power_level;
+	vwrq_->value = power_cfg.power_level;
 	if (power_cfg.is_power_auto)
-		vwrq->fixed = 0;
+		vwrq_->fixed = 0;
 	else
-		vwrq->fixed = 1;
+		vwrq_->fixed = 1;
 	if (bss_info.radio_on) {
-		vwrq->disabled = 0;
-		vwrq->flags = IW_TXPOW_DBM;
+		vwrq_->disabled = 0;
+		vwrq_->flags = IW_TXPOW_DBM;
 	} else {
-		vwrq->disabled = 1;
+		vwrq_->disabled = 1;
 	}
 
 done:
@@ -1063,6 +1278,8 @@ static int woal_set_rate(struct net_device *dev, struct iw_request_info *info,
 
 	ENTER();
 
+	memset(&rate_cfg, 0, sizeof(mlan_rate_cfg_t));
+
 	if (vwrq->value == -1) {
 		rate_cfg.is_rate_auto = 1;
 	} else {
@@ -1771,6 +1988,7 @@ static int woal_get_range(struct net_device *dev, struct iw_request_info *info,
 	mlan_chan_list *pchan_list = NULL;
 	mlan_bss_info bss_info;
 	gfp_t flag;
+	int ret = 0;
 
 	ENTER();
 
@@ -1900,7 +2118,11 @@ static int woal_get_range(struct net_device *dev, struct iw_request_info *info,
 
 	memset(&bss_info, 0, sizeof(bss_info));
 
-	woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info);
+	if (MLAN_STATUS_SUCCESS !=
+	    woal_get_bss_info(priv, MOAL_IOCTL_WAIT, &bss_info)) {
+		ret = -EFAULT;
+		goto done;
+	}
 
 	range->txpower[0] = bss_info.min_power_level;
 	range->txpower[1] = bss_info.max_power_level;
@@ -1911,8 +2133,9 @@ static int woal_get_range(struct net_device *dev, struct iw_request_info *info,
 	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
 			  IW_ENC_CAPA_CIPHER_CCMP | IW_ENC_CAPA_CIPHER_TKIP;
 #endif
+done:
 	LEAVE();
-	return 0;
+	return ret;
 }
 
 #ifdef MEF_CFG_RX_FILTER
@@ -2015,7 +2238,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2033,11 +2256,12 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "%s rssi %d\n", bss_info.ssid.ssid,
-				      signal.bcn_rssi_avg) +
+			len = snprintf(buf, MAX_BUF_LEN, "%s rssi %d\n",
+				       bss_info.ssid.ssid,
+				       signal.bcn_rssi_avg) +
 			      1;
 		} else {
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		}
 	} else if (strncmp(buf, "LINKSPEED", strlen("LINKSPEED")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -2046,14 +2270,15 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 			goto done;
 		}
 		PRINTM(MIOCTL, "tx rate=%d\n", (int)rate.rate);
-		len = sprintf(buf, "LinkSpeed %d\n",
-			      (int)(rate.rate * 500000 / 1000000)) +
+		len = snprintf(buf, MAX_BUF_LEN, "LinkSpeed %d\n",
+			       (int)(rate.rate * 500000 / 1000000)) +
 		      1;
 	} else if (strncmp(buf, "MACADDR", strlen("MACADDR")) == 0) {
-		len = sprintf(buf, "Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
-			      priv->current_addr[0], priv->current_addr[1],
-			      priv->current_addr[2], priv->current_addr[3],
-			      priv->current_addr[4], priv->current_addr[5]) +
+		len = snprintf(buf, MAX_BUF_LEN,
+			       "Macaddr = %02X:%02X:%02X:%02X:%02X:%02X\n",
+			       priv->current_addr[0], priv->current_addr[1],
+			       priv->current_addr[2], priv->current_addr[3],
+			       priv->current_addr[4], priv->current_addr[5]) +
 		      1;
 	} else if (strncmp(buf, "GETPOWER", strlen("GETPOWER")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -2061,7 +2286,9 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "powermode = %d\n", power_mode) + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "powermode = %d\n",
+			       power_mode) +
+		      1;
 	} else if (strncmp(buf, "SCAN-ACTIVE", strlen("SCAN-ACTIVE")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_set_scan_type(priv, MLAN_SCAN_TYPE_ACTIVE)) {
@@ -2070,7 +2297,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 		}
 		priv->scan_type = MLAN_SCAN_TYPE_ACTIVE;
 		PRINTM(MIOCTL, "Set Active Scan\n");
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SCAN-PASSIVE", strlen("SCAN-PASSIVE")) == 0) {
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_set_scan_type(priv, MLAN_SCAN_TYPE_PASSIVE)) {
@@ -2079,7 +2306,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 		}
 		priv->scan_type = MLAN_SCAN_TYPE_PASSIVE;
 		PRINTM(MIOCTL, "Set Passive Scan\n");
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "POWERMODE", strlen("POWERMODE")) == 0) {
 		if (dwrq->length > strlen("POWERMODE") + 1) {
 			pdata = buf + strlen("POWERMODE") + 1;
@@ -2090,7 +2317,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 					goto done;
 				}
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2110,7 +2337,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (memcmp(buf, WEXT_CSCAN_HEADER, strlen(WEXT_CSCAN_HEADER)) ==
 		   0) {
 		PRINTM(MIOCTL, "Set Combo Scan\n");
@@ -2119,38 +2346,38 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "GETBAND", strlen("GETBAND")) == 0) {
 		if (MLAN_STATUS_SUCCESS != woal_get_band(priv, &band)) {
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "Band %d\n", band) + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "Band %d\n", band) + 1;
 	} else if (strncmp(buf, "SETBAND", strlen("SETBAND")) == 0) {
 		pband = buf + strlen("SETBAND") + 1;
 		if (MLAN_STATUS_SUCCESS != woal_set_band(priv, pband)) {
 			ret = -EFAULT;
 			goto done;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "START", strlen("START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "STOP", strlen("STOP")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "SETSUSPENDOPT", strlen("SETSUSPENDOPT")) ==
 		   0) {
 		/* it will be done by GUI */
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXMODE", strlen("BTCOEXMODE")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXSCAN-START",
 			   strlen("BTCOEXSCAN-START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BTCOEXSCAN-STOP", strlen("BTCOEXSCAN-STOP")) ==
 		   0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BGSCAN-START", strlen("BGSCAN-START")) == 0) {
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BGSCAN-CONFIG", strlen("BGSCAN-CONFIG")) ==
 		   0) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -2160,7 +2387,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 		}
 		priv->bg_scan_start = MTRUE;
 		priv->bg_scan_reported = MFALSE;
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "BGSCAN-STOP", strlen("BGSCAN-STOP")) == 0) {
 		if (priv->bg_scan_start && !priv->scan_cfg.rssi_threshold) {
 			if (MLAN_STATUS_SUCCESS !=
@@ -2171,7 +2398,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 			priv->bg_scan_start = MFALSE;
 			priv->bg_scan_reported = MFALSE;
 		}
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-START", strlen("RXFILTER-START")) ==
 		   0) {
 #ifdef MEF_CFG_RX_FILTER
@@ -2179,7 +2406,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 		if (ret)
 			goto done;
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-STOP", strlen("RXFILTER-STOP")) ==
 		   0) {
 #ifdef MEF_CFG_RX_FILTER
@@ -2187,7 +2414,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 		if (ret)
 			goto done;
 #endif
-		len = sprintf(buf, "OK\n") + 1;
+		len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 	} else if (strncmp(buf, "RXFILTER-ADD", strlen("RXFILTER-ADD")) == 0) {
 		if (dwrq->length > strlen("RXFILTER-ADD") + 1) {
 			pdata = buf + strlen("RXFILTER-ADD") + 1;
@@ -2196,7 +2423,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2210,7 +2437,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2223,7 +2450,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2236,7 +2463,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 				ret = -EFAULT;
 				goto done;
 			}
-			len = sprintf(buf, "OK\n") + 1;
+			len = snprintf(buf, MAX_BUF_LEN, "OK\n") + 1;
 		} else {
 			ret = -EFAULT;
 			goto done;
@@ -2248,7 +2475,7 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
 	}
 	PRINTM(MIOCTL, "PRIV Command return: %s, length=%d\n", buf, len);
 	dwrq->length = (t_u16)len;
-	if (copy_to_user(dwrq->pointer, buf, dwrq->length))
+	if (copy_to_user((void __user *)dwrq->pointer, buf, dwrq->length))
 		ret = -EFAULT;
 done:
 	kfree(buf);
@@ -2265,34 +2492,47 @@ static int woal_set_priv(struct net_device *dev, struct iw_request_info *info,
  *
  *  @return                     MLAN_STATUS_SUCCESS -- success, otherwise fail
  */
-mlan_status woal_wext_request_scan(moal_private *priv, t_u8 wait_option,
-				   mlan_802_11_ssid *req_ssid)
+static mlan_status woal_wext_request_scan(moal_private *priv, t_u8 wait_option,
+					  mlan_802_11_ssid *req_ssid)
 {
-	wlan_user_scan_cfg scan_req;
+	wlan_user_scan_cfg *scan_req;
 	mlan_scan_cfg scan_cfg;
+	mlan_status status;
 	ENTER();
 	if (!woal_is_any_interface_active(priv->phandle)) {
 		LEAVE();
 		return woal_request_scan(priv, wait_option, req_ssid);
 	}
+	scan_req = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return MLAN_STATUS_FAILURE;
+	}
+
 	memset(&scan_cfg, 0, sizeof(scan_cfg));
-	memset(&scan_req, 0, sizeof(scan_req));
+	memset(scan_req, 0, sizeof(wlan_user_scan_cfg));
 	if (req_ssid && req_ssid->ssid_len != 0) {
-		moal_memcpy_ext(priv->phandle, scan_req.ssid_list[0].ssid,
+		moal_memcpy_ext(priv->phandle, scan_req->ssid_list[0].ssid,
 				req_ssid->ssid, req_ssid->ssid_len,
 				MLAN_MAX_SSID_LENGTH);
-		scan_req.ssid_list[0].max_len = 0;
+		scan_req->ssid_list[0].max_len = 0;
+	}
+	if (MLAN_STATUS_SUCCESS != woal_get_scan_config(priv, &scan_cfg)) {
+		PRINTM(MERROR, "Unable to get scan configuration\n");
 	}
-	woal_get_scan_config(priv, &scan_cfg);
 	if (scan_cfg.scan_chan_gap)
-		scan_req.scan_chan_gap = scan_cfg.scan_chan_gap;
+		scan_req->scan_chan_gap = scan_cfg.scan_chan_gap;
 	else
-		scan_req.scan_chan_gap = priv->phandle->scan_chan_gap;
+		scan_req->scan_chan_gap = priv->phandle->scan_chan_gap;
 	/** indicate FW, gap is optional */
-	if (scan_req.scan_chan_gap && priv->phandle->pref_mac)
-		scan_req.scan_chan_gap |= GAP_FLAG_OPTIONAL;
+	if (scan_req->scan_chan_gap && priv->phandle->pref_mac)
+		scan_req->scan_chan_gap |= GAP_FLAG_OPTIONAL;
+	status = woal_request_userscan(priv, wait_option, scan_req);
+	kfree(scan_req);
 	LEAVE();
-	return woal_request_userscan(priv, wait_option, &scan_req);
+	return status;
 }
 
 /**
@@ -2376,6 +2616,60 @@ static int woal_set_scan(struct net_device *dev, struct iw_request_info *info,
 	return ret;
 }
 
+/**
+ * @brief Request scan based on connect parameter
+ *
+ * @param priv            A pointer to moal_private structure
+ * @param ssid_bssid      A pointer to mlan_ssid_bssid structure
+ *
+ * @return                0 -- success, otherwise fail
+ */
+static int woal_owe_specific_scan(moal_private *priv,
+				  mlan_ssid_bssid *ssid_bssid)
+{
+	moal_handle *handle = priv->phandle;
+	int ret = 0;
+	wlan_user_scan_cfg *scan_req;
+	ENTER();
+	if (handle->scan_pending_on_block == MTRUE) {
+		PRINTM(MINFO, "scan already in processing...\n");
+		LEAVE();
+		return ret;
+	}
+	scan_req = (wlan_user_scan_cfg *)kmalloc(sizeof(wlan_user_scan_cfg),
+						 GFP_KERNEL);
+	if (!scan_req) {
+		PRINTM(MERROR, "Malloc buffer failed\n");
+		LEAVE();
+		return -ENOMEM;
+	}
+
+	priv->report_scan_result = MTRUE;
+	memset(scan_req, 0x00, sizeof(wlan_user_scan_cfg));
+	scan_req->keep_previous_scan = MTRUE;
+	moal_memcpy_ext(priv->phandle, scan_req->ssid_list[0].ssid,
+			ssid_bssid->trans_ssid.ssid,
+			MIN(ssid_bssid->trans_ssid.ssid_len,
+			    MLAN_MAX_SSID_LENGTH),
+			sizeof(scan_req->ssid_list[0].ssid));
+	scan_req->ssid_list[0].max_len = 0;
+	scan_req->chan_list[0].chan_number = ssid_bssid->channel;
+	if (ssid_bssid->bss_band == BAND_A)
+		scan_req->chan_list[0].radio_type = BAND_5GHZ;
+	else
+		scan_req->chan_list[0].radio_type = BAND_2GHZ;
+	scan_req->chan_list[0].scan_time = 0;
+	// TODO need set to PASSIVE TO ACTIVE on DFS channel
+	scan_req->chan_list[0].scan_type = MLAN_SCAN_TYPE_ACTIVE;
+
+	moal_memcpy_ext(priv->phandle, scan_req->random_mac, priv->random_mac,
+			ETH_ALEN, sizeof(scan_req->random_mac));
+	ret = woal_request_userscan(priv, MOAL_IOCTL_WAIT, scan_req);
+	kfree(scan_req);
+	LEAVE();
+	return ret;
+}
+
 /**
  *  @brief Set essid
  *
@@ -2393,6 +2687,7 @@ static int woal_set_essid(struct net_device *dev, struct iw_request_info *info,
 	struct iw_point *dwrq = &wrqu->data;
 	mlan_802_11_ssid req_ssid;
 	mlan_ssid_bssid ssid_bssid;
+	mlan_ssid_bssid *owe_ssid_bssid = NULL;
 #ifdef REASSOCIATION
 	moal_handle *handle = priv->phandle;
 	mlan_bss_info bss_info;
@@ -2470,6 +2765,38 @@ static int woal_set_essid(struct net_device *dev, struct iw_request_info *info,
 			goto setessid_ret;
 		}
 
+		priv->auto_assoc_priv.drv_assoc.status = MFALSE;
+		priv->auto_assoc_priv.drv_reconnect.status = MFALSE;
+#ifdef REASSOCIATION
+		if (priv->reassoc_on == MTRUE) {
+			if (priv->auto_assoc_priv.auto_assoc_type_on &
+			    (0x1 << (AUTO_ASSOC_TYPE_DRV_ASSOC - 1))) {
+				if (priv->scan_type == MLAN_SCAN_TYPE_PASSIVE)
+					woal_set_scan_type(
+						priv, MLAN_SCAN_TYPE_PASSIVE);
+				MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
+				moal_memcpy_ext(
+					priv->phandle,
+					&priv->prev_ssid_bssid.ssid, &req_ssid,
+					sizeof(mlan_802_11_ssid),
+					sizeof(priv->prev_ssid_bssid.ssid));
+				priv->auto_assoc_priv.auto_assoc_trigger_flag =
+					AUTO_ASSOC_TYPE_DRV_ASSOC;
+				priv->auto_assoc_priv.drv_assoc.status = MTRUE;
+				priv->reassoc_required = MTRUE;
+				priv->phandle->is_reassoc_timer_set = MTRUE;
+				PRINTM(MINFO,
+				       " auto assoc: trigger driver auto assoc\n");
+				woal_mod_timer(&priv->phandle->reassoc_timer,
+					       0);
+				ret = MLAN_STATUS_SUCCESS;
+
+				LEAVE();
+				return ret;
+			}
+		}
+#endif
+
 		if (dwrq->flags != 0xFFFF) {
 			if (MLAN_STATUS_SUCCESS !=
 			    woal_find_essid(priv, &ssid_bssid,
@@ -2488,8 +2815,12 @@ static int woal_set_essid(struct net_device *dev, struct iw_request_info *info,
 	mode = woal_get_mode(priv, MOAL_IOCTL_WAIT);
 	if (mode == IW_MODE_ADHOC)
 		/* disconnect before try to associate */
-		woal_disconnect(priv, MOAL_IOCTL_WAIT, NULL,
-				DEF_DEAUTH_REASON_CODE);
+		if (MLAN_STATUS_SUCCESS !=
+		    woal_disconnect(priv, MOAL_IOCTL_WAIT, NULL,
+				    DEF_DEAUTH_REASON_CODE)) {
+			PRINTM(MERROR,
+			       "Disconnect before association failed\n");
+		}
 
 	if (mode != IW_MODE_ADHOC) {
 		if (MLAN_STATUS_SUCCESS !=
@@ -2498,6 +2829,34 @@ static int woal_set_essid(struct net_device *dev, struct iw_request_info *info,
 			ret = -EFAULT;
 			goto setessid_ret;
 		}
+		if (ssid_bssid.trans_ssid.ssid_len &&
+		    (ssid_bssid.owe_transition_mode == OWE_TRANS_MODE_OPEN)) {
+			// We need scan for OWE AP
+			owe_ssid_bssid = (mlan_ssid_bssid *)kmalloc(
+				sizeof(mlan_ssid_bssid), GFP_KERNEL);
+			if (!owe_ssid_bssid) {
+				PRINTM(MERROR, "Malloc buffer failed\n");
+				ret = -ENOMEM;
+				goto setessid_ret;
+			}
+			woal_owe_specific_scan(priv, &ssid_bssid);
+			memset(owe_ssid_bssid, 0, sizeof(mlan_ssid_bssid));
+			moal_memcpy_ext(priv->phandle, &owe_ssid_bssid->ssid,
+					&ssid_bssid.trans_ssid,
+					sizeof(mlan_802_11_ssid),
+					sizeof(owe_ssid_bssid->ssid));
+			moal_memcpy_ext(priv->phandle, &owe_ssid_bssid->bssid,
+					&ssid_bssid.trans_bssid,
+					sizeof(mlan_802_11_mac_addr),
+					sizeof(owe_ssid_bssid->bssid));
+			if (MLAN_STATUS_SUCCESS ==
+			    woal_find_essid(priv, owe_ssid_bssid,
+					    MOAL_IOCTL_WAIT))
+				moal_memcpy_ext(priv->phandle, &ssid_bssid,
+						owe_ssid_bssid,
+						sizeof(mlan_ssid_bssid),
+						sizeof(ssid_bssid));
+		}
 		if (MLAN_STATUS_SUCCESS !=
 		    woal_11d_check_ap_channel(priv, MOAL_IOCTL_WAIT,
 					      &ssid_bssid)) {
@@ -2551,6 +2910,8 @@ static int woal_set_essid(struct net_device *dev, struct iw_request_info *info,
 #ifdef REASSOCIATION
 	MOAL_REL_SEMAPHORE(&handle->reassoc_sem);
 #endif
+	if (owe_ssid_bssid)
+		kfree(owe_ssid_bssid);
 	LEAVE();
 	return ret;
 }
@@ -2704,7 +3065,11 @@ static int woal_get_scan(struct net_device *dev, struct iw_request_info *info,
 		iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
 		moal_memcpy_ext(priv->phandle, iwe.u.ap_addr.sa_data,
 				&scan_table[i].mac_address, ETH_ALEN,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
+				sizeof(iwe.u.ap_addr.sa_data_min));
+#else
 				sizeof(iwe.u.ap_addr.sa_data));
+#endif
 
 		iwe.len = IW_EV_ADDR_LEN;
 		current_ev = IWE_STREAM_ADD_EVENT(info, current_ev, end_buf,
@@ -2822,8 +3187,8 @@ static int woal_get_scan(struct net_device *dev, struct iw_request_info *info,
 		/* Beacon Interval */
 		memset(&iwe, 0, sizeof(iwe));
 		ptr = buf;
-		ptr += sprintf(ptr, "Beacon interval=%d",
-			       scan_table[i].beacon_period);
+		ptr += snprintf(ptr, MAX_BUF_LEN, "Beacon interval=%d",
+				scan_table[i].beacon_period);
 
 		iwe.u.data.length = strlen(buf);
 		iwe.cmd = IWEVCUSTOM;
@@ -2882,9 +3247,6 @@ static int woal_get_scan(struct net_device *dev, struct iw_request_info *info,
 					current_ev = IWE_STREAM_ADD_POINT(
 						info, current_ev, end_buf, &iwe,
 						buf);
-					current_val = current_ev +
-						      IW_EV_LCP_LEN +
-						      strlen(buf);
 					break;
 #endif
 				default:
@@ -2901,12 +3263,12 @@ static int woal_get_scan(struct net_device *dev, struct iw_request_info *info,
 		memset(&iwe, 0, sizeof(iwe));
 		memset(buf, 0, buf_size);
 		ptr = buf;
-		ptr += sprintf(ptr, "band=");
+		ptr += snprintf(ptr, MAX_BUF_LEN, "band=");
 		memset(&iwe, 0, sizeof(iwe));
 		if (scan_table[i].bss_band == BAND_A)
-			ptr += sprintf(ptr, "a");
+			snprintf(ptr, MAX_BUF_LEN, "a");
 		else
-			ptr += sprintf(ptr, "bg");
+			snprintf(ptr, MAX_BUF_LEN, "bg");
 		iwe.u.data.length = strlen(buf);
 		PRINTM(MINFO, "iwe.u.data.length %d\n", iwe.u.data.length);
 		PRINTM(MINFO, "BUF: %s\n", buf);
@@ -2914,7 +3276,6 @@ static int woal_get_scan(struct net_device *dev, struct iw_request_info *info,
 		iwe.len = IW_EV_POINT_LEN + iwe.u.data.length;
 		current_ev = IWE_STREAM_ADD_POINT(info, current_ev, end_buf,
 						  &iwe, buf);
-		current_val = current_ev + IW_EV_LCP_LEN + strlen(buf);
 #endif
 		current_val = current_ev + IW_EV_LCP_LEN;
 
@@ -3050,13 +3411,18 @@ void woal_send_iwevcustom_event(moal_private *priv, char *str)
 	char buf[IW_CUSTOM_MAX];
 
 	ENTER();
+	/* Check register_netdevice is completed before sending*/
+	if (priv->netdev->reg_state != NETREG_REGISTERED) {
+		LEAVE();
+		return;
+	}
 
 	memset(&iwrq, 0, sizeof(union iwreq_data));
 	memset(buf, 0, sizeof(buf));
 
 	snprintf(buf, sizeof(buf) - 1, "%s", str);
 
-	iwrq.data.pointer = buf;
+	iwrq.data.pointer = (t_u8 __user *)buf;
 	iwrq.data.length = strlen(buf) + 1;
 
 	/* Send Event to upper layer */
@@ -3090,7 +3456,7 @@ void woal_send_mic_error_event(moal_private *priv, t_u32 event)
 		mic.flags = IW_MICFAILURE_PAIRWISE;
 	else
 		mic.flags = IW_MICFAILURE_GROUP;
-	iwrq.data.pointer = &mic;
+	iwrq.data.pointer = (t_u8 __user *)&mic;
 	iwrq.data.length = sizeof(mic);
 
 	wireless_send_event(priv->netdev, IWEVMICHAELMICFAILURE, &iwrq,
@@ -3105,14 +3471,14 @@ void woal_send_mic_error_event(moal_private *priv, t_u32 event)
 #ifdef STA_SUPPORT
 /** wlan_handler_def */
 struct iw_handler_def woal_handler_def = {
-	num_standard: ARRAY_SIZE(woal_handler),
-	num_private : ARRAY_SIZE(woal_private_handler),
-	num_private_args : ARRAY_SIZE(woal_private_args),
-	standard : (iw_handler *)woal_handler,
-	private : (iw_handler *)woal_private_handler,
-	private_args : (struct iw_priv_args *)woal_private_args,
+	.num_standard = ARRAY_SIZE(woal_handler),
+	.num_private = ARRAY_SIZE(woal_private_handler),
+	.num_private_args = ARRAY_SIZE(woal_private_args),
+	.standard = (iw_handler *)woal_handler,
+	.private = (iw_handler *)woal_private_handler,
+	.private_args = (struct iw_priv_args *)woal_private_args,
 #if WIRELESS_EXT > 20
-	get_wireless_stats : woal_get_wireless_stats,
+	.get_wireless_stats = woal_get_wireless_stats,
 #endif
 };
 // clang-format on
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.h b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.h
old mode 100644
new mode 100755
index f363f2f0a..af13eff41
--- a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.h
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/mlinux/moal_wext.h
@@ -3,7 +3,7 @@
  * @brief This file contains definition for wireless extension IOCTL call.
  *
  *
- * Copyright 2014-2020 NXP
+ * Copyright 2008-2021 NXP
  *
  * This software file (the File) is distributed by NXP
  * under the terms of the GNU General Public License Version 2, June 1991
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/load b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/load
new file mode 100755
index 000000000..e9819c959
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/load
@@ -0,0 +1,16 @@
+#! /bin/bash
+if echo $1 2>&1 | grep dbg > /dev/null; then
+    insmod mlan-dbg.ko
+else
+    insmod mlan.ko
+fi
+insmod $1.ko $2 $3 $4 $5 $6 $7 $8
+for (( i = 1; i <= 10; i++ ))
+do
+    ifconfig -a 2>&1 | grep -E "(mlan0|uap0|wfd0)" > /dev/null
+    if [ $? -eq 0 ]; then
+        exit
+    fi
+    sleep 1
+done
+
diff --git a/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/unload b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/unload
new file mode 100755
index 000000000..4f2a306d8
--- /dev/null
+++ b/drivers/net/wireless/nxp/mxm_wifiex/wlan_src/script/unload
@@ -0,0 +1,22 @@
+#! /bin/bash
+ifconfig mlan0 down
+ifconfig uap0 down
+ifconfig mmlan0 down
+ifconfig muap0 down
+ifconfig uap1 down
+ifconfig muap1 down
+ifconfig wfd0 down
+ifconfig wfd1 down
+ifconfig mwfd0 down
+ifconfig mwfd1 down
+for (( i = 0; i <= 30; i++ ))
+do
+    rmmod moal 2> /dev/null
+    lsmod 2>&1 | grep moal > /dev/null
+    if [ ! $? -eq 0 ]; then
+        break
+    fi
+    sleep 1
+done
+rmmod mlan
+sleep 5
diff --git a/drivers/of/Kconfig b/drivers/of/Kconfig
index d91618641..1900188c0 100644
--- a/drivers/of/Kconfig
+++ b/drivers/of/Kconfig
@@ -107,4 +107,11 @@ config OF_DMA_DEFAULT_COHERENT
 	# arches should select this if DMA is coherent by default for OF devices
 	bool
 
+config OF_CONFIGFS
+        bool "Device Tree Overlay ConfigFS interface"
+        select CONFIGFS_FS
+        select OF_OVERLAY
+        help
+          Enable a simple user-space driven DT overlay interface.
+
 endif # OF
diff --git a/drivers/of/Makefile b/drivers/of/Makefile
index 663a4af0c..5e9569176 100644
--- a/drivers/of/Makefile
+++ b/drivers/of/Makefile
@@ -14,5 +14,6 @@ obj-$(CONFIG_OF_RESERVED_MEM) += of_reserved_mem.o
 obj-$(CONFIG_OF_RESOLVE)  += resolver.o
 obj-$(CONFIG_OF_OVERLAY) += overlay.o
 obj-$(CONFIG_OF_NUMA) += of_numa.o
+obj-$(CONFIG_CONFIGFS_FS) += configfs.o
 
 obj-$(CONFIG_OF_UNITTEST) += unittest-data/
diff --git a/drivers/of/configfs.c b/drivers/of/configfs.c
new file mode 100644
index 000000000..ac04301da
--- /dev/null
+++ b/drivers/of/configfs.c
@@ -0,0 +1,277 @@
+/*
+ * Configfs entries for device-tree
+ *
+ * Copyright (C) 2013 - Pantelis Antoniou <panto@antoniou-consulting.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <linux/ctype.h>
+#include <linux/cpu.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/configfs.h>
+#include <linux/types.h>
+#include <linux/stat.h>
+#include <linux/limits.h>
+#include <linux/file.h>
+#include <linux/vmalloc.h>
+#include <linux/firmware.h>
+#include <linux/sizes.h>
+
+#include "of_private.h"
+
+struct cfs_overlay_item {
+	struct config_item	item;
+
+	char			path[PATH_MAX];
+
+	const struct firmware	*fw;
+	struct device_node	*overlay;
+	int			ov_id;
+
+	void			*dtbo;
+	int			dtbo_size;
+};
+
+static inline struct cfs_overlay_item *to_cfs_overlay_item(
+		struct config_item *item)
+{
+	return item ? container_of(item, struct cfs_overlay_item, item) : NULL;
+}
+
+static ssize_t cfs_overlay_item_path_show(struct config_item *item,
+		char *page)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+	return sprintf(page, "%s\n", overlay->path);
+}
+
+static ssize_t cfs_overlay_item_path_store(struct config_item *item,
+		const char *page, size_t count)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+	const char *p = page;
+	char *s;
+	int err;
+
+	/* if it's set do not allow changes */
+	if (overlay->path[0] != '\0' || overlay->dtbo_size > 0)
+		return -EPERM;
+
+	/* copy to path buffer (and make sure it's always zero terminated */
+	count = snprintf(overlay->path, sizeof(overlay->path) - 1, "%s", p);
+	overlay->path[sizeof(overlay->path) - 1] = '\0';
+
+	/* strip trailing newlines */
+	s = overlay->path + strlen(overlay->path);
+	while (s > overlay->path && *--s == '\n')
+		*s = '\0';
+
+	pr_debug("%s: path is '%s'\n", __func__, overlay->path);
+
+	err = request_firmware(&overlay->fw, overlay->path, NULL);
+	if (err != 0)
+		goto out_err;
+
+	err = of_overlay_fdt_apply((void *)overlay->fw->data,
+				   (u32)overlay->fw->size, &overlay->ov_id);
+	if (err != 0)
+		goto out_err;
+
+	return count;
+
+out_err:
+
+	release_firmware(overlay->fw);
+	overlay->fw = NULL;
+
+	overlay->path[0] = '\0';
+	return err;
+}
+
+static ssize_t cfs_overlay_item_status_show(struct config_item *item,
+		char *page)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+
+	return sprintf(page, "%s\n",
+			overlay->ov_id > 0 ? "applied" : "unapplied");
+}
+
+CONFIGFS_ATTR(cfs_overlay_item_, path);
+CONFIGFS_ATTR_RO(cfs_overlay_item_, status);
+
+static struct configfs_attribute *cfs_overlay_attrs[] = {
+	&cfs_overlay_item_attr_path,
+	&cfs_overlay_item_attr_status,
+	NULL,
+};
+
+ssize_t cfs_overlay_item_dtbo_read(struct config_item *item,
+		void *buf, size_t max_count)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+
+	pr_debug("%s: buf=%p max_count=%zu\n", __func__,
+			buf, max_count);
+
+	if (overlay->dtbo == NULL)
+		return 0;
+
+	/* copy if buffer provided */
+	if (buf != NULL) {
+		/* the buffer must be large enough */
+		if (overlay->dtbo_size > max_count)
+			return -ENOSPC;
+
+		memcpy(buf, overlay->dtbo, overlay->dtbo_size);
+	}
+
+	return overlay->dtbo_size;
+}
+
+ssize_t cfs_overlay_item_dtbo_write(struct config_item *item,
+		const void *buf, size_t count)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+	int err;
+
+	/* if it's set do not allow changes */
+	if (overlay->path[0] != '\0' || overlay->dtbo_size > 0)
+		return -EPERM;
+
+	/* copy the contents */
+	overlay->dtbo = kmemdup(buf, count, GFP_KERNEL);
+	if (overlay->dtbo == NULL)
+		return -ENOMEM;
+
+	overlay->dtbo_size = count;
+
+	err = of_overlay_fdt_apply(overlay->dtbo, overlay->dtbo_size,
+				   &overlay->ov_id);
+	if (err != 0)
+		goto out_err;
+
+	return count;
+
+out_err:
+	kfree(overlay->dtbo);
+	overlay->dtbo = NULL;
+	overlay->dtbo_size = 0;
+	overlay->ov_id = 0;
+
+	return err;
+}
+
+CONFIGFS_BIN_ATTR(cfs_overlay_item_, dtbo, NULL, SZ_1M);
+
+static struct configfs_bin_attribute *cfs_overlay_bin_attrs[] = {
+	&cfs_overlay_item_attr_dtbo,
+	NULL,
+};
+
+static void cfs_overlay_release(struct config_item *item)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+
+	if (overlay->ov_id > 0)
+		of_overlay_remove(&overlay->ov_id);
+	if (overlay->fw)
+		release_firmware(overlay->fw);
+	/* kfree with NULL is safe */
+	kfree(overlay->dtbo);
+	kfree(overlay);
+}
+
+static struct configfs_item_operations cfs_overlay_item_ops = {
+	.release	= cfs_overlay_release,
+};
+
+static struct config_item_type cfs_overlay_type = {
+	.ct_item_ops	= &cfs_overlay_item_ops,
+	.ct_attrs	= cfs_overlay_attrs,
+	.ct_bin_attrs	= cfs_overlay_bin_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+static struct config_item *cfs_overlay_group_make_item(
+		struct config_group *group, const char *name)
+{
+	struct cfs_overlay_item *overlay;
+
+	overlay = kzalloc(sizeof(*overlay), GFP_KERNEL);
+	if (!overlay)
+		return ERR_PTR(-ENOMEM);
+
+	config_item_init_type_name(&overlay->item, name, &cfs_overlay_type);
+	return &overlay->item;
+}
+
+static void cfs_overlay_group_drop_item(struct config_group *group,
+		struct config_item *item)
+{
+	struct cfs_overlay_item *overlay = to_cfs_overlay_item(item);
+
+	config_item_put(&overlay->item);
+}
+
+static struct configfs_group_operations overlays_ops = {
+	.make_item	= cfs_overlay_group_make_item,
+	.drop_item	= cfs_overlay_group_drop_item,
+};
+
+static struct config_item_type overlays_type = {
+	.ct_group_ops   = &overlays_ops,
+	.ct_owner       = THIS_MODULE,
+};
+
+static struct configfs_group_operations of_cfs_ops = {
+	/* empty - we don't allow anything to be created */
+};
+
+static struct config_item_type of_cfs_type = {
+	.ct_group_ops   = &of_cfs_ops,
+	.ct_owner       = THIS_MODULE,
+};
+
+struct config_group of_cfs_overlay_group;
+
+static struct configfs_subsystem of_cfs_subsys = {
+	.su_group = {
+		.cg_item = {
+			.ci_namebuf = "device-tree",
+			.ci_type = &of_cfs_type,
+		},
+	},
+	.su_mutex = __MUTEX_INITIALIZER(of_cfs_subsys.su_mutex),
+};
+
+static int __init of_cfs_init(void)
+{
+	int ret;
+
+	pr_info("%s\n", __func__);
+
+	config_group_init(&of_cfs_subsys.su_group);
+	config_group_init_type_name(&of_cfs_overlay_group, "overlays",
+			&overlays_type);
+	configfs_add_default_group(&of_cfs_overlay_group,
+			&of_cfs_subsys.su_group);
+
+	ret = configfs_register_subsystem(&of_cfs_subsys);
+	if (ret != 0) {
+		pr_err("%s: failed to register subsys\n", __func__);
+		goto out;
+	}
+	pr_info("%s: OK\n", __func__);
+out:
+	return ret;
+}
+late_initcall(of_cfs_init);
diff --git a/drivers/of/overlay.c b/drivers/of/overlay.c
index 1688f576e..c9a751d11 100644
--- a/drivers/of/overlay.c
+++ b/drivers/of/overlay.c
@@ -361,9 +361,11 @@ static int add_changeset_property(struct overlay_changeset *ovcs,
 						   new_prop);
 	}
 
+#if 0 /* too noisy */
 	if (!of_node_check_flag(target->np, OF_OVERLAY))
 		pr_err("WARNING: memory leak will occur if overlay removed, property: %pOF/%s\n",
 		       target->np, new_prop->name);
+#endif
 
 	if (ret) {
 		kfree(new_prop->name);
diff --git a/drivers/of/resolver.c b/drivers/of/resolver.c
index 83c766233..32edf3ee3 100644
--- a/drivers/of/resolver.c
+++ b/drivers/of/resolver.c
@@ -321,8 +321,10 @@ int of_resolve_phandles(struct device_node *overlay)
 
 		err = of_property_read_string(tree_symbols,
 				prop->name, &refpath);
-		if (err)
+		if (err){
+			pr_err("node %s not found in base DT, fixup failed", prop->name);
 			goto out;
+		}
 
 		refnode = of_find_node_by_path(refpath);
 		if (!refnode) {
diff --git a/drivers/pci/controller/dwc/pci-imx6.c b/drivers/pci/controller/dwc/pci-imx6.c
index 3bcea6297..38f5d3b41 100644
--- a/drivers/pci/controller/dwc/pci-imx6.c
+++ b/drivers/pci/controller/dwc/pci-imx6.c
@@ -2364,6 +2364,32 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 	if (!pci)
 		return -ENOMEM;
 
+/*
+	//for 5g modem power-on-reset
+	gpio_request(6,"5g-power1");
+	gpio_direction_output(6, 1);
+	gpio_set_value(6, 0);
+
+	gpio_request(1,"5g-reset");
+        gpio_direction_output(1, 1);
+        gpio_set_value(1, 1);
+	msleep(100);
+	gpio_set_value(1,0);
+
+	gpio_request(0,"5g-power2");
+        gpio_direction_output(0, 1);
+        gpio_set_value(0, 1);
+*/
+
+	gpio_request(14,"ZK_MP_PWR");
+        gpio_direction_output(14, 1);
+        gpio_set_value(14, 1);
+
+	gpio_request(0,"wifi_en");
+        gpio_direction_output(0, 1);
+        gpio_set_value(0, 1);
+	msleep(20);
+
 	pci->dev = dev;
 	pci->ops = &dw_pcie_ops;
 
@@ -2675,9 +2701,9 @@ static int imx6_pcie_probe(struct platform_device *pdev)
 	imx6_pcie_deassert_core_reset(imx6_pcie);
 	imx6_setup_phy_mpll(imx6_pcie);
 
-	val = dw_pcie_readl_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF);
-	val |= 0xD;
-	dw_pcie_writel_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF, val);
+//	val = dw_pcie_readl_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF);
+//	val |= 0xD;
+//	dw_pcie_writel_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF, val);
 
 	switch (imx6_pcie->drvdata->mode) {
 	case DW_PCIE_RC_TYPE:
diff --git a/drivers/pci/controller/dwc/pcie-designware-host.c b/drivers/pci/controller/dwc/pcie-designware-host.c
index a0add8c1b..a00912dbb 100644
--- a/drivers/pci/controller/dwc/pcie-designware-host.c
+++ b/drivers/pci/controller/dwc/pcie-designware-host.c
@@ -718,9 +718,9 @@ void dw_pcie_setup_rc(struct pcie_port *pp)
 	val |= PORT_LOGIC_SPEED_CHANGE;
 	dw_pcie_wr_own_conf(pp, PCIE_LINK_WIDTH_SPEED_CONTROL, 4, val);
 
-	val = dw_pcie_readl_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF);
-	val |= 0xD;
-	dw_pcie_writel_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF, val);
+	//val = dw_pcie_readl_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF);
+	//val |= 0xD;
+	//dw_pcie_writel_dbi(pci, PCIE_AMBA_ORDERING_CTRL_OFF, val);
 
 	dw_pcie_dbi_ro_wr_dis(pci);
 }
diff --git a/drivers/pci/controller/dwc/pcie-designware.h b/drivers/pci/controller/dwc/pcie-designware.h
index 541878ad3..08e6642b2 100644
--- a/drivers/pci/controller/dwc/pcie-designware.h
+++ b/drivers/pci/controller/dwc/pcie-designware.h
@@ -60,7 +60,7 @@
 #define PCIE_MSI_INTR0_MASK		0x82C
 #define PCIE_MSI_INTR0_STATUS		0x830
 
-#define PCIE_AMBA_ORDERING_CTRL_OFF	0x8D8
+//#define PCIE_AMBA_ORDERING_CTRL_OFF	0x8D8
 #define PCIE_ATU_VIEWPORT		0x900
 #define PCIE_ATU_REGION_INBOUND		BIT(31)
 #define PCIE_ATU_REGION_OUTBOUND	0
diff --git a/drivers/phy/freescale/phy-fsl-imx8-pcie.c b/drivers/phy/freescale/phy-fsl-imx8-pcie.c
index 7cabfdbeb..47223b467 100644
--- a/drivers/phy/freescale/phy-fsl-imx8-pcie.c
+++ b/drivers/phy/freescale/phy-fsl-imx8-pcie.c
@@ -9,6 +9,8 @@
 #include <linux/delay.h>
 #include <linux/phy/phy.h>
 #include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
 
 #define PHY_PLL_LOCK_WAIT_MAX_RETRIES	2000
 #define IMX8MP_PCIE_PHY_FLAG_EXT_OSC	BIT(0)
diff --git a/drivers/phy/freescale/phy-fsl-samsung-hdmi.c b/drivers/phy/freescale/phy-fsl-samsung-hdmi.c
index d58e3329a..5947cba73 100644
--- a/drivers/phy/freescale/phy-fsl-samsung-hdmi.c
+++ b/drivers/phy/freescale/phy-fsl-samsung-hdmi.c
@@ -31,8 +31,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 	{	22250000, {
 			0x00, 0xD1, 0x4B, 0xF1, 0x89, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x15, 0x25, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -40,8 +40,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		23750000, {
 			0x00, 0xD1, 0x50, 0xF1, 0x86, 0x85, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x03, 0x25, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -49,8 +49,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		24000000, {
 			0x00, 0xD1, 0x50, 0xF0, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x01, 0x25, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -58,8 +58,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		24024000, {
 			0x00, 0xD1, 0x50, 0xF1, 0x99, 0x02, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x00, 0x25, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -67,8 +67,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		25175000, {
 			0x00, 0xD1, 0x54, 0xFC, 0xCC, 0x91, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xF5, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -76,8 +76,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		25200000, {
 			0x00, 0xD1, 0x54, 0xF0, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xF4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -85,8 +85,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		26750000, {
 			0x00, 0xD1, 0x5A, 0xF2, 0x89, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xE6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -94,8 +94,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		27000000, {
 			0x00, 0xD1, 0x5A, 0xF0, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -103,8 +103,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		27027000, {
 			0x00, 0xD1, 0x5A, 0xF2, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -112,8 +112,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		29500000, {
 			0x00, 0xD1, 0x62, 0xF4, 0x95, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xD1, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -121,8 +121,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		30750000, {
 			0x00, 0xD1, 0x66, 0xF4, 0x82, 0x01, 0x88, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xC8, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -130,8 +130,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		30888000, {
 			0x00, 0xD1, 0x66, 0xF4, 0x99, 0x18, 0x88, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xC7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -139,8 +139,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		33750000, {
 			0x00, 0xD1, 0x70, 0xF4, 0x82, 0x01, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xB7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8F, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -148,8 +148,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		35000000, {
 			0x00, 0xD1, 0x58, 0xB8, 0x8B, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xB0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -157,8 +157,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		36000000, {
 			0x00, 0xD1, 0x5A, 0xB0, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -166,8 +166,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		36036000, {
 			0x00, 0xD1, 0x5A, 0xB2, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -175,8 +175,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		40000000, {
 			0x00, 0xD1, 0x64, 0xB0, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x9A, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x8B, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -184,8 +184,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		43200000, {
 			0x00, 0xD1, 0x5A, 0x90, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x8F, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -193,8 +193,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		43243200, {
 			0x00, 0xD1, 0x5A, 0x92, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x8F, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -202,8 +202,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		44500000, {
 			0x00, 0xD1, 0x5C, 0x92, 0x98, 0x11, 0x84, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x8B, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -211,8 +211,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		47000000, {
 			0x00, 0xD1, 0x62, 0x94, 0x95, 0x82, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x83, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -220,8 +220,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		47500000, {
 			0x00, 0xD1, 0x63, 0x96, 0xA1, 0x82, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x00, 0x82, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x89, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -229,8 +229,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		50349650, {
 			0x00, 0xD1, 0x54, 0x7C, 0xC3, 0x8F, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xF5, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -238,8 +238,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		50400000, {
 			0x00, 0xD1, 0x54, 0x70, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xF4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -247,8 +247,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		53250000, {
 			0x00, 0xD1, 0x58, 0x72, 0x84, 0x03, 0x82, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xE7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -256,8 +256,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		53500000, {
 			0x00, 0xD1, 0x5A, 0x72, 0x89, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xE6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -265,8 +265,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		54000000, {
 			0x00, 0xD1, 0x5A, 0x70, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -274,8 +274,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		54054000, {
 			0x00, 0xD1, 0x5A, 0x72, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -283,8 +283,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		59000000, {
 			0x00, 0xD1, 0x62, 0x74, 0x95, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xD1, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -292,8 +292,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		59340659, {
 			0x00, 0xD1, 0x62, 0x74, 0xDB, 0x52, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xD0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -301,8 +301,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		59400000, {
 			0x00, 0xD1, 0x63, 0x70, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xCF, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -310,8 +310,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		61500000, {
 			0x00, 0xD1, 0x66, 0x74, 0x82, 0x01, 0x88, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xC8, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -319,8 +319,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		63500000, {
 			0x00, 0xD1, 0x69, 0x74, 0x89, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xC2, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x87, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -328,8 +328,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		67500000, {
 			0x00, 0xD1, 0x54, 0x52, 0x87, 0x03, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xB7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -337,8 +337,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		70000000, {
 			0x00, 0xD1, 0x58, 0x58, 0x8B, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xB0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -346,8 +346,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		72000000, {
 			0x00, 0xD1, 0x5A, 0x50, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -355,8 +355,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		72072000, {
 			0x00, 0xD1, 0x5A, 0x52, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -364,8 +364,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		74176000, {
 			0x00, 0xD1, 0x5D, 0x58, 0xDB, 0xA2, 0x88, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xA6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -373,8 +373,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		74250000, {
 			0x00, 0xD1, 0x5C, 0x52, 0x90, 0x0D, 0x84, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0xA6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -382,8 +382,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		78500000, {
 			0x00, 0xD1, 0x62, 0x54, 0x87, 0x01, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x9D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -391,8 +391,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		80000000, {
 			0x00, 0xD1, 0x64, 0x50, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x9A, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -400,8 +400,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		82000000, {
 			0x00, 0xD1, 0x66, 0x54, 0x82, 0x01, 0x88, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x96, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -409,8 +409,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		82500000, {
 			0x00, 0xD1, 0x67, 0x54, 0x88, 0x01, 0x90, 0x49,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x95, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -418,8 +418,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		89000000, {
 			0x00, 0xD1, 0x70, 0x54, 0x84, 0x83, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x8B, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -427,8 +427,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		90000000, {
 			0x00, 0xD1, 0x70, 0x54, 0x82, 0x01, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x89, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x85, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -436,8 +436,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		94000000, {
 			0x00, 0xD1, 0x4E, 0x32, 0xA7, 0x10, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x83, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -445,8 +445,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		95000000, {
 			0x00, 0xD1, 0x50, 0x31, 0x86, 0x85, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x82, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -454,8 +454,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		98901099, {
 			0x00, 0xD1, 0x52, 0x3A, 0xDB, 0x4C, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x7D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -463,8 +463,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		99000000, {
 			0x00, 0xD1, 0x52, 0x32, 0x82, 0x01, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x7D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -472,8 +472,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		100699300, {
 			0x00, 0xD1, 0x54, 0x3C, 0xC3, 0x8F, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xF5, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -481,8 +481,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		100800000, {
 			0x00, 0xD1, 0x54, 0x30, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xF4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -490,8 +490,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		102500000, {
 			0x00, 0xD1, 0x55, 0x32, 0x8C, 0x05, 0x90, 0x4B,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xF0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -499,8 +499,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		104750000, {
 			0x00, 0xD1, 0x57, 0x32, 0x98, 0x07, 0x90, 0x49,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xEB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -508,8 +508,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		106500000, {
 			0x00, 0xD1, 0x58, 0x32, 0x84, 0x03, 0x82, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xE7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -517,8 +517,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		107000000, {
 			0x00, 0xD1, 0x5A, 0x32, 0x89, 0x88, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xE6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -526,8 +526,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		108000000, {
 			0x00, 0xD1, 0x5A, 0x30, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -535,8 +535,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		108108000, {
 			0x00, 0xD1, 0x5A, 0x32, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -544,8 +544,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		118000000, {
 			0x00, 0xD1, 0x62, 0x34, 0x95, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xD1, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -553,8 +553,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		118800000, {
 			0x00, 0xD1, 0x63, 0x30, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xCF, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -562,8 +562,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		123000000, {
 			0x00, 0xD1, 0x66, 0x34, 0x82, 0x01, 0x88, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xC8, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -571,8 +571,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		127000000, {
 			0x00, 0xD1, 0x69, 0x34, 0x89, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xC2, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -580,8 +580,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		135000000, {
 			0x00, 0xD1, 0x70, 0x34, 0x82, 0x01, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xB7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -589,8 +589,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		135580000, {
 			0x00, 0xD1, 0x71, 0x39, 0xE9, 0x82, 0x9C, 0x5B,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xB6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -598,8 +598,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		137520000, {
 			0x00, 0xD1, 0x72, 0x38, 0x99, 0x10, 0x85, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xB3, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -607,8 +607,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		138750000, {
 			0x00, 0xD1, 0x73, 0x35, 0x88, 0x05, 0x90, 0x4D,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xB2, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -616,8 +616,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		140000000, {
 			0x00, 0xD1, 0x75, 0x36, 0xA7, 0x90, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xB0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -625,8 +625,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		144000000, {
 			0x00, 0xD1, 0x78, 0x30, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -634,17 +634,17 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		148352000, {
 			0x00, 0xD1, 0x7B, 0x35, 0xDB, 0x39, 0x90, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xA6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8,	0x00, 0x00,
+			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
 	}, {
 		148500000, {
 			0x00, 0xD1, 0x7B, 0x35, 0x84, 0x03, 0x90, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xA6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -652,8 +652,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		154000000, {
 			0x00, 0xD1, 0x40, 0x18, 0x83, 0x01, 0x00, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0xA0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -661,8 +661,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		157000000, {
 			0x00, 0xD1, 0x41, 0x11, 0xA7, 0x14, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x9D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -670,8 +670,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		160000000, {
 			0x00, 0xD1, 0x42, 0x12, 0xA1, 0x20, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x9A, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -679,8 +679,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		162000000, {
 			0x00, 0xD1, 0x43, 0x18, 0x8B, 0x08, 0x96, 0x55,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x98, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -688,8 +688,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		164000000, {
 			0x00, 0xD1, 0x45, 0x11, 0x83, 0x82, 0x90, 0x4B,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x96, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -697,8 +697,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		165000000, {
 			0x00, 0xD1, 0x45, 0x11, 0x84, 0x81, 0x90, 0x4B,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x95, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -706,8 +706,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		180000000, {
 			0x00, 0xD1, 0x4B, 0x10, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x89, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -715,8 +715,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		185625000, {
 			0x00, 0xD1, 0x4E, 0x12, 0x9A, 0x95, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x85, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -724,8 +724,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		188000000, {
 			0x00, 0xD1, 0x4E, 0x12, 0xA7, 0x10, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x83, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -733,8 +733,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		198000000, {
 			0x00, 0xD1, 0x52, 0x12, 0x82, 0x01, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x7D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -742,8 +742,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		205000000, {
 			0x00, 0xD1, 0x55, 0x12, 0x8C, 0x05, 0x90, 0x4B,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xF0, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -751,8 +751,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		209500000, {
 			0x00, 0xD1, 0x57, 0x12, 0x98, 0x07, 0x90, 0x49,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xEB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -760,8 +760,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		213000000, {
 			0x00, 0xD1, 0x58, 0x12, 0x84, 0x03, 0x82, 0x41,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xE7, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -769,8 +769,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		216000000, {
 			0x00, 0xD1, 0x5A, 0x10, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -778,8 +778,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		216216000, {
 			0x00, 0xD1, 0x5A, 0x12, 0xFD, 0x0C, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xE4, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -787,8 +787,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		237600000, {
 			0x00, 0xD1, 0x63, 0x10, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xCF, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -796,8 +796,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		254000000, {
 			0x00, 0xD1, 0x69, 0x14, 0x89, 0x08, 0x80, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xC2, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -805,8 +805,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		277500000, {
 			0x00, 0xD1, 0x73, 0x15, 0x88, 0x05, 0x90, 0x4D,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xB2, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -814,8 +814,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		288000000, {
 			0x00, 0xD1, 0x78, 0x10, 0x00, 0x00, 0x80, 0x00,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xAB, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -823,8 +823,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		297000000, {
 			0x00, 0xD1, 0x7B, 0x15, 0x84, 0x03, 0x90, 0x45,
 			0x4F, 0x30, 0x33, 0x65, 0x30, 0xA6, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -832,8 +832,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		165000000, {
 			0x00, 0xD1, 0x45, 0x11, 0x84, 0x81, 0x90, 0x4B,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x95, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -841,8 +841,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		185625000, {
 			0x00, 0xD1, 0x4E, 0x12, 0xB4, 0x95, 0x88, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x85, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -850,8 +850,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		198000000, {
 			0x00, 0xD1, 0x52, 0x12, 0x84, 0x01, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x20, 0x7D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x81, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -859,8 +859,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		90000000, {
 			0x00, 0xD1, 0x4B, 0x32, 0x84, 0x00, 0x88, 0x40,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x89, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
@@ -868,8 +868,8 @@ const struct phy_config samsung_phy_pll_cfg[] = {
 		99000000, {
 			0x00, 0xD1, 0x52, 0x32, 0x84, 0x01, 0x88, 0x47,
 			0x4F, 0x30, 0x33, 0x65, 0x10, 0x7D, 0x24, 0x80,
-			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x3A,
-			0x74, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
+			0x6C, 0xF2, 0x67, 0x00, 0x10, 0x83, 0x30, 0x32,
+			0x60, 0x8F, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
 			0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 			0x00, 0xE0, 0x83, 0x0F, 0x3E, 0xF8, 0x00, 0x00,
 		},
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index be503a0e6..ff672f6c6 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -728,6 +728,7 @@ static int spidev_probe(struct spi_device *spi)
 	int			status;
 	unsigned long		minor;
 
+#if 0 /* too noisy */
 	/*
 	 * spidev should never be referenced in DT without a specific
 	 * compatible string, it is a Linux implementation thing
@@ -736,6 +737,7 @@ static int spidev_probe(struct spi_device *spi)
 	WARN(spi->dev.of_node &&
 	     of_device_is_compatible(spi->dev.of_node, "spidev"),
 	     "%pOF: buggy DT: spidev listed directly in DT\n", spi->dev.of_node);
+#endif
 
 	spidev_probe_acpi(spi);
 
diff --git a/drivers/usb/dwc3/dwc3-imx8mp.c b/drivers/usb/dwc3/dwc3-imx8mp.c
index 0235ea22a..6af27390d 100644
--- a/drivers/usb/dwc3/dwc3-imx8mp.c
+++ b/drivers/usb/dwc3/dwc3-imx8mp.c
@@ -38,10 +38,22 @@
 
 #define USB_WAKEUP_EN_MASK		GENMASK(5, 0)
 
+/* USB glue registers */
+#define USB_CTRL0		0x00
+#define USB_CTRL1		0x04
+
+#define USB_CTRL0_PORTPWR_EN	BIT(12) /* 1 - PPC enabled (default) */
+#define USB_CTRL0_USB3_FIXED	BIT(22) /* 1 - USB3 permanent attached */
+#define USB_CTRL0_USB2_FIXED	BIT(23) /* 1 - USB2 permanent attached */
+
+#define USB_CTRL1_OC_POLARITY	BIT(16) /* 0 - HIGH / 1 - LOW */
+#define USB_CTRL1_PWR_POLARITY	BIT(17) /* 0 - HIGH / 1 - LOW */
+
 struct dwc3_imx8mp {
 	struct device			*dev;
 	struct platform_device		*dwc3;
 	void __iomem			*glue_base;
+	void __iomem			*glue_base2;
 	struct clk			*hsio_clk;
 	struct clk			*suspend_clk;
 	int				irq;
@@ -49,6 +61,42 @@ struct dwc3_imx8mp {
 	bool				wakeup_pending;
 };
 
+static void imx8mp_configure_glue2(struct dwc3_imx8mp *dwc3_imx)
+{
+	struct device *dev = dwc3_imx->dev;
+	u32 value;
+
+	if (!dwc3_imx->glue_base2)
+		return;
+
+	value = readl(dwc3_imx->glue_base2 + USB_CTRL0);
+
+	if (device_property_read_bool(dev, "fsl,permanently-attached"))
+		value |= (USB_CTRL0_USB2_FIXED | USB_CTRL0_USB3_FIXED);
+	else
+		value &= ~(USB_CTRL0_USB2_FIXED | USB_CTRL0_USB3_FIXED);
+
+	if (device_property_read_bool(dev, "fsl,disable-port-power-control"))
+		value &= ~(USB_CTRL0_PORTPWR_EN);
+	else
+		value |= USB_CTRL0_PORTPWR_EN;
+
+	writel(value, dwc3_imx->glue_base2 + USB_CTRL0);
+
+	value = readl(dwc3_imx->glue_base2 + USB_CTRL1);
+	if (device_property_read_bool(dev, "fsl,over-current-active-low"))
+		value |= USB_CTRL1_OC_POLARITY;
+	else
+		value &= ~USB_CTRL1_OC_POLARITY;
+
+	if (device_property_read_bool(dev, "fsl,power-active-low"))
+		value |= USB_CTRL1_PWR_POLARITY;
+	else
+		value &= ~USB_CTRL1_PWR_POLARITY;
+
+	writel(value, dwc3_imx->glue_base2 + USB_CTRL1);
+}
+
 static void dwc_imx8mp_wakeup_enable(struct dwc3_imx8mp *dwc_imx)
 {
 	struct dwc3	*dwc = platform_get_drvdata(dwc_imx->dwc3);
@@ -166,6 +214,7 @@ static int dwc3_imx8mp_probe(struct platform_device *pdev)
 	struct device_node	*dwc3_np, *node = dev->of_node;
 	struct dwc3_imx8mp	*dwc_imx;
 	int			error, irq;
+	struct resource		*res;
 
 	if (!node) {
 		dev_err(dev, "device node not found\n");
@@ -184,6 +233,15 @@ static int dwc3_imx8mp_probe(struct platform_device *pdev)
 	if (IS_ERR(dwc_imx->glue_base))
 		return PTR_ERR(dwc_imx->glue_base);
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res) {
+		dev_warn(dev, "Base address for glue layer missing. Continuing without, some features are missing though.");
+	} else {
+		dwc_imx->glue_base2 = devm_ioremap_resource(dev, res);
+		if (IS_ERR(dwc_imx->glue_base2))
+			return PTR_ERR(dwc_imx->glue_base2);
+	}
+
 	request_bus_freq(BUS_FREQ_HIGH);
 
 	dwc_imx->hsio_clk = devm_clk_get(dev, "hsio");
@@ -219,6 +277,8 @@ static int dwc3_imx8mp_probe(struct platform_device *pdev)
 	}
 	dwc_imx->irq = irq;
 
+	imx8mp_configure_glue2(dwc_imx);
+
 	error = devm_request_threaded_irq(dev, irq, NULL, dwc3_imx8mp_interrupt,
 					  IRQF_ONESHOT, dev_name(dev), dwc_imx);
 	if (error) {
@@ -312,6 +372,9 @@ static int dwc3_imx8mp_resume(struct dwc3_imx8mp *dwc_imx, pm_message_t msg)
 	dwc_imx8mp_wakeup_disable(dwc_imx);
 	dwc_imx->pm_suspended = false;
 
+	/* Upon power loss any previous configuration is lost, restore it */
+	imx8mp_configure_glue2(dwc_imx);
+
 	if (dwc_imx->wakeup_pending) {
 		dwc_imx->wakeup_pending = false;
 		if (dwc && dwc->current_dr_role == DWC3_GCTL_PRTCAP_DEVICE) {
diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c
index f7a6ac05a..c3fa598f1 100644
--- a/drivers/usb/serial/option.c
+++ b/drivers/usb/serial/option.c
@@ -247,9 +247,17 @@ static void option_instat_callback(struct urb *urb);
 #define QUECTEL_PRODUCT_EC25			0x0125
 #define QUECTEL_PRODUCT_EG95			0x0195
 #define QUECTEL_PRODUCT_BG96			0x0296
+#define QUECTEL_PRODUCT_EC200S			0x6002
+#define QUECTEL_PRODUCT_EC200T			0x6026
+#define QUECTEL_PRODUCT_EC200A			0x6005
 #define QUECTEL_PRODUCT_EP06			0x0306
 #define QUECTEL_PRODUCT_EM12			0x0512
 #define QUECTEL_PRODUCT_RM500Q			0x0800
+#define QUECTEL_PRODUCT_RM520N			0x0801
+
+#define MEIG_VENDOR_ID					0x2dee
+/* These Meig products use Meig's vendor ID */
+#define MEIG_PRODUCT_SRM821				0x4d52
 
 #define CMOTECH_VENDOR_ID			0x16d8
 #define CMOTECH_PRODUCT_6001			0x6001
@@ -574,6 +582,31 @@ static void option_instat_callback(struct urb *urb);
 
 
 static const struct usb_device_id option_ids[] = {
+#if 1 //Added by Quectel
+	{ USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */
+	{ USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */
+	{ USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20(MDM9215) */
+	{ USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC20(MDM9x07)/EC25/EG25 */
+	{ USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */
+	{ USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */
+	{ USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */
+	{ USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */
+	{ USB_DEVICE(0x2C7C, 0x030B) }, /* Quectel EG065K/EG060K */
+	{ USB_DEVICE(0x2C7C, 0x0512) }, /* Quectel EG12/EP12/EM12/EG16/EG18 */
+	{ USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */
+	{ USB_DEVICE(0x2C7C, 0x0700) }, /* Quectel BG95/BG77/BG600L-M3/BC69 */
+	{ USB_DEVICE(0x2C7C, 0x0435) }, /* Quectel AG35 */
+	{ USB_DEVICE(0x2C7C, 0x0415) }, /* Quectel AG15 */
+	{ USB_DEVICE(0x2C7C, 0x0452) }, /* Quectel AG520 */
+	{ USB_DEVICE(0x2C7C, 0x0455) }, /* Quectel AG550 */
+	{ USB_DEVICE(0x2C7C, 0x0620) }, /* Quectel EG20 */
+	{ USB_DEVICE(0x2C7C, 0x0800) }, /* Quectel RG500/RM500/RG510/RM510 */
+	{ USB_DEVICE(0x2C7C, 0x0801) }, /* Quectel RG520/RM520/SG520 */
+	{ USB_DEVICE(0x2C7C, 0x6026) }, /* Quectel EC200 */
+	{ USB_DEVICE(0x2C7C, 0x6120) }, /* Quectel UC200 */
+	{ USB_DEVICE(0x2C7C, 0x6000) }, /* Quectel EC200/UC200 */
+	{ .match_flags = USB_DEVICE_ID_MATCH_VENDOR, .idVendor = 0x2C7C }, /* Match All Quectel Modules */
+#endif
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
@@ -975,6 +1008,7 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7B) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x06, 0x7C) },
 
+	{ USB_DEVICE_AND_INTERFACE_INFO(0x2c7c, 0x0900, 0xff, 0x00, 0x00) }, //RG500U
 	/* Motorola devices */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x22b8, 0x2a70, 0xff, 0xff, 0xff) },	/* mdm6600 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x22b8, 0x2e0a, 0xff, 0xff, 0xff) },	/* mdm9600 */
@@ -1106,6 +1140,12 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96, 0xff, 0xff, 0xff),
 	  .driver_info = NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_BG96, 0xff, 0, 0) },
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC200S),
+      .driver_info = RSVD(0) },
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC200T),
+      .driver_info = RSVD(0) },
+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC200A),
+      .driver_info = RSVD(0) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0xff, 0xff),
 	  .driver_info = RSVD(1) | RSVD(2) | RSVD(3) | RSVD(4) | NUMEP2 },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EP06, 0xff, 0, 0) },
@@ -1116,6 +1156,13 @@ static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500Q, 0xff, 0, 0) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM500Q, 0xff, 0xff, 0x10),
 	  .driver_info = ZLP },
+	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0xff, 0x30) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0, 0) },
+	{ USB_DEVICE_AND_INTERFACE_INFO(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_RM520N, 0xff, 0xff, 0x10),
+	  .driver_info = ZLP },
+	/* Meig products using Meig vendor ID */
+	{ USB_DEVICE_AND_INTERFACE_INFO(MEIG_VENDOR_ID, MEIG_PRODUCT_SRM821, 0xff, 0x00, 0x00),
+	  .driver_info = RSVD(0) | RSVD(1) | RSVD(6) },
 
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
@@ -2075,6 +2122,9 @@ static struct usb_serial_driver option_1port_device = {
 #ifdef CONFIG_PM
 	.suspend           = usb_wwan_suspend,
 	.resume            = usb_wwan_resume,
+#if 1 //Added by Quectel
+	.reset_resume = usb_wwan_resume,
+#endif
 #endif
 };
 
@@ -2091,6 +2141,35 @@ static int option_probe(struct usb_serial *serial,
 				&serial->interface->cur_altsetting->desc;
 	unsigned long device_flags = id->driver_info;
 
+#if 1 //Added by Quectel
+	//Quectel UC20's interface 4 can be used as USB Network device
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && serial->dev->descriptor.idProduct == cpu_to_le16(0x9003)
+		&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+	//Quectel EC20(MDM9215)'s interface 4 can be used as USB Network device
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)
+		&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+		return -ENODEV;
+
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
+		__u16 idProduct = le16_to_cpu(serial->dev->descriptor.idProduct);
+		struct usb_interface_descriptor *intf = &serial->interface->cur_altsetting->desc;
+
+		if (intf->bInterfaceClass != 0xFF || intf->bInterfaceSubClass == 0x42) {
+			//ECM, RNDIS, NCM, MBIM, ACM, UAC, ADB
+			return -ENODEV;
+		}
+
+		if ((idProduct&0xF000) == 0x0000) {
+			//MDM interface 4 is QMI
+			if (intf->bInterfaceNumber == 4 && intf->bNumEndpoints == 3
+				&& intf->bInterfaceSubClass == 0xFF && intf->bInterfaceProtocol == 0xFF)
+				return -ENODEV;
+		}
+	}
+#endif
+
 	/* Never bind to the CD-Rom emulation interface	*/
 	if (iface_desc->bInterfaceClass == USB_CLASS_MASS_STORAGE)
 		return -ENODEV;
@@ -2110,6 +2189,30 @@ static int option_probe(struct usb_serial *serial,
 	if (device_flags & NUMEP2 && iface_desc->bNumEndpoints != 2)
 		return -ENODEV;
 
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
+ 	//some interfaces can be used as USB Network device (ecm, rndis, mbim)
+ 		if (serial->interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {
+ 			return -ENODEV;
+ 		}
+	 //interface 4 can be used as USB Network device (qmi)
+ 		else if ((serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
+			&& (serial->dev->descriptor.idProduct != cpu_to_le16(0x0900))
+			&& (serial->dev->descriptor.idProduct != cpu_to_le16(QUECTEL_PRODUCT_EC200S))
+			&& (serial->dev->descriptor.idProduct != cpu_to_le16(QUECTEL_PRODUCT_EC200T))
+			&& (serial->dev->descriptor.idProduct != cpu_to_le16(QUECTEL_PRODUCT_EC200A))) {
+			 return -ENODEV;
+ 		}
+ 	}
+#if 0 // may cause EG25 USB disconnecting
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
+		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
+		usb_enable_autosuspend(serial->dev);
+	}
+
+	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
+		device_init_wakeup(&serial->dev->dev, 1); //usb remote wakeup
+	}
+#endif
 	/* Store the device flags so we can use them during attach. */
 	usb_set_serial_data(serial, (void *)device_flags);
 
diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c
index 0f60363c1..8a444b97d 100644
--- a/drivers/usb/serial/qcserial.c
+++ b/drivers/usb/serial/qcserial.c
@@ -63,7 +63,7 @@ static const struct usb_device_id id_table[] = {
 	{DEVICE_G1K(0x05c6, 0x9202)},	/* Generic Gobi Modem device */
 	{DEVICE_G1K(0x05c6, 0x9203)},	/* Generic Gobi Modem device */
 	{DEVICE_G1K(0x05c6, 0x9222)},	/* Generic Gobi Modem device */
-	{DEVICE_G1K(0x05c6, 0x9008)},	/* Generic Gobi QDL device */
+	//{DEVICE_G1K(0x05c6, 0x9008)},	/* Generic Gobi QDL device */
 	{DEVICE_G1K(0x05c6, 0x9009)},	/* Generic Gobi Modem device */
 	{DEVICE_G1K(0x05c6, 0x9201)},	/* Generic Gobi QDL device */
 	{DEVICE_G1K(0x05c6, 0x9221)},	/* Generic Gobi QDL device */
diff --git a/drivers/usb/serial/usb_wwan.c b/drivers/usb/serial/usb_wwan.c
index 4b9845807..6356e1abf 100644
--- a/drivers/usb/serial/usb_wwan.c
+++ b/drivers/usb/serial/usb_wwan.c
@@ -476,6 +476,19 @@ static struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,
 			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
 			  buf, len, callback, ctx);
 
+#if 1 //Added by Quectel for Zero Packet
+	if (dir == USB_DIR_OUT) {
+		if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && serial->dev->descriptor.idProduct == cpu_to_le16(0x9090))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && serial->dev->descriptor.idProduct == cpu_to_le16(0x9003))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && serial->dev->descriptor.idProduct == cpu_to_le16(0x9215))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+		if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C))
+			urb->transfer_flags |= URB_ZERO_PACKET;
+	}
+#endif
+
 	if (intfdata->use_zlp && dir == USB_DIR_OUT)
 		urb->transfer_flags |= URB_ZERO_PACKET;
 
diff --git a/include/linux/platform_data/mmc-esdhc-imx.h b/include/linux/platform_data/mmc-esdhc-imx.h
index 0434f68ed..48543abff 100644
--- a/include/linux/platform_data/mmc-esdhc-imx.h
+++ b/include/linux/platform_data/mmc-esdhc-imx.h
@@ -38,5 +38,6 @@ struct esdhc_platform_data {
 	unsigned int tuning_step;       /* The delay cell steps in tuning procedure */
 	unsigned int tuning_start_tap;	/* The start delay cell point in tuning procedure */
 	unsigned int strobe_dll_delay_target;	/* The delay cell for strobe pad (read clock) */
+	bool sdio_interrupt_enabled;
 };
 #endif /* __ASM_ARCH_IMX_ESDHC_H */
diff --git a/net/bluetooth/hci_request.c b/net/bluetooth/hci_request.c
index 7800b1458..e25e103b7 100644
--- a/net/bluetooth/hci_request.c
+++ b/net/bluetooth/hci_request.c
@@ -1227,7 +1227,7 @@ void __hci_req_update_scan_rsp_data(struct hci_request *req, u8 instance)
 		memcpy(hdev->scan_rsp_data, cp.data, sizeof(cp.data));
 		hdev->scan_rsp_data_len = len;
 
-		cp.handle = 0;
+		cp.handle = instance;
 		cp.length = len;
 		cp.operation = LE_SET_ADV_DATA_OP_COMPLETE;
 		cp.frag_pref = LE_SET_ADV_DATA_NO_FRAG;
@@ -1371,7 +1371,7 @@ void __hci_req_update_adv_data(struct hci_request *req, u8 instance)
 		hdev->adv_data_len = len;
 
 		cp.length = len;
-		cp.handle = 0;
+		cp.handle = instance;
 		cp.operation = LE_SET_ADV_DATA_OP_COMPLETE;
 		cp.frag_pref = LE_SET_ADV_DATA_NO_FRAG;
 
@@ -1656,7 +1656,7 @@ int __hci_req_setup_ext_adv_instance(struct hci_request *req, u8 instance)
 
 		memset(&cp, 0, sizeof(cp));
 
-		cp.handle = 0;
+		cp.handle = instance;
 		bacpy(&cp.bdaddr, &random_addr);
 
 		hci_req_add(req,
diff --git a/net/ipv4/esp4_offload.c b/net/ipv4/esp4_offload.c
index 25c8ba673..4692d9710 100644
--- a/net/ipv4/esp4_offload.c
+++ b/net/ipv4/esp4_offload.c
@@ -242,6 +242,9 @@ static int esp_xmit(struct xfrm_state *x, struct sk_buff *skb,  netdev_features_
 	esp.plen = esp.clen - skb->len - esp.tfclen;
 	esp.tailen = esp.tfclen + esp.plen + alen;
 
+        if(pskb_expand_head(skb,0,esp.tailen+128,GFP_ATOMIC))
+                return -ENOMEM;
+
 	esp.esph = ip_esp_hdr(skb);
 
 
diff --git a/net/wireless/Kconfig b/net/wireless/Kconfig
index 211007c09..41a056e99 100644
--- a/net/wireless/Kconfig
+++ b/net/wireless/Kconfig
@@ -1,6 +1,7 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config WIRELESS_EXT
-	bool
+	def_bool y
+	depends on CFG80211_WEXT 
 
 config WEXT_CORE
 	def_bool y
@@ -12,10 +13,12 @@ config WEXT_PROC
 	depends on WEXT_CORE
 
 config WEXT_SPY
-	bool
+	def_bool y
+	depends on CFG80211_WEXT || WIRELESS_EXT
 
 config WEXT_PRIV
-	bool
+	def_bool y
+	depends on CFG80211_WEXT || WIRELESS_EXT
 
 config CFG80211
 	tristate "cfg80211 - wireless configuration API"
diff --git a/scripts/Makefile.dtbinst b/scripts/Makefile.dtbinst
index 7301ab5e2..ceca947e0 100644
--- a/scripts/Makefile.dtbinst
+++ b/scripts/Makefile.dtbinst
@@ -20,6 +20,7 @@ include scripts/Kbuild.include
 include $(src)/Makefile
 
 dtbinst-files	:= $(sort $(dtb-y) $(if $(CONFIG_OF_ALL_DTBS), $(dtb-)))
+dtboinst-files	:= $(sort $(dtbo-y) $(if $(CONFIG_OF_ALL_DTBS), $(dtbo-)))
 dtbinst-dirs	:= $(subdir-y) $(subdir-m)
 
 # Helper targets for Installing DTBs into the boot directory
@@ -31,10 +32,13 @@ install-dir = $(patsubst $(dtbinst_root)%,$(INSTALL_DTBS_PATH)%,$(obj))
 $(dtbinst-files): %.dtb: $(obj)/%.dtb
 	$(call cmd,dtb_install,$(install-dir))
 
+$(dtboinst-files): %.dtbo: $(obj)/%.dtbo
+	$(call cmd,dtb_install,$(install-dir))
+
 $(dtbinst-dirs):
 	$(Q)$(MAKE) $(dtbinst)=$(obj)/$@
 
 PHONY += $(dtbinst-files) $(dtbinst-dirs)
-__dtbs_install: $(dtbinst-files) $(dtbinst-dirs)
+__dtbs_install: $(dtbinst-files) $(dtbinst-dirs) $(dtboinst-files)
 
 .PHONY: $(PHONY)
diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index a6d004432..789f15380 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -299,6 +299,18 @@ endef
 $(obj)/%.dt.yaml: $(src)/%.dts $(DTC) $(DT_TMP_SCHEMA) FORCE
 	$(call if_changed_rule,dtc,yaml)
 
+quiet_cmd_dtco = DTCO    $@
+cmd_dtco = mkdir -p $(dir ${dtc-tmp}) ; \
+	$(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
+	$(DTC) -@ -H epapr -O dtb -o $@ -b 0 \
+		-i $(dir $<) $(DTC_FLAGS) \
+		-Wno-interrupts_property \
+		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
+		cat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)
+
+$(obj)/%.dtbo: $(src)/%-overlay.dts FORCE
+	$(call if_changed_dep,dtco)
+
 dtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)
 
 # Bzip2
-- 
2.30.2

